/*!
 * 
 *     ol-mapbox-style
 *     Copyright 2016-present Boundless Spatial
 *     CopyrightÂ© 2000-2018 SuperMap Software Co. Ltd
 *     github: https://github.com/boundlessgeo/ol-mapbox-style
 *     github: https://github.com/SuperMap/ol-mapbox-style
 *     license: BSD 2-Clause "Simplified" License
 *     version: v2.11.2-1
 * 
 */
olms =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./olms.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                                              ol-mapbox-style - Use Mapbox Style objects with OpenLayers
                                                                                                                                                                                                                                                                              Copyright 2016-present Boundless Spatial, Inc.
                                                                                                                                                                                                                                                                              License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE
                                                                                                                                                                                                                                                                              */

exports.applyStyle = applyStyle;
exports.applyBackground = applyBackground;
exports.apply = apply;
exports.getLayer = getLayer;
exports.getSource = getSource;

var _mapboxGlStyleSpec = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec */ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js");

var _mapboxToCssFont = __webpack_require__(/*! mapbox-to-css-font */ "./node_modules/mapbox-to-css-font/index.js");

var _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);

var _stylefunction = __webpack_require__(/*! ./stylefunction */ "./stylefunction.js");

var _stylefunction2 = _interopRequireDefault(_stylefunction);

var _google = __webpack_require__(/*! webfont-matcher/lib/fonts/google */ "./node_modules/webfont-matcher/lib/fonts/google.js");

var _google2 = _interopRequireDefault(_google);

var _proj = __webpack_require__(/*! ol/proj */ "ol/proj");

var _tilegrid = __webpack_require__(/*! ol/tilegrid */ "ol/tilegrid");

var _Map = __webpack_require__(/*! ol/Map */ "ol/Map");

var _Map2 = _interopRequireDefault(_Map);

var _GeoJSON = __webpack_require__(/*! ol/format/GeoJSON */ "ol/format/GeoJSON");

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

var _MVT = __webpack_require__(/*! ol/format/MVT */ "ol/format/MVT");

var _MVT2 = _interopRequireDefault(_MVT);

var _Observable = __webpack_require__(/*! ol/Observable */ "ol/Observable");

var _Tile = __webpack_require__(/*! ol/layer/Tile */ "ol/layer/Tile");

var _Tile2 = _interopRequireDefault(_Tile);

var _Vector = __webpack_require__(/*! ol/layer/Vector */ "ol/layer/Vector");

var _Vector2 = _interopRequireDefault(_Vector);

var _VectorTile = __webpack_require__(/*! ol/layer/VectorTile */ "ol/layer/VectorTile");

var _VectorTile2 = _interopRequireDefault(_VectorTile);

var _TileJSON = __webpack_require__(/*! ol/source/TileJSON */ "ol/source/TileJSON");

var _TileJSON2 = _interopRequireDefault(_TileJSON);

var _Vector3 = __webpack_require__(/*! ol/source/Vector */ "ol/source/Vector");

var _Vector4 = _interopRequireDefault(_Vector3);

var _VectorTile3 = __webpack_require__(/*! ol/source/VectorTile */ "ol/source/VectorTile");

var _VectorTile4 = _interopRequireDefault(_VectorTile3);

var _XYZ = __webpack_require__(/*! ol/source/XYZ */ "ol/source/XYZ");

var _XYZ2 = _interopRequireDefault(_XYZ);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var availableFonts;

function loadFont(fonts) {
  var i, ii;
  if (!Array.isArray(fonts)) {
    var stops = fonts.stops;
    if (stops) {
      for (i = 0, ii = stops.length; i < ii; ++i) {
        loadFont(stops[i][1]);
      }
    }
    return;
  }
  var googleFamilies = _google2.default.getNames();
  var families = fonts.map(function (font) {
    return (0, _mapboxToCssFont2.default)(font, 1).split(' 1px ')[1].replace(/"/g, '');
  });
  for (i = 0, ii = families.length; i < ii; ++i) {
    var family = families[i];
    var font = fonts[i];
    if (googleFamilies.indexOf(family) !== -1) {
      if (!availableFonts) {
        availableFonts = [];
      }
      if (availableFonts.indexOf(font) == -1) {
        availableFonts.push(font);
        var fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+');
        if (!document.querySelector('link[href="' + fontUrl + '"]')) {
          var markup = document.createElement('link');
          markup.href = fontUrl;
          markup.rel = 'stylesheet';
          document.getElementsByTagName('head')[0].appendChild(markup);
        }
      }
      break;
    }
  }
}

var defaultFont = ['Open Sans Regular', 'Arial Regular'];

function preprocess(layer) {
  if ('layout' in layer && 'text-field' in layer.layout) {
    loadFont(layer.layout['text-font'] || defaultFont);
  }
}

var spriteRegEx = /^(.*)(\?.*)$/;

function withPath(url, path) {
  if (path && url.indexOf('http') != 0) {
    url = path + url;
  }
  return url;
}

function toSpriteUrl(url, path, extension) {
  url = withPath(url, path);
  var parts = url.match(spriteRegEx);
  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;
}

/**
 * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`
 * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function
 * will render all layers from the `glStyle` object that use the specified
 * `source`, or a subset of layers from the same source. The source needs to be
 * a `"type": "vector"`, `"type": "geojson"` or `"type": "raster"` source.
 *
 * @param {ol.layer.VectorTile} layer OpenLayers layer.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string} source `source` key or an array of layer `id`s from the
 * Mapbox Style object. When a `source` key is provided, all layers for the
 * specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {string} [path=undefined] Path of the style file. Only required when
 * a relative path is used with the `"sprite"` property of the style.
 * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.
 * @return {Promise} Promise which will be resolved when the style can be used
 * for rendering.
 */
function applyStyle(layer, glStyle, source, path, resolutions) {
  return new Promise(function (resolve, reject) {

    if ((typeof glStyle === 'undefined' ? 'undefined' : _typeof(glStyle)) != 'object') {
      glStyle = JSON.parse(glStyle);
    }
    if (glStyle.version != 8) {
      reject(new Error('glStyle version 8 required.'));
    }
    var spriteScale, spriteData, spriteImageUrl;
    if (glStyle.sprite) {
      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;
      var sizeFactor = spriteScale == 0.5 ? '@2x' : '';
      var spriteUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.json');

      fetch(spriteUrl, { credentials: 'same-origin' }).then(function (response) {
        // if the response is ready return the JSON promise
        if (response.status === 200) {
          return response.json();
        } else if (sizeFactor !== '') {
          // return the JSON promise for the low-resolution sprites.
          sizeFactor = '';
          spriteUrl = toSpriteUrl(glStyle.sprite, path, '.json');
          return fetch(spriteUrl, { credentials: 'same-origin' }).then(function (r) {
            return r.json();
          });
        }
      }).then(function (spritesJson) {
        if (spritesJson === undefined) {
          throw 'No sprites found.';
        }
        spriteData = spritesJson;
        spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.png');
        onChange();
      }).catch(function (err) {
        console.error(err);
        reject(new Error('Sprites cannot be loaded from ' + spriteUrl));
      });
    }

    var style;
    function onChange() {
      if (!style && (!glStyle.sprite || spriteData) && (!availableFonts || availableFonts.length > 0)) {
        style = (0, _stylefunction2.default)(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, availableFonts);
        resolve();
      } else if (style) {
        layer.setStyle(style);
      }
    }

    if (layer instanceof _VectorTile2.default || layer instanceof _Vector2.default) {
      try {
        var layers = glStyle.layers;
        for (var i = 0, ii = layers.length; i < ii; ++i) {
          if (typeof source == 'string' && layers[i].source == source || source.indexOf(layers[i].id) >= 0) {
            preprocess(layers[i]);
          }
        }
        onChange();
      } catch (e) {
        setTimeout(function () {
          reject(e);
        }, 0);
      }
    }
  });
}

function setBackground(map, layer) {
  var background = {
    type: layer.type
  };
  function updateStyle() {
    var element = map.getTargetElement();
    if (!element) {
      return;
    }
    var layout = layer.layout || {};
    var paint = layer.paint || {};
    background['paint'] = paint;
    background.id = 'olms-bg-' + paint['background-opacity'] + paint['background-color'];
    var zoom = map.getView().getZoom();
    if (paint['background-color'] !== undefined) {
      var bg = (0, _stylefunction.getValue)(background, 'paint', 'background-color', zoom, {});
      element.style.background = _mapboxGlStyleSpec.Color.parse(bg).toString();
    }
    if (paint['background-opacity'] !== undefined) {
      element.style.opacity = (0, _stylefunction.getValue)(background, 'paint', 'background-opacity', zoom, {});
    }
    if (layout.visibility == 'none') {
      element.style.backgroundColor = '';
      element.style.opacity = '';
    }
  }
  if (map.getTargetElement()) {
    updateStyle();
  }
  map.on(['change:resolution', 'change:target'], updateStyle);
}

/**
 * Applies properties of the Mapbox Style's first `background` layer to the map.
 * @param {ol.Map} map OpenLayers Map.
 * @param {Object} glStyle Mapbox Style object.
 */
function applyBackground(map, glStyle) {
  glStyle.layers.some(function (l) {
    if (l.type == 'background') {
      setBackground(map, l);
      return true;
    }
  });
}

function getSourceIdByRef(layers, ref) {
  var sourceId;
  layers.some(function (layer) {
    if (layer.id == ref) {
      sourceId = layer.source;
      return true;
    }
  });
  return sourceId;
}

function processStyle(glStyle, map, baseUrl, host, path, accessToken) {
  var view = map.getView();
  if ('center' in glStyle && !view.getCenter()) {
    view.setCenter((0, _proj.fromLonLat)(glStyle.center));
  }
  if ('zoom' in glStyle && view.getZoom() === undefined) {
    view.setZoom(glStyle.zoom);
  }
  if (!view.getCenter() || view.getZoom() === undefined) {
    view.fit(view.getProjection().getExtent(), {
      nearest: true,
      size: map.getSize()
    });
  }
  if (glStyle.sprite) {
    if (glStyle.sprite.indexOf('mapbox://') == 0) {
      glStyle.sprite = baseUrl + '/sprite' + accessToken;
    } else if (glStyle.sprite.indexOf('http') != 0) {
      glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;
    }
  }

  var glLayers = glStyle.layers;
  var geoJsonFormat = new _GeoJSON2.default();
  var layerIds = [];

  function finalizeLayer(layer) {
    if (layerIds.length > 0) {
      map.addLayer(layer);
      var setStyle = function setStyle() {
        applyStyle(layer, glStyle, layerIds, path).then(function () {
          layer.setVisible(true);
        }, function (e) {
          /*eslint no-console: ["error", { allow: ["error"] }] */
          console.error(e);
        });
      };
      if (layer.getSource()) {
        setStyle();
      } else {
        layer.once('change:source', setStyle);
      }
    }
  }

  var glLayer, glSource, glSourceId, id, layer, mapid, url;
  for (var i = 0, ii = glLayers.length; i < ii; ++i) {
    glLayer = glLayers[i];
    if (glLayer.type == 'background') {
      setBackground(map, glLayer);
    } else {
      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);
      if (id != glSourceId) {
        finalizeLayer(layer);
        layerIds = [];
        glSource = glStyle.sources[id];
        url = glSource.url;
        var tiles = glSource.tiles;
        if (url) {
          if (url.indexOf('mapbox://') == 0) {
            mapid = url.replace('mapbox://', '');
            tiles = ['a', 'b', 'c', 'd'].map(function (host) {
              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;
            });
          }
        }

        if (glSource.type == 'vector') {
          layer = tiles ? function () {
            var tileGrid = (0, _tilegrid.createXYZ)({
              tileSize: 512,
              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,
              minZoom: glSource.minzoom
            });
            return new _VectorTile2.default({
              declutter: true,
              maxResolution: tileGrid.getMinZoom() > 0 ? tileGrid.getResolution(tileGrid.getMinZoom()) : undefined,
              source: new _VectorTile4.default({
                attributions: glSource.attribution,
                format: new _MVT2.default(),
                tileGrid: tileGrid,
                urls: tiles
              }),
              visible: false,
              zIndex: i
            });
          }() : function () {
            var layer = new _VectorTile2.default({
              declutter: true,
              visible: false,
              zIndex: i
            });
            var tilejson = new _TileJSON2.default({
              url: url
            });
            var key = tilejson.on('change', function () {
              if (tilejson.getState() == 'ready') {
                var tileJSONDoc = tilejson.getTileJSON();
                var tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];
                for (var i = 0, ii = tiles.length; i < ii; ++i) {
                  var tile = tiles[i];
                  if (tile.indexOf('http') != 0) {
                    tiles[i] = glSource.url + tile;
                  }
                }
                var tileGrid = tilejson.getTileGrid();
                layer.setSource(new _VectorTile4.default({
                  attributions: tilejson.getAttributions() || tileJSONDoc.attribution,
                  format: new _MVT2.default(),
                  tileGrid: (0, _tilegrid.createXYZ)({
                    minZoom: tileGrid.getMinZoom(),
                    maxZoom: tileGrid.getMaxZoom(),
                    tileSize: 512
                  }),
                  urls: tiles
                }));
                if (tileGrid.getMinZoom() > 0) {
                  layer.setMaxResolution(tileGrid.getResolution(tileGrid.getMinZoom()));
                }
                (0, _Observable.unByKey)(key);
              }
            });
            return layer;
          }();
        } else if (glSource.type == 'raster') {
          var source;
          if (!glSource.tiles) {
            source = function () {
              return new _TileJSON2.default({
                url: url,
                crossOrigin: 'anonymous'
              });
            }();
          } else {
            source = new _XYZ2.default({
              attributions: glSource.attribution,
              minZoom: glSource.minzoom,
              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,
              tileSize: glSource.tileSize || 512,
              url: url,
              urls: glSource.tiles,
              crossOrigin: 'anonymous'
            });
          }
          source.setTileLoadFunction(function (tile, src) {
            if (src.indexOf('{bbox-epsg-3857}') != -1) {
              var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());
              src = src.replace('{bbox-epsg-3857}', bbox.toString());
            }
            tile.getImage().src = src;
          });
          layer = new _Tile2.default({
            source: source,
            visible: glLayer.layout ? glLayer.layout.visibility !== 'none' : true
          });
        } else if (glSource.type == 'geojson') {
          var data = glSource.data;
          var features, geoJsonUrl;
          if (typeof data == 'string') {
            geoJsonUrl = withPath(data, path);
          } else {
            features = geoJsonFormat.readFeatures(data, { featureProjection: 'EPSG:3857' });
          }
          layer = new _Vector2.default({
            source: new _Vector4.default({
              attributions: glSource.attribution,
              features: features,
              format: geoJsonFormat,
              url: geoJsonUrl
            }),
            visible: false,
            zIndex: i
          });
        }
        glSourceId = id;
      }
      layerIds.push(glLayer.id);
    }
  }
  finalizeLayer(layer);
  map.set('mapbox-style', glStyle);
}

/**
 * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes
 * the map background, the layers, the center and the zoom.
 *
 * The center and zoom will only be set if present in the Mapbox Style document,
 * and if not already set on the OpenLayers map.
 *
 * Layers will be added to the OpenLayers map, without affecting any layers that
 * might already be set on the map.
 *
 * Layers added by `apply()` will have two additional properties:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * The map returned by this function will have an additional `mapbox-style`
 * property which holds the Mapbox Style object.
 *
 * @param {ol.Map|HTMLElement|string} map Either an existing OpenLayers Map
 * instance, or a HTML element, or the id of a HTML element that will be the
 * target of a new OpenLayers Map.
 * @param {string|Object} style JSON style object or style url pointing to a
 * Mapbox Style object. When using Mapbox APIs, the url must contain an access
 * token and look like
 * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.
 * When passed as JSON style object, all OpenLayers layers created by `apply()`
 * will be immediately available, but they may not have a source yet (i.e. when
 * they are defined by a TileJSON url in the Mapbox Style document). When passed
 * as style url, layers will be added to the map when the Mapbox Style document
 * is loaded and parsed.
 * @return {ol.Map} The OpenLayers Map instance that will be populated with the
 * contents described in the Mapbox Style object.
 */
function apply(map, style) {

  var accessToken, baseUrl, host, path;
  accessToken = baseUrl = host = path = '';

  if (!(map instanceof _Map2.default)) {
    map = new _Map2.default({
      target: map
    });
  }

  if (typeof style === 'string') {
    var parts = style.match(spriteRegEx);
    if (parts) {
      baseUrl = parts[1];
      accessToken = parts.length > 2 ? parts[2] : '';
    }

    fetch(style, {
      credentials: 'same-origin'
    }).then(function (response) {
      return response.json();
    }).then(function (glStyle) {
      var a = document.createElement('A');
      a.href = style;
      path = a.pathname.split('/').slice(0, -1).join('/') + '/';
      host = style.substr(0, style.indexOf(path));

      processStyle(glStyle, map, baseUrl, host, path, accessToken);
    }).catch(function (err) {
      console.error(err);
      throw new Error('Could not load ' + style);
    });
  } else {
    setTimeout(function () {
      processStyle(style, map);
    }, 0);
  }
  return map;
}

/**
 * Get the OpenLayers layer instance that contains the provided Mapbox Style
 * `layer`. Note that multiple Mapbox Style layers are combined in a single
 * OpenLayers layer instance when they use the same Mapbox Style `source`.
 * @param {ol.Map} map OpenLayers Map.
 * @param {string} layerId Mapbox Style layer id.
 * @return {ol.layer.Layer} layer OpenLayers layer instance.
 */
function getLayer(map, layerId) {
  var layers = map.getLayers().getArray();
  for (var i = 0, ii = layers.length; i < ii; ++i) {
    if (layers[i].get('mapbox-layers').indexOf(layerId) !== -1) {
      return layers[i];
    }
  }
}

/**
 * Get the OpenLayers source instance for the provided Mapbox Style `source`.
 * @param {ol.Map} map OpenLayers Map.
 * @param {string} sourceId Mapbox Style source id.
 * @return {ol.layer.Layer} layer OpenLayers layer instance.
 */
function getSource(map, sourceId) {
  var layers = map.getLayers().getArray();
  for (var i = 0, ii = layers.length; i < ii; ++i) {
    var source = layers[i].getSource();
    if (layers[i].get('mapbox-source').indexOf(sourceId) !== -1) {
      return source;
    }
  }
}

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var $version = 8;
var $root = {
    version: {
        required: true,
        type: "enum",
        values: [8],
        doc: "Style specification version number. Must be 8.",
        example: 8
    },
    name: {
        type: "string",
        doc: "A human-readable name for the style.",
        example: "Bright"
    },
    metadata: {
        type: "*",
        doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    center: {
        type: "array",
        value: "number",
        doc: "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: [-73.9749, 40.7736]
    },
    zoom: {
        type: "number",
        doc: "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 12.5
    },
    bearing: {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Default bearing, in degrees. The bearing is the compass direction that is \"up\"; for example, a bearing of 90Â° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 29
    },
    pitch: {
        type: "number",
        "default": 0,
        units: "degrees",
        doc: "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 50
    },
    light: {
        type: "light",
        doc: "The global light source.",
        example: {
            anchor: "viewport",
            color: "white",
            intensity: 0.4
        }
    },
    sources: {
        required: true,
        type: "sources",
        doc: "Data source specifications.",
        example: {
            "mapbox-streets": {
                type: "vector",
                url: "mapbox://mapbox.mapbox-streets-v6"
            }
        }
    },
    sprite: {
        type: "string",
        doc: "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
        example: "mapbox://sprites/mapbox/bright-v8"
    },
    glyphs: {
        type: "string",
        doc: "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
        example: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
    },
    transition: {
        type: "transition",
        doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.",
        example: {
            duration: 300,
            delay: 0
        }
    },
    layers: {
        required: true,
        type: "array",
        value: "layer",
        doc: "Layers will be drawn in the order of this array.",
        example: [{
            id: "water",
            source: "mapbox-streets",
            "source-layer": "water",
            type: "fill",
            paint: {
                "fill-color": "#00ffff"
            }
        }]
    }
};
var sources = {
    "*": {
        type: "source",
        doc: "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."
    }
};
var source = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];
var source_vector = {
    type: {
        required: true,
        type: "enum",
        values: {
            vector: {
                doc: "A vector tile source."
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    scheme: {
        type: "enum",
        values: {
            xyz: {
                doc: "Slippy map tilenames scheme."
            },
            tms: {
                doc: "OSGeo spec scheme."
            }
        },
        "default": "xyz",
        doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    promoteId: {
        type: "promoteId",
        doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers."
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_raster = {
    type: {
        required: true,
        type: "enum",
        values: {
            raster: {
                doc: "A raster tile source."
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    tileSize: {
        type: "number",
        "default": 512,
        units: "pixels",
        doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    scheme: {
        type: "enum",
        values: {
            xyz: {
                doc: "Slippy map tilenames scheme."
            },
            tms: {
                doc: "OSGeo spec scheme."
            }
        },
        "default": "xyz",
        doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_raster_dem = {
    type: {
        required: true,
        type: "enum",
        values: {
            "raster-dem": {
                doc: "A RGB-encoded raster DEM source"
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    tileSize: {
        type: "number",
        "default": 512,
        units: "pixels",
        doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    encoding: {
        type: "enum",
        values: {
            terrarium: {
                doc: "Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info."
            },
            mapbox: {
                doc: "Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info."
            }
        },
        "default": "mapbox",
        doc: "The encoding used by this source. Mapbox Terrain RGB is used by default"
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_geojson = {
    type: {
        required: true,
        type: "enum",
        values: {
            geojson: {
                doc: "A GeoJSON data source."
            }
        },
        doc: "The data type of the GeoJSON source."
    },
    data: {
        type: "*",
        doc: "A URL to a GeoJSON file, or inline GeoJSON."
    },
    maxzoom: {
        type: "number",
        "default": 18,
        doc: "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    buffer: {
        type: "number",
        "default": 128,
        maximum: 512,
        minimum: 0,
        doc: "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."
    },
    tolerance: {
        type: "number",
        "default": 0.375,
        doc: "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
    },
    cluster: {
        type: "boolean",
        "default": false,
        doc: "If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\n * `cluster` Is `true` if the point is a cluster \n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\n * `point_count` Number of original points grouped into this cluster\n * `point_count_abbreviated` An abbreviated point count"
    },
    clusterRadius: {
        type: "number",
        "default": 50,
        minimum: 0,
        doc: "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."
    },
    clusterMaxZoom: {
        type: "number",
        doc: "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered)."
    },
    clusterProperties: {
        type: "*",
        doc: "An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{\"property_name\": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `\"+\"` or `\"max\"`) â it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\n\nExample: `{\"sum\": [\"+\", [\"get\", \"scalerank\"]]}`.\n\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `[\"accumulated\"]` value, e.g.:\n`{\"sum\": [[\"+\", [\"accumulated\"], [\"get\", \"sum\"]], [\"get\", \"scalerank\"]]}`"
    },
    lineMetrics: {
        type: "boolean",
        "default": false,
        doc: "Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values."
    },
    generateId: {
        type: "boolean",
        "default": false,
        doc: "Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values."
    },
    promoteId: {
        type: "promoteId",
        doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`."
    }
};
var source_video = {
    type: {
        required: true,
        type: "enum",
        values: {
            video: {
                doc: "A video data source."
            }
        },
        doc: "The data type of the video source."
    },
    urls: {
        required: true,
        type: "array",
        value: "string",
        doc: "URLs to video content in order of preferred format."
    },
    coordinates: {
        required: true,
        doc: "Corners of video specified in longitude, latitude pairs.",
        type: "array",
        length: 4,
        value: {
            type: "array",
            length: 2,
            value: "number",
            doc: "A single longitude, latitude pair."
        }
    }
};
var source_image = {
    type: {
        required: true,
        type: "enum",
        values: {
            image: {
                doc: "An image data source."
            }
        },
        doc: "The data type of the image source."
    },
    url: {
        required: true,
        type: "string",
        doc: "URL that points to an image."
    },
    coordinates: {
        required: true,
        doc: "Corners of image specified in longitude, latitude pairs.",
        type: "array",
        length: 4,
        value: {
            type: "array",
            length: 2,
            value: "number",
            doc: "A single longitude, latitude pair."
        }
    }
};
var layer = {
    id: {
        type: "string",
        doc: "Unique layer name.",
        required: true
    },
    type: {
        type: "enum",
        values: {
            fill: {
                doc: "A filled polygon with an optional stroked border.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            line: {
                doc: "A stroked line.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            symbol: {
                doc: "An icon or a text label.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            circle: {
                doc: "A filled circle.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            heatmap: {
                doc: "A heatmap.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.41.0",
                        android: "6.0.0",
                        ios: "4.0.0",
                        macos: "0.7.0"
                    }
                }
            },
            "fill-extrusion": {
                doc: "An extruded (3D) polygon.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.27.0",
                        android: "5.1.0",
                        ios: "3.6.0",
                        macos: "0.5.0"
                    }
                }
            },
            raster: {
                doc: "Raster map textures such as satellite imagery.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            hillshade: {
                doc: "Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.43.0",
                        android: "6.0.0",
                        ios: "4.0.0",
                        macos: "0.7.0"
                    }
                }
            },
            background: {
                doc: "The background color or pattern of the map.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            }
        },
        doc: "Rendering type of this layer.",
        required: true
    },
    metadata: {
        type: "*",
        doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    source: {
        type: "string",
        doc: "Name of a source description to be used for this layer. Required for all layer types except `background`."
    },
    "source-layer": {
        type: "string",
        doc: "Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources."
    },
    minzoom: {
        type: "number",
        minimum: 0,
        maximum: 24,
        doc: "The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden."
    },
    maxzoom: {
        type: "number",
        minimum: 0,
        maximum: 24,
        doc: "The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden."
    },
    filter: {
        type: "filter",
        doc: "A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `feature-state` expression is not supported in filter expressions."
    },
    layout: {
        type: "layout",
        doc: "Layout properties for the layer."
    },
    paint: {
        type: "paint",
        doc: "Default paint properties for this layer."
    }
};
var layout = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"];
var layout_background = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_fill = {
    "fill-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0"
            },
            "data-driven styling": {
                js: "1.2.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_circle = {
    "circle-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0"
            },
            "data-driven styling": {
                js: "1.2.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_heatmap = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_line = {
    "line-cap": {
        type: "enum",
        values: {
            butt: {
                doc: "A cap with a squared-off end which is drawn to the exact endpoint of the line."
            },
            round: {
                doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
            },
            square: {
                doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
            }
        },
        "default": "butt",
        doc: "The display of line endings.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-join": {
        type: "enum",
        values: {
            bevel: {
                doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
            },
            round: {
                doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
            },
            miter: {
                doc: "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."
            }
        },
        "default": "miter",
        doc: "The display of lines when joining.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "line-miter-limit": {
        type: "number",
        "default": 2,
        doc: "Used to automatically convert miter joins to bevel joins for sharp angles.",
        requires: [{
            "line-join": "miter"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-round-limit": {
        type: "number",
        "default": 1.05,
        doc: "Used to automatically convert round joins to miter joins for shallow angles.",
        requires: [{
            "line-join": "round"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0"
            },
            "data-driven styling": {
                js: "1.2.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_symbol = {
    "symbol-placement": {
        type: "enum",
        values: {
            point: {
                doc: "The label is placed at the point where the geometry is located."
            },
            line: {
                doc: "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."
            },
            "line-center": {
                doc: "The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries."
            }
        },
        "default": "point",
        doc: "Label placement relative to its geometry.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`line-center` value": {
                js: "0.47.0",
                android: "6.4.0",
                ios: "4.3.0",
                macos: "0.10.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-spacing": {
        type: "number",
        "default": 250,
        minimum: 1,
        units: "pixels",
        doc: "Distance between two symbol anchors.",
        requires: [{
            "symbol-placement": "line"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-avoid-edges": {
        type: "boolean",
        "default": false,
        doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "0.53.0",
                android: "7.4.0",
                ios: "4.11.0",
                macos: "0.14.0"
            },
            "data-driven styling": {
                js: "0.53.0",
                android: "7.4.0",
                ios: "4.11.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "symbol-z-order": {
        type: "enum",
        values: {
            auto: {
                doc: "If `symbol-sort-key` is set, sort based on that. Otherwise sort symbols by their y-position relative to the viewport."
            },
            "viewport-y": {
                doc: "Symbols will be sorted by their y-position relative to the viewport."
            },
            source: {
                doc: "Symbols will be rendered in the same order as the source data with no sorting applied."
            }
        },
        "default": "auto",
        doc: "Controls the order in which overlapping symbols in the same layer are rendered",
        "sdk-support": {
            "basic functionality": {
                js: "0.49.0",
                android: "6.6.0",
                ios: "4.5.0",
                macos: "0.12.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-allow-overlap": {
        type: "boolean",
        "default": false,
        doc: "If true, the icon will be visible even if it collides with other previously drawn symbols.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-ignore-placement": {
        type: "boolean",
        "default": false,
        doc: "If true, other symbols can be visible even if they collide with the icon.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-optional": {
        type: "boolean",
        "default": false,
        doc: "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
        requires: ["icon-image", "text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-rotation-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line."
            },
            viewport: {
                doc: "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
            },
            auto: {
                doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
            }
        },
        "default": "auto",
        doc: "In combination with `symbol-placement`, determines the rotation behavior of icons.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-size": {
        type: "number",
        "default": 1,
        minimum: 0,
        units: "factor of the original icon size",
        doc: "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-text-fit": {
        type: "enum",
        values: {
            none: {
                doc: "The icon is displayed at its intrinsic aspect ratio."
            },
            width: {
                doc: "The icon is scaled in the x-dimension to fit the width of the text."
            },
            height: {
                doc: "The icon is scaled in the y-dimension to fit the height of the text."
            },
            both: {
                doc: "The icon is scaled in both x- and y-dimensions."
            }
        },
        "default": "none",
        doc: "Scales the icon to fit around the associated text.",
        requires: ["icon-image", "text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-text-fit-padding": {
        type: "array",
        value: "number",
        length: 4,
        "default": [0, 0, 0, 0],
        units: "pixels",
        doc: "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",
        requires: ["icon-image", "text-field", {
            "icon-text-fit": ["both", "width", "height"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-image": {
        type: "resolvedImage",
        doc: "Name of image in sprite to use for drawing an image background.",
        tokens: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Rotates the icon clockwise.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.21.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-padding": {
        type: "number",
        "default": 2,
        minimum: 0,
        units: "pixels",
        doc: "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-keep-upright": {
        type: "boolean",
        "default": false,
        doc: "If true, the icon may be flipped to prevent it from being rendered upside-down.",
        requires: ["icon-image", {
            "icon-rotation-alignment": "map"
        }, {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-offset": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        doc: "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-anchor": {
        type: "enum",
        values: {
            center: {
                doc: "The center of the icon is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the icon is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the icon is placed closest to the anchor."
            },
            top: {
                doc: "The top of the icon is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the icon is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the icon is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the icon is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the icon is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the icon is placed closest to the anchor."
            }
        },
        "default": "center",
        doc: "Part of the icon placed closest to the anchor.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The icon is aligned to the plane of the map."
            },
            viewport: {
                doc: "The icon is aligned to the plane of the viewport."
            },
            auto: {
                doc: "Automatically matches the value of `icon-rotation-alignment`."
            }
        },
        "default": "auto",
        doc: "Orientation of icon when map is pitched.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The text is aligned to the plane of the map."
            },
            viewport: {
                doc: "The text is aligned to the plane of the viewport."
            },
            auto: {
                doc: "Automatically matches the value of `text-rotation-alignment`."
            }
        },
        "default": "auto",
        doc: "Orientation of text when map is pitched.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-rotation-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line."
            },
            viewport: {
                doc: "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
            },
            auto: {
                doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
            }
        },
        "default": "auto",
        doc: "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-field": {
        type: "formatted",
        "default": "",
        tokens: true,
        doc: "Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-font": {
        type: "array",
        value: "string",
        "default": ["Open Sans Regular", "Arial Unicode MS Regular"],
        doc: "Font stack to use for displaying text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-size": {
        type: "number",
        "default": 16,
        minimum: 0,
        units: "pixels",
        doc: "Font size.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-max-width": {
        type: "number",
        "default": 10,
        minimum: 0,
        units: "ems",
        doc: "The maximum line width for text wrapping.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-line-height": {
        type: "number",
        "default": 1.2,
        units: "ems",
        doc: "Text leading value for multi-line text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-letter-spacing": {
        type: "number",
        "default": 0,
        units: "ems",
        doc: "Text tracking amount.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-justify": {
        type: "enum",
        values: {
            auto: {
                doc: "The text is aligned towards the anchor position."
            },
            left: {
                doc: "The text is aligned to the left."
            },
            center: {
                doc: "The text is centered."
            },
            right: {
                doc: "The text is aligned to the right."
            }
        },
        "default": "center",
        doc: "Text justification options.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            },
            auto: {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-radial-offset": {
        type: "number",
        units: "ems",
        "default": 0,
        doc: "Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",
        "sdk-support": {
            "basic functionality": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            },
            "data-driven styling": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        requires: ["text-field"],
        "property-type": "data-driven",
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        }
    },
    "text-variable-anchor": {
        type: "array",
        value: "enum",
        values: {
            center: {
                doc: "The center of the text is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the text is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the text is placed closest to the anchor."
            },
            top: {
                doc: "The top of the text is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the text is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the text is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the text is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the text is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the text is placed closest to the anchor."
            }
        },
        requires: ["text-field", {
            "symbol-placement": ["point"]
        }],
        doc: "To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.",
        "sdk-support": {
            "basic functionality": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-anchor": {
        type: "enum",
        values: {
            center: {
                doc: "The center of the text is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the text is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the text is placed closest to the anchor."
            },
            top: {
                doc: "The top of the text is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the text is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the text is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the text is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the text is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the text is placed closest to the anchor."
            }
        },
        "default": "center",
        doc: "Part of the text placed closest to the anchor.",
        requires: ["text-field", {
            "!": "text-variable-anchor"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-max-angle": {
        type: "number",
        "default": 45,
        units: "degrees",
        doc: "Maximum angle change between adjacent characters.",
        requires: ["text-field", {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-writing-mode": {
        type: "array",
        value: "enum",
        values: {
            horizontal: {
                doc: "If a text's language supports horizontal writing mode, symbols with point placement would be laid out horizontally."
            },
            vertical: {
                doc: "If a text's language supports vertical writing mode, symbols with point placement would be laid out vertically."
            }
        },
        doc: "The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesnât support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. The order of elements in an array define priority order for the placement of an orientation variant.",
        requires: ["text-field", {
            "symbol-placement": ["point"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "1.3.0",
                android: "8.3.0",
                ios: "5.3.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Rotates the text clockwise.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-padding": {
        type: "number",
        "default": 2,
        minimum: 0,
        units: "pixels",
        doc: "Size of the additional area around the text bounding box used for detecting symbol collisions.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-keep-upright": {
        type: "boolean",
        "default": true,
        doc: "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
        requires: ["text-field", {
            "text-rotation-alignment": "map"
        }, {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-transform": {
        type: "enum",
        values: {
            none: {
                doc: "The text is not altered."
            },
            uppercase: {
                doc: "Forces all letters to be displayed in uppercase."
            },
            lowercase: {
                doc: "Forces all letters to be displayed in lowercase."
            }
        },
        "default": "none",
        doc: "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-offset": {
        type: "array",
        doc: "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.",
        value: "number",
        units: "ems",
        length: 2,
        "default": [0, 0],
        requires: ["text-field", {
            "!": "text-radial-offset"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-allow-overlap": {
        type: "boolean",
        "default": false,
        doc: "If true, the text will be visible even if it collides with other previously drawn symbols.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-ignore-placement": {
        type: "boolean",
        "default": false,
        doc: "If true, other symbols can be visible even if they collide with the text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-optional": {
        type: "boolean",
        "default": false,
        doc: "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
        requires: ["text-field", "icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_raster = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_hillshade = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        "property-type": "constant"
    }
};
var filter = {
    type: "array",
    value: "*",
    doc: "A filter selects specific features from a layer."
};
var filter_operator = {
    type: "enum",
    values: {
        "==": {
            doc: "`[\"==\", key, value]` equality: `feature[key] = value`"
        },
        "!=": {
            doc: "`[\"!=\", key, value]` inequality: `feature[key] â  value`"
        },
        ">": {
            doc: "`[\">\", key, value]` greater than: `feature[key] > value`"
        },
        ">=": {
            doc: "`[\">=\", key, value]` greater than or equal: `feature[key] â¥ value`"
        },
        "<": {
            doc: "`[\"<\", key, value]` less than: `feature[key] < value`"
        },
        "<=": {
            doc: "`[\"<=\", key, value]` less than or equal: `feature[key] â¤ value`"
        },
        "in": {
            doc: "`[\"in\", key, v0, ..., vn]` set inclusion: `feature[key] â {v0, ..., vn}`"
        },
        "!in": {
            doc: "`[\"!in\", key, v0, ..., vn]` set exclusion: `feature[key] â {v0, ..., vn}`"
        },
        all: {
            doc: "`[\"all\", f0, ..., fn]` logical `AND`: `f0 â§ ... â§ fn`"
        },
        any: {
            doc: "`[\"any\", f0, ..., fn]` logical `OR`: `f0 â¨ ... â¨ fn`"
        },
        none: {
            doc: "`[\"none\", f0, ..., fn]` logical `NOR`: `Â¬f0 â§ ... â§ Â¬fn`"
        },
        has: {
            doc: "`[\"has\", key]` `feature[key]` exists"
        },
        "!has": {
            doc: "`[\"!has\", key]` `feature[key]` does not exist"
        }
    },
    doc: "The filter operator."
};
var geometry_type = {
    type: "enum",
    values: {
        Point: {
            doc: "Filter to point geometries."
        },
        LineString: {
            doc: "Filter to line geometries."
        },
        Polygon: {
            doc: "Filter to polygon geometries."
        }
    },
    doc: "The geometry type for the filter to select."
};
var function_stop = {
    type: "array",
    minimum: 0,
    maximum: 24,
    value: ["number", "color"],
    length: 2,
    doc: "Zoom level and value pair."
};
var expression = {
    type: "array",
    value: "*",
    minimum: 1,
    doc: "An expression defines a function that can be used for data-driven style properties or feature filters."
};
var expression_name = {
    doc: "",
    type: "enum",
    values: {
        "let": {
            doc: "Binds expressions to named variables, which can then be referenced in the result expression using [\"var\", \"variable_name\"].",
            group: "Variable binding",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "var": {
            doc: "References variable bound using \"let\".",
            group: "Variable binding",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        literal: {
            doc: "Provides a literal array or object value.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        array: {
            doc: "Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        at: {
            doc: "Retrieves an item from an array.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "in": {
            doc: "Determines whether an item exists in an array or a substring exists in a string.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "1.6.0"
                }
            }
        },
        "index-of": {
            doc: "Returns the first index at which a given element can be found in an array, or for a string, the first occurrence of the specified value. If a second argument is provided, then the search is started from that position. Returns -1 if the value is not found.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "1.10.0"
                }
            }
        },
        "case": {
            doc: "Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        match: {
            doc: "Selects the output whose label value matches the input value, or the fallback value if no match is found. The input can be any expression (e.g. `[\"get\", \"building_type\"]`). Each label must be either:\n * a single literal value; or\n * an array of literal values, whose values must be all strings or all numbers (e.g. `[100, 101]` or `[\"c\", \"b\"]`). The input matches if any of the values in the array matches, similar to the `\"in\"` operator.\n\nEach label must be unique. If the input type does not match the type of the labels, the result will be the fallback value.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        coalesce: {
            doc: "Evaluates each expression in turn until the first non-null value is obtained, and returns that value.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        step: {
            doc: "Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        interpolate: {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\n\nInterpolation types:\n- `[\"linear\"]`: interpolates linearly between the pair of stops just less than and just greater than the input.\n- `[\"exponential\", base]`: interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\n- `[\"cubic-bezier\", x1, y1, x2, y2]`: interpolates using the cubic bezier curve defined by the given control points.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "interpolate-hcl": {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.49.0"
                }
            }
        },
        "interpolate-lab": {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.49.0"
                }
            }
        },
        ln2: {
            doc: "Returns mathematical constant ln(2).",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        pi: {
            doc: "Returns the mathematical constant pi.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        e: {
            doc: "Returns the mathematical constant e.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "typeof": {
            doc: "Returns a string describing the type of the given value.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        string: {
            doc: "Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        number: {
            doc: "Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        boolean: {
            doc: "Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        object: {
            doc: "Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        collator: {
            doc: "Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        format: {
            doc: "Returns `formatted` text containing annotations for use in mixed-format `text-field` entries. For a `text-field` entries of a string type, following option object's properties are supported: If set, the `text-font` value overrides the font specified by the root layout properties. If set, the `font-scale` value specifies a scaling factor relative to the `text-size` specified in the root layout properties. If set, the `text-color` value overrides the color specified by the root paint properties for this layer.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "text-font": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "font-scale": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "text-color": {
                    js: "1.3.0",
                    android: "7.3.0",
                    ios: "4.10.0",
                    macos: "0.14.0"
                },
                image: {
                    js: "1.6.0"
                }
            }
        },
        image: {
            doc: "Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "1.4.0",
                    android: "8.6.0",
                    ios: "5.6.0"
                }
            }
        },
        "number-format": {
            doc: "Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.54.0"
                }
            }
        },
        "to-string": {
            doc: "Converts the input value to a string. If the input is `null`, the result is `\"\"`. If the input is a boolean, the result is `\"true\"` or `\"false\"`. If the input is a number, it is converted to a string as specified by the [\"NumberToString\" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `\"rgba(r,g,b,a)\"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-number": {
            doc: "Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the [\"ToNumber Applied to the String Type\" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-boolean": {
            doc: "Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-rgba": {
            doc: "Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-color": {
            doc: "Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        rgb: {
            doc: "Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        rgba: {
            doc: "Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        get: {
            doc: "Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns null if the requested property is missing.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        has: {
            doc: "Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        length: {
            doc: "Gets the length of an array or string.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        properties: {
            doc: "Gets the feature properties object.  Note that in some cases, it may be more efficient to use [\"get\", \"property_name\"] directly.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "feature-state": {
            doc: "Retrieves a property value from the current feature's state. Returns null if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\"feature-state\"] can only be used with paint properties that support data-driven styling.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.46.0"
                }
            }
        },
        "geometry-type": {
            doc: "Gets the feature's geometry type: Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        id: {
            doc: "Gets the feature's id, if it has one.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        zoom: {
            doc: "Gets the current zoom level.  Note that in style layout and paint properties, [\"zoom\"] may only appear as the input to a top-level \"step\" or \"interpolate\" expression.",
            group: "Zoom",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "heatmap-density": {
            doc: "Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",
            group: "Heatmap",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "line-progress": {
            doc: "Gets the progress along a gradient line. Can only be used in the `line-gradient` property.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                }
            }
        },
        accumulated: {
            doc: "Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.53.0"
                }
            }
        },
        "+": {
            doc: "Returns the sum of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "*": {
            doc: "Returns the product of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "-": {
            doc: "For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "/": {
            doc: "Returns the result of floating point division of the first input by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "%": {
            doc: "Returns the remainder after integer division of the first input by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "^": {
            doc: "Returns the result of raising the first input to the power specified by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        sqrt: {
            doc: "Returns the square root of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        log10: {
            doc: "Returns the base-ten logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        ln: {
            doc: "Returns the natural logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        log2: {
            doc: "Returns the base-two logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        sin: {
            doc: "Returns the sine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        cos: {
            doc: "Returns the cosine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        tan: {
            doc: "Returns the tangent of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        asin: {
            doc: "Returns the arcsine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        acos: {
            doc: "Returns the arccosine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        atan: {
            doc: "Returns the arctangent of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        min: {
            doc: "Returns the minimum value of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        max: {
            doc: "Returns the maximum value of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        round: {
            doc: "Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `[\"round\", -1.5]` evaluates to -2.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        abs: {
            doc: "Returns the absolute value of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        ceil: {
            doc: "Returns the smallest integer that is greater than or equal to the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        floor: {
            doc: "Returns the largest integer that is less than or equal to the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "==": {
            doc: "Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "!=": {
            doc: "Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        ">": {
            doc: "Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "<": {
            doc: "Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        ">=": {
            doc: "Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "<=": {
            doc: "Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        all: {
            doc: "Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        any: {
            doc: "Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "!": {
            doc: "Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        within: {
            doc: "Returns `true` if the feature being evaluated is inside the pre-defined geometry boundary, `false` otherwise. The expression has one argument which must be a valid GeoJSON Polygon/Multi-Polygon object. The expression only evaluates on `Point` or `LineString` feature. For `Point` feature, The expression will return false if any point of the feature is on the boundary or outside the boundary. For `LineString` feature, the expression will return false if the line is fully outside the boundary, or the line is partially intersecting the boundary, which means either part of the line is outside of the boundary, or end point of the line lies on the boundary.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "1.9.0"
                }
            }
        },
        "is-supported-script": {
            doc: "Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.6.0"
                }
            }
        },
        upcase: {
            doc: "Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        downcase: {
            doc: "Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        concat: {
            doc: "Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "resolved-locale": {
            doc: "Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        slice: {
            doc: "Returns a portion of a string or an array starting from the provided beginning index. If a second argument is provided, then the return portion will run to, but not include, the end index.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "1.10.0"
                }
            }
        }
    }
};
var light = {
    anchor: {
        type: "enum",
        "default": "viewport",
        values: {
            map: {
                doc: "The position of the light source is aligned to the rotation of the map."
            },
            viewport: {
                doc: "The position of the light source is aligned to the rotation of the viewport."
            }
        },
        "property-type": "data-constant",
        transition: false,
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        doc: "Whether extruded geometries are lit relative to the map or viewport.",
        example: "map",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    position: {
        type: "array",
        "default": [1.15, 210, 30],
        length: 3,
        value: "number",
        "property-type": "data-constant",
        transition: true,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        doc: "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0Â° (0Â° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0Â° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0Â°, directly above, to 180Â°, directly below).",
        example: [1.5, 90, 80],
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    color: {
        type: "color",
        "property-type": "data-constant",
        "default": "#ffffff",
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "Color tint for lighting extruded geometries.",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    intensity: {
        type: "number",
        "property-type": "data-constant",
        "default": 0.5,
        minimum: 0,
        maximum: 1,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    }
};
var paint = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"];
var paint_fill = {
    "fill-antialias": {
        type: "boolean",
        "default": true,
        doc: "Whether or not the fill should be antialiased.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-opacity": {
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        doc: "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.21.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-color": {
        type: "color",
        "default": "#000000",
        doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
        transition: true,
        requires: [{
            "!": "fill-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.19.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-outline-color": {
        type: "color",
        doc: "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
        transition: true,
        requires: [{
            "!": "fill-pattern"
        }, {
            "fill-antialias": true
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.19.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The fill is translated relative to the map."
            },
            viewport: {
                doc: "The fill is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `fill-translate`.",
        "default": "map",
        requires: ["fill-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.49.0",
                android: "6.5.0",
                macos: "0.11.0",
                ios: "4.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "cross-faded-data-driven"
    }
};
var paint_line = {
    "line-opacity": {
        type: "number",
        doc: "The opacity at which the line will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-color": {
        type: "color",
        doc: "The color with which the line will be drawn.",
        "default": "#000000",
        transition: true,
        requires: [{
            "!": "line-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.23.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The line is translated relative to the map."
            },
            viewport: {
                doc: "The line is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `line-translate`.",
        "default": "map",
        requires: ["line-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-width": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Stroke thickness.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-gap-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        doc: "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
        transition: true,
        units: "pixels",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-offset": {
        type: "number",
        "default": 0,
        doc: "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
        transition: true,
        units: "pixels",
        "sdk-support": {
            "basic functionality": {
                js: "0.12.1",
                android: "3.0.0",
                ios: "3.1.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Blur applied to the line, in pixels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-dasharray": {
        type: "array",
        value: "number",
        doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        minimum: 0,
        transition: true,
        units: "line widths",
        requires: [{
            "!": "line-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "cross-faded"
    },
    "line-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.49.0",
                android: "6.5.0",
                macos: "0.11.0",
                ios: "4.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "cross-faded-data-driven"
    },
    "line-gradient": {
        type: "color",
        doc: "Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `\"lineMetrics\": true`.",
        transition: false,
        requires: [{
            "!": "line-dasharray"
        }, {
            "!": "line-pattern"
        }, {
            source: "geojson",
            has: {
                lineMetrics: true
            }
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.45.0",
                android: "6.5.0",
                ios: "4.4.0",
                macos: "0.11.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: true,
            parameters: ["line-progress"]
        },
        "property-type": "color-ramp"
    }
};
var paint_circle = {
    "circle-radius": {
        type: "number",
        "default": 5,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Circle radius.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.18.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-color": {
        type: "color",
        "default": "#000000",
        doc: "The fill color of the circle.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.18.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-blur": {
        type: "number",
        "default": 0,
        doc: "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.20.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-opacity": {
        type: "number",
        doc: "The opacity at which the circle will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.20.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The circle is translated relative to the map."
            },
            viewport: {
                doc: "The circle is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `circle-translate`.",
        "default": "map",
        requires: ["circle-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-pitch-scale": {
        type: "enum",
        values: {
            map: {
                doc: "Circles are scaled according to their apparent distance to the camera."
            },
            viewport: {
                doc: "Circles are not scaled."
            }
        },
        "default": "map",
        doc: "Controls the scaling behavior of the circle when the map is pitched.",
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The circle is aligned to the plane of the map."
            },
            viewport: {
                doc: "The circle is aligned to the plane of the viewport."
            }
        },
        "default": "viewport",
        doc: "Orientation of circle when map is pitched.",
        "sdk-support": {
            "basic functionality": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-stroke-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-stroke-color": {
        type: "color",
        "default": "#000000",
        doc: "The stroke color of the circle.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-stroke-opacity": {
        type: "number",
        doc: "The opacity of the circle's stroke.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    }
};
var paint_heatmap = {
    "heatmap-radius": {
        type: "number",
        "default": 30,
        minimum: 1,
        transition: true,
        units: "pixels",
        doc: "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "heatmap-weight": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: false,
        doc: "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "heatmap-intensity": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: true,
        doc: "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "heatmap-color": {
        type: "color",
        "default": ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"],
        doc: "Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `[\"heatmap-density\"]` as input.",
        transition: false,
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: true,
            parameters: ["heatmap-density"]
        },
        "property-type": "color-ramp"
    },
    "heatmap-opacity": {
        type: "number",
        doc: "The global opacity at which the heatmap layer will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_symbol = {
    "icon-opacity": {
        doc: "The opacity at which the icon will be drawn.",
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-color": {
        type: "color",
        "default": "#000000",
        transition: true,
        doc: "The color of the icon. This can only be used with sdf icons.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-color": {
        type: "color",
        "default": "rgba(0, 0, 0, 0)",
        transition: true,
        doc: "The color of the icon's halo. Icon halos can only be used with SDF icons.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Distance of halo to the icon outline.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Fade out the halo towards the outside.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "Icons are translated relative to the map."
            },
            viewport: {
                doc: "Icons are translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `icon-translate`.",
        "default": "map",
        requires: ["icon-image", "icon-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-opacity": {
        type: "number",
        doc: "The opacity at which the text will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-color": {
        type: "color",
        doc: "The color with which the text will be drawn.",
        "default": "#000000",
        transition: true,
        overridable: true,
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-color": {
        type: "color",
        "default": "rgba(0, 0, 0, 0)",
        transition: true,
        doc: "The color of the text's halo, which helps it stand out from backgrounds.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "The halo's fadeout distance towards the outside.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The text is translated relative to the map."
            },
            viewport: {
                doc: "The text is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `text-translate`.",
        "default": "map",
        requires: ["text-field", "text-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_raster = {
    "raster-opacity": {
        type: "number",
        doc: "The opacity at which the image will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-hue-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        transition: true,
        units: "degrees",
        doc: "Rotates hues around the color wheel.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-brightness-min": {
        type: "number",
        doc: "Increase or reduce the brightness of the image. The value is the minimum brightness.",
        "default": 0,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-brightness-max": {
        type: "number",
        doc: "Increase or reduce the brightness of the image. The value is the maximum brightness.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-saturation": {
        type: "number",
        doc: "Increase or reduce the saturation of the image.",
        "default": 0,
        minimum: -1,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-contrast": {
        type: "number",
        doc: "Increase or reduce the contrast of the image.",
        "default": 0,
        minimum: -1,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-resampling": {
        type: "enum",
        doc: "The resampling/interpolation method to use for overscaling, also known as texture magnification filter",
        values: {
            linear: {
                doc: "(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled"
            },
            nearest: {
                doc: "Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled"
            }
        },
        "default": "linear",
        "sdk-support": {
            "basic functionality": {
                js: "0.47.0",
                android: "6.3.0",
                ios: "4.2.0",
                macos: "0.9.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-fade-duration": {
        type: "number",
        "default": 300,
        minimum: 0,
        transition: false,
        units: "milliseconds",
        doc: "Fade duration when a new tile is added.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_hillshade = {
    "hillshade-illumination-direction": {
        type: "number",
        "default": 335,
        minimum: 0,
        maximum: 359,
        doc: "The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.",
        transition: false,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-illumination-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The hillshade illumination is relative to the north direction."
            },
            viewport: {
                doc: "The hillshade illumination is relative to the top of the viewport."
            }
        },
        "default": "viewport",
        doc: "Direction of light source when map is rotated.",
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-exaggeration": {
        type: "number",
        doc: "Intensity of the hillshade",
        "default": 0.5,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-shadow-color": {
        type: "color",
        "default": "#000000",
        doc: "The shading color of areas that face away from the light source.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-highlight-color": {
        type: "color",
        "default": "#FFFFFF",
        doc: "The shading color of areas that faces towards the light source.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-accent-color": {
        type: "color",
        "default": "#000000",
        doc: "The shading color used to accentuate rugged terrain like sharp cliffs and gorges.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_background = {
    "background-color": {
        type: "color",
        "default": "#000000",
        doc: "The color with which the background will be drawn.",
        transition: true,
        requires: [{
            "!": "background-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "background-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "cross-faded"
    },
    "background-opacity": {
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        doc: "The opacity at which the background will be drawn.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var transition = {
    duration: {
        type: "number",
        "default": 300,
        minimum: 0,
        units: "milliseconds",
        doc: "Time allotted for transitions to complete."
    },
    delay: {
        type: "number",
        "default": 0,
        minimum: 0,
        units: "milliseconds",
        doc: "Length of time before a transition begins."
    }
};
var promoteId = {
    "*": {
        type: "string",
        doc: "A name of a feature property to use as ID for feature state."
    }
};
var v8 = {
    $version: $version,
    $root: $root,
    sources: sources,
    source: source,
    source_vector: source_vector,
    source_raster: source_raster,
    source_raster_dem: source_raster_dem,
    source_geojson: source_geojson,
    source_video: source_video,
    source_image: source_image,
    layer: layer,
    layout: layout,
    layout_background: layout_background,
    layout_fill: layout_fill,
    layout_circle: layout_circle,
    layout_heatmap: layout_heatmap,
    "layout_fill-extrusion": {
        visibility: {
            type: "enum",
            values: {
                visible: {
                    doc: "The layer is shown."
                },
                none: {
                    doc: "The layer is not shown."
                }
            },
            "default": "visible",
            doc: "Whether this layer is displayed.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            "property-type": "constant"
        }
    },
    layout_line: layout_line,
    layout_symbol: layout_symbol,
    layout_raster: layout_raster,
    layout_hillshade: layout_hillshade,
    filter: filter,
    filter_operator: filter_operator,
    geometry_type: geometry_type,
    "function": {
        expression: {
            type: "expression",
            doc: "An expression."
        },
        stops: {
            type: "array",
            doc: "An array of stops.",
            value: "function_stop"
        },
        base: {
            type: "number",
            "default": 1,
            minimum: 0,
            doc: "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
        },
        property: {
            type: "string",
            doc: "The name of a feature property to use as the function input.",
            "default": "$zoom"
        },
        type: {
            type: "enum",
            values: {
                identity: {
                    doc: "Return the input value as the output value."
                },
                exponential: {
                    doc: "Generate an output by interpolating between stops just less than and just greater than the function input."
                },
                interval: {
                    doc: "Return the output value of the stop just less than the function input."
                },
                categorical: {
                    doc: "Return the output value of the stop equal to the function input."
                }
            },
            doc: "The interpolation strategy to use in function evaluation.",
            "default": "exponential"
        },
        colorSpace: {
            type: "enum",
            values: {
                rgb: {
                    doc: "Use the RGB color space to interpolate color values"
                },
                lab: {
                    doc: "Use the LAB color space to interpolate color values."
                },
                hcl: {
                    doc: "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."
                }
            },
            doc: "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",
            "default": "rgb"
        },
        "default": {
            type: "*",
            required: false,
            doc: "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances."
        }
    },
    function_stop: function_stop,
    expression: expression,
    expression_name: expression_name,
    light: light,
    paint: paint,
    paint_fill: paint_fill,
    "paint_fill-extrusion": {
        "fill-extrusion-opacity": {
            type: "number",
            "default": 1,
            minimum: 0,
            maximum: 1,
            doc: "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",
            transition: true,
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-color": {
            type: "color",
            "default": "#000000",
            doc: "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",
            transition: true,
            requires: [{
                "!": "fill-extrusion-pattern"
            }],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-translate": {
            type: "array",
            value: "number",
            length: 2,
            "default": [0, 0],
            transition: true,
            units: "pixels",
            doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-translate-anchor": {
            type: "enum",
            values: {
                map: {
                    doc: "The fill extrusion is translated relative to the map."
                },
                viewport: {
                    doc: "The fill extrusion is translated relative to the viewport."
                }
            },
            doc: "Controls the frame of reference for `fill-extrusion-translate`.",
            "default": "map",
            requires: ["fill-extrusion-translate"],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-pattern": {
            type: "resolvedImage",
            transition: true,
            doc: "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.49.0",
                    android: "6.5.0",
                    macos: "0.11.0",
                    ios: "4.4.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom", "feature"]
            },
            "property-type": "cross-faded-data-driven"
        },
        "fill-extrusion-height": {
            type: "number",
            "default": 0,
            minimum: 0,
            units: "meters",
            doc: "The height with which to extrude this layer.",
            transition: true,
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-base": {
            type: "number",
            "default": 0,
            minimum: 0,
            units: "meters",
            doc: "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",
            transition: true,
            requires: ["fill-extrusion-height"],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-vertical-gradient": {
            type: "boolean",
            "default": true,
            doc: "Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.",
            transition: false,
            "sdk-support": {
                "basic functionality": {
                    js: "0.50.0",
                    ios: "4.7.0",
                    macos: "0.13.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        }
    },
    paint_line: paint_line,
    paint_circle: paint_circle,
    paint_heatmap: paint_heatmap,
    paint_symbol: paint_symbol,
    paint_raster: paint_raster,
    paint_hillshade: paint_hillshade,
    paint_background: paint_background,
    transition: transition,
    "property-type": {
        "data-driven": {
            type: "property-type",
            doc: "Property is interpolable and can be represented using a property expression."
        },
        "cross-faded": {
            type: "property-type",
            doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms."
        },
        "cross-faded-data-driven": {
            type: "property-type",
            doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression."
        },
        "color-ramp": {
            type: "property-type",
            doc: "Property should be specified using a color ramp from which the output color can be sampled based on a property calculation."
        },
        "data-constant": {
            type: "property-type",
            doc: "Property is interpolable but cannot be represented using a property expression."
        },
        constant: {
            type: "property-type",
            doc: "Property is constant across all zoom levels and property values."
        }
    },
    promoteId: promoteId
};

// Note: This regex matches even invalid JSON strings, but since weâre
// working on the output of `JSON.stringify` we know that only valid strings
// are present (unless the user supplied a weird `options.indent` but in
// that case we donât care since the output would be invalid anyway).
var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;

var jsonStringifyPrettyCompact = function stringify(passedObj, options) {
    var indent, maxLength, replacer;

    options = options || {};
    indent = JSON.stringify([1], undefined, options.indent === undefined ? 2 : options.indent).slice(2, -3);
    maxLength = indent === "" ? Infinity : options.maxLength === undefined ? 80 : options.maxLength;
    replacer = options.replacer;

    return function _stringify(obj, currentIndent, reserved) {
        // prettier-ignore
        var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;

        if (obj && typeof obj.toJSON === "function") {
            obj = obj.toJSON();
        }

        string = JSON.stringify(obj, replacer);

        if (string === undefined) {
            return string;
        }

        length = maxLength - currentIndent.length - reserved;

        if (string.length <= length) {
            prettified = string.replace(stringOrChar, function (match, stringLiteral) {
                return stringLiteral || match + " ";
            });
            if (prettified.length <= length) {
                return prettified;
            }
        }

        if (replacer != null) {
            obj = JSON.parse(string);
            replacer = undefined;
        }

        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && obj !== null) {
            nextIndent = currentIndent + indent;
            items = [];
            index = 0;

            if (Array.isArray(obj)) {
                start = "[";
                end = "]";
                length = obj.length;
                for (; index < length; index++) {
                    items.push(_stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || "null");
                }
            } else {
                start = "{";
                end = "}";
                keys = Object.keys(obj);
                length = keys.length;
                for (; index < length; index++) {
                    key = keys[index];
                    keyPart = JSON.stringify(key) + ": ";
                    value = _stringify(obj[key], nextIndent, keyPart.length + (index === length - 1 ? 0 : 1));
                    if (value !== undefined) {
                        items.push(keyPart + value);
                    }
                }
            }

            if (items.length > 0) {
                return [start, indent + items.join(",\n" + nextIndent), end].join("\n" + currentIndent);
            }
        }

        return string;
    }(passedObj, "", 0);
};

function sortKeysBy(obj, reference) {
    var result = {};
    for (var key in reference) {
        if (obj[key] !== undefined) {
            result[key] = obj[key];
        }
    }
    for (var key$1 in obj) {
        if (result[key$1] === undefined) {
            result[key$1] = obj[key$1];
        }
    }
    return result;
}
function format(style, space) {
    if (space === void 0) space = 2;
    style = sortKeysBy(style, v8.$root);
    if (style.layers) {
        style.layers = style.layers.map(function (layer) {
            return sortKeysBy(layer, v8.layer);
        });
    }
    return jsonStringifyPrettyCompact(style, { indent: space });
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire() {
    throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
    return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var punycode = createCommonjsModule(function (module, exports) {
    (function (root) {

        /** Detect free variables */
        var freeExports = exports && !exports.nodeType && exports;
        var freeModule = module && !module.nodeType && module;
        var freeGlobal = (typeof commonjsGlobal === "undefined" ? "undefined" : _typeof(commonjsGlobal)) == 'object' && commonjsGlobal;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
            root = freeGlobal;
        }

        /**
         * The `punycode` object.
         * @name punycode
         * @type Object
         */
        var punycode,


        /** Highest positive signed 32-bit float value */
        maxInt = 2147483647,
            // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128,
            // 0x80
        delimiter = '-',
            // '\x2D'

        /** Regular expressions */
        regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/,
            // unprintable ASCII chars + non-ASCII chars
        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
            // RFC 3490 separators

        /** Error messages */
        errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
        },


        /** Convenience shortcuts */
        baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,


        /** Temporary variable */
        key;

        /*--------------------------------------------------------------------------*/

        /**
         * A generic error utility function.
         * @private
         * @param {String} type The error type.
         * @returns {Error} Throws a `RangeError` with the applicable error message.
         */
        function error(type) {
            throw RangeError(errors[type]);
        }

        /**
         * A generic `Array#map` utility function.
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function that gets called for every array
         * item.
         * @returns {Array} A new array of values returned by the callback function.
         */
        function map(array, fn) {
            var length = array.length;
            var result = [];
            while (length--) {
                result[length] = fn(array[length]);
            }
            return result;
        }

        /**
         * A simple `Array#map`-like wrapper to work with domain name strings or email
         * addresses.
         * @private
         * @param {String} domain The domain name or email address.
         * @param {Function} callback The function that gets called for every
         * character.
         * @returns {Array} A new string of characters returned by the callback
         * function.
         */
        function mapDomain(string, fn) {
            var parts = string.split('@');
            var result = '';
            if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@';
                string = parts[1];
            }
            // Avoid `split(regex)` for IE8 compatibility. See #17.
            string = string.replace(regexSeparators, '\x2E');
            var labels = string.split('.');
            var encoded = map(labels, fn).join('.');
            return result + encoded;
        }

        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         * @see `punycode.ucs2.encode`
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode.ucs2
         * @name decode
         * @param {String} string The Unicode input string (UCS-2).
         * @returns {Array} The new array of code points.
         */
        function ucs2decode(string) {
            var output = [],
                counter = 0,
                length = string.length,
                value,
                extra;
            while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                    // high surrogate, and there is a next character
                    extra = string.charCodeAt(counter++);
                    if ((extra & 0xFC00) == 0xDC00) {
                        // low surrogate
                        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                    } else {
                        // unmatched surrogate; only append this code unit, in case the next
                        // code unit is the high surrogate of a surrogate pair
                        output.push(value);
                        counter--;
                    }
                } else {
                    output.push(value);
                }
            }
            return output;
        }

        /**
         * Creates a string based on an array of numeric code points.
         * @see `punycode.ucs2.decode`
         * @memberOf punycode.ucs2
         * @name encode
         * @param {Array} codePoints The array of numeric code points.
         * @returns {String} The new Unicode string (UCS-2).
         */
        function ucs2encode(array) {
            return map(array, function (value) {
                var output = '';
                if (value > 0xFFFF) {
                    value -= 0x10000;
                    output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                    value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
            }).join('');
        }

        /**
         * Converts a basic code point into a digit/integer.
         * @see `digitToBasic()`
         * @private
         * @param {Number} codePoint The basic numeric code point value.
         * @returns {Number} The numeric value of a basic code point (for use in
         * representing integers) in the range `0` to `base - 1`, or `base` if
         * the code point does not represent a value.
         */
        function basicToDigit(codePoint) {
            if (codePoint - 48 < 10) {
                return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
                return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
                return codePoint - 97;
            }
            return base;
        }

        /**
         * Converts a digit/integer into a basic code point.
         * @see `basicToDigit()`
         * @private
         * @param {Number} digit The numeric value of a basic code point.
         * @returns {Number} The basic code point whose value (when used for
         * representing integers) is `digit`, which needs to be in the range
         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
         * used; else, the lowercase form is used. The behavior is undefined
         * if `flag` is non-zero and `digit` has no uppercase form.
         */
        function digitToBasic(digit, flag) {
            //  0..25 map to ASCII a..z or A..Z
            // 26..35 map to ASCII 0..9
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }

        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * http://tools.ietf.org/html/rfc3492#section-3.4
         * @private
         */
        function adapt(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }

        /**
         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
         * symbols.
         * @memberOf punycode
         * @param {String} input The Punycode string of ASCII-only symbols.
         * @returns {String} The resulting string of Unicode symbols.
         */
        function decode(input) {
            // Don't use UCS-2
            var output = [],
                inputLength = input.length,
                out,
                i = 0,
                n = initialN,
                bias = initialBias,
                basic,
                j,
                index,
                oldi,
                w,
                k,
                digit,
                t,

            /** Cached calculation results */
            baseMinusT;

            // Handle the basic code points: let `basic` be the number of input code
            // points before the last delimiter, or `0` if there is none, then copy
            // the first basic code points to the output.

            basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
                basic = 0;
            }

            for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                    error('not-basic');
                }
                output.push(input.charCodeAt(j));
            }

            // Main decoding loop: start just after the last delimiter if any basic code
            // points were copied; start at the beginning otherwise.

            for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

                    if (index >= inputLength) {
                        error('invalid-input');
                    }

                    digit = basicToDigit(input.charCodeAt(index++));

                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error('overflow');
                    }

                    i += digit * w;
                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                    if (digit < t) {
                        break;
                    }

                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                        error('overflow');
                    }

                    w *= baseMinusT;
                }

                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);

                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                    error('overflow');
                }

                n += floor(i / out);
                i %= out;

                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n);
            }

            return ucs2encode(output);
        }

        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         * @memberOf punycode
         * @param {String} input The string of Unicode symbols.
         * @returns {String} The resulting Punycode string of ASCII-only symbols.
         */
        function encode(input) {
            var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],

            /** `inputLength` will hold the number of code points in `input`. */
            inputLength,

            /** Cached calculation results */
            handledCPCountPlusOne,
                baseMinusT,
                qMinusT;

            // Convert the input in UCS-2 to Unicode
            input = ucs2decode(input);

            // Cache the length
            inputLength = input.length;

            // Initialize the state
            n = initialN;
            delta = 0;
            bias = initialBias;

            // Handle the basic code points
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue));
                }
            }

            handledCPCount = basicLength = output.length;

            // `handledCPCount` is the number of code points that have been handled;
            // `basicLength` is the number of basic code points.

            // Finish the basic string - if it is not empty - with a delimiter
            if (basicLength) {
                output.push(delimiter);
            }

            // Main encoding loop:
            while (handledCPCount < inputLength) {

                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                    }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error('overflow');
                }

                delta += (m - n) * handledCPCountPlusOne;
                n = m;

                for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];

                    if (currentValue < n && ++delta > maxInt) {
                        error('overflow');
                    }

                    if (currentValue == n) {
                        // Represent delta as a generalized variable-length integer
                        for (q = delta, k = base;; /* no condition */k += base) {
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (q < t) {
                                break;
                            }
                            qMinusT = q - t;
                            baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }

                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }

                ++delta;
                ++n;
            }
            return output.join('');
        }

        /**
         * Converts a Punycode string representing a domain name or an email address
         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
         * it doesn't matter if you call it on a string that has already been
         * converted to Unicode.
         * @memberOf punycode
         * @param {String} input The Punycoded domain name or email address to
         * convert to Unicode.
         * @returns {String} The Unicode representation of the given Punycode
         * string.
         */
        function toUnicode(input) {
            return mapDomain(input, function (string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
        }

        /**
         * Converts a Unicode string representing a domain name or an email address to
         * Punycode. Only the non-ASCII parts of the domain name will be converted,
         * i.e. it doesn't matter if you call it with a domain that's already in
         * ASCII.
         * @memberOf punycode
         * @param {String} input The domain name or email address to convert, as a
         * Unicode string.
         * @returns {String} The Punycode representation of the given domain name or
         * email address.
         */
        function toASCII(input) {
            return mapDomain(input, function (string) {
                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
            });
        }

        /*--------------------------------------------------------------------------*/

        /** Define the public API */
        punycode = {
            /**
             * A string representing the current Punycode.js version number.
             * @memberOf punycode
             * @type String
             */
            'version': '1.3.2',
            /**
             * An object of methods to convert from JavaScript's internal character
             * representation (UCS-2) to Unicode code points, and back.
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode
             * @type Object
             */
            'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
            },
            'decode': decode,
            'encode': encode,
            'toASCII': toASCII,
            'toUnicode': toUnicode
        };

        /** Expose `punycode` */
        // Some AMD build optimizers, like r.js, check for specific condition patterns
        // like the following:
        if (freeExports && freeModule) {
            if (module.exports == freeExports) {
                // in Node.js or RingoJS v0.8.0+
                freeModule.exports = punycode;
            } else {
                // in Narwhal or RingoJS v0.7.0-
                for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
            }
        } else {
            // in Rhino or a web browser
            root.punycode = punycode;
        }
    })(commonjsGlobal);
});

var util = {
    isString: function isString(arg) {
        return typeof arg === 'string';
    },
    isObject: function isObject(arg) {
        return (typeof arg === "undefined" ? "undefined" : _typeof(arg)) === 'object' && arg !== null;
    },
    isNull: function isNull(arg) {
        return arg === null;
    },
    isNullOrUndefined: function isNullOrUndefined(arg) {
        return arg == null;
    }
};

// Copyright Joyent, Inc. and other Node contributors.

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

var decode = function decode(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr,
            vstr,
            k,
            v;

        if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
        } else {
            kstr = x;
            vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
        } else if (Array.isArray(obj[k])) {
            obj[k].push(v);
        } else {
            obj[k] = [obj[k], v];
        }
    }

    return obj;
};

// Copyright Joyent, Inc. and other Node contributors.

var stringifyPrimitive = function stringifyPrimitive(v) {
    switch (typeof v === "undefined" ? "undefined" : _typeof(v)) {
        case 'string':
            return v;

        case 'boolean':
            return v ? 'true' : 'false';

        case 'number':
            return isFinite(v) ? v : '';

        default:
            return '';
    }
};

var encode = function encode(obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
        obj = undefined;
    }

    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === 'object') {
        return Object.keys(obj).map(function (k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (Array.isArray(obj[k])) {
                return obj[k].map(function (v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
            } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
        }).join(sep);
    }

    if (!name) {
        return '';
    }
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var querystring = createCommonjsModule(function (module, exports) {

    exports.decode = exports.parse = decode;
    exports.encode = exports.stringify = encode;
});
var querystring_1 = querystring.decode;
var querystring_2 = querystring.parse;
var querystring_3 = querystring.encode;
var querystring_4 = querystring.stringify;

var parse = urlParse;
var resolve = urlResolve;
var resolveObject = urlResolveObject;
var format$1 = urlFormat;

var Url_1 = Url;

function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
    'javascript': true,
    'javascript:': true
},

// protocols that never have a hostname.
hostlessProtocol = {
    'javascript': true,
    'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
};

function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && util.isObject(url) && url instanceof Url) {
        return url;
    }

    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
    if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === "undefined" ? "undefined" : _typeof(url)));
    }

    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    var queryIndex = url.indexOf('?'),
        splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
        uSplit = url.split(splitter),
        slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, '/');
    url = uSplit.join(splitter);

    var rest = url;

    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();

    if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                    this.query = querystring.parse(this.search.substr(1));
                } else {
                    this.query = this.search.substr(1);
                }
            } else if (parseQueryString) {
                this.search = '';
                this.query = {};
            }
            return this;
        }
    }

    var proto = protocolPattern.exec(rest);
    if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
    }

    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
        }
    }

    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                hostEnd = hec;
            }
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
            // atSign can be anywhere.
            atSign = rest.lastIndexOf('@');
        } else {
            // atSign must be in auth portion.
            // http://a@b/c@d => host:b auth:a path:/c@d
            atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                hostEnd = hec;
            }
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1) {
            hostEnd = rest.length;
        }

        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        this.parseHost();

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part) {
                    continue;
                }
                if (!part.match(hostnamePartPattern)) {
                    var newpart = '';
                    for (var j = 0, k = part.length; j < k; j++) {
                        if (part.charCodeAt(j) > 127) {
                            // we replace non-ASCII char with a temporary placeholder
                            // we need this to make sure size of hostname is not
                            // broken by replacing non-ASCII by nothing
                            newpart += 'x';
                        } else {
                            newpart += part[j];
                        }
                    }
                    // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                        var validParts = hostparts.slice(0, i);
                        var notHost = hostparts.slice(i + 1);
                        var bit = part.match(hostnamePartStart);
                        if (bit) {
                            validParts.push(bit[1]);
                            notHost.unshift(bit[2]);
                        }
                        if (notHost.length) {
                            rest = '/' + notHost.join('.') + rest;
                        }
                        this.hostname = validParts.join('.');
                        break;
                    }
                }
            }
        }

        if (this.hostname.length > hostnameMaxLen) {
            this.hostname = '';
        } else {
            // hostnames are always lower case.
            this.hostname = this.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
            // IDNA Support: Returns a punycoded representation of "domain".
            // It only converts parts of the domain name that
            // have non-ASCII characters, i.e. it doesn't matter if
            // you call it with a domain that already is ASCII-only.
            this.hostname = punycode.toASCII(this.hostname);
        }

        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host;

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== '/') {
                rest = '/' + rest;
            }
        }
    }

    // now rest is set to the post-host stuff.
    // chop off any delim chars.
    if (!unsafeProtocol[lowerProto]) {

        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
            var ae = autoEscape[i];
            if (rest.indexOf(ae) === -1) {
                continue;
            }
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
                esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
        }
    }

    // chop off from the tail first.
    var hash = rest.indexOf('#');
    if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
            this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
    } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
    }
    if (rest) {
        this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = '/';
    }

    //to support http.request
    if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
    }

    // finally, reconstruct the href based on what has been validated.
    this.href = this.format();
    return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
    // ensure it's an object, and not a string url.
    // If it's an obj, this is a no-op.
    // this way, you can call url_format() on strings
    // to clean up potentially wonky urls.
    if (util.isString(obj)) {
        obj = urlParse(obj);
    }
    if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
    }
    return obj.format();
}

Url.prototype.format = function () {
    var auth = this.auth || '';
    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
    }

    var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';

    if (this.host) {
        host = auth + this.host;
    } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
        if (this.port) {
            host += ':' + this.port;
        }
    }

    if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
    }

    var search = this.search || query && '?' + query || '';

    if (protocol && protocol.substr(-1) !== ':') {
        protocol += ':';
    }

    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
    // unless they had them to begin with.
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') {
            pathname = '/' + pathname;
        }
    } else if (!host) {
        host = '';
    }

    if (hash && hash.charAt(0) !== '#') {
        hash = '#' + hash;
    }
    if (search && search.charAt(0) !== '?') {
        search = '?' + search;
    }

    pathname = pathname.replace(/[?#]/g, function (match) {
        return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');

    return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
    if (!source) {
        return relative;
    }
    return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
    if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
    }

    var result = new Url();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
    }

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === '') {
        result.href = result.format();
        return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== 'protocol') {
                result[rkey] = relative[rkey];
            }
        }

        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
    }

    if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
            }
            result.href = result.format();
            return result;
        }

        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || '').split('/');
            while (relPath.length && !(relative.host = relPath.shift())) {}
            if (!relative.host) {
                relative.host = '';
            }
            if (!relative.hostname) {
                relative.hostname = '';
            }
            if (relPath[0] !== '') {
                relPath.unshift('');
            }
            if (relPath.length < 2) {
                relPath.unshift('');
            }
            result.pathname = relPath.join('/');
        } else {
            result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
            var p = result.pathname || '';
            var s = result.search || '';
            result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }

    var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
        isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
        mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
            if (srcPath[0] === '') {
                srcPath[0] = result.host;
            } else {
                srcPath.unshift(result.host);
            }
        }
        result.host = '';
        if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
                if (relPath[0] === '') {
                    relPath[0] = relative.host;
                } else {
                    relPath.unshift(relative.host);
                }
            }
            relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }

    if (isRelAbs) {
        // it's absolute.
        result.host = relative.host || relative.host === '' ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) {
            srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
    } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
    }

    if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
            result.path = '/' + result.search;
        } else {
            result.path = null;
        }
        result.href = result.format();
        return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
            srcPath.splice(i, 1);
        } else if (last === '..') {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
            srcPath.unshift('..');
        }
    }

    if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
    }

    if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
        srcPath.push('');
    }

    var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }

    mustEndAbs = mustEndAbs || result.host && srcPath.length;

    if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
    }

    if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
    } else {
        result.pathname = srcPath.join('/');
    }

    //to support request.http
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
};

Url.prototype.parseHost = function () {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
        port = port[0];
        if (port !== ':') {
            this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
    }
    if (host) {
        this.hostname = host;
    }
};

var url = {
    parse: parse,
    resolve: resolve,
    resolveObject: resolveObject,
    format: format$1,
    Url: Url_1
};

function getPropertyReference(propertyName) {
    for (var i = 0; i < v8.layout.length; i++) {
        for (var key in v8[v8.layout[i]]) {
            if (key === propertyName) {
                return v8[v8.layout[i]][key];
            }
        }
    }
    for (var i$1 = 0; i$1 < v8.paint.length; i$1++) {
        for (var key$1 in v8[v8.paint[i$1]]) {
            if (key$1 === propertyName) {
                return v8[v8.paint[i$1]][key$1];
            }
        }
    }
    return null;
}
function eachSource(style, callback) {
    for (var k in style.sources) {
        callback(style.sources[k]);
    }
}
function eachLayer(style, callback) {
    for (var i = 0, list = style.layers; i < list.length; i += 1) {
        var layer = list[i];
        callback(layer);
    }
}
function eachProperty(style, options, callback) {
    function inner(layer, propertyType) {
        var properties = layer[propertyType];
        if (!properties) {
            return;
        }
        Object.keys(properties).forEach(function (key) {
            callback({
                path: [layer.id, propertyType, key],
                key: key,
                value: properties[key],
                reference: getPropertyReference(key),
                set: function set(x) {
                    properties[key] = x;
                }
            });
        });
    }
    eachLayer(style, function (layer) {
        if (options.paint) {
            inner(layer, 'paint');
        }
        if (options.layout) {
            inner(layer, 'layout');
        }
    });
}

function eachLayout(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('layout') === 0) {
            callback(layer[k], k);
        }
    }
}
function eachPaint(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('paint') === 0) {
            callback(layer[k], k);
        }
    }
}
function resolveConstant(style, value) {
    if (typeof value === 'string' && value[0] === '@') {
        return resolveConstant(style, style.constants[value]);
    } else {
        return value;
    }
}
function isFunction(value) {
    return Array.isArray(value.stops);
}
function renameProperty(obj, from, to) {
    obj[to] = obj[from];
    delete obj[from];
}
function migrateToV8(style) {
    style.version = 8;
    eachSource(style, function (source) {
        if (source.type === 'video' && source.url !== undefined) {
            renameProperty(source, 'url', 'urls');
        }
        if (source.type === 'video') {
            source.coordinates.forEach(function (coord) {
                return coord.reverse();
            });
        }
    });
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            if (layout['symbol-min-distance'] !== undefined) {
                renameProperty(layout, 'symbol-min-distance', 'symbol-spacing');
            }
        });
        eachPaint(layer, function (paint) {
            if (paint['background-image'] !== undefined) {
                renameProperty(paint, 'background-image', 'background-pattern');
            }
            if (paint['line-image'] !== undefined) {
                renameProperty(paint, 'line-image', 'line-pattern');
            }
            if (paint['fill-image'] !== undefined) {
                renameProperty(paint, 'fill-image', 'fill-pattern');
            }
        });
    });
    eachProperty(style, {
        paint: true,
        layout: true
    }, function (property) {
        var value = resolveConstant(style, property.value);
        if (isFunction(value)) {
            value.stops.forEach(function (stop) {
                stop[1] = resolveConstant(style, stop[1]);
            });
        }
        property.set(value);
    });
    delete style.constants;
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            delete layout['text-max-size'];
            delete layout['icon-max-size'];
        });
        eachPaint(layer, function (paint) {
            if (paint['text-size']) {
                if (!layer.layout) {
                    layer.layout = {};
                }
                layer.layout['text-size'] = paint['text-size'];
                delete paint['text-size'];
            }
            if (paint['icon-size']) {
                if (!layer.layout) {
                    layer.layout = {};
                }
                layer.layout['icon-size'] = paint['icon-size'];
                delete paint['icon-size'];
            }
        });
    });
    function migrateFontstackURL(input) {
        var inputParsed = url.parse(input);
        var inputPathnameParts = inputParsed.pathname.split('/');
        if (inputParsed.protocol !== 'mapbox:') {
            return input;
        } else if (inputParsed.hostname === 'fontstack') {
            return 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf';
        } else if (inputParsed.hostname === 'fonts') {
            return 'mapbox://fonts/' + inputPathnameParts[2] + '/{fontstack}/{range}.pbf';
        }
    }
    if (style.glyphs) {
        style.glyphs = migrateFontstackURL(style.glyphs);
    }
    function migrateFontStack(font) {
        function splitAndTrim(string) {
            return string.split(',').map(function (s) {
                return s.trim();
            });
        }
        if (Array.isArray(font)) {
            return font;
        } else if (typeof font === 'string') {
            return splitAndTrim(font);
        } else if ((typeof font === "undefined" ? "undefined" : _typeof(font)) === 'object') {
            font.stops.forEach(function (stop) {
                stop[1] = splitAndTrim(stop[1]);
            });
            return font;
        } else {
            throw new Error('unexpected font value');
        }
    }
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            if (layout['text-font']) {
                layout['text-font'] = migrateFontStack(layout['text-font']);
            }
        });
    });
    var firstSymbolLayer = 0;
    for (var i = style.layers.length - 1; i >= 0; i--) {
        var layer = style.layers[i];
        if (layer.type !== 'symbol') {
            firstSymbolLayer = i + 1;
            break;
        }
    }
    var symbolLayers = style.layers.splice(firstSymbolLayer);
    symbolLayers.reverse();
    style.layers = style.layers.concat(symbolLayers);
    return style;
}

function extend(output) {
    var inputs = [],
        len = arguments.length - 1;
    while (len-- > 0) {
        inputs[len] = arguments[len + 1];
    }for (var i = 0, list = inputs; i < list.length; i += 1) {
        var input = list[i];
        for (var k in input) {
            output[k] = input[k];
        }
    }
    return output;
}

var ParsingError = function (Error) {
    function ParsingError(key, message) {
        Error.call(this, message);
        this.message = message;
        this.key = key;
    }
    if (Error) ParsingError.__proto__ = Error;
    ParsingError.prototype = Object.create(Error && Error.prototype);
    ParsingError.prototype.constructor = ParsingError;
    return ParsingError;
}(Error);

var Scope = function Scope(parent, bindings) {
    if (bindings === void 0) bindings = [];
    this.parent = parent;
    this.bindings = {};
    for (var i = 0, list = bindings; i < list.length; i += 1) {
        var ref = list[i];
        var name = ref[0];
        var expression = ref[1];
        this.bindings[name] = expression;
    }
};
Scope.prototype.concat = function concat(bindings) {
    return new Scope(this, bindings);
};
Scope.prototype.get = function get(name) {
    if (this.bindings[name]) {
        return this.bindings[name];
    }
    if (this.parent) {
        return this.parent.get(name);
    }
    throw new Error(name + ' not found in scope.');
};
Scope.prototype.has = function has(name) {
    if (this.bindings[name]) {
        return true;
    }
    return this.parent ? this.parent.has(name) : false;
};

var NullType = { kind: 'null' };
var NumberType = { kind: 'number' };
var StringType = { kind: 'string' };
var BooleanType = { kind: 'boolean' };
var ColorType = { kind: 'color' };
var ObjectType = { kind: 'object' };
var ValueType = { kind: 'value' };
var ErrorType = { kind: 'error' };
var CollatorType = { kind: 'collator' };
var FormattedType = { kind: 'formatted' };
var ResolvedImageType = { kind: 'resolvedImage' };
function array(itemType, N) {
    return {
        kind: 'array',
        itemType: itemType,
        N: N
    };
}
function toString(type) {
    if (type.kind === 'array') {
        var itemType = toString(type.itemType);
        return typeof type.N === 'number' ? 'array<' + itemType + ', ' + type.N + '>' : type.itemType.kind === 'value' ? 'array' : 'array<' + itemType + '>';
    } else {
        return type.kind;
    }
}
var valueMemberTypes = [NullType, NumberType, StringType, BooleanType, ColorType, FormattedType, ObjectType, array(ValueType), ResolvedImageType];
function checkSubtype(expected, t) {
    if (t.kind === 'error') {
        return null;
    } else if (expected.kind === 'array') {
        if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {
            return null;
        }
    } else if (expected.kind === t.kind) {
        return null;
    } else if (expected.kind === 'value') {
        for (var i = 0, list = valueMemberTypes; i < list.length; i += 1) {
            var memberType = list[i];
            if (!checkSubtype(memberType, t)) {
                return null;
            }
        }
    }
    return 'Expected ' + toString(expected) + ' but found ' + toString(t) + ' instead.';
}
function isValidType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
        return t.kind === provided.kind;
    });
}
function isValidNativeType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
        if (t === 'null') {
            return provided === null;
        } else if (t === 'array') {
            return Array.isArray(provided);
        } else if (t === 'object') {
            return provided && !Array.isArray(provided) && (typeof provided === "undefined" ? "undefined" : _typeof(provided)) === 'object';
        } else {
            return t === (typeof provided === "undefined" ? "undefined" : _typeof(provided));
        }
    });
}

var csscolorparser = createCommonjsModule(function (module, exports) {
    // (c) Dean McNamee <dean@gmail.com>, 2012.
    //
    // https://github.com/deanm/css-color-parser-js
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to
    // deal in the Software without restriction, including without limitation the
    // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    // sell copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    // IN THE SOFTWARE.

    // http://www.w3.org/TR/css3-color/
    var kCSSColorTable = {
        "transparent": [0, 0, 0, 0], "aliceblue": [240, 248, 255, 1],
        "antiquewhite": [250, 235, 215, 1], "aqua": [0, 255, 255, 1],
        "aquamarine": [127, 255, 212, 1], "azure": [240, 255, 255, 1],
        "beige": [245, 245, 220, 1], "bisque": [255, 228, 196, 1],
        "black": [0, 0, 0, 1], "blanchedalmond": [255, 235, 205, 1],
        "blue": [0, 0, 255, 1], "blueviolet": [138, 43, 226, 1],
        "brown": [165, 42, 42, 1], "burlywood": [222, 184, 135, 1],
        "cadetblue": [95, 158, 160, 1], "chartreuse": [127, 255, 0, 1],
        "chocolate": [210, 105, 30, 1], "coral": [255, 127, 80, 1],
        "cornflowerblue": [100, 149, 237, 1], "cornsilk": [255, 248, 220, 1],
        "crimson": [220, 20, 60, 1], "cyan": [0, 255, 255, 1],
        "darkblue": [0, 0, 139, 1], "darkcyan": [0, 139, 139, 1],
        "darkgoldenrod": [184, 134, 11, 1], "darkgray": [169, 169, 169, 1],
        "darkgreen": [0, 100, 0, 1], "darkgrey": [169, 169, 169, 1],
        "darkkhaki": [189, 183, 107, 1], "darkmagenta": [139, 0, 139, 1],
        "darkolivegreen": [85, 107, 47, 1], "darkorange": [255, 140, 0, 1],
        "darkorchid": [153, 50, 204, 1], "darkred": [139, 0, 0, 1],
        "darksalmon": [233, 150, 122, 1], "darkseagreen": [143, 188, 143, 1],
        "darkslateblue": [72, 61, 139, 1], "darkslategray": [47, 79, 79, 1],
        "darkslategrey": [47, 79, 79, 1], "darkturquoise": [0, 206, 209, 1],
        "darkviolet": [148, 0, 211, 1], "deeppink": [255, 20, 147, 1],
        "deepskyblue": [0, 191, 255, 1], "dimgray": [105, 105, 105, 1],
        "dimgrey": [105, 105, 105, 1], "dodgerblue": [30, 144, 255, 1],
        "firebrick": [178, 34, 34, 1], "floralwhite": [255, 250, 240, 1],
        "forestgreen": [34, 139, 34, 1], "fuchsia": [255, 0, 255, 1],
        "gainsboro": [220, 220, 220, 1], "ghostwhite": [248, 248, 255, 1],
        "gold": [255, 215, 0, 1], "goldenrod": [218, 165, 32, 1],
        "gray": [128, 128, 128, 1], "green": [0, 128, 0, 1],
        "greenyellow": [173, 255, 47, 1], "grey": [128, 128, 128, 1],
        "honeydew": [240, 255, 240, 1], "hotpink": [255, 105, 180, 1],
        "indianred": [205, 92, 92, 1], "indigo": [75, 0, 130, 1],
        "ivory": [255, 255, 240, 1], "khaki": [240, 230, 140, 1],
        "lavender": [230, 230, 250, 1], "lavenderblush": [255, 240, 245, 1],
        "lawngreen": [124, 252, 0, 1], "lemonchiffon": [255, 250, 205, 1],
        "lightblue": [173, 216, 230, 1], "lightcoral": [240, 128, 128, 1],
        "lightcyan": [224, 255, 255, 1], "lightgoldenrodyellow": [250, 250, 210, 1],
        "lightgray": [211, 211, 211, 1], "lightgreen": [144, 238, 144, 1],
        "lightgrey": [211, 211, 211, 1], "lightpink": [255, 182, 193, 1],
        "lightsalmon": [255, 160, 122, 1], "lightseagreen": [32, 178, 170, 1],
        "lightskyblue": [135, 206, 250, 1], "lightslategray": [119, 136, 153, 1],
        "lightslategrey": [119, 136, 153, 1], "lightsteelblue": [176, 196, 222, 1],
        "lightyellow": [255, 255, 224, 1], "lime": [0, 255, 0, 1],
        "limegreen": [50, 205, 50, 1], "linen": [250, 240, 230, 1],
        "magenta": [255, 0, 255, 1], "maroon": [128, 0, 0, 1],
        "mediumaquamarine": [102, 205, 170, 1], "mediumblue": [0, 0, 205, 1],
        "mediumorchid": [186, 85, 211, 1], "mediumpurple": [147, 112, 219, 1],
        "mediumseagreen": [60, 179, 113, 1], "mediumslateblue": [123, 104, 238, 1],
        "mediumspringgreen": [0, 250, 154, 1], "mediumturquoise": [72, 209, 204, 1],
        "mediumvioletred": [199, 21, 133, 1], "midnightblue": [25, 25, 112, 1],
        "mintcream": [245, 255, 250, 1], "mistyrose": [255, 228, 225, 1],
        "moccasin": [255, 228, 181, 1], "navajowhite": [255, 222, 173, 1],
        "navy": [0, 0, 128, 1], "oldlace": [253, 245, 230, 1],
        "olive": [128, 128, 0, 1], "olivedrab": [107, 142, 35, 1],
        "orange": [255, 165, 0, 1], "orangered": [255, 69, 0, 1],
        "orchid": [218, 112, 214, 1], "palegoldenrod": [238, 232, 170, 1],
        "palegreen": [152, 251, 152, 1], "paleturquoise": [175, 238, 238, 1],
        "palevioletred": [219, 112, 147, 1], "papayawhip": [255, 239, 213, 1],
        "peachpuff": [255, 218, 185, 1], "peru": [205, 133, 63, 1],
        "pink": [255, 192, 203, 1], "plum": [221, 160, 221, 1],
        "powderblue": [176, 224, 230, 1], "purple": [128, 0, 128, 1],
        "rebeccapurple": [102, 51, 153, 1],
        "red": [255, 0, 0, 1], "rosybrown": [188, 143, 143, 1],
        "royalblue": [65, 105, 225, 1], "saddlebrown": [139, 69, 19, 1],
        "salmon": [250, 128, 114, 1], "sandybrown": [244, 164, 96, 1],
        "seagreen": [46, 139, 87, 1], "seashell": [255, 245, 238, 1],
        "sienna": [160, 82, 45, 1], "silver": [192, 192, 192, 1],
        "skyblue": [135, 206, 235, 1], "slateblue": [106, 90, 205, 1],
        "slategray": [112, 128, 144, 1], "slategrey": [112, 128, 144, 1],
        "snow": [255, 250, 250, 1], "springgreen": [0, 255, 127, 1],
        "steelblue": [70, 130, 180, 1], "tan": [210, 180, 140, 1],
        "teal": [0, 128, 128, 1], "thistle": [216, 191, 216, 1],
        "tomato": [255, 99, 71, 1], "turquoise": [64, 224, 208, 1],
        "violet": [238, 130, 238, 1], "wheat": [245, 222, 179, 1],
        "white": [255, 255, 255, 1], "whitesmoke": [245, 245, 245, 1],
        "yellow": [255, 255, 0, 1], "yellowgreen": [154, 205, 50, 1] };

    function clamp_css_byte(i) {
        // Clamp to integer 0 .. 255.
        i = Math.round(i); // Seems to be what Chrome does (vs truncation).
        return i < 0 ? 0 : i > 255 ? 255 : i;
    }

    function clamp_css_float(f) {
        // Clamp to float 0.0 .. 1.0.
        return f < 0 ? 0 : f > 1 ? 1 : f;
    }

    function parse_css_int(str) {
        // int or percentage.
        if (str[str.length - 1] === '%') {
            return clamp_css_byte(parseFloat(str) / 100 * 255);
        }
        return clamp_css_byte(parseInt(str));
    }

    function parse_css_float(str) {
        // float or percentage.
        if (str[str.length - 1] === '%') {
            return clamp_css_float(parseFloat(str) / 100);
        }
        return clamp_css_float(parseFloat(str));
    }

    function css_hue_to_rgb(m1, m2, h) {
        if (h < 0) {
            h += 1;
        } else if (h > 1) {
            h -= 1;
        }

        if (h * 6 < 1) {
            return m1 + (m2 - m1) * h * 6;
        }
        if (h * 2 < 1) {
            return m2;
        }
        if (h * 3 < 2) {
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        }
        return m1;
    }

    function parseCSSColor(css_str) {
        // Remove all whitespace, not compliant, but should just be more accepting.
        var str = css_str.replace(/ /g, '').toLowerCase();

        // Color keywords (and transparent) lookup.
        if (str in kCSSColorTable) {
            return kCSSColorTable[str].slice();
        } // dup.

        // #abc and #abc123 syntax.
        if (str[0] === '#') {
            if (str.length === 4) {
                var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xfff)) {
                    return null;
                } // Covers NaN.
                return [(iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1];
            } else if (str.length === 7) {
                var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xffffff)) {
                    return null;
                } // Covers NaN.
                return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];
            }

            return null;
        }

        var op = str.indexOf('('),
            ep = str.indexOf(')');
        if (op !== -1 && ep + 1 === str.length) {
            var fname = str.substr(0, op);
            var params = str.substr(op + 1, ep - (op + 1)).split(',');
            var alpha = 1; // To allow case fallthrough.
            switch (fname) {
                case 'rgba':
                    if (params.length !== 4) {
                        return null;
                    }
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'rgb':
                    if (params.length !== 3) {
                        return null;
                    }
                    return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];
                case 'hsla':
                    if (params.length !== 4) {
                        return null;
                    }
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'hsl':
                    if (params.length !== 3) {
                        return null;
                    }
                    var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1
                    // NOTE(deanm): According to the CSS spec s/l should only be
                    // percentages, but we don't bother and let float or percentage.
                    var s = parse_css_float(params[1]);
                    var l = parse_css_float(params[2]);
                    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                    var m1 = l * 2 - m2;
                    return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];
                default:
                    return null;
            }
        }

        return null;
    }

    try {
        exports.parseCSSColor = parseCSSColor;
    } catch (e) {}
});
var csscolorparser_1 = csscolorparser.parseCSSColor;

var Color = function Color(r, g, b, a) {
    if (a === void 0) a = 1;
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
};
Color.parse = function parse(input) {
    if (!input) {
        return undefined;
    }
    if (input instanceof Color) {
        return input;
    }
    if (typeof input !== 'string') {
        return undefined;
    }
    var rgba = csscolorparser_1(input);
    if (!rgba) {
        return undefined;
    }
    return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
};
Color.prototype.toString = function toString() {
    var ref = this.toArray();
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    return 'rgba(' + Math.round(r) + ',' + Math.round(g) + ',' + Math.round(b) + ',' + a + ')';
};
Color.prototype.toArray = function toArray() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var a = ref.a;
    return a === 0 ? [0, 0, 0, 0] : [r * 255 / a, g * 255 / a, b * 255 / a, a];
};
Color.black = new Color(0, 0, 0, 1);
Color.white = new Color(1, 1, 1, 1);
Color.transparent = new Color(0, 0, 0, 0);
Color.red = new Color(1, 0, 0, 1);

var Collator = function Collator(caseSensitive, diacriticSensitive, locale) {
    if (caseSensitive) {
        this.sensitivity = diacriticSensitive ? 'variant' : 'case';
    } else {
        this.sensitivity = diacriticSensitive ? 'accent' : 'base';
    }
    this.locale = locale;
    this.collator = new Intl.Collator(this.locale ? this.locale : [], {
        sensitivity: this.sensitivity,
        usage: 'search'
    });
};
Collator.prototype.compare = function compare(lhs, rhs) {
    return this.collator.compare(lhs, rhs);
};
Collator.prototype.resolvedLocale = function resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
};

var FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {
    this.text = text;
    this.image = image;
    this.scale = scale;
    this.fontStack = fontStack;
    this.textColor = textColor;
};
var Formatted = function Formatted(sections) {
    this.sections = sections;
};
Formatted.fromString = function fromString(unformatted) {
    return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);
};
Formatted.prototype.isEmpty = function isEmpty() {
    if (this.sections.length === 0) {
        return true;
    }
    return !this.sections.some(function (section) {
        return section.text.length !== 0 || section.image && section.image.name.length !== 0;
    });
};
Formatted.factory = function factory(text) {
    if (text instanceof Formatted) {
        return text;
    } else {
        return Formatted.fromString(text);
    }
};
Formatted.prototype.toString = function toString() {
    if (this.sections.length === 0) {
        return '';
    }
    return this.sections.map(function (section) {
        return section.text;
    }).join('');
};
Formatted.prototype.serialize = function serialize() {
    var serialized = ['format'];
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        if (section.image) {
            serialized.push(['image', section.image.name]);
            continue;
        }
        serialized.push(section.text);
        var options = {};
        if (section.fontStack) {
            options['text-font'] = ['literal', section.fontStack.split(',')];
        }
        if (section.scale) {
            options['font-scale'] = section.scale;
        }
        if (section.textColor) {
            options['text-color'] = ['rgba'].concat(section.textColor.toArray());
        }
        serialized.push(options);
    }
    return serialized;
};

var ResolvedImage = function ResolvedImage(options) {
    this.name = options.name;
    this.available = options.available;
};
ResolvedImage.prototype.toString = function toString() {
    return this.name;
};
ResolvedImage.fromString = function fromString(name) {
    if (!name) {
        return null;
    }
    return new ResolvedImage({
        name: name,
        available: false
    });
};
ResolvedImage.prototype.serialize = function serialize() {
    return ['image', this.name];
};

function validateRGBA(r, g, b, a) {
    if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {
        var value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];
        return 'Invalid rgba value [' + value.join(', ') + ']: \'r\', \'g\', and \'b\' must be between 0 and 255.';
    }
    if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {
        return 'Invalid rgba value [' + [r, g, b, a].join(', ') + ']: \'a\' must be between 0 and 1.';
    }
    return null;
}
function isValue(mixed) {
    if (mixed === null) {
        return true;
    } else if (typeof mixed === 'string') {
        return true;
    } else if (typeof mixed === 'boolean') {
        return true;
    } else if (typeof mixed === 'number') {
        return true;
    } else if (mixed instanceof Color) {
        return true;
    } else if (mixed instanceof Collator) {
        return true;
    } else if (mixed instanceof Formatted) {
        return true;
    } else if (mixed instanceof ResolvedImage) {
        return true;
    } else if (Array.isArray(mixed)) {
        for (var i = 0, list = mixed; i < list.length; i += 1) {
            var item = list[i];
            if (!isValue(item)) {
                return false;
            }
        }
        return true;
    } else if ((typeof mixed === "undefined" ? "undefined" : _typeof(mixed)) === 'object') {
        for (var key in mixed) {
            if (!isValue(mixed[key])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
function typeOf(value) {
    if (value === null) {
        return NullType;
    } else if (typeof value === 'string') {
        return StringType;
    } else if (typeof value === 'boolean') {
        return BooleanType;
    } else if (typeof value === 'number') {
        return NumberType;
    } else if (value instanceof Color) {
        return ColorType;
    } else if (value instanceof Collator) {
        return CollatorType;
    } else if (value instanceof Formatted) {
        return FormattedType;
    } else if (value instanceof ResolvedImage) {
        return ResolvedImageType;
    } else if (Array.isArray(value)) {
        var length = value.length;
        var itemType;
        for (var i = 0, list = value; i < list.length; i += 1) {
            var item = list[i];
            var t = typeOf(item);
            if (!itemType) {
                itemType = t;
            } else if (itemType === t) {
                continue;
            } else {
                itemType = ValueType;
                break;
            }
        }
        return array(itemType || ValueType, length);
    } else {
        return ObjectType;
    }
}
function toString$1(value) {
    var type = typeof value === "undefined" ? "undefined" : _typeof(value);
    if (value === null) {
        return '';
    } else if (type === 'string' || type === 'number' || type === 'boolean') {
        return String(value);
    } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {
        return value.toString();
    } else {
        return JSON.stringify(value);
    }
}

var Literal = function Literal(type, value) {
    this.type = type;
    this.value = value;
};
Literal.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('\'literal\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');
    }
    if (!isValue(args[1])) {
        return context.error('invalid value');
    }
    var value = args[1];
    var type = typeOf(value);
    var expected = context.expectedType;
    if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {
        type = expected;
    }
    return new Literal(type, value);
};
Literal.prototype.evaluate = function evaluate() {
    return this.value;
};
Literal.prototype.eachChild = function eachChild() {};
Literal.prototype.outputDefined = function outputDefined() {
    return true;
};
Literal.prototype.serialize = function serialize() {
    if (this.type.kind === 'array' || this.type.kind === 'object') {
        return ['literal', this.value];
    } else if (this.value instanceof Color) {
        return ['rgba'].concat(this.value.toArray());
    } else if (this.value instanceof Formatted) {
        return this.value.serialize();
    } else {
        return this.value;
    }
};

var RuntimeError = function RuntimeError(message) {
    this.name = 'ExpressionEvaluationError';
    this.message = message;
};
RuntimeError.prototype.toJSON = function toJSON() {
    return this.message;
};

var types = {
    string: StringType,
    number: NumberType,
    boolean: BooleanType,
    object: ObjectType
};
var Assertion = function Assertion(type, args) {
    this.type = type;
    this.args = args;
};
Assertion.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var i = 1;
    var type;
    var name = args[0];
    if (name === 'array') {
        var itemType;
        if (args.length > 2) {
            var type$1 = args[1];
            if (typeof type$1 !== 'string' || !(type$1 in types) || type$1 === 'object') {
                return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
            }
            itemType = types[type$1];
            i++;
        } else {
            itemType = ValueType;
        }
        var N;
        if (args.length > 3) {
            if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
                return context.error('The length argument to "array" must be a positive integer literal', 2);
            }
            N = args[2];
            i++;
        }
        type = array(itemType, N);
    } else {
        type = types[name];
    }
    var parsed = [];
    for (; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) {
            return null;
        }
        parsed.push(input);
    }
    return new Assertion(type, parsed);
};
Assertion.prototype.evaluate = function evaluate(ctx) {
    for (var i = 0; i < this.args.length; i++) {
        var value = this.args[i].evaluate(ctx);
        var error = checkSubtype(this.type, typeOf(value));
        if (!error) {
            return value;
        } else if (i === this.args.length - 1) {
            throw new RuntimeError('Expected value to be of type ' + toString(this.type) + ', but found ' + toString(typeOf(value)) + ' instead.');
        }
    }
    return null;
};
Assertion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Assertion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Assertion.prototype.serialize = function serialize() {
    var type = this.type;
    var serialized = [type.kind];
    if (type.kind === 'array') {
        var itemType = type.itemType;
        if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {
            serialized.push(itemType.kind);
            var N = type.N;
            if (typeof N === 'number' || this.args.length > 1) {
                serialized.push(N);
            }
        }
    }
    return serialized.concat(this.args.map(function (arg) {
        return arg.serialize();
    }));
};

var FormatExpression = function FormatExpression(sections) {
    this.type = FormattedType;
    this.sections = sections;
};
FormatExpression.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var firstArg = args[1];
    if (!Array.isArray(firstArg) && (typeof firstArg === "undefined" ? "undefined" : _typeof(firstArg)) === 'object') {
        return context.error('First argument must be an image or text section.');
    }
    var sections = [];
    var nextTokenMayBeObject = false;
    for (var i = 1; i <= args.length - 1; ++i) {
        var arg = args[i];
        if (nextTokenMayBeObject && (typeof arg === "undefined" ? "undefined" : _typeof(arg)) === 'object' && !Array.isArray(arg)) {
            nextTokenMayBeObject = false;
            var scale = null;
            if (arg['font-scale']) {
                scale = context.parse(arg['font-scale'], 1, NumberType);
                if (!scale) {
                    return null;
                }
            }
            var font = null;
            if (arg['text-font']) {
                font = context.parse(arg['text-font'], 1, array(StringType));
                if (!font) {
                    return null;
                }
            }
            var textColor = null;
            if (arg['text-color']) {
                textColor = context.parse(arg['text-color'], 1, ColorType);
                if (!textColor) {
                    return null;
                }
            }
            var lastExpression = sections[sections.length - 1];
            lastExpression.scale = scale;
            lastExpression.font = font;
            lastExpression.textColor = textColor;
        } else {
            var content = context.parse(args[i], 1, ValueType);
            if (!content) {
                return null;
            }
            var kind = content.type.kind;
            if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage') {
                return context.error('Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.');
            }
            nextTokenMayBeObject = true;
            sections.push({
                content: content,
                scale: null,
                font: null,
                textColor: null
            });
        }
    }
    return new FormatExpression(sections);
};
FormatExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluateSection = function evaluateSection(section) {
        var evaluatedContent = section.content.evaluate(ctx);
        if (typeOf(evaluatedContent) === ResolvedImageType) {
            return new FormattedSection('', evaluatedContent, null, null, null);
        }
        return new FormattedSection(toString$1(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);
    };
    return new Formatted(this.sections.map(evaluateSection));
};
FormatExpression.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        fn(section.content);
        if (section.scale) {
            fn(section.scale);
        }
        if (section.font) {
            fn(section.font);
        }
        if (section.textColor) {
            fn(section.textColor);
        }
    }
};
FormatExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
FormatExpression.prototype.serialize = function serialize() {
    var serialized = ['format'];
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        serialized.push(section.content.serialize());
        var options = {};
        if (section.scale) {
            options['font-scale'] = section.scale.serialize();
        }
        if (section.font) {
            options['text-font'] = section.font.serialize();
        }
        if (section.textColor) {
            options['text-color'] = section.textColor.serialize();
        }
        serialized.push(options);
    }
    return serialized;
};

var ImageExpression = function ImageExpression(input) {
    this.type = ResolvedImageType;
    this.input = input;
};
ImageExpression.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected two arguments.');
    }
    var name = context.parse(args[1], 1, StringType);
    if (!name) {
        return context.error('No image name provided.');
    }
    return new ImageExpression(name);
};
ImageExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluatedImageName = this.input.evaluate(ctx);
    var value = ResolvedImage.fromString(evaluatedImageName);
    if (value && ctx.availableImages) {
        value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
    }
    return value;
};
ImageExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
};
ImageExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
ImageExpression.prototype.serialize = function serialize() {
    return ['image', this.input.serialize()];
};

var types$1 = {
    'to-boolean': BooleanType,
    'to-color': ColorType,
    'to-number': NumberType,
    'to-string': StringType
};
var Coercion = function Coercion(type, args) {
    this.type = type;
    this.args = args;
};
Coercion.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var name = args[0];
    if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2) {
        return context.error('Expected one argument.');
    }
    var type = types$1[name];
    var parsed = [];
    for (var i = 1; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) {
            return null;
        }
        parsed.push(input);
    }
    return new Coercion(type, parsed);
};
Coercion.prototype.evaluate = function evaluate(ctx) {
    if (this.type.kind === 'boolean') {
        return Boolean(this.args[0].evaluate(ctx));
    } else if (this.type.kind === 'color') {
        var input;
        var error;
        for (var i = 0, list = this.args; i < list.length; i += 1) {
            var arg = list[i];
            input = arg.evaluate(ctx);
            error = null;
            if (input instanceof Color) {
                return input;
            } else if (typeof input === 'string') {
                var c = ctx.parseColor(input);
                if (c) {
                    return c;
                }
            } else if (Array.isArray(input)) {
                if (input.length < 3 || input.length > 4) {
                    error = 'Invalid rbga value ' + JSON.stringify(input) + ': expected an array containing either three or four numeric values.';
                } else {
                    error = validateRGBA(input[0], input[1], input[2], input[3]);
                }
                if (!error) {
                    return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
                }
            }
        }
        throw new RuntimeError(error || 'Could not parse color from value \'' + (typeof input === 'string' ? input : String(JSON.stringify(input))) + '\'');
    } else if (this.type.kind === 'number') {
        var value = null;
        for (var i$1 = 0, list$1 = this.args; i$1 < list$1.length; i$1 += 1) {
            var arg$1 = list$1[i$1];
            value = arg$1.evaluate(ctx);
            if (value === null) {
                return 0;
            }
            var num = Number(value);
            if (isNaN(num)) {
                continue;
            }
            return num;
        }
        throw new RuntimeError('Could not convert ' + JSON.stringify(value) + ' to number.');
    } else if (this.type.kind === 'formatted') {
        return Formatted.fromString(toString$1(this.args[0].evaluate(ctx)));
    } else if (this.type.kind === 'resolvedImage') {
        return ResolvedImage.fromString(toString$1(this.args[0].evaluate(ctx)));
    } else {
        return toString$1(this.args[0].evaluate(ctx));
    }
};
Coercion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Coercion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Coercion.prototype.serialize = function serialize() {
    if (this.type.kind === 'formatted') {
        return new FormatExpression([{
            content: this.args[0],
            scale: null,
            font: null,
            textColor: null
        }]).serialize();
    }
    if (this.type.kind === 'resolvedImage') {
        return new ImageExpression(this.args[0]).serialize();
    }
    var serialized = ['to-' + this.type.kind];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];
var EvaluationContext = function EvaluationContext() {
    this.globals = null;
    this.feature = null;
    this.featureState = null;
    this.formattedSection = null;
    this._parseColorCache = {};
    this.availableImages = null;
    this.canonical = null;
};
EvaluationContext.prototype.id = function id() {
    return this.feature && 'id' in this.feature ? this.feature.id : null;
};
EvaluationContext.prototype.geometryType = function geometryType() {
    return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
};
EvaluationContext.prototype.geometry = function geometry() {
    return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
};
EvaluationContext.prototype.canonicalID = function canonicalID() {
    return this.canonical;
};
EvaluationContext.prototype.properties = function properties() {
    return this.feature && this.feature.properties || {};
};
EvaluationContext.prototype.parseColor = function parseColor(input) {
    var cached = this._parseColorCache[input];
    if (!cached) {
        cached = this._parseColorCache[input] = Color.parse(input);
    }
    return cached;
};

var CompoundExpression = function CompoundExpression(name, type, evaluate, args) {
    this.name = name;
    this.type = type;
    this._evaluate = evaluate;
    this.args = args;
};
CompoundExpression.prototype.evaluate = function evaluate(ctx) {
    return this._evaluate(ctx, this.args);
};
CompoundExpression.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
CompoundExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
CompoundExpression.prototype.serialize = function serialize() {
    return [this.name].concat(this.args.map(function (arg) {
        return arg.serialize();
    }));
};
CompoundExpression.parse = function parse(args, context) {
    var ref$1;
    var op = args[0];
    var definition = CompoundExpression.definitions[op];
    if (!definition) {
        return context.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
    }
    var type = Array.isArray(definition) ? definition[0] : definition.type;
    var availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;
    var overloads = availableOverloads.filter(function (ref) {
        var signature = ref[0];
        return !Array.isArray(signature) || signature.length === args.length - 1;
    });
    var signatureContext = null;
    for (var i$3 = 0, list = overloads; i$3 < list.length; i$3 += 1) {
        var ref = list[i$3];
        var params = ref[0];
        var evaluate = ref[1];
        signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);
        var parsedArgs = [];
        var argParseFailed = false;
        for (var i = 1; i < args.length; i++) {
            var arg = args[i];
            var expectedType = Array.isArray(params) ? params[i - 1] : params.type;
            var parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
            if (!parsed) {
                argParseFailed = true;
                break;
            }
            parsedArgs.push(parsed);
        }
        if (argParseFailed) {
            continue;
        }
        if (Array.isArray(params)) {
            if (params.length !== parsedArgs.length) {
                signatureContext.error('Expected ' + params.length + ' arguments, but found ' + parsedArgs.length + ' instead.');
                continue;
            }
        }
        for (var i$1 = 0; i$1 < parsedArgs.length; i$1++) {
            var expected = Array.isArray(params) ? params[i$1] : params.type;
            var arg$1 = parsedArgs[i$1];
            signatureContext.concat(i$1 + 1).checkSubtype(expected, arg$1.type);
        }
        if (signatureContext.errors.length === 0) {
            return new CompoundExpression(op, type, evaluate, parsedArgs);
        }
    }
    if (overloads.length === 1) {
        (ref$1 = context.errors).push.apply(ref$1, signatureContext.errors);
    } else {
        var expected$1 = overloads.length ? overloads : availableOverloads;
        var signatures = expected$1.map(function (ref) {
            var params = ref[0];
            return stringifySignature(params);
        }).join(' | ');
        var actualTypes = [];
        for (var i$2 = 1; i$2 < args.length; i$2++) {
            var parsed$1 = context.parse(args[i$2], 1 + actualTypes.length);
            if (!parsed$1) {
                return null;
            }
            actualTypes.push(toString(parsed$1.type));
        }
        context.error('Expected arguments of type ' + signatures + ', but found (' + actualTypes.join(', ') + ') instead.');
    }
    return null;
};
CompoundExpression.register = function register(registry, definitions) {
    CompoundExpression.definitions = definitions;
    for (var name in definitions) {
        registry[name] = CompoundExpression;
    }
};
function stringifySignature(signature) {
    if (Array.isArray(signature)) {
        return '(' + signature.map(toString).join(', ') + ')';
    } else {
        return '(' + toString(signature.type) + '...)';
    }
}

var CollatorExpression = function CollatorExpression(caseSensitive, diacriticSensitive, locale) {
    this.type = CollatorType;
    this.locale = locale;
    this.caseSensitive = caseSensitive;
    this.diacriticSensitive = diacriticSensitive;
};
CollatorExpression.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected one argument.');
    }
    var options = args[1];
    if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== 'object' || Array.isArray(options)) {
        return context.error('Collator options argument must be an object.');
    }
    var caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);
    if (!caseSensitive) {
        return null;
    }
    var diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);
    if (!diacriticSensitive) {
        return null;
    }
    var locale = null;
    if (options['locale']) {
        locale = context.parse(options['locale'], 1, StringType);
        if (!locale) {
            return null;
        }
    }
    return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
};
CollatorExpression.prototype.evaluate = function evaluate(ctx) {
    return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
};
CollatorExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.caseSensitive);
    fn(this.diacriticSensitive);
    if (this.locale) {
        fn(this.locale);
    }
};
CollatorExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
CollatorExpression.prototype.serialize = function serialize() {
    var options = {};
    options['case-sensitive'] = this.caseSensitive.serialize();
    options['diacritic-sensitive'] = this.diacriticSensitive.serialize();
    if (this.locale) {
        options['locale'] = this.locale.serialize();
    }
    return ['collator', options];
};

var EXTENT = 8192;
function updateBBox(bbox, coord) {
    bbox[0] = Math.min(bbox[0], coord[0]);
    bbox[1] = Math.min(bbox[1], coord[1]);
    bbox[2] = Math.max(bbox[2], coord[0]);
    bbox[3] = Math.max(bbox[3], coord[1]);
}
function mercatorXfromLng(lng) {
    return (180 + lng) / 360;
}
function mercatorYfromLat(lat) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function boxWithinBox(bbox1, bbox2) {
    if (bbox1[0] <= bbox2[0]) {
        return false;
    }
    if (bbox1[2] >= bbox2[2]) {
        return false;
    }
    if (bbox1[1] <= bbox2[1]) {
        return false;
    }
    if (bbox1[3] >= bbox2[3]) {
        return false;
    }
    return true;
}
function getTileCoordinates(p, canonical) {
    var x = mercatorXfromLng(p[0]);
    var y = mercatorYfromLat(p[1]);
    var tilesAtZoom = Math.pow(2, canonical.z);
    return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];
}
function onBoundary(p, p1, p2) {
    var x1 = p[0] - p1[0];
    var y1 = p[1] - p1[1];
    var x2 = p[0] - p2[0];
    var y2 = p[1] - p2[1];
    return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
}
function rayIntersect(p, p1, p2) {
    return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
}
function pointWithinPolygon(point, rings) {
    var inside = false;
    for (var i = 0, len = rings.length; i < len; i++) {
        var ring = rings[i];
        for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {
            if (onBoundary(point, ring[j], ring[j + 1])) {
                return false;
            }
            if (rayIntersect(point, ring[j], ring[j + 1])) {
                inside = !inside;
            }
        }
    }
    return inside;
}
function pointWithinPolygons(point, polygons) {
    for (var i = 0; i < polygons.length; i++) {
        if (pointWithinPolygon(point, polygons[i])) {
            return true;
        }
    }
    return false;
}
function perp(v1, v2) {
    return v1[0] * v2[1] - v1[1] * v2[0];
}
function twoSided(p1, p2, q1, q2) {
    var x1 = p1[0] - q1[0];
    var y1 = p1[1] - q1[1];
    var x2 = p2[0] - q1[0];
    var y2 = p2[1] - q1[1];
    var x3 = q2[0] - q1[0];
    var y3 = q2[1] - q1[1];
    var det1 = x1 * y3 - x3 * y1;
    var det2 = x2 * y3 - x3 * y2;
    if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) {
        return true;
    }
    return false;
}
function lineIntersectLine(a, b, c, d) {
    var vectorP = [b[0] - a[0], b[1] - a[1]];
    var vectorQ = [d[0] - c[0], d[1] - c[1]];
    if (perp(vectorQ, vectorP) === 0) {
        return false;
    }
    if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) {
        return true;
    }
    return false;
}
function lineIntersectPolygon(p1, p2, polygon) {
    for (var i = 0, list = polygon; i < list.length; i += 1) {
        var ring = list[i];
        for (var j = 0; j < ring.length - 1; ++j) {
            if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {
                return true;
            }
        }
    }
    return false;
}
function lineStringWithinPolygon(line, polygon) {
    for (var i = 0; i < line.length; ++i) {
        if (!pointWithinPolygon(line[i], polygon)) {
            return false;
        }
    }
    for (var i$1 = 0; i$1 < line.length - 1; ++i$1) {
        if (lineIntersectPolygon(line[i$1], line[i$1 + 1], polygon)) {
            return false;
        }
    }
    return true;
}
function lineStringWithinPolygons(line, polygons) {
    for (var i = 0; i < polygons.length; i++) {
        if (lineStringWithinPolygon(line, polygons[i])) {
            return true;
        }
    }
    return false;
}
function getTilePolygon(coordinates, bbox, canonical) {
    var polygon = [];
    for (var i = 0; i < coordinates.length; i++) {
        var ring = [];
        for (var j = 0; j < coordinates[i].length; j++) {
            var coord = getTileCoordinates(coordinates[i][j], canonical);
            updateBBox(bbox, coord);
            ring.push(coord);
        }
        polygon.push(ring);
    }
    return polygon;
}
function getTilePolygons(coordinates, bbox, canonical) {
    var polygons = [];
    for (var i = 0; i < coordinates.length; i++) {
        var polygon = getTilePolygon(coordinates[i], bbox, canonical);
        polygons.push(polygon);
    }
    return polygons;
}
function updatePoint(p, bbox, polyBBox, worldSize) {
    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
        var halfWorldSize = worldSize * 0.5;
        var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;
        if (shift === 0) {
            shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
        }
        p[0] += shift;
    }
    updateBBox(bbox, p);
}
function resetBBox(bbox) {
    bbox[0] = bbox[1] = Infinity;
    bbox[2] = bbox[3] = -Infinity;
}
function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
    var tilePoints = [];
    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
        var points = list$1[i$1];
        for (var i = 0, list = points; i < list.length; i += 1) {
            var point = list[i];
            var p = [point.x + shifts[0], point.y + shifts[1]];
            updatePoint(p, pointBBox, polyBBox, worldSize);
            tilePoints.push(p);
        }
    }
    return tilePoints;
}
function getTileLines(geometry, lineBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
    var tileLines = [];
    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
        var line = list$1[i$1];
        var tileLine = [];
        for (var i = 0, list = line; i < list.length; i += 1) {
            var point = list[i];
            var p = [point.x + shifts[0], point.y + shifts[1]];
            updateBBox(lineBBox, p);
            tileLine.push(p);
        }
        tileLines.push(tileLine);
    }
    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
        resetBBox(lineBBox);
        for (var i$3 = 0, list$3 = tileLines; i$3 < list$3.length; i$3 += 1) {
            var line$1 = list$3[i$3];
            for (var i$2 = 0, list$2 = line$1; i$2 < list$2.length; i$2 += 1) {
                var p$1 = list$2[i$2];
                updatePoint(p$1, lineBBox, polyBBox, worldSize);
            }
        }
    }
    return tileLines;
}
function pointsWithinPolygons(ctx, polygonGeometry) {
    var pointBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var canonical = ctx.canonicalID();
    if (polygonGeometry.type === 'Polygon') {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) {
            return false;
        }
        for (var i = 0, list = tilePoints; i < list.length; i += 1) {
            var point = list[i];
            if (!pointWithinPolygon(point, tilePolygon)) {
                return false;
            }
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints$1 = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) {
            return false;
        }
        for (var i$1 = 0, list$1 = tilePoints$1; i$1 < list$1.length; i$1 += 1) {
            var point$1 = list$1[i$1];
            if (!pointWithinPolygons(point$1, tilePolygons)) {
                return false;
            }
        }
    }
    return true;
}
function linesWithinPolygons(ctx, polygonGeometry) {
    var lineBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var canonical = ctx.canonicalID();
    if (polygonGeometry.type === 'Polygon') {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) {
            return false;
        }
        for (var i = 0, list = tileLines; i < list.length; i += 1) {
            var line = list[i];
            if (!lineStringWithinPolygon(line, tilePolygon)) {
                return false;
            }
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines$1 = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) {
            return false;
        }
        for (var i$1 = 0, list$1 = tileLines$1; i$1 < list$1.length; i$1 += 1) {
            var line$1 = list$1[i$1];
            if (!lineStringWithinPolygons(line$1, tilePolygons)) {
                return false;
            }
        }
    }
    return true;
}
var Within = function Within(geojson, geometries) {
    this.type = BooleanType;
    this.geojson = geojson;
    this.geometries = geometries;
};
Within.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('\'within\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');
    }
    if (isValue(args[1])) {
        var geojson = args[1];
        if (geojson.type === 'FeatureCollection') {
            for (var i = 0; i < geojson.features.length; ++i) {
                var type = geojson.features[i].geometry.type;
                if (type === 'Polygon' || type === 'MultiPolygon') {
                    return new Within(geojson, geojson.features[i].geometry);
                }
            }
        } else if (geojson.type === 'Feature') {
            var type$1 = geojson.geometry.type;
            if (type$1 === 'Polygon' || type$1 === 'MultiPolygon') {
                return new Within(geojson, geojson.geometry);
            }
        } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {
            return new Within(geojson, geojson);
        }
    }
    return context.error('\'within\' expression requires valid geojson object that contains polygon geometry type.');
};
Within.prototype.evaluate = function evaluate(ctx) {
    if (ctx.geometry() != null && ctx.canonicalID() != null) {
        if (ctx.geometryType() === 'Point') {
            return pointsWithinPolygons(ctx, this.geometries);
        } else if (ctx.geometryType() === 'LineString') {
            return linesWithinPolygons(ctx, this.geometries);
        }
    }
    return false;
};
Within.prototype.eachChild = function eachChild() {};
Within.prototype.outputDefined = function outputDefined() {
    return true;
};
Within.prototype.serialize = function serialize() {
    return ['within', this.geojson];
};

function isFeatureConstant(e) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'get' && e.args.length === 1) {
            return false;
        } else if (e.name === 'feature-state') {
            return false;
        } else if (e.name === 'has' && e.args.length === 1) {
            return false;
        } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {
            return false;
        } else if (/^filter-/.test(e.name)) {
            return false;
        }
    }
    if (e instanceof Within) {
        return false;
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isFeatureConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isStateConstant(e) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'feature-state') {
            return false;
        }
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isStateConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isGlobalPropertyConstant(e, properties) {
    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {
        return false;
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isGlobalPropertyConstant(arg, properties)) {
            result = false;
        }
    });
    return result;
}

var Var = function Var(name, boundExpression) {
    this.type = boundExpression.type;
    this.name = name;
    this.boundExpression = boundExpression;
};
Var.parse = function parse(args, context) {
    if (args.length !== 2 || typeof args[1] !== 'string') {
        return context.error('\'var\' expression requires exactly one string literal argument.');
    }
    var name = args[1];
    if (!context.scope.has(name)) {
        return context.error('Unknown variable "' + name + '". Make sure "' + name + '" has been bound in an enclosing "let" expression before using it.', 1);
    }
    return new Var(name, context.scope.get(name));
};
Var.prototype.evaluate = function evaluate(ctx) {
    return this.boundExpression.evaluate(ctx);
};
Var.prototype.eachChild = function eachChild() {};
Var.prototype.outputDefined = function outputDefined() {
    return false;
};
Var.prototype.serialize = function serialize() {
    return ['var', this.name];
};

var ParsingContext = function ParsingContext(registry, path, expectedType, scope, errors) {
    if (path === void 0) path = [];
    if (scope === void 0) scope = new Scope();
    if (errors === void 0) errors = [];
    this.registry = registry;
    this.path = path;
    this.key = path.map(function (part) {
        return '[' + part + ']';
    }).join('');
    this.scope = scope;
    this.errors = errors;
    this.expectedType = expectedType;
};
ParsingContext.prototype.parse = function parse(expr, index, expectedType, bindings, options) {
    if (options === void 0) options = {};
    if (index) {
        return this.concat(index, expectedType, bindings)._parse(expr, options);
    }
    return this._parse(expr, options);
};
ParsingContext.prototype._parse = function _parse(expr, options) {
    if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
        expr = ['literal', expr];
    }
    function annotate(parsed, type, typeAnnotation) {
        if (typeAnnotation === 'assert') {
            return new Assertion(type, [parsed]);
        } else if (typeAnnotation === 'coerce') {
            return new Coercion(type, [parsed]);
        } else {
            return parsed;
        }
    }
    if (Array.isArray(expr)) {
        if (expr.length === 0) {
            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
        }
        var op = expr[0];
        if (typeof op !== 'string') {
            this.error('Expression name must be a string, but found ' + (typeof op === "undefined" ? "undefined" : _typeof(op)) + ' instead. If you wanted a literal array, use ["literal", [...]].', 0);
            return null;
        }
        var Expr = this.registry[op];
        if (Expr) {
            var parsed = Expr.parse(expr, this);
            if (!parsed) {
                return null;
            }
            if (this.expectedType) {
                var expected = this.expectedType;
                var actual = parsed.type;
                if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {
                    parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');
                } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {
                    parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');
                } else if (this.checkSubtype(expected, actual)) {
                    return null;
                }
            }
            if (!(parsed instanceof Literal) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {
                var ec = new EvaluationContext();
                try {
                    parsed = new Literal(parsed.type, parsed.evaluate(ec));
                } catch (e) {
                    this.error(e.message);
                    return null;
                }
            }
            return parsed;
        }
        return this.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
    } else if (typeof expr === 'undefined') {
        return this.error('\'undefined\' value invalid. Use null instead.');
    } else if ((typeof expr === "undefined" ? "undefined" : _typeof(expr)) === 'object') {
        return this.error('Bare objects invalid. Use ["literal", {...}] instead.');
    } else {
        return this.error('Expected an array, but found ' + (typeof expr === "undefined" ? "undefined" : _typeof(expr)) + ' instead.');
    }
};
ParsingContext.prototype.concat = function concat(index, expectedType, bindings) {
    var path = typeof index === 'number' ? this.path.concat(index) : this.path;
    var scope = bindings ? this.scope.concat(bindings) : this.scope;
    return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
};
ParsingContext.prototype.error = function error(error$1) {
    var keys = [],
        len = arguments.length - 1;
    while (len-- > 0) {
        keys[len] = arguments[len + 1];
    }var key = '' + this.key + keys.map(function (k) {
        return '[' + k + ']';
    }).join('');
    this.errors.push(new ParsingError(key, error$1));
};
ParsingContext.prototype.checkSubtype = function checkSubtype$1(expected, t) {
    var error = checkSubtype(expected, t);
    if (error) {
        this.error(error);
    }
    return error;
};
function isConstant(expression) {
    if (expression instanceof Var) {
        return isConstant(expression.boundExpression);
    } else if (expression instanceof CompoundExpression && expression.name === 'error') {
        return false;
    } else if (expression instanceof CollatorExpression) {
        return false;
    } else if (expression instanceof Within) {
        return false;
    }
    var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;
    var childrenConstant = true;
    expression.eachChild(function (child) {
        if (isTypeAnnotation) {
            childrenConstant = childrenConstant && isConstant(child);
        } else {
            childrenConstant = childrenConstant && child instanceof Literal;
        }
    });
    if (!childrenConstant) {
        return false;
    }
    return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, ['zoom', 'heatmap-density', 'line-progress', 'accumulated', 'is-supported-script']);
}

function findStopLessThanOrEqualTo(stops, input) {
    var lastIndex = stops.length - 1;
    var lowerIndex = 0;
    var upperIndex = lastIndex;
    var currentIndex = 0;
    var currentValue, nextValue;
    while (lowerIndex <= upperIndex) {
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex];
        nextValue = stops[currentIndex + 1];
        if (currentValue <= input) {
            if (currentIndex === lastIndex || input < nextValue) {
                return currentIndex;
            }
            lowerIndex = currentIndex + 1;
        } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
        } else {
            throw new RuntimeError('Input is not a number.');
        }
    }
    return 0;
}

var Step = function Step(type, input, stops) {
    this.type = type;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];
        this.labels.push(label);
        this.outputs.push(expression);
    }
};
Step.parse = function parse(args, context) {
    if (args.length - 1 < 4) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if ((args.length - 1) % 2 !== 0) {
        return context.error('Expected an even number of arguments.');
    }
    var input = context.parse(args[1], 1, NumberType);
    if (!input) {
        return null;
    }
    var stops = [];
    var outputType = null;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    for (var i = 1; i < args.length; i += 2) {
        var label = i === 1 ? -Infinity : args[i];
        var value = args[i + 1];
        var labelKey = i;
        var valueKey = i + 1;
        if (typeof label !== 'number') {
            return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }
        if (stops.length && stops[stops.length - 1][0] >= label) {
            return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }
        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        stops.push([label, parsed]);
    }
    return new Step(outputType, input, stops);
};
Step.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;
    if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
    }
    var value = this.input.evaluate(ctx);
    if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
    }
    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
    }
    var index = findStopLessThanOrEqualTo(labels, value);
    return outputs[index].evaluate(ctx);
};
Step.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
        var expression = list[i];
        fn(expression);
    }
};
Step.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    });
};
Step.prototype.serialize = function serialize() {
    var serialized = ['step', this.input.serialize()];
    for (var i = 0; i < this.labels.length; i++) {
        if (i > 0) {
            serialized.push(this.labels[i]);
        }
        serialized.push(this.outputs[i].serialize());
    }
    return serialized;
};

/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

var unitbezier = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function (t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function (t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function (t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function (x, epsilon) {
    if (typeof epsilon === 'undefined') {
        epsilon = 1e-6;
    }

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) {
            return t2;
        }

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) {
            break;
        }

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) {
        return t0;
    }
    if (t2 > t1) {
        return t1;
    }

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) {
            return t2;
        }

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function (x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

function number(a, b, t) {
    return a * (1 - t) + b * t;
}
function color(from, to, t) {
    return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
}
function array$1(from, to, t) {
    return from.map(function (d, i) {
        return number(d, to[i], t);
    });
}

var interpolate = /*#__PURE__*/Object.freeze({
    __proto__: null,
    number: number,
    color: color,
    array: array$1
});

var Xn = 0.95047,
    Yn = 1,
    Zn = 1.08883,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1,
    deg2rad = Math.PI / 180,
    rad2deg = 180 / Math.PI;
function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
}
function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2xyz(x) {
    x /= 255;
    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function rgbToLab(rgbColor) {
    var b = rgb2xyz(rgbColor.r),
        a = rgb2xyz(rgbColor.g),
        l = rgb2xyz(rgbColor.b),
        x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
        y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn),
        z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
    return {
        l: 116 * y - 16,
        a: 500 * (x - y),
        b: 200 * (y - z),
        alpha: rgbColor.a
    };
}
function labToRgb(labColor) {
    var y = (labColor.l + 16) / 116,
        x = isNaN(labColor.a) ? y : y + labColor.a / 500,
        z = isNaN(labColor.b) ? y : y - labColor.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
}
function interpolateLab(from, to, t) {
    return {
        l: number(from.l, to.l, t),
        a: number(from.a, to.a, t),
        b: number(from.b, to.b, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
function rgbToHcl(rgbColor) {
    var ref = rgbToLab(rgbColor);
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var h = Math.atan2(b, a) * rad2deg;
    return {
        h: h < 0 ? h + 360 : h,
        c: Math.sqrt(a * a + b * b),
        l: l,
        alpha: rgbColor.a
    };
}
function hclToRgb(hclColor) {
    var h = hclColor.h * deg2rad,
        c = hclColor.c,
        l = hclColor.l;
    return labToRgb({
        l: l,
        a: Math.cos(h) * c,
        b: Math.sin(h) * c,
        alpha: hclColor.alpha
    });
}
function interpolateHue(a, b, t) {
    var d = b - a;
    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
}
function interpolateHcl(from, to, t) {
    return {
        h: interpolateHue(from.h, to.h, t),
        c: number(from.c, to.c, t),
        l: number(from.l, to.l, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
var lab = {
    forward: rgbToLab,
    reverse: labToRgb,
    interpolate: interpolateLab
};
var hcl = {
    forward: rgbToHcl,
    reverse: hclToRgb,
    interpolate: interpolateHcl
};

var colorSpaces = /*#__PURE__*/Object.freeze({
    __proto__: null,
    lab: lab,
    hcl: hcl
});

var Interpolate = function Interpolate(type, operator, interpolation, input, stops) {
    this.type = type;
    this.operator = operator;
    this.interpolation = interpolation;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];
        this.labels.push(label);
        this.outputs.push(expression);
    }
};
Interpolate.interpolationFactor = function interpolationFactor(interpolation, input, lower, upper) {
    var t = 0;
    if (interpolation.name === 'exponential') {
        t = exponentialInterpolation(input, interpolation.base, lower, upper);
    } else if (interpolation.name === 'linear') {
        t = exponentialInterpolation(input, 1, lower, upper);
    } else if (interpolation.name === 'cubic-bezier') {
        var c = interpolation.controlPoints;
        var ub = new unitbezier(c[0], c[1], c[2], c[3]);
        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
    }
    return t;
};
Interpolate.parse = function parse(args, context) {
    var operator = args[0];
    var interpolation = args[1];
    var input = args[2];
    var rest = args.slice(3);
    if (!Array.isArray(interpolation) || interpolation.length === 0) {
        return context.error('Expected an interpolation type expression.', 1);
    }
    if (interpolation[0] === 'linear') {
        interpolation = { name: 'linear' };
    } else if (interpolation[0] === 'exponential') {
        var base = interpolation[1];
        if (typeof base !== 'number') {
            return context.error('Exponential interpolation requires a numeric base.', 1, 1);
        }
        interpolation = {
            name: 'exponential',
            base: base
        };
    } else if (interpolation[0] === 'cubic-bezier') {
        var controlPoints = interpolation.slice(1);
        if (controlPoints.length !== 4 || controlPoints.some(function (t) {
            return typeof t !== 'number' || t < 0 || t > 1;
        })) {
            return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
        }
        interpolation = {
            name: 'cubic-bezier',
            controlPoints: controlPoints
        };
    } else {
        return context.error('Unknown interpolation type ' + String(interpolation[0]), 1, 0);
    }
    if (args.length - 1 < 4) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if ((args.length - 1) % 2 !== 0) {
        return context.error('Expected an even number of arguments.');
    }
    input = context.parse(input, 2, NumberType);
    if (!input) {
        return null;
    }
    var stops = [];
    var outputType = null;
    if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {
        outputType = ColorType;
    } else if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    for (var i = 0; i < rest.length; i += 2) {
        var label = rest[i];
        var value = rest[i + 1];
        var labelKey = i + 3;
        var valueKey = i + 4;
        if (typeof label !== 'number') {
            return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }
        if (stops.length && stops[stops.length - 1][0] >= label) {
            return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }
        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        stops.push([label, parsed]);
    }
    if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
        return context.error('Type ' + toString(outputType) + ' is not interpolatable.');
    }
    return new Interpolate(outputType, operator, interpolation, input, stops);
};
Interpolate.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;
    if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
    }
    var value = this.input.evaluate(ctx);
    if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
    }
    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
    }
    var index = findStopLessThanOrEqualTo(labels, value);
    var lower = labels[index];
    var upper = labels[index + 1];
    var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
    var outputLower = outputs[index].evaluate(ctx);
    var outputUpper = outputs[index + 1].evaluate(ctx);
    if (this.operator === 'interpolate') {
        return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);
    } else if (this.operator === 'interpolate-hcl') {
        return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
    } else {
        return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
    }
};
Interpolate.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
        var expression = list[i];
        fn(expression);
    }
};
Interpolate.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    });
};
Interpolate.prototype.serialize = function serialize() {
    var interpolation;
    if (this.interpolation.name === 'linear') {
        interpolation = ['linear'];
    } else if (this.interpolation.name === 'exponential') {
        if (this.interpolation.base === 1) {
            interpolation = ['linear'];
        } else {
            interpolation = ['exponential', this.interpolation.base];
        }
    } else {
        interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);
    }
    var serialized = [this.operator, interpolation, this.input.serialize()];
    for (var i = 0; i < this.labels.length; i++) {
        serialized.push(this.labels[i], this.outputs[i].serialize());
    }
    return serialized;
};
function exponentialInterpolation(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

var Coalesce = function Coalesce(type, args) {
    this.type = type;
    this.args = args;
};
Coalesce.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expectected at least one argument.');
    }
    var outputType = null;
    var expectedType = context.expectedType;
    if (expectedType && expectedType.kind !== 'value') {
        outputType = expectedType;
    }
    var parsedArgs = [];
    for (var i = 0, list = args.slice(1); i < list.length; i += 1) {
        var arg = list[i];
        var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, { typeAnnotation: 'omit' });
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        parsedArgs.push(parsed);
    }
    var needsAnnotation = expectedType && parsedArgs.some(function (arg) {
        return checkSubtype(expectedType, arg.type);
    });
    return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
};
Coalesce.prototype.evaluate = function evaluate(ctx) {
    var result = null;
    var argCount = 0;
    var requestedImageName;
    for (var i = 0, list = this.args; i < list.length; i += 1) {
        var arg = list[i];
        argCount++;
        result = arg.evaluate(ctx);
        if (result && result instanceof ResolvedImage && !result.available) {
            if (!requestedImageName) {
                requestedImageName = result.name;
            }
            result = null;
            if (argCount === this.args.length) {
                result = requestedImageName;
            }
        }
        if (result !== null) {
            break;
        }
    }
    return result;
};
Coalesce.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Coalesce.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Coalesce.prototype.serialize = function serialize() {
    var serialized = ['coalesce'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var Let = function Let(bindings, result) {
    this.type = result.type;
    this.bindings = [].concat(bindings);
    this.result = result;
};
Let.prototype.evaluate = function evaluate(ctx) {
    return this.result.evaluate(ctx);
};
Let.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
        var binding = list[i];
        fn(binding[1]);
    }
    fn(this.result);
};
Let.parse = function parse(args, context) {
    if (args.length < 4) {
        return context.error('Expected at least 3 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var bindings = [];
    for (var i = 1; i < args.length - 1; i += 2) {
        var name = args[i];
        if (typeof name !== 'string') {
            return context.error('Expected string, but found ' + (typeof name === "undefined" ? "undefined" : _typeof(name)) + ' instead.', i);
        }
        if (/[^a-zA-Z0-9_]/.test(name)) {
            return context.error('Variable names must contain only alphanumeric characters or \'_\'.', i);
        }
        var value = context.parse(args[i + 1], i + 1);
        if (!value) {
            return null;
        }
        bindings.push([name, value]);
    }
    var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
    if (!result) {
        return null;
    }
    return new Let(bindings, result);
};
Let.prototype.outputDefined = function outputDefined() {
    return this.result.outputDefined();
};
Let.prototype.serialize = function serialize() {
    var serialized = ['let'];
    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
        var ref = list[i];
        var name = ref[0];
        var expr = ref[1];
        serialized.push(name, expr.serialize());
    }
    serialized.push(this.result.serialize());
    return serialized;
};

var At = function At(type, index, input) {
    this.type = type;
    this.index = index;
    this.input = input;
};
At.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var index = context.parse(args[1], 1, NumberType);
    var input = context.parse(args[2], 2, array(context.expectedType || ValueType));
    if (!index || !input) {
        return null;
    }
    var t = input.type;
    return new At(t.itemType, index, input);
};
At.prototype.evaluate = function evaluate(ctx) {
    var index = this.index.evaluate(ctx);
    var array = this.input.evaluate(ctx);
    if (index < 0) {
        throw new RuntimeError('Array index out of bounds: ' + index + ' < 0.');
    }
    if (index >= array.length) {
        throw new RuntimeError('Array index out of bounds: ' + index + ' > ' + (array.length - 1) + '.');
    }
    if (index !== Math.floor(index)) {
        throw new RuntimeError('Array index must be an integer, but found ' + index + ' instead.');
    }
    return array[index];
};
At.prototype.eachChild = function eachChild(fn) {
    fn(this.index);
    fn(this.input);
};
At.prototype.outputDefined = function outputDefined() {
    return false;
};
At.prototype.serialize = function serialize() {
    return ['at', this.index.serialize(), this.input.serialize()];
};

var In = function In(needle, haystack) {
    this.type = BooleanType;
    this.needle = needle;
    this.haystack = haystack;
};
In.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack) {
        return null;
    }
    if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');
    }
    return new In(needle, haystack);
};
In.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);
    if (!haystack) {
        return false;
    }
    if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
        throw new RuntimeError('Expected first argument to be of type boolean, string, number or null, but found ' + toString(typeOf(needle)) + ' instead.');
    }
    if (!isValidNativeType(haystack, ['string', 'array'])) {
        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');
    }
    return haystack.indexOf(needle) >= 0;
};
In.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
};
In.prototype.outputDefined = function outputDefined() {
    return true;
};
In.prototype.serialize = function serialize() {
    return ['in', this.needle.serialize(), this.haystack.serialize()];
};

var IndexOf = function IndexOf(needle, haystack, fromIndex) {
    this.type = NumberType;
    this.needle = needle;
    this.haystack = haystack;
    this.fromIndex = fromIndex;
};
IndexOf.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
        return context.error('Expected 3 or 4 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack) {
        return null;
    }
    if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');
    }
    if (args.length === 4) {
        var fromIndex = context.parse(args[3], 3, NumberType);
        if (!fromIndex) {
            return null;
        }
        return new IndexOf(needle, haystack, fromIndex);
    } else {
        return new IndexOf(needle, haystack);
    }
};
IndexOf.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);
    if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
        throw new RuntimeError('Expected first argument to be of type boolean, string, number or null, but found ' + toString(typeOf(needle)) + ' instead.');
    }
    if (!isValidNativeType(haystack, ['string', 'array'])) {
        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');
    }
    if (this.fromIndex) {
        var fromIndex = this.fromIndex.evaluate(ctx);
        return haystack.indexOf(needle, fromIndex);
    }
    return haystack.indexOf(needle);
};
IndexOf.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
    if (this.fromIndex) {
        fn(this.fromIndex);
    }
};
IndexOf.prototype.outputDefined = function outputDefined() {
    return false;
};
IndexOf.prototype.serialize = function serialize() {
    if (this.fromIndex != null && this.fromIndex !== undefined) {
        var fromIndex = this.fromIndex.serialize();
        return ['index-of', this.needle.serialize(), this.haystack.serialize(), fromIndex];
    }
    return ['index-of', this.needle.serialize(), this.haystack.serialize()];
};

var Match = function Match(inputType, outputType, input, cases, outputs, otherwise) {
    this.inputType = inputType;
    this.type = outputType;
    this.input = input;
    this.cases = cases;
    this.outputs = outputs;
    this.otherwise = otherwise;
};
Match.parse = function parse(args, context) {
    if (args.length < 5) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if (args.length % 2 !== 1) {
        return context.error('Expected an even number of arguments.');
    }
    var inputType;
    var outputType;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    var cases = {};
    var outputs = [];
    for (var i = 2; i < args.length - 1; i += 2) {
        var labels = args[i];
        var value = args[i + 1];
        if (!Array.isArray(labels)) {
            labels = [labels];
        }
        var labelContext = context.concat(i);
        if (labels.length === 0) {
            return labelContext.error('Expected at least one branch label.');
        }
        for (var i$1 = 0, list = labels; i$1 < list.length; i$1 += 1) {
            var label = list[i$1];
            if (typeof label !== 'number' && typeof label !== 'string') {
                return labelContext.error('Branch labels must be numbers or strings.');
            } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
                return labelContext.error('Branch labels must be integers no larger than ' + Number.MAX_SAFE_INTEGER + '.');
            } else if (typeof label === 'number' && Math.floor(label) !== label) {
                return labelContext.error('Numeric branch labels must be integer values.');
            } else if (!inputType) {
                inputType = typeOf(label);
            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
                return null;
            }
            if (typeof cases[String(label)] !== 'undefined') {
                return labelContext.error('Branch labels must be unique.');
            }
            cases[String(label)] = outputs.length;
        }
        var result = context.parse(value, i, outputType);
        if (!result) {
            return null;
        }
        outputType = outputType || result.type;
        outputs.push(result);
    }
    var input = context.parse(args[1], 1, ValueType);
    if (!input) {
        return null;
    }
    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) {
        return null;
    }
    if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {
        return null;
    }
    return new Match(inputType, outputType, input, cases, outputs, otherwise);
};
Match.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
    return output.evaluate(ctx);
};
Match.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    this.outputs.forEach(fn);
    fn(this.otherwise);
};
Match.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    }) && this.otherwise.outputDefined();
};
Match.prototype.serialize = function serialize() {
    var this$1 = this;
    var serialized = ['match', this.input.serialize()];
    var sortedLabels = Object.keys(this.cases).sort();
    var groupedByOutput = [];
    var outputLookup = {};
    for (var i = 0, list = sortedLabels; i < list.length; i += 1) {
        var label = list[i];
        var outputIndex = outputLookup[this.cases[label]];
        if (outputIndex === undefined) {
            outputLookup[this.cases[label]] = groupedByOutput.length;
            groupedByOutput.push([this.cases[label], [label]]);
        } else {
            groupedByOutput[outputIndex][1].push(label);
        }
    }
    var coerceLabel = function coerceLabel(label) {
        return this$1.inputType.kind === 'number' ? Number(label) : label;
    };
    for (var i$1 = 0, list$1 = groupedByOutput; i$1 < list$1.length; i$1 += 1) {
        var ref = list$1[i$1];
        var outputIndex = ref[0];
        var labels = ref[1];
        if (labels.length === 1) {
            serialized.push(coerceLabel(labels[0]));
        } else {
            serialized.push(labels.map(coerceLabel));
        }
        serialized.push(this.outputs[outputIndex$1].serialize());
    }
    serialized.push(this.otherwise.serialize());
    return serialized;
};

var Case = function Case(type, branches, otherwise) {
    this.type = type;
    this.branches = branches;
    this.otherwise = otherwise;
};
Case.parse = function parse(args, context) {
    if (args.length < 4) {
        return context.error('Expected at least 3 arguments, but found only ' + (args.length - 1) + '.');
    }
    if (args.length % 2 !== 0) {
        return context.error('Expected an odd number of arguments.');
    }
    var outputType;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    var branches = [];
    for (var i = 1; i < args.length - 1; i += 2) {
        var test = context.parse(args[i], i, BooleanType);
        if (!test) {
            return null;
        }
        var result = context.parse(args[i + 1], i + 1, outputType);
        if (!result) {
            return null;
        }
        branches.push([test, result]);
        outputType = outputType || result.type;
    }
    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) {
        return null;
    }
    return new Case(outputType, branches, otherwise);
};
Case.prototype.evaluate = function evaluate(ctx) {
    for (var i = 0, list = this.branches; i < list.length; i += 1) {
        var ref = list[i];
        var test = ref[0];
        var expression = ref[1];
        if (test.evaluate(ctx)) {
            return expression.evaluate(ctx);
        }
    }
    return this.otherwise.evaluate(ctx);
};
Case.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.branches; i < list.length; i += 1) {
        var ref = list[i];
        var test = ref[0];
        var expression = ref[1];
        fn(test);
        fn(expression);
    }
    fn(this.otherwise);
};
Case.prototype.outputDefined = function outputDefined() {
    return this.branches.every(function (ref) {
        var _ = ref[0];
        var out = ref[1];
        return out.outputDefined();
    }) && this.otherwise.outputDefined();
};
Case.prototype.serialize = function serialize() {
    var serialized = ['case'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var Slice = function Slice(type, input, beginIndex, endIndex) {
    this.type = type;
    this.input = input;
    this.beginIndex = beginIndex;
    this.endIndex = endIndex;
};
Slice.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
        return context.error('Expected 3 or 4 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var input = context.parse(args[1], 1, ValueType);
    var beginIndex = context.parse(args[2], 2, NumberType);
    if (!input || !beginIndex) {
        return null;
    }
    if (!isValidType(input.type, [array(ValueType), StringType, ValueType])) {
        return context.error('Expected first argument to be of type array or string, but found ' + toString(input.type) + ' instead');
    }
    if (args.length === 4) {
        var endIndex = context.parse(args[3], 3, NumberType);
        if (!endIndex) {
            return null;
        }
        return new Slice(input.type, input, beginIndex, endIndex);
    } else {
        return new Slice(input.type, input, beginIndex);
    }
};
Slice.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var beginIndex = this.beginIndex.evaluate(ctx);
    if (!isValidNativeType(input, ['string', 'array'])) {
        throw new RuntimeError('Expected first argument to be of type array or string, but found ' + toString(typeOf(input)) + ' instead.');
    }
    if (this.endIndex) {
        var endIndex = this.endIndex.evaluate(ctx);
        return input.slice(beginIndex, endIndex);
    }
    return input.slice(beginIndex);
};
Slice.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    fn(this.beginIndex);
    if (this.endIndex) {
        fn(this.endIndex);
    }
};
Slice.prototype.outputDefined = function outputDefined() {
    return false;
};
Slice.prototype.serialize = function serialize() {
    if (this.endIndex != null && this.endIndex !== undefined) {
        var endIndex = this.endIndex.serialize();
        return ['slice', this.input.serialize(), this.beginIndex.serialize(), endIndex];
    }
    return ['slice', this.input.serialize(), this.beginIndex.serialize()];
};

function isComparableType(op, type) {
    if (op === '==' || op === '!=') {
        return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';
    } else {
        return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';
    }
}
function eq(ctx, a, b) {
    return a === b;
}
function neq(ctx, a, b) {
    return a !== b;
}
function lt(ctx, a, b) {
    return a < b;
}
function gt(ctx, a, b) {
    return a > b;
}
function lteq(ctx, a, b) {
    return a <= b;
}
function gteq(ctx, a, b) {
    return a >= b;
}
function eqCollate(ctx, a, b, c) {
    return c.compare(a, b) === 0;
}
function neqCollate(ctx, a, b, c) {
    return !eqCollate(ctx, a, b, c);
}
function ltCollate(ctx, a, b, c) {
    return c.compare(a, b) < 0;
}
function gtCollate(ctx, a, b, c) {
    return c.compare(a, b) > 0;
}
function lteqCollate(ctx, a, b, c) {
    return c.compare(a, b) <= 0;
}
function gteqCollate(ctx, a, b, c) {
    return c.compare(a, b) >= 0;
}
function makeComparison(op, compareBasic, compareWithCollator) {
    var isOrderComparison = op !== '==' && op !== '!=';
    return function () {
        function Comparison(lhs, rhs, collator) {
            this.type = BooleanType;
            this.lhs = lhs;
            this.rhs = rhs;
            this.collator = collator;
            this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';
        }
        Comparison.parse = function parse(args, context) {
            if (args.length !== 3 && args.length !== 4) {
                return context.error('Expected two or three arguments.');
            }
            var op = args[0];
            var lhs = context.parse(args[1], 1, ValueType);
            if (!lhs) {
                return null;
            }
            if (!isComparableType(op, lhs.type)) {
                return context.concat(1).error('"' + op + '" comparisons are not supported for type \'' + toString(lhs.type) + '\'.');
            }
            var rhs = context.parse(args[2], 2, ValueType);
            if (!rhs) {
                return null;
            }
            if (!isComparableType(op, rhs.type)) {
                return context.concat(2).error('"' + op + '" comparisons are not supported for type \'' + toString(rhs.type) + '\'.');
            }
            if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                return context.error('Cannot compare types \'' + toString(lhs.type) + '\' and \'' + toString(rhs.type) + '\'.');
            }
            if (isOrderComparison) {
                if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {
                    lhs = new Assertion(rhs.type, [lhs]);
                } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {
                    rhs = new Assertion(lhs.type, [rhs]);
                }
            }
            var collator = null;
            if (args.length === 4) {
                if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                    return context.error('Cannot use collator to compare non-string types.');
                }
                collator = context.parse(args[3], 3, CollatorType);
                if (!collator) {
                    return null;
                }
            }
            return new Comparison(lhs, rhs, collator);
        };
        Comparison.prototype.evaluate = function evaluate(ctx) {
            var lhs = this.lhs.evaluate(ctx);
            var rhs = this.rhs.evaluate(ctx);
            if (isOrderComparison && this.hasUntypedArgument) {
                var lt = typeOf(lhs);
                var rt = typeOf(rhs);
                if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {
                    throw new RuntimeError('Expected arguments for "' + op + '" to be (string, string) or (number, number), but found (' + lt.kind + ', ' + rt.kind + ') instead.');
                }
            }
            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
                var lt$1 = typeOf(lhs);
                var rt$1 = typeOf(rhs);
                if (lt$1.kind !== 'string' || rt$1.kind !== 'string') {
                    return compareBasic(ctx, lhs, rhs);
                }
            }
            return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
        };
        Comparison.prototype.eachChild = function eachChild(fn) {
            fn(this.lhs);
            fn(this.rhs);
            if (this.collator) {
                fn(this.collator);
            }
        };
        Comparison.prototype.outputDefined = function outputDefined() {
            return true;
        };
        Comparison.prototype.serialize = function serialize() {
            var serialized = [op];
            this.eachChild(function (child) {
                serialized.push(child.serialize());
            });
            return serialized;
        };
        return Comparison;
    }();
}
var Equals = makeComparison('==', eq, eqCollate);
var NotEquals = makeComparison('!=', neq, neqCollate);
var LessThan = makeComparison('<', lt, ltCollate);
var GreaterThan = makeComparison('>', gt, gtCollate);
var LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);
var GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);

var NumberFormat = function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {
    this.type = StringType;
    this.number = number;
    this.locale = locale;
    this.currency = currency;
    this.minFractionDigits = minFractionDigits;
    this.maxFractionDigits = maxFractionDigits;
};
NumberFormat.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected two arguments.');
    }
    var number = context.parse(args[1], 1, NumberType);
    if (!number) {
        return null;
    }
    var options = args[2];
    if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== 'object' || Array.isArray(options)) {
        return context.error('NumberFormat options argument must be an object.');
    }
    var locale = null;
    if (options['locale']) {
        locale = context.parse(options['locale'], 1, StringType);
        if (!locale) {
            return null;
        }
    }
    var currency = null;
    if (options['currency']) {
        currency = context.parse(options['currency'], 1, StringType);
        if (!currency) {
            return null;
        }
    }
    var minFractionDigits = null;
    if (options['min-fraction-digits']) {
        minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);
        if (!minFractionDigits) {
            return null;
        }
    }
    var maxFractionDigits = null;
    if (options['max-fraction-digits']) {
        maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);
        if (!maxFractionDigits) {
            return null;
        }
    }
    return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);
};
NumberFormat.prototype.evaluate = function evaluate(ctx) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
        style: this.currency ? 'currency' : 'decimal',
        currency: this.currency ? this.currency.evaluate(ctx) : undefined,
        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
    }).format(this.number.evaluate(ctx));
};
NumberFormat.prototype.eachChild = function eachChild(fn) {
    fn(this.number);
    if (this.locale) {
        fn(this.locale);
    }
    if (this.currency) {
        fn(this.currency);
    }
    if (this.minFractionDigits) {
        fn(this.minFractionDigits);
    }
    if (this.maxFractionDigits) {
        fn(this.maxFractionDigits);
    }
};
NumberFormat.prototype.outputDefined = function outputDefined() {
    return false;
};
NumberFormat.prototype.serialize = function serialize() {
    var options = {};
    if (this.locale) {
        options['locale'] = this.locale.serialize();
    }
    if (this.currency) {
        options['currency'] = this.currency.serialize();
    }
    if (this.minFractionDigits) {
        options['min-fraction-digits'] = this.minFractionDigits.serialize();
    }
    if (this.maxFractionDigits) {
        options['max-fraction-digits'] = this.maxFractionDigits.serialize();
    }
    return ['number-format', this.number.serialize(), options];
};

var Length = function Length(input) {
    this.type = NumberType;
    this.input = input;
};
Length.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected 1 argument, but found ' + (args.length - 1) + ' instead.');
    }
    var input = context.parse(args[1], 1);
    if (!input) {
        return null;
    }
    if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value') {
        return context.error('Expected argument of type string or array, but found ' + toString(input.type) + ' instead.');
    }
    return new Length(input);
};
Length.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    if (typeof input === 'string') {
        return input.length;
    } else if (Array.isArray(input)) {
        return input.length;
    } else {
        throw new RuntimeError('Expected value to be of type string or array, but found ' + toString(typeOf(input)) + ' instead.');
    }
};
Length.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
};
Length.prototype.outputDefined = function outputDefined() {
    return false;
};
Length.prototype.serialize = function serialize() {
    var serialized = ['length'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var expressions = {
    '==': Equals,
    '!=': NotEquals,
    '>': GreaterThan,
    '<': LessThan,
    '>=': GreaterThanOrEqual,
    '<=': LessThanOrEqual,
    'array': Assertion,
    'at': At,
    'boolean': Assertion,
    'case': Case,
    'coalesce': Coalesce,
    'collator': CollatorExpression,
    'format': FormatExpression,
    'image': ImageExpression,
    'in': In,
    'index-of': IndexOf,
    'interpolate': Interpolate,
    'interpolate-hcl': Interpolate,
    'interpolate-lab': Interpolate,
    'length': Length,
    'let': Let,
    'literal': Literal,
    'match': Match,
    'number': Assertion,
    'number-format': NumberFormat,
    'object': Assertion,
    'slice': Slice,
    'step': Step,
    'string': Assertion,
    'to-boolean': Coercion,
    'to-color': Coercion,
    'to-number': Coercion,
    'to-string': Coercion,
    'var': Var,
    'within': Within
};
function rgba(ctx, ref) {
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    r = r.evaluate(ctx);
    g = g.evaluate(ctx);
    b = b.evaluate(ctx);
    var alpha = a ? a.evaluate(ctx) : 1;
    var error = validateRGBA(r, g, b, alpha);
    if (error) {
        throw new RuntimeError(error);
    }
    return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
}
function has(key, obj) {
    return key in obj;
}
function get(key, obj) {
    var v = obj[key];
    return typeof v === 'undefined' ? null : v;
}
function binarySearch(v, a, i, j) {
    while (i <= j) {
        var m = i + j >> 1;
        if (a[m] === v) {
            return true;
        }
        if (a[m] > v) {
            j = m - 1;
        } else {
            i = m + 1;
        }
    }
    return false;
}
function varargs(type) {
    return { type: type };
}
CompoundExpression.register(expressions, {
    'error': [ErrorType, [StringType], function (ctx, ref) {
        var v = ref[0];
        throw new RuntimeError(v.evaluate(ctx));
    }],
    'typeof': [StringType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        return toString(typeOf(v.evaluate(ctx)));
    }],
    'to-rgba': [array(NumberType, 4), [ColorType], function (ctx, ref) {
        var v = ref[0];
        return v.evaluate(ctx).toArray();
    }],
    'rgb': [ColorType, [NumberType, NumberType, NumberType], rgba],
    'rgba': [ColorType, [NumberType, NumberType, NumberType, NumberType], rgba],
    'has': {
        type: BooleanType,
        overloads: [[[StringType], function (ctx, ref) {
            var key = ref[0];
            return has(key.evaluate(ctx), ctx.properties());
        }], [[StringType, ObjectType], function (ctx, ref) {
            var key = ref[0];
            var obj = ref[1];
            return has(key.evaluate(ctx), obj.evaluate(ctx));
        }]]
    },
    'get': {
        type: ValueType,
        overloads: [[[StringType], function (ctx, ref) {
            var key = ref[0];
            return get(key.evaluate(ctx), ctx.properties());
        }], [[StringType, ObjectType], function (ctx, ref) {
            var key = ref[0];
            var obj = ref[1];
            return get(key.evaluate(ctx), obj.evaluate(ctx));
        }]]
    },
    'feature-state': [ValueType, [StringType], function (ctx, ref) {
        var key = ref[0];
        return get(key.evaluate(ctx), ctx.featureState || {});
    }],
    'properties': [ObjectType, [], function (ctx) {
        return ctx.properties();
    }],
    'geometry-type': [StringType, [], function (ctx) {
        return ctx.geometryType();
    }],
    'id': [ValueType, [], function (ctx) {
        return ctx.id();
    }],
    'zoom': [NumberType, [], function (ctx) {
        return ctx.globals.zoom;
    }],
    'heatmap-density': [NumberType, [], function (ctx) {
        return ctx.globals.heatmapDensity || 0;
    }],
    'line-progress': [NumberType, [], function (ctx) {
        return ctx.globals.lineProgress || 0;
    }],
    'accumulated': [ValueType, [], function (ctx) {
        return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;
    }],
    '+': [NumberType, varargs(NumberType), function (ctx, args) {
        var result = 0;
        for (var i = 0, list = args; i < list.length; i += 1) {
            var arg = list[i];
            result += arg.evaluate(ctx);
        }
        return result;
    }],
    '*': [NumberType, varargs(NumberType), function (ctx, args) {
        var result = 1;
        for (var i = 0, list = args; i < list.length; i += 1) {
            var arg = list[i];
            result *= arg.evaluate(ctx);
        }
        return result;
    }],
    '-': {
        type: NumberType,
        overloads: [[[NumberType, NumberType], function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) - b.evaluate(ctx);
        }], [[NumberType], function (ctx, ref) {
            var a = ref[0];
            return -a.evaluate(ctx);
        }]]
    },
    '/': [NumberType, [NumberType, NumberType], function (ctx, ref) {
        var a = ref[0];
        var b = ref[1];
        return a.evaluate(ctx) / b.evaluate(ctx);
    }],
    '%': [NumberType, [NumberType, NumberType], function (ctx, ref) {
        var a = ref[0];
        var b = ref[1];
        return a.evaluate(ctx) % b.evaluate(ctx);
    }],
    'ln2': [NumberType, [], function () {
        return Math.LN2;
    }],
    'pi': [NumberType, [], function () {
        return Math.PI;
    }],
    'e': [NumberType, [], function () {
        return Math.E;
    }],
    '^': [NumberType, [NumberType, NumberType], function (ctx, ref) {
        var b = ref[0];
        var e = ref[1];
        return Math.pow(b.evaluate(ctx), e.evaluate(ctx));
    }],
    'sqrt': [NumberType, [NumberType], function (ctx, ref) {
        var x = ref[0];
        return Math.sqrt(x.evaluate(ctx));
    }],
    'log10': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.log(n.evaluate(ctx)) / Math.LN10;
    }],
    'ln': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.log(n.evaluate(ctx));
    }],
    'log2': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.log(n.evaluate(ctx)) / Math.LN2;
    }],
    'sin': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.sin(n.evaluate(ctx));
    }],
    'cos': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.cos(n.evaluate(ctx));
    }],
    'tan': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.tan(n.evaluate(ctx));
    }],
    'asin': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.asin(n.evaluate(ctx));
    }],
    'acos': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.acos(n.evaluate(ctx));
    }],
    'atan': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.atan(n.evaluate(ctx));
    }],
    'min': [NumberType, varargs(NumberType), function (ctx, args) {
        return Math.min.apply(Math, args.map(function (arg) {
            return arg.evaluate(ctx);
        }));
    }],
    'max': [NumberType, varargs(NumberType), function (ctx, args) {
        return Math.max.apply(Math, args.map(function (arg) {
            return arg.evaluate(ctx);
        }));
    }],
    'abs': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.abs(n.evaluate(ctx));
    }],
    'round': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        var v = n.evaluate(ctx);
        return v < 0 ? -Math.round(-v) : Math.round(v);
    }],
    'floor': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.floor(n.evaluate(ctx));
    }],
    'ceil': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.ceil(n.evaluate(ctx));
    }],
    'filter-==': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        return ctx.properties()[k.value] === v.value;
    }],
    'filter-id-==': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        return ctx.id() === v.value;
    }],
    'filter-type-==': [BooleanType, [StringType], function (ctx, ref) {
        var v = ref[0];
        return ctx.geometryType() === v.value;
    }],
    'filter-<': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a < b;
    }],
    'filter-id-<': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a < b;
    }],
    'filter->': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a > b;
    }],
    'filter-id->': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a > b;
    }],
    'filter-<=': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a <= b;
    }],
    'filter-id-<=': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a <= b;
    }],
    'filter->=': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a >= b;
    }],
    'filter-id->=': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a >= b;
    }],
    'filter-has': [BooleanType, [ValueType], function (ctx, ref) {
        var k = ref[0];
        return k.value in ctx.properties();
    }],
    'filter-has-id': [BooleanType, [], function (ctx) {
        return ctx.id() !== null && ctx.id() !== undefined;
    }],
    'filter-type-in': [BooleanType, [array(StringType)], function (ctx, ref) {
        var v = ref[0];
        return v.value.indexOf(ctx.geometryType()) >= 0;
    }],
    'filter-id-in': [BooleanType, [array(ValueType)], function (ctx, ref) {
        var v = ref[0];
        return v.value.indexOf(ctx.id()) >= 0;
    }],
    'filter-in-small': [BooleanType, [StringType, array(ValueType)], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        return v.value.indexOf(ctx.properties()[k.value]) >= 0;
    }],
    'filter-in-large': [BooleanType, [StringType, array(ValueType)], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);
    }],
    'all': {
        type: BooleanType,
        overloads: [[[BooleanType, BooleanType], function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) && b.evaluate(ctx);
        }], [varargs(BooleanType), function (ctx, args) {
            for (var i = 0, list = args; i < list.length; i += 1) {
                var arg = list[i];
                if (!arg.evaluate(ctx)) {
                    return false;
                }
            }
            return true;
        }]]
    },
    'any': {
        type: BooleanType,
        overloads: [[[BooleanType, BooleanType], function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) || b.evaluate(ctx);
        }], [varargs(BooleanType), function (ctx, args) {
            for (var i = 0, list = args; i < list.length; i += 1) {
                var arg = list[i];
                if (arg.evaluate(ctx)) {
                    return true;
                }
            }
            return false;
        }]]
    },
    '!': [BooleanType, [BooleanType], function (ctx, ref) {
        var b = ref[0];
        return !b.evaluate(ctx);
    }],
    'is-supported-script': [BooleanType, [StringType], function (ctx, ref) {
        var s = ref[0];
        var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;
        if (isSupportedScript) {
            return isSupportedScript(s.evaluate(ctx));
        }
        return true;
    }],
    'upcase': [StringType, [StringType], function (ctx, ref) {
        var s = ref[0];
        return s.evaluate(ctx).toUpperCase();
    }],
    'downcase': [StringType, [StringType], function (ctx, ref) {
        var s = ref[0];
        return s.evaluate(ctx).toLowerCase();
    }],
    'concat': [StringType, varargs(ValueType), function (ctx, args) {
        return args.map(function (arg) {
            return toString$1(arg.evaluate(ctx));
        }).join('');
    }],
    'resolved-locale': [StringType, [CollatorType], function (ctx, ref) {
        var collator = ref[0];
        return collator.evaluate(ctx).resolvedLocale();
    }]
});

function success(value) {
    return {
        result: 'success',
        value: value
    };
}
function error(value) {
    return {
        result: 'error',
        value: value
    };
}

function supportsPropertyExpression(spec) {
    return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';
}
function supportsZoomExpression(spec) {
    return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;
}
function supportsInterpolation(spec) {
    return !!spec.expression && spec.expression.interpolated;
}

function getType(val) {
    if (val instanceof Number) {
        return 'number';
    } else if (val instanceof String) {
        return 'string';
    } else if (val instanceof Boolean) {
        return 'boolean';
    } else if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val === "undefined" ? "undefined" : _typeof(val);
    }
}

function isFunction$1(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && value !== null && !Array.isArray(value);
}
function identityFunction(x) {
    return x;
}
function createFunction(parameters, propertySpec) {
    var isColor = propertySpec.type === 'color';
    var zoomAndFeatureDependent = parameters.stops && _typeof(parameters.stops[0][0]) === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    var type = parameters.type || (supportsInterpolation(propertySpec) ? 'exponential' : 'interval');
    if (isColor) {
        parameters = extend({}, parameters);
        if (parameters.stops) {
            parameters.stops = parameters.stops.map(function (stop) {
                return [stop[0], Color.parse(stop[1])];
            });
        }
        if (parameters.default) {
            parameters.default = Color.parse(parameters.default);
        } else {
            parameters.default = Color.parse(propertySpec.default);
        }
    }
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb' && !colorSpaces[parameters.colorSpace]) {
        throw new Error('Unknown color space: ' + parameters.colorSpace);
    }
    var innerFun;
    var hashedStops;
    var categoricalKeyType;
    if (type === 'exponential') {
        innerFun = evaluateExponentialFunction;
    } else if (type === 'interval') {
        innerFun = evaluateIntervalFunction;
    } else if (type === 'categorical') {
        innerFun = evaluateCategoricalFunction;
        hashedStops = Object.create(null);
        for (var i = 0, list = parameters.stops; i < list.length; i += 1) {
            var stop = list[i];
            hashedStops[stop[0]] = stop[1];
        }
        categoricalKeyType = _typeof(parameters.stops[0][0]);
    } else if (type === 'identity') {
        innerFun = evaluateIdentityFunction;
    } else {
        throw new Error('Unknown function type "' + type + '"');
    }
    if (zoomAndFeatureDependent) {
        var featureFunctions = {};
        var zoomStops = [];
        for (var s = 0; s < parameters.stops.length; s++) {
            var stop$1 = parameters.stops[s];
            var zoom = stop$1[0].zoom;
            if (featureFunctions[zoom] === undefined) {
                featureFunctions[zoom] = {
                    zoom: zoom,
                    type: parameters.type,
                    property: parameters.property,
                    default: parameters.default,
                    stops: []
                };
                zoomStops.push(zoom);
            }
            featureFunctions[zoom].stops.push([stop$1[0].value, stop$1[1]]);
        }
        var featureFunctionStops = [];
        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {
            var z = list$1[i$1];
            featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);
        }
        var interpolationType = { name: 'linear' };
        return {
            kind: 'composite',
            interpolationType: interpolationType,
            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),
            zoomStops: featureFunctionStops.map(function (s) {
                return s[0];
            }),
            evaluate: function evaluate(ref, properties) {
                var zoom = ref.zoom;
                return evaluateExponentialFunction({
                    stops: featureFunctionStops,
                    base: parameters.base
                }, propertySpec, zoom).evaluate(zoom, properties);
            }
        };
    } else if (zoomDependent) {
        var interpolationType$1 = type === 'exponential' ? {
            name: 'exponential',
            base: parameters.base !== undefined ? parameters.base : 1
        } : null;
        return {
            kind: 'camera',
            interpolationType: interpolationType$1,
            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType$1),
            zoomStops: parameters.stops.map(function (s) {
                return s[0];
            }),
            evaluate: function evaluate(ref) {
                var zoom = ref.zoom;
                return innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType);
            }
        };
    } else {
        return {
            kind: 'source',
            evaluate: function evaluate(_, feature) {
                var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;
                if (value === undefined) {
                    return coalesce(parameters.default, propertySpec.default);
                }
                return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);
            }
        };
    }
}
function coalesce(a, b, c) {
    if (a !== undefined) {
        return a;
    }
    if (b !== undefined) {
        return b;
    }
    if (c !== undefined) {
        return c;
    }
}
function evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {
    var evaluated = (typeof input === "undefined" ? "undefined" : _typeof(input)) === keyType ? hashedStops[input] : undefined;
    return coalesce(evaluated, parameters.default, propertySpec.default);
}
function evaluateIntervalFunction(parameters, propertySpec, input) {
    if (getType(input) !== 'number') {
        return coalesce(parameters.default, propertySpec.default);
    }
    var n = parameters.stops.length;
    if (n === 1) {
        return parameters.stops[0][1];
    }
    if (input <= parameters.stops[0][0]) {
        return parameters.stops[0][1];
    }
    if (input >= parameters.stops[n - 1][0]) {
        return parameters.stops[n - 1][1];
    }
    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
        return stop[0];
    }), input);
    return parameters.stops[index][1];
}
function evaluateExponentialFunction(parameters, propertySpec, input) {
    var base = parameters.base !== undefined ? parameters.base : 1;
    if (getType(input) !== 'number') {
        return coalesce(parameters.default, propertySpec.default);
    }
    var n = parameters.stops.length;
    if (n === 1) {
        return parameters.stops[0][1];
    }
    if (input <= parameters.stops[0][0]) {
        return parameters.stops[0][1];
    }
    if (input >= parameters.stops[n - 1][0]) {
        return parameters.stops[n - 1][1];
    }
    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
        return stop[0];
    }), input);
    var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);
    var outputLower = parameters.stops[index][1];
    var outputUpper = parameters.stops[index + 1][1];
    var interp = interpolate[propertySpec.type] || identityFunction;
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {
        var colorspace = colorSpaces[parameters.colorSpace];
        interp = function interp(a, b) {
            return colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));
        };
    }
    if (typeof outputLower.evaluate === 'function') {
        return {
            evaluate: function evaluate() {
                var args = [],
                    len = arguments.length;
                while (len--) {
                    args[len] = arguments[len];
                }var evaluatedLower = outputLower.evaluate.apply(undefined, args);
                var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);
                if (evaluatedLower === undefined || evaluatedUpper === undefined) {
                    return undefined;
                }
                return interp(evaluatedLower, evaluatedUpper, t);
            }
        };
    }
    return interp(outputLower, outputUpper, t);
}
function evaluateIdentityFunction(parameters, propertySpec, input) {
    if (propertySpec.type === 'color') {
        input = Color.parse(input);
    } else if (propertySpec.type === 'formatted') {
        input = Formatted.fromString(input.toString());
    } else if (propertySpec.type === 'resolvedImage') {
        input = ResolvedImage.fromString(input.toString());
    } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {
        input = undefined;
    }
    return coalesce(input, parameters.default, propertySpec.default);
}
function interpolationFactor(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

var StyleExpression = function StyleExpression(expression, propertySpec) {
    this.expression = expression;
    this._warningHistory = {};
    this._evaluator = new EvaluationContext();
    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;
    this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;
};
StyleExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature;
    this._evaluator.featureState = featureState;
    this._evaluator.canonical = canonical;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection;
    return this.expression.evaluate(this._evaluator);
};
StyleExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature || null;
    this._evaluator.featureState = featureState || null;
    this._evaluator.canonical = canonical;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection || null;
    try {
        var val = this.expression.evaluate(this._evaluator);
        if (val === null || val === undefined || typeof val === 'number' && val !== val) {
            return this._defaultValue;
        }
        if (this._enumValues && !(val in this._enumValues)) {
            throw new RuntimeError('Expected value to be one of ' + Object.keys(this._enumValues).map(function (v) {
                return JSON.stringify(v);
            }).join(', ') + ', but found ' + JSON.stringify(val) + ' instead.');
        }
        return val;
    } catch (e) {
        if (!this._warningHistory[e.message]) {
            this._warningHistory[e.message] = true;
            if (typeof console !== 'undefined') {
                console.warn(e.message);
            }
        }
        return this._defaultValue;
    }
};
function isExpression(expression) {
    return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in expressions;
}
function createExpression(expression, propertySpec) {
    var parser = new ParsingContext(expressions, [], propertySpec ? getExpectedType(propertySpec) : undefined);
    var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? { typeAnnotation: 'coerce' } : undefined);
    if (!parsed) {
        return error(parser.errors);
    }
    return success(new StyleExpression(parsed, propertySpec));
}
var ZoomConstantExpression = function ZoomConstantExpression(kind, expression) {
    this.kind = kind;
    this._styleExpression = expression;
    this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);
};
ZoomConstantExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomConstantExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
};
var ZoomDependentExpression = function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {
    this.kind = kind;
    this.zoomStops = zoomStops;
    this._styleExpression = expression;
    this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);
    this.interpolationType = interpolationType;
};
ZoomDependentExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomDependentExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomDependentExpression.prototype.interpolationFactor = function interpolationFactor(input, lower, upper) {
    if (this.interpolationType) {
        return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);
    } else {
        return 0;
    }
};
function createPropertyExpression(expression, propertySpec) {
    expression = createExpression(expression, propertySpec);
    if (expression.result === 'error') {
        return expression;
    }
    var parsed = expression.value.expression;
    var isFeatureConstant$1 = isFeatureConstant(parsed);
    if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {
        return error([new ParsingError('', 'data expressions not supported')]);
    }
    var isZoomConstant = isGlobalPropertyConstant(parsed, ['zoom']);
    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
        return error([new ParsingError('', 'zoom expressions not supported')]);
    }
    var zoomCurve = findZoomCurve(parsed);
    if (!zoomCurve && !isZoomConstant) {
        return error([new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
    } else if (zoomCurve instanceof ParsingError) {
        return error([zoomCurve]);
    } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {
        return error([new ParsingError('', '"interpolate" expressions cannot be used with this property')]);
    }
    if (!zoomCurve) {
        return success(isFeatureConstant$1 ? new ZoomConstantExpression('constant', expression.value) : new ZoomConstantExpression('source', expression.value));
    }
    var interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;
    return success(isFeatureConstant$1 ? new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));
}
var StylePropertyFunction = function StylePropertyFunction(parameters, specification) {
    this._parameters = parameters;
    this._specification = specification;
    extend(this, createFunction(this._parameters, this._specification));
};
StylePropertyFunction.deserialize = function deserialize(serialized) {
    return new StylePropertyFunction(serialized._parameters, serialized._specification);
};
StylePropertyFunction.serialize = function serialize(input) {
    return {
        _parameters: input._parameters,
        _specification: input._specification
    };
};
function normalizePropertyExpression(value, specification) {
    if (isFunction$1(value)) {
        return new StylePropertyFunction(value, specification);
    } else if (isExpression(value)) {
        var expression = createPropertyExpression(value, specification);
        if (expression.result === 'error') {
            throw new Error(expression.value.map(function (err) {
                return err.key + ': ' + err.message;
            }).join(', '));
        }
        return expression.value;
    } else {
        var constant = value;
        if (typeof value === 'string' && specification.type === 'color') {
            constant = Color.parse(value);
        }
        return {
            kind: 'constant',
            evaluate: function evaluate() {
                return constant;
            }
        };
    }
}
function findZoomCurve(expression) {
    var result = null;
    if (expression instanceof Let) {
        result = findZoomCurve(expression.result);
    } else if (expression instanceof Coalesce) {
        for (var i = 0, list = expression.args; i < list.length; i += 1) {
            var arg = list[i];
            result = findZoomCurve(arg);
            if (result) {
                break;
            }
        }
    } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === 'zoom') {
        result = expression;
    }
    if (result instanceof ParsingError) {
        return result;
    }
    expression.eachChild(function (child) {
        var childResult = findZoomCurve(child);
        if (childResult instanceof ParsingError) {
            result = childResult;
        } else if (!result && childResult) {
            result = new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
        } else if (result && childResult && result !== childResult) {
            result = new ParsingError('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
        }
    });
    return result;
}
function getExpectedType(spec) {
    var types = {
        color: ColorType,
        string: StringType,
        number: NumberType,
        enum: StringType,
        boolean: BooleanType,
        formatted: FormattedType,
        resolvedImage: ResolvedImageType
    };
    if (spec.type === 'array') {
        return array(types[spec.value] || ValueType, spec.length);
    }
    return types[spec.type];
}
function getDefaultValue(spec) {
    if (spec.type === 'color' && isFunction$1(spec.default)) {
        return new Color(0, 0, 0, 0);
    } else if (spec.type === 'color') {
        return Color.parse(spec.default) || null;
    } else if (spec.default === undefined) {
        return null;
    } else {
        return spec.default;
    }
}

function convertLiteral(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' ? ['literal', value] : value;
}
function convertFunction(parameters, propertySpec) {
    var stops = parameters.stops;
    if (!stops) {
        return convertIdentityFunction(parameters, propertySpec);
    }
    var zoomAndFeatureDependent = stops && _typeof(stops[0][0]) === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    stops = stops.map(function (stop) {
        if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {
            return [stop[0], convertTokenString(stop[1])];
        }
        return [stop[0], convertLiteral(stop[1])];
    });
    if (zoomAndFeatureDependent) {
        return convertZoomAndPropertyFunction(parameters, propertySpec, stops);
    } else if (zoomDependent) {
        return convertZoomFunction(parameters, propertySpec, stops);
    } else {
        return convertPropertyFunction(parameters, propertySpec, stops);
    }
}
function convertIdentityFunction(parameters, propertySpec) {
    var get = ['get', parameters.property];
    if (parameters.default === undefined) {
        return propertySpec.type === 'string' ? ['string', get] : get;
    } else if (propertySpec.type === 'enum') {
        return ['match', get, Object.keys(propertySpec.values), get, parameters.default];
    } else {
        var expression = [propertySpec.type === 'color' ? 'to-color' : propertySpec.type, get, convertLiteral(parameters.default)];
        if (propertySpec.type === 'array') {
            expression.splice(1, 0, propertySpec.value, propertySpec.length || null);
        }
        return expression;
    }
}
function getInterpolateOperator(parameters) {
    switch (parameters.colorSpace) {
        case 'hcl':
            return 'interpolate-hcl';
        case 'lab':
            return 'interpolate-lab';
        default:
            return 'interpolate';
    }
}
function convertZoomAndPropertyFunction(parameters, propertySpec, stops) {
    var featureFunctionParameters = {};
    var featureFunctionStops = {};
    var zoomStops = [];
    for (var s = 0; s < stops.length; s++) {
        var stop = stops[s];
        var zoom = stop[0].zoom;
        if (featureFunctionParameters[zoom] === undefined) {
            featureFunctionParameters[zoom] = {
                zoom: zoom,
                type: parameters.type,
                property: parameters.property,
                default: parameters.default
            };
            featureFunctionStops[zoom] = [];
            zoomStops.push(zoom);
        }
        featureFunctionStops[zoom].push([stop[0].value, stop[1]]);
    }
    var functionType = getFunctionType({}, propertySpec);
    if (functionType === 'exponential') {
        var expression = [getInterpolateOperator(parameters), ['linear'], ['zoom']];
        for (var i = 0, list = zoomStops; i < list.length; i += 1) {
            var z = list[i];
            var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
            appendStopPair(expression, z, output, false);
        }
        return expression;
    } else {
        var expression$1 = ['step', ['zoom']];
        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {
            var z$1 = list$1[i$1];
            var output$1 = convertPropertyFunction(featureFunctionParameters[z$1], propertySpec, featureFunctionStops[z$1]);
            appendStopPair(expression$1, z$1, output$1, true);
        }
        fixupDegenerateStepCurve(expression$1);
        return expression$1;
    }
}
function coalesce$1(a, b) {
    if (a !== undefined) {
        return a;
    }
    if (b !== undefined) {
        return b;
    }
}
function convertPropertyFunction(parameters, propertySpec, stops) {
    var type = getFunctionType(parameters, propertySpec);
    var get = ['get', parameters.property];
    if (type === 'categorical' && typeof stops[0][0] === 'boolean') {
        var expression = ['case'];
        for (var i = 0, list = stops; i < list.length; i += 1) {
            var stop = list[i];
            expression.push(['==', get, stop[0]], stop[1]);
        }
        expression.push(convertLiteral(coalesce$1(parameters.default, propertySpec.default)));
        return expression;
    } else if (type === 'categorical') {
        var expression$1 = ['match', get];
        for (var i$1 = 0, list$1 = stops; i$1 < list$1.length; i$1 += 1) {
            var stop$1 = list$1[i$1];
            appendStopPair(expression$1, stop$1[0], stop$1[1], false);
        }
        expression$1.push(convertLiteral(coalesce$1(parameters.default, propertySpec.default)));
        return expression$1;
    } else if (type === 'interval') {
        var expression$2 = ['step', ['number', get]];
        for (var i$2 = 0, list$2 = stops; i$2 < list$2.length; i$2 += 1) {
            var stop$2 = list$2[i$2];
            appendStopPair(expression$2, stop$2[0], stop$2[1], true);
        }
        fixupDegenerateStepCurve(expression$2);
        return parameters.default === undefined ? expression$2 : ['case', ['==', ['typeof', get], 'number'], expression$2, convertLiteral(parameters.default)];
    } else if (type === 'exponential') {
        var base = parameters.base !== undefined ? parameters.base : 1;
        var expression$3 = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], ['number', get]];
        for (var i$3 = 0, list$3 = stops; i$3 < list$3.length; i$3 += 1) {
            var stop$3 = list$3[i$3];
            appendStopPair(expression$3, stop$3[0], stop$3[1], false);
        }
        return parameters.default === undefined ? expression$3 : ['case', ['==', ['typeof', get], 'number'], expression$3, convertLiteral(parameters.default)];
    } else {
        throw new Error('Unknown property function type ' + type);
    }
}
function convertZoomFunction(parameters, propertySpec, stops, input) {
    if (input === void 0) input = ['zoom'];
    var type = getFunctionType(parameters, propertySpec);
    var expression;
    var isStep = false;
    if (type === 'interval') {
        expression = ['step', input];
        isStep = true;
    } else if (type === 'exponential') {
        var base = parameters.base !== undefined ? parameters.base : 1;
        expression = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], input];
    } else {
        throw new Error('Unknown zoom function type "' + type + '"');
    }
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var stop = list[i];
        appendStopPair(expression, stop[0], stop[1], isStep);
    }
    fixupDegenerateStepCurve(expression);
    return expression;
}
function fixupDegenerateStepCurve(expression) {
    if (expression[0] === 'step' && expression.length === 3) {
        expression.push(0);
        expression.push(expression[3]);
    }
}
function appendStopPair(curve, input, output, isStep) {
    if (curve.length > 3 && input === curve[curve.length - 2]) {
        return;
    }
    if (!(isStep && curve.length === 2)) {
        curve.push(input);
    }
    curve.push(output);
}
function getFunctionType(parameters, propertySpec) {
    if (parameters.type) {
        return parameters.type;
    } else {
        return propertySpec.expression.interpolated ? 'exponential' : 'interval';
    }
}
function convertTokenString(s) {
    var result = ['concat'];
    var re = /{([^{}]+)}/g;
    var pos = 0;
    for (var match = re.exec(s); match !== null; match = re.exec(s)) {
        var literal = s.slice(pos, re.lastIndex - match[0].length);
        pos = re.lastIndex;
        if (literal.length > 0) {
            result.push(literal);
        }
        result.push(['get', match[1]]);
    }
    if (result.length === 1) {
        return s;
    }
    if (pos < s.length) {
        result.push(s.slice(pos));
    } else if (result.length === 2) {
        return ['to-string', result[1]];
    }
    return result;
}

function isExpressionFilter(filter) {
    if (filter === true || filter === false) {
        return true;
    }
    if (!Array.isArray(filter) || filter.length === 0) {
        return false;
    }
    switch (filter[0]) {
        case 'has':
            return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';
        case 'in':
            return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));
        case '!in':
        case '!has':
        case 'none':
            return false;
        case '==':
        case '!=':
        case '>':
        case '>=':
        case '<':
        case '<=':
            return filter.length !== 3 || Array.isArray(filter[1]) || Array.isArray(filter[2]);
        case 'any':
        case 'all':
            for (var i = 0, list = filter.slice(1); i < list.length; i += 1) {
                var f = list[i];
                if (!isExpressionFilter(f) && typeof f !== 'boolean') {
                    return false;
                }
            }
            return true;
        default:
            return true;
    }
}
var filterSpec = {
    'type': 'boolean',
    'default': false,
    'transition': false,
    'property-type': 'data-driven',
    'expression': {
        'interpolated': false,
        'parameters': ['zoom', 'feature']
    }
};
function createFilter(filter) {
    if (filter === null || filter === undefined) {
        return {
            filter: function filter() {
                return true;
            },
            needGeometry: false
        };
    }
    if (!isExpressionFilter(filter)) {
        filter = convertFilter(filter);
    }
    var compiled = createExpression(filter, filterSpec);
    if (compiled.result === 'error') {
        throw new Error(compiled.value.map(function (err) {
            return err.key + ': ' + err.message;
        }).join(', '));
    } else {
        var needGeometry = Array.isArray(filter) && filter.length !== 0 && filter[0] === 'within';
        return {
            filter: function filter(globalProperties, feature, canonical) {
                return compiled.value.evaluate(globalProperties, feature, {}, canonical);
            },
            needGeometry: needGeometry
        };
    }
}
function compare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
function convertFilter(filter) {
    if (!filter) {
        return true;
    }
    var op = filter[0];
    if (filter.length <= 1) {
        return op !== 'any';
    }
    var converted = op === '==' ? convertComparisonOp(filter[1], filter[2], '==') : op === '!=' ? convertNegation(convertComparisonOp(filter[1], filter[2], '==')) : op === '<' || op === '>' || op === '<=' || op === '>=' ? convertComparisonOp(filter[1], filter[2], op) : op === 'any' ? convertDisjunctionOp(filter.slice(1)) : op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter)) : op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === 'in' ? convertInOp(filter[1], filter.slice(2)) : op === '!in' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === 'has' ? convertHasOp(filter[1]) : op === '!has' ? convertNegation(convertHasOp(filter[1])) : true;
    return converted;
}
function convertComparisonOp(property, value, op) {
    switch (property) {
        case '$type':
            return ['filter-type-' + op, value];
        case '$id':
            return ['filter-id-' + op, value];
        default:
            return ['filter-' + op, property, value];
    }
}
function convertDisjunctionOp(filters) {
    return ['any'].concat(filters.map(convertFilter));
}
function convertInOp(property, values) {
    if (values.length === 0) {
        return false;
    }
    switch (property) {
        case '$type':
            return ['filter-type-in', ['literal', values]];
        case '$id':
            return ['filter-id-in', ['literal', values]];
        default:
            if (values.length > 200 && !values.some(function (v) {
                return (typeof v === "undefined" ? "undefined" : _typeof(v)) !== _typeof(values[0]);
            })) {
                return ['filter-in-large', property, ['literal', values.sort(compare)]];
            } else {
                return ['filter-in-small', property, ['literal', values]];
            }
    }
}
function convertHasOp(property) {
    switch (property) {
        case '$type':
            return true;
        case '$id':
            return ['filter-has-id'];
        default:
            return ['filter-has', property];
    }
}
function convertNegation(filter) {
    return ['!', filter];
}

function convertFilter$1(filter) {
    return _convertFilter(filter, {});
}
function _convertFilter(filter, expectedTypes) {
    var ref$1;
    if (isExpressionFilter(filter)) {
        return filter;
    }
    if (!filter) {
        return true;
    }
    var op = filter[0];
    if (filter.length <= 1) {
        return op !== 'any';
    }
    var converted;
    if (op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=') {
        var ref = filter;
        var property = ref[1];
        var value = ref[2];
        converted = convertComparisonOp$1(property, value, op, expectedTypes);
    } else if (op === 'any') {
        var children = filter.slice(1).map(function (f) {
            var types = {};
            var child = _convertFilter(f, types);
            var typechecks = runtimeTypeChecks(types);
            return typechecks === true ? child : ['case', typechecks, child, false];
        });
        return ['any'].concat(children);
    } else if (op === 'all') {
        var children$1 = filter.slice(1).map(function (f) {
            return _convertFilter(f, expectedTypes);
        });
        return children$1.length > 1 ? ['all'].concat(children$1) : (ref$1 = []).concat.apply(ref$1, children$1);
    } else if (op === 'none') {
        return ['!', _convertFilter(['any'].concat(filter.slice(1)), {})];
    } else if (op === 'in') {
        converted = convertInOp$1(filter[1], filter.slice(2));
    } else if (op === '!in') {
        converted = convertInOp$1(filter[1], filter.slice(2), true);
    } else if (op === 'has') {
        converted = convertHasOp$1(filter[1]);
    } else if (op === '!has') {
        converted = ['!', convertHasOp$1(filter[1])];
    } else {
        converted = true;
    }
    return converted;
}
function runtimeTypeChecks(expectedTypes) {
    var conditions = [];
    for (var property in expectedTypes) {
        var get = property === '$id' ? ['id'] : ['get', property];
        conditions.push(['==', ['typeof', get], expectedTypes[property]]);
    }
    if (conditions.length === 0) {
        return true;
    }
    if (conditions.length === 1) {
        return conditions[0];
    }
    return ['all'].concat(conditions);
}
function convertComparisonOp$1(property, value, op, expectedTypes) {
    var get;
    if (property === '$type') {
        return [op, ['geometry-type'], value];
    } else if (property === '$id') {
        get = ['id'];
    } else {
        get = ['get', property];
    }
    if (expectedTypes && value !== null) {
        var type = typeof value === "undefined" ? "undefined" : _typeof(value);
        expectedTypes[property] = type;
    }
    if (op === '==' && property !== '$id' && value === null) {
        return ['all', ['has', property], ['==', get, null]];
    } else if (op === '!=' && property !== '$id' && value === null) {
        return ['any', ['!', ['has', property]], ['!=', get, null]];
    }
    return [op, get, value];
}
function convertInOp$1(property, values, negate) {
    if (negate === void 0) negate = false;
    if (values.length === 0) {
        return negate;
    }
    var get;
    if (property === '$type') {
        get = ['geometry-type'];
    } else if (property === '$id') {
        get = ['id'];
    } else {
        get = ['get', property];
    }
    var uniformTypes = true;
    var type = _typeof(values[0]);
    for (var i = 0, list = values; i < list.length; i += 1) {
        var value = list[i];
        if ((typeof value === "undefined" ? "undefined" : _typeof(value)) !== type) {
            uniformTypes = false;
            break;
        }
    }
    if (uniformTypes && (type === 'string' || type === 'number')) {
        var uniqueValues = values.sort().filter(function (v, i) {
            return i === 0 || values[i - 1] !== v;
        });
        return ['match', get, uniqueValues, !negate, negate];
    }
    return [negate ? 'all' : 'any'].concat(values.map(function (v) {
        return [negate ? '!=' : '==', get, v];
    }));
}
function convertHasOp$1(property) {
    if (property === '$type') {
        return true;
    } else if (property === '$id') {
        return ['!=', ['id'], null];
    } else {
        return ['has', property];
    }
}

function migrateToExpressions(style) {
    var converted = [];
    eachLayer(style, function (layer) {
        if (layer.filter) {
            layer.filter = convertFilter$1(layer.filter);
        }
    });
    eachProperty(style, {
        paint: true,
        layout: true
    }, function (ref) {
        var path = ref.path;
        var value = ref.value;
        var reference = ref.reference;
        var set = ref.set;
        if (isExpression(value)) {
            return;
        }
        if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && !Array.isArray(value)) {
            set(convertFunction(value, reference));
            converted.push(path.join('.'));
        } else if (reference.tokens && typeof value === 'string') {
            set(convertTokenString(value));
        }
    });
    return style;
}

function migrate(style) {
    var migrated = false;
    if (style.version === 7) {
        style = migrateToV8(style);
        migrated = true;
    }
    if (style.version === 8) {
        migrated = migrateToExpressions(style);
        migrated = true;
    }
    if (!migrated) {
        throw new Error('cannot migrate from', style.version);
    }
    return style;
}

function composite(style) {
    var styleIDs = [];
    var sourceIDs = [];
    var compositedSourceLayers = [];
    for (var id in style.sources) {
        var source = style.sources[id];
        if (source.type !== 'vector') {
            continue;
        }
        var match = /^mapbox:\/\/(.*)/.exec(source.url);
        if (!match) {
            continue;
        }
        styleIDs.push(id);
        sourceIDs.push(match[1]);
    }
    if (styleIDs.length < 2) {
        return style;
    }
    styleIDs.forEach(function (id) {
        delete style.sources[id];
    });
    var compositeID = sourceIDs.join(',');
    style.sources[compositeID] = {
        'type': 'vector',
        'url': 'mapbox://' + compositeID
    };
    style.layers.forEach(function (layer) {
        if (styleIDs.indexOf(layer.source) >= 0) {
            layer.source = compositeID;
            if ('source-layer' in layer) {
                if (compositedSourceLayers.indexOf(layer['source-layer']) >= 0) {
                    throw new Error('Conflicting source layer names');
                } else {
                    compositedSourceLayers.push(layer['source-layer']);
                }
            }
        }
    });
    return style;
}

var refProperties = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];

function deref(layer, parent) {
    var result = {};
    for (var k in layer) {
        if (k !== 'ref') {
            result[k] = layer[k];
        }
    }
    refProperties.forEach(function (k) {
        if (k in parent) {
            result[k] = parent[k];
        }
    });
    return result;
}
function derefLayers(layers) {
    layers = layers.slice();
    var map = Object.create(null);
    for (var i = 0; i < layers.length; i++) {
        map[layers[i].id] = layers[i];
    }
    for (var i$1 = 0; i$1 < layers.length; i$1++) {
        if ('ref' in layers[i$1]) {
            layers[i$1] = deref(layers[i$1], map[layers[i$1].ref]);
        }
    }
    return layers;
}

function deepEqual(a, b) {
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    if ((typeof a === "undefined" ? "undefined" : _typeof(a)) === 'object' && a !== null && b !== null) {
        if (!((typeof b === "undefined" ? "undefined" : _typeof(b)) === 'object')) {
            return false;
        }
        var keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) {
            return false;
        }
        for (var key in a) {
            if (!deepEqual(a[key], b[key])) {
                return false;
            }
        }
        return true;
    }
    return a === b;
}

var operations = {
    setStyle: 'setStyle',
    addLayer: 'addLayer',
    removeLayer: 'removeLayer',
    setPaintProperty: 'setPaintProperty',
    setLayoutProperty: 'setLayoutProperty',
    setFilter: 'setFilter',
    addSource: 'addSource',
    removeSource: 'removeSource',
    setGeoJSONSourceData: 'setGeoJSONSourceData',
    setLayerZoomRange: 'setLayerZoomRange',
    setLayerProperty: 'setLayerProperty',
    setCenter: 'setCenter',
    setZoom: 'setZoom',
    setBearing: 'setBearing',
    setPitch: 'setPitch',
    setSprite: 'setSprite',
    setGlyphs: 'setGlyphs',
    setTransition: 'setTransition',
    setLight: 'setLight'
};
function addSource(sourceId, after, commands) {
    commands.push({
        command: operations.addSource,
        args: [sourceId, after[sourceId]]
    });
}
function removeSource(sourceId, commands, sourcesRemoved) {
    commands.push({
        command: operations.removeSource,
        args: [sourceId]
    });
    sourcesRemoved[sourceId] = true;
}
function updateSource(sourceId, after, commands, sourcesRemoved) {
    removeSource(sourceId, commands, sourcesRemoved);
    addSource(sourceId, after, commands);
}
function canUpdateGeoJSON(before, after, sourceId) {
    var prop;
    for (prop in before[sourceId]) {
        if (!before[sourceId].hasOwnProperty(prop)) {
            continue;
        }
        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {
            return false;
        }
    }
    for (prop in after[sourceId]) {
        if (!after[sourceId].hasOwnProperty(prop)) {
            continue;
        }
        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {
            return false;
        }
    }
    return true;
}
function diffSources(before, after, commands, sourcesRemoved) {
    before = before || {};
    after = after || {};
    var sourceId;
    for (sourceId in before) {
        if (!before.hasOwnProperty(sourceId)) {
            continue;
        }
        if (!after.hasOwnProperty(sourceId)) {
            removeSource(sourceId, commands, sourcesRemoved);
        }
    }
    for (sourceId in after) {
        if (!after.hasOwnProperty(sourceId)) {
            continue;
        }
        if (!before.hasOwnProperty(sourceId)) {
            addSource(sourceId, after, commands);
        } else if (!deepEqual(before[sourceId], after[sourceId])) {
            if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson' && canUpdateGeoJSON(before, after, sourceId)) {
                commands.push({
                    command: operations.setGeoJSONSourceData,
                    args: [sourceId, after[sourceId].data]
                });
            } else {
                updateSource(sourceId, after, commands, sourcesRemoved);
            }
        }
    }
}
function diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {
    before = before || {};
    after = after || {};
    var prop;
    for (prop in before) {
        if (!before.hasOwnProperty(prop)) {
            continue;
        }
        if (!deepEqual(before[prop], after[prop])) {
            commands.push({
                command: command,
                args: [layerId, prop, after[prop], klass]
            });
        }
    }
    for (prop in after) {
        if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) {
            continue;
        }
        if (!deepEqual(before[prop], after[prop])) {
            commands.push({
                command: command,
                args: [layerId, prop, after[prop], klass]
            });
        }
    }
}
function pluckId(layer) {
    return layer.id;
}
function indexById(group, layer) {
    group[layer.id] = layer;
    return group;
}
function diffLayers(before, after, commands) {
    before = before || [];
    after = after || [];
    var beforeOrder = before.map(pluckId);
    var afterOrder = after.map(pluckId);
    var beforeIndex = before.reduce(indexById, {});
    var afterIndex = after.reduce(indexById, {});
    var tracker = beforeOrder.slice();
    var clean = Object.create(null);
    var i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;
    for (i = 0, d = 0; i < beforeOrder.length; i++) {
        layerId = beforeOrder[i];
        if (!afterIndex.hasOwnProperty(layerId)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            tracker.splice(tracker.indexOf(layerId, d), 1);
        } else {
            d++;
        }
    }
    for (i = 0, d = 0; i < afterOrder.length; i++) {
        layerId = afterOrder[afterOrder.length - 1 - i];
        if (tracker[tracker.length - 1 - i] === layerId) {
            continue;
        }
        if (beforeIndex.hasOwnProperty(layerId)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);
        } else {
            d++;
        }
        insertBeforeLayerId = tracker[tracker.length - i];
        commands.push({
            command: operations.addLayer,
            args: [afterIndex[layerId], insertBeforeLayerId]
        });
        tracker.splice(tracker.length - i, 0, layerId);
        clean[layerId] = true;
    }
    for (i = 0; i < afterOrder.length; i++) {
        layerId = afterOrder[i];
        beforeLayer = beforeIndex[layerId];
        afterLayer = afterIndex[layerId];
        if (clean[layerId] || deepEqual(beforeLayer, afterLayer)) {
            continue;
        }
        if (!deepEqual(beforeLayer.source, afterLayer.source) || !deepEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !deepEqual(beforeLayer.type, afterLayer.type)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];
            commands.push({
                command: operations.addLayer,
                args: [afterLayer, insertBeforeLayerId]
            });
            continue;
        }
        diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);
        diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);
        if (!deepEqual(beforeLayer.filter, afterLayer.filter)) {
            commands.push({
                command: operations.setFilter,
                args: [layerId, afterLayer.filter]
            });
        }
        if (!deepEqual(beforeLayer.minzoom, afterLayer.minzoom) || !deepEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {
            commands.push({
                command: operations.setLayerZoomRange,
                args: [layerId, afterLayer.minzoom, afterLayer.maxzoom]
            });
        }
        for (prop in beforeLayer) {
            if (!beforeLayer.hasOwnProperty(prop)) {
                continue;
            }
            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') {
                continue;
            }
            if (prop.indexOf('paint.') === 0) {
                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
            } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {
                commands.push({
                    command: operations.setLayerProperty,
                    args: [layerId, prop, afterLayer[prop]]
                });
            }
        }
        for (prop in afterLayer) {
            if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) {
                continue;
            }
            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') {
                continue;
            }
            if (prop.indexOf('paint.') === 0) {
                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
            } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {
                commands.push({
                    command: operations.setLayerProperty,
                    args: [layerId, prop, afterLayer[prop]]
                });
            }
        }
    }
}
function diffStyles(before, after) {
    if (!before) {
        return [{
            command: operations.setStyle,
            args: [after]
        }];
    }
    var commands = [];
    try {
        if (!deepEqual(before.version, after.version)) {
            return [{
                command: operations.setStyle,
                args: [after]
            }];
        }
        if (!deepEqual(before.center, after.center)) {
            commands.push({
                command: operations.setCenter,
                args: [after.center]
            });
        }
        if (!deepEqual(before.zoom, after.zoom)) {
            commands.push({
                command: operations.setZoom,
                args: [after.zoom]
            });
        }
        if (!deepEqual(before.bearing, after.bearing)) {
            commands.push({
                command: operations.setBearing,
                args: [after.bearing]
            });
        }
        if (!deepEqual(before.pitch, after.pitch)) {
            commands.push({
                command: operations.setPitch,
                args: [after.pitch]
            });
        }
        if (!deepEqual(before.sprite, after.sprite)) {
            commands.push({
                command: operations.setSprite,
                args: [after.sprite]
            });
        }
        if (!deepEqual(before.glyphs, after.glyphs)) {
            commands.push({
                command: operations.setGlyphs,
                args: [after.glyphs]
            });
        }
        if (!deepEqual(before.transition, after.transition)) {
            commands.push({
                command: operations.setTransition,
                args: [after.transition]
            });
        }
        if (!deepEqual(before.light, after.light)) {
            commands.push({
                command: operations.setLight,
                args: [after.light]
            });
        }
        var sourcesRemoved = {};
        var removeOrAddSourceCommands = [];
        diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);
        var beforeLayers = [];
        if (before.layers) {
            before.layers.forEach(function (layer) {
                if (sourcesRemoved[layer.source]) {
                    commands.push({
                        command: operations.removeLayer,
                        args: [layer.id]
                    });
                } else {
                    beforeLayers.push(layer);
                }
            });
        }
        commands = commands.concat(removeOrAddSourceCommands);
        diffLayers(beforeLayers, after.layers, commands);
    } catch (e) {
        console.warn('Unable to compute style diff:', e);
        commands = [{
            command: operations.setStyle,
            args: [after]
        }];
    }
    return commands;
}

var ValidationError = function ValidationError(key, value, message, identifier) {
    this.message = (key ? key + ': ' : '') + message;
    if (identifier) {
        this.identifier = identifier;
    }
    if (value !== null && value !== undefined && value.__line__) {
        this.line = value.__line__;
    }
};

var ParsingError$1 = function ParsingError(error) {
    this.error = error;
    this.message = error.message;
    var match = error.message.match(/line (\d+)/);
    this.line = match ? parseInt(match[1], 10) : 0;
};

function validateConstants(options) {
    var key = options.key;
    var constants = options.value;
    if (constants) {
        return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
    } else {
        return [];
    }
}

function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
        return value.valueOf();
    } else {
        return value;
    }
}
function deepUnbundle(value) {
    if (Array.isArray(value)) {
        return value.map(deepUnbundle);
    } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {
        var unbundledValue = {};
        for (var key in value) {
            unbundledValue[key] = deepUnbundle(value[key]);
        }
        return unbundledValue;
    }
    return unbundle(value);
}

function validateObject(options) {
    var key = options.key;
    var object = options.value;
    var elementSpecs = options.valueSpec || {};
    var elementValidators = options.objectElementValidators || {};
    var style = options.style;
    var styleSpec = options.styleSpec;
    var errors = [];
    var type = getType(object);
    if (type !== 'object') {
        return [new ValidationError(key, object, 'object expected, ' + type + ' found')];
    }
    for (var objectKey in object) {
        var elementSpecKey = objectKey.split('.')[0];
        var elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];
        var validateElement = void 0;
        if (elementValidators[elementSpecKey]) {
            validateElement = elementValidators[elementSpecKey];
        } else if (elementSpecs[elementSpecKey]) {
            validateElement = validate;
        } else if (elementValidators['*']) {
            validateElement = elementValidators['*'];
        } else if (elementSpecs['*']) {
            validateElement = validate;
        } else {
            errors.push(new ValidationError(key, object[objectKey], 'unknown property "' + objectKey + '"'));
            continue;
        }
        errors = errors.concat(validateElement({
            key: (key ? key + '.' : key) + objectKey,
            value: object[objectKey],
            valueSpec: elementSpec,
            style: style,
            styleSpec: styleSpec,
            object: object,
            objectKey: objectKey
        }, object));
    }
    for (var elementSpecKey$1 in elementSpecs) {
        if (elementValidators[elementSpecKey$1]) {
            continue;
        }
        if (elementSpecs[elementSpecKey$1].required && elementSpecs[elementSpecKey$1]['default'] === undefined && object[elementSpecKey$1] === undefined) {
            errors.push(new ValidationError(key, object, 'missing required property "' + elementSpecKey$1 + '"'));
        }
    }
    return errors;
}

function validateArray(options) {
    var array = options.value;
    var arraySpec = options.valueSpec;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var key = options.key;
    var validateArrayElement = options.arrayElementValidator || validate;
    if (getType(array) !== 'array') {
        return [new ValidationError(key, array, 'array expected, ' + getType(array) + ' found')];
    }
    if (arraySpec.length && array.length !== arraySpec.length) {
        return [new ValidationError(key, array, 'array length ' + arraySpec.length + ' expected, length ' + array.length + ' found')];
    }
    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
        return [new ValidationError(key, array, 'array length at least ' + arraySpec['min-length'] + ' expected, length ' + array.length + ' found')];
    }
    var arrayElementSpec = {
        'type': arraySpec.value,
        'values': arraySpec.values
    };
    if (styleSpec.$version < 7) {
        arrayElementSpec.function = arraySpec.function;
    }
    if (getType(arraySpec.value) === 'object') {
        arrayElementSpec = arraySpec.value;
    }
    var errors = [];
    for (var i = 0; i < array.length; i++) {
        errors = errors.concat(validateArrayElement({
            array: array,
            arrayIndex: i,
            value: array[i],
            valueSpec: arrayElementSpec,
            style: style,
            styleSpec: styleSpec,
            key: key + '[' + i + ']'
        }));
    }
    return errors;
}

function validateNumber(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var type = getType(value);
    if (type === 'number' && value !== value) {
        type = 'NaN';
    }
    if (type !== 'number') {
        return [new ValidationError(key, value, 'number expected, ' + type + ' found')];
    }
    if ('minimum' in valueSpec && value < valueSpec.minimum) {
        return [new ValidationError(key, value, value + ' is less than the minimum value ' + valueSpec.minimum)];
    }
    if ('maximum' in valueSpec && value > valueSpec.maximum) {
        return [new ValidationError(key, value, value + ' is greater than the maximum value ' + valueSpec.maximum)];
    }
    return [];
}

function validateFunction(options) {
    var functionValueSpec = options.valueSpec;
    var functionType = unbundle(options.value.type);
    var stopKeyType;
    var stopDomainValues = {};
    var previousStopDomainValue;
    var previousStopDomainZoom;
    var isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;
    var isPropertyFunction = !isZoomFunction;
    var isZoomAndPropertyFunction = getType(options.value.stops) === 'array' && getType(options.value.stops[0]) === 'array' && getType(options.value.stops[0][0]) === 'object';
    var errors = validateObject({
        key: options.key,
        value: options.value,
        valueSpec: options.styleSpec.function,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            stops: validateFunctionStops,
            default: validateFunctionDefault
        }
    });
    if (functionType === 'identity' && isZoomFunction) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "property"'));
    }
    if (functionType !== 'identity' && !options.value.stops) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "stops"'));
    }
    if (functionType === 'exponential' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {
        errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));
    }
    if (options.styleSpec.$version >= 8) {
        if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {
            errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));
        } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {
            errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));
        }
    }
    if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {
        errors.push(new ValidationError(options.key, options.value, '"property" property is required'));
    }
    return errors;
    function validateFunctionStops(options) {
        if (functionType === 'identity') {
            return [new ValidationError(options.key, options.value, 'identity function may not have a "stops" property')];
        }
        var errors = [];
        var value = options.value;
        errors = errors.concat(validateArray({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec,
            style: options.style,
            styleSpec: options.styleSpec,
            arrayElementValidator: validateFunctionStop
        }));
        if (getType(value) === 'array' && value.length === 0) {
            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
        }
        return errors;
    }
    function validateFunctionStop(options) {
        var errors = [];
        var value = options.value;
        var key = options.key;
        if (getType(value) !== 'array') {
            return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];
        }
        if (value.length !== 2) {
            return [new ValidationError(key, value, 'array length 2 expected, length ' + value.length + ' found')];
        }
        if (isZoomAndPropertyFunction) {
            if (getType(value[0]) !== 'object') {
                return [new ValidationError(key, value, 'object expected, ' + getType(value[0]) + ' found')];
            }
            if (value[0].zoom === undefined) {
                return [new ValidationError(key, value, 'object stop key must have zoom')];
            }
            if (value[0].value === undefined) {
                return [new ValidationError(key, value, 'object stop key must have value')];
            }
            if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {
                return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];
            }
            if (unbundle(value[0].zoom) !== previousStopDomainZoom) {
                previousStopDomainZoom = unbundle(value[0].zoom);
                previousStopDomainValue = undefined;
                stopDomainValues = {};
            }
            errors = errors.concat(validateObject({
                key: key + '[0]',
                value: value[0],
                valueSpec: { zoom: {} },
                style: options.style,
                styleSpec: options.styleSpec,
                objectElementValidators: {
                    zoom: validateNumber,
                    value: validateStopDomainValue
                }
            }));
        } else {
            errors = errors.concat(validateStopDomainValue({
                key: key + '[0]',
                value: value[0],
                valueSpec: {},
                style: options.style,
                styleSpec: options.styleSpec
            }, value));
        }
        if (isExpression(deepUnbundle(value[1]))) {
            return errors.concat([new ValidationError(key + '[1]', value[1], 'expressions are not allowed in function stops.')]);
        }
        return errors.concat(validate({
            key: key + '[1]',
            value: value[1],
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        }));
    }
    function validateStopDomainValue(options, stop) {
        var type = getType(options.value);
        var value = unbundle(options.value);
        var reportValue = options.value !== null ? options.value : stop;
        if (!stopKeyType) {
            stopKeyType = type;
        } else if (type !== stopKeyType) {
            return [new ValidationError(options.key, reportValue, type + ' stop domain type must match previous stop domain type ' + stopKeyType)];
        }
        if (type !== 'number' && type !== 'string' && type !== 'boolean') {
            return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];
        }
        if (type !== 'number' && functionType !== 'categorical') {
            var message = 'number expected, ' + type + ' found';
            if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {
                message += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.';
            }
            return [new ValidationError(options.key, reportValue, message)];
        }
        if (functionType === 'categorical' && type === 'number' && (!isFinite(value) || Math.floor(value) !== value)) {
            return [new ValidationError(options.key, reportValue, 'integer expected, found ' + value)];
        }
        if (functionType !== 'categorical' && type === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];
        } else {
            previousStopDomainValue = value;
        }
        if (functionType === 'categorical' && value in stopDomainValues) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];
        } else {
            stopDomainValues[value] = true;
        }
        return [];
    }
    function validateFunctionDefault(options) {
        return validate({
            key: options.key,
            value: options.value,
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        });
    }
}

function validateExpression(options) {
    var expression = (options.expressionContext === 'property' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);
    if (expression.result === 'error') {
        return expression.value.map(function (error) {
            return new ValidationError('' + options.key + error.key, options.value, error.message);
        });
    }
    var expressionObj = expression.value.expression || expression.value._styleExpression.expression;
    if (options.expressionContext === 'property' && options.propertyKey === 'text-font' && !expressionObj.outputDefined()) {
        return [new ValidationError(options.key, options.value, 'Invalid data expression for "' + options.propertyKey + '". Output values must be contained as literals within the expression.')];
    }
    if (options.expressionContext === 'property' && options.propertyType === 'layout' && !isStateConstant(expressionObj)) {
        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with layout properties.')];
    }
    if (options.expressionContext === 'filter' && !isStateConstant(expressionObj)) {
        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with filters.')];
    }
    if (options.expressionContext && options.expressionContext.indexOf('cluster') === 0) {
        if (!isGlobalPropertyConstant(expressionObj, ['zoom', 'feature-state'])) {
            return [new ValidationError(options.key, options.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
        }
        if (options.expressionContext === 'cluster-initial' && !isFeatureConstant(expressionObj)) {
            return [new ValidationError(options.key, options.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];
        }
    }
    return [];
}

function validateBoolean(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);
    if (type !== 'boolean') {
        return [new ValidationError(key, value, 'boolean expected, ' + type + ' found')];
    }
    return [];
}

function validateColor(options) {
    var key = options.key;
    var value = options.value;
    var type = getType(value);
    if (type !== 'string') {
        return [new ValidationError(key, value, 'color expected, ' + type + ' found')];
    }
    if (csscolorparser_1(value) === null) {
        return [new ValidationError(key, value, 'color expected, "' + value + '" found')];
    }
    return [];
}

function validateEnum(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var errors = [];
    if (Array.isArray(valueSpec.values)) {
        if (valueSpec.values.indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, 'expected one of [' + valueSpec.values.join(', ') + '], ' + JSON.stringify(value) + ' found'));
        }
    } else {
        if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, 'expected one of [' + Object.keys(valueSpec.values).join(', ') + '], ' + JSON.stringify(value) + ' found'));
        }
    }
    return errors;
}

function validateFilter(options) {
    if (isExpressionFilter(deepUnbundle(options.value))) {
        return validateExpression(extend({}, options, {
            expressionContext: 'filter',
            valueSpec: { value: 'boolean' }
        }));
    } else {
        return validateNonExpressionFilter(options);
    }
}
function validateNonExpressionFilter(options) {
    var value = options.value;
    var key = options.key;
    if (getType(value) !== 'array') {
        return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];
    }
    var styleSpec = options.styleSpec;
    var type;
    var errors = [];
    if (value.length < 1) {
        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
    }
    errors = errors.concat(validateEnum({
        key: key + '[0]',
        value: value[0],
        valueSpec: styleSpec.filter_operator,
        style: options.style,
        styleSpec: options.styleSpec
    }));
    switch (unbundle(value[0])) {
        case '<':
        case '<=':
        case '>':
        case '>=':
            if (value.length >= 2 && unbundle(value[1]) === '$type') {
                errors.push(new ValidationError(key, value, '"$type" cannot be use with operator "' + value[0] + '"'));
            }
        case '==':
        case '!=':
            if (value.length !== 3) {
                errors.push(new ValidationError(key, value, 'filter array for operator "' + value[0] + '" must have 3 elements'));
            }
        case 'in':
        case '!in':
            if (value.length >= 2) {
                type = getType(value[1]);
                if (type !== 'string') {
                    errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));
                }
            }
            for (var i = 2; i < value.length; i++) {
                type = getType(value[i]);
                if (unbundle(value[1]) === '$type') {
                    errors = errors.concat(validateEnum({
                        key: key + '[' + i + ']',
                        value: value[i],
                        valueSpec: styleSpec.geometry_type,
                        style: options.style,
                        styleSpec: options.styleSpec
                    }));
                } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'string, number, or boolean expected, ' + type + ' found'));
                }
            }
            break;
        case 'any':
        case 'all':
        case 'none':
            for (var i$1 = 1; i$1 < value.length; i$1++) {
                errors = errors.concat(validateNonExpressionFilter({
                    key: key + '[' + i$1 + ']',
                    value: value[i$1],
                    style: options.style,
                    styleSpec: options.styleSpec
                }));
            }
            break;
        case 'has':
        case '!has':
            type = getType(value[1]);
            if (value.length !== 2) {
                errors.push(new ValidationError(key, value, 'filter array for "' + value[0] + '" operator must have 2 elements'));
            } else if (type !== 'string') {
                errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));
            }
            break;
    }
    return errors;
}

function validateProperty(options, propertyType) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec[propertyType + '_' + options.layerType];
    if (!layerSpec) {
        return [];
    }
    var transitionMatch = propertyKey.match(/^(.*)-transition$/);
    if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
        return validate({
            key: key,
            value: value,
            valueSpec: styleSpec.transition,
            style: style,
            styleSpec: styleSpec
        });
    }
    var valueSpec = options.valueSpec || layerSpec[propertyKey];
    if (!valueSpec) {
        return [new ValidationError(key, value, 'unknown property "' + propertyKey + '"')];
    }
    var tokenMatch;
    if (getType(value) === 'string' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {
        return [new ValidationError(key, value, '"' + propertyKey + '" does not support interpolation syntax\n' + 'Use an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(tokenMatch[1]) + ' }`.')];
    }
    var errors = [];
    if (options.layerType === 'symbol') {
        if (propertyKey === 'text-field' && style && !style.glyphs) {
            errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
        }
        if (propertyKey === 'text-font' && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === 'identity') {
            errors.push(new ValidationError(key, value, '"text-font" does not support identity functions'));
        }
    }
    return errors.concat(validate({
        key: options.key,
        value: value,
        valueSpec: valueSpec,
        style: style,
        styleSpec: styleSpec,
        expressionContext: 'property',
        propertyType: propertyType,
        propertyKey: propertyKey
    }));
}

function validatePaintProperty(options) {
    return validateProperty(options, 'paint');
}

function validateLayoutProperty(options) {
    return validateProperty(options, 'layout');
}

function validateLayer(options) {
    var errors = [];
    var layer = options.value;
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    if (!layer.type && !layer.ref) {
        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
    }
    var type = unbundle(layer.type);
    var ref = unbundle(layer.ref);
    if (layer.id) {
        var layerId = unbundle(layer.id);
        for (var i = 0; i < options.arrayIndex; i++) {
            var otherLayer = style.layers[i];
            if (unbundle(otherLayer.id) === layerId) {
                errors.push(new ValidationError(key, layer.id, 'duplicate layer id "' + layer.id + '", previously used at line ' + otherLayer.id.__line__));
            }
        }
    }
    if ('ref' in layer) {
        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
            if (p in layer) {
                errors.push(new ValidationError(key, layer[p], '"' + p + '" is prohibited for ref layers'));
            }
        });
        var parent;
        style.layers.forEach(function (layer) {
            if (unbundle(layer.id) === ref) {
                parent = layer;
            }
        });
        if (!parent) {
            errors.push(new ValidationError(key, layer.ref, 'ref layer "' + ref + '" not found'));
        } else if (parent.ref) {
            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
        } else {
            type = unbundle(parent.type);
        }
    } else if (type !== 'background') {
        if (!layer.source) {
            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
        } else {
            var source = style.sources && style.sources[layer.source];
            var sourceType = source && unbundle(source.type);
            if (!source) {
                errors.push(new ValidationError(key, layer.source, 'source "' + layer.source + '" not found'));
            } else if (sourceType === 'vector' && type === 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "' + layer.id + '" requires a raster source'));
            } else if (sourceType === 'raster' && type !== 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "' + layer.id + '" requires a vector source'));
            } else if (sourceType === 'vector' && !layer['source-layer']) {
                errors.push(new ValidationError(key, layer, 'layer "' + layer.id + '" must specify a "source-layer"'));
            } else if (sourceType === 'raster-dem' && type !== 'hillshade') {
                errors.push(new ValidationError(key, layer.source, 'raster-dem source can only be used with layer type \'hillshade\'.'));
            } else if (type === 'line' && layer.paint && layer.paint['line-gradient'] && (sourceType !== 'geojson' || !source.lineMetrics)) {
                errors.push(new ValidationError(key, layer, 'layer "' + layer.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'));
            }
        }
    }
    errors = errors.concat(validateObject({
        key: key,
        value: layer,
        valueSpec: styleSpec.layer,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            '*': function _() {
                return [];
            },
            type: function type() {
                return validate({
                    key: key + '.type',
                    value: layer.type,
                    valueSpec: styleSpec.layer.type,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    object: layer,
                    objectKey: 'type'
                });
            },
            filter: validateFilter,
            layout: function layout(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function _(options) {
                            return validateLayoutProperty(extend({ layerType: type }, options));
                        }
                    }
                });
            },
            paint: function paint(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function _(options) {
                            return validatePaintProperty(extend({ layerType: type }, options));
                        }
                    }
                });
            }
        }
    }));
    return errors;
}

function validateString(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);
    if (type !== 'string') {
        return [new ValidationError(key, value, 'string expected, ' + type + ' found')];
    }
    return [];
}

var objectElementValidators = { promoteId: validatePromoteId };
function validateSource(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;
    if (!value.type) {
        return [new ValidationError(key, value, '"type" is required')];
    }
    var type = unbundle(value.type);
    var errors;
    switch (type) {
        case 'vector':
        case 'raster':
        case 'raster-dem':
            errors = validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec['source_' + type.replace('-', '_')],
                style: options.style,
                styleSpec: styleSpec,
                objectElementValidators: objectElementValidators
            });
            return errors;
        case 'geojson':
            errors = validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_geojson,
                style: style,
                styleSpec: styleSpec,
                objectElementValidators: objectElementValidators
            });
            if (value.cluster) {
                for (var prop in value.clusterProperties) {
                    var ref = value.clusterProperties[prop];
                    var operator = ref[0];
                    var mapExpr = ref[1];
                    var reduceExpr = typeof operator === 'string' ? [operator, ['accumulated'], ['get', prop]] : operator;
                    errors.push.apply(errors, validateExpression({
                        key: key + '.' + prop + '.map',
                        value: mapExpr,
                        expressionContext: 'cluster-map'
                    }));
                    errors.push.apply(errors, validateExpression({
                        key: key + '.' + prop + '.reduce',
                        value: reduceExpr,
                        expressionContext: 'cluster-reduce'
                    }));
                }
            }
            return errors;
        case 'video':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_video,
                style: style,
                styleSpec: styleSpec
            });
        case 'image':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_image,
                style: style,
                styleSpec: styleSpec
            });
        case 'canvas':
            return [new ValidationError(key, null, 'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.', 'source.canvas')];
        default:
            return validateEnum({
                key: key + '.type',
                value: value.type,
                valueSpec: {
                    values: ['vector', 'raster', 'raster-dem', 'geojson', 'video', 'image']
                },
                style: style,
                styleSpec: styleSpec
            });
    }
}
function validatePromoteId(ref) {
    var key = ref.key;
    var value = ref.value;
    if (getType(value) === 'string') {
        return validateString({
            key: key,
            value: value
        });
    } else {
        var errors = [];
        for (var prop in value) {
            errors.push.apply(errors, validateString({
                key: key + '.' + prop,
                value: value[prop]
            }));
        }
        return errors;
    }
}

function validateLight(options) {
    var light = options.value;
    var styleSpec = options.styleSpec;
    var lightSpec = styleSpec.light;
    var style = options.style;
    var errors = [];
    var rootType = getType(light);
    if (light === undefined) {
        return errors;
    } else if (rootType !== 'object') {
        errors = errors.concat([new ValidationError('light', light, 'object expected, ' + rootType + ' found')]);
        return errors;
    }
    for (var key in light) {
        var transitionMatch = key.match(/^(.*)-transition$/);
        if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: styleSpec.transition,
                style: style,
                styleSpec: styleSpec
            }));
        } else if (lightSpec[key]) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: lightSpec[key],
                style: style,
                styleSpec: styleSpec
            }));
        } else {
            errors = errors.concat([new ValidationError(key, light[key], 'unknown property "' + key + '"')]);
        }
    }
    return errors;
}

function validateFormatted(options) {
    if (validateString(options).length === 0) {
        return [];
    }
    return validateExpression(options);
}

function validateImage(options) {
    if (validateString(options).length === 0) {
        return [];
    }
    return validateExpression(options);
}

var VALIDATORS = {
    '*': function _() {
        return [];
    },
    'array': validateArray,
    'boolean': validateBoolean,
    'number': validateNumber,
    'color': validateColor,
    'constants': validateConstants,
    'enum': validateEnum,
    'filter': validateFilter,
    'function': validateFunction,
    'layer': validateLayer,
    'object': validateObject,
    'source': validateSource,
    'light': validateLight,
    'string': validateString,
    'formatted': validateFormatted,
    'resolvedImage': validateImage
};
function validate(options) {
    var value = options.value;
    var valueSpec = options.valueSpec;
    var styleSpec = options.styleSpec;
    if (valueSpec.expression && isFunction$1(unbundle(value))) {
        return validateFunction(options);
    } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {
        return validateExpression(options);
    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
        return VALIDATORS[valueSpec.type](options);
    } else {
        var valid = validateObject(extend({}, options, { valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec }));
        return valid;
    }
}

function validateGlyphsURL(options) {
    var value = options.value;
    var key = options.key;
    var errors = validateString(options);
    if (errors.length) {
        return errors;
    }
    if (value.indexOf('{fontstack}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
    }
    if (value.indexOf('{range}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
    }
    return errors;
}

function validateStyleMin(style, styleSpec) {
    if (styleSpec === void 0) styleSpec = v8;
    var errors = [];
    errors = errors.concat(validate({
        key: '',
        value: style,
        valueSpec: styleSpec.$root,
        styleSpec: styleSpec,
        style: style,
        objectElementValidators: {
            glyphs: validateGlyphsURL,
            '*': function _() {
                return [];
            }
        }
    }));
    if (style.constants) {
        errors = errors.concat(validateConstants({
            key: 'constants',
            value: style.constants,
            style: style,
            styleSpec: styleSpec
        }));
    }
    return sortErrors(errors);
}
validateStyleMin.source = wrapCleanErrors(validateSource);
validateStyleMin.light = wrapCleanErrors(validateLight);
validateStyleMin.layer = wrapCleanErrors(validateLayer);
validateStyleMin.filter = wrapCleanErrors(validateFilter);
validateStyleMin.paintProperty = wrapCleanErrors(validatePaintProperty);
validateStyleMin.layoutProperty = wrapCleanErrors(validateLayoutProperty);
function sortErrors(errors) {
    return [].concat(errors).sort(function (a, b) {
        return a.line - b.line;
    });
}
function wrapCleanErrors(inner) {
    return function () {
        var args = [],
            len = arguments.length;
        while (len--) {
            args[len] = arguments[len];
        }return sortErrors(inner.apply(this, args));
    };
}

var jsonlint = createCommonjsModule(function (module, exports) {
    /* parser generated by jison 0.4.15 */
    /*
      Returns a Parser object of the following structure:
    
      Parser: {
        yy: {}
      }
    
      Parser.prototype: {
        yy: {},
        trace: function(),
        symbols_: {associative list: name ==> number},
        terminals_: {associative list: number ==> name},
        productions_: [...],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
        table: [...],
        defaultActions: {...},
        parseError: function(str, hash),
        parse: function(input),
    
        lexer: {
            EOF: 1,
            parseError: function(str, hash),
            setInput: function(input),
            input: function(),
            unput: function(str),
            more: function(),
            less: function(n),
            pastInput: function(),
            upcomingInput: function(),
            showPosition: function(),
            test_match: function(regex_match_array, rule_index),
            next: function(),
            lex: function(),
            begin: function(condition),
            popState: function(),
            _currentRules: function(),
            topState: function(),
            pushState: function(condition),
    
            options: {
                ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
            },
    
            performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
            rules: [...],
            conditions: {associative list: name ==> set},
        }
      }
    
    
      token location info (@$, _$, etc.): {
        first_line: n,
        last_line: n,
        first_column: n,
        last_column: n,
        range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
      }
    
    
      the parseError function receives a 'hash' object with these members for lexer and parser errors: {
        text:        (matched text)
        token:       (the produced terminal token, if any)
        line:        (yylineno)
      }
      while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
        loc:         (yylloc)
        expected:    (string describing the set of expected tokens)
        recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
      }
    */
    var parser = function () {
        var o = function o(k, v, _o, l) {
            for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {}return _o;
        },
            $V0 = [1, 12],
            $V1 = [1, 13],
            $V2 = [1, 9],
            $V3 = [1, 10],
            $V4 = [1, 11],
            $V5 = [1, 14],
            $V6 = [1, 15],
            $V7 = [14, 18, 22, 24],
            $V8 = [18, 22],
            $V9 = [22, 24];
        var parser = { trace: function trace() {},
            yy: {},
            symbols_: { "error": 2, "JSONString": 3, "STRING": 4, "JSONNumber": 5, "NUMBER": 6, "JSONNullLiteral": 7, "NULL": 8, "JSONBooleanLiteral": 9, "TRUE": 10, "FALSE": 11, "JSONText": 12, "JSONValue": 13, "EOF": 14, "JSONObject": 15, "JSONArray": 16, "{": 17, "}": 18, "JSONMemberList": 19, "JSONMember": 20, ":": 21, ",": 22, "[": 23, "]": 24, "JSONElementList": 25, "$accept": 0, "$end": 1 },
            terminals_: { 2: "error", 4: "STRING", 6: "NUMBER", 8: "NULL", 10: "TRUE", 11: "FALSE", 14: "EOF", 17: "{", 18: "}", 21: ":", 22: ",", 23: "[", 24: "]" },
            productions_: [0, [3, 1], [5, 1], [7, 1], [9, 1], [9, 1], [12, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [15, 2], [15, 3], [20, 3], [19, 1], [19, 3], [16, 2], [16, 3], [25, 1], [25, 3]],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
                /* this == yyval */

                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1:
                        // replace escaped characters with actual character
                        this.$ = new String(yytext.replace(/\\(\\|")/g, "$" + "1").replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\v/g, '\v').replace(/\\f/g, '\f').replace(/\\b/g, '\b'));
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 2:

                        this.$ = new Number(yytext);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 3:

                        this.$ = null;

                        break;
                    case 4:

                        this.$ = new Boolean(true);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 5:

                        this.$ = new Boolean(false);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 6:
                        return this.$ = $$[$0 - 1];
                    case 13:
                        this.$ = {};Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 14:case 19:
                        this.$ = $$[$0 - 1];Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 15:
                        this.$ = [$$[$0 - 2], $$[$0]];
                        break;
                    case 16:
                        this.$ = {};this.$[$$[$0][0]] = $$[$0][1];
                        break;
                    case 17:
                        this.$ = $$[$0 - 2];$$[$0 - 2][$$[$0][0]] = $$[$0][1];
                        break;
                    case 18:
                        this.$ = [];Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 20:
                        this.$ = [$$[$0]];
                        break;
                    case 21:
                        this.$ = $$[$0 - 2];$$[$0 - 2].push($$[$0]);
                        break;
                }
            },
            table: [{ 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 12: 1, 13: 2, 15: 7, 16: 8, 17: $V5, 23: $V6 }, { 1: [3] }, { 14: [1, 16] }, o($V7, [2, 7]), o($V7, [2, 8]), o($V7, [2, 9]), o($V7, [2, 10]), o($V7, [2, 11]), o($V7, [2, 12]), o($V7, [2, 3]), o($V7, [2, 4]), o($V7, [2, 5]), o([14, 18, 21, 22, 24], [2, 1]), o($V7, [2, 2]), { 3: 20, 4: $V0, 18: [1, 17], 19: 18, 20: 19 }, { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 23, 15: 7, 16: 8, 17: $V5, 23: $V6, 24: [1, 21], 25: 22 }, { 1: [2, 6] }, o($V7, [2, 13]), { 18: [1, 24], 22: [1, 25] }, o($V8, [2, 16]), { 21: [1, 26] }, o($V7, [2, 18]), { 22: [1, 28], 24: [1, 27] }, o($V9, [2, 20]), o($V7, [2, 14]), { 3: 20, 4: $V0, 20: 29 }, { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 30, 15: 7, 16: 8, 17: $V5, 23: $V6 }, o($V7, [2, 19]), { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 31, 15: 7, 16: 8, 17: $V5, 23: $V6 }, o($V8, [2, 17]), o($V8, [2, 15]), o($V9, [2, 21])],
            defaultActions: { 16: [2, 6] },
            parseError: function parseError(str, hash) {
                if (hash.recoverable) {
                    this.trace(str);
                } else {
                    throw new Error(str);
                }
            },
            parse: function parse(input) {
                var self = this,
                    stack = [0],
                    vstack = [null],
                    lstack = [],
                    table = this.table,
                    yytext = '',
                    yylineno = 0,
                    yyleng = 0,
                    TERROR = 2,
                    EOF = 1;
                var args = lstack.slice.call(arguments, 1);
                var lexer = Object.create(this.lexer);
                var sharedState = { yy: {} };
                for (var k in this.yy) {
                    if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                        sharedState.yy[k] = this.yy[k];
                    }
                }
                lexer.setInput(input, sharedState.yy);
                sharedState.yy.lexer = lexer;
                sharedState.yy.parser = this;
                if (typeof lexer.yylloc == 'undefined') {
                    lexer.yylloc = {};
                }
                var yyloc = lexer.yylloc;
                lstack.push(yyloc);
                var ranges = lexer.options && lexer.options.ranges;
                if (typeof sharedState.yy.parseError === 'function') {
                    this.parseError = sharedState.yy.parseError;
                } else {
                    this.parseError = Object.getPrototypeOf(this).parseError;
                }

                function lex() {
                    var token;
                    token = lexer.lex() || EOF;
                    if (typeof token !== 'number') {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                }
                var symbol,
                    state,
                    action,
                    r,
                    yyval = {},
                    p,
                    len,
                    newState,
                    expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    } else {
                        if (symbol === null || typeof symbol == 'undefined') {
                            symbol = lex();
                        }
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                        var errStr = '';
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push('\'' + this.terminals_[p] + '\'');
                            }
                        }
                        if (lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                        } else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                        }
                        this.parseError(errStr, {
                            text: lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: lexer.yylineno,
                            loc: yyloc,
                            expected: expected
                        });
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(lexer.yytext);
                            lstack.push(lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            {
                                yyleng = lexer.yyleng;
                                yytext = lexer.yytext;
                                yylineno = lexer.yylineno;
                                yyloc = lexer.yylloc;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = {
                                first_line: lstack[lstack.length - (len || 1)].first_line,
                                last_line: lstack[lstack.length - 1].last_line,
                                first_column: lstack[lstack.length - (len || 1)].first_column,
                                last_column: lstack[lstack.length - 1].last_column
                            };
                            if (ranges) {
                                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                            }
                            r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
                            if (typeof r !== 'undefined') {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            } };
        /* generated by jison-lex 0.3.4 */
        var lexer = function () {
            var lexer = {

                EOF: 1,

                parseError: function parseError(str, hash) {
                    if (this.yy.parser) {
                        this.yy.parser.parseError(str, hash);
                    } else {
                        throw new Error(str);
                    }
                },

                // resets the lexer, sets new input
                setInput: function setInput(input, yy) {
                    this.yy = yy || this.yy || {};
                    this._input = input;
                    this._more = this._backtrack = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = '';
                    this.conditionStack = ['INITIAL'];
                    this.yylloc = {
                        first_line: 1,
                        first_column: 0,
                        last_line: 1,
                        last_column: 0
                    };
                    if (this.options.ranges) {
                        this.yylloc.range = [0, 0];
                    }
                    this.offset = 0;
                    return this;
                },

                // consumes and returns one char from the input
                input: function input() {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno++;
                        this.yylloc.last_line++;
                    } else {
                        this.yylloc.last_column++;
                    }
                    if (this.options.ranges) {
                        this.yylloc.range[1]++;
                    }

                    this._input = this._input.slice(1);
                    return ch;
                },

                // unshifts one char (or a string) into the input
                unput: function unput(ch) {
                    var len = ch.length;
                    var lines = ch.split(/(?:\r\n?|\n)/g);

                    this._input = ch + this._input;
                    this.yytext = this.yytext.substr(0, this.yytext.length - len);
                    //this.yyleng -= len;
                    this.offset -= len;
                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                    this.match = this.match.substr(0, this.match.length - 1);
                    this.matched = this.matched.substr(0, this.matched.length - 1);

                    if (lines.length - 1) {
                        this.yylineno -= lines.length - 1;
                    }
                    var r = this.yylloc.range;

                    this.yylloc = {
                        first_line: this.yylloc.first_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.first_column,
                        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                    };

                    if (this.options.ranges) {
                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                    }
                    this.yyleng = this.yytext.length;
                    return this;
                },

                // When called from action, caches matched text and appends it on next action
                more: function more() {
                    this._more = true;
                    return this;
                },

                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function reject() {
                    if (this.options.backtrack_lexer) {
                        this._backtrack = true;
                    } else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                    return this;
                },

                // retain first n characters of the match
                less: function less(n) {
                    this.unput(this.match.slice(n));
                },

                // displays already matched input, i.e. for error messages
                pastInput: function pastInput() {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                },

                // displays upcoming input, i.e. for error messages
                upcomingInput: function upcomingInput() {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length);
                    }
                    return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                },

                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function showPosition() {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^";
                },

                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function test_match(match, indexed_rule) {
                    var token, lines, backup;

                    if (this.options.backtrack_lexer) {
                        // save context
                        backup = {
                            yylineno: this.yylineno,
                            yylloc: {
                                first_line: this.yylloc.first_line,
                                last_line: this.last_line,
                                first_column: this.yylloc.first_column,
                                last_column: this.yylloc.last_column
                            },
                            yytext: this.yytext,
                            match: this.match,
                            matches: this.matches,
                            matched: this.matched,
                            yyleng: this.yyleng,
                            offset: this.offset,
                            _more: this._more,
                            _input: this._input,
                            yy: this.yy,
                            conditionStack: this.conditionStack.slice(0),
                            done: this.done
                        };
                        if (this.options.ranges) {
                            backup.yylloc.range = this.yylloc.range.slice(0);
                        }
                    }

                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno += lines.length;
                    }
                    this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                    };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._backtrack = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                    if (this.done && this._input) {
                        this.done = false;
                    }
                    if (token) {
                        return token;
                    } else if (this._backtrack) {
                        // recover context
                        for (var k in backup) {
                            this[k] = backup[k];
                        }
                        return false; // rule action called reject() implying the next rule should be tested instead.
                    }
                    return false;
                },

                // return next match in input
                next: function next() {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input) {
                        this.done = true;
                    }

                    var token, match, tempMatch, index;
                    if (!this._more) {
                        this.yytext = '';
                        this.match = '';
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        tempMatch = this._input.match(this.rules[rules[i]]);
                        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                            match = tempMatch;
                            index = i;
                            if (this.options.backtrack_lexer) {
                                token = this.test_match(tempMatch, rules[i]);
                                if (token !== false) {
                                    return token;
                                } else if (this._backtrack) {
                                    match = false;
                                    continue; // rule action called reject() implying a rule MISmatch.
                                } else {
                                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                    return false;
                                }
                            } else if (!this.options.flex) {
                                break;
                            }
                        }
                    }
                    if (match) {
                        token = this.test_match(match, rules[index]);
                        if (token !== false) {
                            return token;
                        }
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                    if (this._input === "") {
                        return this.EOF;
                    } else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                },

                // return next match that has a token
                lex: function lex() {
                    var r = this.next();
                    if (r) {
                        return r;
                    } else {
                        return this.lex();
                    }
                },

                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function begin(condition) {
                    this.conditionStack.push(condition);
                },

                // pop the previously active lexer condition state off the condition stack
                popState: function popState() {
                    var n = this.conditionStack.length - 1;
                    if (n > 0) {
                        return this.conditionStack.pop();
                    } else {
                        return this.conditionStack[0];
                    }
                },

                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function _currentRules() {
                    if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                    } else {
                        return this.conditions["INITIAL"].rules;
                    }
                },

                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function topState(n) {
                    n = this.conditionStack.length - 1 - Math.abs(n || 0);
                    if (n >= 0) {
                        return this.conditionStack[n];
                    } else {
                        return "INITIAL";
                    }
                },

                // alias for begin(condition)
                pushState: function pushState(condition) {
                    this.begin(condition);
                },

                // return the number of states currently on the stack
                stateStackSize: function stateStackSize() {
                    return this.conditionStack.length;
                },
                options: {},
                performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                    switch ($avoiding_name_collisions) {
                        case 0:
                            /* skip whitespace */
                            break;
                        case 1:
                            return 6;
                        case 2:
                            yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);return 4;
                        case 3:
                            return 17;
                        case 4:
                            return 18;
                        case 5:
                            return 23;
                        case 6:
                            return 24;
                        case 7:
                            return 22;
                        case 8:
                            return 21;
                        case 9:
                            return 10;
                        case 10:
                            return 11;
                        case 11:
                            return 8;
                        case 12:
                            return 14;
                        case 13:
                            return 'INVALID';
                    }
                },
                rules: [/^(?:\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/, /^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/, /^(?:\{)/, /^(?:\})/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?::)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:$)/, /^(?:.)/],
                conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "inclusive": true } }
            };
            return lexer;
        }();
        parser.lexer = lexer;
        function Parser() {
            this.yy = {};
        }
        Parser.prototype = parser;parser.Parser = Parser;
        return new Parser();
    }();

    if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
        exports.parser = parser;
        exports.Parser = parser.Parser;
        exports.parse = function () {
            return parser.parse.apply(parser, arguments);
        };
    }
});
var jsonlint_1 = jsonlint.parser;
var jsonlint_2 = jsonlint.Parser;
var jsonlint_3 = jsonlint.parse;

function readStyle(style) {
    if (style instanceof String || typeof style === 'string' || style instanceof Buffer) {
        try {
            return jsonlint.parse(style.toString());
        } catch (e) {
            throw new ParsingError$1(e);
        }
    }
    return style;
}

function validateStyle(style, styleSpec) {
    if (styleSpec === void 0) styleSpec = v8;
    var s = style;
    try {
        s = readStyle(s);
    } catch (e) {
        return [e];
    }
    return validateStyleMin(s, styleSpec);
}

var SUPPORTED_SPEC_VERSION = 8;
var MAX_SOURCES_IN_STYLE = 15;
function isValid(value, regex) {
    if (!value || getType(value) !== 'string') {
        return true;
    }
    return !!value.match(regex);
}
function getSourceCount(source) {
    if (source.url) {
        return source.url.split(',').length;
    } else {
        return 0;
    }
}
function getAllowedKeyErrors(obj, keys, path) {
    var allowed = new Set(keys);
    var errors = [];
    Object.keys(obj).forEach(function (k) {
        if (!allowed.has(k)) {
            var prop = path ? path + '.' + k : null;
            errors.push(new ValidationError(prop, obj[k], 'Unsupported property "' + k + '"'));
        }
    });
    return errors;
}
function getSourceErrors(source, i) {
    var errors = [];
    var sourceKeys = ['type', 'url', 'tileSize'];
    errors.push.apply(errors, getAllowedKeyErrors(source, sourceKeys, 'source'));
    var sourceUrlPattern = /^mapbox:\/\/([^/]*)$/;
    if (!isValid(source.url, sourceUrlPattern)) {
        errors.push(new ValidationError('sources[' + i + ']', source.url, 'Source url must be a valid Mapbox tileset url'));
    }
    return errors;
}
function getSourcesErrors(sources) {
    var errors = [];
    var count = 0;
    Object.keys(sources).forEach(function (s, i) {
        var sourceErrors = getSourceErrors(sources[s], i);
        if (!sourceErrors.length) {
            count = count + getSourceCount(sources[s]);
        }
        errors.push.apply(errors, sourceErrors);
    });
    if (count > MAX_SOURCES_IN_STYLE) {
        errors.push(new ValidationError('sources', null, 'Styles must contain ' + MAX_SOURCES_IN_STYLE + ' or fewer sources'));
    }
    return errors;
}
function getRootErrors(style, specKeys) {
    var errors = [];
    var optionalRootProperties = ['owner', 'id', 'cacheControl', 'draft', 'created', 'modified', 'visibility'];
    var allowedKeyErrors = getAllowedKeyErrors(style, specKeys.concat(optionalRootProperties));
    errors.push.apply(errors, allowedKeyErrors);
    if (style.version > SUPPORTED_SPEC_VERSION || style.version < SUPPORTED_SPEC_VERSION) {
        errors.push(new ValidationError('version', style.version, 'Style version must be ' + SUPPORTED_SPEC_VERSION));
    }
    var glyphUrlPattern = /^mapbox:\/\/fonts\/([^/]*)\/{fontstack}\/{range}.pbf$/;
    if (!isValid(style.glyphs, glyphUrlPattern)) {
        errors.push(new ValidationError('glyphs', style.glyphs, 'Styles must reference glyphs hosted by Mapbox'));
    }
    var spriteUrlPattern = /^mapbox:\/\/sprites\/([^/]*)\/([^/]*)\/?([^/]*)?$/;
    if (!isValid(style.sprite, spriteUrlPattern)) {
        errors.push(new ValidationError('sprite', style.sprite, 'Styles must reference sprites hosted by Mapbox'));
    }
    var visibilityPattern = /^(public|private)$/;
    if (!isValid(style.visibility, visibilityPattern)) {
        errors.push(new ValidationError('visibility', style.visibility, 'Style visibility must be public or private'));
    }
    return errors;
}
function validateMapboxApiSupported(style) {
    var s = style;
    try {
        s = readStyle(s);
    } catch (e) {
        return [e];
    }
    var errors = validateStyleMin(s, v8).concat(getRootErrors(s, Object.keys(v8.$root)));
    if (s.sources) {
        errors = errors.concat(getSourcesErrors(s.sources));
    }
    return errors;
}

var expression$1 = {
    StyleExpression: StyleExpression,
    isExpression: isExpression,
    isExpressionFilter: isExpressionFilter,
    createExpression: createExpression,
    createPropertyExpression: createPropertyExpression,
    normalizePropertyExpression: normalizePropertyExpression,
    ZoomConstantExpression: ZoomConstantExpression,
    ZoomDependentExpression: ZoomDependentExpression,
    StylePropertyFunction: StylePropertyFunction
};
var styleFunction = {
    convertFunction: convertFunction,
    createFunction: createFunction,
    isFunction: isFunction$1
};
var visit = {
    eachSource: eachSource,
    eachLayer: eachLayer,
    eachProperty: eachProperty
};
validateStyle.parsed = validateStyle;
validateStyle.latest = validateStyle;

exports.Color = Color;
exports.ParsingError = ParsingError$1;
exports.ValidationError = ValidationError;
exports.composite = composite;
exports.convertFilter = convertFilter$1;
exports.derefLayers = derefLayers;
exports.diff = diffStyles;
exports.expression = expression$1;
exports.featureFilter = createFilter;
exports.format = format;
exports.function = styleFunction;
exports.latest = v8;
exports.migrate = migrate;
exports.v8 = v8;
exports.validate = validateStyle;
exports.validateMapboxApiSupported = validateMapboxApiSupported;
exports.visit = visit;
//# sourceMappingURL=index.es.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "./node_modules/mapbox-to-css-font/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mapbox-to-css-font/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fontWeights = {
  thin: 100,
  hairline: 100,
  'ultra-light': 100,
  'extra-light': 100,
  light: 200,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  'semi-bold': 600,
  'demi-bold': 600,
  bold: 700,
  heavy: 800,
  black: 800,
  'extra-bold': 800,
  'ultra-black': 900,
  'extra-black': 900,
  'ultra-bold': 900,
  'heavy-black': 900,
  fat: 900,
  poster: 900
};
var sp = ' ';
var italicRE = /(italic|oblique)$/i;

var fontCache = {};

module.exports = function (fonts, size, lineHeight) {
  var cssData = fontCache[fonts];
  if (!cssData) {
    if (!Array.isArray(fonts)) {
      fonts = [fonts];
    }
    var weight = 400;
    var style = 'normal';
    var fontFamilies = [];
    var haveWeight, haveStyle;
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      var parts = font.split(' ');
      var maybeWeight = parts[parts.length - 1].toLowerCase();
      if (maybeWeight == 'normal' || maybeWeight == 'italic' || maybeWeight == 'oblique') {
        style = haveStyle ? style : maybeWeight;
        parts.pop();
        maybeWeight = parts[parts.length - 1].toLowerCase();
      } else if (italicRE.test(maybeWeight)) {
        maybeWeight = maybeWeight.replace(italicRE, '');
        style = haveStyle ? style : parts[parts.length - 1].replace(maybeWeight, '');
      }
      for (var w in fontWeights) {
        if (maybeWeight == w || maybeWeight == w.replace('-', '') || maybeWeight == w.replace('-', sp)) {
          weight = haveWeight ? weight : fontWeights[w];
          parts.pop();
          break;
        }
      }
      if (!haveWeight && typeof maybeWeight == 'number') {
        weight = maybeWeight;
      }
      var fontFamily = parts.join(sp).replace('Klokantech Noto Sans', 'Noto Sans');
      if (fontFamily.indexOf(sp) !== -1) {
        fontFamily = '"' + fontFamily + '"';
      }
      fontFamilies.push(fontFamily);
    }
    // CSS font property: font-style font-weight font-size/line-height font-family
    cssData = fontCache[fonts] = [style, weight, fontFamilies];
  }
  return cssData[0] + sp + cssData[1] + sp + size + 'px' + (lineHeight ? '/' + lineHeight : '') + sp + cssData[2];
};

/***/ }),

/***/ "./node_modules/webfont-matcher/lib/fonts/google.js":
/*!**********************************************************!*\
  !*** ./node_modules/webfont-matcher/lib/fonts/google.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Generated by CoffeeScript 1.10.0
(function () {
  var families;

  module.exports = {
    icon: 'icons/google.svg',
    name: 'google',
    title: 'Google Fonts',
    link: 'google.com/fonts',
    getNames: function getNames() {
      return families;
    },
    getLink: function getLink(name) {
      return "https://fonts.google.com/specimen/" + name.replace(/( )/g, '+');
    },
    normalizeName: function normalizeName(name) {
      return name;
    }
  };

  families = ["ABeeZee", "Abel", "Abril Fatface", "Aclonica", "Acme", "Actor", "Adamina", "Advent Pro", "Aguafina Script", "Akronim", "Aladin", "Aldrich", "Alef", "Alegreya", "Alegreya SC", "Alegreya Sans", "Alegreya Sans SC", "Alex Brush", "Alfa Slab One", "Alice", "Alike", "Alike Angular", "Allan", "Allerta", "Allerta Stencil", "Allura", "Almendra", "Almendra Display", "Almendra SC", "Amarante", "Amaranth", "Amatic SC", "Amethysta", "Amiri", "Amita", "Anaheim", "Andada", "Andika", "Angkor", "Annie Use Your Telescope", "Anonymous Pro", "Antic", "Antic Didone", "Antic Slab", "Anton", "Arapey", "Arbutus", "Arbutus Slab", "Architects Daughter", "Archivo Black", "Archivo Narrow", "Arimo", "Arizonia", "Armata", "Artifika", "Arvo", "Arya", "Asap", "Asar", "Asset", "Astloch", "Asul", "Atomic Age", "Aubrey", "Audiowide", "Autour One", "Average", "Average Sans", "Averia Gruesa Libre", "Averia Libre", "Averia Sans Libre", "Averia Serif Libre", "Bad Script", "Balthazar", "Bangers", "Basic", "Battambang", "Baumans", "Bayon", "Belgrano", "Belleza", "BenchNine", "Bentham", "Berkshire Swash", "Bevan", "Bigelow Rules", "Bigshot One", "Bilbo", "Bilbo Swash Caps", "Biryani", "Bitter", "Black Ops One", "Bokor", "Bonbon", "Boogaloo", "Bowlby One", "Bowlby One SC", "Brawler", "Bree Serif", "Bubblegum Sans", "Bubbler One", "Buda", "Buenard", "Butcherman", "Butterfly Kids", "Cabin", "Cabin Condensed", "Cabin Sketch", "Caesar Dressing", "Cagliostro", "Calligraffitti", "Cambay", "Cambo", "Candal", "Cantarell", "Cantata One", "Cantora One", "Capriola", "Cardo", "Carme", "Carrois Gothic", "Carrois Gothic SC", "Carter One", "Catamaran", "Caudex", "Caveat", "Caveat Brush", "Cedarville Cursive", "Ceviche One", "Changa One", "Chango", "Chau Philomene One", "Chela One", "Chelsea Market", "Chenla", "Cherry Cream Soda", "Cherry Swash", "Chewy", "Chicle", "Chivo", "Chonburi", "Cinzel", "Cinzel Decorative", "Clicker Script", "Coda", "Coda Caption", "Codystar", "Combo", "Comfortaa", "Coming Soon", "Concert One", "Condiment", "Content", "Contrail One", "Convergence", "Cookie", "Copse", "Corben", "Courgette", "Cousine", "Coustard", "Covered By Your Grace", "Crafty Girls", "Creepster", "Crete Round", "Crimson Text", "Croissant One", "Crushed", "Cuprum", "Cutive", "Cutive Mono", "Damion", "Dancing Script", "Dangrek", "Dawning of a New Day", "Days One", "Dekko", "Delius", "Delius Swash Caps", "Delius Unicase", "Della Respira", "Denk One", "Devonshire", "Dhurjati", "Didact Gothic", "Diplomata", "Diplomata SC", "Domine", "Donegal One", "Doppio One", "Dorsa", "Dosis", "Dr Sugiyama", "Droid Sans", "Droid Sans Mono", "Droid Serif", "Duru Sans", "Dynalight", "EB Garamond", "Eagle Lake", "Eater", "Economica", "Eczar", "Ek Mukta", "Electrolize", "Elsie", "Elsie Swash Caps", "Emblema One", "Emilys Candy", "Engagement", "Englebert", "Enriqueta", "Erica One", "Esteban", "Euphoria Script", "Ewert", "Exo", "Exo 2", "Expletus Sans", "Fanwood Text", "Fascinate", "Fascinate Inline", "Faster One", "Fasthand", "Fauna One", "Federant", "Federo", "Felipa", "Fenix", "Finger Paint", "Fira Mono", "Fira Sans", "Fjalla One", "Fjord One", "Flamenco", "Flavors", "Fondamento", "Fontdiner Swanky", "Forum", "Francois One", "Freckle Face", "Fredericka the Great", "Fredoka One", "Freehand", "Fresca", "Frijole", "Fruktur", "Fugaz One", "GFS Didot", "GFS Neohellenic", "Gabriela", "Gafata", "Galdeano", "Galindo", "Gentium Basic", "Gentium Book Basic", "Geo", "Geostar", "Geostar Fill", "Germania One", "Gidugu", "Gilda Display", "Give You Glory", "Glass Antiqua", "Glegoo", "Gloria Hallelujah", "Goblin One", "Gochi Hand", "Gorditas", "Goudy Bookletter 1911", "Graduate", "Grand Hotel", "Gravitas One", "Great Vibes", "Griffy", "Gruppo", "Gudea", "Gurajada", "Habibi", "Halant", "Hammersmith One", "Hanalei", "Hanalei Fill", "Handlee", "Hanuman", "Happy Monkey", "Headland One", "Henny Penny", "Herr Von Muellerhoff", "Hind", "Hind Siliguri", "Hind Vadodara", "Holtwood One SC", "Homemade Apple", "Homenaje", "IM Fell DW Pica", "IM Fell DW Pica SC", "IM Fell Double Pica", "IM Fell Double Pica SC", "IM Fell English", "IM Fell English SC", "IM Fell French Canon", "IM Fell French Canon SC", "IM Fell Great Primer", "IM Fell Great Primer SC", "Iceberg", "Iceland", "Imprima", "Inconsolata", "Inder", "Indie Flower", "Inika", "Inknut Antiqua", "Irish Grover", "Istok Web", "Italiana", "Italianno", "Itim", "Jacques Francois", "Jacques Francois Shadow", "Jaldi", "Jim Nightshade", "Jockey One", "Jolly Lodger", "Josefin Sans", "Josefin Slab", "Joti One", "Judson", "Julee", "Julius Sans One", "Junge", "Jura", "Just Another Hand", "Just Me Again Down Here", "Kadwa", "Kalam", "Kameron", "Kantumruy", "Karla", "Karma", "Kaushan Script", "Kavoon", "Kdam Thmor", "Keania One", "Kelly Slab", "Kenia", "Khand", "Khmer", "Khula", "Kite One", "Knewave", "Kotta One", "Koulen", "Kranky", "Kreon", "Kristi", "Krona One", "Kurale", "La Belle Aurore", "Laila", "Lakki Reddy", "Lancelot", "Lateef", "Lato", "League Script", "Leckerli One", "Ledger", "Lekton", "Lemon", "Libre Baskerville", "Life Savers", "Lilita One", "Lily Script One", "Limelight", "Linden Hill", "Lobster", "Lobster Two", "Londrina Outline", "Londrina Shadow", "Londrina Sketch", "Londrina Solid", "Lora", "Love Ya Like A Sister", "Loved by the King", "Lovers Quarrel", "Luckiest Guy", "Lusitana", "Lustria", "Macondo", "Macondo Swash Caps", "Magra", "Maiden Orange", "Mako", "Mallanna", "Mandali", "Marcellus", "Marcellus SC", "Marck Script", "Margarine", "Marko One", "Marmelad", "Martel", "Martel Sans", "Marvel", "Mate", "Mate SC", "Maven Pro", "McLaren", "Meddon", "MedievalSharp", "Medula One", "Megrim", "Meie Script", "Merienda", "Merienda One", "Merriweather", "Merriweather Sans", "Metal", "Metal Mania", "Metamorphous", "Metrophobic", "Michroma", "Milonga", "Miltonian", "Miltonian Tattoo", "Miniver", "Miss Fajardose", "Modak", "Modern Antiqua", "Molengo", "Molle", "Monda", "Monofett", "Monoton", "Monsieur La Doulaise", "Montaga", "Montez", "Montserrat", "Montserrat Alternates", "Montserrat Subrayada", "Moul", "Moulpali", "Mountains of Christmas", "Mouse Memoirs", "Mr Bedfort", "Mr Dafoe", "Mr De Haviland", "Mrs Saint Delafield", "Mrs Sheppards", "Muli", "Mystery Quest", "NTR", "Neucha", "Neuton", "New Rocker", "News Cycle", "Niconne", "Nixie One", "Nobile", "Nokora", "Norican", "Nosifer", "Nothing You Could Do", "Noticia Text", "Noto Sans", "Noto Serif", "Nova Cut", "Nova Flat", "Nova Mono", "Nova Oval", "Nova Round", "Nova Script", "Nova Slim", "Nova Square", "Numans", "Nunito", "Odor Mean Chey", "Offside", "Old Standard TT", "Oldenburg", "Oleo Script", "Oleo Script Swash Caps", "Open Sans", "Open Sans Condensed", "Oranienbaum", "Orbitron", "Oregano", "Orienta", "Original Surfer", "Oswald", "Over the Rainbow", "Overlock", "Overlock SC", "Ovo", "Oxygen", "Oxygen Mono", "PT Mono", "PT Sans", "PT Sans Caption", "PT Sans Narrow", "PT Serif", "PT Serif Caption", "Pacifico", "Palanquin", "Palanquin Dark", "Paprika", "Parisienne", "Passero One", "Passion One", "Pathway Gothic One", "Patrick Hand", "Patrick Hand SC", "Patua One", "Paytone One", "Peddana", "Peralta", "Permanent Marker", "Petit Formal Script", "Petrona", "Philosopher", "Piedra", "Pinyon Script", "Pirata One", "Plaster", "Play", "Playball", "Playfair Display", "Playfair Display SC", "Podkova", "Poiret One", "Poller One", "Poly", "Pompiere", "Pontano Sans", "Poppins", "Port Lligat Sans", "Port Lligat Slab", "Pragati Narrow", "Prata", "Preahvihear", "Press Start 2P", "Princess Sofia", "Prociono", "Prosto One", "Puritan", "Purple Purse", "Quando", "Quantico", "Quattrocento", "Quattrocento Sans", "Questrial", "Quicksand", "Quintessential", "Qwigley", "Racing Sans One", "Radley", "Rajdhani", "Raleway", "Raleway Dots", "Ramabhadra", "Ramaraja", "Rambla", "Rammetto One", "Ranchers", "Rancho", "Ranga", "Rationale", "Ravi Prakash", "Redressed", "Reenie Beanie", "Revalia", "Rhodium Libre", "Ribeye", "Ribeye Marrow", "Righteous", "Risque", "Roboto", "Roboto Condensed", "Roboto Mono", "Roboto Slab", "Rochester", "Rock Salt", "Rokkitt", "Romanesco", "Ropa Sans", "Rosario", "Rosarivo", "Rouge Script", "Rozha One", "Rubik", "Rubik Mono One", "Rubik One", "Ruda", "Rufina", "Ruge Boogie", "Ruluko", "Rum Raisin", "Ruslan Display", "Russo One", "Ruthie", "Rye", "Sacramento", "Sahitya", "Sail", "Salsa", "Sanchez", "Sancreek", "Sansita One", "Sarala", "Sarina", "Sarpanch", "Satisfy", "Scada", "Scheherazade", "Schoolbell", "Seaweed Script", "Sevillana", "Seymour One", "Shadows Into Light", "Shadows Into Light Two", "Shanti", "Share", "Share Tech", "Share Tech Mono", "Shojumaru", "Short Stack", "Siemreap", "Sigmar One", "Signika", "Signika Negative", "Simonetta", "Sintony", "Sirin Stencil", "Six Caps", "Skranji", "Slabo 13px", "Slabo 27px", "Slackey", "Smokum", "Smythe", "Sniglet", "Snippet", "Snowburst One", "Sofadi One", "Sofia", "Sonsie One", "Sorts Mill Goudy", "Source Code Pro", "Source Sans Pro", "Source Serif Pro", "Special Elite", "Spicy Rice", "Spinnaker", "Spirax", "Squada One", "Sree Krushnadevaraya", "Stalemate", "Stalinist One", "Stardos Stencil", "Stint Ultra Condensed", "Stint Ultra Expanded", "Stoke", "Strait", "Sue Ellen Francisco", "Sumana", "Sunshiney", "Supermercado One", "Sura", "Suranna", "Suravaram", "Suwannaphum", "Swanky and Moo Moo", "Syncopate", "Tangerine", "Taprom", "Tauri", "Teko", "Telex", "Tenali Ramakrishna", "Tenor Sans", "Text Me One", "The Girl Next Door", "Tienne", "Tillana", "Timmana", "Tinos", "Titan One", "Titillium Web", "Trade Winds", "Trocchi", "Trochut", "Trykker", "Tulpen One", "Ubuntu", "Ubuntu Condensed", "Ubuntu Mono", "Ultra", "Uncial Antiqua", "Underdog", "Unica One", "UnifrakturCook", "UnifrakturMaguntia", "Unkempt", "Unlock", "Unna", "VT323", "Vampiro One", "Varela", "Varela Round", "Vast Shadow", "Vesper Libre", "Vibur", "Vidaloka", "Viga", "Voces", "Volkhov", "Vollkorn", "Voltaire", "Waiting for the Sunrise", "Wallpoet", "Walter Turncoat", "Warnes", "Wellfleet", "Wendy One", "Wire One", "Work Sans", "Yanone Kaffeesatz", "Yantramanav", "Yellowtail", "Yeseva One", "Yesteryear", "Zeyada"];
}).call(undefined);

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "./olms.js":
/*!*****************!*\
  !*** ./olms.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index */ "./index.js");

var _stylefunction = __webpack_require__(/*! ./stylefunction */ "./stylefunction.js");

var _stylefunction2 = _interopRequireDefault(_stylefunction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  apply: _index.apply,
  applyBackground: _index.applyBackground,
  applyStyle: _index.applyStyle,
  stylefunction: _stylefunction2.default
};

/***/ }),

/***/ "./stylefunction.js":
/*!**************************!*\
  !*** ./stylefunction.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValue = getValue;

exports.default = function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, spriteImage, fonts) {
  if (!resolutions) {
    resolutions = [];
    for (var res = 78271.51696402048; resolutions.length < 21; res /= 2) {
      resolutions.push(res);
    }
  }
  if (typeof glStyle == 'string') {
    glStyle = JSON.parse(glStyle);
  }
  if (glStyle.version != 8) {
    throw new Error('glStyle version 8 required.');
  }

  var spriteImgSize = void 0;
  if (spriteImageUrl && !spriteImage) {
    var img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = function () {
      spriteImage = img;
      spriteImgSize = [img.width, img.height];
      olLayer.changed();
    };
    img.src = spriteImageUrl;
  }

  var ctx = document.createElement('CANVAS').getContext('2d');
  var measureCache = {};

  function wrapText(text, font, em) {
    var key = em + ',' + font + ',' + text;
    var wrappedText = measureCache[key];
    if (!wrappedText) {
      ctx.font = font;
      var oneEm = ctx.measureText('M').width;
      var width = oneEm * em;
      var words = text.split(' ');
      var line = '';
      var lines = [];
      for (var i = 0, ii = words.length; i < ii; ++i) {
        var word = words[i];
        if (ctx.measureText(line + word).width <= width) {
          line += (line ? ' ' : '') + word;
        } else {
          if (line) {
            lines.push(line);
          }
          line = word;
        }
      }
      if (line) {
        lines.push(line);
      }
      measureCache[key] = wrappedText = lines.join('\n');
    }
    return wrappedText;
  }

  var allLayers = (0, _mapboxGlStyleSpec.derefLayers)(glStyle.layers);

  var layersBySourceLayer = {};
  var mapboxLayers = [];
  var mapboxSource = void 0;
  for (var i = 0, ii = allLayers.length; i < ii; ++i) {
    var layer = allLayers[i];
    var layerId = layer.id;
    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {
      var sourceLayer = layer['source-layer'];
      if (!mapboxSource) {
        mapboxSource = layer.source;
      }
      var layers = layersBySourceLayer[sourceLayer];
      if (!layers) {
        layers = layersBySourceLayer[sourceLayer] = [];
      }
      layers.push({
        layer: layer,
        index: i
      });
      mapboxLayers.push(layerId);
    }
    // // TODO revisit when diffing gets added
    delete functionCache[layerId];
    delete filterCache[layerId];
  }
  var iconImageCache = {};

  var styles = [];
  var patternCache = {};

  var styleFunction = function styleFunction(feature, resolution) {
    var properties = feature.getProperties();
    feature.styleIds = feature.styleIds || {};
    var layers = layersBySourceLayer[properties.layer];
    if (!layers) {
      return;
    }
    var zoom = resolutions.indexOf(resolution);
    if (zoom == -1) {
      zoom = Math.round((0, _util.getZoomForResolution)(resolution, resolutions));
    }
    var type = types[feature.getGeometry().getType()];
    var f = {
      properties: properties,
      type: type
    };
    var stylesLength = -1;
    for (var _i = 0, _ii = layers.length; _i < _ii; ++_i) {
      var layerData = layers[_i];
      var _layer = layerData.layer;
      var _layerId = _layer.id;

      var layout = _layer.layout || emptyObj;
      var paint = _layer.paint || emptyObj;
      if (layout.visibility === 'none' || 'minzoom' in _layer && zoom < _layer.minzoom || 'maxzoom' in _layer && zoom >= _layer.maxzoom) {
        continue;
      }
      feature.styleIds[zoom] = feature.styleIds[zoom] || [];
      var filter = _layer.filter;
      var icon = void 0,
          iconImg = void 0;
      if (!filter || evaluateFilter(_layerId, filter, f, zoom)) {
        var color = void 0,
            opacity = void 0,
            fill = void 0,
            stroke = void 0,
            strokeColor = void 0,
            style = void 0;
        var index = layerData.index;
        if (type == 3 && _layer.type == 'fill') {
          opacity = getValue(_layer, 'paint', 'fill-opacity', zoom, f);
          if ('fill-pattern' in paint) {
            var iconImage = getValue(_layer, 'paint', 'fill-pattern', zoom, f);
            if (iconImage) {
              icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();
              if (spriteImage && spriteData && spriteData[icon]) {
                ++stylesLength;
                if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                  feature.styleIds[zoom].push(_layerId);
                }
                style = styles[stylesLength];
                if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                  style = styles[stylesLength] = new _Style2.default({
                    fill: new _Fill2.default()
                  });
                }
                fill = style.getFill();
                style.setZIndex(index);
                var icon_cache_key = icon + '.' + opacity;
                var pattern = patternCache[icon_cache_key];
                if (!pattern) {
                  var spriteImageData = spriteData[icon];
                  var canvas = document.createElement('canvas');
                  canvas.width = spriteImageData.width;
                  canvas.height = spriteImageData.height;
                  var _ctx = canvas.getContext('2d');
                  _ctx.globalAlpha = opacity;
                  _ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);
                  pattern = _ctx.createPattern(canvas, 'repeat');
                  patternCache[icon_cache_key] = pattern;
                }
                fill.setColor(pattern);
              }
            }
          } else if ('fill-color' in paint) {
            color = colorWithOpacity(getValue(_layer, 'paint', 'fill-color', zoom, f), opacity);
            if (color) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  fill: new _Fill2.default()
                });
              }
              fill = style.getFill();
              fill.setColor(color);
              style.setZIndex(index);
            }
            if ('fill-outline-color' in paint) {
              strokeColor = colorWithOpacity(getValue(_layer, 'paint', 'fill-outline-color', zoom, properties), opacity);
            } else if ('fill-antialias' in paint) {
              strokeColor = color;
            }
            if (strokeColor) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  stroke: new _Stroke2.default()
                });
              }
              stroke = style.getStroke();
              stroke.setColor(strokeColor);
              stroke.setWidth(1);
              style.setZIndex(index);
            }
          }
        }
        if (type != 1 && _layer.type == 'line') {
          (function () {
            color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(_layer, 'paint', 'line-color', zoom, f), getValue(_layer, 'paint', 'line-opacity', zoom, f)) : undefined;
            var width = getValue(_layer, 'paint', 'line-width', zoom, f);
            if (color && width > 0) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  stroke: new _Stroke2.default()
                });
              }
              stroke = style.getStroke();
              stroke.setLineCap(getValue(_layer, 'layout', 'line-cap', zoom, f));
              stroke.setLineJoin(getValue(_layer, 'layout', 'line-join', zoom, f));
              stroke.setMiterLimit(getValue(_layer, 'layout', 'line-miter-limit', zoom, f));
              stroke.setColor(color);
              stroke.setWidth(width);
              stroke.setLineDash(paint['line-dasharray'] ? getValue(_layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {
                return x * width;
              }) : null);
              style.setZIndex(index);
            }
          })();
        }

        var hasImage = false;
        var text = null;
        var skipLabel = void 0;
        if ((type == 1 || type == 2) && 'icon-image' in layout) {
          var _iconImage = getValue(_layer, 'layout', 'icon-image', zoom, f);
          if (_iconImage) {
            icon = typeof _iconImage === 'string' ? fromTemplate(_iconImage, properties) : _iconImage.toString();
            var styleGeom = undefined;
            if (spriteImage && spriteData && spriteData[icon]) {
              if (type == 2) {
                var geom = feature.getGeometry();
                // ol package and ol-debug.js only
                if (geom.getFlatMidpoint) {
                  var extent = geom.getExtent();
                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));
                  if (size > 150) {
                    //FIXME Do not hard-code a size of 150
                    styleGeom = new _Point2.default(geom.getFlatMidpoint());
                  }
                }
              }
              if (type !== 2 || styleGeom) {
                ++stylesLength;
                if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                  feature.styleIds[zoom].push(_layerId);
                }
                style = styles[stylesLength];
                if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
                  style = styles[stylesLength] = new _Style2.default();
                }
                style.setGeometry(styleGeom);
                var iconSize = getValue(_layer, 'layout', 'icon-size', zoom, f);
                var iconColor = paint['icon-color'] !== undefined ? getValue(_layer, 'paint', 'icon-color', zoom, f) : null;
                var iconTranslate = getValue(_layer, 'paint', 'icon-translate', zoom, f);
                var iconTranslateAnchor = getValue(_layer, 'paint', 'icon-translate-anchor', zoom, f);
                var iconAnchorValue = getValue(_layer, 'layout', 'icon-anchor', zoom, f);
                var iconOffset = getValue(_layer, 'layout', 'icon-offset', zoom, f);

                var _covertIconAnchor = covertIconAnchor(iconAnchorValue),
                    anchorOffset = _covertIconAnchor.anchorOffset,
                    _covertIconAnchor$ico = _covertIconAnchor.iconAnchor,
                    iconAnchor = _covertIconAnchor$ico === undefined ? iconAnchorValue : _covertIconAnchor$ico;

                var _icon_cache_key = icon + '.' + iconSize + '.' + iconTranslate + '.' + iconTranslateAnchor + '.' + iconAnchor + '.' + iconOffset + '.' + anchorOffset;
                if (iconColor !== null) {
                  _icon_cache_key += '.' + iconColor;
                }
                iconImg = iconImageCache[_icon_cache_key];
                if (!iconImg) {
                  var _spriteImageData = spriteData[icon];
                  var _canvas = document.createElement('canvas');
                  _canvas.width = _spriteImageData.width;
                  _canvas.height = _spriteImageData.height;
                  var _ctx2 = _canvas.getContext('2d');
                  _ctx2.drawImage(spriteImage, _spriteImageData.x, _spriteImageData.y, _spriteImageData.width, _spriteImageData.height, 0, 0, _spriteImageData.width, _spriteImageData.height);
                  var data = _ctx2.getImageData(0, 0, _canvas.width, _canvas.height);
                  if (iconColor !== null) {
                    // cut out the sprite and color it
                    color = colorWithOpacity(iconColor, 1);
                    for (var c = 0, cc = data.data.length; c < cc; c += 4) {
                      data.data[c] = color[0];
                      data.data[c + 1] = color[1];
                      data.data[c + 2] = color[2];
                    }
                  }
                  _ctx2.putImageData(data, 0, 0);
                  var translateOffset = [iconTranslate[0] / _spriteImageData.width, iconTranslate[1] / _spriteImageData.height];
                  iconImg = iconImageCache[_icon_cache_key] = new _Icon2.default({
                    img: _canvas,
                    anchorOrigin: iconAnchor,
                    anchor: [iconOffset[0] + anchorOffset[0] + translateOffset[0], iconOffset[1] + anchorOffset[1] - translateOffset[1]],
                    imgSize: [_canvas.width, _canvas.height],
                    scale: iconSize / _spriteImageData.pixelRatio
                  });
                }
                var rotateValue = getValue(_layer, 'layout', 'icon-rotate', zoom, f);
                if (rotateValue.indexOf && rotateValue.indexOf('{') === 0) {
                  rotateValue = 360 - fromTemplate(rotateValue, properties);
                }
                iconImg.setRotation((0, _util.deg2rad)(rotateValue));
                iconImg.setOpacity(getValue(_layer, 'paint', 'icon-opacity', zoom, f));
                style.setImage(iconImg);
                text = style.getText();
                style.setText(undefined);
                style.setZIndex(99999 - index);
                hasImage = true;
                skipLabel = false;
              } else {
                skipLabel = true;
              }
            }
          }
        }

        if (type == 1 && 'circle-radius' in paint) {
          ++stylesLength;
          if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
            feature.styleIds[zoom].push(_layerId);
          }
          style = styles[stylesLength];
          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
            style = styles[stylesLength] = new _Style2.default();
          }
          var circleRadius = getValue(_layer, 'paint', 'circle-radius', zoom, f);
          var circleStrokeColor = getValue(_layer, 'paint', 'circle-stroke-color', zoom, f);
          var circleColor = getValue(_layer, 'paint', 'circle-color', zoom, f);
          var circleOpacity = getValue(_layer, 'paint', 'circle-opacity', zoom, f);
          var circleStrokeWidth = getValue(_layer, 'paint', 'circle-stroke-width', zoom, f);
          var circleStrokeOpacity = getValue(_layer, 'paint', 'circle-stroke-opacity', zoom, f);
          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleOpacity + '.' + circleStrokeWidth + '.' + circleStrokeOpacity;
          iconImg = iconImageCache[cache_key];
          if (!iconImg) {
            iconImg = new _Circle2.default({
              radius: circleRadius,
              stroke: circleStrokeWidth === 0 ? undefined : new _Stroke2.default({
                width: circleStrokeWidth,
                color: colorWithOpacity(circleStrokeColor, circleStrokeOpacity)
              }),
              fill: new _Fill2.default({
                color: colorWithOpacity(circleColor, circleOpacity)
              })
            });
          }
          style.setImage(iconImg);
          text = style.getText();
          style.setText(undefined);
          style.setGeometry(undefined);
          style.setZIndex(99999 - index);
          hasImage = true;
        }

        var label = void 0;
        if ('text-field' in layout) {
          var textField = getValue(_layer, 'layout', 'text-field', zoom, f);
          label = fromTemplate(textField, properties);
        }
        if (label && !skipLabel) {
          if (!hasImage) {
            ++stylesLength;
            if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
              feature.styleIds[zoom].push(_layerId);
            }
            style = styles[stylesLength];
            if (!style || !style.getText() || style.getFill() || style.getStroke()) {
              style = styles[stylesLength] = new _Style2.default();
            }
            style.setImage(undefined);
            style.setGeometry(undefined);
          }
          if (!style.getText()) {
            style.setText(text || new _Text2.default());
          }
          text = style.getText();
          var textSize = getValue(_layer, 'layout', 'text-size', zoom, f);
          var textLineHeight = getValue(_layer, 'layout', 'text-line-height', zoom, f);
          var font = (0, _mapboxToCssFont2.default)(chooseFont(getValue(_layer, 'layout', 'text-font', zoom, f)), textSize);
          var textTransform = layout['text-transform'];
          if (textTransform == 'uppercase') {
            label = label.toUpperCase();
          } else if (textTransform == 'lowercase') {
            label = label.toLowerCase();
          }
          var wrappedLabel = type == 2 ? label : wrapText(label, font, getValue(_layer, 'layout', 'text-max-width', zoom, f));
          text.setText(wrappedLabel);
          text.setFont(font);
          text.setRotation((0, _util.deg2rad)(getValue(_layer, 'layout', 'text-rotate', zoom, f)));
          var textAnchor = getValue(_layer, 'layout', 'text-anchor', zoom, f);
          var placement = hasImage || type == 1 ? 'point' : getValue(_layer, 'layout', 'symbol-placement', zoom, f);
          text.setPlacement(placement);
          var textHaloWidth = getValue(_layer, 'paint', 'text-halo-width', zoom, f);
          var textOffset = getValue(_layer, 'layout', 'text-offset', zoom, f);
          var textTranslate = getValue(_layer, 'paint', 'text-translate', zoom, f);
          var vOffset = 0;
          var hOffset = 0;
          var textAlign = 'center';
          if (textAnchor.indexOf('left') !== -1) {
            textAlign = 'left';
            hOffset = textHaloWidth;
          } else if (textAnchor.indexOf('right') !== -1) {
            textAlign = 'right';
            hOffset = -textHaloWidth;
          }
          if (placement == 'point') {
            text.setTextAlign(textAlign);
          } else {
            text.setMaxAngle((0, _util.deg2rad)(getValue(_layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);
            text.setTextAlign();
          }
          var textBaseline = 'middle';
          if (textAnchor.indexOf('bottom') == 0) {
            textBaseline = 'bottom';
            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;
          } else if (textAnchor.indexOf('top') == 0) {
            textBaseline = 'top';
            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;
          }
          text.setTextBaseline(textBaseline);
          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);
          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);
          opacity = getValue(_layer, 'paint', 'text-opacity', zoom, f);
          var textColor = new _Fill2.default();

          textColor.setColor(colorWithOpacity(getValue(_layer, 'paint', 'text-color', zoom, f), opacity));
          text.setFill(textColor);
          var haloColor = colorWithOpacity(getValue(_layer, 'paint', 'text-halo-color', zoom, f), opacity);
          if (haloColor) {
            var textHalo = new _Stroke2.default();
            textHalo.setColor(haloColor);
            textHalo.setWidth(getValue(_layer, 'paint', 'text-halo-width', zoom, f));
            text.setStroke(textHalo);
          } else {
            text.setStroke(undefined);
          }
          style.setZIndex(99999 - index);
        }
      }
    }

    if (stylesLength > -1) {
      styles.length = stylesLength + 1;
      return styles;
    }
  };

  olLayer.setStyle(styleFunction);
  olLayer.set('mapbox-source', mapboxSource);
  olLayer.set('mapbox-layers', mapboxLayers);
  return styleFunction;
};

var _Style = __webpack_require__(/*! ol/style/Style */ "ol/style/Style");

var _Style2 = _interopRequireDefault(_Style);

var _Fill = __webpack_require__(/*! ol/style/Fill */ "ol/style/Fill");

var _Fill2 = _interopRequireDefault(_Fill);

var _Stroke = __webpack_require__(/*! ol/style/Stroke */ "ol/style/Stroke");

var _Stroke2 = _interopRequireDefault(_Stroke);

var _Icon = __webpack_require__(/*! ol/style/Icon */ "ol/style/Icon");

var _Icon2 = _interopRequireDefault(_Icon);

var _Text = __webpack_require__(/*! ol/style/Text */ "ol/style/Text");

var _Text2 = _interopRequireDefault(_Text);

var _Circle = __webpack_require__(/*! ol/style/Circle */ "ol/style/Circle");

var _Circle2 = _interopRequireDefault(_Circle);

var _Point = __webpack_require__(/*! ol/geom/Point */ "ol/geom/Point");

var _Point2 = _interopRequireDefault(_Point);

var _mapboxGlStyleSpec = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec */ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js");

var _mapboxToCssFont = __webpack_require__(/*! mapbox-to-css-font */ "./node_modules/mapbox-to-css-font/index.js");

var _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);

var _util = __webpack_require__(/*! ./util */ "./util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isFunction = _mapboxGlStyleSpec.function.isFunction; /*
                                                         ol-mapbox-style - Use Mapbox Style objects with OpenLayers
                                                         Copyright 2016-present Boundless Spatial, Inc.
                                                         License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE
                                                         */

var convertFunction = _mapboxGlStyleSpec.function.convertFunction;
var isExpression = _mapboxGlStyleSpec.expression.isExpression;
var createPropertyExpression = _mapboxGlStyleSpec.expression.createPropertyExpression;

var types = {
  'Point': 1,
  'MultiPoint': 1,
  'LineString': 2,
  'MultiLineString': 2,
  'Polygon': 3,
  'MultiPolygon': 3
};
var expressionData = function expressionData(rawExpression, propertySpec) {
  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);
  if (compiledExpression.result === 'error') {
    throw new Error(compiledExpression.value.map(function (err) {
      return err.key + ': ' + err.message;
    }).join(', '));
  }
  return compiledExpression.value;
};

var emptyObj = {};
var zoomObj = { zoom: 0 };
var functionCache = {};

/**
 * @private
 * @param {Object} layer Gl object layer.
 * @param {string} layoutOrPaint 'layout' or 'paint'.
 * @param {string} property Feature property.
 * @param {number} zoom Zoom.
 * @param {Object} feature Gl feature.
 * @return {?} Value.
 */
function getValue(layer, layoutOrPaint, property, zoom, feature) {
  var layerId = layer.id;
  if (!functionCache[layerId]) {
    functionCache[layerId] = {};
  }
  var functions = functionCache[layerId];
  if (!functions[property]) {
    var value = (layer[layoutOrPaint] || emptyObj)[property];
    var propertySpec = _mapboxGlStyleSpec.latest[layoutOrPaint + '_' + layer.type][property];
    if (value === undefined) {
      value = propertySpec.default;
    }
    var isExpr = isExpression(value);
    if (!isExpr && isFunction(value)) {
      value = convertFunction(value, propertySpec);
      isExpr = true;
    }
    if (isExpr) {
      var compiledExpression = expressionData(value, propertySpec);
      functions[property] = compiledExpression.evaluate.bind(compiledExpression);
    } else {
      if (propertySpec.type == 'color') {
        value = _mapboxGlStyleSpec.Color.parse(value);
      }
      functions[property] = function () {
        return value;
      };
    }
  }
  zoomObj.zoom = zoom;
  return functions[property](zoomObj, feature);
}

function covertIconAnchor(iconAnchor) {
  var anchorOffset = [0.5, 0.5];
  if (['top-left', 'top-right', 'bottom-left', 'bottom-right'].indexOf(iconAnchor) > -1) {
    anchorOffset = [0, 0];
  }
  if (iconAnchor === 'left') {
    iconAnchor = 'top-left';
    anchorOffset = [0, 0.5];
  }
  if (iconAnchor === 'right') {
    iconAnchor = 'top-left';
    anchorOffset = [1, 0.5];
  }
  if (iconAnchor === 'bottom') {
    iconAnchor = 'top-left';
    anchorOffset = [0.5, 1];
  }
  if (iconAnchor === 'top') {
    iconAnchor = 'top-left';
    anchorOffset = [0.5, 0];
  }
  //center
  return {
    anchorOffset: anchorOffset,
    iconAnchor: iconAnchor
  };
}

var fontMap = {};

function chooseFont(fonts, availableFonts) {
  if (fontMap[fonts]) {
    return fontMap[fonts];
  }
  if (availableFonts) {
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      if (availableFonts.indexOf(font) != -1) {
        fontMap[fonts] = font;
        break;
      }
    }
    if (!fontMap[fonts]) {
      // fallback font
      fontMap[fonts] = fonts[fonts.length - 1];
    }
  } else {
    fontMap[fonts] = fonts[0];
  }
  return fontMap[fonts];
}

var filterCache = {};

function evaluateFilter(layerId, filter, feature, zoom) {
  if (!(layerId in filterCache)) {
    filterCache[layerId] = (0, _mapboxGlStyleSpec.featureFilter)(filter).filter;
  }
  zoomObj.zoom = zoom;
  return filterCache[layerId](zoomObj, feature);
}

function colorWithOpacity(color, opacity) {
  if (color) {
    if (color.a === 0 || opacity === 0) {
      return undefined;
    }
    var a = color.a;
    opacity = opacity === undefined ? 1 : opacity;
    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';
  }
  return color;
}

var templateRegEx = /^([^]*)\{(.*)\}([^]*)$/;

function fromTemplate(text, properties) {
  var parts = void 0;
  do {
    parts = text.match(templateRegEx);
    if (parts) {
      var value = properties[parts[2]] || '';
      text = parts[1] + value + parts[3];
    }
  } while (parts);
  return text;
}

/**
 * Creates a style function from the `glStyle` object for all layers that use
 * the specified `source`, which needs to be a `"type": "vector"` or
 * `"type": "geojson"` source and applies it to the specified OpenLayers layer.
 *
 * @param {ol.layer.Vector|ol.layer.VectorTile} olLayer OpenLayers layer to
 * apply the style to. In addition to the style, the layer will get two
 * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used
 * for the layer, and `mapbox-layers` will be an array of the `id`s of the
 * `glStyle`'s layers.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>} source `source` key or an array of layer `id`s
 * from the Mapbox Style object. When a `source` key is provided, all layers for
 * the specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,
 * 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,
 * 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,
 * 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,
 * 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,
 * 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]
 * Resolutions for mapping resolution to zoom level.
 * @param {Object} [spriteData=undefined] Sprite data from the url specified in
 * the Mapbox Style object's `sprite` property. Only required if a `sprite`
 * property is specified in the Mapbox Style object.
 * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite
 * specified in the Mapbox Style object's `sprite` property. Only required if a
 * `sprite` property is specified in the Mapbox Style object.
 * @param {Array<string>} [fonts=undefined] Array of available fonts, using the
 * same font names as the Mapbox Style object. If not provided, the style
 * function will always use the first font from the font array.
 * @return {ol.style.StyleFunction} Style function for use in
 * `ol.layer.Vector` or `ol.layer.VectorTile`.
 */

/***/ }),

/***/ "./util.js":
/*!*****************!*\
  !*** ./util.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deg2rad = deg2rad;
exports.getZoomForResolution = getZoomForResolution;
function deg2rad(degrees) {
  return degrees * Math.PI / 180;
}

function getZoomForResolution(resolution, resolutions) {
  var i = 0;
  var ii = resolutions.length;
  for (; i < ii; ++i) {
    var candidate = resolutions[i];
    if (candidate < resolution && i + 1 < ii) {
      var zoomFactor = resolutions[i] / resolutions[i + 1];
      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);
    }
  }
  return ii - 1;
}

/***/ }),

/***/ "ol/Map":
/*!*************************!*\
  !*** external "ol.Map" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.Map;

/***/ }),

/***/ "ol/Observable":
/*!********************************!*\
  !*** external "ol.Observable" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.Observable;

/***/ }),

/***/ "ol/format/GeoJSON":
/*!************************************!*\
  !*** external "ol.format.GeoJSON" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.format.GeoJSON;

/***/ }),

/***/ "ol/format/MVT":
/*!********************************!*\
  !*** external "ol.format.MVT" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.format.MVT;

/***/ }),

/***/ "ol/geom/Point":
/*!********************************!*\
  !*** external "ol.geom.Point" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.geom.Point;

/***/ }),

/***/ "ol/layer/Tile":
/*!********************************!*\
  !*** external "ol.layer.Tile" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.layer.Tile;

/***/ }),

/***/ "ol/layer/Vector":
/*!**********************************!*\
  !*** external "ol.layer.Vector" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.layer.Vector;

/***/ }),

/***/ "ol/layer/VectorTile":
/*!**************************************!*\
  !*** external "ol.layer.VectorTile" ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.layer.VectorTile;

/***/ }),

/***/ "ol/proj":
/*!**************************!*\
  !*** external "ol.proj" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.proj;

/***/ }),

/***/ "ol/source/TileJSON":
/*!*************************************!*\
  !*** external "ol.source.TileJSON" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.source.TileJSON;

/***/ }),

/***/ "ol/source/Vector":
/*!***********************************!*\
  !*** external "ol.source.Vector" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.source.Vector;

/***/ }),

/***/ "ol/source/VectorTile":
/*!***************************************!*\
  !*** external "ol.source.VectorTile" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.source.VectorTile;

/***/ }),

/***/ "ol/source/XYZ":
/*!********************************!*\
  !*** external "ol.source.XYZ" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.source.XYZ;

/***/ }),

/***/ "ol/style/Circle":
/*!**********************************!*\
  !*** external "ol.style.Circle" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Circle;

/***/ }),

/***/ "ol/style/Fill":
/*!********************************!*\
  !*** external "ol.style.Fill" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Fill;

/***/ }),

/***/ "ol/style/Icon":
/*!********************************!*\
  !*** external "ol.style.Icon" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Icon;

/***/ }),

/***/ "ol/style/Stroke":
/*!**********************************!*\
  !*** external "ol.style.Stroke" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Stroke;

/***/ }),

/***/ "ol/style/Style":
/*!*********************************!*\
  !*** external "ol.style.Style" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Style;

/***/ }),

/***/ "ol/style/Text":
/*!********************************!*\
  !*** external "ol.style.Text" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Text;

/***/ }),

/***/ "ol/tilegrid":
/*!******************************!*\
  !*** external "ol.tilegrid" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.tilegrid;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbG1zL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL29sbXMvLi9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL0BtYXBib3gvbWFwYm94LWdsLXN0eWxlLXNwZWMvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvbWFwYm94LXRvLWNzcy1mb250L2luZGV4LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvd2ViZm9udC1tYXRjaGVyL2xpYi9mb250cy9nb29nbGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL29sbXMuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL3N0eWxlZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL3V0aWwuanMiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLk1hcFwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5PYnNlcnZhYmxlXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLmZvcm1hdC5HZW9KU09OXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLmZvcm1hdC5NVlRcIiIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIFwib2wuZ2VvbS5Qb2ludFwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5sYXllci5UaWxlXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLmxheWVyLlZlY3RvclwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5sYXllci5WZWN0b3JUaWxlXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLnByb2pcIiIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIFwib2wuc291cmNlLlRpbGVKU09OXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLnNvdXJjZS5WZWN0b3JcIiIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIFwib2wuc291cmNlLlZlY3RvclRpbGVcIiIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIFwib2wuc291cmNlLlhZWlwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5zdHlsZS5DaXJjbGVcIiIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIFwib2wuc3R5bGUuRmlsbFwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5zdHlsZS5JY29uXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLnN0eWxlLlN0cm9rZVwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5zdHlsZS5TdHlsZVwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5zdHlsZS5UZXh0XCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLnRpbGVncmlkXCIiXSwibmFtZXMiOlsiYXBwbHlTdHlsZSIsImFwcGx5QmFja2dyb3VuZCIsImFwcGx5IiwiZ2V0TGF5ZXIiLCJnZXRTb3VyY2UiLCJhdmFpbGFibGVGb250cyIsImxvYWRGb250IiwiZm9udHMiLCJpIiwiaWkiLCJBcnJheSIsImlzQXJyYXkiLCJzdG9wcyIsImxlbmd0aCIsImdvb2dsZUZhbWlsaWVzIiwiZ29vZ2xlRm9udHMiLCJnZXROYW1lcyIsImZhbWlsaWVzIiwibWFwIiwiZm9udCIsInNwbGl0IiwicmVwbGFjZSIsImZhbWlseSIsImluZGV4T2YiLCJwdXNoIiwiZm9udFVybCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm1hcmt1cCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwicmVsIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJhcHBlbmRDaGlsZCIsImRlZmF1bHRGb250IiwicHJlcHJvY2VzcyIsImxheWVyIiwibGF5b3V0Iiwic3ByaXRlUmVnRXgiLCJ3aXRoUGF0aCIsInVybCIsInBhdGgiLCJ0b1Nwcml0ZVVybCIsImV4dGVuc2lvbiIsInBhcnRzIiwibWF0Y2giLCJnbFN0eWxlIiwic291cmNlIiwicmVzb2x1dGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIkpTT04iLCJwYXJzZSIsInZlcnNpb24iLCJFcnJvciIsInNwcml0ZVNjYWxlIiwic3ByaXRlRGF0YSIsInNwcml0ZUltYWdlVXJsIiwic3ByaXRlIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNpemVGYWN0b3IiLCJzcHJpdGVVcmwiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwidGhlbiIsInJlc3BvbnNlIiwic3RhdHVzIiwianNvbiIsInIiLCJzcHJpdGVzSnNvbiIsInVuZGVmaW5lZCIsIm9uQ2hhbmdlIiwiY2F0Y2giLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJzdHlsZSIsInNldFN0eWxlIiwiVmVjdG9yVGlsZUxheWVyIiwiVmVjdG9yTGF5ZXIiLCJsYXllcnMiLCJpZCIsImUiLCJzZXRUaW1lb3V0Iiwic2V0QmFja2dyb3VuZCIsImJhY2tncm91bmQiLCJ0eXBlIiwidXBkYXRlU3R5bGUiLCJlbGVtZW50IiwiZ2V0VGFyZ2V0RWxlbWVudCIsInBhaW50Iiwiem9vbSIsImdldFZpZXciLCJnZXRab29tIiwiYmciLCJDb2xvciIsInRvU3RyaW5nIiwib3BhY2l0eSIsInZpc2liaWxpdHkiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvbiIsInNvbWUiLCJsIiwiZ2V0U291cmNlSWRCeVJlZiIsInJlZiIsInNvdXJjZUlkIiwicHJvY2Vzc1N0eWxlIiwiYmFzZVVybCIsImhvc3QiLCJhY2Nlc3NUb2tlbiIsInZpZXciLCJnZXRDZW50ZXIiLCJzZXRDZW50ZXIiLCJjZW50ZXIiLCJzZXRab29tIiwiZml0IiwiZ2V0UHJvamVjdGlvbiIsImdldEV4dGVudCIsIm5lYXJlc3QiLCJzaXplIiwiZ2V0U2l6ZSIsImdsTGF5ZXJzIiwiZ2VvSnNvbkZvcm1hdCIsIkdlb0pTT04iLCJsYXllcklkcyIsImZpbmFsaXplTGF5ZXIiLCJhZGRMYXllciIsInNldFZpc2libGUiLCJvbmNlIiwiZ2xMYXllciIsImdsU291cmNlIiwiZ2xTb3VyY2VJZCIsIm1hcGlkIiwic291cmNlcyIsInRpbGVzIiwidGlsZUdyaWQiLCJ0aWxlU2l6ZSIsIm1heFpvb20iLCJtYXh6b29tIiwibWluWm9vbSIsIm1pbnpvb20iLCJkZWNsdXR0ZXIiLCJtYXhSZXNvbHV0aW9uIiwiZ2V0TWluWm9vbSIsImdldFJlc29sdXRpb24iLCJWZWN0b3JUaWxlU291cmNlIiwiYXR0cmlidXRpb25zIiwiYXR0cmlidXRpb24iLCJmb3JtYXQiLCJNVlQiLCJ1cmxzIiwidmlzaWJsZSIsInpJbmRleCIsInRpbGVqc29uIiwiVGlsZUpTT04iLCJrZXkiLCJnZXRTdGF0ZSIsInRpbGVKU09ORG9jIiwiZ2V0VGlsZUpTT04iLCJ0aWxlIiwiZ2V0VGlsZUdyaWQiLCJzZXRTb3VyY2UiLCJnZXRBdHRyaWJ1dGlvbnMiLCJnZXRNYXhab29tIiwic2V0TWF4UmVzb2x1dGlvbiIsImNyb3NzT3JpZ2luIiwiWFlaIiwic2V0VGlsZUxvYWRGdW5jdGlvbiIsInNyYyIsImJib3giLCJnZXRUaWxlQ29vcmRFeHRlbnQiLCJnZXRUaWxlQ29vcmQiLCJnZXRJbWFnZSIsIlRpbGVMYXllciIsImRhdGEiLCJmZWF0dXJlcyIsImdlb0pzb25VcmwiLCJyZWFkRmVhdHVyZXMiLCJmZWF0dXJlUHJvamVjdGlvbiIsIlZlY3RvclNvdXJjZSIsInNldCIsIk1hcCIsInRhcmdldCIsImEiLCJwYXRobmFtZSIsInNsaWNlIiwiam9pbiIsInN1YnN0ciIsImxheWVySWQiLCJnZXRMYXllcnMiLCJnZXRBcnJheSIsImdldCIsIiR2ZXJzaW9uIiwiJHJvb3QiLCJyZXF1aXJlZCIsInZhbHVlcyIsImRvYyIsImV4YW1wbGUiLCJuYW1lIiwibWV0YWRhdGEiLCJ2YWx1ZSIsImJlYXJpbmciLCJwZXJpb2QiLCJ1bml0cyIsInBpdGNoIiwibGlnaHQiLCJhbmNob3IiLCJjb2xvciIsImludGVuc2l0eSIsImdseXBocyIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImRlbGF5Iiwic291cmNlX3ZlY3RvciIsInZlY3RvciIsImJvdW5kcyIsInNjaGVtZSIsInh5eiIsInRtcyIsInByb21vdGVJZCIsInNvdXJjZV9yYXN0ZXIiLCJyYXN0ZXIiLCJzb3VyY2VfcmFzdGVyX2RlbSIsImVuY29kaW5nIiwidGVycmFyaXVtIiwibWFwYm94Iiwic291cmNlX2dlb2pzb24iLCJnZW9qc29uIiwiYnVmZmVyIiwibWF4aW11bSIsIm1pbmltdW0iLCJ0b2xlcmFuY2UiLCJjbHVzdGVyIiwiY2x1c3RlclJhZGl1cyIsImNsdXN0ZXJNYXhab29tIiwiY2x1c3RlclByb3BlcnRpZXMiLCJsaW5lTWV0cmljcyIsImdlbmVyYXRlSWQiLCJzb3VyY2VfdmlkZW8iLCJ2aWRlbyIsImNvb3JkaW5hdGVzIiwic291cmNlX2ltYWdlIiwiaW1hZ2UiLCJmaWxsIiwianMiLCJhbmRyb2lkIiwiaW9zIiwibWFjb3MiLCJsaW5lIiwic3ltYm9sIiwiY2lyY2xlIiwiaGVhdG1hcCIsImhpbGxzaGFkZSIsImZpbHRlciIsImxheW91dF9iYWNrZ3JvdW5kIiwibm9uZSIsImxheW91dF9maWxsIiwiZXhwcmVzc2lvbiIsImludGVycG9sYXRlZCIsInBhcmFtZXRlcnMiLCJsYXlvdXRfY2lyY2xlIiwibGF5b3V0X2hlYXRtYXAiLCJsYXlvdXRfbGluZSIsImJ1dHQiLCJyb3VuZCIsInNxdWFyZSIsImJldmVsIiwibWl0ZXIiLCJyZXF1aXJlcyIsImxheW91dF9zeW1ib2wiLCJwb2ludCIsImF1dG8iLCJ2aWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwiYm90aCIsInRva2VucyIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsInVwcGVyY2FzZSIsImxvd2VyY2FzZSIsImxheW91dF9yYXN0ZXIiLCJsYXlvdXRfaGlsbHNoYWRlIiwiZmlsdGVyX29wZXJhdG9yIiwiYWxsIiwiYW55IiwiaGFzIiwiZ2VvbWV0cnlfdHlwZSIsIlBvaW50IiwiTGluZVN0cmluZyIsIlBvbHlnb24iLCJmdW5jdGlvbl9zdG9wIiwiZXhwcmVzc2lvbl9uYW1lIiwiZ3JvdXAiLCJsaXRlcmFsIiwiYXJyYXkiLCJhdCIsImNvYWxlc2NlIiwic3RlcCIsImludGVycG9sYXRlIiwibG4yIiwicGkiLCJzdHJpbmciLCJudW1iZXIiLCJib29sZWFuIiwib2JqZWN0IiwiY29sbGF0b3IiLCJyZ2IiLCJyZ2JhIiwicHJvcGVydGllcyIsImFjY3VtdWxhdGVkIiwic3FydCIsImxvZzEwIiwibG4iLCJsb2cyIiwic2luIiwiY29zIiwidGFuIiwiYXNpbiIsImFjb3MiLCJhdGFuIiwibWluIiwibWF4IiwiYWJzIiwiY2VpbCIsImZsb29yIiwid2l0aGluIiwidXBjYXNlIiwiZG93bmNhc2UiLCJjb25jYXQiLCJwb3NpdGlvbiIsInBhaW50X2ZpbGwiLCJwYWludF9saW5lIiwicGFpbnRfY2lyY2xlIiwicGFpbnRfaGVhdG1hcCIsInBhaW50X3N5bWJvbCIsIm92ZXJyaWRhYmxlIiwicGFpbnRfcmFzdGVyIiwibGluZWFyIiwicGFpbnRfaGlsbHNoYWRlIiwicGFpbnRfYmFja2dyb3VuZCIsInY4IiwiYmFzZSIsInByb3BlcnR5IiwiaWRlbnRpdHkiLCJleHBvbmVudGlhbCIsImludGVydmFsIiwiY2F0ZWdvcmljYWwiLCJjb2xvclNwYWNlIiwibGFiIiwiaGNsIiwiY29uc3RhbnQiLCJzdHJpbmdPckNoYXIiLCJqc29uU3RyaW5naWZ5UHJldHR5Q29tcGFjdCIsInN0cmluZ2lmeSIsInBhc3NlZE9iaiIsIm9wdGlvbnMiLCJpbmRlbnQiLCJtYXhMZW5ndGgiLCJyZXBsYWNlciIsIkluZmluaXR5IiwiX3N0cmluZ2lmeSIsIm9iaiIsImN1cnJlbnRJbmRlbnQiLCJyZXNlcnZlZCIsImVuZCIsImluZGV4IiwiaXRlbXMiLCJrZXlQYXJ0Iiwia2V5cyIsIm5leHRJbmRlbnQiLCJwcmV0dGlmaWVkIiwic3RhcnQiLCJ0b0pTT04iLCJzdHJpbmdMaXRlcmFsIiwiT2JqZWN0Iiwic29ydEtleXNCeSIsInJlZmVyZW5jZSIsInJlc3VsdCIsImtleSQxIiwic3BhY2UiLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJnbG9iYWwiLCJzZWxmIiwiY29tbW9uanNSZXF1aXJlIiwiY3JlYXRlQ29tbW9uanNNb2R1bGUiLCJmbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJwdW55Y29kZSIsInJvb3QiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJtYXhJbnQiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsIk1hdGgiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJSYW5nZUVycm9yIiwibWFwRG9tYWluIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJvdXRwdXQiLCJjb3VudGVyIiwiZXh0cmEiLCJjaGFyQ29kZUF0IiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJrIiwiZGVjb2RlIiwiaW5wdXQiLCJpbnB1dExlbmd0aCIsIm91dCIsIm4iLCJiaWFzIiwiYmFzaWMiLCJqIiwib2xkaSIsInciLCJ0IiwiYmFzZU1pbnVzVCIsImxhc3RJbmRleE9mIiwic3BsaWNlIiwiZW5jb2RlIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsIm0iLCJxIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsInRvVW5pY29kZSIsInRlc3QiLCJ0b0xvd2VyQ2FzZSIsInRvQVNDSUkiLCJoYXNPd25Qcm9wZXJ0eSIsInV0aWwiLCJpc1N0cmluZyIsImFyZyIsImlzT2JqZWN0IiwiaXNOdWxsIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJwcm9wIiwicHJvdG90eXBlIiwiY2FsbCIsInFzIiwic2VwIiwiZXEiLCJyZWdleHAiLCJtYXhLZXlzIiwibGVuIiwieCIsImlkeCIsImtzdHIiLCJ2c3RyIiwidiIsImRlY29kZVVSSUNvbXBvbmVudCIsInN0cmluZ2lmeVByaW1pdGl2ZSIsImlzRmluaXRlIiwia3MiLCJlbmNvZGVVUklDb21wb25lbnQiLCJxdWVyeXN0cmluZyIsInF1ZXJ5c3RyaW5nXzEiLCJxdWVyeXN0cmluZ18yIiwicXVlcnlzdHJpbmdfMyIsInF1ZXJ5c3RyaW5nXzQiLCJ1cmxQYXJzZSIsInVybFJlc29sdmUiLCJyZXNvbHZlT2JqZWN0IiwidXJsUmVzb2x2ZU9iamVjdCIsImZvcm1hdCQxIiwidXJsRm9ybWF0IiwiVXJsXzEiLCJVcmwiLCJwcm90b2NvbCIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsImhvc3RuYW1lIiwiaGFzaCIsInNlYXJjaCIsInF1ZXJ5IiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsInVuc2FmZVByb3RvY29sIiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInBhcnNlUXVlcnlTdHJpbmciLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJUeXBlRXJyb3IiLCJxdWVyeUluZGV4Iiwic3BsaXR0ZXIiLCJ1U3BsaXQiLCJzbGFzaFJlZ2V4IiwicmVzdCIsInRyaW0iLCJzaW1wbGVQYXRoIiwiZXhlYyIsInByb3RvIiwibG93ZXJQcm90byIsImhvc3RFbmQiLCJoZWMiLCJhdFNpZ24iLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwidW5zaGlmdCIsInAiLCJoIiwiYWUiLCJlc2MiLCJlc2NhcGUiLCJxbSIsInMiLCJjaGFyQXQiLCJyZWxhdGl2ZSIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJyZWxQYXRoIiwic2hpZnQiLCJpc1NvdXJjZUFicyIsImlzUmVsQWJzIiwibXVzdEVuZEFicyIsInJlbW92ZUFsbERvdHMiLCJzcmNQYXRoIiwicHN5Y2hvdGljIiwicG9wIiwiYXV0aEluSG9zdCIsImxhc3QiLCJoYXNUcmFpbGluZ1NsYXNoIiwidXAiLCJpc0Fic29sdXRlIiwiZ2V0UHJvcGVydHlSZWZlcmVuY2UiLCJwcm9wZXJ0eU5hbWUiLCJpJDEiLCJlYWNoU291cmNlIiwiY2FsbGJhY2siLCJlYWNoTGF5ZXIiLCJsaXN0IiwiZWFjaFByb3BlcnR5IiwiaW5uZXIiLCJwcm9wZXJ0eVR5cGUiLCJmb3JFYWNoIiwiZWFjaExheW91dCIsImVhY2hQYWludCIsInJlc29sdmVDb25zdGFudCIsImNvbnN0YW50cyIsImlzRnVuY3Rpb24iLCJyZW5hbWVQcm9wZXJ0eSIsImZyb20iLCJ0byIsIm1pZ3JhdGVUb1Y4IiwiY29vcmQiLCJyZXZlcnNlIiwic3RvcCIsIm1pZ3JhdGVGb250c3RhY2tVUkwiLCJpbnB1dFBhcnNlZCIsImlucHV0UGF0aG5hbWVQYXJ0cyIsIm1pZ3JhdGVGb250U3RhY2siLCJzcGxpdEFuZFRyaW0iLCJmaXJzdFN5bWJvbExheWVyIiwic3ltYm9sTGF5ZXJzIiwiZXh0ZW5kIiwiaW5wdXRzIiwiYXJndW1lbnRzIiwiUGFyc2luZ0Vycm9yIiwibWVzc2FnZSIsIl9fcHJvdG9fXyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiU2NvcGUiLCJwYXJlbnQiLCJiaW5kaW5ncyIsIk51bGxUeXBlIiwia2luZCIsIk51bWJlclR5cGUiLCJTdHJpbmdUeXBlIiwiQm9vbGVhblR5cGUiLCJDb2xvclR5cGUiLCJPYmplY3RUeXBlIiwiVmFsdWVUeXBlIiwiRXJyb3JUeXBlIiwiQ29sbGF0b3JUeXBlIiwiRm9ybWF0dGVkVHlwZSIsIlJlc29sdmVkSW1hZ2VUeXBlIiwiaXRlbVR5cGUiLCJOIiwidmFsdWVNZW1iZXJUeXBlcyIsImNoZWNrU3VidHlwZSIsImV4cGVjdGVkIiwibWVtYmVyVHlwZSIsImlzVmFsaWRUeXBlIiwicHJvdmlkZWQiLCJhbGxvd2VkVHlwZXMiLCJpc1ZhbGlkTmF0aXZlVHlwZSIsImNzc2NvbG9ycGFyc2VyIiwia0NTU0NvbG9yVGFibGUiLCJjbGFtcF9jc3NfYnl0ZSIsImNsYW1wX2Nzc19mbG9hdCIsImYiLCJwYXJzZV9jc3NfaW50Iiwic3RyIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwicGFyc2VfY3NzX2Zsb2F0IiwiY3NzX2h1ZV90b19yZ2IiLCJtMSIsIm0yIiwicGFyc2VDU1NDb2xvciIsImNzc19zdHIiLCJpdiIsIm9wIiwiZXAiLCJmbmFtZSIsInBhcmFtcyIsImFscGhhIiwiY3NzY29sb3JwYXJzZXJfMSIsImciLCJiIiwidG9BcnJheSIsImJsYWNrIiwid2hpdGUiLCJ0cmFuc3BhcmVudCIsInJlZCIsIkNvbGxhdG9yIiwiY2FzZVNlbnNpdGl2ZSIsImRpYWNyaXRpY1NlbnNpdGl2ZSIsImxvY2FsZSIsInNlbnNpdGl2aXR5IiwiSW50bCIsInVzYWdlIiwiY29tcGFyZSIsImxocyIsInJocyIsInJlc29sdmVkTG9jYWxlIiwicmVzb2x2ZWRPcHRpb25zIiwiRm9ybWF0dGVkU2VjdGlvbiIsInRleHQiLCJzY2FsZSIsImZvbnRTdGFjayIsInRleHRDb2xvciIsIkZvcm1hdHRlZCIsInNlY3Rpb25zIiwiZnJvbVN0cmluZyIsInVuZm9ybWF0dGVkIiwiaXNFbXB0eSIsInNlY3Rpb24iLCJmYWN0b3J5Iiwic2VyaWFsaXplIiwic2VyaWFsaXplZCIsIlJlc29sdmVkSW1hZ2UiLCJhdmFpbGFibGUiLCJ2YWxpZGF0ZVJHQkEiLCJpc1ZhbHVlIiwibWl4ZWQiLCJpdGVtIiwidHlwZU9mIiwidG9TdHJpbmckMSIsIkxpdGVyYWwiLCJhcmdzIiwiY29udGV4dCIsImV4cGVjdGVkVHlwZSIsImV2YWx1YXRlIiwiZWFjaENoaWxkIiwib3V0cHV0RGVmaW5lZCIsIlJ1bnRpbWVFcnJvciIsInR5cGVzIiwiQXNzZXJ0aW9uIiwidHlwZSQxIiwicGFyc2VkIiwiY3R4IiwiZXZlcnkiLCJGb3JtYXRFeHByZXNzaW9uIiwiZmlyc3RBcmciLCJuZXh0VG9rZW5NYXlCZU9iamVjdCIsImxhc3RFeHByZXNzaW9uIiwiY29udGVudCIsImV2YWx1YXRlU2VjdGlvbiIsImV2YWx1YXRlZENvbnRlbnQiLCJJbWFnZUV4cHJlc3Npb24iLCJldmFsdWF0ZWRJbWFnZU5hbWUiLCJhdmFpbGFibGVJbWFnZXMiLCJ0eXBlcyQxIiwiQ29lcmNpb24iLCJCb29sZWFuIiwiYyIsInBhcnNlQ29sb3IiLCJsaXN0JDEiLCJhcmckMSIsIm51bSIsIk51bWJlciIsImlzTmFOIiwiY2hpbGQiLCJnZW9tZXRyeVR5cGVzIiwiRXZhbHVhdGlvbkNvbnRleHQiLCJnbG9iYWxzIiwiZmVhdHVyZSIsImZlYXR1cmVTdGF0ZSIsImZvcm1hdHRlZFNlY3Rpb24iLCJfcGFyc2VDb2xvckNhY2hlIiwiY2Fub25pY2FsIiwiZ2VvbWV0cnlUeXBlIiwiZ2VvbWV0cnkiLCJjYW5vbmljYWxJRCIsImNhY2hlZCIsIkNvbXBvdW5kRXhwcmVzc2lvbiIsIl9ldmFsdWF0ZSIsInJlZiQxIiwiZGVmaW5pdGlvbiIsImRlZmluaXRpb25zIiwiYXZhaWxhYmxlT3ZlcmxvYWRzIiwib3ZlcmxvYWRzIiwic2lnbmF0dXJlIiwic2lnbmF0dXJlQ29udGV4dCIsImkkMyIsIlBhcnNpbmdDb250ZXh0IiwicmVnaXN0cnkiLCJzY29wZSIsInBhcnNlZEFyZ3MiLCJhcmdQYXJzZUZhaWxlZCIsImV4cGVjdGVkJDEiLCJzaWduYXR1cmVzIiwic3RyaW5naWZ5U2lnbmF0dXJlIiwiYWN0dWFsVHlwZXMiLCJpJDIiLCJwYXJzZWQkMSIsInJlZ2lzdGVyIiwiQ29sbGF0b3JFeHByZXNzaW9uIiwiRVhURU5UIiwidXBkYXRlQkJveCIsIm1lcmNhdG9yWGZyb21MbmciLCJsbmciLCJtZXJjYXRvcllmcm9tTGF0IiwibGF0IiwiUEkiLCJsb2ciLCJib3hXaXRoaW5Cb3giLCJiYm94MSIsImJib3gyIiwiZ2V0VGlsZUNvb3JkaW5hdGVzIiwieSIsInRpbGVzQXRab29tIiwicG93IiwieiIsIm9uQm91bmRhcnkiLCJwMSIsInAyIiwieDEiLCJ5MSIsIngyIiwieTIiLCJyYXlJbnRlcnNlY3QiLCJwb2ludFdpdGhpblBvbHlnb24iLCJyaW5ncyIsImluc2lkZSIsInJpbmciLCJsZW4yIiwicG9pbnRXaXRoaW5Qb2x5Z29ucyIsInBvbHlnb25zIiwicGVycCIsInYxIiwidjIiLCJ0d29TaWRlZCIsInExIiwicTIiLCJ4MyIsInkzIiwiZGV0MSIsImRldDIiLCJsaW5lSW50ZXJzZWN0TGluZSIsImQiLCJ2ZWN0b3JQIiwidmVjdG9yUSIsImxpbmVJbnRlcnNlY3RQb2x5Z29uIiwicG9seWdvbiIsImxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uIiwibGluZVN0cmluZ1dpdGhpblBvbHlnb25zIiwiZ2V0VGlsZVBvbHlnb24iLCJnZXRUaWxlUG9seWdvbnMiLCJ1cGRhdGVQb2ludCIsInBvbHlCQm94Iiwid29ybGRTaXplIiwiaGFsZldvcmxkU2l6ZSIsInJlc2V0QkJveCIsImdldFRpbGVQb2ludHMiLCJwb2ludEJCb3giLCJzaGlmdHMiLCJ0aWxlUG9pbnRzIiwicG9pbnRzIiwiZ2V0VGlsZUxpbmVzIiwibGluZUJCb3giLCJ0aWxlTGluZXMiLCJ0aWxlTGluZSIsImxpc3QkMyIsImxpbmUkMSIsImxpc3QkMiIsInAkMSIsInBvaW50c1dpdGhpblBvbHlnb25zIiwicG9seWdvbkdlb21ldHJ5IiwidGlsZVBvbHlnb24iLCJ0aWxlUG9seWdvbnMiLCJ0aWxlUG9pbnRzJDEiLCJwb2ludCQxIiwibGluZXNXaXRoaW5Qb2x5Z29ucyIsInRpbGVMaW5lcyQxIiwiV2l0aGluIiwiZ2VvbWV0cmllcyIsImlzRmVhdHVyZUNvbnN0YW50IiwiaXNTdGF0ZUNvbnN0YW50IiwiaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50IiwiVmFyIiwiYm91bmRFeHByZXNzaW9uIiwiZXhwciIsIl9wYXJzZSIsImFubm90YXRlIiwidHlwZUFubm90YXRpb24iLCJFeHByIiwiYWN0dWFsIiwiaXNDb25zdGFudCIsImVjIiwiZXJyb3IkMSIsImNoZWNrU3VidHlwZSQxIiwiaXNUeXBlQW5ub3RhdGlvbiIsImNoaWxkcmVuQ29uc3RhbnQiLCJmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvIiwibGFzdEluZGV4IiwibG93ZXJJbmRleCIsInVwcGVySW5kZXgiLCJjdXJyZW50SW5kZXgiLCJuZXh0VmFsdWUiLCJTdGVwIiwib3V0cHV0cyIsImxhYmVsIiwib3V0cHV0VHlwZSIsImxhYmVsS2V5IiwidmFsdWVLZXkiLCJzdG9wQ291bnQiLCJ1bml0YmV6aWVyIiwiVW5pdEJlemllciIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsImN4IiwiYngiLCJheCIsImN5IiwiYnkiLCJheSIsInNhbXBsZUN1cnZlWCIsInNhbXBsZUN1cnZlWSIsInNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgiLCJzb2x2ZUN1cnZlWCIsImVwc2lsb24iLCJ0MCIsInQxIiwidDIiLCJkMiIsInNvbHZlIiwiYXJyYXkkMSIsImZyZWV6ZSIsIlhuIiwiWW4iLCJabiIsInQzIiwiZGVnMnJhZCIsInJhZDJkZWciLCJ4eXoybGFiIiwibGFiMnh5eiIsInh5ejJyZ2IiLCJyZ2IyeHl6IiwicmdiVG9MYWIiLCJyZ2JDb2xvciIsImxhYlRvUmdiIiwibGFiQ29sb3IiLCJpbnRlcnBvbGF0ZUxhYiIsInJnYlRvSGNsIiwiYXRhbjIiLCJoY2xUb1JnYiIsImhjbENvbG9yIiwiaW50ZXJwb2xhdGVIdWUiLCJpbnRlcnBvbGF0ZUhjbCIsImZvcndhcmQiLCJjb2xvclNwYWNlcyIsIkludGVycG9sYXRlIiwib3BlcmF0b3IiLCJpbnRlcnBvbGF0aW9uIiwiaW50ZXJwb2xhdGlvbkZhY3RvciIsImxvd2VyIiwidXBwZXIiLCJleHBvbmVudGlhbEludGVycG9sYXRpb24iLCJjb250cm9sUG9pbnRzIiwidWIiLCJvdXRwdXRMb3dlciIsIm91dHB1dFVwcGVyIiwibG93ZXJWYWx1ZSIsInVwcGVyVmFsdWUiLCJkaWZmZXJlbmNlIiwicHJvZ3Jlc3MiLCJDb2FsZXNjZSIsIm5lZWRzQW5ub3RhdGlvbiIsImFyZ0NvdW50IiwicmVxdWVzdGVkSW1hZ2VOYW1lIiwiTGV0IiwiYmluZGluZyIsIkF0IiwiSW4iLCJuZWVkbGUiLCJoYXlzdGFjayIsIkluZGV4T2YiLCJmcm9tSW5kZXgiLCJNYXRjaCIsImlucHV0VHlwZSIsImNhc2VzIiwib3RoZXJ3aXNlIiwibGFiZWxDb250ZXh0IiwiTUFYX1NBRkVfSU5URUdFUiIsInRoaXMkMSIsInNvcnRlZExhYmVscyIsInNvcnQiLCJncm91cGVkQnlPdXRwdXQiLCJvdXRwdXRMb29rdXAiLCJvdXRwdXRJbmRleCIsImNvZXJjZUxhYmVsIiwib3V0cHV0SW5kZXgkMSIsIkNhc2UiLCJicmFuY2hlcyIsIl8iLCJTbGljZSIsImJlZ2luSW5kZXgiLCJlbmRJbmRleCIsImlzQ29tcGFyYWJsZVR5cGUiLCJuZXEiLCJsdCIsImd0IiwibHRlcSIsImd0ZXEiLCJlcUNvbGxhdGUiLCJuZXFDb2xsYXRlIiwibHRDb2xsYXRlIiwiZ3RDb2xsYXRlIiwibHRlcUNvbGxhdGUiLCJndGVxQ29sbGF0ZSIsIm1ha2VDb21wYXJpc29uIiwiY29tcGFyZUJhc2ljIiwiY29tcGFyZVdpdGhDb2xsYXRvciIsImlzT3JkZXJDb21wYXJpc29uIiwiQ29tcGFyaXNvbiIsImhhc1VudHlwZWRBcmd1bWVudCIsInJ0IiwibHQkMSIsInJ0JDEiLCJFcXVhbHMiLCJOb3RFcXVhbHMiLCJMZXNzVGhhbiIsIkdyZWF0ZXJUaGFuIiwiTGVzc1RoYW5PckVxdWFsIiwiR3JlYXRlclRoYW5PckVxdWFsIiwiTnVtYmVyRm9ybWF0IiwiY3VycmVuY3kiLCJtaW5GcmFjdGlvbkRpZ2l0cyIsIm1heEZyYWN0aW9uRGlnaXRzIiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwiTGVuZ3RoIiwiZXhwcmVzc2lvbnMiLCJiaW5hcnlTZWFyY2giLCJ2YXJhcmdzIiwiaGVhdG1hcERlbnNpdHkiLCJsaW5lUHJvZ3Jlc3MiLCJMTjIiLCJFIiwiTE4xMCIsImlzU3VwcG9ydGVkU2NyaXB0IiwidG9VcHBlckNhc2UiLCJzdWNjZXNzIiwic3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24iLCJzcGVjIiwic3VwcG9ydHNab29tRXhwcmVzc2lvbiIsInN1cHBvcnRzSW50ZXJwb2xhdGlvbiIsImdldFR5cGUiLCJ2YWwiLCJpc0Z1bmN0aW9uJDEiLCJpZGVudGl0eUZ1bmN0aW9uIiwiY3JlYXRlRnVuY3Rpb24iLCJwcm9wZXJ0eVNwZWMiLCJpc0NvbG9yIiwiem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQiLCJmZWF0dXJlRGVwZW5kZW50Iiwiem9vbURlcGVuZGVudCIsImRlZmF1bHQiLCJpbm5lckZ1biIsImhhc2hlZFN0b3BzIiwiY2F0ZWdvcmljYWxLZXlUeXBlIiwiZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uIiwiZXZhbHVhdGVJbnRlcnZhbEZ1bmN0aW9uIiwiZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uIiwiZXZhbHVhdGVJZGVudGl0eUZ1bmN0aW9uIiwiZmVhdHVyZUZ1bmN0aW9ucyIsInpvb21TdG9wcyIsInN0b3AkMSIsImZlYXR1cmVGdW5jdGlvblN0b3BzIiwiaW50ZXJwb2xhdGlvblR5cGUiLCJiaW5kIiwiaW50ZXJwb2xhdGlvblR5cGUkMSIsImtleVR5cGUiLCJldmFsdWF0ZWQiLCJpbnRlcnAiLCJjb2xvcnNwYWNlIiwiZXZhbHVhdGVkTG93ZXIiLCJldmFsdWF0ZWRVcHBlciIsIlN0eWxlRXhwcmVzc2lvbiIsIl93YXJuaW5nSGlzdG9yeSIsIl9ldmFsdWF0b3IiLCJfZGVmYXVsdFZhbHVlIiwiZ2V0RGVmYXVsdFZhbHVlIiwiX2VudW1WYWx1ZXMiLCJldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nIiwid2FybiIsImlzRXhwcmVzc2lvbiIsImNyZWF0ZUV4cHJlc3Npb24iLCJwYXJzZXIiLCJnZXRFeHBlY3RlZFR5cGUiLCJab29tQ29uc3RhbnRFeHByZXNzaW9uIiwiX3N0eWxlRXhwcmVzc2lvbiIsImlzU3RhdGVEZXBlbmRlbnQiLCJab29tRGVwZW5kZW50RXhwcmVzc2lvbiIsImNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbiIsImlzRmVhdHVyZUNvbnN0YW50JDEiLCJpc1pvb21Db25zdGFudCIsInpvb21DdXJ2ZSIsImZpbmRab29tQ3VydmUiLCJTdHlsZVByb3BlcnR5RnVuY3Rpb24iLCJzcGVjaWZpY2F0aW9uIiwiX3BhcmFtZXRlcnMiLCJfc3BlY2lmaWNhdGlvbiIsImRlc2VyaWFsaXplIiwibm9ybWFsaXplUHJvcGVydHlFeHByZXNzaW9uIiwiY2hpbGRSZXN1bHQiLCJlbnVtIiwiZm9ybWF0dGVkIiwicmVzb2x2ZWRJbWFnZSIsImNvbnZlcnRMaXRlcmFsIiwiY29udmVydEZ1bmN0aW9uIiwiY29udmVydElkZW50aXR5RnVuY3Rpb24iLCJjb252ZXJ0VG9rZW5TdHJpbmciLCJjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24iLCJjb252ZXJ0Wm9vbUZ1bmN0aW9uIiwiY29udmVydFByb3BlcnR5RnVuY3Rpb24iLCJnZXRJbnRlcnBvbGF0ZU9wZXJhdG9yIiwiZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVycyIsImZ1bmN0aW9uVHlwZSIsImdldEZ1bmN0aW9uVHlwZSIsImFwcGVuZFN0b3BQYWlyIiwiZXhwcmVzc2lvbiQxIiwieiQxIiwib3V0cHV0JDEiLCJmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUiLCJjb2FsZXNjZSQxIiwiZXhwcmVzc2lvbiQyIiwic3RvcCQyIiwiZXhwcmVzc2lvbiQzIiwic3RvcCQzIiwiaXNTdGVwIiwiY3VydmUiLCJyZSIsInBvcyIsImlzRXhwcmVzc2lvbkZpbHRlciIsImZpbHRlclNwZWMiLCJjcmVhdGVGaWx0ZXIiLCJuZWVkR2VvbWV0cnkiLCJjb252ZXJ0RmlsdGVyIiwiY29tcGlsZWQiLCJnbG9iYWxQcm9wZXJ0aWVzIiwiY29udmVydGVkIiwiY29udmVydENvbXBhcmlzb25PcCIsImNvbnZlcnROZWdhdGlvbiIsImNvbnZlcnREaXNqdW5jdGlvbk9wIiwiY29udmVydEluT3AiLCJjb252ZXJ0SGFzT3AiLCJmaWx0ZXJzIiwiY29udmVydEZpbHRlciQxIiwiX2NvbnZlcnRGaWx0ZXIiLCJleHBlY3RlZFR5cGVzIiwiY29udmVydENvbXBhcmlzb25PcCQxIiwiY2hpbGRyZW4iLCJ0eXBlY2hlY2tzIiwicnVudGltZVR5cGVDaGVja3MiLCJjaGlsZHJlbiQxIiwiY29udmVydEluT3AkMSIsImNvbnZlcnRIYXNPcCQxIiwiY29uZGl0aW9ucyIsIm5lZ2F0ZSIsInVuaWZvcm1UeXBlcyIsInVuaXF1ZVZhbHVlcyIsIm1pZ3JhdGVUb0V4cHJlc3Npb25zIiwibWlncmF0ZSIsIm1pZ3JhdGVkIiwiY29tcG9zaXRlIiwic3R5bGVJRHMiLCJzb3VyY2VJRHMiLCJjb21wb3NpdGVkU291cmNlTGF5ZXJzIiwiY29tcG9zaXRlSUQiLCJyZWZQcm9wZXJ0aWVzIiwiZGVyZWYiLCJkZXJlZkxheWVycyIsImRlZXBFcXVhbCIsIm9wZXJhdGlvbnMiLCJyZW1vdmVMYXllciIsInNldFBhaW50UHJvcGVydHkiLCJzZXRMYXlvdXRQcm9wZXJ0eSIsInNldEZpbHRlciIsImFkZFNvdXJjZSIsInJlbW92ZVNvdXJjZSIsInNldEdlb0pTT05Tb3VyY2VEYXRhIiwic2V0TGF5ZXJab29tUmFuZ2UiLCJzZXRMYXllclByb3BlcnR5Iiwic2V0QmVhcmluZyIsInNldFBpdGNoIiwic2V0U3ByaXRlIiwic2V0R2x5cGhzIiwic2V0VHJhbnNpdGlvbiIsInNldExpZ2h0IiwiYWZ0ZXIiLCJjb21tYW5kcyIsImNvbW1hbmQiLCJzb3VyY2VzUmVtb3ZlZCIsInVwZGF0ZVNvdXJjZSIsImNhblVwZGF0ZUdlb0pTT04iLCJiZWZvcmUiLCJkaWZmU291cmNlcyIsImRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyIsImtsYXNzIiwicGx1Y2tJZCIsImluZGV4QnlJZCIsImRpZmZMYXllcnMiLCJiZWZvcmVPcmRlciIsImFmdGVyT3JkZXIiLCJiZWZvcmVJbmRleCIsInJlZHVjZSIsImFmdGVySW5kZXgiLCJ0cmFja2VyIiwiY2xlYW4iLCJiZWZvcmVMYXllciIsImFmdGVyTGF5ZXIiLCJpbnNlcnRCZWZvcmVMYXllcklkIiwiZGlmZlN0eWxlcyIsInJlbW92ZU9yQWRkU291cmNlQ29tbWFuZHMiLCJiZWZvcmVMYXllcnMiLCJWYWxpZGF0aW9uRXJyb3IiLCJpZGVudGlmaWVyIiwiX19saW5lX18iLCJQYXJzaW5nRXJyb3IkMSIsInZhbGlkYXRlQ29uc3RhbnRzIiwidW5idW5kbGUiLCJ2YWx1ZU9mIiwiZGVlcFVuYnVuZGxlIiwidW5idW5kbGVkVmFsdWUiLCJ2YWxpZGF0ZU9iamVjdCIsImVsZW1lbnRTcGVjcyIsInZhbHVlU3BlYyIsImVsZW1lbnRWYWxpZGF0b3JzIiwib2JqZWN0RWxlbWVudFZhbGlkYXRvcnMiLCJzdHlsZVNwZWMiLCJvYmplY3RLZXkiLCJlbGVtZW50U3BlY0tleSIsImVsZW1lbnRTcGVjIiwidmFsaWRhdGVFbGVtZW50IiwidmFsaWRhdGUiLCJlbGVtZW50U3BlY0tleSQxIiwidmFsaWRhdGVBcnJheSIsImFycmF5U3BlYyIsInZhbGlkYXRlQXJyYXlFbGVtZW50IiwiYXJyYXlFbGVtZW50VmFsaWRhdG9yIiwiYXJyYXlFbGVtZW50U3BlYyIsImZ1bmN0aW9uIiwiYXJyYXlJbmRleCIsInZhbGlkYXRlTnVtYmVyIiwidmFsaWRhdGVGdW5jdGlvbiIsImZ1bmN0aW9uVmFsdWVTcGVjIiwic3RvcEtleVR5cGUiLCJzdG9wRG9tYWluVmFsdWVzIiwicHJldmlvdXNTdG9wRG9tYWluVmFsdWUiLCJwcmV2aW91c1N0b3BEb21haW5ab29tIiwiaXNab29tRnVuY3Rpb24iLCJpc1Byb3BlcnR5RnVuY3Rpb24iLCJpc1pvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uIiwidmFsaWRhdGVGdW5jdGlvblN0b3BzIiwidmFsaWRhdGVGdW5jdGlvbkRlZmF1bHQiLCJ2YWxpZGF0ZUZ1bmN0aW9uU3RvcCIsInZhbGlkYXRlU3RvcERvbWFpblZhbHVlIiwicmVwb3J0VmFsdWUiLCJ2YWxpZGF0ZUV4cHJlc3Npb24iLCJleHByZXNzaW9uQ29udGV4dCIsImV4cHJlc3Npb25PYmoiLCJwcm9wZXJ0eUtleSIsInZhbGlkYXRlQm9vbGVhbiIsInZhbGlkYXRlQ29sb3IiLCJ2YWxpZGF0ZUVudW0iLCJ2YWxpZGF0ZUZpbHRlciIsInZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlciIsInZhbGlkYXRlUHJvcGVydHkiLCJsYXllclNwZWMiLCJsYXllclR5cGUiLCJ0cmFuc2l0aW9uTWF0Y2giLCJ0b2tlbk1hdGNoIiwidmFsaWRhdGVQYWludFByb3BlcnR5IiwidmFsaWRhdGVMYXlvdXRQcm9wZXJ0eSIsInZhbGlkYXRlTGF5ZXIiLCJvdGhlckxheWVyIiwic291cmNlVHlwZSIsInZhbGlkYXRlU3RyaW5nIiwidmFsaWRhdGVQcm9tb3RlSWQiLCJ2YWxpZGF0ZVNvdXJjZSIsIm1hcEV4cHIiLCJyZWR1Y2VFeHByIiwidmFsaWRhdGVMaWdodCIsImxpZ2h0U3BlYyIsInJvb3RUeXBlIiwidmFsaWRhdGVGb3JtYXR0ZWQiLCJ2YWxpZGF0ZUltYWdlIiwiVkFMSURBVE9SUyIsInZhbGlkIiwidmFsaWRhdGVHbHlwaHNVUkwiLCJ2YWxpZGF0ZVN0eWxlTWluIiwic29ydEVycm9ycyIsIndyYXBDbGVhbkVycm9ycyIsInBhaW50UHJvcGVydHkiLCJsYXlvdXRQcm9wZXJ0eSIsImpzb25saW50IiwibyIsIiRWMCIsIiRWMSIsIiRWMiIsIiRWMyIsIiRWNCIsIiRWNSIsIiRWNiIsIiRWNyIsIiRWOCIsIiRWOSIsInRyYWNlIiwieXkiLCJzeW1ib2xzXyIsInRlcm1pbmFsc18iLCJwcm9kdWN0aW9uc18iLCJwZXJmb3JtQWN0aW9uIiwiYW5vbnltb3VzIiwieXl0ZXh0IiwieXlsZW5nIiwieXlsaW5lbm8iLCJ5eXN0YXRlIiwiJCQiLCJfJCIsIiQwIiwiJCIsImZpcnN0X2xpbmUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ0YWJsZSIsImRlZmF1bHRBY3Rpb25zIiwicGFyc2VFcnJvciIsInJlY292ZXJhYmxlIiwic3RhY2siLCJ2c3RhY2siLCJsc3RhY2siLCJURVJST1IiLCJFT0YiLCJsZXhlciIsInNoYXJlZFN0YXRlIiwic2V0SW5wdXQiLCJ5eWxsb2MiLCJ5eWxvYyIsInJhbmdlcyIsImdldFByb3RvdHlwZU9mIiwibGV4IiwidG9rZW4iLCJzdGF0ZSIsImFjdGlvbiIsInl5dmFsIiwibmV3U3RhdGUiLCJlcnJTdHIiLCJzaG93UG9zaXRpb24iLCJsb2MiLCJsYXN0X2xpbmUiLCJmaXJzdF9jb2x1bW4iLCJsYXN0X2NvbHVtbiIsInJhbmdlIiwiX2lucHV0IiwiX21vcmUiLCJfYmFja3RyYWNrIiwiZG9uZSIsIm1hdGNoZWQiLCJjb25kaXRpb25TdGFjayIsIm9mZnNldCIsImNoIiwibGluZXMiLCJ1bnB1dCIsIm9sZExpbmVzIiwibW9yZSIsImJhY2t0cmFja19sZXhlciIsImxlc3MiLCJwYXN0SW5wdXQiLCJwYXN0IiwidXBjb21pbmdJbnB1dCIsIm5leHQiLCJwcmUiLCJ0ZXN0X21hdGNoIiwiaW5kZXhlZF9ydWxlIiwiYmFja3VwIiwibWF0Y2hlcyIsInRlbXBNYXRjaCIsInJ1bGVzIiwiX2N1cnJlbnRSdWxlcyIsImZsZXgiLCJiZWdpbiIsImNvbmRpdGlvbiIsInBvcFN0YXRlIiwidG9wU3RhdGUiLCJwdXNoU3RhdGUiLCJzdGF0ZVN0YWNrU2l6ZSIsInl5XyIsIiRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMiLCJZWV9TVEFSVCIsIlBhcnNlciIsImpzb25saW50XzEiLCJqc29ubGludF8yIiwianNvbmxpbnRfMyIsInJlYWRTdHlsZSIsIkJ1ZmZlciIsInZhbGlkYXRlU3R5bGUiLCJTVVBQT1JURURfU1BFQ19WRVJTSU9OIiwiTUFYX1NPVVJDRVNfSU5fU1RZTEUiLCJpc1ZhbGlkIiwicmVnZXgiLCJnZXRTb3VyY2VDb3VudCIsImdldEFsbG93ZWRLZXlFcnJvcnMiLCJhbGxvd2VkIiwiU2V0IiwiZ2V0U291cmNlRXJyb3JzIiwic291cmNlS2V5cyIsInNvdXJjZVVybFBhdHRlcm4iLCJnZXRTb3VyY2VzRXJyb3JzIiwiY291bnQiLCJzb3VyY2VFcnJvcnMiLCJnZXRSb290RXJyb3JzIiwic3BlY0tleXMiLCJvcHRpb25hbFJvb3RQcm9wZXJ0aWVzIiwiYWxsb3dlZEtleUVycm9ycyIsImdseXBoVXJsUGF0dGVybiIsInNwcml0ZVVybFBhdHRlcm4iLCJ2aXNpYmlsaXR5UGF0dGVybiIsInZhbGlkYXRlTWFwYm94QXBpU3VwcG9ydGVkIiwic3R5bGVGdW5jdGlvbiIsInZpc2l0IiwibGF0ZXN0IiwiZGlmZiIsImZlYXR1cmVGaWx0ZXIiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsImNvZGUiLCJnZXRMZW5zIiwiYjY0IiwidmFsaWRMZW4iLCJwbGFjZUhvbGRlcnNMZW4iLCJsZW5zIiwiX2J5dGVMZW5ndGgiLCJ0bXAiLCJhcnIiLCJjdXJCeXRlIiwidHJpcGxldFRvQmFzZTY0IiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsImV4dHJhQnl0ZXMiLCJtYXhDaHVua0xlbmd0aCIsImJhc2U2NCIsInJlcXVpcmUiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsImZvbyIsInN1YmFycmF5IiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJBcnJheUJ1ZmZlciIsImZyb21BcnJheUJ1ZmZlciIsImZyb21PYmplY3QiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uZmlndXJhYmxlIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsImlzRW5jb2RpbmciLCJ3cml0ZSIsImZyb21BcnJheUxpa2UiLCJieXRlT2Zmc2V0IiwiaXNCdWZmZXIiLCJjb3B5IiwiaXNuYW4iLCJfaXNCdWZmZXIiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwiaW5zcGVjdCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsImRpciIsImFycmF5SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwicmVtYWluaW5nIiwic3RyTGVuIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJfYXJyIiwicmVzIiwiZmlyc3RCeXRlIiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsInJldCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJkc3QiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsImZvbnRXZWlnaHRzIiwidGhpbiIsImhhaXJsaW5lIiwiYm9vayIsInJlZ3VsYXIiLCJub3JtYWwiLCJwbGFpbiIsInJvbWFuIiwic3RhbmRhcmQiLCJtZWRpdW0iLCJib2xkIiwiaGVhdnkiLCJmYXQiLCJwb3N0ZXIiLCJzcCIsIml0YWxpY1JFIiwiZm9udENhY2hlIiwibGluZUhlaWdodCIsImNzc0RhdGEiLCJ3ZWlnaHQiLCJmb250RmFtaWxpZXMiLCJoYXZlV2VpZ2h0IiwiaGF2ZVN0eWxlIiwibWF5YmVXZWlnaHQiLCJmb250RmFtaWx5IiwiaWNvbiIsInRpdGxlIiwibGluayIsImdldExpbmsiLCJub3JtYWxpemVOYW1lIiwiRnVuY3Rpb24iLCJzdHlsZWZ1bmN0aW9uIiwiZ2V0VmFsdWUiLCJvbExheWVyIiwic3ByaXRlSW1hZ2UiLCJzcHJpdGVJbWdTaXplIiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJjaGFuZ2VkIiwiZ2V0Q29udGV4dCIsIm1lYXN1cmVDYWNoZSIsIndyYXBUZXh0IiwiZW0iLCJ3cmFwcGVkVGV4dCIsIm9uZUVtIiwibWVhc3VyZVRleHQiLCJ3b3JkcyIsIndvcmQiLCJhbGxMYXllcnMiLCJsYXllcnNCeVNvdXJjZUxheWVyIiwibWFwYm94TGF5ZXJzIiwibWFwYm94U291cmNlIiwic291cmNlTGF5ZXIiLCJmdW5jdGlvbkNhY2hlIiwiZmlsdGVyQ2FjaGUiLCJpY29uSW1hZ2VDYWNoZSIsInN0eWxlcyIsInBhdHRlcm5DYWNoZSIsInJlc29sdXRpb24iLCJnZXRQcm9wZXJ0aWVzIiwic3R5bGVJZHMiLCJnZXRHZW9tZXRyeSIsInN0eWxlc0xlbmd0aCIsImxheWVyRGF0YSIsImVtcHR5T2JqIiwiaWNvbkltZyIsImV2YWx1YXRlRmlsdGVyIiwic3Ryb2tlIiwic3Ryb2tlQ29sb3IiLCJpY29uSW1hZ2UiLCJmcm9tVGVtcGxhdGUiLCJnZXRGaWxsIiwiZ2V0U3Ryb2tlIiwiZ2V0VGV4dCIsIlN0eWxlIiwiRmlsbCIsInNldFpJbmRleCIsImljb25fY2FjaGVfa2V5IiwicGF0dGVybiIsInNwcml0ZUltYWdlRGF0YSIsImNhbnZhcyIsImdsb2JhbEFscGhhIiwiZHJhd0ltYWdlIiwiY3JlYXRlUGF0dGVybiIsInNldENvbG9yIiwiY29sb3JXaXRoT3BhY2l0eSIsIlN0cm9rZSIsInNldFdpZHRoIiwic2V0TGluZUNhcCIsInNldExpbmVKb2luIiwic2V0TWl0ZXJMaW1pdCIsInNldExpbmVEYXNoIiwiaGFzSW1hZ2UiLCJza2lwTGFiZWwiLCJzdHlsZUdlb20iLCJnZW9tIiwiZ2V0RmxhdE1pZHBvaW50IiwiZXh0ZW50Iiwic2V0R2VvbWV0cnkiLCJpY29uU2l6ZSIsImljb25Db2xvciIsImljb25UcmFuc2xhdGUiLCJpY29uVHJhbnNsYXRlQW5jaG9yIiwiaWNvbkFuY2hvclZhbHVlIiwiaWNvbk9mZnNldCIsImNvdmVydEljb25BbmNob3IiLCJhbmNob3JPZmZzZXQiLCJpY29uQW5jaG9yIiwiZ2V0SW1hZ2VEYXRhIiwiY2MiLCJwdXRJbWFnZURhdGEiLCJ0cmFuc2xhdGVPZmZzZXQiLCJJY29uIiwiYW5jaG9yT3JpZ2luIiwiaW1nU2l6ZSIsInBpeGVsUmF0aW8iLCJyb3RhdGVWYWx1ZSIsInNldFJvdGF0aW9uIiwic2V0T3BhY2l0eSIsInNldEltYWdlIiwic2V0VGV4dCIsImNpcmNsZVJhZGl1cyIsImNpcmNsZVN0cm9rZUNvbG9yIiwiY2lyY2xlQ29sb3IiLCJjaXJjbGVPcGFjaXR5IiwiY2lyY2xlU3Ryb2tlV2lkdGgiLCJjaXJjbGVTdHJva2VPcGFjaXR5IiwiY2FjaGVfa2V5IiwiQ2lyY2xlIiwicmFkaXVzIiwidGV4dEZpZWxkIiwiVGV4dCIsInRleHRTaXplIiwidGV4dExpbmVIZWlnaHQiLCJjaG9vc2VGb250IiwidGV4dFRyYW5zZm9ybSIsIndyYXBwZWRMYWJlbCIsInNldEZvbnQiLCJ0ZXh0QW5jaG9yIiwicGxhY2VtZW50Iiwic2V0UGxhY2VtZW50IiwidGV4dEhhbG9XaWR0aCIsInRleHRPZmZzZXQiLCJ0ZXh0VHJhbnNsYXRlIiwidk9mZnNldCIsImhPZmZzZXQiLCJ0ZXh0QWxpZ24iLCJzZXRUZXh0QWxpZ24iLCJzZXRNYXhBbmdsZSIsInRleHRCYXNlbGluZSIsInNldFRleHRCYXNlbGluZSIsInNldE9mZnNldFgiLCJzZXRPZmZzZXRZIiwic2V0RmlsbCIsImhhbG9Db2xvciIsInRleHRIYWxvIiwic2V0U3Ryb2tlIiwiZXhwcmVzc2lvbkRhdGEiLCJyYXdFeHByZXNzaW9uIiwiY29tcGlsZWRFeHByZXNzaW9uIiwiem9vbU9iaiIsImxheW91dE9yUGFpbnQiLCJmdW5jdGlvbnMiLCJpc0V4cHIiLCJmb250TWFwIiwidGVtcGxhdGVSZWdFeCIsImdldFpvb21Gb3JSZXNvbHV0aW9uIiwiZGVncmVlcyIsImNhbmRpZGF0ZSIsInpvb21GYWN0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7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Ozs7Ozs7O0FDQUEsK0I7Ozs7Ozs7Ozs7O0FDQUEsK0I7Ozs7Ozs7Ozs7O0FDQUEsaUM7Ozs7Ozs7Ozs7O0FDQUEsZ0M7Ozs7Ozs7Ozs7O0FDQUEsK0I7Ozs7Ozs7Ozs7O0FDQUEsNkIiLCJmaWxlIjoib2xtcy1kZWJ1Zy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vb2xtcy5qc1wiKTtcbiIsIi8qXHJcbm9sLW1hcGJveC1zdHlsZSAtIFVzZSBNYXBib3ggU3R5bGUgb2JqZWN0cyB3aXRoIE9wZW5MYXllcnNcclxuQ29weXJpZ2h0IDIwMTYtcHJlc2VudCBCb3VuZGxlc3MgU3BhdGlhbCwgSW5jLlxyXG5MaWNlbnNlOiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYm91bmRsZXNzZ2VvL29sLW1hcGJveC1nbC1zdHlsZS9tYXN0ZXIvTElDRU5TRVxyXG4qL1xyXG5cclxuaW1wb3J0IHtDb2xvcn0gZnJvbSAnQG1hcGJveC9tYXBib3gtZ2wtc3R5bGUtc3BlYyc7XHJcbmltcG9ydCBtYjJjc3MgZnJvbSAnbWFwYm94LXRvLWNzcy1mb250JztcclxuaW1wb3J0IGFwcGx5U3R5bGVGdW5jdGlvbiwge2dldFZhbHVlfSBmcm9tICcuL3N0eWxlZnVuY3Rpb24nO1xyXG5pbXBvcnQgZ29vZ2xlRm9udHMgZnJvbSAnd2ViZm9udC1tYXRjaGVyL2xpYi9mb250cy9nb29nbGUnO1xyXG5pbXBvcnQge2Zyb21Mb25MYXR9IGZyb20gJ29sL3Byb2onO1xyXG5pbXBvcnQge2NyZWF0ZVhZWn0gZnJvbSAnb2wvdGlsZWdyaWQnO1xyXG5pbXBvcnQgTWFwIGZyb20gJ29sL01hcCc7XHJcbmltcG9ydCBHZW9KU09OIGZyb20gJ29sL2Zvcm1hdC9HZW9KU09OJztcclxuaW1wb3J0IE1WVCBmcm9tICdvbC9mb3JtYXQvTVZUJztcclxuaW1wb3J0IHt1bkJ5S2V5fSBmcm9tICdvbC9PYnNlcnZhYmxlJztcclxuaW1wb3J0IFRpbGVMYXllciBmcm9tICdvbC9sYXllci9UaWxlJztcclxuaW1wb3J0IFZlY3RvckxheWVyIGZyb20gJ29sL2xheWVyL1ZlY3Rvcic7XHJcbmltcG9ydCBWZWN0b3JUaWxlTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVmVjdG9yVGlsZSc7XHJcbmltcG9ydCBUaWxlSlNPTiBmcm9tICdvbC9zb3VyY2UvVGlsZUpTT04nO1xyXG5pbXBvcnQgVmVjdG9yU291cmNlIGZyb20gJ29sL3NvdXJjZS9WZWN0b3InO1xyXG5pbXBvcnQgVmVjdG9yVGlsZVNvdXJjZSBmcm9tICdvbC9zb3VyY2UvVmVjdG9yVGlsZSc7XHJcbmltcG9ydCBYWVogZnJvbSAnb2wvc291cmNlL1hZWic7XHJcblxyXG52YXIgYXZhaWxhYmxlRm9udHM7XHJcblxyXG5mdW5jdGlvbiBsb2FkRm9udChmb250cykge1xyXG4gIHZhciBpLCBpaTtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkoZm9udHMpKSB7XHJcbiAgICB2YXIgc3RvcHMgPSBmb250cy5zdG9wcztcclxuICAgIGlmIChzdG9wcykge1xyXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHN0b3BzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgICBsb2FkRm9udChzdG9wc1tpXVsxXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIGdvb2dsZUZhbWlsaWVzID0gZ29vZ2xlRm9udHMuZ2V0TmFtZXMoKTtcclxuICB2YXIgZmFtaWxpZXMgPSBmb250cy5tYXAoZnVuY3Rpb24oZm9udCkge1xyXG4gICAgcmV0dXJuIG1iMmNzcyhmb250LCAxKS5zcGxpdCgnIDFweCAnKVsxXS5yZXBsYWNlKC9cIi9nLCAnJyk7XHJcbiAgfSk7XHJcbiAgZm9yIChpID0gMCwgaWkgPSBmYW1pbGllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICB2YXIgZmFtaWx5ID0gZmFtaWxpZXNbaV07XHJcbiAgICB2YXIgZm9udCA9IGZvbnRzW2ldO1xyXG4gICAgaWYgKGdvb2dsZUZhbWlsaWVzLmluZGV4T2YoZmFtaWx5KSAhPT0gLTEpIHtcclxuICAgICAgaWYgKCFhdmFpbGFibGVGb250cykge1xyXG4gICAgICAgIGF2YWlsYWJsZUZvbnRzID0gW107XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGF2YWlsYWJsZUZvbnRzLmluZGV4T2YoZm9udCkgPT0gLTEpIHtcclxuICAgICAgICBhdmFpbGFibGVGb250cy5wdXNoKGZvbnQpO1xyXG4gICAgICAgIHZhciBmb250VXJsID0gJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT0nICsgZmFtaWx5LnJlcGxhY2UoLyAvZywgJysnKTtcclxuICAgICAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZj1cIicgKyBmb250VXJsICsgJ1wiXScpKSB7XHJcbiAgICAgICAgICB2YXIgbWFya3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xyXG4gICAgICAgICAgbWFya3VwLmhyZWYgPSBmb250VXJsO1xyXG4gICAgICAgICAgbWFya3VwLnJlbCA9ICdzdHlsZXNoZWV0JztcclxuICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobWFya3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgZGVmYXVsdEZvbnQgPSBbJ09wZW4gU2FucyBSZWd1bGFyJywgJ0FyaWFsIFJlZ3VsYXInXTtcclxuXHJcbmZ1bmN0aW9uIHByZXByb2Nlc3MobGF5ZXIpIHtcclxuICBpZiAoJ2xheW91dCcgaW4gbGF5ZXIgJiYgJ3RleHQtZmllbGQnIGluIGxheWVyLmxheW91dCkge1xyXG4gICAgbG9hZEZvbnQobGF5ZXIubGF5b3V0Wyd0ZXh0LWZvbnQnXSB8fCBkZWZhdWx0Rm9udCk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgc3ByaXRlUmVnRXggPSAvXiguKikoXFw/LiopJC87XHJcblxyXG5mdW5jdGlvbiB3aXRoUGF0aCh1cmwsIHBhdGgpIHtcclxuICBpZiAocGF0aCAmJiB1cmwuaW5kZXhPZignaHR0cCcpICE9IDApIHtcclxuICAgIHVybCA9IHBhdGggKyB1cmw7XHJcbiAgfVxyXG4gIHJldHVybiB1cmw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvU3ByaXRlVXJsKHVybCwgcGF0aCwgZXh0ZW5zaW9uKSB7XHJcbiAgdXJsID0gd2l0aFBhdGgodXJsLCBwYXRoKTtcclxuICB2YXIgcGFydHMgPSB1cmwubWF0Y2goc3ByaXRlUmVnRXgpO1xyXG4gIHJldHVybiBwYXJ0cyA/XHJcbiAgICBwYXJ0c1sxXSArIGV4dGVuc2lvbiArIChwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiAnJykgOlxyXG4gICAgdXJsICsgZXh0ZW5zaW9uO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbGllcyBhIHN0eWxlIGZ1bmN0aW9uIHRvIGFuIGBvbC5sYXllci5WZWN0b3JUaWxlYCBvciBgb2wubGF5ZXIuVmVjdG9yYFxyXG4gKiB3aXRoIGFuIGBvbC5zb3VyY2UuVmVjdG9yVGlsZWAgb3IgYW4gYG9sLnNvdXJjZS5WZWN0b3JgLiBUaGUgc3R5bGUgZnVuY3Rpb25cclxuICogd2lsbCByZW5kZXIgYWxsIGxheWVycyBmcm9tIHRoZSBgZ2xTdHlsZWAgb2JqZWN0IHRoYXQgdXNlIHRoZSBzcGVjaWZpZWRcclxuICogYHNvdXJjZWAsIG9yIGEgc3Vic2V0IG9mIGxheWVycyBmcm9tIHRoZSBzYW1lIHNvdXJjZS4gVGhlIHNvdXJjZSBuZWVkcyB0byBiZVxyXG4gKiBhIGBcInR5cGVcIjogXCJ2ZWN0b3JcImAsIGBcInR5cGVcIjogXCJnZW9qc29uXCJgIG9yIGBcInR5cGVcIjogXCJyYXN0ZXJcImAgc291cmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29sLmxheWVyLlZlY3RvclRpbGV9IGxheWVyIE9wZW5MYXllcnMgbGF5ZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZ2xTdHlsZSBNYXBib3ggU3R5bGUgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIGBzb3VyY2VgIGtleSBvciBhbiBhcnJheSBvZiBsYXllciBgaWRgcyBmcm9tIHRoZVxyXG4gKiBNYXBib3ggU3R5bGUgb2JqZWN0LiBXaGVuIGEgYHNvdXJjZWAga2V5IGlzIHByb3ZpZGVkLCBhbGwgbGF5ZXJzIGZvciB0aGVcclxuICogc3BlY2lmaWVkIHNvdXJjZSB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBzdHlsZSBmdW5jdGlvbi4gV2hlbiBsYXllciBgaWRgc1xyXG4gKiBhcmUgcHJvdmlkZWQsIHRoZXkgbXVzdCBiZSBmcm9tIGxheWVycyB0aGF0IHVzZSB0aGUgc2FtZSBzb3VyY2UuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aD11bmRlZmluZWRdIFBhdGggb2YgdGhlIHN0eWxlIGZpbGUuIE9ubHkgcmVxdWlyZWQgd2hlblxyXG4gKiBhIHJlbGF0aXZlIHBhdGggaXMgdXNlZCB3aXRoIHRoZSBgXCJzcHJpdGVcImAgcHJvcGVydHkgb2YgdGhlIHN0eWxlLlxyXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtyZXNvbHV0aW9ucz11bmRlZmluZWRdIFJlc29sdXRpb25zIGZvciBtYXBwaW5nIHJlc29sdXRpb24gdG8gem9vbSBsZXZlbC5cclxuICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHN0eWxlIGNhbiBiZSB1c2VkXHJcbiAqIGZvciByZW5kZXJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTdHlsZShsYXllciwgZ2xTdHlsZSwgc291cmNlLCBwYXRoLCByZXNvbHV0aW9ucykge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIGdsU3R5bGUgIT0gJ29iamVjdCcpIHtcclxuICAgICAgZ2xTdHlsZSA9IEpTT04ucGFyc2UoZ2xTdHlsZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZ2xTdHlsZS52ZXJzaW9uICE9IDgpIHtcclxuICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2xTdHlsZSB2ZXJzaW9uIDggcmVxdWlyZWQuJykpO1xyXG4gICAgfVxyXG4gICAgdmFyIHNwcml0ZVNjYWxlLCBzcHJpdGVEYXRhLCBzcHJpdGVJbWFnZVVybDtcclxuICAgIGlmIChnbFN0eWxlLnNwcml0ZSkge1xyXG4gICAgICBzcHJpdGVTY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID49IDEuNSA/IDAuNSA6IDE7XHJcbiAgICAgIHZhciBzaXplRmFjdG9yID0gc3ByaXRlU2NhbGUgPT0gMC41ID8gJ0AyeCcgOiAnJztcclxuICAgICAgdmFyIHNwcml0ZVVybCA9IHRvU3ByaXRlVXJsKGdsU3R5bGUuc3ByaXRlLCBwYXRoLCBzaXplRmFjdG9yICsgJy5qc29uJyk7XHJcblxyXG4gICAgICBmZXRjaChzcHJpdGVVcmwsIHtjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ30pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgIC8vIGlmIHRoZSByZXNwb25zZSBpcyByZWFkeSByZXR1cm4gdGhlIEpTT04gcHJvbWlzZVxyXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHNpemVGYWN0b3IgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgSlNPTiBwcm9taXNlIGZvciB0aGUgbG93LXJlc29sdXRpb24gc3ByaXRlcy5cclxuICAgICAgICAgICAgc2l6ZUZhY3RvciA9ICcnO1xyXG4gICAgICAgICAgICBzcHJpdGVVcmwgPSB0b1Nwcml0ZVVybChnbFN0eWxlLnNwcml0ZSwgcGF0aCwgJy5qc29uJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChzcHJpdGVVcmwsIHtjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ30pLnRoZW4ociA9PiByLmpzb24oKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihzcHJpdGVzSnNvbikge1xyXG4gICAgICAgICAgaWYgKHNwcml0ZXNKc29uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ05vIHNwcml0ZXMgZm91bmQuJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNwcml0ZURhdGEgPSBzcHJpdGVzSnNvbjtcclxuICAgICAgICAgIHNwcml0ZUltYWdlVXJsID0gdG9TcHJpdGVVcmwoZ2xTdHlsZS5zcHJpdGUsIHBhdGgsIHNpemVGYWN0b3IgKyAnLnBuZycpO1xyXG4gICAgICAgICAgb25DaGFuZ2UoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1Nwcml0ZXMgY2Fubm90IGJlIGxvYWRlZCBmcm9tICcgKyBzcHJpdGVVcmwpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3R5bGU7XHJcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcclxuICAgICAgaWYgKCFzdHlsZSAmJiAoIWdsU3R5bGUuc3ByaXRlIHx8IHNwcml0ZURhdGEpICYmICghYXZhaWxhYmxlRm9udHMgfHwgYXZhaWxhYmxlRm9udHMubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICBzdHlsZSA9IGFwcGx5U3R5bGVGdW5jdGlvbihsYXllciwgZ2xTdHlsZSwgc291cmNlLCByZXNvbHV0aW9ucywgc3ByaXRlRGF0YSwgc3ByaXRlSW1hZ2VVcmwsIGF2YWlsYWJsZUZvbnRzKTtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUpIHtcclxuICAgICAgICBsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBWZWN0b3JUaWxlTGF5ZXIgfHwgbGF5ZXIgaW5zdGFuY2VvZiBWZWN0b3JMYXllcikge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBsYXllcnMgPSBnbFN0eWxlLmxheWVycztcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT0gJ3N0cmluZycgJiYgbGF5ZXJzW2ldLnNvdXJjZSA9PSBzb3VyY2UgfHwgc291cmNlLmluZGV4T2YobGF5ZXJzW2ldLmlkKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHByZXByb2Nlc3MobGF5ZXJzW2ldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb25DaGFuZ2UoKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0QmFja2dyb3VuZChtYXAsIGxheWVyKSB7XHJcbiAgY29uc3QgYmFja2dyb3VuZCA9IHtcclxuICAgIHR5cGU6IGxheWVyLnR5cGVcclxuICB9O1xyXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBtYXAuZ2V0VGFyZ2V0RWxlbWVudCgpO1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBsYXlvdXQgPSBsYXllci5sYXlvdXQgfHwge307XHJcbiAgICB2YXIgcGFpbnQgPSBsYXllci5wYWludCB8fCB7fTtcclxuICAgIGJhY2tncm91bmRbJ3BhaW50J10gPSBwYWludDtcclxuICAgIGJhY2tncm91bmQuaWQgPSAnb2xtcy1iZy0nICsgcGFpbnRbJ2JhY2tncm91bmQtb3BhY2l0eSddICsgcGFpbnRbJ2JhY2tncm91bmQtY29sb3InXTtcclxuICAgIHZhciB6b29tID0gbWFwLmdldFZpZXcoKS5nZXRab29tKCk7XHJcbiAgICBpZiAocGFpbnRbJ2JhY2tncm91bmQtY29sb3InXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IGJnID0gZ2V0VmFsdWUoYmFja2dyb3VuZCwgJ3BhaW50JywgJ2JhY2tncm91bmQtY29sb3InLCB6b29tLCB7fSk7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9IENvbG9yLnBhcnNlKGJnKS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhaW50WydiYWNrZ3JvdW5kLW9wYWNpdHknXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IGdldFZhbHVlKGJhY2tncm91bmQsICdwYWludCcsICdiYWNrZ3JvdW5kLW9wYWNpdHknLCB6b29tLCB7fSk7XHJcbiAgICB9XHJcbiAgICBpZiAobGF5b3V0LnZpc2liaWxpdHkgPT0gJ25vbmUnKSB7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyc7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9ICcnO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAobWFwLmdldFRhcmdldEVsZW1lbnQoKSkge1xyXG4gICAgdXBkYXRlU3R5bGUoKTtcclxuICB9XHJcbiAgbWFwLm9uKFsnY2hhbmdlOnJlc29sdXRpb24nLCAnY2hhbmdlOnRhcmdldCddLCB1cGRhdGVTdHlsZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHByb3BlcnRpZXMgb2YgdGhlIE1hcGJveCBTdHlsZSdzIGZpcnN0IGBiYWNrZ3JvdW5kYCBsYXllciB0byB0aGUgbWFwLlxyXG4gKiBAcGFyYW0ge29sLk1hcH0gbWFwIE9wZW5MYXllcnMgTWFwLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZ2xTdHlsZSBNYXBib3ggU3R5bGUgb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5QmFja2dyb3VuZChtYXAsIGdsU3R5bGUpIHtcclxuICBnbFN0eWxlLmxheWVycy5zb21lKGZ1bmN0aW9uKGwpIHtcclxuICAgIGlmIChsLnR5cGUgPT0gJ2JhY2tncm91bmQnKSB7XHJcbiAgICAgIHNldEJhY2tncm91bmQobWFwLCBsKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNvdXJjZUlkQnlSZWYobGF5ZXJzLCByZWYpIHtcclxuICB2YXIgc291cmNlSWQ7XHJcbiAgbGF5ZXJzLnNvbWUoZnVuY3Rpb24obGF5ZXIpIHtcclxuICAgIGlmIChsYXllci5pZCA9PSByZWYpIHtcclxuICAgICAgc291cmNlSWQgPSBsYXllci5zb3VyY2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBzb3VyY2VJZDtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1N0eWxlKGdsU3R5bGUsIG1hcCwgYmFzZVVybCwgaG9zdCwgcGF0aCwgYWNjZXNzVG9rZW4pIHtcclxuICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XHJcbiAgaWYgKCdjZW50ZXInIGluIGdsU3R5bGUgJiYgIXZpZXcuZ2V0Q2VudGVyKCkpIHtcclxuICAgIHZpZXcuc2V0Q2VudGVyKGZyb21Mb25MYXQoZ2xTdHlsZS5jZW50ZXIpKTtcclxuICB9XHJcbiAgaWYgKCd6b29tJyBpbiBnbFN0eWxlICYmIHZpZXcuZ2V0Wm9vbSgpID09PSB1bmRlZmluZWQpIHtcclxuICAgIHZpZXcuc2V0Wm9vbShnbFN0eWxlLnpvb20pO1xyXG4gIH1cclxuICBpZiAoIXZpZXcuZ2V0Q2VudGVyKCkgfHwgdmlldy5nZXRab29tKCkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdmlldy5maXQodmlldy5nZXRQcm9qZWN0aW9uKCkuZ2V0RXh0ZW50KCksIHtcclxuICAgICAgbmVhcmVzdDogdHJ1ZSxcclxuICAgICAgc2l6ZTogbWFwLmdldFNpemUoKVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChnbFN0eWxlLnNwcml0ZSkge1xyXG4gICAgaWYgKGdsU3R5bGUuc3ByaXRlLmluZGV4T2YoJ21hcGJveDovLycpID09IDApIHtcclxuICAgICAgZ2xTdHlsZS5zcHJpdGUgPSBiYXNlVXJsICsgJy9zcHJpdGUnICsgYWNjZXNzVG9rZW47XHJcbiAgICB9IGVsc2UgaWYgKGdsU3R5bGUuc3ByaXRlLmluZGV4T2YoJ2h0dHAnKSAhPSAwKSB7XHJcbiAgICAgIGdsU3R5bGUuc3ByaXRlID0gKGhvc3QgPyAoaG9zdCArIHBhdGgpIDogJycpICsgZ2xTdHlsZS5zcHJpdGUgKyBhY2Nlc3NUb2tlbjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBnbExheWVycyA9IGdsU3R5bGUubGF5ZXJzO1xyXG4gIHZhciBnZW9Kc29uRm9ybWF0ID0gbmV3IEdlb0pTT04oKTtcclxuICB2YXIgbGF5ZXJJZHMgPSBbXTtcclxuXHJcbiAgZnVuY3Rpb24gZmluYWxpemVMYXllcihsYXllcikge1xyXG4gICAgaWYgKGxheWVySWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgbWFwLmFkZExheWVyKGxheWVyKTtcclxuICAgICAgdmFyIHNldFN0eWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXBwbHlTdHlsZShsYXllciwgZ2xTdHlsZSwgbGF5ZXJJZHMsIHBhdGgpLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBsYXllci5zZXRWaXNpYmxlKHRydWUpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIC8qZXNsaW50IG5vLWNvbnNvbGU6IFtcImVycm9yXCIsIHsgYWxsb3c6IFtcImVycm9yXCJdIH1dICovXHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICBpZiAobGF5ZXIuZ2V0U291cmNlKCkpIHtcclxuICAgICAgICBzZXRTdHlsZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxheWVyLm9uY2UoJ2NoYW5nZTpzb3VyY2UnLCBzZXRTdHlsZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBnbExheWVyLCBnbFNvdXJjZSwgZ2xTb3VyY2VJZCwgaWQsIGxheWVyLCBtYXBpZCwgdXJsO1xyXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGdsTGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgIGdsTGF5ZXIgPSBnbExheWVyc1tpXTtcclxuICAgIGlmIChnbExheWVyLnR5cGUgPT0gJ2JhY2tncm91bmQnKSB7XHJcbiAgICAgIHNldEJhY2tncm91bmQobWFwLCBnbExheWVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlkID0gZ2xMYXllci5zb3VyY2UgfHwgZ2V0U291cmNlSWRCeVJlZihnbExheWVycywgZ2xMYXllci5yZWYpO1xyXG4gICAgICBpZiAoaWQgIT0gZ2xTb3VyY2VJZCkge1xyXG4gICAgICAgIGZpbmFsaXplTGF5ZXIobGF5ZXIpO1xyXG4gICAgICAgIGxheWVySWRzID0gW107XHJcbiAgICAgICAgZ2xTb3VyY2UgPSBnbFN0eWxlLnNvdXJjZXNbaWRdO1xyXG4gICAgICAgIHVybCA9IGdsU291cmNlLnVybDtcclxuICAgICAgICB2YXIgdGlsZXMgPSBnbFNvdXJjZS50aWxlcztcclxuICAgICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJ21hcGJveDovLycpID09IDApIHtcclxuICAgICAgICAgICAgbWFwaWQgPSB1cmwucmVwbGFjZSgnbWFwYm94Oi8vJywgJycpO1xyXG4gICAgICAgICAgICB0aWxlcyA9IFsnYScsICdiJywgJ2MnLCAnZCddLm1hcChmdW5jdGlvbihob3N0KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICdodHRwczovLycgKyBob3N0ICsgJy50aWxlcy5tYXBib3guY29tL3Y0LycgKyBtYXBpZCArXHJcbiAgICAgICAgICAgICAgICAgICcve3p9L3t4fS97eX0uJyArXHJcbiAgICAgICAgICAgICAgICAgIChnbFNvdXJjZS50eXBlID09ICd2ZWN0b3InID8gJ3ZlY3Rvci5wYmYnIDogJ3BuZycpICtcclxuICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGdsU291cmNlLnR5cGUgPT0gJ3ZlY3RvcicpIHtcclxuICAgICAgICAgIGxheWVyID0gdGlsZXMgPyAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlR3JpZCA9IGNyZWF0ZVhZWih7XHJcbiAgICAgICAgICAgICAgdGlsZVNpemU6IDUxMixcclxuICAgICAgICAgICAgICBtYXhab29tOiAnbWF4em9vbScgaW4gZ2xTb3VyY2UgPyBnbFNvdXJjZS5tYXh6b29tIDogMjIsXHJcbiAgICAgICAgICAgICAgbWluWm9vbTogZ2xTb3VyY2UubWluem9vbVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3JUaWxlTGF5ZXIoe1xyXG4gICAgICAgICAgICAgIGRlY2x1dHRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICBtYXhSZXNvbHV0aW9uOiB0aWxlR3JpZC5nZXRNaW5ab29tKCkgPiAwID9cclxuICAgICAgICAgICAgICAgIHRpbGVHcmlkLmdldFJlc29sdXRpb24odGlsZUdyaWQuZ2V0TWluWm9vbSgpKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICBzb3VyY2U6IG5ldyBWZWN0b3JUaWxlU291cmNlKHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0aW9uczogZ2xTb3VyY2UuYXR0cmlidXRpb24sXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IG5ldyBNVlQoKSxcclxuICAgICAgICAgICAgICAgIHRpbGVHcmlkOiB0aWxlR3JpZCxcclxuICAgICAgICAgICAgICAgIHVybHM6IHRpbGVzXHJcbiAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgekluZGV4OiBpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSkoKSA6IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gbmV3IFZlY3RvclRpbGVMYXllcih7XHJcbiAgICAgICAgICAgICAgZGVjbHV0dGVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIHpJbmRleDogaVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHRpbGVqc29uID0gbmV3IFRpbGVKU09OKHtcclxuICAgICAgICAgICAgICB1cmw6IHVybFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRpbGVqc29uLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBpZiAodGlsZWpzb24uZ2V0U3RhdGUoKSA9PSAncmVhZHknKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlsZUpTT05Eb2MgPSB0aWxlanNvbi5nZXRUaWxlSlNPTigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVzID0gQXJyYXkuaXNBcnJheSh0aWxlSlNPTkRvYy50aWxlcykgPyB0aWxlSlNPTkRvYy50aWxlcyA6IFt0aWxlSlNPTkRvYy50aWxlc107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aWxlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB0aWxlID0gdGlsZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgIGlmICh0aWxlLmluZGV4T2YoJ2h0dHAnKSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZXNbaV0gPSBnbFNvdXJjZS51cmwgKyB0aWxlO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlsZUdyaWQgPSB0aWxlanNvbi5nZXRUaWxlR3JpZCgpO1xyXG4gICAgICAgICAgICAgICAgbGF5ZXIuc2V0U291cmNlKG5ldyBWZWN0b3JUaWxlU291cmNlKHtcclxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb25zOiB0aWxlanNvbi5nZXRBdHRyaWJ1dGlvbnMoKSB8fCB0aWxlSlNPTkRvYy5hdHRyaWJ1dGlvbixcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0OiBuZXcgTVZUKCksXHJcbiAgICAgICAgICAgICAgICAgIHRpbGVHcmlkOiBjcmVhdGVYWVooe1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblpvb206IHRpbGVHcmlkLmdldE1pblpvb20oKSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhab29tOiB0aWxlR3JpZC5nZXRNYXhab29tKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZVNpemU6IDUxMlxyXG4gICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgdXJsczogdGlsZXNcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aWxlR3JpZC5nZXRNaW5ab29tKCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIGxheWVyLnNldE1heFJlc29sdXRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih0aWxlR3JpZC5nZXRNaW5ab29tKCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVuQnlLZXkoa2V5KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICAgICAgICB9KSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZ2xTb3VyY2UudHlwZSA9PSAncmFzdGVyJykge1xyXG4gICAgICAgICAgdmFyIHNvdXJjZTtcclxuICAgICAgICAgIGlmICghZ2xTb3VyY2UudGlsZXMpIHtcclxuICAgICAgICAgICAgc291cmNlID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVGlsZUpTT04oe1xyXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IG5ldyBYWVooe1xyXG4gICAgICAgICAgICAgIGF0dHJpYnV0aW9uczogZ2xTb3VyY2UuYXR0cmlidXRpb24sXHJcbiAgICAgICAgICAgICAgbWluWm9vbTogZ2xTb3VyY2UubWluem9vbSxcclxuICAgICAgICAgICAgICBtYXhab29tOiAnbWF4em9vbScgaW4gZ2xTb3VyY2UgPyBnbFNvdXJjZS5tYXh6b29tIDogMjIsXHJcbiAgICAgICAgICAgICAgdGlsZVNpemU6IGdsU291cmNlLnRpbGVTaXplIHx8IDUxMixcclxuICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICB1cmxzOiBnbFNvdXJjZS50aWxlcyxcclxuICAgICAgICAgICAgICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzb3VyY2Uuc2V0VGlsZUxvYWRGdW5jdGlvbihmdW5jdGlvbih0aWxlLCBzcmMpIHtcclxuICAgICAgICAgICAgaWYgKHNyYy5pbmRleE9mKCd7YmJveC1lcHNnLTM4NTd9JykgIT0gLTEpIHtcclxuICAgICAgICAgICAgICB2YXIgYmJveCA9IHNvdXJjZS5nZXRUaWxlR3JpZCgpLmdldFRpbGVDb29yZEV4dGVudCh0aWxlLmdldFRpbGVDb29yZCgpKTtcclxuICAgICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgne2Jib3gtZXBzZy0zODU3fScsIGJib3gudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgbGF5ZXIgPSBuZXcgVGlsZUxheWVyKHtcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGdsTGF5ZXIubGF5b3V0ID8gZ2xMYXllci5sYXlvdXQudmlzaWJpbGl0eSAhPT0gJ25vbmUnIDogdHJ1ZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChnbFNvdXJjZS50eXBlID09ICdnZW9qc29uJykge1xyXG4gICAgICAgICAgdmFyIGRhdGEgPSBnbFNvdXJjZS5kYXRhO1xyXG4gICAgICAgICAgdmFyIGZlYXR1cmVzLCBnZW9Kc29uVXJsO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGdlb0pzb25VcmwgPSB3aXRoUGF0aChkYXRhLCBwYXRoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmVzID0gZ2VvSnNvbkZvcm1hdC5yZWFkRmVhdHVyZXMoZGF0YSwge2ZlYXR1cmVQcm9qZWN0aW9uOiAnRVBTRzozODU3J30pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGF5ZXIgPSBuZXcgVmVjdG9yTGF5ZXIoe1xyXG4gICAgICAgICAgICBzb3VyY2U6IG5ldyBWZWN0b3JTb3VyY2Uoe1xyXG4gICAgICAgICAgICAgIGF0dHJpYnV0aW9uczogZ2xTb3VyY2UuYXR0cmlidXRpb24sXHJcbiAgICAgICAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzLFxyXG4gICAgICAgICAgICAgIGZvcm1hdDogZ2VvSnNvbkZvcm1hdCxcclxuICAgICAgICAgICAgICB1cmw6IGdlb0pzb25VcmxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB6SW5kZXg6IGlcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbFNvdXJjZUlkID0gaWQ7XHJcbiAgICAgIH1cclxuICAgICAgbGF5ZXJJZHMucHVzaChnbExheWVyLmlkKTtcclxuICAgIH1cclxuICB9XHJcbiAgZmluYWxpemVMYXllcihsYXllcik7XHJcbiAgbWFwLnNldCgnbWFwYm94LXN0eWxlJywgZ2xTdHlsZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBhbmQgYXBwbGllcyBhIE1hcGJveCBTdHlsZSBvYmplY3QgdG8gYW4gT3BlbkxheWVycyBNYXAuIFRoaXMgaW5jbHVkZXNcclxuICogdGhlIG1hcCBiYWNrZ3JvdW5kLCB0aGUgbGF5ZXJzLCB0aGUgY2VudGVyIGFuZCB0aGUgem9vbS5cclxuICpcclxuICogVGhlIGNlbnRlciBhbmQgem9vbSB3aWxsIG9ubHkgYmUgc2V0IGlmIHByZXNlbnQgaW4gdGhlIE1hcGJveCBTdHlsZSBkb2N1bWVudCxcclxuICogYW5kIGlmIG5vdCBhbHJlYWR5IHNldCBvbiB0aGUgT3BlbkxheWVycyBtYXAuXHJcbiAqXHJcbiAqIExheWVycyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBPcGVuTGF5ZXJzIG1hcCwgd2l0aG91dCBhZmZlY3RpbmcgYW55IGxheWVycyB0aGF0XHJcbiAqIG1pZ2h0IGFscmVhZHkgYmUgc2V0IG9uIHRoZSBtYXAuXHJcbiAqXHJcbiAqIExheWVycyBhZGRlZCBieSBgYXBwbHkoKWAgd2lsbCBoYXZlIHR3byBhZGRpdGlvbmFsIHByb3BlcnRpZXM6XHJcbiAqXHJcbiAqICAqIGBtYXBib3gtc291cmNlYDogVGhlIGBpZGAgb2YgdGhlIE1hcGJveCBTdHlsZSBkb2N1bWVudCdzIHNvdXJjZSB0aGF0IHRoZVxyXG4gKiAgICBPcGVuTGF5ZXJzIGxheWVyIHdhcyBjcmVhdGVkIGZyb20uIFVzdWFsbHkgYGFwcGx5KClgIGNyZWF0ZXMgb25lXHJcbiAqICAgIE9wZW5MYXllcnMgbGF5ZXIgcGVyIE1hcGJveCBTdHlsZSBzb3VyY2UsIHVubGVzcyB0aGUgbGF5ZXIgc3RhY2sgaGFzXHJcbiAqICAgIGxheWVycyBmcm9tIGRpZmZlcmVudCBzb3VyY2VzIGluIGJldHdlZW4uXHJcbiAqICAqIGBtYXBib3gtbGF5ZXJzYDogVGhlIGBpZGBzIG9mIHRoZSBNYXBib3ggU3R5bGUgZG9jdW1lbnQncyBsYXllcnMgdGhhdCBhcmVcclxuICogICAgaW5jbHVkZWQgaW4gdGhlIE9wZW5MYXllcnMgbGF5ZXIuXHJcbiAqXHJcbiAqIFRoZSBtYXAgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiB3aWxsIGhhdmUgYW4gYWRkaXRpb25hbCBgbWFwYm94LXN0eWxlYFxyXG4gKiBwcm9wZXJ0eSB3aGljaCBob2xkcyB0aGUgTWFwYm94IFN0eWxlIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtvbC5NYXB8SFRNTEVsZW1lbnR8c3RyaW5nfSBtYXAgRWl0aGVyIGFuIGV4aXN0aW5nIE9wZW5MYXllcnMgTWFwXHJcbiAqIGluc3RhbmNlLCBvciBhIEhUTUwgZWxlbWVudCwgb3IgdGhlIGlkIG9mIGEgSFRNTCBlbGVtZW50IHRoYXQgd2lsbCBiZSB0aGVcclxuICogdGFyZ2V0IG9mIGEgbmV3IE9wZW5MYXllcnMgTWFwLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHN0eWxlIEpTT04gc3R5bGUgb2JqZWN0IG9yIHN0eWxlIHVybCBwb2ludGluZyB0byBhXHJcbiAqIE1hcGJveCBTdHlsZSBvYmplY3QuIFdoZW4gdXNpbmcgTWFwYm94IEFQSXMsIHRoZSB1cmwgbXVzdCBjb250YWluIGFuIGFjY2Vzc1xyXG4gKiB0b2tlbiBhbmQgbG9vayBsaWtlXHJcbiAqIGBodHRwczovL2FwaS5tYXBib3guY29tL3N0eWxlcy92MS9tYXBib3gvYnJpZ2h0LXY5P2FjY2Vzc190b2tlbj1beW91cl9hY2Nlc3NfdG9rZW5faGVyZV1gLlxyXG4gKiBXaGVuIHBhc3NlZCBhcyBKU09OIHN0eWxlIG9iamVjdCwgYWxsIE9wZW5MYXllcnMgbGF5ZXJzIGNyZWF0ZWQgYnkgYGFwcGx5KClgXHJcbiAqIHdpbGwgYmUgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLCBidXQgdGhleSBtYXkgbm90IGhhdmUgYSBzb3VyY2UgeWV0IChpLmUuIHdoZW5cclxuICogdGhleSBhcmUgZGVmaW5lZCBieSBhIFRpbGVKU09OIHVybCBpbiB0aGUgTWFwYm94IFN0eWxlIGRvY3VtZW50KS4gV2hlbiBwYXNzZWRcclxuICogYXMgc3R5bGUgdXJsLCBsYXllcnMgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIHdoZW4gdGhlIE1hcGJveCBTdHlsZSBkb2N1bWVudFxyXG4gKiBpcyBsb2FkZWQgYW5kIHBhcnNlZC5cclxuICogQHJldHVybiB7b2wuTWFwfSBUaGUgT3BlbkxheWVycyBNYXAgaW5zdGFuY2UgdGhhdCB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHRoZVxyXG4gKiBjb250ZW50cyBkZXNjcmliZWQgaW4gdGhlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkobWFwLCBzdHlsZSkge1xyXG5cclxuICB2YXIgYWNjZXNzVG9rZW4sIGJhc2VVcmwsIGhvc3QsIHBhdGg7XHJcbiAgYWNjZXNzVG9rZW4gPSBiYXNlVXJsID0gaG9zdCA9IHBhdGggPSAnJztcclxuXHJcbiAgaWYgKCEobWFwIGluc3RhbmNlb2YgTWFwKSkge1xyXG4gICAgbWFwID0gbmV3IE1hcCh7XHJcbiAgICAgIHRhcmdldDogbWFwXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICB2YXIgcGFydHMgPSBzdHlsZS5tYXRjaChzcHJpdGVSZWdFeCk7XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgYmFzZVVybCA9IHBhcnRzWzFdO1xyXG4gICAgICBhY2Nlc3NUb2tlbiA9IHBhcnRzLmxlbmd0aCA+IDIgPyBwYXJ0c1syXSA6ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGZldGNoKHN0eWxlLCB7XHJcbiAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXHJcbiAgICB9KVxyXG4gICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC50aGVuKGZ1bmN0aW9uKGdsU3R5bGUpIHtcclxuICAgICAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0EnKTtcclxuICAgICAgICBhLmhyZWYgPSBzdHlsZTtcclxuICAgICAgICBwYXRoID0gYS5wYXRobmFtZS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5qb2luKCcvJykgKyAnLyc7XHJcbiAgICAgICAgaG9zdCA9IHN0eWxlLnN1YnN0cigwLCBzdHlsZS5pbmRleE9mKHBhdGgpKTtcclxuXHJcbiAgICAgICAgcHJvY2Vzc1N0eWxlKGdsU3R5bGUsIG1hcCwgYmFzZVVybCwgaG9zdCwgcGF0aCwgYWNjZXNzVG9rZW4pO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGxvYWQgJyArIHN0eWxlKTtcclxuICAgICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHByb2Nlc3NTdHlsZShzdHlsZSwgbWFwKTtcclxuICAgIH0sIDApO1xyXG4gIH1cclxuICByZXR1cm4gbWFwO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBPcGVuTGF5ZXJzIGxheWVyIGluc3RhbmNlIHRoYXQgY29udGFpbnMgdGhlIHByb3ZpZGVkIE1hcGJveCBTdHlsZVxyXG4gKiBgbGF5ZXJgLiBOb3RlIHRoYXQgbXVsdGlwbGUgTWFwYm94IFN0eWxlIGxheWVycyBhcmUgY29tYmluZWQgaW4gYSBzaW5nbGVcclxuICogT3BlbkxheWVycyBsYXllciBpbnN0YW5jZSB3aGVuIHRoZXkgdXNlIHRoZSBzYW1lIE1hcGJveCBTdHlsZSBgc291cmNlYC5cclxuICogQHBhcmFtIHtvbC5NYXB9IG1hcCBPcGVuTGF5ZXJzIE1hcC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGxheWVySWQgTWFwYm94IFN0eWxlIGxheWVyIGlkLlxyXG4gKiBAcmV0dXJuIHtvbC5sYXllci5MYXllcn0gbGF5ZXIgT3BlbkxheWVycyBsYXllciBpbnN0YW5jZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXllcihtYXAsIGxheWVySWQpIHtcclxuICBjb25zdCBsYXllcnMgPSBtYXAuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKTtcclxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgaWYgKGxheWVyc1tpXS5nZXQoJ21hcGJveC1sYXllcnMnKS5pbmRleE9mKGxheWVySWQpICE9PSAtMSkge1xyXG4gICAgICByZXR1cm4gbGF5ZXJzW2ldO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgT3BlbkxheWVycyBzb3VyY2UgaW5zdGFuY2UgZm9yIHRoZSBwcm92aWRlZCBNYXBib3ggU3R5bGUgYHNvdXJjZWAuXHJcbiAqIEBwYXJhbSB7b2wuTWFwfSBtYXAgT3BlbkxheWVycyBNYXAuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VJZCBNYXBib3ggU3R5bGUgc291cmNlIGlkLlxyXG4gKiBAcmV0dXJuIHtvbC5sYXllci5MYXllcn0gbGF5ZXIgT3BlbkxheWVycyBsYXllciBpbnN0YW5jZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTb3VyY2UobWFwLCBzb3VyY2VJZCkge1xyXG4gIGNvbnN0IGxheWVycyA9IG1hcC5nZXRMYXllcnMoKS5nZXRBcnJheSgpO1xyXG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGxheWVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBsYXllcnNbaV0uZ2V0U291cmNlKCk7XHJcbiAgICBpZiAobGF5ZXJzW2ldLmdldCgnbWFwYm94LXNvdXJjZScpLmluZGV4T2Yoc291cmNlSWQpICE9PSAtMSkge1xyXG4gICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJ2YXIgJHZlcnNpb24gPSA4O1xudmFyICRyb290ID0ge1xuXHR2ZXJzaW9uOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiBbXG5cdFx0XHQ4XG5cdFx0XSxcblx0XHRkb2M6IFwiU3R5bGUgc3BlY2lmaWNhdGlvbiB2ZXJzaW9uIG51bWJlci4gTXVzdCBiZSA4LlwiLFxuXHRcdGV4YW1wbGU6IDhcblx0fSxcblx0bmFtZToge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkEgaHVtYW4tcmVhZGFibGUgbmFtZSBmb3IgdGhlIHN0eWxlLlwiLFxuXHRcdGV4YW1wbGU6IFwiQnJpZ2h0XCJcblx0fSxcblx0bWV0YWRhdGE6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRkb2M6IFwiQXJiaXRyYXJ5IHByb3BlcnRpZXMgdXNlZnVsIHRvIHRyYWNrIHdpdGggdGhlIHN0eWxlc2hlZXQsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuXCJcblx0fSxcblx0Y2VudGVyOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJEZWZhdWx0IG1hcCBjZW50ZXIgaW4gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZS4gIFRoZSBzdHlsZSBjZW50ZXIgd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcblx0XHRleGFtcGxlOiBbXG5cdFx0XHQtNzMuOTc0OSxcblx0XHRcdDQwLjc3MzZcblx0XHRdXG5cdH0sXG5cdHpvb206IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJEZWZhdWx0IHpvb20gbGV2ZWwuICBUaGUgc3R5bGUgem9vbSB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuXHRcdGV4YW1wbGU6IDEyLjVcblx0fSxcblx0YmVhcmluZzoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0cGVyaW9kOiAzNjAsXG5cdFx0dW5pdHM6IFwiZGVncmVlc1wiLFxuXHRcdGRvYzogXCJEZWZhdWx0IGJlYXJpbmcsIGluIGRlZ3JlZXMuIFRoZSBiZWFyaW5nIGlzIHRoZSBjb21wYXNzIGRpcmVjdGlvbiB0aGF0IGlzIFxcXCJ1cFxcXCI7IGZvciBleGFtcGxlLCBhIGJlYXJpbmcgb2YgOTDCsCBvcmllbnRzIHRoZSBtYXAgc28gdGhhdCBlYXN0IGlzIHVwLiBUaGlzIHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG5cdFx0ZXhhbXBsZTogMjlcblx0fSxcblx0cGl0Y2g6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdHVuaXRzOiBcImRlZ3JlZXNcIixcblx0XHRkb2M6IFwiRGVmYXVsdCBwaXRjaCwgaW4gZGVncmVlcy4gWmVybyBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBzdXJmYWNlLCBmb3IgYSBsb29rIHN0cmFpZ2h0IGRvd24gYXQgdGhlIG1hcCwgd2hpbGUgYSBncmVhdGVyIHZhbHVlIGxpa2UgNjAgbG9va3MgYWhlYWQgdG93YXJkcyB0aGUgaG9yaXpvbi4gVGhlIHN0eWxlIHBpdGNoIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG5cdFx0ZXhhbXBsZTogNTBcblx0fSxcblx0bGlnaHQ6IHtcblx0XHR0eXBlOiBcImxpZ2h0XCIsXG5cdFx0ZG9jOiBcIlRoZSBnbG9iYWwgbGlnaHQgc291cmNlLlwiLFxuXHRcdGV4YW1wbGU6IHtcblx0XHRcdGFuY2hvcjogXCJ2aWV3cG9ydFwiLFxuXHRcdFx0Y29sb3I6IFwid2hpdGVcIixcblx0XHRcdGludGVuc2l0eTogMC40XG5cdFx0fVxuXHR9LFxuXHRzb3VyY2VzOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJzb3VyY2VzXCIsXG5cdFx0ZG9jOiBcIkRhdGEgc291cmNlIHNwZWNpZmljYXRpb25zLlwiLFxuXHRcdGV4YW1wbGU6IHtcblx0XHRcdFwibWFwYm94LXN0cmVldHNcIjoge1xuXHRcdFx0XHR0eXBlOiBcInZlY3RvclwiLFxuXHRcdFx0XHR1cmw6IFwibWFwYm94Oi8vbWFwYm94Lm1hcGJveC1zdHJlZXRzLXY2XCJcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHNwcml0ZToge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkEgYmFzZSBVUkwgZm9yIHJldHJpZXZpbmcgdGhlIHNwcml0ZSBpbWFnZSBhbmQgbWV0YWRhdGEuIFRoZSBleHRlbnNpb25zIGAucG5nYCwgYC5qc29uYCBhbmQgc2NhbGUgZmFjdG9yIGBAMngucG5nYCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXBwZW5kZWQuIFRoaXMgcHJvcGVydHkgaXMgcmVxdWlyZWQgaWYgYW55IGxheWVyIHVzZXMgdGhlIGBiYWNrZ3JvdW5kLXBhdHRlcm5gLCBgZmlsbC1wYXR0ZXJuYCwgYGxpbmUtcGF0dGVybmAsIGBmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuYCwgb3IgYGljb24taW1hZ2VgIHByb3BlcnRpZXMuIFRoZSBVUkwgbXVzdCBiZSBhYnNvbHV0ZSwgY29udGFpbmluZyB0aGUgW3NjaGVtZSwgYXV0aG9yaXR5IGFuZCBwYXRoIGNvbXBvbmVudHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VSTCNTeW50YXgpLlwiLFxuXHRcdGV4YW1wbGU6IFwibWFwYm94Oi8vc3ByaXRlcy9tYXBib3gvYnJpZ2h0LXY4XCJcblx0fSxcblx0Z2x5cGhzOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQSBVUkwgdGVtcGxhdGUgZm9yIGxvYWRpbmcgc2lnbmVkLWRpc3RhbmNlLWZpZWxkIGdseXBoIHNldHMgaW4gUEJGIGZvcm1hdC4gVGhlIFVSTCBtdXN0IGluY2x1ZGUgYHtmb250c3RhY2t9YCBhbmQgYHtyYW5nZX1gIHRva2Vucy4gVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpZiBhbnkgbGF5ZXIgdXNlcyB0aGUgYHRleHQtZmllbGRgIGxheW91dCBwcm9wZXJ0eS4gVGhlIFVSTCBtdXN0IGJlIGFic29sdXRlLCBjb250YWluaW5nIHRoZSBbc2NoZW1lLCBhdXRob3JpdHkgYW5kIHBhdGggY29tcG9uZW50c10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVJMI1N5bnRheCkuXCIsXG5cdFx0ZXhhbXBsZTogXCJtYXBib3g6Ly9mb250cy9tYXBib3gve2ZvbnRzdGFja30ve3JhbmdlfS5wYmZcIlxuXHR9LFxuXHR0cmFuc2l0aW9uOiB7XG5cdFx0dHlwZTogXCJ0cmFuc2l0aW9uXCIsXG5cdFx0ZG9jOiBcIkEgZ2xvYmFsIHRyYW5zaXRpb24gZGVmaW5pdGlvbiB0byB1c2UgYXMgYSBkZWZhdWx0IGFjcm9zcyBwcm9wZXJ0aWVzLCB0byBiZSB1c2VkIGZvciB0aW1pbmcgdHJhbnNpdGlvbnMgYmV0d2VlbiBvbmUgdmFsdWUgYW5kIHRoZSBuZXh0IHdoZW4gbm8gcHJvcGVydHktc3BlY2lmaWMgdHJhbnNpdGlvbiBpcyBzZXQuIENvbGxpc2lvbi1iYXNlZCBzeW1ib2wgZmFkaW5nIGlzIGNvbnRyb2xsZWQgaW5kZXBlbmRlbnRseSBvZiB0aGUgc3R5bGUncyBgdHJhbnNpdGlvbmAgcHJvcGVydHkuXCIsXG5cdFx0ZXhhbXBsZToge1xuXHRcdFx0ZHVyYXRpb246IDMwMCxcblx0XHRcdGRlbGF5OiAwXG5cdFx0fVxuXHR9LFxuXHRsYXllcnM6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibGF5ZXJcIixcblx0XHRkb2M6IFwiTGF5ZXJzIHdpbGwgYmUgZHJhd24gaW4gdGhlIG9yZGVyIG9mIHRoaXMgYXJyYXkuXCIsXG5cdFx0ZXhhbXBsZTogW1xuXHRcdFx0e1xuXHRcdFx0XHRpZDogXCJ3YXRlclwiLFxuXHRcdFx0XHRzb3VyY2U6IFwibWFwYm94LXN0cmVldHNcIixcblx0XHRcdFx0XCJzb3VyY2UtbGF5ZXJcIjogXCJ3YXRlclwiLFxuXHRcdFx0XHR0eXBlOiBcImZpbGxcIixcblx0XHRcdFx0cGFpbnQ6IHtcblx0XHRcdFx0XHRcImZpbGwtY29sb3JcIjogXCIjMDBmZmZmXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fVxufTtcbnZhciBzb3VyY2VzID0ge1xuXHRcIipcIjoge1xuXHRcdHR5cGU6IFwic291cmNlXCIsXG5cdFx0ZG9jOiBcIlNwZWNpZmljYXRpb24gb2YgYSBkYXRhIHNvdXJjZS4gRm9yIHZlY3RvciBhbmQgcmFzdGVyIHNvdXJjZXMsIGVpdGhlciBUaWxlSlNPTiBvciBhIFVSTCB0byBhIFRpbGVKU09OIG11c3QgYmUgcHJvdmlkZWQuIEZvciBpbWFnZSBhbmQgdmlkZW8gc291cmNlcywgYSBVUkwgbXVzdCBiZSBwcm92aWRlZC4gRm9yIEdlb0pTT04gc291cmNlcywgYSBVUkwgb3IgaW5saW5lIEdlb0pTT04gbXVzdCBiZSBwcm92aWRlZC5cIlxuXHR9XG59O1xudmFyIHNvdXJjZSA9IFtcblx0XCJzb3VyY2VfdmVjdG9yXCIsXG5cdFwic291cmNlX3Jhc3RlclwiLFxuXHRcInNvdXJjZV9yYXN0ZXJfZGVtXCIsXG5cdFwic291cmNlX2dlb2pzb25cIixcblx0XCJzb3VyY2VfdmlkZW9cIixcblx0XCJzb3VyY2VfaW1hZ2VcIlxuXTtcbnZhciBzb3VyY2VfdmVjdG9yID0ge1xuXHR0eXBlOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2ZWN0b3I6IHtcblx0XHRcdFx0ZG9jOiBcIkEgdmVjdG9yIHRpbGUgc291cmNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmw6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLlwiXG5cdH0sXG5cdHRpbGVzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRib3VuZHM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQtMTgwLFxuXHRcdFx0LTg1LjA1MTEyOSxcblx0XHRcdDE4MCxcblx0XHRcdDg1LjA1MTEyOVxuXHRcdF0sXG5cdFx0ZG9jOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuXHR9LFxuXHRzY2hlbWU6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHh5ejoge1xuXHRcdFx0XHRkb2M6IFwiU2xpcHB5IG1hcCB0aWxlbmFtZXMgc2NoZW1lLlwiXG5cdFx0XHR9LFxuXHRcdFx0dG1zOiB7XG5cdFx0XHRcdGRvYzogXCJPU0dlbyBzcGVjIHNjaGVtZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwieHl6XCIsXG5cdFx0ZG9jOiBcIkluZmx1ZW5jZXMgdGhlIHkgZGlyZWN0aW9uIG9mIHRoZSB0aWxlIGNvb3JkaW5hdGVzLiBUaGUgZ2xvYmFsLW1lcmNhdG9yIChha2EgU3BoZXJpY2FsIE1lcmNhdG9yKSBwcm9maWxlIGlzIGFzc3VtZWQuXCJcblx0fSxcblx0bWluem9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0ZG9jOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcblx0fSxcblx0bWF4em9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDIyLFxuXHRcdGRvYzogXCJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLlwiXG5cdH0sXG5cdGF0dHJpYnV0aW9uOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuXCJcblx0fSxcblx0cHJvbW90ZUlkOiB7XG5cdFx0dHlwZTogXCJwcm9tb3RlSWRcIixcblx0XHRkb2M6IFwiQSBwcm9wZXJ0eSB0byB1c2UgYXMgYSBmZWF0dXJlIGlkIChmb3IgZmVhdHVyZSBzdGF0ZSkuIEVpdGhlciBhIHByb3BlcnR5IG5hbWUsIG9yIGFuIG9iamVjdCBvZiB0aGUgZm9ybSBgezxzb3VyY2VMYXllcj46IDxwcm9wZXJ0eU5hbWU+fWAuIElmIHNwZWNpZmllZCBhcyBhIHN0cmluZyBmb3IgYSB2ZWN0b3IgdGlsZSBzb3VyY2UsIHRoZSBzYW1lIHByb3BlcnR5IGlzIHVzZWQgYWNyb3NzIGFsbCBpdHMgc291cmNlIGxheWVycy5cIlxuXHR9LFxuXHRcIipcIjoge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcblx0fVxufTtcbnZhciBzb3VyY2VfcmFzdGVyID0ge1xuXHR0eXBlOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRyYXN0ZXI6IHtcblx0XHRcdFx0ZG9jOiBcIkEgcmFzdGVyIHRpbGUgc291cmNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmw6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLlwiXG5cdH0sXG5cdHRpbGVzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRib3VuZHM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQtMTgwLFxuXHRcdFx0LTg1LjA1MTEyOSxcblx0XHRcdDE4MCxcblx0XHRcdDg1LjA1MTEyOVxuXHRcdF0sXG5cdFx0ZG9jOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuXHR9LFxuXHRtaW56b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRtYXh6b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMjIsXG5cdFx0ZG9jOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcblx0fSxcblx0dGlsZVNpemU6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiA1MTIsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG5cdH0sXG5cdHNjaGVtZToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0eHl6OiB7XG5cdFx0XHRcdGRvYzogXCJTbGlwcHkgbWFwIHRpbGVuYW1lcyBzY2hlbWUuXCJcblx0XHRcdH0sXG5cdFx0XHR0bXM6IHtcblx0XHRcdFx0ZG9jOiBcIk9TR2VvIHNwZWMgc2NoZW1lLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ4eXpcIixcblx0XHRkb2M6IFwiSW5mbHVlbmNlcyB0aGUgeSBkaXJlY3Rpb24gb2YgdGhlIHRpbGUgY29vcmRpbmF0ZXMuIFRoZSBnbG9iYWwtbWVyY2F0b3IgKGFrYSBTcGhlcmljYWwgTWVyY2F0b3IpIHByb2ZpbGUgaXMgYXNzdW1lZC5cIlxuXHR9LFxuXHRhdHRyaWJ1dGlvbjoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLlwiXG5cdH0sXG5cdFwiKlwiOiB7XG5cdFx0dHlwZTogXCIqXCIsXG5cdFx0ZG9jOiBcIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS5cIlxuXHR9XG59O1xudmFyIHNvdXJjZV9yYXN0ZXJfZGVtID0ge1xuXHR0eXBlOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRcInJhc3Rlci1kZW1cIjoge1xuXHRcdFx0XHRkb2M6IFwiQSBSR0ItZW5jb2RlZCByYXN0ZXIgREVNIHNvdXJjZVwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmw6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLlwiXG5cdH0sXG5cdHRpbGVzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRib3VuZHM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQtMTgwLFxuXHRcdFx0LTg1LjA1MTEyOSxcblx0XHRcdDE4MCxcblx0XHRcdDg1LjA1MTEyOVxuXHRcdF0sXG5cdFx0ZG9jOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuXHR9LFxuXHRtaW56b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRtYXh6b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMjIsXG5cdFx0ZG9jOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcblx0fSxcblx0dGlsZVNpemU6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiA1MTIsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG5cdH0sXG5cdGF0dHJpYnV0aW9uOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuXCJcblx0fSxcblx0ZW5jb2Rpbmc6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHRlcnJhcml1bToge1xuXHRcdFx0XHRkb2M6IFwiVGVycmFyaXVtIGZvcm1hdCBQTkcgdGlsZXMuIFNlZSBodHRwczovL2F3cy5hbWF6b24uY29tL2VzL3B1YmxpYy1kYXRhc2V0cy90ZXJyYWluLyBmb3IgbW9yZSBpbmZvLlwiXG5cdFx0XHR9LFxuXHRcdFx0bWFwYm94OiB7XG5cdFx0XHRcdGRvYzogXCJNYXBib3ggVGVycmFpbiBSR0IgdGlsZXMuIFNlZSBodHRwczovL3d3dy5tYXBib3guY29tL2hlbHAvYWNjZXNzLWVsZXZhdGlvbi1kYXRhLyNtYXBib3gtdGVycmFpbi1yZ2IgZm9yIG1vcmUgaW5mby5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwYm94XCIsXG5cdFx0ZG9jOiBcIlRoZSBlbmNvZGluZyB1c2VkIGJ5IHRoaXMgc291cmNlLiBNYXBib3ggVGVycmFpbiBSR0IgaXMgdXNlZCBieSBkZWZhdWx0XCJcblx0fSxcblx0XCIqXCI6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRkb2M6IFwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwiXG5cdH1cbn07XG52YXIgc291cmNlX2dlb2pzb24gPSB7XG5cdHR5cGU6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGdlb2pzb246IHtcblx0XHRcdFx0ZG9jOiBcIkEgR2VvSlNPTiBkYXRhIHNvdXJjZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIEdlb0pTT04gc291cmNlLlwiXG5cdH0sXG5cdGRhdGE6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRkb2M6IFwiQSBVUkwgdG8gYSBHZW9KU09OIGZpbGUsIG9yIGlubGluZSBHZW9KU09OLlwiXG5cdH0sXG5cdG1heHpvb206IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxOCxcblx0XHRkb2M6IFwiTWF4aW11bSB6b29tIGxldmVsIGF0IHdoaWNoIHRvIGNyZWF0ZSB2ZWN0b3IgdGlsZXMgKGhpZ2hlciBtZWFucyBncmVhdGVyIGRldGFpbCBhdCBoaWdoIHpvb20gbGV2ZWxzKS5cIlxuXHR9LFxuXHRhdHRyaWJ1dGlvbjoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLlwiXG5cdH0sXG5cdGJ1ZmZlcjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEyOCxcblx0XHRtYXhpbXVtOiA1MTIsXG5cdFx0bWluaW11bTogMCxcblx0XHRkb2M6IFwiU2l6ZSBvZiB0aGUgdGlsZSBidWZmZXIgb24gZWFjaCBzaWRlLiBBIHZhbHVlIG9mIDAgcHJvZHVjZXMgbm8gYnVmZmVyLiBBIHZhbHVlIG9mIDUxMiBwcm9kdWNlcyBhIGJ1ZmZlciBhcyB3aWRlIGFzIHRoZSB0aWxlIGl0c2VsZi4gTGFyZ2VyIHZhbHVlcyBwcm9kdWNlIGZld2VyIHJlbmRlcmluZyBhcnRpZmFjdHMgbmVhciB0aWxlIGVkZ2VzIGFuZCBzbG93ZXIgcGVyZm9ybWFuY2UuXCJcblx0fSxcblx0dG9sZXJhbmNlOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMC4zNzUsXG5cdFx0ZG9jOiBcIkRvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2UgKGhpZ2hlciBtZWFucyBzaW1wbGVyIGdlb21ldHJpZXMgYW5kIGZhc3RlciBwZXJmb3JtYW5jZSkuXCJcblx0fSxcblx0Y2x1c3Rlcjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiSWYgdGhlIGRhdGEgaXMgYSBjb2xsZWN0aW9uIG9mIHBvaW50IGZlYXR1cmVzLCBzZXR0aW5nIHRoaXMgdG8gdHJ1ZSBjbHVzdGVycyB0aGUgcG9pbnRzIGJ5IHJhZGl1cyBpbnRvIGdyb3Vwcy4gQ2x1c3RlciBncm91cHMgYmVjb21lIG5ldyBgUG9pbnRgIGZlYXR1cmVzIGluIHRoZSBzb3VyY2Ugd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXM6XFxuICogYGNsdXN0ZXJgIElzIGB0cnVlYCBpZiB0aGUgcG9pbnQgaXMgYSBjbHVzdGVyIFxcbiAqIGBjbHVzdGVyX2lkYCBBIHVucWl1ZSBpZCBmb3IgdGhlIGNsdXN0ZXIgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBbY2x1c3RlciBpbnNwZWN0aW9uIG1ldGhvZHNdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2FwaS8jZ2VvanNvbnNvdXJjZSNnZXRjbHVzdGVyZXhwYW5zaW9uem9vbSlcXG4gKiBgcG9pbnRfY291bnRgIE51bWJlciBvZiBvcmlnaW5hbCBwb2ludHMgZ3JvdXBlZCBpbnRvIHRoaXMgY2x1c3RlclxcbiAqIGBwb2ludF9jb3VudF9hYmJyZXZpYXRlZGAgQW4gYWJicmV2aWF0ZWQgcG9pbnQgY291bnRcIlxuXHR9LFxuXHRjbHVzdGVyUmFkaXVzOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogNTAsXG5cdFx0bWluaW11bTogMCxcblx0XHRkb2M6IFwiUmFkaXVzIG9mIGVhY2ggY2x1c3RlciBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIEEgdmFsdWUgb2YgNTEyIGluZGljYXRlcyBhIHJhZGl1cyBlcXVhbCB0byB0aGUgd2lkdGggb2YgYSB0aWxlLlwiXG5cdH0sXG5cdGNsdXN0ZXJNYXhab29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiTWF4IHpvb20gb24gd2hpY2ggdG8gY2x1c3RlciBwb2ludHMgaWYgY2x1c3RlcmluZyBpcyBlbmFibGVkLiBEZWZhdWx0cyB0byBvbmUgem9vbSBsZXNzIHRoYW4gbWF4em9vbSAoc28gdGhhdCBsYXN0IHpvb20gZmVhdHVyZXMgYXJlIG5vdCBjbHVzdGVyZWQpLlwiXG5cdH0sXG5cdGNsdXN0ZXJQcm9wZXJ0aWVzOiB7XG5cdFx0dHlwZTogXCIqXCIsXG5cdFx0ZG9jOiBcIkFuIG9iamVjdCBkZWZpbmluZyBjdXN0b20gcHJvcGVydGllcyBvbiB0aGUgZ2VuZXJhdGVkIGNsdXN0ZXJzIGlmIGNsdXN0ZXJpbmcgaXMgZW5hYmxlZCwgYWdncmVnYXRpbmcgdmFsdWVzIGZyb20gY2x1c3RlcmVkIHBvaW50cy4gSGFzIHRoZSBmb3JtIGB7XFxcInByb3BlcnR5X25hbWVcXFwiOiBbb3BlcmF0b3IsIG1hcF9leHByZXNzaW9uXX1gLiBgb3BlcmF0b3JgIGlzIGFueSBleHByZXNzaW9uIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhdCBsZWFzdCAyIG9wZXJhbmRzIChlLmcuIGBcXFwiK1xcXCJgIG9yIGBcXFwibWF4XFxcImApIOKAlCBpdCBhY2N1bXVsYXRlcyB0aGUgcHJvcGVydHkgdmFsdWUgZnJvbSBjbHVzdGVycy9wb2ludHMgdGhlIGNsdXN0ZXIgY29udGFpbnM7IGBtYXBfZXhwcmVzc2lvbmAgcHJvZHVjZXMgdGhlIHZhbHVlIG9mIGEgc2luZ2xlIHBvaW50LlxcblxcbkV4YW1wbGU6IGB7XFxcInN1bVxcXCI6IFtcXFwiK1xcXCIsIFtcXFwiZ2V0XFxcIiwgXFxcInNjYWxlcmFua1xcXCJdXX1gLlxcblxcbkZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcywgaW4gcGxhY2Ugb2YgYG9wZXJhdG9yYCwgeW91IGNhbiB1c2UgYSBjdXN0b20gcmVkdWNlIGV4cHJlc3Npb24gdGhhdCByZWZlcmVuY2VzIGEgc3BlY2lhbCBgW1xcXCJhY2N1bXVsYXRlZFxcXCJdYCB2YWx1ZSwgZS5nLjpcXG5ge1xcXCJzdW1cXFwiOiBbW1xcXCIrXFxcIiwgW1xcXCJhY2N1bXVsYXRlZFxcXCJdLCBbXFxcImdldFxcXCIsIFxcXCJzdW1cXFwiXV0sIFtcXFwiZ2V0XFxcIiwgXFxcInNjYWxlcmFua1xcXCJdXX1gXCJcblx0fSxcblx0bGluZU1ldHJpY3M6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdG8gY2FsY3VsYXRlIGxpbmUgZGlzdGFuY2UgbWV0cmljcy4gVGhpcyBpcyByZXF1aXJlZCBmb3IgbGluZSBsYXllcnMgdGhhdCBzcGVjaWZ5IGBsaW5lLWdyYWRpZW50YCB2YWx1ZXMuXCJcblx0fSxcblx0Z2VuZXJhdGVJZDoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiV2hldGhlciB0byBnZW5lcmF0ZSBpZHMgZm9yIHRoZSBnZW9qc29uIGZlYXR1cmVzLiBXaGVuIGVuYWJsZWQsIHRoZSBgZmVhdHVyZS5pZGAgcHJvcGVydHkgd2lsbCBiZSBhdXRvIGFzc2lnbmVkIGJhc2VkIG9uIGl0cyBpbmRleCBpbiB0aGUgYGZlYXR1cmVzYCBhcnJheSwgb3Zlci13cml0aW5nIGFueSBwcmV2aW91cyB2YWx1ZXMuXCJcblx0fSxcblx0cHJvbW90ZUlkOiB7XG5cdFx0dHlwZTogXCJwcm9tb3RlSWRcIixcblx0XHRkb2M6IFwiQSBwcm9wZXJ0eSB0byB1c2UgYXMgYSBmZWF0dXJlIGlkIChmb3IgZmVhdHVyZSBzdGF0ZSkuIEVpdGhlciBhIHByb3BlcnR5IG5hbWUsIG9yIGFuIG9iamVjdCBvZiB0aGUgZm9ybSBgezxzb3VyY2VMYXllcj46IDxwcm9wZXJ0eU5hbWU+fWAuXCJcblx0fVxufTtcbnZhciBzb3VyY2VfdmlkZW8gPSB7XG5cdHR5cGU6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpZGVvOiB7XG5cdFx0XHRcdGRvYzogXCJBIHZpZGVvIGRhdGEgc291cmNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgdmlkZW8gc291cmNlLlwiXG5cdH0sXG5cdHVybHM6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIlVSTHMgdG8gdmlkZW8gY29udGVudCBpbiBvcmRlciBvZiBwcmVmZXJyZWQgZm9ybWF0LlwiXG5cdH0sXG5cdGNvb3JkaW5hdGVzOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0ZG9jOiBcIkNvcm5lcnMgb2YgdmlkZW8gc3BlY2lmaWVkIGluIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpcnMuXCIsXG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdGxlbmd0aDogNCxcblx0XHR2YWx1ZToge1xuXHRcdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdFx0bGVuZ3RoOiAyLFxuXHRcdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0XHRkb2M6IFwiQSBzaW5nbGUgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlyLlwiXG5cdFx0fVxuXHR9XG59O1xudmFyIHNvdXJjZV9pbWFnZSA9IHtcblx0dHlwZToge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0aW1hZ2U6IHtcblx0XHRcdFx0ZG9jOiBcIkFuIGltYWdlIGRhdGEgc291cmNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgaW1hZ2Ugc291cmNlLlwiXG5cdH0sXG5cdHVybDoge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIlVSTCB0aGF0IHBvaW50cyB0byBhbiBpbWFnZS5cIlxuXHR9LFxuXHRjb29yZGluYXRlczoge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdGRvYzogXCJDb3JuZXJzIG9mIGltYWdlIHNwZWNpZmllZCBpbiBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXJzLlwiLFxuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRsZW5ndGg6IDQsXG5cdFx0dmFsdWU6IHtcblx0XHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRcdGxlbmd0aDogMixcblx0XHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdFx0ZG9jOiBcIkEgc2luZ2xlIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpci5cIlxuXHRcdH1cblx0fVxufTtcbnZhciBsYXllciA9IHtcblx0aWQ6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJVbmlxdWUgbGF5ZXIgbmFtZS5cIixcblx0XHRyZXF1aXJlZDogdHJ1ZVxuXHR9LFxuXHR0eXBlOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRmaWxsOiB7XG5cdFx0XHRcdGRvYzogXCJBIGZpbGxlZCBwb2x5Z29uIHdpdGggYW4gb3B0aW9uYWwgc3Ryb2tlZCBib3JkZXIuXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGxpbmU6IHtcblx0XHRcdFx0ZG9jOiBcIkEgc3Ryb2tlZCBsaW5lLlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzeW1ib2w6IHtcblx0XHRcdFx0ZG9jOiBcIkFuIGljb24gb3IgYSB0ZXh0IGxhYmVsLlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjaXJjbGU6IHtcblx0XHRcdFx0ZG9jOiBcIkEgZmlsbGVkIGNpcmNsZS5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGVhdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiQSBoZWF0bWFwLlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRcImZpbGwtZXh0cnVzaW9uXCI6IHtcblx0XHRcdFx0ZG9jOiBcIkFuIGV4dHJ1ZGVkICgzRCkgcG9seWdvbi5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmFzdGVyOiB7XG5cdFx0XHRcdGRvYzogXCJSYXN0ZXIgbWFwIHRleHR1cmVzIHN1Y2ggYXMgc2F0ZWxsaXRlIGltYWdlcnkuXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhpbGxzaGFkZToge1xuXHRcdFx0XHRkb2M6IFwiQ2xpZW50LXNpZGUgaGlsbHNoYWRpbmcgdmlzdWFsaXphdGlvbiBiYXNlZCBvbiBERU0gZGF0YS4gQ3VycmVudGx5LCB0aGUgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBNYXBib3ggVGVycmFpbiBSR0IgYW5kIE1hcHplbiBUZXJyYXJpdW0gdGlsZXMuXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJhY2tncm91bmQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9yIHBhdHRlcm4gb2YgdGhlIG1hcC5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIixcblx0XHRyZXF1aXJlZDogdHJ1ZVxuXHR9LFxuXHRtZXRhZGF0YToge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJBcmJpdHJhcnkgcHJvcGVydGllcyB1c2VmdWwgdG8gdHJhY2sgd2l0aCB0aGUgbGF5ZXIsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuXCJcblx0fSxcblx0c291cmNlOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiTmFtZSBvZiBhIHNvdXJjZSBkZXNjcmlwdGlvbiB0byBiZSB1c2VkIGZvciB0aGlzIGxheWVyLiBSZXF1aXJlZCBmb3IgYWxsIGxheWVyIHR5cGVzIGV4Y2VwdCBgYmFja2dyb3VuZGAuXCJcblx0fSxcblx0XCJzb3VyY2UtbGF5ZXJcIjoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkxheWVyIHRvIHVzZSBmcm9tIGEgdmVjdG9yIHRpbGUgc291cmNlLiBSZXF1aXJlZCBmb3IgdmVjdG9yIHRpbGUgc291cmNlczsgcHJvaGliaXRlZCBmb3IgYWxsIG90aGVyIHNvdXJjZSB0eXBlcywgaW5jbHVkaW5nIEdlb0pTT04gc291cmNlcy5cIlxuXHR9LFxuXHRtaW56b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDI0LFxuXHRcdGRvYzogXCJUaGUgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgbGF5ZXIuIEF0IHpvb20gbGV2ZWxzIGxlc3MgdGhhbiB0aGUgbWluem9vbSwgdGhlIGxheWVyIHdpbGwgYmUgaGlkZGVuLlwiXG5cdH0sXG5cdG1heHpvb206IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMjQsXG5cdFx0ZG9jOiBcIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBsYXllci4gQXQgem9vbSBsZXZlbHMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIHRoZSBtYXh6b29tLCB0aGUgbGF5ZXIgd2lsbCBiZSBoaWRkZW4uXCJcblx0fSxcblx0ZmlsdGVyOiB7XG5cdFx0dHlwZTogXCJmaWx0ZXJcIixcblx0XHRkb2M6IFwiQSBleHByZXNzaW9uIHNwZWNpZnlpbmcgY29uZGl0aW9ucyBvbiBzb3VyY2UgZmVhdHVyZXMuIE9ubHkgZmVhdHVyZXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyIGFyZSBkaXNwbGF5ZWQuIFpvb20gZXhwcmVzc2lvbnMgaW4gZmlsdGVycyBhcmUgb25seSBldmFsdWF0ZWQgYXQgaW50ZWdlciB6b29tIGxldmVscy4gVGhlIGBmZWF0dXJlLXN0YXRlYCBleHByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZmlsdGVyIGV4cHJlc3Npb25zLlwiXG5cdH0sXG5cdGxheW91dDoge1xuXHRcdHR5cGU6IFwibGF5b3V0XCIsXG5cdFx0ZG9jOiBcIkxheW91dCBwcm9wZXJ0aWVzIGZvciB0aGUgbGF5ZXIuXCJcblx0fSxcblx0cGFpbnQ6IHtcblx0XHR0eXBlOiBcInBhaW50XCIsXG5cdFx0ZG9jOiBcIkRlZmF1bHQgcGFpbnQgcHJvcGVydGllcyBmb3IgdGhpcyBsYXllci5cIlxuXHR9XG59O1xudmFyIGxheW91dCA9IFtcblx0XCJsYXlvdXRfZmlsbFwiLFxuXHRcImxheW91dF9saW5lXCIsXG5cdFwibGF5b3V0X2NpcmNsZVwiLFxuXHRcImxheW91dF9oZWF0bWFwXCIsXG5cdFwibGF5b3V0X2ZpbGwtZXh0cnVzaW9uXCIsXG5cdFwibGF5b3V0X3N5bWJvbFwiLFxuXHRcImxheW91dF9yYXN0ZXJcIixcblx0XCJsYXlvdXRfaGlsbHNoYWRlXCIsXG5cdFwibGF5b3V0X2JhY2tncm91bmRcIlxuXTtcbnZhciBsYXlvdXRfYmFja2dyb3VuZCA9IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfZmlsbCA9IHtcblx0XCJmaWxsLXNvcnQta2V5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJTb3J0cyBmZWF0dXJlcyBpbiBhc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhpcyB2YWx1ZS4gRmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIGFwcGVhciBhYm92ZSBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIxLjIuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMS4yLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn07XG52YXIgbGF5b3V0X2NpcmNsZSA9IHtcblx0XCJjaXJjbGUtc29ydC1rZXlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgYXBwZWFyIGFib3ZlIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjEuMi4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIxLjIuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfaGVhdG1hcCA9IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfbGluZSA9IHtcblx0XCJsaW5lLWNhcFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRidXR0OiB7XG5cdFx0XHRcdGRvYzogXCJBIGNhcCB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIHRvIHRoZSBleGFjdCBlbmRwb2ludCBvZiB0aGUgbGluZS5cIlxuXHRcdFx0fSxcblx0XHRcdHJvdW5kOiB7XG5cdFx0XHRcdGRvYzogXCJBIGNhcCB3aXRoIGEgcm91bmRlZCBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIHJhZGl1cyBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoIGFuZCBjZW50ZXJlZCBvbiB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHRzcXVhcmU6IHtcblx0XHRcdFx0ZG9jOiBcIkEgY2FwIHdpdGggYSBzcXVhcmVkLW9mZiBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIGRpc3RhbmNlIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGguXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImJ1dHRcIixcblx0XHRkb2M6IFwiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJsaW5lLWpvaW5cIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0YmV2ZWw6IHtcblx0XHRcdFx0ZG9jOiBcIkEgam9pbiB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSBkaXN0YW5jZSBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoLlwiXG5cdFx0XHR9LFxuXHRcdFx0cm91bmQ6IHtcblx0XHRcdFx0ZG9jOiBcIkEgam9pbiB3aXRoIGEgcm91bmRlZCBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIHJhZGl1cyBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoIGFuZCBjZW50ZXJlZCBvbiB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHRtaXRlcjoge1xuXHRcdFx0XHRkb2M6IFwiQSBqb2luIHdpdGggYSBzaGFycCwgYW5nbGVkIGNvcm5lciB3aGljaCBpcyBkcmF3biB3aXRoIHRoZSBvdXRlciBzaWRlcyBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBwYXRoIHVudGlsIHRoZXkgbWVldC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibWl0ZXJcIixcblx0XHRkb2M6IFwiVGhlIGRpc3BsYXkgb2YgbGluZXMgd2hlbiBqb2luaW5nLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS1taXRlci1saW1pdFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMixcblx0XHRkb2M6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcImxpbmUtam9pblwiOiBcIm1pdGVyXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImxpbmUtcm91bmQtbGltaXRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEuMDUsXG5cdFx0ZG9jOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IHJvdW5kIGpvaW5zIHRvIG1pdGVyIGpvaW5zIGZvciBzaGFsbG93IGFuZ2xlcy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcImxpbmUtam9pblwiOiBcInJvdW5kXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImxpbmUtc29ydC1rZXlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgYXBwZWFyIGFib3ZlIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjEuMi4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIxLjIuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfc3ltYm9sID0ge1xuXHRcInN5bWJvbC1wbGFjZW1lbnRcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0cG9pbnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYWJlbCBpcyBwbGFjZWQgYXQgdGhlIHBvaW50IHdoZXJlIHRoZSBnZW9tZXRyeSBpcyBsb2NhdGVkLlwiXG5cdFx0XHR9LFxuXHRcdFx0bGluZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxhYmVsIGlzIHBsYWNlZCBhbG9uZyB0aGUgbGluZSBvZiB0aGUgZ2VvbWV0cnkuIENhbiBvbmx5IGJlIHVzZWQgb24gYExpbmVTdHJpbmdgIGFuZCBgUG9seWdvbmAgZ2VvbWV0cmllcy5cIlxuXHRcdFx0fSxcblx0XHRcdFwibGluZS1jZW50ZXJcIjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxhYmVsIGlzIHBsYWNlZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBsaW5lIG9mIHRoZSBnZW9tZXRyeS4gQ2FuIG9ubHkgYmUgdXNlZCBvbiBgTGluZVN0cmluZ2AgYW5kIGBQb2x5Z29uYCBnZW9tZXRyaWVzLiBOb3RlIHRoYXQgYSBzaW5nbGUgZmVhdHVyZSBpbiBhIHZlY3RvciB0aWxlIG1heSBjb250YWluIG11bHRpcGxlIGxpbmUgZ2VvbWV0cmllcy5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwicG9pbnRcIixcblx0XHRkb2M6IFwiTGFiZWwgcGxhY2VtZW50IHJlbGF0aXZlIHRvIGl0cyBnZW9tZXRyeS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJgbGluZS1jZW50ZXJgIHZhbHVlXCI6IHtcblx0XHRcdFx0anM6IFwiMC40Ny4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi40LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTAuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwic3ltYm9sLXNwYWNpbmdcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDI1MCxcblx0XHRtaW5pbXVtOiAxLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJEaXN0YW5jZSBiZXR3ZWVuIHR3byBzeW1ib2wgYW5jaG9ycy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInN5bWJvbC1hdm9pZC1lZGdlc1wiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCB0aGUgc3ltYm9scyB3aWxsIG5vdCBjcm9zcyB0aWxlIGVkZ2VzIHRvIGF2b2lkIG11dHVhbCBjb2xsaXNpb25zLiBSZWNvbW1lbmRlZCBpbiBsYXllcnMgdGhhdCBkb24ndCBoYXZlIGVub3VnaCBwYWRkaW5nIGluIHRoZSB2ZWN0b3IgdGlsZSB0byBwcmV2ZW50IGNvbGxpc2lvbnMsIG9yIGlmIGl0IGlzIGEgcG9pbnQgc3ltYm9sIGxheWVyIHBsYWNlZCBhZnRlciBhIGxpbmUgc3ltYm9sIGxheWVyLiBXaGVuIHVzaW5nIGEgY2xpZW50IHRoYXQgc3VwcG9ydHMgZ2xvYmFsIGNvbGxpc2lvbiBkZXRlY3Rpb24sIGxpa2UgTWFwYm94IEdMIEpTIHZlcnNpb24gMC40Mi4wIG9yIGdyZWF0ZXIsIGVuYWJsaW5nIHRoaXMgcHJvcGVydHkgaXMgbm90IG5lZWRlZCB0byBwcmV2ZW50IGNsaXBwZWQgbGFiZWxzIGF0IHRpbGUgYm91bmRhcmllcy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwic3ltYm9sLXNvcnQta2V5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJTb3J0cyBmZWF0dXJlcyBpbiBhc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhpcyB2YWx1ZS4gRmVhdHVyZXMgd2l0aCBsb3dlciBzb3J0IGtleXMgYXJlIGRyYXduIGFuZCBwbGFjZWQgZmlyc3QuICBXaGVuIGBpY29uLWFsbG93LW92ZXJsYXBgIG9yIGB0ZXh0LWFsbG93LW92ZXJsYXBgIGlzIGBmYWxzZWAsIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleSB3aWxsIGhhdmUgcHJpb3JpdHkgZHVyaW5nIHBsYWNlbWVudC4gV2hlbiBgaWNvbi1hbGxvdy1vdmVybGFwYCBvciBgdGV4dC1hbGxvdy1vdmVybGFwYCBpcyBzZXQgdG8gYHRydWVgLCBmZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgb3ZlcmxhcCBvdmVyIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjExLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjUzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI3LjQuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4xMS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJzeW1ib2wtei1vcmRlclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJJZiBgc3ltYm9sLXNvcnQta2V5YCBpcyBzZXQsIHNvcnQgYmFzZWQgb24gdGhhdC4gT3RoZXJ3aXNlIHNvcnQgc3ltYm9scyBieSB0aGVpciB5LXBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fSxcblx0XHRcdFwidmlld3BvcnQteVwiOiB7XG5cdFx0XHRcdGRvYzogXCJTeW1ib2xzIHdpbGwgYmUgc29ydGVkIGJ5IHRoZWlyIHktcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9LFxuXHRcdFx0c291cmNlOiB7XG5cdFx0XHRcdGRvYzogXCJTeW1ib2xzIHdpbGwgYmUgcmVuZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHNvdXJjZSBkYXRhIHdpdGggbm8gc29ydGluZyBhcHBsaWVkLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJhdXRvXCIsXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBvcmRlciBpbiB3aGljaCBvdmVybGFwcGluZyBzeW1ib2xzIGluIHRoZSBzYW1lIGxheWVyIGFyZSByZW5kZXJlZFwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40OS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi42LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTIuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi1hbGxvdy1vdmVybGFwXCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRydWUsIHRoZSBpY29uIHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgcHJldmlvdXNseSBkcmF3biBzeW1ib2xzLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24taWdub3JlLXBsYWNlbWVudFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIGljb24uXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi1vcHRpb25hbFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCB0ZXh0IHdpbGwgZGlzcGxheSB3aXRob3V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgaWNvbnMgd2hlbiB0aGUgaWNvbiBjb2xsaWRlcyB3aXRoIG90aGVyIHN5bWJvbHMgYW5kIHRoZSB0ZXh0IGRvZXMgbm90LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIixcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgYWxpZ25zIGljb25zIGVhc3Qtd2VzdC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCBvciBgbGluZS1jZW50ZXJgLCBhbGlnbnMgaWNvbiB4LWF4ZXMgd2l0aCB0aGUgbGluZS5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJQcm9kdWNlcyBpY29ucyB3aG9zZSB4LWF4ZXMgYXJlIGFsaWduZWQgd2l0aCB0aGUgeC1heGlzIG9mIHRoZSB2aWV3cG9ydCwgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYHN5bWJvbC1wbGFjZW1lbnRgLlwiXG5cdFx0XHR9LFxuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRkb2M6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgdmlld3BvcnRgLiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgbWFwYC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwiYXV0b1wiLFxuXHRcdGRvYzogXCJJbiBjb21iaW5hdGlvbiB3aXRoIGBzeW1ib2wtcGxhY2VtZW50YCwgZGV0ZXJtaW5lcyB0aGUgcm90YXRpb24gYmVoYXZpb3Igb2YgaWNvbnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJgYXV0b2AgdmFsdWVcIjoge1xuXHRcdFx0XHRqczogXCIwLjI1LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI0LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy40LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4zLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24tc2l6ZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcImZhY3RvciBvZiB0aGUgb3JpZ2luYWwgaWNvbiBzaXplXCIsXG5cdFx0ZG9jOiBcIlNjYWxlcyB0aGUgb3JpZ2luYWwgc2l6ZSBvZiB0aGUgaWNvbiBieSB0aGUgcHJvdmlkZWQgZmFjdG9yLiBUaGUgbmV3IHBpeGVsIHNpemUgb2YgdGhlIGltYWdlIHdpbGwgYmUgdGhlIG9yaWdpbmFsIHBpeGVsIHNpemUgbXVsdGlwbGllZCBieSBgaWNvbi1zaXplYC4gMSBpcyB0aGUgb3JpZ2luYWwgc2l6ZTsgMyB0cmlwbGVzIHRoZSBzaXplIG9mIHRoZSBpbWFnZS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjM1LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLXRleHQtZml0XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBpY29uIGlzIGRpc3BsYXllZCBhdCBpdHMgaW50cmluc2ljIGFzcGVjdCByYXRpby5cIlxuXHRcdFx0fSxcblx0XHRcdHdpZHRoOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaWNvbiBpcyBzY2FsZWQgaW4gdGhlIHgtZGltZW5zaW9uIHRvIGZpdCB0aGUgd2lkdGggb2YgdGhlIHRleHQuXCJcblx0XHRcdH0sXG5cdFx0XHRoZWlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBpY29uIGlzIHNjYWxlZCBpbiB0aGUgeS1kaW1lbnNpb24gdG8gZml0IHRoZSBoZWlnaHQgb2YgdGhlIHRleHQuXCJcblx0XHRcdH0sXG5cdFx0XHRib3RoOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaWNvbiBpcyBzY2FsZWQgaW4gYm90aCB4LSBhbmQgeS1kaW1lbnNpb25zLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJub25lXCIsXG5cdFx0ZG9jOiBcIlNjYWxlcyB0aGUgaWNvbiB0byBmaXQgYXJvdW5kIHRoZSBhc3NvY2lhdGVkIHRleHQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiLFxuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMi4xXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLXRleHQtZml0LXBhZGRpbmdcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDQsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwLFxuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYWRkZWQgdG8gZGltZW5zaW9ucyBkZXRlcm1pbmVkIGJ5IGBpY29uLXRleHQtZml0YCwgaW4gY2xvY2t3aXNlIG9yZGVyOiB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiLFxuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwiaWNvbi10ZXh0LWZpdFwiOiBbXG5cdFx0XHRcdFx0XCJib3RoXCIsXG5cdFx0XHRcdFx0XCJ3aWR0aFwiLFxuXHRcdFx0XHRcdFwiaGVpZ2h0XCJcblx0XHRcdFx0XVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjIxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI0LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy40LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4yLjFcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi1pbWFnZVwiOiB7XG5cdFx0dHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG5cdFx0ZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBhbiBpbWFnZSBiYWNrZ3JvdW5kLlwiLFxuXHRcdHRva2VuczogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24tcm90YXRlXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdHBlcmlvZDogMzYwLFxuXHRcdHVuaXRzOiBcImRlZ3JlZXNcIixcblx0XHRkb2M6IFwiUm90YXRlcyB0aGUgaWNvbiBjbG9ja3dpc2UuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi1wYWRkaW5nXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAyLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhcm91bmQgdGhlIGljb24gYm91bmRpbmcgYm94IHVzZWQgZm9yIGRldGVjdGluZyBzeW1ib2wgY29sbGlzaW9ucy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24ta2VlcC11cHJpZ2h0XCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRydWUsIHRoZSBpY29uIG1heSBiZSBmbGlwcGVkIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93bi5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjogXCJtYXBcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0XCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcblx0XHRcdFx0XHRcImxpbmVcIixcblx0XHRcdFx0XHRcImxpbmUtY2VudGVyXCJcblx0XHRcdFx0XVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24tb2Zmc2V0XCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MFxuXHRcdF0sXG5cdFx0ZG9jOiBcIk9mZnNldCBkaXN0YW5jZSBvZiBpY29uIGZyb20gaXRzIGFuY2hvci4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuIEVhY2ggY29tcG9uZW50IGlzIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlIG9mIGBpY29uLXNpemVgIHRvIG9idGFpbiB0aGUgZmluYWwgb2Zmc2V0IGluIHBpeGVscy4gV2hlbiBjb21iaW5lZCB3aXRoIGBpY29uLXJvdGF0ZWAgdGhlIG9mZnNldCB3aWxsIGJlIGFzIGlmIHRoZSByb3RhdGVkIGRpcmVjdGlvbiB3YXMgdXAuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0Y2VudGVyOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgY2VudGVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRsZWZ0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGVmdCBzaWRlIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRyaWdodDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdHRvcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRvcCBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0Ym90dG9tOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcInRvcC1sZWZ0XCI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdFwidG9wLXJpZ2h0XCI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcImJvdHRvbS1sZWZ0XCI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdFwiYm90dG9tLXJpZ2h0XCI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuXHRcdGRvYzogXCJQYXJ0IG9mIHRoZSBpY29uIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40MC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24tcGl0Y2gtYWxpZ25tZW50XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGljb24gaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaWNvbiBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH0sXG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJBdXRvbWF0aWNhbGx5IG1hdGNoZXMgdGhlIHZhbHVlIG9mIGBpY29uLXJvdGF0aW9uLWFsaWdubWVudGAuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImF1dG9cIixcblx0XHRkb2M6IFwiT3JpZW50YXRpb24gb2YgaWNvbiB3aGVuIG1hcCBpcyBwaXRjaGVkLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjM5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtcGl0Y2gtYWxpZ25tZW50XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH0sXG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJBdXRvbWF0aWNhbGx5IG1hdGNoZXMgdGhlIHZhbHVlIG9mIGB0ZXh0LXJvdGF0aW9uLWFsaWdubWVudGAuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImF1dG9cIixcblx0XHRkb2M6IFwiT3JpZW50YXRpb24gb2YgdGV4dCB3aGVuIG1hcCBpcyBwaXRjaGVkLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjIxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI0LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy40LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4yLjFcIlxuXHRcdFx0fSxcblx0XHRcdFwiYGF1dG9gIHZhbHVlXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIldoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgcG9pbnRgLCBhbGlnbnMgdGV4dCBlYXN0LXdlc3QuIFdoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgbGluZWAgb3IgYGxpbmUtY2VudGVyYCwgYWxpZ25zIHRleHQgeC1heGVzIHdpdGggdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiUHJvZHVjZXMgZ2x5cGhzIHdob3NlIHgtYXhlcyBhcmUgYWxpZ25lZCB3aXRoIHRoZSB4LWF4aXMgb2YgdGhlIHZpZXdwb3J0LCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBgc3ltYm9sLXBsYWNlbWVudGAuXCJcblx0XHRcdH0sXG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGB2aWV3cG9ydGAuIFdoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgbGluZWAgb3IgYGxpbmUtY2VudGVyYCwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGBtYXBgLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJhdXRvXCIsXG5cdFx0ZG9jOiBcIkluIGNvbWJpbmF0aW9uIHdpdGggYHN5bWJvbC1wbGFjZW1lbnRgLCBkZXRlcm1pbmVzIHRoZSByb3RhdGlvbiBiZWhhdmlvciBvZiB0aGUgaW5kaXZpZHVhbCBnbHlwaHMgZm9ybWluZyB0aGUgdGV4dC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImBhdXRvYCB2YWx1ZVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjUuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjQuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjQuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjMuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1maWVsZFwiOiB7XG5cdFx0dHlwZTogXCJmb3JtYXR0ZWRcIixcblx0XHRcImRlZmF1bHRcIjogXCJcIixcblx0XHR0b2tlbnM6IHRydWUsXG5cdFx0ZG9jOiBcIlZhbHVlIHRvIHVzZSBmb3IgYSB0ZXh0IGxhYmVsLiBJZiBhIHBsYWluIGBzdHJpbmdgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBgZm9ybWF0dGVkYCB3aXRoIGRlZmF1bHQvaW5oZXJpdGVkIGZvcm1hdHRpbmcgb3B0aW9ucy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtZm9udFwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHRcIk9wZW4gU2FucyBSZWd1bGFyXCIsXG5cdFx0XHRcIkFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiXG5cdFx0XSxcblx0XHRkb2M6IFwiRm9udCBzdGFjayB0byB1c2UgZm9yIGRpc3BsYXlpbmcgdGV4dC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1zaXplXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxNixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJGb250IHNpemUuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1tYXgtd2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwiZW1zXCIsXG5cdFx0ZG9jOiBcIlRoZSBtYXhpbXVtIGxpbmUgd2lkdGggZm9yIHRleHQgd3JhcHBpbmcuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40MC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1saW5lLWhlaWdodFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMS4yLFxuXHRcdHVuaXRzOiBcImVtc1wiLFxuXHRcdGRvYzogXCJUZXh0IGxlYWRpbmcgdmFsdWUgZm9yIG11bHRpLWxpbmUgdGV4dC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0dW5pdHM6IFwiZW1zXCIsXG5cdFx0ZG9jOiBcIlRleHQgdHJhY2tpbmcgYW1vdW50LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtanVzdGlmeVwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvd2FyZHMgdGhlIGFuY2hvciBwb3NpdGlvbi5cIlxuXHRcdFx0fSxcblx0XHRcdGxlZnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIGxlZnQuXCJcblx0XHRcdH0sXG5cdFx0XHRjZW50ZXI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGNlbnRlcmVkLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIHJpZ2h0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcblx0XHRkb2M6IFwiVGV4dCBqdXN0aWZpY2F0aW9uIG9wdGlvbnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH0sXG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTQuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjEwLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtcmFkaWFsLW9mZnNldFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHR1bml0czogXCJlbXNcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiUmFkaWFsIG9mZnNldCBvZiB0ZXh0LCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzeW1ib2wncyBhbmNob3IuIFVzZWZ1bCBpbiBjb21iaW5hdGlvbiB3aXRoIGB0ZXh0LXZhcmlhYmxlLWFuY2hvcmAsIHdoaWNoIGRlZmF1bHRzIHRvIHVzaW5nIHRoZSB0d28tZGltZW5zaW9uYWwgYHRleHQtb2Zmc2V0YCBpZiBwcmVzZW50LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC41NC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNy40LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMTAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTQuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjEwLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIixcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH1cblx0fSxcblx0XCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGNlbnRlcjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGNlbnRlciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0bGVmdDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHR0b3A6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3Agb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdGJvdHRvbToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ0b3AtbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcInRvcC1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJib3R0b20tbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcImJvdHRvbS1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG5cdFx0XHRcdFx0XCJwb2ludFwiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdGRvYzogXCJUbyBpbmNyZWFzZSB0aGUgY2hhbmNlIG9mIHBsYWNpbmcgaGlnaC1wcmlvcml0eSBsYWJlbHMgb24gdGhlIG1hcCwgeW91IGNhbiBwcm92aWRlIGFuIGFycmF5IG9mIGB0ZXh0LWFuY2hvcmAgbG9jYXRpb25zOiB0aGUgcmVuZGVyZXIgd2lsbCBhdHRlbXB0IHRvIHBsYWNlIHRoZSBsYWJlbCBhdCBlYWNoIGxvY2F0aW9uLCBpbiBvcmRlciwgYmVmb3JlIG1vdmluZyBvbnRvIHRoZSBuZXh0IGxhYmVsLiBVc2UgYHRleHQtanVzdGlmeTogYXV0b2AgdG8gY2hvb3NlIGp1c3RpZmljYXRpb24gYmFzZWQgb24gYW5jaG9yIHBvc2l0aW9uLiBUbyBhcHBseSBhbiBvZmZzZXQsIHVzZSB0aGUgYHRleHQtcmFkaWFsLW9mZnNldGAgb3IgdGhlIHR3by1kaW1lbnNpb25hbCBgdGV4dC1vZmZzZXRgLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC41NC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNy40LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMTAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGNlbnRlcjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGNlbnRlciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0bGVmdDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHR0b3A6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3Agb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdGJvdHRvbToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ0b3AtbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcInRvcC1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJib3R0b20tbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcImJvdHRvbS1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcblx0XHRkb2M6IFwiUGFydCBvZiB0aGUgdGV4dCBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwidGV4dC12YXJpYWJsZS1hbmNob3JcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LW1heC1hbmdsZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogNDUsXG5cdFx0dW5pdHM6IFwiZGVncmVlc1wiLFxuXHRcdGRvYzogXCJNYXhpbXVtIGFuZ2xlIGNoYW5nZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcInN5bWJvbC1wbGFjZW1lbnRcIjogW1xuXHRcdFx0XHRcdFwibGluZVwiLFxuXHRcdFx0XHRcdFwibGluZS1jZW50ZXJcIlxuXHRcdFx0XHRdXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXdyaXRpbmctbW9kZVwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGhvcml6b250YWw6IHtcblx0XHRcdFx0ZG9jOiBcIklmIGEgdGV4dCdzIGxhbmd1YWdlIHN1cHBvcnRzIGhvcml6b250YWwgd3JpdGluZyBtb2RlLCBzeW1ib2xzIHdpdGggcG9pbnQgcGxhY2VtZW50IHdvdWxkIGJlIGxhaWQgb3V0IGhvcml6b250YWxseS5cIlxuXHRcdFx0fSxcblx0XHRcdHZlcnRpY2FsOiB7XG5cdFx0XHRcdGRvYzogXCJJZiBhIHRleHQncyBsYW5ndWFnZSBzdXBwb3J0cyB2ZXJ0aWNhbCB3cml0aW5nIG1vZGUsIHN5bWJvbHMgd2l0aCBwb2ludCBwbGFjZW1lbnQgd291bGQgYmUgbGFpZCBvdXQgdmVydGljYWxseS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBwcm9wZXJ0eSBhbGxvd3MgY29udHJvbCBvdmVyIGEgc3ltYm9sJ3Mgb3JpZW50YXRpb24uIE5vdGUgdGhhdCB0aGUgcHJvcGVydHkgdmFsdWVzIGFjdCBhcyBhIGhpbnQsIHNvIHRoYXQgYSBzeW1ib2wgd2hvc2UgbGFuZ3VhZ2UgZG9lc27igJl0IHN1cHBvcnQgdGhlIHByb3ZpZGVkIG9yaWVudGF0aW9uIHdpbGwgYmUgbGFpZCBvdXQgaW4gaXRzIG5hdHVyYWwgb3JpZW50YXRpb24uIEV4YW1wbGU6IEVuZ2xpc2ggcG9pbnQgc3ltYm9sIHdpbGwgYmUgcmVuZGVyZWQgaG9yaXpvbnRhbGx5IGV2ZW4gaWYgYXJyYXkgdmFsdWUgY29udGFpbnMgc2luZ2xlICd2ZXJ0aWNhbCcgZW51bSB2YWx1ZS4gVGhlIG9yZGVyIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5IGRlZmluZSBwcmlvcml0eSBvcmRlciBmb3IgdGhlIHBsYWNlbWVudCBvZiBhbiBvcmllbnRhdGlvbiB2YXJpYW50LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdHtcblx0XHRcdFx0XCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcblx0XHRcdFx0XHRcInBvaW50XCJcblx0XHRcdFx0XVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIxLjMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjguMy4wXCIsXG5cdFx0XHRcdGlvczogXCI1LjMuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtcm90YXRlXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdHBlcmlvZDogMzYwLFxuXHRcdHVuaXRzOiBcImRlZ3JlZXNcIixcblx0XHRkb2M6IFwiUm90YXRlcyB0aGUgdGV4dCBjbG9ja3dpc2UuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1wYWRkaW5nXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAyLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhcm91bmQgdGhlIHRleHQgYm91bmRpbmcgYm94IHVzZWQgZm9yIGRldGVjdGluZyBzeW1ib2wgY29sbGlzaW9ucy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQta2VlcC11cHJpZ2h0XCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogdHJ1ZSxcblx0XHRkb2M6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgbWF5IGJlIGZsaXBwZWQgdmVydGljYWxseSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG5cdFx0XHRcdFx0XCJsaW5lXCIsXG5cdFx0XHRcdFx0XCJsaW5lLWNlbnRlclwiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyBub3QgYWx0ZXJlZC5cIlxuXHRcdFx0fSxcblx0XHRcdHVwcGVyY2FzZToge1xuXHRcdFx0XHRkb2M6IFwiRm9yY2VzIGFsbCBsZXR0ZXJzIHRvIGJlIGRpc3BsYXllZCBpbiB1cHBlcmNhc2UuXCJcblx0XHRcdH0sXG5cdFx0XHRsb3dlcmNhc2U6IHtcblx0XHRcdFx0ZG9jOiBcIkZvcmNlcyBhbGwgbGV0dGVycyB0byBiZSBkaXNwbGF5ZWQgaW4gbG93ZXJjYXNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJub25lXCIsXG5cdFx0ZG9jOiBcIlNwZWNpZmllcyBob3cgdG8gY2FwaXRhbGl6ZSB0ZXh0LCBzaW1pbGFyIHRvIHRoZSBDU1MgYHRleHQtdHJhbnNmb3JtYCBwcm9wZXJ0eS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1vZmZzZXRcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRkb2M6IFwiT2Zmc2V0IGRpc3RhbmNlIG9mIHRleHQgZnJvbSBpdHMgYW5jaG9yLiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC4gSWYgdXNlZCB3aXRoIHRleHQtdmFyaWFibGUtYW5jaG9yLCBpbnB1dCB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBhcyBhYnNvbHV0ZSB2YWx1ZXMuIE9mZnNldHMgYWxvbmcgdGhlIHgtIGFuZCB5LWF4aXMgd2lsbCBiZSBhcHBsaWVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhlIGFuY2hvciBwb3NpdGlvbi5cIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHR1bml0czogXCJlbXNcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcInRleHQtcmFkaWFsLW9mZnNldFwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgcHJldmlvdXNseSBkcmF3biBzeW1ib2xzLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIHRleHQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1vcHRpb25hbFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCBpY29ucyB3aWxsIGRpc3BsYXkgd2l0aG91dCB0aGVpciBjb3JyZXNwb25kaW5nIHRleHQgd2hlbiB0aGUgdGV4dCBjb2xsaWRlcyB3aXRoIG90aGVyIHN5bWJvbHMgYW5kIHRoZSBpY29uIGRvZXMgbm90LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn07XG52YXIgbGF5b3V0X3Jhc3RlciA9IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfaGlsbHNoYWRlID0ge1xuXHR2aXNpYmlsaXR5OiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2aXNpYmxlOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcblx0XHRcdH0sXG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIGZpbHRlciA9IHtcblx0dHlwZTogXCJhcnJheVwiLFxuXHR2YWx1ZTogXCIqXCIsXG5cdGRvYzogXCJBIGZpbHRlciBzZWxlY3RzIHNwZWNpZmljIGZlYXR1cmVzIGZyb20gYSBsYXllci5cIlxufTtcbnZhciBmaWx0ZXJfb3BlcmF0b3IgPSB7XG5cdHR5cGU6IFwiZW51bVwiLFxuXHR2YWx1ZXM6IHtcblx0XHRcIj09XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCI9PVxcXCIsIGtleSwgdmFsdWVdYCBlcXVhbGl0eTogYGZlYXR1cmVba2V5XSA9IHZhbHVlYFwiXG5cdFx0fSxcblx0XHRcIiE9XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCIhPVxcXCIsIGtleSwgdmFsdWVdYCBpbmVxdWFsaXR5OiBgZmVhdHVyZVtrZXldIOKJoCB2YWx1ZWBcIlxuXHRcdH0sXG5cdFx0XCI+XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCI+XFxcIiwga2V5LCB2YWx1ZV1gIGdyZWF0ZXIgdGhhbjogYGZlYXR1cmVba2V5XSA+IHZhbHVlYFwiXG5cdFx0fSxcblx0XHRcIj49XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCI+PVxcXCIsIGtleSwgdmFsdWVdYCBncmVhdGVyIHRoYW4gb3IgZXF1YWw6IGBmZWF0dXJlW2tleV0g4omlIHZhbHVlYFwiXG5cdFx0fSxcblx0XHRcIjxcIjoge1xuXHRcdFx0ZG9jOiBcImBbXFxcIjxcXFwiLCBrZXksIHZhbHVlXWAgbGVzcyB0aGFuOiBgZmVhdHVyZVtrZXldIDwgdmFsdWVgXCJcblx0XHR9LFxuXHRcdFwiPD1cIjoge1xuXHRcdFx0ZG9jOiBcImBbXFxcIjw9XFxcIiwga2V5LCB2YWx1ZV1gIGxlc3MgdGhhbiBvciBlcXVhbDogYGZlYXR1cmVba2V5XSDiiaQgdmFsdWVgXCJcblx0XHR9LFxuXHRcdFwiaW5cIjoge1xuXHRcdFx0ZG9jOiBcImBbXFxcImluXFxcIiwga2V5LCB2MCwgLi4uLCB2bl1gIHNldCBpbmNsdXNpb246IGBmZWF0dXJlW2tleV0g4oiIIHt2MCwgLi4uLCB2bn1gXCJcblx0XHR9LFxuXHRcdFwiIWluXCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCIhaW5cXFwiLCBrZXksIHYwLCAuLi4sIHZuXWAgc2V0IGV4Y2x1c2lvbjogYGZlYXR1cmVba2V5XSDiiIkge3YwLCAuLi4sIHZufWBcIlxuXHRcdH0sXG5cdFx0YWxsOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiYWxsXFxcIiwgZjAsIC4uLiwgZm5dYCBsb2dpY2FsIGBBTkRgOiBgZjAg4oinIC4uLiDiiKcgZm5gXCJcblx0XHR9LFxuXHRcdGFueToge1xuXHRcdFx0ZG9jOiBcImBbXFxcImFueVxcXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgT1JgOiBgZjAg4oioIC4uLiDiiKggZm5gXCJcblx0XHR9LFxuXHRcdG5vbmU6IHtcblx0XHRcdGRvYzogXCJgW1xcXCJub25lXFxcIiwgZjAsIC4uLiwgZm5dYCBsb2dpY2FsIGBOT1JgOiBgwqxmMCDiiKcgLi4uIOKIpyDCrGZuYFwiXG5cdFx0fSxcblx0XHRoYXM6IHtcblx0XHRcdGRvYzogXCJgW1xcXCJoYXNcXFwiLCBrZXldYCBgZmVhdHVyZVtrZXldYCBleGlzdHNcIlxuXHRcdH0sXG5cdFx0XCIhaGFzXCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCIhaGFzXFxcIiwga2V5XWAgYGZlYXR1cmVba2V5XWAgZG9lcyBub3QgZXhpc3RcIlxuXHRcdH1cblx0fSxcblx0ZG9jOiBcIlRoZSBmaWx0ZXIgb3BlcmF0b3IuXCJcbn07XG52YXIgZ2VvbWV0cnlfdHlwZSA9IHtcblx0dHlwZTogXCJlbnVtXCIsXG5cdHZhbHVlczoge1xuXHRcdFBvaW50OiB7XG5cdFx0XHRkb2M6IFwiRmlsdGVyIHRvIHBvaW50IGdlb21ldHJpZXMuXCJcblx0XHR9LFxuXHRcdExpbmVTdHJpbmc6IHtcblx0XHRcdGRvYzogXCJGaWx0ZXIgdG8gbGluZSBnZW9tZXRyaWVzLlwiXG5cdFx0fSxcblx0XHRQb2x5Z29uOiB7XG5cdFx0XHRkb2M6IFwiRmlsdGVyIHRvIHBvbHlnb24gZ2VvbWV0cmllcy5cIlxuXHRcdH1cblx0fSxcblx0ZG9jOiBcIlRoZSBnZW9tZXRyeSB0eXBlIGZvciB0aGUgZmlsdGVyIHRvIHNlbGVjdC5cIlxufTtcbnZhciBmdW5jdGlvbl9zdG9wID0ge1xuXHR0eXBlOiBcImFycmF5XCIsXG5cdG1pbmltdW06IDAsXG5cdG1heGltdW06IDI0LFxuXHR2YWx1ZTogW1xuXHRcdFwibnVtYmVyXCIsXG5cdFx0XCJjb2xvclwiXG5cdF0sXG5cdGxlbmd0aDogMixcblx0ZG9jOiBcIlpvb20gbGV2ZWwgYW5kIHZhbHVlIHBhaXIuXCJcbn07XG52YXIgZXhwcmVzc2lvbiA9IHtcblx0dHlwZTogXCJhcnJheVwiLFxuXHR2YWx1ZTogXCIqXCIsXG5cdG1pbmltdW06IDEsXG5cdGRvYzogXCJBbiBleHByZXNzaW9uIGRlZmluZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGZvciBkYXRhLWRyaXZlbiBzdHlsZSBwcm9wZXJ0aWVzIG9yIGZlYXR1cmUgZmlsdGVycy5cIlxufTtcbnZhciBleHByZXNzaW9uX25hbWUgPSB7XG5cdGRvYzogXCJcIixcblx0dHlwZTogXCJlbnVtXCIsXG5cdHZhbHVlczoge1xuXHRcdFwibGV0XCI6IHtcblx0XHRcdGRvYzogXCJCaW5kcyBleHByZXNzaW9ucyB0byBuYW1lZCB2YXJpYWJsZXMsIHdoaWNoIGNhbiB0aGVuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIHJlc3VsdCBleHByZXNzaW9uIHVzaW5nIFtcXFwidmFyXFxcIiwgXFxcInZhcmlhYmxlX25hbWVcXFwiXS5cIixcblx0XHRcdGdyb3VwOiBcIlZhcmlhYmxlIGJpbmRpbmdcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwidmFyXCI6IHtcblx0XHRcdGRvYzogXCJSZWZlcmVuY2VzIHZhcmlhYmxlIGJvdW5kIHVzaW5nIFxcXCJsZXRcXFwiLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVmFyaWFibGUgYmluZGluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bGl0ZXJhbDoge1xuXHRcdFx0ZG9jOiBcIlByb3ZpZGVzIGEgbGl0ZXJhbCBhcnJheSBvciBvYmplY3QgdmFsdWUuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXJyYXk6IHtcblx0XHRcdGRvYzogXCJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IGlzIGFuIGFycmF5IChvcHRpb25hbGx5IHdpdGggYSBzcGVjaWZpYyBpdGVtIHR5cGUgYW5kIGxlbmd0aCkuICBJZiwgd2hlbiB0aGUgaW5wdXQgZXhwcmVzc2lvbiBpcyBldmFsdWF0ZWQsIGl0IGlzIG5vdCBvZiB0aGUgYXNzZXJ0ZWQgdHlwZSwgdGhlbiB0aGlzIGFzc2VydGlvbiB3aWxsIGNhdXNlIHRoZSB3aG9sZSBleHByZXNzaW9uIHRvIGJlIGFib3J0ZWQuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXQ6IHtcblx0XHRcdGRvYzogXCJSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImluXCI6IHtcblx0XHRcdGRvYzogXCJEZXRlcm1pbmVzIHdoZXRoZXIgYW4gaXRlbSBleGlzdHMgaW4gYW4gYXJyYXkgb3IgYSBzdWJzdHJpbmcgZXhpc3RzIGluIGEgc3RyaW5nLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjYuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiaW5kZXgtb2ZcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gYW4gYXJyYXksIG9yIGZvciBhIHN0cmluZywgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCB2YWx1ZS4gSWYgYSBzZWNvbmQgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZW4gdGhlIHNlYXJjaCBpcyBzdGFydGVkIGZyb20gdGhhdCBwb3NpdGlvbi4gUmV0dXJucyAtMSBpZiB0aGUgdmFsdWUgaXMgbm90IGZvdW5kLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjEwLjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImNhc2VcIjoge1xuXHRcdFx0ZG9jOiBcIlNlbGVjdHMgdGhlIGZpcnN0IG91dHB1dCB3aG9zZSBjb3JyZXNwb25kaW5nIHRlc3QgY29uZGl0aW9uIGV2YWx1YXRlcyB0byB0cnVlLCBvciB0aGUgZmFsbGJhY2sgdmFsdWUgb3RoZXJ3aXNlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG1hdGNoOiB7XG5cdFx0XHRkb2M6IFwiU2VsZWN0cyB0aGUgb3V0cHV0IHdob3NlIGxhYmVsIHZhbHVlIG1hdGNoZXMgdGhlIGlucHV0IHZhbHVlLCBvciB0aGUgZmFsbGJhY2sgdmFsdWUgaWYgbm8gbWF0Y2ggaXMgZm91bmQuIFRoZSBpbnB1dCBjYW4gYmUgYW55IGV4cHJlc3Npb24gKGUuZy4gYFtcXFwiZ2V0XFxcIiwgXFxcImJ1aWxkaW5nX3R5cGVcXFwiXWApLiBFYWNoIGxhYmVsIG11c3QgYmUgZWl0aGVyOlxcbiAqIGEgc2luZ2xlIGxpdGVyYWwgdmFsdWU7IG9yXFxuICogYW4gYXJyYXkgb2YgbGl0ZXJhbCB2YWx1ZXMsIHdob3NlIHZhbHVlcyBtdXN0IGJlIGFsbCBzdHJpbmdzIG9yIGFsbCBudW1iZXJzIChlLmcuIGBbMTAwLCAxMDFdYCBvciBgW1xcXCJjXFxcIiwgXFxcImJcXFwiXWApLiBUaGUgaW5wdXQgbWF0Y2hlcyBpZiBhbnkgb2YgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgbWF0Y2hlcywgc2ltaWxhciB0byB0aGUgYFxcXCJpblxcXCJgIG9wZXJhdG9yLlxcblxcbkVhY2ggbGFiZWwgbXVzdCBiZSB1bmlxdWUuIElmIHRoZSBpbnB1dCB0eXBlIGRvZXMgbm90IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBsYWJlbHMsIHRoZSByZXN1bHQgd2lsbCBiZSB0aGUgZmFsbGJhY2sgdmFsdWUuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29hbGVzY2U6IHtcblx0XHRcdGRvYzogXCJFdmFsdWF0ZXMgZWFjaCBleHByZXNzaW9uIGluIHR1cm4gdW50aWwgdGhlIGZpcnN0IG5vbi1udWxsIHZhbHVlIGlzIG9idGFpbmVkLCBhbmQgcmV0dXJucyB0aGF0IHZhbHVlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHN0ZXA6IHtcblx0XHRcdGRvYzogXCJQcm9kdWNlcyBkaXNjcmV0ZSwgc3RlcHBlZCByZXN1bHRzIGJ5IGV2YWx1YXRpbmcgYSBwaWVjZXdpc2UtY29uc3RhbnQgZnVuY3Rpb24gZGVmaW5lZCBieSBwYWlycyBvZiBpbnB1dCBhbmQgb3V0cHV0IHZhbHVlcyAoXFxcInN0b3BzXFxcIikuIFRoZSBgaW5wdXRgIG1heSBiZSBhbnkgbnVtZXJpYyBleHByZXNzaW9uIChlLmcuLCBgW1xcXCJnZXRcXFwiLCBcXFwicG9wdWxhdGlvblxcXCJdYCkuIFN0b3AgaW5wdXRzIG11c3QgYmUgbnVtZXJpYyBsaXRlcmFscyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuIFJldHVybnMgdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBqdXN0IGxlc3MgdGhhbiB0aGUgaW5wdXQsIG9yIHRoZSBmaXJzdCBvdXRwdXQgaWYgdGhlIGlucHV0IGlzIGxlc3MgdGhhbiB0aGUgZmlyc3Qgc3RvcC5cIixcblx0XHRcdGdyb3VwOiBcIlJhbXBzLCBzY2FsZXMsIGN1cnZlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40Mi4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW50ZXJwb2xhdGU6IHtcblx0XHRcdGRvYzogXCJQcm9kdWNlcyBjb250aW51b3VzLCBzbW9vdGggcmVzdWx0cyBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFxcXCJzdG9wc1xcXCIpLiBUaGUgYGlucHV0YCBtYXkgYmUgYW55IG51bWVyaWMgZXhwcmVzc2lvbiAoZS5nLiwgYFtcXFwiZ2V0XFxcIiwgXFxcInBvcHVsYXRpb25cXFwiXWApLiBTdG9wIGlucHV0cyBtdXN0IGJlIG51bWVyaWMgbGl0ZXJhbHMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLiBUaGUgb3V0cHV0IHR5cGUgbXVzdCBiZSBgbnVtYmVyYCwgYGFycmF5PG51bWJlcj5gLCBvciBgY29sb3JgLlxcblxcbkludGVycG9sYXRpb24gdHlwZXM6XFxuLSBgW1xcXCJsaW5lYXJcXFwiXWA6IGludGVycG9sYXRlcyBsaW5lYXJseSBiZXR3ZWVuIHRoZSBwYWlyIG9mIHN0b3BzIGp1c3QgbGVzcyB0aGFuIGFuZCBqdXN0IGdyZWF0ZXIgdGhhbiB0aGUgaW5wdXQuXFxuLSBgW1xcXCJleHBvbmVudGlhbFxcXCIsIGJhc2VdYDogaW50ZXJwb2xhdGVzIGV4cG9uZW50aWFsbHkgYmV0d2VlbiB0aGUgc3RvcHMganVzdCBsZXNzIHRoYW4gYW5kIGp1c3QgZ3JlYXRlciB0aGFuIHRoZSBpbnB1dC4gYGJhc2VgIGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBvdXRwdXQgaW5jcmVhc2VzOiBoaWdoZXIgdmFsdWVzIG1ha2UgdGhlIG91dHB1dCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCB2YWx1ZXMgY2xvc2UgdG8gMSB0aGUgb3V0cHV0IGluY3JlYXNlcyBsaW5lYXJseS5cXG4tIGBbXFxcImN1YmljLWJlemllclxcXCIsIHgxLCB5MSwgeDIsIHkyXWA6IGludGVycG9sYXRlcyB1c2luZyB0aGUgY3ViaWMgYmV6aWVyIGN1cnZlIGRlZmluZWQgYnkgdGhlIGdpdmVuIGNvbnRyb2wgcG9pbnRzLlwiLFxuXHRcdFx0Z3JvdXA6IFwiUmFtcHMsIHNjYWxlcywgY3VydmVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQyLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImludGVycG9sYXRlLWhjbFwiOiB7XG5cdFx0XHRkb2M6IFwiUHJvZHVjZXMgY29udGludW91cywgc21vb3RoIHJlc3VsdHMgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcXFwic3RvcHNcXFwiKS4gV29ya3MgbGlrZSBgaW50ZXJwb2xhdGVgLCBidXQgdGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYGNvbG9yYCwgYW5kIHRoZSBpbnRlcnBvbGF0aW9uIGlzIHBlcmZvcm1lZCBpbiB0aGUgSHVlLUNocm9tYS1MdW1pbmFuY2UgY29sb3Igc3BhY2UuXCIsXG5cdFx0XHRncm91cDogXCJSYW1wcywgc2NhbGVzLCBjdXJ2ZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiaW50ZXJwb2xhdGUtbGFiXCI6IHtcblx0XHRcdGRvYzogXCJQcm9kdWNlcyBjb250aW51b3VzLCBzbW9vdGggcmVzdWx0cyBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFxcXCJzdG9wc1xcXCIpLiBXb3JrcyBsaWtlIGBpbnRlcnBvbGF0ZWAsIGJ1dCB0aGUgb3V0cHV0IHR5cGUgbXVzdCBiZSBgY29sb3JgLCBhbmQgdGhlIGludGVycG9sYXRpb24gaXMgcGVyZm9ybWVkIGluIHRoZSBDSUVMQUIgY29sb3Igc3BhY2UuXCIsXG5cdFx0XHRncm91cDogXCJSYW1wcywgc2NhbGVzLCBjdXJ2ZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGxuMjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgbWF0aGVtYXRpY2FsIGNvbnN0YW50IGxuKDIpLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cGk6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBtYXRoZW1hdGljYWwgY29uc3RhbnQgcGkuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgbWF0aGVtYXRpY2FsIGNvbnN0YW50IGUuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInR5cGVvZlwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSB0eXBlIG9mIHRoZSBnaXZlbiB2YWx1ZS5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdHJpbmc6IHtcblx0XHRcdGRvYzogXCJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IHZhbHVlIGlzIGEgc3RyaW5nLiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgYSBzdHJpbmcgaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgc3RyaW5ncywgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bnVtYmVyOiB7XG5cdFx0XHRkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIG51bWJlci4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgbnVtYmVyIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIG51bWJlcnMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGJvb2xlYW46IHtcblx0XHRcdGRvYzogXCJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IHZhbHVlIGlzIGEgYm9vbGVhbi4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgYm9vbGVhbiBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGFyZSBib29sZWFucywgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b2JqZWN0OiB7XG5cdFx0XHRkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhbiBvYmplY3QuIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhbiBvYmplY3QgaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgb2JqZWN0cywgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29sbGF0b3I6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGEgYGNvbGxhdG9yYCBmb3IgdXNlIGluIGxvY2FsZS1kZXBlbmRlbnQgY29tcGFyaXNvbiBvcGVyYXRpb25zLiBUaGUgYGNhc2Utc2Vuc2l0aXZlYCBhbmQgYGRpYWNyaXRpYy1zZW5zaXRpdmVgIG9wdGlvbnMgZGVmYXVsdCB0byBgZmFsc2VgLiBUaGUgYGxvY2FsZWAgYXJndW1lbnQgc3BlY2lmaWVzIHRoZSBJRVRGIGxhbmd1YWdlIHRhZyBvZiB0aGUgbG9jYWxlIHRvIHVzZS4gSWYgbm9uZSBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgbG9jYWxlIGlzIHVzZWQuIElmIHRoZSByZXF1ZXN0ZWQgbG9jYWxlIGlzIG5vdCBhdmFpbGFibGUsIHRoZSBgY29sbGF0b3JgIHdpbGwgdXNlIGEgc3lzdGVtLWRlZmluZWQgZmFsbGJhY2sgbG9jYWxlLiBVc2UgYHJlc29sdmVkLWxvY2FsZWAgdG8gdGVzdCB0aGUgcmVzdWx0cyBvZiBsb2NhbGUgZmFsbGJhY2sgYmVoYXZpb3IuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zm9ybWF0OiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgZm9ybWF0dGVkYCB0ZXh0IGNvbnRhaW5pbmcgYW5ub3RhdGlvbnMgZm9yIHVzZSBpbiBtaXhlZC1mb3JtYXQgYHRleHQtZmllbGRgIGVudHJpZXMuIEZvciBhIGB0ZXh0LWZpZWxkYCBlbnRyaWVzIG9mIGEgc3RyaW5nIHR5cGUsIGZvbGxvd2luZyBvcHRpb24gb2JqZWN0J3MgcHJvcGVydGllcyBhcmUgc3VwcG9ydGVkOiBJZiBzZXQsIHRoZSBgdGV4dC1mb250YCB2YWx1ZSBvdmVycmlkZXMgdGhlIGZvbnQgc3BlY2lmaWVkIGJ5IHRoZSByb290IGxheW91dCBwcm9wZXJ0aWVzLiBJZiBzZXQsIHRoZSBgZm9udC1zY2FsZWAgdmFsdWUgc3BlY2lmaWVzIGEgc2NhbGluZyBmYWN0b3IgcmVsYXRpdmUgdG8gdGhlIGB0ZXh0LXNpemVgIHNwZWNpZmllZCBpbiB0aGUgcm9vdCBsYXlvdXQgcHJvcGVydGllcy4gSWYgc2V0LCB0aGUgYHRleHQtY29sb3JgIHZhbHVlIG92ZXJyaWRlcyB0aGUgY29sb3Igc3BlY2lmaWVkIGJ5IHRoZSByb290IHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40OC4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjcuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjYuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuMTIuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwidGV4dC1mb250XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ4LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNy4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuNi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xMi4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJmb250LXNjYWxlXCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ4LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNy4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuNi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xMi4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJ0ZXh0LWNvbG9yXCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjMuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNy4zLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4xMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0aW1hZ2U6IHtcblx0XHRcdFx0XHRqczogXCIxLjYuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGltYWdlOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhbiBgaW1hZ2VgIHR5cGUgZm9yIHVzZSBpbiBgaWNvbi1pbWFnZWAsIGAqLXBhdHRlcm5gIGVudHJpZXMgYW5kIGFzIGEgc2VjdGlvbiBpbiB0aGUgYGZvcm1hdGAgZXhwcmVzc2lvbi4gSWYgc2V0LCB0aGUgYGltYWdlYCBhcmd1bWVudCB3aWxsIGNoZWNrIHRoYXQgdGhlIHJlcXVlc3RlZCBpbWFnZSBleGlzdHMgaW4gdGhlIHN0eWxlIGFuZCB3aWxsIHJldHVybiBlaXRoZXIgdGhlIHJlc29sdmVkIGltYWdlIG5hbWUgb3IgYG51bGxgLCBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3QgdGhlIGltYWdlIGlzIGN1cnJlbnRseSBpbiB0aGUgc3R5bGUuIFRoaXMgdmFsaWRhdGlvbiBwcm9jZXNzIGlzIHN5bmNocm9ub3VzIGFuZCByZXF1aXJlcyB0aGUgaW1hZ2UgdG8gaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBzdHlsZSBiZWZvcmUgcmVxdWVzdGluZyBpdCBpbiB0aGUgYGltYWdlYCBhcmd1bWVudC5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjQuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiOC42LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNS42LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIm51bWJlci1mb3JtYXRcIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCBudW1iZXIgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiB1c2luZyB0aGUgcHJvdmlkaW5nIGZvcm1hdHRpbmcgcnVsZXMuIElmIHNldCwgdGhlIGBsb2NhbGVgIGFyZ3VtZW50IHNwZWNpZmllcyB0aGUgbG9jYWxlIHRvIHVzZSwgYXMgYSBCQ1AgNDcgbGFuZ3VhZ2UgdGFnLiBJZiBzZXQsIHRoZSBgY3VycmVuY3lgIGFyZ3VtZW50IHNwZWNpZmllcyBhbiBJU08gNDIxNyBjb2RlIHRvIHVzZSBmb3IgY3VycmVuY3ktc3R5bGUgZm9ybWF0dGluZy4gSWYgc2V0LCB0aGUgYG1pbi1mcmFjdGlvbi1kaWdpdHNgIGFuZCBgbWF4LWZyYWN0aW9uLWRpZ2l0c2AgYXJndW1lbnRzIHNwZWNpZnkgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbnVtYmVyIG9mIGZyYWN0aW9uYWwgZGlnaXRzIHRvIGluY2x1ZGUuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC41NC4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ0by1zdHJpbmdcIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIHN0cmluZy4gSWYgdGhlIGlucHV0IGlzIGBudWxsYCwgdGhlIHJlc3VsdCBpcyBgXFxcIlxcXCJgLiBJZiB0aGUgaW5wdXQgaXMgYSBib29sZWFuLCB0aGUgcmVzdWx0IGlzIGBcXFwidHJ1ZVxcXCJgIG9yIGBcXFwiZmFsc2VcXFwiYC4gSWYgdGhlIGlucHV0IGlzIGEgbnVtYmVyLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgYXMgc3BlY2lmaWVkIGJ5IHRoZSBbXFxcIk51bWJlclRvU3RyaW5nXFxcIiBhbGdvcml0aG1dKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvc3RyaW5nLWFwcGxpZWQtdG8tdGhlLW51bWJlci10eXBlKSBvZiB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uLiBJZiB0aGUgaW5wdXQgaXMgYSBjb2xvciwgaXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIG9mIHRoZSBmb3JtIGBcXFwicmdiYShyLGcsYixhKVxcXCJgLCB3aGVyZSBgcmAsIGBnYCwgYW5kIGBiYCBhcmUgbnVtZXJhbHMgcmFuZ2luZyBmcm9tIDAgdG8gMjU1LCBhbmQgYGFgIHJhbmdlcyBmcm9tIDAgdG8gMS4gT3RoZXJ3aXNlLCB0aGUgaW5wdXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IHRoZSBbYEpTT04uc3RyaW5naWZ5YF0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtanNvbi5zdHJpbmdpZnkpIGZ1bmN0aW9uIG9mIHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb24uXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ0by1udW1iZXJcIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciwgaWYgcG9zc2libGUuIElmIHRoZSBpbnB1dCBpcyBgbnVsbGAgb3IgYGZhbHNlYCwgdGhlIHJlc3VsdCBpcyAwLiBJZiB0aGUgaW5wdXQgaXMgYHRydWVgLCB0aGUgcmVzdWx0IGlzIDEuIElmIHRoZSBpbnB1dCBpcyBhIHN0cmluZywgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyIGFzIHNwZWNpZmllZCBieSB0aGUgW1xcXCJUb051bWJlciBBcHBsaWVkIHRvIHRoZSBTdHJpbmcgVHlwZVxcXCIgYWxnb3JpdGhtXShodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b251bWJlci1hcHBsaWVkLXRvLXRoZS1zdHJpbmctdHlwZSkgb2YgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgU3BlY2lmaWNhdGlvbi4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGNvbnZlcnNpb24gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBjYW4gYmUgY29udmVydGVkLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInRvLWJvb2xlYW5cIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIGJvb2xlYW4uIFRoZSByZXN1bHQgaXMgYGZhbHNlYCB3aGVuIHRoZW4gaW5wdXQgaXMgYW4gZW1wdHkgc3RyaW5nLCAwLCBgZmFsc2VgLCBgbnVsbGAsIG9yIGBOYU5gOyBvdGhlcndpc2UgaXQgaXMgYHRydWVgLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwidG8tcmdiYVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhIGZvdXItZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSBpbnB1dCBjb2xvcidzIHJlZCwgZ3JlZW4sIGJsdWUsIGFuZCBhbHBoYSBjb21wb25lbnRzLCBpbiB0aGF0IG9yZGVyLlwiLFxuXHRcdFx0Z3JvdXA6IFwiQ29sb3JcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwidG8tY29sb3JcIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIGNvbG9yLiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgdGhlIGZpcnN0IHN1Y2Nlc3NmdWwgY29udmVyc2lvbiBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGNhbiBiZSBjb252ZXJ0ZWQsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJnYjoge1xuXHRcdFx0ZG9jOiBcIkNyZWF0ZXMgYSBjb2xvciB2YWx1ZSBmcm9tIHJlZCwgZ3JlZW4sIGFuZCBibHVlIGNvbXBvbmVudHMsIHdoaWNoIG11c3QgcmFuZ2UgYmV0d2VlbiAwIGFuZCAyNTUsIGFuZCBhbiBhbHBoYSBjb21wb25lbnQgb2YgMS4gSWYgYW55IGNvbXBvbmVudCBpcyBvdXQgb2YgcmFuZ2UsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiQ29sb3JcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJnYmE6IHtcblx0XHRcdGRvYzogXCJDcmVhdGVzIGEgY29sb3IgdmFsdWUgZnJvbSByZWQsIGdyZWVuLCBibHVlIGNvbXBvbmVudHMsIHdoaWNoIG11c3QgcmFuZ2UgYmV0d2VlbiAwIGFuZCAyNTUsIGFuZCBhbiBhbHBoYSBjb21wb25lbnQgd2hpY2ggbXVzdCByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuIElmIGFueSBjb21wb25lbnQgaXMgb3V0IG9mIHJhbmdlLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcblx0XHRcdGdyb3VwOiBcIkNvbG9yXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXQ6IHtcblx0XHRcdGRvYzogXCJSZXRyaWV2ZXMgYSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IGZlYXR1cmUncyBwcm9wZXJ0aWVzLCBvciBmcm9tIGFub3RoZXIgb2JqZWN0IGlmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLiBSZXR1cm5zIG51bGwgaWYgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSBpcyBtaXNzaW5nLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoYXM6IHtcblx0XHRcdGRvYzogXCJUZXN0cyBmb3IgdGhlIHByZXNlbmNlIG9mIGFuIHByb3BlcnR5IHZhbHVlIGluIHRoZSBjdXJyZW50IGZlYXR1cmUncyBwcm9wZXJ0aWVzLCBvciBmcm9tIGFub3RoZXIgb2JqZWN0IGlmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsZW5ndGg6IHtcblx0XHRcdGRvYzogXCJHZXRzIHRoZSBsZW5ndGggb2YgYW4gYXJyYXkgb3Igc3RyaW5nLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRwcm9wZXJ0aWVzOiB7XG5cdFx0XHRkb2M6IFwiR2V0cyB0aGUgZmVhdHVyZSBwcm9wZXJ0aWVzIG9iamVjdC4gIE5vdGUgdGhhdCBpbiBzb21lIGNhc2VzLCBpdCBtYXkgYmUgbW9yZSBlZmZpY2llbnQgdG8gdXNlIFtcXFwiZ2V0XFxcIiwgXFxcInByb3BlcnR5X25hbWVcXFwiXSBkaXJlY3RseS5cIixcblx0XHRcdGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJmZWF0dXJlLXN0YXRlXCI6IHtcblx0XHRcdGRvYzogXCJSZXRyaWV2ZXMgYSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IGZlYXR1cmUncyBzdGF0ZS4gUmV0dXJucyBudWxsIGlmIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgb24gdGhlIGZlYXR1cmUncyBzdGF0ZS4gQSBmZWF0dXJlJ3Mgc3RhdGUgaXMgbm90IHBhcnQgb2YgdGhlIEdlb0pTT04gb3IgdmVjdG9yIHRpbGUgZGF0YSwgYW5kIG11c3QgYmUgc2V0IHByb2dyYW1tYXRpY2FsbHkgb24gZWFjaCBmZWF0dXJlLiBGZWF0dXJlcyBhcmUgaWRlbnRpZmllZCBieSB0aGVpciBgaWRgIGF0dHJpYnV0ZSwgd2hpY2ggbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIGEgc3RyaW5nIHRoYXQgY2FuIGJlIGNhc3QgdG8gYW4gaW50ZWdlci4gTm90ZSB0aGF0IFtcXFwiZmVhdHVyZS1zdGF0ZVxcXCJdIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBwYWludCBwcm9wZXJ0aWVzIHRoYXQgc3VwcG9ydCBkYXRhLWRyaXZlbiBzdHlsaW5nLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ2LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImdlb21ldHJ5LXR5cGVcIjoge1xuXHRcdFx0ZG9jOiBcIkdldHMgdGhlIGZlYXR1cmUncyBnZW9tZXRyeSB0eXBlOiBQb2ludCwgTXVsdGlQb2ludCwgTGluZVN0cmluZywgTXVsdGlMaW5lU3RyaW5nLCBQb2x5Z29uLCBNdWx0aVBvbHlnb24uXCIsXG5cdFx0XHRncm91cDogXCJGZWF0dXJlIGRhdGFcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGlkOiB7XG5cdFx0XHRkb2M6IFwiR2V0cyB0aGUgZmVhdHVyZSdzIGlkLCBpZiBpdCBoYXMgb25lLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR6b29tOiB7XG5cdFx0XHRkb2M6IFwiR2V0cyB0aGUgY3VycmVudCB6b29tIGxldmVsLiAgTm90ZSB0aGF0IGluIHN0eWxlIGxheW91dCBhbmQgcGFpbnQgcHJvcGVydGllcywgW1xcXCJ6b29tXFxcIl0gbWF5IG9ubHkgYXBwZWFyIGFzIHRoZSBpbnB1dCB0byBhIHRvcC1sZXZlbCBcXFwic3RlcFxcXCIgb3IgXFxcImludGVycG9sYXRlXFxcIiBleHByZXNzaW9uLlwiLFxuXHRcdFx0Z3JvdXA6IFwiWm9vbVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJoZWF0bWFwLWRlbnNpdHlcIjoge1xuXHRcdFx0ZG9jOiBcIkdldHMgdGhlIGtlcm5lbCBkZW5zaXR5IGVzdGltYXRpb24gb2YgYSBwaXhlbCBpbiBhIGhlYXRtYXAgbGF5ZXIsIHdoaWNoIGlzIGEgcmVsYXRpdmUgbWVhc3VyZSBvZiBob3cgbWFueSBkYXRhIHBvaW50cyBhcmUgY3Jvd2RlZCBhcm91bmQgYSBwYXJ0aWN1bGFyIHBpeGVsLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgaGVhdG1hcC1jb2xvcmAgcHJvcGVydHkuXCIsXG5cdFx0XHRncm91cDogXCJIZWF0bWFwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImxpbmUtcHJvZ3Jlc3NcIjoge1xuXHRcdFx0ZG9jOiBcIkdldHMgdGhlIHByb2dyZXNzIGFsb25nIGEgZ3JhZGllbnQgbGluZS4gQ2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgYGxpbmUtZ3JhZGllbnRgIHByb3BlcnR5LlwiLFxuXHRcdFx0Z3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuNi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xMi4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YWNjdW11bGF0ZWQ6IHtcblx0XHRcdGRvYzogXCJHZXRzIHRoZSB2YWx1ZSBvZiBhIGNsdXN0ZXIgcHJvcGVydHkgYWNjdW11bGF0ZWQgc28gZmFyLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgY2x1c3RlclByb3BlcnRpZXNgIG9wdGlvbiBvZiBhIGNsdXN0ZXJlZCBHZW9KU09OIHNvdXJjZS5cIixcblx0XHRcdGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC41My4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIrXCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGlucHV0cy5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiKlwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGUgaW5wdXRzLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCItXCI6IHtcblx0XHRcdGRvYzogXCJGb3IgdHdvIGlucHV0cywgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW5nIHRoZSBzZWNvbmQgaW5wdXQgZnJvbSB0aGUgZmlyc3QuIEZvciBhIHNpbmdsZSBpbnB1dCwgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW5nIGl0IGZyb20gMC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiL1wiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgcmVzdWx0IG9mIGZsb2F0aW5nIHBvaW50IGRpdmlzaW9uIG9mIHRoZSBmaXJzdCBpbnB1dCBieSB0aGUgc2Vjb25kLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIlXCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSByZW1haW5kZXIgYWZ0ZXIgaW50ZWdlciBkaXZpc2lvbiBvZiB0aGUgZmlyc3QgaW5wdXQgYnkgdGhlIHNlY29uZC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiXlwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgcmVzdWx0IG9mIHJhaXNpbmcgdGhlIGZpcnN0IGlucHV0IHRvIHRoZSBwb3dlciBzcGVjaWZpZWQgYnkgdGhlIHNlY29uZC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNxcnQ6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQyLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsb2cxMDoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGJhc2UtdGVuIGxvZ2FyaXRobSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsbjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGxvZzI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBiYXNlLXR3byBsb2dhcml0aG0gb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2luOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgc2luZSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjb3M6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBjb3NpbmUgb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dGFuOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgdGFuZ2VudCBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhc2luOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgYXJjc2luZSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhY29zOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgYXJjY29zaW5lIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGF0YW46IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBhcmN0YW5nZW50IG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG1pbjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIGlucHV0cy5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG1heDoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIGlucHV0cy5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJvdW5kOiB7XG5cdFx0XHRkb2M6IFwiUm91bmRzIHRoZSBpbnB1dCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLiBIYWxmd2F5IHZhbHVlcyBhcmUgcm91bmRlZCBhd2F5IGZyb20gemVyby4gRm9yIGV4YW1wbGUsIGBbXFxcInJvdW5kXFxcIiwgLTEuNV1gIGV2YWx1YXRlcyB0byAtMi5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFiczoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNlaWw6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBzbWFsbGVzdCBpbnRlZ2VyIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGZsb29yOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiPT1cIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGNvbXBhcmlzb24gaXMgc3RyaWN0bHkgdHlwZWQ6IHZhbHVlcyBvZiBkaWZmZXJlbnQgcnVudGltZSB0eXBlcyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQgdW5lcXVhbC4gQ2FzZXMgd2hlcmUgdGhlIHR5cGVzIGFyZSBrbm93biB0byBiZSBkaWZmZXJlbnQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbnZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29sbGF0b3I6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIiE9XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSBub3QgZXF1YWwsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgY29tcGFyaXNvbiBpcyBzdHJpY3RseSB0eXBlZDogdmFsdWVzIG9mIGRpZmZlcmVudCBydW50aW1lIHR5cGVzIGFyZSBhbHdheXMgY29uc2lkZXJlZCB1bmVxdWFsLiBDYXNlcyB3aGVyZSB0aGUgdHlwZXMgYXJlIGtub3duIHRvIGJlIGRpZmZlcmVudCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGludmFsaWQgYW5kIHdpbGwgcHJvZHVjZSBhIHBhcnNlIGVycm9yLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGBjb2xsYXRvcmAgYXJndW1lbnQgdG8gY29udHJvbCBsb2NhbGUtZGVwZW5kZW50IHN0cmluZyBjb21wYXJpc29ucy5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb2xsYXRvcjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4yLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiPlwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI8XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgc3RyaWN0bHkgbGVzcyB0aGFuIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29sbGF0b3I6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIj49XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29sbGF0b3I6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjw9XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29sbGF0b3I6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbGw6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiBhbGwgdGhlIGlucHV0cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGlucHV0cyBhcmUgZXZhbHVhdGVkIGluIG9yZGVyLCBhbmQgZXZhbHVhdGlvbiBpcyBzaG9ydC1jaXJjdWl0aW5nOiBvbmNlIGFuIGlucHV0IGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGBmYWxzZWAsIHRoZSByZXN1bHQgaXMgYGZhbHNlYCBhbmQgbm8gZnVydGhlciBpbnB1dCBleHByZXNzaW9ucyBhcmUgZXZhbHVhdGVkLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFueToge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIGFueSBvZiB0aGUgaW5wdXRzIGFyZSBgdHJ1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgaW5wdXRzIGFyZSBldmFsdWF0ZWQgaW4gb3JkZXIsIGFuZCBldmFsdWF0aW9uIGlzIHNob3J0LWNpcmN1aXRpbmc6IG9uY2UgYW4gaW5wdXQgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYHRydWVgLCB0aGUgcmVzdWx0IGlzIGB0cnVlYCBhbmQgbm8gZnVydGhlciBpbnB1dCBleHByZXNzaW9ucyBhcmUgZXZhbHVhdGVkLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiIVwiOiB7XG5cdFx0XHRkb2M6IFwiTG9naWNhbCBuZWdhdGlvbi4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IGlzIGBmYWxzZWAsIGFuZCBgZmFsc2VgIGlmIHRoZSBpbnB1dCBpcyBgdHJ1ZWAuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0d2l0aGluOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZlYXR1cmUgYmVpbmcgZXZhbHVhdGVkIGlzIGluc2lkZSB0aGUgcHJlLWRlZmluZWQgZ2VvbWV0cnkgYm91bmRhcnksIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgZXhwcmVzc2lvbiBoYXMgb25lIGFyZ3VtZW50IHdoaWNoIG11c3QgYmUgYSB2YWxpZCBHZW9KU09OIFBvbHlnb24vTXVsdGktUG9seWdvbiBvYmplY3QuIFRoZSBleHByZXNzaW9uIG9ubHkgZXZhbHVhdGVzIG9uIGBQb2ludGAgb3IgYExpbmVTdHJpbmdgIGZlYXR1cmUuIEZvciBgUG9pbnRgIGZlYXR1cmUsIFRoZSBleHByZXNzaW9uIHdpbGwgcmV0dXJuIGZhbHNlIGlmIGFueSBwb2ludCBvZiB0aGUgZmVhdHVyZSBpcyBvbiB0aGUgYm91bmRhcnkgb3Igb3V0c2lkZSB0aGUgYm91bmRhcnkuIEZvciBgTGluZVN0cmluZ2AgZmVhdHVyZSwgdGhlIGV4cHJlc3Npb24gd2lsbCByZXR1cm4gZmFsc2UgaWYgdGhlIGxpbmUgaXMgZnVsbHkgb3V0c2lkZSB0aGUgYm91bmRhcnksIG9yIHRoZSBsaW5lIGlzIHBhcnRpYWxseSBpbnRlcnNlY3RpbmcgdGhlIGJvdW5kYXJ5LCB3aGljaCBtZWFucyBlaXRoZXIgcGFydCBvZiB0aGUgbGluZSBpcyBvdXRzaWRlIG9mIHRoZSBib3VuZGFyeSwgb3IgZW5kIHBvaW50IG9mIHRoZSBsaW5lIGxpZXMgb24gdGhlIGJvdW5kYXJ5LlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjEuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJpcy1zdXBwb3J0ZWQtc2NyaXB0XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5wdXQgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIHJlbmRlciBsZWdpYmx5LiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGlucHV0IHN0cmluZyBjb250YWlucyBzZWN0aW9ucyB0aGF0IGNhbm5vdCBiZSByZW5kZXJlZCB3aXRob3V0IHBvdGVudGlhbCBsb3NzIG9mIG1lYW5pbmcgKGUuZy4gSW5kaWMgc2NyaXB0cyB0aGF0IHJlcXVpcmUgY29tcGxleCB0ZXh0IHNoYXBpbmcsIG9yIHJpZ2h0LXRvLWxlZnQgc2NyaXB0cyBpZiB0aGUgdGhlIGBtYXBib3gtZ2wtcnRsLXRleHRgIHBsdWdpbiBpcyBub3QgaW4gdXNlIGluIE1hcGJveCBHTCBKUykuXCIsXG5cdFx0XHRncm91cDogXCJTdHJpbmdcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi42LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR1cGNhc2U6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBpbnB1dCBzdHJpbmcgY29udmVydGVkIHRvIHVwcGVyY2FzZS4gRm9sbG93cyB0aGUgVW5pY29kZSBEZWZhdWx0IENhc2UgQ29udmVyc2lvbiBhbGdvcml0aG0gYW5kIHRoZSBsb2NhbGUtaW5zZW5zaXRpdmUgY2FzZSBtYXBwaW5ncyBpbiB0aGUgVW5pY29kZSBDaGFyYWN0ZXIgRGF0YWJhc2UuXCIsXG5cdFx0XHRncm91cDogXCJTdHJpbmdcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvd25jYXNlOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgaW5wdXQgc3RyaW5nIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UuIEZvbGxvd3MgdGhlIFVuaWNvZGUgRGVmYXVsdCBDYXNlIENvbnZlcnNpb24gYWxnb3JpdGhtIGFuZCB0aGUgbG9jYWxlLWluc2Vuc2l0aXZlIGNhc2UgbWFwcGluZ3MgaW4gdGhlIFVuaWNvZGUgQ2hhcmFjdGVyIERhdGFiYXNlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiU3RyaW5nXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjb25jYXQ6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGEgYHN0cmluZ2AgY29uc2lzdGluZyBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgaW5wdXRzLiBFYWNoIGlucHV0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBhcyBpZiBieSBgdG8tc3RyaW5nYC5cIixcblx0XHRcdGdyb3VwOiBcIlN0cmluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJyZXNvbHZlZC1sb2NhbGVcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIElFVEYgbGFuZ3VhZ2UgdGFnIG9mIHRoZSBsb2NhbGUgYmVpbmcgdXNlZCBieSB0aGUgcHJvdmlkZWQgYGNvbGxhdG9yYC4gVGhpcyBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgc3lzdGVtIGxvY2FsZSwgb3IgdG8gZGV0ZXJtaW5lIGlmIGEgcmVxdWVzdGVkIGxvY2FsZSB3YXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cIixcblx0XHRcdGdyb3VwOiBcIlN0cmluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2xpY2U6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGEgcG9ydGlvbiBvZiBhIHN0cmluZyBvciBhbiBhcnJheSBzdGFydGluZyBmcm9tIHRoZSBwcm92aWRlZCBiZWdpbm5pbmcgaW5kZXguIElmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB0aGVuIHRoZSByZXR1cm4gcG9ydGlvbiB3aWxsIHJ1biB0bywgYnV0IG5vdCBpbmNsdWRlLCB0aGUgZW5kIGluZGV4LlwiLFxuXHRcdFx0Z3JvdXA6IFwiU3RyaW5nXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjEwLjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xudmFyIGxpZ2h0ID0ge1xuXHRhbmNob3I6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHRcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSBpcyBhbGlnbmVkIHRvIHRoZSByb3RhdGlvbiBvZiB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBwb3NpdGlvbiBvZiB0aGUgbGlnaHQgc291cmNlIGlzIGFsaWduZWQgdG8gdGhlIHJvdGF0aW9uIG9mIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuXHRcdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRkb2M6IFwiV2hldGhlciBleHRydWRlZCBnZW9tZXRyaWVzIGFyZSBsaXQgcmVsYXRpdmUgdG8gdGhlIG1hcCBvciB2aWV3cG9ydC5cIixcblx0XHRleGFtcGxlOiBcIm1hcFwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHBvc2l0aW9uOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQxLjE1LFxuXHRcdFx0MjEwLFxuXHRcdFx0MzBcblx0XHRdLFxuXHRcdGxlbmd0aDogMyxcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRkb2M6IFwiUG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSByZWxhdGl2ZSB0byBsaXQgKGV4dHJ1ZGVkKSBnZW9tZXRyaWVzLCBpbiBbciByYWRpYWwgY29vcmRpbmF0ZSwgYSBhemltdXRoYWwgYW5nbGUsIHAgcG9sYXIgYW5nbGVdIHdoZXJlIHIgaW5kaWNhdGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGJhc2Ugb2YgYW4gb2JqZWN0IHRvIGl0cyBsaWdodCwgYSBpbmRpY2F0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCByZWxhdGl2ZSB0byAwwrAgKDDCsCB3aGVuIGBsaWdodC5hbmNob3JgIGlzIHNldCB0byBgdmlld3BvcnRgIGNvcnJlc3BvbmRzIHRvIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0LCBvciAwwrAgd2hlbiBgbGlnaHQuYW5jaG9yYCBpcyBzZXQgdG8gYG1hcGAgY29ycmVzcG9uZHMgdG8gZHVlIG5vcnRoLCBhbmQgZGVncmVlcyBwcm9jZWVkIGNsb2Nrd2lzZSksIGFuZCBwIGluZGljYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBsaWdodCAoZnJvbSAwwrAsIGRpcmVjdGx5IGFib3ZlLCB0byAxODDCsCwgZGlyZWN0bHkgYmVsb3cpLlwiLFxuXHRcdGV4YW1wbGU6IFtcblx0XHRcdDEuNSxcblx0XHRcdDkwLFxuXHRcdFx0ODBcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGNvbG9yOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcblx0XHRcImRlZmF1bHRcIjogXCIjZmZmZmZmXCIsXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiQ29sb3IgdGludCBmb3IgbGlnaHRpbmcgZXh0cnVkZWQgZ2VvbWV0cmllcy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRpbnRlbnNpdHk6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcblx0XHRcImRlZmF1bHRcIjogMC41LFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJJbnRlbnNpdHkgb2YgbGlnaHRpbmcgKG9uIGEgc2NhbGUgZnJvbSAwIHRvIDEpLiBIaWdoZXIgbnVtYmVycyB3aWxsIHByZXNlbnQgYXMgbW9yZSBleHRyZW1lIGNvbnRyYXN0LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG52YXIgcGFpbnQgPSBbXG5cdFwicGFpbnRfZmlsbFwiLFxuXHRcInBhaW50X2xpbmVcIixcblx0XCJwYWludF9jaXJjbGVcIixcblx0XCJwYWludF9oZWF0bWFwXCIsXG5cdFwicGFpbnRfZmlsbC1leHRydXNpb25cIixcblx0XCJwYWludF9zeW1ib2xcIixcblx0XCJwYWludF9yYXN0ZXJcIixcblx0XCJwYWludF9oaWxsc2hhZGVcIixcblx0XCJwYWludF9iYWNrZ3JvdW5kXCJcbl07XG52YXIgcGFpbnRfZmlsbCA9IHtcblx0XCJmaWxsLWFudGlhbGlhc1wiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IHRydWUsXG5cdFx0ZG9jOiBcIldoZXRoZXIgb3Igbm90IHRoZSBmaWxsIHNob3VsZCBiZSBhbnRpYWxpYXNlZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiZmlsbC1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIGVudGlyZSBmaWxsIGxheWVyLiBJbiBjb250cmFzdCB0byB0aGUgYGZpbGwtY29sb3JgLCB0aGlzIHZhbHVlIHdpbGwgYWxzbyBhZmZlY3QgdGhlIDFweCBzdHJva2UgYXJvdW5kIHRoZSBmaWxsLCBpZiB0aGUgc3Ryb2tlIGlzIHVzZWQuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImZpbGwtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciBvZiB0aGUgZmlsbGVkIHBhcnQgb2YgdGhpcyBsYXllci4gVGhpcyBjb2xvciBjYW4gYmUgc3BlY2lmaWVkIGFzIGByZ2JhYCB3aXRoIGFuIGFscGhhIGNvbXBvbmVudCBhbmQgdGhlIGNvbG9yJ3Mgb3BhY2l0eSB3aWxsIG5vdCBhZmZlY3QgdGhlIG9wYWNpdHkgb2YgdGhlIDFweCBzdHJva2UsIGlmIGl0IGlzIHVzZWQuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJmaWxsLXBhdHRlcm5cIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJmaWxsLW91dGxpbmUtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRkb2M6IFwiVGhlIG91dGxpbmUgY29sb3Igb2YgdGhlIGZpbGwuIE1hdGNoZXMgdGhlIHZhbHVlIG9mIGBmaWxsLWNvbG9yYCBpZiB1bnNwZWNpZmllZC5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcImZpbGwtcGF0dGVyblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRcImZpbGwtYW50aWFsaWFzXCI6IHRydWVcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjE5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiZmlsbC10cmFuc2xhdGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBmaWxsIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgZmlsbCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBmaWxsLXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiZmlsbC10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImZpbGwtcGF0dGVyblwiOiB7XG5cdFx0dHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGZpbGxzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40OS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMS4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcblx0fVxufTtcbnZhciBwYWludF9saW5lID0ge1xuXHRcImxpbmUtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRkb2M6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLXRyYW5zbGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogMixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwibGluZS10cmFuc2xhdGUtYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxpbmUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsaW5lIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiQ29udHJvbHMgdGhlIGZyYW1lIG9mIHJlZmVyZW5jZSBmb3IgYGxpbmUtdHJhbnNsYXRlYC5cIixcblx0XHRcImRlZmF1bHRcIjogXCJtYXBcIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJsaW5lLXRyYW5zbGF0ZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwibGluZS13aWR0aFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlN0cm9rZSB0aGlja25lc3MuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLWdhcC13aWR0aFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdGRvYzogXCJEcmF3cyBhIGxpbmUgY2FzaW5nIG91dHNpZGUgb2YgYSBsaW5lJ3MgYWN0dWFsIHBhdGguIFZhbHVlIGluZGljYXRlcyB0aGUgd2lkdGggb2YgdGhlIGlubmVyIGdhcC5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS1vZmZzZXRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0ZG9jOiBcIlRoZSBsaW5lJ3Mgb2Zmc2V0LiBGb3IgbGluZWFyIGZlYXR1cmVzLCBhIHBvc2l0aXZlIHZhbHVlIG9mZnNldHMgdGhlIGxpbmUgdG8gdGhlIHJpZ2h0LCByZWxhdGl2ZSB0byB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lLCBhbmQgYSBuZWdhdGl2ZSB2YWx1ZSB0byB0aGUgbGVmdC4gRm9yIHBvbHlnb24gZmVhdHVyZXMsIGEgcG9zaXRpdmUgdmFsdWUgcmVzdWx0cyBpbiBhbiBpbnNldCwgYW5kIGEgbmVnYXRpdmUgdmFsdWUgcmVzdWx0cyBpbiBhbiBvdXRzZXQuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTIuMVwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjMuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjEuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtYmx1clwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIkJsdXIgYXBwbGllZCB0byB0aGUgbGluZSwgaW4gcGl4ZWxzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS1kYXNoYXJyYXlcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiU3BlY2lmaWVzIHRoZSBsZW5ndGhzIG9mIHRoZSBhbHRlcm5hdGluZyBkYXNoZXMgYW5kIGdhcHMgdGhhdCBmb3JtIHRoZSBkYXNoIHBhdHRlcm4uIFRoZSBsZW5ndGhzIGFyZSBsYXRlciBzY2FsZWQgYnkgdGhlIGxpbmUgd2lkdGguIFRvIGNvbnZlcnQgYSBkYXNoIGxlbmd0aCB0byBwaXhlbHMsIG11bHRpcGx5IHRoZSBsZW5ndGggYnkgdGhlIGN1cnJlbnQgbGluZSB3aWR0aC4gTm90ZSB0aGF0IEdlb0pTT04gc291cmNlcyB3aXRoIGBsaW5lTWV0cmljczogdHJ1ZWAgc3BlY2lmaWVkIHdvbid0IHJlbmRlciBkYXNoZWQgbGluZXMgdG8gdGhlIGV4cGVjdGVkIHNjYWxlLiBBbHNvIG5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcImxpbmUgd2lkdGhzXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkXCJcblx0fSxcblx0XCJsaW5lLXBhdHRlcm5cIjoge1xuXHRcdHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBsaW5lcy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLiBOb3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQ5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjExLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtZ3JhZGllbnRcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRkb2M6IFwiRGVmaW5lcyBhIGdyYWRpZW50IHdpdGggd2hpY2ggdG8gY29sb3IgYSBsaW5lIGZlYXR1cmUuIENhbiBvbmx5IGJlIHVzZWQgd2l0aCBHZW9KU09OIHNvdXJjZXMgdGhhdCBzcGVjaWZ5IGBcXFwibGluZU1ldHJpY3NcXFwiOiB0cnVlYC5cIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJsaW5lLWRhc2hhcnJheVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0c291cmNlOiBcImdlb2pzb25cIixcblx0XHRcdFx0aGFzOiB7XG5cdFx0XHRcdFx0bGluZU1ldHJpY3M6IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC40LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcImxpbmUtcHJvZ3Jlc3NcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG5cdH1cbn07XG52YXIgcGFpbnRfY2lyY2xlID0ge1xuXHRcImNpcmNsZS1yYWRpdXNcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDUsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJDaXJjbGUgcmFkaXVzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjE4LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiY2lyY2xlLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdGRvYzogXCJUaGUgZmlsbCBjb2xvciBvZiB0aGUgY2lyY2xlLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTguMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJjaXJjbGUtYmx1clwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiQW1vdW50IHRvIGJsdXIgdGhlIGNpcmNsZS4gMSBibHVycyB0aGUgY2lyY2xlIHN1Y2ggdGhhdCBvbmx5IHRoZSBjZW50ZXJwb2ludCBpcyBmdWxsIG9wYWNpdHkuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImNpcmNsZS1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgY2lyY2xlIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJjaXJjbGUtdHJhbnNsYXRlXCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MFxuXHRcdF0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBjaXJjbGUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBjaXJjbGUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgY2lyY2xlLXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiY2lyY2xlLXRyYW5zbGF0ZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiQ2lyY2xlcyBhcmUgc2NhbGVkIGFjY29yZGluZyB0byB0aGVpciBhcHBhcmVudCBkaXN0YW5jZSB0byB0aGUgY2FtZXJhLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIkNpcmNsZXMgYXJlIG5vdCBzY2FsZWQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgc2NhbGluZyBiZWhhdmlvciBvZiB0aGUgY2lyY2xlIHdoZW4gdGhlIG1hcCBpcyBwaXRjaGVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMi4xXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGNpcmNsZSBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBjaXJjbGUgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuXHRcdGRvYzogXCJPcmllbnRhdGlvbiBvZiBjaXJjbGUgd2hlbiBtYXAgaXMgcGl0Y2hlZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSB3aWR0aCBvZiB0aGUgY2lyY2xlJ3Mgc3Ryb2tlLiBTdHJva2VzIGFyZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgYGNpcmNsZS1yYWRpdXNgLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiY2lyY2xlLXN0cm9rZS1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgY2lyY2xlLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBjaXJjbGUncyBzdHJva2UuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fVxufTtcbnZhciBwYWludF9oZWF0bWFwID0ge1xuXHRcImhlYXRtYXAtcmFkaXVzXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAzMCxcblx0XHRtaW5pbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlJhZGl1cyBvZiBpbmZsdWVuY2Ugb2Ygb25lIGhlYXRtYXAgcG9pbnQgaW4gcGl4ZWxzLiBJbmNyZWFzaW5nIHRoZSB2YWx1ZSBtYWtlcyB0aGUgaGVhdG1hcCBzbW9vdGhlciwgYnV0IGxlc3MgZGV0YWlsZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJoZWF0bWFwLXdlaWdodFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcdGRvYzogXCJBIG1lYXN1cmUgb2YgaG93IG11Y2ggYW4gaW5kaXZpZHVhbCBwb2ludCBjb250cmlidXRlcyB0byB0aGUgaGVhdG1hcC4gQSB2YWx1ZSBvZiAxMCB3b3VsZCBiZSBlcXVpdmFsZW50IHRvIGhhdmluZyAxMCBwb2ludHMgb2Ygd2VpZ2h0IDEgaW4gdGhlIHNhbWUgc3BvdC4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiBjb21iaW5lZCB3aXRoIGNsdXN0ZXJpbmcuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJoZWF0bWFwLWludGVuc2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIlNpbWlsYXIgdG8gYGhlYXRtYXAtd2VpZ2h0YCBidXQgY29udHJvbHMgdGhlIGludGVuc2l0eSBvZiB0aGUgaGVhdG1hcCBnbG9iYWxseS4gUHJpbWFyaWx5IHVzZWQgZm9yIGFkanVzdGluZyB0aGUgaGVhdG1hcCBiYXNlZCBvbiB6b29tIGxldmVsLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImhlYXRtYXAtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0XCJpbnRlcnBvbGF0ZVwiLFxuXHRcdFx0W1xuXHRcdFx0XHRcImxpbmVhclwiXG5cdFx0XHRdLFxuXHRcdFx0W1xuXHRcdFx0XHRcImhlYXRtYXAtZGVuc2l0eVwiXG5cdFx0XHRdLFxuXHRcdFx0MCxcblx0XHRcdFwicmdiYSgwLCAwLCAyNTUsIDApXCIsXG5cdFx0XHQwLjEsXG5cdFx0XHRcInJveWFsYmx1ZVwiLFxuXHRcdFx0MC4zLFxuXHRcdFx0XCJjeWFuXCIsXG5cdFx0XHQwLjUsXG5cdFx0XHRcImxpbWVcIixcblx0XHRcdDAuNyxcblx0XHRcdFwieWVsbG93XCIsXG5cdFx0XHQxLFxuXHRcdFx0XCJyZWRcIlxuXHRcdF0sXG5cdFx0ZG9jOiBcIkRlZmluZXMgdGhlIGNvbG9yIG9mIGVhY2ggcGl4ZWwgYmFzZWQgb24gaXRzIGRlbnNpdHkgdmFsdWUgaW4gYSBoZWF0bWFwLiAgU2hvdWxkIGJlIGFuIGV4cHJlc3Npb24gdGhhdCB1c2VzIGBbXFxcImhlYXRtYXAtZGVuc2l0eVxcXCJdYCBhcyBpbnB1dC5cIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJoZWF0bWFwLWRlbnNpdHlcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG5cdH0sXG5cdFwiaGVhdG1hcC1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJUaGUgZ2xvYmFsIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGhlYXRtYXAgbGF5ZXIgd2lsbCBiZSBkcmF3bi5cIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fVxufTtcbnZhciBwYWludF9zeW1ib2wgPSB7XG5cdFwiaWNvbi1vcGFjaXR5XCI6IHtcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGljb24gd2lsbCBiZSBkcmF3bi5cIixcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciBvZiB0aGUgaWNvbi4gVGhpcyBjYW4gb25seSBiZSB1c2VkIHdpdGggc2RmIGljb25zLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLWhhbG8tY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uJ3MgaGFsby4gSWNvbiBoYWxvcyBjYW4gb25seSBiZSB1c2VkIHdpdGggU0RGIGljb25zLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLWhhbG8td2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBpY29uIG91dGxpbmUuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24taGFsby1ibHVyXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiRmFkZSBvdXQgdGhlIGhhbG8gdG93YXJkcyB0aGUgb3V0c2lkZS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi10cmFuc2xhdGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJEaXN0YW5jZSB0aGF0IHRoZSBpY29uJ3MgYW5jaG9yIGlzIG1vdmVkIGZyb20gaXRzIG9yaWdpbmFsIHBsYWNlbWVudC4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJJY29ucyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIkljb25zIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBpY29uLXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiLFxuXHRcdFx0XCJpY29uLXRyYW5zbGF0ZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0b3ZlcnJpZGFibGU6IHRydWUsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtaGFsby1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIHRleHQncyBoYWxvLCB3aGljaCBoZWxwcyBpdCBzdGFuZCBvdXQgZnJvbSBiYWNrZ3JvdW5kcy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1oYWxvLXdpZHRoXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgZm9udCBvdXRsaW5lLiBNYXggdGV4dCBoYWxvIHdpZHRoIGlzIDEvNCBvZiB0aGUgZm9udC1zaXplLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LWhhbG8tYmx1clwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBoYWxvJ3MgZmFkZW91dCBkaXN0YW5jZSB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LXRyYW5zbGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogMixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIkRpc3RhbmNlIHRoYXQgdGhlIHRleHQncyBhbmNob3IgaXMgbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcGxhY2VtZW50LiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGB0ZXh0LXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0XCJ0ZXh0LXRyYW5zbGF0ZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH1cbn07XG52YXIgcGFpbnRfcmFzdGVyID0ge1xuXHRcInJhc3Rlci1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItaHVlLXJvdGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRwZXJpb2Q6IDM2MCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcImRlZ3JlZXNcIixcblx0XHRkb2M6IFwiUm90YXRlcyBodWVzIGFyb3VuZCB0aGUgY29sb3Igd2hlZWwuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1pbmltdW0gYnJpZ2h0bmVzcy5cIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgaW1hZ2UuIFRoZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBicmlnaHRuZXNzLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInJhc3Rlci1zYXR1cmF0aW9uXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIHNhdHVyYXRpb24gb2YgdGhlIGltYWdlLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IC0xLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItY29udHJhc3RcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgY29udHJhc3Qgb2YgdGhlIGltYWdlLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IC0xLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItcmVzYW1wbGluZ1wiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0ZG9jOiBcIlRoZSByZXNhbXBsaW5nL2ludGVycG9sYXRpb24gbWV0aG9kIHRvIHVzZSBmb3Igb3ZlcnNjYWxpbmcsIGFsc28ga25vd24gYXMgdGV4dHVyZSBtYWduaWZpY2F0aW9uIGZpbHRlclwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bGluZWFyOiB7XG5cdFx0XHRcdGRvYzogXCIoQmkpbGluZWFyIGZpbHRlcmluZyBpbnRlcnBvbGF0ZXMgcGl4ZWwgdmFsdWVzIHVzaW5nIHRoZSB3ZWlnaHRlZCBhdmVyYWdlIG9mIHRoZSBmb3VyIGNsb3Nlc3Qgb3JpZ2luYWwgc291cmNlIHBpeGVscyBjcmVhdGluZyBhIHNtb290aCBidXQgYmx1cnJ5IGxvb2sgd2hlbiBvdmVyc2NhbGVkXCJcblx0XHRcdH0sXG5cdFx0XHRuZWFyZXN0OiB7XG5cdFx0XHRcdGRvYzogXCJOZWFyZXN0IG5laWdoYm9yIGZpbHRlcmluZyBpbnRlcnBvbGF0ZXMgcGl4ZWwgdmFsdWVzIHVzaW5nIHRoZSBuZWFyZXN0IG9yaWdpbmFsIHNvdXJjZSBwaXhlbCBjcmVhdGluZyBhIHNoYXJwIGJ1dCBwaXhlbGF0ZWQgbG9vayB3aGVuIG92ZXJzY2FsZWRcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibGluZWFyXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQ3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjMuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4yLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAzMDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHR1bml0czogXCJtaWxsaXNlY29uZHNcIixcblx0XHRkb2M6IFwiRmFkZSBkdXJhdGlvbiB3aGVuIGEgbmV3IHRpbGUgaXMgYWRkZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH1cbn07XG52YXIgcGFpbnRfaGlsbHNoYWRlID0ge1xuXHRcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tZGlyZWN0aW9uXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAzMzUsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAzNTksXG5cdFx0ZG9jOiBcIlRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBoaWxsc2hhZGluZyB3aXRoIDAgYXMgdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgaWYgYGhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yYCBpcyBzZXQgdG8gYHZpZXdwb3J0YCBhbmQgZHVlIG5vcnRoIGlmIGBoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvcmAgaXMgc2V0IHRvIGBtYXBgLlwiLFxuXHRcdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGhpbGxzaGFkZSBpbGx1bWluYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG5vcnRoIGRpcmVjdGlvbi5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaGlsbHNoYWRlIGlsbHVtaW5hdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcblx0XHRkb2M6IFwiRGlyZWN0aW9uIG9mIGxpZ2h0IHNvdXJjZSB3aGVuIG1hcCBpcyByb3RhdGVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJJbnRlbnNpdHkgb2YgdGhlIGhpbGxzaGFkZVwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLjUsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaGlsbHNoYWRlLXNoYWRvdy1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIHNoYWRpbmcgY29sb3Igb2YgYXJlYXMgdGhhdCBmYWNlIGF3YXkgZnJvbSB0aGUgbGlnaHQgc291cmNlLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaGlsbHNoYWRlLWhpZ2hsaWdodC1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiNGRkZGRkZcIixcblx0XHRkb2M6IFwiVGhlIHNoYWRpbmcgY29sb3Igb2YgYXJlYXMgdGhhdCBmYWNlcyB0b3dhcmRzIHRoZSBsaWdodCBzb3VyY2UuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdGRvYzogXCJUaGUgc2hhZGluZyBjb2xvciB1c2VkIHRvIGFjY2VudHVhdGUgcnVnZ2VkIHRlcnJhaW4gbGlrZSBzaGFycCBjbGlmZnMgYW5kIGdvcmdlcy5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIHBhaW50X2JhY2tncm91bmQgPSB7XG5cdFwiYmFja2dyb3VuZC1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcImJhY2tncm91bmQtcGF0dGVyblwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJiYWNrZ3JvdW5kLXBhdHRlcm5cIjoge1xuXHRcdHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBhbiBpbWFnZSBiYWNrZ3JvdW5kLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZFwiXG5cdH0sXG5cdFwiYmFja2dyb3VuZC1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIHRyYW5zaXRpb24gPSB7XG5cdGR1cmF0aW9uOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMzAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwibWlsbGlzZWNvbmRzXCIsXG5cdFx0ZG9jOiBcIlRpbWUgYWxsb3R0ZWQgZm9yIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlLlwiXG5cdH0sXG5cdGRlbGF5OiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcIm1pbGxpc2Vjb25kc1wiLFxuXHRcdGRvYzogXCJMZW5ndGggb2YgdGltZSBiZWZvcmUgYSB0cmFuc2l0aW9uIGJlZ2lucy5cIlxuXHR9XG59O1xudmFyIHByb21vdGVJZCA9IHtcblx0XCIqXCI6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIG5hbWUgb2YgYSBmZWF0dXJlIHByb3BlcnR5IHRvIHVzZSBhcyBJRCBmb3IgZmVhdHVyZSBzdGF0ZS5cIlxuXHR9XG59O1xudmFyIHY4ID0ge1xuXHQkdmVyc2lvbjogJHZlcnNpb24sXG5cdCRyb290OiAkcm9vdCxcblx0c291cmNlczogc291cmNlcyxcblx0c291cmNlOiBzb3VyY2UsXG5cdHNvdXJjZV92ZWN0b3I6IHNvdXJjZV92ZWN0b3IsXG5cdHNvdXJjZV9yYXN0ZXI6IHNvdXJjZV9yYXN0ZXIsXG5cdHNvdXJjZV9yYXN0ZXJfZGVtOiBzb3VyY2VfcmFzdGVyX2RlbSxcblx0c291cmNlX2dlb2pzb246IHNvdXJjZV9nZW9qc29uLFxuXHRzb3VyY2VfdmlkZW86IHNvdXJjZV92aWRlbyxcblx0c291cmNlX2ltYWdlOiBzb3VyY2VfaW1hZ2UsXG5cdGxheWVyOiBsYXllcixcblx0bGF5b3V0OiBsYXlvdXQsXG5cdGxheW91dF9iYWNrZ3JvdW5kOiBsYXlvdXRfYmFja2dyb3VuZCxcblx0bGF5b3V0X2ZpbGw6IGxheW91dF9maWxsLFxuXHRsYXlvdXRfY2lyY2xlOiBsYXlvdXRfY2lyY2xlLFxuXHRsYXlvdXRfaGVhdG1hcDogbGF5b3V0X2hlYXRtYXAsXG5cdFwibGF5b3V0X2ZpbGwtZXh0cnVzaW9uXCI6IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufSxcblx0bGF5b3V0X2xpbmU6IGxheW91dF9saW5lLFxuXHRsYXlvdXRfc3ltYm9sOiBsYXlvdXRfc3ltYm9sLFxuXHRsYXlvdXRfcmFzdGVyOiBsYXlvdXRfcmFzdGVyLFxuXHRsYXlvdXRfaGlsbHNoYWRlOiBsYXlvdXRfaGlsbHNoYWRlLFxuXHRmaWx0ZXI6IGZpbHRlcixcblx0ZmlsdGVyX29wZXJhdG9yOiBmaWx0ZXJfb3BlcmF0b3IsXG5cdGdlb21ldHJ5X3R5cGU6IGdlb21ldHJ5X3R5cGUsXG5cdFwiZnVuY3Rpb25cIjoge1xuXHRleHByZXNzaW9uOiB7XG5cdFx0dHlwZTogXCJleHByZXNzaW9uXCIsXG5cdFx0ZG9jOiBcIkFuIGV4cHJlc3Npb24uXCJcblx0fSxcblx0c3RvcHM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0ZG9jOiBcIkFuIGFycmF5IG9mIHN0b3BzLlwiLFxuXHRcdHZhbHVlOiBcImZ1bmN0aW9uX3N0b3BcIlxuXHR9LFxuXHRiYXNlOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdGRvYzogXCJUaGUgZXhwb25lbnRpYWwgYmFzZSBvZiB0aGUgaW50ZXJwb2xhdGlvbiBjdXJ2ZS4gSXQgY29udHJvbHMgdGhlIHJhdGUgYXQgd2hpY2ggdGhlIHJlc3VsdCBpbmNyZWFzZXMuIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgcmVzdWx0IGluY3JlYXNlIG1vcmUgdG93YXJkcyB0aGUgaGlnaCBlbmQgb2YgdGhlIHJhbmdlLiBXaXRoIGAxYCB0aGUgc3RvcHMgYXJlIGludGVycG9sYXRlZCBsaW5lYXJseS5cIlxuXHR9LFxuXHRwcm9wZXJ0eToge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIlRoZSBuYW1lIG9mIGEgZmVhdHVyZSBwcm9wZXJ0eSB0byB1c2UgYXMgdGhlIGZ1bmN0aW9uIGlucHV0LlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiR6b29tXCJcblx0fSxcblx0dHlwZToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0aWRlbnRpdHk6IHtcblx0XHRcdFx0ZG9jOiBcIlJldHVybiB0aGUgaW5wdXQgdmFsdWUgYXMgdGhlIG91dHB1dCB2YWx1ZS5cIlxuXHRcdFx0fSxcblx0XHRcdGV4cG9uZW50aWFsOiB7XG5cdFx0XHRcdGRvYzogXCJHZW5lcmF0ZSBhbiBvdXRwdXQgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHN0b3BzIGp1c3QgbGVzcyB0aGFuIGFuZCBqdXN0IGdyZWF0ZXIgdGhhbiB0aGUgZnVuY3Rpb24gaW5wdXQuXCJcblx0XHRcdH0sXG5cdFx0XHRpbnRlcnZhbDoge1xuXHRcdFx0XHRkb2M6IFwiUmV0dXJuIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhlIHN0b3AganVzdCBsZXNzIHRoYW4gdGhlIGZ1bmN0aW9uIGlucHV0LlwiXG5cdFx0XHR9LFxuXHRcdFx0Y2F0ZWdvcmljYWw6IHtcblx0XHRcdFx0ZG9jOiBcIlJldHVybiB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoZSBzdG9wIGVxdWFsIHRvIHRoZSBmdW5jdGlvbiBpbnB1dC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBpbnRlcnBvbGF0aW9uIHN0cmF0ZWd5IHRvIHVzZSBpbiBmdW5jdGlvbiBldmFsdWF0aW9uLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcImV4cG9uZW50aWFsXCJcblx0fSxcblx0Y29sb3JTcGFjZToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0cmdiOiB7XG5cdFx0XHRcdGRvYzogXCJVc2UgdGhlIFJHQiBjb2xvciBzcGFjZSB0byBpbnRlcnBvbGF0ZSBjb2xvciB2YWx1ZXNcIlxuXHRcdFx0fSxcblx0XHRcdGxhYjoge1xuXHRcdFx0XHRkb2M6IFwiVXNlIHRoZSBMQUIgY29sb3Igc3BhY2UgdG8gaW50ZXJwb2xhdGUgY29sb3IgdmFsdWVzLlwiXG5cdFx0XHR9LFxuXHRcdFx0aGNsOiB7XG5cdFx0XHRcdGRvYzogXCJVc2UgdGhlIEhDTCBjb2xvciBzcGFjZSB0byBpbnRlcnBvbGF0ZSBjb2xvciB2YWx1ZXMsIGludGVycG9sYXRpbmcgdGhlIEh1ZSwgQ2hyb21hLCBhbmQgTHVtaW5hbmNlIGNoYW5uZWxzIGluZGl2aWR1YWxseS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciBzcGFjZSBpbiB3aGljaCBjb2xvcnMgaW50ZXJwb2xhdGVkLiBJbnRlcnBvbGF0aW5nIGNvbG9ycyBpbiBwZXJjZXB0dWFsIGNvbG9yIHNwYWNlcyBsaWtlIExBQiBhbmQgSENMIHRlbmQgdG8gcHJvZHVjZSBjb2xvciByYW1wcyB0aGF0IGxvb2sgbW9yZSBjb25zaXN0ZW50IGFuZCBwcm9kdWNlIGNvbG9ycyB0aGF0IGNhbiBiZSBkaWZmZXJlbnRpYXRlZCBtb3JlIGVhc2lseSB0aGFuIHRob3NlIGludGVycG9sYXRlZCBpbiBSR0Igc3BhY2UuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwicmdiXCJcblx0fSxcblx0XCJkZWZhdWx0XCI6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRyZXF1aXJlZDogZmFsc2UsXG5cdFx0ZG9jOiBcIkEgdmFsdWUgdG8gc2VydmUgYXMgYSBmYWxsYmFjayBmdW5jdGlvbiByZXN1bHQgd2hlbiBhIHZhbHVlIGlzbid0IG90aGVyd2lzZSBhdmFpbGFibGUuIEl0IGlzIHVzZWQgaW4gdGhlIGZvbGxvd2luZyBjaXJjdW1zdGFuY2VzOlxcbiogSW4gY2F0ZWdvcmljYWwgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgc3RvcCBkb21haW4gdmFsdWVzLlxcbiogSW4gcHJvcGVydHkgYW5kIHpvb20tYW5kLXByb3BlcnR5IGZ1bmN0aW9ucywgd2hlbiBhIGZlYXR1cmUgZG9lcyBub3QgY29udGFpbiBhIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxcbiogSW4gaWRlbnRpdHkgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGlzIG5vdCB2YWxpZCBmb3IgdGhlIHN0eWxlIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgaWYgdGhlIGZ1bmN0aW9uIGlzIGJlaW5nIHVzZWQgZm9yIGEgYGNpcmNsZS1jb2xvcmAgcHJvcGVydHkgYnV0IHRoZSBmZWF0dXJlIHByb3BlcnR5IHZhbHVlIGlzIG5vdCBhIHN0cmluZyBvciBub3QgYSB2YWxpZCBjb2xvcikuXFxuKiBJbiBpbnRlcnZhbCBvciBleHBvbmVudGlhbCBwcm9wZXJ0eSBhbmQgem9vbS1hbmQtcHJvcGVydHkgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGlzIG5vdCBudW1lcmljLlxcbklmIG5vIGRlZmF1bHQgaXMgcHJvdmlkZWQsIHRoZSBzdHlsZSBwcm9wZXJ0eSdzIGRlZmF1bHQgaXMgdXNlZCBpbiB0aGVzZSBjaXJjdW1zdGFuY2VzLlwiXG5cdH1cbn0sXG5cdGZ1bmN0aW9uX3N0b3A6IGZ1bmN0aW9uX3N0b3AsXG5cdGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG5cdGV4cHJlc3Npb25fbmFtZTogZXhwcmVzc2lvbl9uYW1lLFxuXHRsaWdodDogbGlnaHQsXG5cdHBhaW50OiBwYWludCxcblx0cGFpbnRfZmlsbDogcGFpbnRfZmlsbCxcblx0XCJwYWludF9maWxsLWV4dHJ1c2lvblwiOiB7XG5cdFwiZmlsbC1leHRydXNpb24tb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBlbnRpcmUgZmlsbCBleHRydXNpb24gbGF5ZXIuIFRoaXMgaXMgcmVuZGVyZWQgb24gYSBwZXItbGF5ZXIsIG5vdCBwZXItZmVhdHVyZSwgYmFzaXMsIGFuZCBkYXRhLWRyaXZlbiBzdHlsaW5nIGlzIG5vdCBhdmFpbGFibGUuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIGJhc2UgY29sb3Igb2YgdGhlIGV4dHJ1ZGVkIGZpbGwuIFRoZSBleHRydXNpb24ncyBzdXJmYWNlcyB3aWxsIGJlIHNoYWRlZCBkaWZmZXJlbnRseSBiYXNlZCBvbiB0aGlzIGNvbG9yIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIHJvb3QgYGxpZ2h0YCBzZXR0aW5ncy4gSWYgdGhpcyBjb2xvciBpcyBzcGVjaWZpZWQgYXMgYHJnYmFgIHdpdGggYW4gYWxwaGEgY29tcG9uZW50LCB0aGUgYWxwaGEgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZDsgdXNlIGBmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5YCB0byBzZXQgbGF5ZXIgb3BhY2l0eS5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCAob24gdGhlIGZsYXQgcGxhbmUpLCByZXNwZWN0aXZlbHkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBmaWxsIGV4dHJ1c2lvbiBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGZpbGwgZXh0cnVzaW9uIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiQ29udHJvbHMgdGhlIGZyYW1lIG9mIHJlZmVyZW5jZSBmb3IgYGZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCI6IHtcblx0XHR0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2VzIG9uIGV4dHJ1ZGVkIGZpbGxzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40OS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMS4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi1oZWlnaHRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR1bml0czogXCJtZXRlcnNcIixcblx0XHRkb2M6IFwiVGhlIGhlaWdodCB3aXRoIHdoaWNoIHRvIGV4dHJ1ZGUgdGhpcyBsYXllci5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiZmlsbC1leHRydXNpb24tYmFzZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcIm1ldGVyc1wiLFxuXHRcdGRvYzogXCJUaGUgaGVpZ2h0IHdpdGggd2hpY2ggdG8gZXh0cnVkZSB0aGUgYmFzZSBvZiB0aGlzIGxheWVyLiBNdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgZmlsbC1leHRydXNpb24taGVpZ2h0YC5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImZpbGwtZXh0cnVzaW9uLWhlaWdodFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImZpbGwtZXh0cnVzaW9uLXZlcnRpY2FsLWdyYWRpZW50XCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogdHJ1ZSxcblx0XHRkb2M6IFwiV2hldGhlciB0byBhcHBseSBhIHZlcnRpY2FsIGdyYWRpZW50IHRvIHRoZSBzaWRlcyBvZiBhIGZpbGwtZXh0cnVzaW9uIGxheWVyLiBJZiB0cnVlLCBzaWRlcyB3aWxsIGJlIHNoYWRlZCBzbGlnaHRseSBkYXJrZXIgZmFydGhlciBkb3duLlwiLFxuXHRcdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC41MC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEzLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59LFxuXHRwYWludF9saW5lOiBwYWludF9saW5lLFxuXHRwYWludF9jaXJjbGU6IHBhaW50X2NpcmNsZSxcblx0cGFpbnRfaGVhdG1hcDogcGFpbnRfaGVhdG1hcCxcblx0cGFpbnRfc3ltYm9sOiBwYWludF9zeW1ib2wsXG5cdHBhaW50X3Jhc3RlcjogcGFpbnRfcmFzdGVyLFxuXHRwYWludF9oaWxsc2hhZGU6IHBhaW50X2hpbGxzaGFkZSxcblx0cGFpbnRfYmFja2dyb3VuZDogcGFpbnRfYmFja2dyb3VuZCxcblx0dHJhbnNpdGlvbjogdHJhbnNpdGlvbixcblx0XCJwcm9wZXJ0eS10eXBlXCI6IHtcblx0XCJkYXRhLWRyaXZlblwiOiB7XG5cdFx0dHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG5cdFx0ZG9jOiBcIlByb3BlcnR5IGlzIGludGVycG9sYWJsZSBhbmQgY2FuIGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi5cIlxuXHR9LFxuXHRcImNyb3NzLWZhZGVkXCI6IHtcblx0XHR0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcblx0XHRkb2M6IFwiUHJvcGVydHkgaXMgbm9uLWludGVycG9sYWJsZTsgcmF0aGVyLCBpdHMgdmFsdWVzIHdpbGwgYmUgY3Jvc3MtZmFkZWQgdG8gc21vb3RobHkgdHJhbnNpdGlvbiBiZXR3ZWVuIGludGVnZXIgem9vbXMuXCJcblx0fSxcblx0XCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiOiB7XG5cdFx0dHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG5cdFx0ZG9jOiBcIlByb3BlcnR5IGlzIG5vbi1pbnRlcnBvbGFibGU7IHJhdGhlciwgaXRzIHZhbHVlcyB3aWxsIGJlIGNyb3NzLWZhZGVkIHRvIHNtb290aGx5IHRyYW5zaXRpb24gYmV0d2VlbiBpbnRlZ2VyIHpvb21zLiBJdCBjYW4gYmUgcmVwcmVzZW50ZWQgdXNpbmcgYSBwcm9wZXJ0eSBleHByZXNzaW9uLlwiXG5cdH0sXG5cdFwiY29sb3ItcmFtcFwiOiB7XG5cdFx0dHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG5cdFx0ZG9jOiBcIlByb3BlcnR5IHNob3VsZCBiZSBzcGVjaWZpZWQgdXNpbmcgYSBjb2xvciByYW1wIGZyb20gd2hpY2ggdGhlIG91dHB1dCBjb2xvciBjYW4gYmUgc2FtcGxlZCBiYXNlZCBvbiBhIHByb3BlcnR5IGNhbGN1bGF0aW9uLlwiXG5cdH0sXG5cdFwiZGF0YS1jb25zdGFudFwiOiB7XG5cdFx0dHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG5cdFx0ZG9jOiBcIlByb3BlcnR5IGlzIGludGVycG9sYWJsZSBidXQgY2Fubm90IGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi5cIlxuXHR9LFxuXHRjb25zdGFudDoge1xuXHRcdHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuXHRcdGRvYzogXCJQcm9wZXJ0eSBpcyBjb25zdGFudCBhY3Jvc3MgYWxsIHpvb20gbGV2ZWxzIGFuZCBwcm9wZXJ0eSB2YWx1ZXMuXCJcblx0fVxufSxcblx0cHJvbW90ZUlkOiBwcm9tb3RlSWRcbn07XG5cbi8vIE5vdGU6IFRoaXMgcmVnZXggbWF0Y2hlcyBldmVuIGludmFsaWQgSlNPTiBzdHJpbmdzLCBidXQgc2luY2Ugd2XigJlyZVxuLy8gd29ya2luZyBvbiB0aGUgb3V0cHV0IG9mIGBKU09OLnN0cmluZ2lmeWAgd2Uga25vdyB0aGF0IG9ubHkgdmFsaWQgc3RyaW5nc1xuLy8gYXJlIHByZXNlbnQgKHVubGVzcyB0aGUgdXNlciBzdXBwbGllZCBhIHdlaXJkIGBvcHRpb25zLmluZGVudGAgYnV0IGluXG4vLyB0aGF0IGNhc2Ugd2UgZG9u4oCZdCBjYXJlIHNpbmNlIHRoZSBvdXRwdXQgd291bGQgYmUgaW52YWxpZCBhbnl3YXkpLlxudmFyIHN0cmluZ09yQ2hhciA9IC8oXCIoPzpbXlxcXFxcIl18XFxcXC4pKlwiKXxbOixdL2c7XG5cbnZhciBqc29uU3RyaW5naWZ5UHJldHR5Q29tcGFjdCA9IGZ1bmN0aW9uIHN0cmluZ2lmeShwYXNzZWRPYmosIG9wdGlvbnMpIHtcbiAgdmFyIGluZGVudCwgbWF4TGVuZ3RoLCByZXBsYWNlcjtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaW5kZW50ID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgWzFdLFxuICAgIHVuZGVmaW5lZCxcbiAgICBvcHRpb25zLmluZGVudCA9PT0gdW5kZWZpbmVkID8gMiA6IG9wdGlvbnMuaW5kZW50XG4gICkuc2xpY2UoMiwgLTMpO1xuICBtYXhMZW5ndGggPVxuICAgIGluZGVudCA9PT0gXCJcIlxuICAgICAgPyBJbmZpbml0eVxuICAgICAgOiBvcHRpb25zLm1heExlbmd0aCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IDgwXG4gICAgICA6IG9wdGlvbnMubWF4TGVuZ3RoO1xuICByZXBsYWNlciA9IG9wdGlvbnMucmVwbGFjZXI7XG5cbiAgcmV0dXJuIChmdW5jdGlvbiBfc3RyaW5naWZ5KG9iaiwgY3VycmVudEluZGVudCwgcmVzZXJ2ZWQpIHtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICB2YXIgZW5kLCBpbmRleCwgaXRlbXMsIGtleSwga2V5UGFydCwga2V5cywgbGVuZ3RoLCBuZXh0SW5kZW50LCBwcmV0dGlmaWVkLCBzdGFydCwgc3RyaW5nLCB2YWx1ZTtcblxuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgIH1cblxuICAgIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIpO1xuXG4gICAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIGxlbmd0aCA9IG1heExlbmd0aCAtIGN1cnJlbnRJbmRlbnQubGVuZ3RoIC0gcmVzZXJ2ZWQ7XG5cbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgIHByZXR0aWZpZWQgPSBzdHJpbmcucmVwbGFjZShzdHJpbmdPckNoYXIsIGZ1bmN0aW9uKG1hdGNoLCBzdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdMaXRlcmFsIHx8IG1hdGNoICsgXCIgXCI7XG4gICAgICB9KTtcbiAgICAgIGlmIChwcmV0dGlmaWVkLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHByZXR0aWZpZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2VyICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IEpTT04ucGFyc2Uoc3RyaW5nKTtcbiAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgbmV4dEluZGVudCA9IGN1cnJlbnRJbmRlbnQgKyBpbmRlbnQ7XG4gICAgICBpdGVtcyA9IFtdO1xuICAgICAgaW5kZXggPSAwO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHN0YXJ0ID0gXCJbXCI7XG4gICAgICAgIGVuZCA9IFwiXVwiO1xuICAgICAgICBsZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKFxuICAgICAgICAgICAgX3N0cmluZ2lmeShvYmpbaW5kZXhdLCBuZXh0SW5kZW50LCBpbmRleCA9PT0gbGVuZ3RoIC0gMSA/IDAgOiAxKSB8fFxuICAgICAgICAgICAgICBcIm51bGxcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gXCJ7XCI7XG4gICAgICAgIGVuZCA9IFwifVwiO1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICAgIGtleVBhcnQgPSBKU09OLnN0cmluZ2lmeShrZXkpICsgXCI6IFwiO1xuICAgICAgICAgIHZhbHVlID0gX3N0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAgbmV4dEluZGVudCxcbiAgICAgICAgICAgIGtleVBhcnQubGVuZ3RoICsgKGluZGV4ID09PSBsZW5ndGggLSAxID8gMCA6IDEpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChrZXlQYXJ0ICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gW3N0YXJ0LCBpbmRlbnQgKyBpdGVtcy5qb2luKFwiLFxcblwiICsgbmV4dEluZGVudCksIGVuZF0uam9pbihcbiAgICAgICAgICBcIlxcblwiICsgY3VycmVudEluZGVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH0pKHBhc3NlZE9iaiwgXCJcIiwgMCk7XG59O1xuXG5mdW5jdGlvbiBzb3J0S2V5c0J5KG9iaiwgcmVmZXJlbmNlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiByZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5JDEgaW4gb2JqKSB7XG4gICAgICAgIGlmIChyZXN1bHRba2V5JDFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXkkMV0gPSBvYmpba2V5JDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmb3JtYXQoc3R5bGUsIHNwYWNlKSB7XG4gICAgaWYgKHNwYWNlID09PSB2b2lkIDApXG4gICAgICAgIHNwYWNlID0gMjtcbiAgICBzdHlsZSA9IHNvcnRLZXlzQnkoc3R5bGUsIHY4LiRyb290KTtcbiAgICBpZiAoc3R5bGUubGF5ZXJzKSB7XG4gICAgICAgIHN0eWxlLmxheWVycyA9IHN0eWxlLmxheWVycy5tYXAoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydEtleXNCeShsYXllciwgdjgubGF5ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25TdHJpbmdpZnlQcmV0dHlDb21wYWN0KHN0eWxlLCB7IGluZGVudDogc3BhY2UgfSk7XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBjb21tb25qc1JlcXVpcmUgKCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHJvbGx1cC1wbHVnaW4tY29tbW9uanMnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBwdW55Y29kZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbihmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSAgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0oY29tbW9uanNHbG9iYWwpKTtcbn0pO1xuXG52YXIgdXRpbCA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxudmFyIGVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHsgcmV0dXJuICcnOyB9XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgcXVlcnlzdHJpbmcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IGRlY29kZTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBlbmNvZGU7XG59KTtcbnZhciBxdWVyeXN0cmluZ18xID0gcXVlcnlzdHJpbmcuZGVjb2RlO1xudmFyIHF1ZXJ5c3RyaW5nXzIgPSBxdWVyeXN0cmluZy5wYXJzZTtcbnZhciBxdWVyeXN0cmluZ18zID0gcXVlcnlzdHJpbmcuZW5jb2RlO1xudmFyIHF1ZXJ5c3RyaW5nXzQgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnk7XG5cbnZhciBwYXJzZSA9IHVybFBhcnNlO1xudmFyIHJlc29sdmUgPSB1cmxSZXNvbHZlO1xudmFyIHJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xudmFyIGZvcm1hdCQxID0gdXJsRm9ybWF0O1xuXG52YXIgVXJsXzEgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9O1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICB7IGhvc3RFbmQgPSBoZWM7IH1cbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICB7IGhvc3RFbmQgPSBoZWM7IH1cbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIHsgaG9zdEVuZCA9IHJlc3QubGVuZ3RoOyB9XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICB7IGNvbnRpbnVlOyB9XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB7IHRoaXMucGF0aG5hbWUgPSByZXN0OyB9XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIHsgb2JqID0gdXJsUGFyc2Uob2JqKTsgfVxuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSB7IHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7IH1cbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHsgcHJvdG9jb2wgKz0gJzonOyB9XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHsgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTsgfVxuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgeyBoYXNoID0gJyMnICsgaGFzaDsgfVxuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgeyBzZWFyY2ggPSAnPycgKyBzZWFyY2g7IH1cblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSB7IHJldHVybiByZWxhdGl2ZTsgfVxuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICB7IHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldOyB9XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSl7IH1cbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgeyByZWxhdGl2ZS5ob3N0ID0gJyc7IH1cbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHsgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJzsgfVxuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSB7IHJlbFBhdGgudW5zaGlmdCgnJyk7IH1cbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHsgcmVsUGF0aC51bnNoaWZ0KCcnKTsgfVxuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSB7IHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDsgfVxuICAgICAgZWxzZSB7IHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7IH1cbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSB7IHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0OyB9XG4gICAgICAgIGVsc2UgeyByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7IH1cbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSB7IHNyY1BhdGggPSBbXTsgfVxuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB7IHRoaXMuaG9zdG5hbWUgPSBob3N0OyB9XG59O1xuXG52YXIgdXJsID0ge1xuXHRwYXJzZTogcGFyc2UsXG5cdHJlc29sdmU6IHJlc29sdmUsXG5cdHJlc29sdmVPYmplY3Q6IHJlc29sdmVPYmplY3QsXG5cdGZvcm1hdDogZm9ybWF0JDEsXG5cdFVybDogVXJsXzFcbn07XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5UmVmZXJlbmNlKHByb3BlcnR5TmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdjgubGF5b3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2OFt2OC5sYXlvdXRbaV1dKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjhbdjgubGF5b3V0W2ldXVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHY4LnBhaW50Lmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgZm9yICh2YXIga2V5JDEgaW4gdjhbdjgucGFpbnRbaSQxXV0pIHtcbiAgICAgICAgICAgIGlmIChrZXkkMSA9PT0gcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY4W3Y4LnBhaW50W2kkMV1dW2tleSQxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVhY2hTb3VyY2Uoc3R5bGUsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgayBpbiBzdHlsZS5zb3VyY2VzKSB7XG4gICAgICAgIGNhbGxiYWNrKHN0eWxlLnNvdXJjZXNba10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVhY2hMYXllcihzdHlsZSwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0eWxlLmxheWVyczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGxheWVyID0gbGlzdFtpXTtcbiAgICAgICAgY2FsbGJhY2sobGF5ZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVhY2hQcm9wZXJ0eShzdHlsZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBpbm5lcihsYXllciwgcHJvcGVydHlUeXBlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gbGF5ZXJbcHJvcGVydHlUeXBlXTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgICAgICBsYXllci5pZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlUeXBlLFxuICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wZXJ0aWVzW2tleV0sXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBnZXRQcm9wZXJ0eVJlZmVyZW5jZShrZXkpLFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1trZXldID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBhaW50KSB7XG4gICAgICAgICAgICBpbm5lcihsYXllciwgJ3BhaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubGF5b3V0KSB7XG4gICAgICAgICAgICBpbm5lcihsYXllciwgJ2xheW91dCcpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGVhY2hMYXlvdXQobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgayBpbiBsYXllcikge1xuICAgICAgICBpZiAoay5pbmRleE9mKCdsYXlvdXQnKSA9PT0gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobGF5ZXJba10sIGspO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZWFjaFBhaW50KGxheWVyLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGsgaW4gbGF5ZXIpIHtcbiAgICAgICAgaWYgKGsuaW5kZXhPZigncGFpbnQnKSA9PT0gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobGF5ZXJba10sIGspO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0YW50KHN0eWxlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnQCcpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVDb25zdGFudChzdHlsZSwgc3R5bGUuY29uc3RhbnRzW3ZhbHVlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZS5zdG9wcyk7XG59XG5mdW5jdGlvbiByZW5hbWVQcm9wZXJ0eShvYmosIGZyb20sIHRvKSB7XG4gICAgb2JqW3RvXSA9IG9ialtmcm9tXTtcbiAgICBkZWxldGUgb2JqW2Zyb21dO1xufVxuZnVuY3Rpb24gbWlncmF0ZVRvVjggKHN0eWxlKSB7XG4gICAgc3R5bGUudmVyc2lvbiA9IDg7XG4gICAgZWFjaFNvdXJjZShzdHlsZSwgZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLnR5cGUgPT09ICd2aWRlbycgJiYgc291cmNlLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShzb3VyY2UsICd1cmwnLCAndXJscycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgc291cmNlLmNvb3JkaW5hdGVzLmZvckVhY2goZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgZWFjaExheW91dChsYXllciwgZnVuY3Rpb24gKGxheW91dCkge1xuICAgICAgICAgICAgaWYgKGxheW91dFsnc3ltYm9sLW1pbi1kaXN0YW5jZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShsYXlvdXQsICdzeW1ib2wtbWluLWRpc3RhbmNlJywgJ3N5bWJvbC1zcGFjaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoUGFpbnQobGF5ZXIsIGZ1bmN0aW9uIChwYWludCkge1xuICAgICAgICAgICAgaWYgKHBhaW50WydiYWNrZ3JvdW5kLWltYWdlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmFtZVByb3BlcnR5KHBhaW50LCAnYmFja2dyb3VuZC1pbWFnZScsICdiYWNrZ3JvdW5kLXBhdHRlcm4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWludFsnbGluZS1pbWFnZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShwYWludCwgJ2xpbmUtaW1hZ2UnLCAnbGluZS1wYXR0ZXJuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFpbnRbJ2ZpbGwtaW1hZ2UnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuYW1lUHJvcGVydHkocGFpbnQsICdmaWxsLWltYWdlJywgJ2ZpbGwtcGF0dGVybicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBlYWNoUHJvcGVydHkoc3R5bGUsIHtcbiAgICAgICAgcGFpbnQ6IHRydWUsXG4gICAgICAgIGxheW91dDogdHJ1ZVxuICAgIH0sIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgdmFsdWUgPSByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHByb3BlcnR5LnZhbHVlKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5zdG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgc3RvcFsxXSA9IHJlc29sdmVDb25zdGFudChzdHlsZSwgc3RvcFsxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wZXJ0eS5zZXQodmFsdWUpO1xuICAgIH0pO1xuICAgIGRlbGV0ZSBzdHlsZS5jb25zdGFudHM7XG4gICAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgZWFjaExheW91dChsYXllciwgZnVuY3Rpb24gKGxheW91dCkge1xuICAgICAgICAgICAgZGVsZXRlIGxheW91dFsndGV4dC1tYXgtc2l6ZSddO1xuICAgICAgICAgICAgZGVsZXRlIGxheW91dFsnaWNvbi1tYXgtc2l6ZSddO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaFBhaW50KGxheWVyLCBmdW5jdGlvbiAocGFpbnQpIHtcbiAgICAgICAgICAgIGlmIChwYWludFsndGV4dC1zaXplJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLmxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5sYXlvdXQgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGF5ZXIubGF5b3V0Wyd0ZXh0LXNpemUnXSA9IHBhaW50Wyd0ZXh0LXNpemUnXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFpbnRbJ3RleHQtc2l6ZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhaW50WydpY29uLXNpemUnXSkge1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXIubGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmxheW91dCA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXllci5sYXlvdXRbJ2ljb24tc2l6ZSddID0gcGFpbnRbJ2ljb24tc2l6ZSddO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYWludFsnaWNvbi1zaXplJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG1pZ3JhdGVGb250c3RhY2tVUkwoaW5wdXQpIHtcbiAgICAgICAgdmFyIGlucHV0UGFyc2VkID0gdXJsLnBhcnNlKGlucHV0KTtcbiAgICAgICAgdmFyIGlucHV0UGF0aG5hbWVQYXJ0cyA9IGlucHV0UGFyc2VkLnBhdGhuYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChpbnB1dFBhcnNlZC5wcm90b2NvbCAhPT0gJ21hcGJveDonKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRQYXJzZWQuaG9zdG5hbWUgPT09ICdmb250c3RhY2snKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21hcGJveDovL2ZvbnRzL21hcGJveC97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZic7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRQYXJzZWQuaG9zdG5hbWUgPT09ICdmb250cycpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFwYm94Oi8vZm9udHMvJyArIGlucHV0UGF0aG5hbWVQYXJ0c1syXSArICcve2ZvbnRzdGFja30ve3JhbmdlfS5wYmYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZS5nbHlwaHMpIHtcbiAgICAgICAgc3R5bGUuZ2x5cGhzID0gbWlncmF0ZUZvbnRzdGFja1VSTChzdHlsZS5nbHlwaHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtaWdyYXRlRm9udFN0YWNrKGZvbnQpIHtcbiAgICAgICAgZnVuY3Rpb24gc3BsaXRBbmRUcmltKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzLnRyaW0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZvbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9udDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGxpdEFuZFRyaW0oZm9udCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb250LnN0b3BzLmZvckVhY2goZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgICAgICAgICBzdG9wWzFdID0gc3BsaXRBbmRUcmltKHN0b3BbMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm9udDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBmb250IHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgZWFjaExheW91dChsYXllciwgZnVuY3Rpb24gKGxheW91dCkge1xuICAgICAgICAgICAgaWYgKGxheW91dFsndGV4dC1mb250J10pIHtcbiAgICAgICAgICAgICAgICBsYXlvdXRbJ3RleHQtZm9udCddID0gbWlncmF0ZUZvbnRTdGFjayhsYXlvdXRbJ3RleHQtZm9udCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGZpcnN0U3ltYm9sTGF5ZXIgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdHlsZS5sYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGxheWVyID0gc3R5bGUubGF5ZXJzW2ldO1xuICAgICAgICBpZiAobGF5ZXIudHlwZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIGZpcnN0U3ltYm9sTGF5ZXIgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzeW1ib2xMYXllcnMgPSBzdHlsZS5sYXllcnMuc3BsaWNlKGZpcnN0U3ltYm9sTGF5ZXIpO1xuICAgIHN5bWJvbExheWVycy5yZXZlcnNlKCk7XG4gICAgc3R5bGUubGF5ZXJzID0gc3R5bGUubGF5ZXJzLmNvbmNhdChzeW1ib2xMYXllcnMpO1xuICAgIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kIChvdXRwdXQpIHtcbiAgICB2YXIgaW5wdXRzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsZW4tLSA+IDApXG4gICAgICAgIGlucHV0c1tsZW5dID0gYXJndW1lbnRzW2xlbiArIDFdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gaW5wdXRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgaW5wdXQgPSBsaXN0W2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIGlucHV0KSB7XG4gICAgICAgICAgICBvdXRwdXRba10gPSBpbnB1dFtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG52YXIgUGFyc2luZ0Vycm9yID0gZnVuY3Rpb24gKEVycm9yKSB7XG4gICAgZnVuY3Rpb24gUGFyc2luZ0Vycm9yKGtleSwgbWVzc2FnZSkge1xuICAgICAgICBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgaWYgKEVycm9yKVxuICAgICAgICBQYXJzaW5nRXJyb3IuX19wcm90b19fID0gRXJyb3I7XG4gICAgUGFyc2luZ0Vycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IgJiYgRXJyb3IucHJvdG90eXBlKTtcbiAgICBQYXJzaW5nRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyc2luZ0Vycm9yO1xuICAgIHJldHVybiBQYXJzaW5nRXJyb3I7XG59KEVycm9yKTtcblxudmFyIFNjb3BlID0gZnVuY3Rpb24gU2NvcGUocGFyZW50LCBiaW5kaW5ncykge1xuICAgIGlmIChiaW5kaW5ncyA9PT0gdm9pZCAwKVxuICAgICAgICBiaW5kaW5ncyA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGJpbmRpbmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmVmID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIG5hbWUgPSByZWZbMF07XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcmVmWzFdO1xuICAgICAgICB0aGlzLmJpbmRpbmdzW25hbWVdID0gZXhwcmVzc2lvbjtcbiAgICB9XG59O1xuU2NvcGUucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChiaW5kaW5ncykge1xuICAgIHJldHVybiBuZXcgU2NvcGUodGhpcywgYmluZGluZ3MpO1xufTtcblNjb3BlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIGlmICh0aGlzLmJpbmRpbmdzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldChuYW1lKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnIG5vdCBmb3VuZCBpbiBzY29wZS4nKTtcbn07XG5TY29wZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICBpZiAodGhpcy5iaW5kaW5nc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuaGFzKG5hbWUpIDogZmFsc2U7XG59O1xuXG52YXIgTnVsbFR5cGUgPSB7IGtpbmQ6ICdudWxsJyB9O1xudmFyIE51bWJlclR5cGUgPSB7IGtpbmQ6ICdudW1iZXInIH07XG52YXIgU3RyaW5nVHlwZSA9IHsga2luZDogJ3N0cmluZycgfTtcbnZhciBCb29sZWFuVHlwZSA9IHsga2luZDogJ2Jvb2xlYW4nIH07XG52YXIgQ29sb3JUeXBlID0geyBraW5kOiAnY29sb3InIH07XG52YXIgT2JqZWN0VHlwZSA9IHsga2luZDogJ29iamVjdCcgfTtcbnZhciBWYWx1ZVR5cGUgPSB7IGtpbmQ6ICd2YWx1ZScgfTtcbnZhciBFcnJvclR5cGUgPSB7IGtpbmQ6ICdlcnJvcicgfTtcbnZhciBDb2xsYXRvclR5cGUgPSB7IGtpbmQ6ICdjb2xsYXRvcicgfTtcbnZhciBGb3JtYXR0ZWRUeXBlID0geyBraW5kOiAnZm9ybWF0dGVkJyB9O1xudmFyIFJlc29sdmVkSW1hZ2VUeXBlID0geyBraW5kOiAncmVzb2x2ZWRJbWFnZScgfTtcbmZ1bmN0aW9uIGFycmF5KGl0ZW1UeXBlLCBOKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ2FycmF5JyxcbiAgICAgICAgaXRlbVR5cGU6IGl0ZW1UeXBlLFxuICAgICAgICBOOiBOXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHR5cGUpIHtcbiAgICBpZiAodHlwZS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgICAgIHZhciBpdGVtVHlwZSA9IHRvU3RyaW5nKHR5cGUuaXRlbVR5cGUpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHR5cGUuTiA9PT0gJ251bWJlcicgPyAnYXJyYXk8JyArIGl0ZW1UeXBlICsgJywgJyArIHR5cGUuTiArICc+JyA6IHR5cGUuaXRlbVR5cGUua2luZCA9PT0gJ3ZhbHVlJyA/ICdhcnJheScgOiAnYXJyYXk8JyArIGl0ZW1UeXBlICsgJz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0eXBlLmtpbmQ7XG4gICAgfVxufVxudmFyIHZhbHVlTWVtYmVyVHlwZXMgPSBbXG4gICAgTnVsbFR5cGUsXG4gICAgTnVtYmVyVHlwZSxcbiAgICBTdHJpbmdUeXBlLFxuICAgIEJvb2xlYW5UeXBlLFxuICAgIENvbG9yVHlwZSxcbiAgICBGb3JtYXR0ZWRUeXBlLFxuICAgIE9iamVjdFR5cGUsXG4gICAgYXJyYXkoVmFsdWVUeXBlKSxcbiAgICBSZXNvbHZlZEltYWdlVHlwZVxuXTtcbmZ1bmN0aW9uIGNoZWNrU3VidHlwZShleHBlY3RlZCwgdCkge1xuICAgIGlmICh0LmtpbmQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZC5raW5kID09PSAnYXJyYXknKSB7XG4gICAgICAgIGlmICh0LmtpbmQgPT09ICdhcnJheScgJiYgKHQuTiA9PT0gMCAmJiB0Lml0ZW1UeXBlLmtpbmQgPT09ICd2YWx1ZScgfHwgIWNoZWNrU3VidHlwZShleHBlY3RlZC5pdGVtVHlwZSwgdC5pdGVtVHlwZSkpICYmICh0eXBlb2YgZXhwZWN0ZWQuTiAhPT0gJ251bWJlcicgfHwgZXhwZWN0ZWQuTiA9PT0gdC5OKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09IHQua2luZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB2YWx1ZU1lbWJlclR5cGVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG1lbWJlclR5cGUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKCFjaGVja1N1YnR5cGUobWVtYmVyVHlwZSwgdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ0V4cGVjdGVkICcgKyB0b1N0cmluZyhleHBlY3RlZCkgKyAnIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodCkgKyAnIGluc3RlYWQuJztcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUeXBlKHByb3ZpZGVkLCBhbGxvd2VkVHlwZXMpIHtcbiAgICByZXR1cm4gYWxsb3dlZFR5cGVzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQua2luZCA9PT0gcHJvdmlkZWQua2luZDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWROYXRpdmVUeXBlKHByb3ZpZGVkLCBhbGxvd2VkVHlwZXMpIHtcbiAgICByZXR1cm4gYWxsb3dlZFR5cGVzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgPT09ICdudWxsJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkID09PSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHByb3ZpZGVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkICYmICFBcnJheS5pc0FycmF5KHByb3ZpZGVkKSAmJiB0eXBlb2YgcHJvdmlkZWQgPT09ICdvYmplY3QnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHQgPT09IHR5cGVvZiBwcm92aWRlZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG52YXIgY3NzY29sb3JwYXJzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL2Nzcy1jb2xvci1wYXJzZXItanNcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuLy8gSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yL1xudmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICBcInRyYW5zcGFyZW50XCI6IFswLDAsMCwwXSwgXCJhbGljZWJsdWVcIjogWzI0MCwyNDgsMjU1LDFdLFxuICBcImFudGlxdWV3aGl0ZVwiOiBbMjUwLDIzNSwyMTUsMV0sIFwiYXF1YVwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImFxdWFtYXJpbmVcIjogWzEyNywyNTUsMjEyLDFdLCBcImF6dXJlXCI6IFsyNDAsMjU1LDI1NSwxXSxcbiAgXCJiZWlnZVwiOiBbMjQ1LDI0NSwyMjAsMV0sIFwiYmlzcXVlXCI6IFsyNTUsMjI4LDE5NiwxXSxcbiAgXCJibGFja1wiOiBbMCwwLDAsMV0sIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwyMzUsMjA1LDFdLFxuICBcImJsdWVcIjogWzAsMCwyNTUsMV0sIFwiYmx1ZXZpb2xldFwiOiBbMTM4LDQzLDIyNiwxXSxcbiAgXCJicm93blwiOiBbMTY1LDQyLDQyLDFdLCBcImJ1cmx5d29vZFwiOiBbMjIyLDE4NCwxMzUsMV0sXG4gIFwiY2FkZXRibHVlXCI6IFs5NSwxNTgsMTYwLDFdLCBcImNoYXJ0cmV1c2VcIjogWzEyNywyNTUsMCwxXSxcbiAgXCJjaG9jb2xhdGVcIjogWzIxMCwxMDUsMzAsMV0sIFwiY29yYWxcIjogWzI1NSwxMjcsODAsMV0sXG4gIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwxNDksMjM3LDFdLCBcImNvcm5zaWxrXCI6IFsyNTUsMjQ4LDIyMCwxXSxcbiAgXCJjcmltc29uXCI6IFsyMjAsMjAsNjAsMV0sIFwiY3lhblwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImRhcmtibHVlXCI6IFswLDAsMTM5LDFdLCBcImRhcmtjeWFuXCI6IFswLDEzOSwxMzksMV0sXG4gIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LDEzNCwxMSwxXSwgXCJkYXJrZ3JheVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2dyZWVuXCI6IFswLDEwMCwwLDFdLCBcImRhcmtncmV5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJra2hha2lcIjogWzE4OSwxODMsMTA3LDFdLCBcImRhcmttYWdlbnRhXCI6IFsxMzksMCwxMzksMV0sXG4gIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LDEwNyw0NywxXSwgXCJkYXJrb3JhbmdlXCI6IFsyNTUsMTQwLDAsMV0sXG4gIFwiZGFya29yY2hpZFwiOiBbMTUzLDUwLDIwNCwxXSwgXCJkYXJrcmVkXCI6IFsxMzksMCwwLDFdLFxuICBcImRhcmtzYWxtb25cIjogWzIzMywxNTAsMTIyLDFdLCBcImRhcmtzZWFncmVlblwiOiBbMTQzLDE4OCwxNDMsMV0sXG4gIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsNjEsMTM5LDFdLCBcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LDc5LDc5LDFdLFxuICBcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LDc5LDc5LDFdLCBcImRhcmt0dXJxdW9pc2VcIjogWzAsMjA2LDIwOSwxXSxcbiAgXCJkYXJrdmlvbGV0XCI6IFsxNDgsMCwyMTEsMV0sIFwiZGVlcHBpbmtcIjogWzI1NSwyMCwxNDcsMV0sXG4gIFwiZGVlcHNreWJsdWVcIjogWzAsMTkxLDI1NSwxXSwgXCJkaW1ncmF5XCI6IFsxMDUsMTA1LDEwNSwxXSxcbiAgXCJkaW1ncmV5XCI6IFsxMDUsMTA1LDEwNSwxXSwgXCJkb2RnZXJibHVlXCI6IFszMCwxNDQsMjU1LDFdLFxuICBcImZpcmVicmlja1wiOiBbMTc4LDM0LDM0LDFdLCBcImZsb3JhbHdoaXRlXCI6IFsyNTUsMjUwLDI0MCwxXSxcbiAgXCJmb3Jlc3RncmVlblwiOiBbMzQsMTM5LDM0LDFdLCBcImZ1Y2hzaWFcIjogWzI1NSwwLDI1NSwxXSxcbiAgXCJnYWluc2Jvcm9cIjogWzIyMCwyMjAsMjIwLDFdLCBcImdob3N0d2hpdGVcIjogWzI0OCwyNDgsMjU1LDFdLFxuICBcImdvbGRcIjogWzI1NSwyMTUsMCwxXSwgXCJnb2xkZW5yb2RcIjogWzIxOCwxNjUsMzIsMV0sXG4gIFwiZ3JheVwiOiBbMTI4LDEyOCwxMjgsMV0sIFwiZ3JlZW5cIjogWzAsMTI4LDAsMV0sXG4gIFwiZ3JlZW55ZWxsb3dcIjogWzE3MywyNTUsNDcsMV0sIFwiZ3JleVwiOiBbMTI4LDEyOCwxMjgsMV0sXG4gIFwiaG9uZXlkZXdcIjogWzI0MCwyNTUsMjQwLDFdLCBcImhvdHBpbmtcIjogWzI1NSwxMDUsMTgwLDFdLFxuICBcImluZGlhbnJlZFwiOiBbMjA1LDkyLDkyLDFdLCBcImluZGlnb1wiOiBbNzUsMCwxMzAsMV0sXG4gIFwiaXZvcnlcIjogWzI1NSwyNTUsMjQwLDFdLCBcImtoYWtpXCI6IFsyNDAsMjMwLDE0MCwxXSxcbiAgXCJsYXZlbmRlclwiOiBbMjMwLDIzMCwyNTAsMV0sIFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LDI0MCwyNDUsMV0sXG4gIFwibGF3bmdyZWVuXCI6IFsxMjQsMjUyLDAsMV0sIFwibGVtb25jaGlmZm9uXCI6IFsyNTUsMjUwLDIwNSwxXSxcbiAgXCJsaWdodGJsdWVcIjogWzE3MywyMTYsMjMwLDFdLCBcImxpZ2h0Y29yYWxcIjogWzI0MCwxMjgsMTI4LDFdLFxuICBcImxpZ2h0Y3lhblwiOiBbMjI0LDI1NSwyNTUsMV0sIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwyNTAsMjEwLDFdLFxuICBcImxpZ2h0Z3JheVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRncmVlblwiOiBbMTQ0LDIzOCwxNDQsMV0sXG4gIFwibGlnaHRncmV5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodHBpbmtcIjogWzI1NSwxODIsMTkzLDFdLFxuICBcImxpZ2h0c2FsbW9uXCI6IFsyNTUsMTYwLDEyMiwxXSwgXCJsaWdodHNlYWdyZWVuXCI6IFszMiwxNzgsMTcwLDFdLFxuICBcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LDIwNiwyNTAsMV0sIFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwxMzYsMTUzLDFdLFxuICBcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksMTM2LDE1MywxXSwgXCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LDE5NiwyMjIsMV0sXG4gIFwibGlnaHR5ZWxsb3dcIjogWzI1NSwyNTUsMjI0LDFdLCBcImxpbWVcIjogWzAsMjU1LDAsMV0sXG4gIFwibGltZWdyZWVuXCI6IFs1MCwyMDUsNTAsMV0sIFwibGluZW5cIjogWzI1MCwyNDAsMjMwLDFdLFxuICBcIm1hZ2VudGFcIjogWzI1NSwwLDI1NSwxXSwgXCJtYXJvb25cIjogWzEyOCwwLDAsMV0sXG4gIFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLDIwNSwxNzAsMV0sIFwibWVkaXVtYmx1ZVwiOiBbMCwwLDIwNSwxXSxcbiAgXCJtZWRpdW1vcmNoaWRcIjogWzE4Niw4NSwyMTEsMV0sIFwibWVkaXVtcHVycGxlXCI6IFsxNDcsMTEyLDIxOSwxXSxcbiAgXCJtZWRpdW1zZWFncmVlblwiOiBbNjAsMTc5LDExMywxXSwgXCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywxMDQsMjM4LDFdLFxuICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLDI1MCwxNTQsMV0sIFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwyMDksMjA0LDFdLFxuICBcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LDIxLDEzMywxXSwgXCJtaWRuaWdodGJsdWVcIjogWzI1LDI1LDExMiwxXSxcbiAgXCJtaW50Y3JlYW1cIjogWzI0NSwyNTUsMjUwLDFdLCBcIm1pc3R5cm9zZVwiOiBbMjU1LDIyOCwyMjUsMV0sXG4gIFwibW9jY2FzaW5cIjogWzI1NSwyMjgsMTgxLDFdLCBcIm5hdmFqb3doaXRlXCI6IFsyNTUsMjIyLDE3MywxXSxcbiAgXCJuYXZ5XCI6IFswLDAsMTI4LDFdLCBcIm9sZGxhY2VcIjogWzI1MywyNDUsMjMwLDFdLFxuICBcIm9saXZlXCI6IFsxMjgsMTI4LDAsMV0sIFwib2xpdmVkcmFiXCI6IFsxMDcsMTQyLDM1LDFdLFxuICBcIm9yYW5nZVwiOiBbMjU1LDE2NSwwLDFdLCBcIm9yYW5nZXJlZFwiOiBbMjU1LDY5LDAsMV0sXG4gIFwib3JjaGlkXCI6IFsyMTgsMTEyLDIxNCwxXSwgXCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsMjMyLDE3MCwxXSxcbiAgXCJwYWxlZ3JlZW5cIjogWzE1MiwyNTEsMTUyLDFdLCBcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwyMzgsMjM4LDFdLFxuICBcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwxMTIsMTQ3LDFdLCBcInBhcGF5YXdoaXBcIjogWzI1NSwyMzksMjEzLDFdLFxuICBcInBlYWNocHVmZlwiOiBbMjU1LDIxOCwxODUsMV0sIFwicGVydVwiOiBbMjA1LDEzMyw2MywxXSxcbiAgXCJwaW5rXCI6IFsyNTUsMTkyLDIwMywxXSwgXCJwbHVtXCI6IFsyMjEsMTYwLDIyMSwxXSxcbiAgXCJwb3dkZXJibHVlXCI6IFsxNzYsMjI0LDIzMCwxXSwgXCJwdXJwbGVcIjogWzEyOCwwLDEyOCwxXSxcbiAgXCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsNTEsMTUzLDFdLFxuICBcInJlZFwiOiBbMjU1LDAsMCwxXSwgXCJyb3N5YnJvd25cIjogWzE4OCwxNDMsMTQzLDFdLFxuICBcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNSwxXSwgXCJzYWRkbGVicm93blwiOiBbMTM5LDY5LDE5LDFdLFxuICBcInNhbG1vblwiOiBbMjUwLDEyOCwxMTQsMV0sIFwic2FuZHlicm93blwiOiBbMjQ0LDE2NCw5NiwxXSxcbiAgXCJzZWFncmVlblwiOiBbNDYsMTM5LDg3LDFdLCBcInNlYXNoZWxsXCI6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgXCJzaWVubmFcIjogWzE2MCw4Miw0NSwxXSwgXCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyLDFdLFxuICBcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1LDFdLCBcInNsYXRlYmx1ZVwiOiBbMTA2LDkwLDIwNSwxXSxcbiAgXCJzbGF0ZWdyYXlcIjogWzExMiwxMjgsMTQ0LDFdLCBcInNsYXRlZ3JleVwiOiBbMTEyLDEyOCwxNDQsMV0sXG4gIFwic25vd1wiOiBbMjU1LDI1MCwyNTAsMV0sIFwic3ByaW5nZ3JlZW5cIjogWzAsMjU1LDEyNywxXSxcbiAgXCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODAsMV0sIFwidGFuXCI6IFsyMTAsMTgwLDE0MCwxXSxcbiAgXCJ0ZWFsXCI6IFswLDEyOCwxMjgsMV0sIFwidGhpc3RsZVwiOiBbMjE2LDE5MSwyMTYsMV0sXG4gIFwidG9tYXRvXCI6IFsyNTUsOTksNzEsMV0sIFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4LDFdLFxuICBcInZpb2xldFwiOiBbMjM4LDEzMCwyMzgsMV0sIFwid2hlYXRcIjogWzI0NSwyMjIsMTc5LDFdLFxuICBcIndoaXRlXCI6IFsyNTUsMjU1LDI1NSwxXSwgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgXCJ5ZWxsb3dcIjogWzI1NSwyNTUsMCwxXSwgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MCwxXX07XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19ieXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfaW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgeyByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTsgfVxuICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgeyByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7IH1cbiAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHtcbiAgaWYgKGggPCAwKSB7IGggKz0gMTsgfVxuICBlbHNlIGlmIChoID4gMSkgeyBoIC09IDE7IH1cblxuICBpZiAoaCAqIDYgPCAxKSB7IHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2OyB9XG4gIGlmIChoICogMiA8IDEpIHsgcmV0dXJuIG0yOyB9XG4gIGlmIChoICogMyA8IDIpIHsgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjsgfVxuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1NTQ29sb3IoY3NzX3N0cikge1xuICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHsgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgfSAgLy8gZHVwLlxuXG4gIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkgeyByZXR1cm4gbnVsbDsgfSAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKChpdiAmIDB4ZjAwKSA+PiA0KSB8ICgoaXYgJiAweGYwMCkgPj4gOCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZjApIHwgKChpdiAmIDB4ZjApID4+IDQpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXG4gICAgICAgICAgICAgIDFdO1xuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkgeyByZXR1cm4gbnVsbDsgfSAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4gW3BhcnNlX2Nzc19pbnQocGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1sxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMl0pLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICAgICAgcmV0dXJuIFtjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgrMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG50cnkgeyBleHBvcnRzLnBhcnNlQ1NTQ29sb3IgPSBwYXJzZUNTU0NvbG9yOyB9IGNhdGNoKGUpIHsgfVxufSk7XG52YXIgY3NzY29sb3JwYXJzZXJfMSA9IGNzc2NvbG9ycGFyc2VyLnBhcnNlQ1NTQ29sb3I7XG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uIENvbG9yKHIsIGcsIGIsIGEpIHtcbiAgICBpZiAoYSA9PT0gdm9pZCAwKVxuICAgICAgICBhID0gMTtcbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMuZyA9IGc7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmEgPSBhO1xufTtcbkNvbG9yLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHJnYmEgPSBjc3Njb2xvcnBhcnNlcl8xKGlucHV0KTtcbiAgICBpZiAoIXJnYmEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb2xvcihyZ2JhWzBdIC8gMjU1ICogcmdiYVszXSwgcmdiYVsxXSAvIDI1NSAqIHJnYmFbM10sIHJnYmFbMl0gLyAyNTUgKiByZ2JhWzNdLCByZ2JhWzNdKTtcbn07XG5Db2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgcmVmID0gdGhpcy50b0FycmF5KCk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgdmFyIGEgPSByZWZbM107XG4gICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKHIpICsgJywnICsgTWF0aC5yb3VuZChnKSArICcsJyArIE1hdGgucm91bmQoYikgKyAnLCcgKyBhICsgJyknO1xufTtcbkNvbG9yLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgciA9IHJlZi5yO1xuICAgIHZhciBnID0gcmVmLmc7XG4gICAgdmFyIGIgPSByZWYuYjtcbiAgICB2YXIgYSA9IHJlZi5hO1xuICAgIHJldHVybiBhID09PSAwID8gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgXSA6IFtcbiAgICAgICAgciAqIDI1NSAvIGEsXG4gICAgICAgIGcgKiAyNTUgLyBhLFxuICAgICAgICBiICogMjU1IC8gYSxcbiAgICAgICAgYVxuICAgIF07XG59O1xuQ29sb3IuYmxhY2sgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7XG5Db2xvci53aGl0ZSA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKTtcbkNvbG9yLnRyYW5zcGFyZW50ID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuQ29sb3IucmVkID0gbmV3IENvbG9yKDEsIDAsIDAsIDEpO1xuXG52YXIgQ29sbGF0b3IgPSBmdW5jdGlvbiBDb2xsYXRvcihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSkge1xuICAgIGlmIChjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSBkaWFjcml0aWNTZW5zaXRpdmUgPyAndmFyaWFudCcgOiAnY2FzZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZW5zaXRpdml0eSA9IGRpYWNyaXRpY1NlbnNpdGl2ZSA/ICdhY2NlbnQnIDogJ2Jhc2UnO1xuICAgIH1cbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB0aGlzLmNvbGxhdG9yID0gbmV3IEludGwuQ29sbGF0b3IodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZSA6IFtdLCB7XG4gICAgICAgIHNlbnNpdGl2aXR5OiB0aGlzLnNlbnNpdGl2aXR5LFxuICAgICAgICB1c2FnZTogJ3NlYXJjaCdcbiAgICB9KTtcbn07XG5Db2xsYXRvci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUobGhzLCByaHMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsYXRvci5jb21wYXJlKGxocywgcmhzKTtcbn07XG5Db2xsYXRvci5wcm90b3R5cGUucmVzb2x2ZWRMb2NhbGUgPSBmdW5jdGlvbiByZXNvbHZlZExvY2FsZSgpIHtcbiAgICByZXR1cm4gbmV3IEludGwuQ29sbGF0b3IodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZSA6IFtdKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG59O1xuXG52YXIgRm9ybWF0dGVkU2VjdGlvbiA9IGZ1bmN0aW9uIEZvcm1hdHRlZFNlY3Rpb24odGV4dCwgaW1hZ2UsIHNjYWxlLCBmb250U3RhY2ssIHRleHRDb2xvcikge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLmZvbnRTdGFjayA9IGZvbnRTdGFjaztcbiAgICB0aGlzLnRleHRDb2xvciA9IHRleHRDb2xvcjtcbn07XG52YXIgRm9ybWF0dGVkID0gZnVuY3Rpb24gRm9ybWF0dGVkKHNlY3Rpb25zKSB7XG4gICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xufTtcbkZvcm1hdHRlZC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyh1bmZvcm1hdHRlZCkge1xuICAgIHJldHVybiBuZXcgRm9ybWF0dGVkKFtuZXcgRm9ybWF0dGVkU2VjdGlvbih1bmZvcm1hdHRlZCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCldKTtcbn07XG5Gb3JtYXR0ZWQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLnNlY3Rpb25zLnNvbWUoZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24udGV4dC5sZW5ndGggIT09IDAgfHwgc2VjdGlvbi5pbWFnZSAmJiBzZWN0aW9uLmltYWdlLm5hbWUubGVuZ3RoICE9PSAwO1xuICAgIH0pO1xufTtcbkZvcm1hdHRlZC5mYWN0b3J5ID0gZnVuY3Rpb24gZmFjdG9yeSh0ZXh0KSB7XG4gICAgaWYgKHRleHQgaW5zdGFuY2VvZiBGb3JtYXR0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlZC5mcm9tU3RyaW5nKHRleHQpO1xuICAgIH1cbn07XG5Gb3JtYXR0ZWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBzZWN0aW9uLnRleHQ7XG4gICAgfSkuam9pbignJyk7XG59O1xuRm9ybWF0dGVkLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5zZWN0aW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBsaXN0W2ldO1xuICAgICAgICBpZiAoc2VjdGlvbi5pbWFnZSkge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKFtcbiAgICAgICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgIHNlY3Rpb24uaW1hZ2UubmFtZVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkLnB1c2goc2VjdGlvbi50ZXh0KTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHNlY3Rpb24uZm9udFN0YWNrKSB7XG4gICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWZvbnQnXSA9IFtcbiAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5mb250U3RhY2suc3BsaXQoJywnKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkge1xuICAgICAgICAgICAgb3B0aW9uc1snZm9udC1zY2FsZSddID0gc2VjdGlvbi5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbi50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ3RleHQtY29sb3InXSA9IFsncmdiYSddLmNvbmNhdChzZWN0aW9uLnRleHRDb2xvci50b0FycmF5KCkpO1xuICAgICAgICB9XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaChvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG52YXIgUmVzb2x2ZWRJbWFnZSA9IGZ1bmN0aW9uIFJlc29sdmVkSW1hZ2Uob3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLmF2YWlsYWJsZSA9IG9wdGlvbnMuYXZhaWxhYmxlO1xufTtcblJlc29sdmVkSW1hZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbn07XG5SZXNvbHZlZEltYWdlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVzb2x2ZWRJbWFnZSh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGF2YWlsYWJsZTogZmFsc2VcbiAgICB9KTtcbn07XG5SZXNvbHZlZEltYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgdGhpcy5uYW1lXG4gICAgXTtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUkdCQShyLCBnLCBiLCBhKSB7XG4gICAgaWYgKCEodHlwZW9mIHIgPT09ICdudW1iZXInICYmIHIgPj0gMCAmJiByIDw9IDI1NSAmJiB0eXBlb2YgZyA9PT0gJ251bWJlcicgJiYgZyA+PSAwICYmIGcgPD0gMjU1ICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiBiID49IDAgJiYgYiA8PSAyNTUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhID09PSAnbnVtYmVyJyA/IFtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGFcbiAgICAgICAgXSA6IFtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgYlxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gJ0ludmFsaWQgcmdiYSB2YWx1ZSBbJyArIHZhbHVlLmpvaW4oJywgJykgKyAnXTogXFwnclxcJywgXFwnZ1xcJywgYW5kIFxcJ2JcXCcgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS4nO1xuICAgIH1cbiAgICBpZiAoISh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGEgPT09ICdudW1iZXInICYmIGEgPj0gMCAmJiBhIDw9IDEpKSB7XG4gICAgICAgIHJldHVybiAnSW52YWxpZCByZ2JhIHZhbHVlIFsnICsgW1xuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYVxuICAgICAgICBdLmpvaW4oJywgJykgKyAnXTogXFwnYVxcJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS4nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzVmFsdWUobWl4ZWQpIHtcbiAgICBpZiAobWl4ZWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgQ29sbGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIEZvcm1hdHRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWl4ZWQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbWl4ZWQ7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoIWlzVmFsdWUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtaXhlZCkge1xuICAgICAgICAgICAgaWYgKCFpc1ZhbHVlKG1peGVkW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0eXBlT2YodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE51bGxUeXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nVHlwZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuVHlwZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlclR5cGU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICAgIHJldHVybiBDb2xvclR5cGU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbGxhdG9yKSB7XG4gICAgICAgIHJldHVybiBDb2xsYXRvclR5cGU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZvcm1hdHRlZCkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVkVHlwZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkge1xuICAgICAgICByZXR1cm4gUmVzb2x2ZWRJbWFnZVR5cGU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbVR5cGU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdmFsdWU7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICB2YXIgdCA9IHR5cGVPZihpdGVtKTtcbiAgICAgICAgICAgIGlmICghaXRlbVR5cGUpIHtcbiAgICAgICAgICAgICAgICBpdGVtVHlwZSA9IHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1UeXBlID09PSB0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1UeXBlID0gVmFsdWVUeXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheShpdGVtVHlwZSB8fCBWYWx1ZVR5cGUsIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdFR5cGU7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TdHJpbmckMSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yIHx8IHZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbn1cblxudmFyIExpdGVyYWwgPSBmdW5jdGlvbiBMaXRlcmFsKHR5cGUsIHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59O1xuTGl0ZXJhbC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1xcJ2xpdGVyYWxcXCcgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbHVlKGFyZ3NbMV0pKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdpbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IGFyZ3NbMV07XG4gICAgdmFyIHR5cGUgPSB0eXBlT2YodmFsdWUpO1xuICAgIHZhciBleHBlY3RlZCA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgIGlmICh0eXBlLmtpbmQgPT09ICdhcnJheScgJiYgdHlwZS5OID09PSAwICYmIGV4cGVjdGVkICYmIGV4cGVjdGVkLmtpbmQgPT09ICdhcnJheScgJiYgKHR5cGVvZiBleHBlY3RlZC5OICE9PSAnbnVtYmVyJyB8fCBleHBlY3RlZC5OID09PSAwKSkge1xuICAgICAgICB0eXBlID0gZXhwZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbCh0eXBlLCB2YWx1ZSk7XG59O1xuTGl0ZXJhbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5MaXRlcmFsLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoKSB7XG59O1xuTGl0ZXJhbC5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuTGl0ZXJhbC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2FycmF5JyB8fCB0aGlzLnR5cGUua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgIHRoaXMudmFsdWVcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICByZXR1cm4gWydyZ2JhJ10uY29uY2F0KHRoaXMudmFsdWUudG9BcnJheSgpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBGb3JtYXR0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc2VyaWFsaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufTtcblxudmFyIFJ1bnRpbWVFcnJvciA9IGZ1bmN0aW9uIFJ1bnRpbWVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5uYW1lID0gJ0V4cHJlc3Npb25FdmFsdWF0aW9uRXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59O1xuUnVudGltZUVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbn07XG5cbnZhciB0eXBlcyA9IHtcbiAgICBzdHJpbmc6IFN0cmluZ1R5cGUsXG4gICAgbnVtYmVyOiBOdW1iZXJUeXBlLFxuICAgIGJvb2xlYW46IEJvb2xlYW5UeXBlLFxuICAgIG9iamVjdDogT2JqZWN0VHlwZVxufTtcbnZhciBBc3NlcnRpb24gPSBmdW5jdGlvbiBBc3NlcnRpb24odHlwZSwgYXJncykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbn07XG5Bc3NlcnRpb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHR5cGU7XG4gICAgdmFyIG5hbWUgPSBhcmdzWzBdO1xuICAgIGlmIChuYW1lID09PSAnYXJyYXknKSB7XG4gICAgICAgIHZhciBpdGVtVHlwZTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIHR5cGUkMSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUkMSAhPT0gJ3N0cmluZycgfHwgISh0eXBlJDEgaW4gdHlwZXMpIHx8IHR5cGUkMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignVGhlIGl0ZW0gdHlwZSBhcmd1bWVudCBvZiBcImFycmF5XCIgbXVzdCBiZSBvbmUgb2Ygc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4nLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1UeXBlID0gdHlwZXNbdHlwZSQxXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1UeXBlID0gVmFsdWVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBOO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICBpZiAoYXJnc1syXSAhPT0gbnVsbCAmJiAodHlwZW9mIGFyZ3NbMl0gIT09ICdudW1iZXInIHx8IGFyZ3NbMl0gPCAwIHx8IGFyZ3NbMl0gIT09IE1hdGguZmxvb3IoYXJnc1syXSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1RoZSBsZW5ndGggYXJndW1lbnQgdG8gXCJhcnJheVwiIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxpdGVyYWwnLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE4gPSBhcmdzWzJdO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSBhcnJheShpdGVtVHlwZSwgTik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHR5cGVzW25hbWVdO1xuICAgIH1cbiAgICB2YXIgcGFyc2VkID0gW107XG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgaSwgVmFsdWVUeXBlKTtcbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLnB1c2goaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0eXBlLCBwYXJzZWQpO1xufTtcbkFzc2VydGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmFyZ3NbaV0uZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tTdWJ0eXBlKHRoaXMudHlwZSwgdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSB0aGlzLmFyZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSAnICsgdG9TdHJpbmcodGhpcy50eXBlKSArICcsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodHlwZU9mKHZhbHVlKSkgKyAnIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuQXNzZXJ0aW9uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG59O1xuQXNzZXJ0aW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSk7XG59O1xuQXNzZXJ0aW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbdHlwZS5raW5kXTtcbiAgICBpZiAodHlwZS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgICAgIHZhciBpdGVtVHlwZSA9IHR5cGUuaXRlbVR5cGU7XG4gICAgICAgIGlmIChpdGVtVHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCBpdGVtVHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCBpdGVtVHlwZS5raW5kID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChpdGVtVHlwZS5raW5kKTtcbiAgICAgICAgICAgIHZhciBOID0gdHlwZS5OO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBOID09PSAnbnVtYmVyJyB8fCB0aGlzLmFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZC5jb25jYXQodGhpcy5hcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmcuc2VyaWFsaXplKCk7XG4gICAgfSkpO1xufTtcblxudmFyIEZvcm1hdEV4cHJlc3Npb24gPSBmdW5jdGlvbiBGb3JtYXRFeHByZXNzaW9uKHNlY3Rpb25zKSB7XG4gICAgdGhpcy50eXBlID0gRm9ybWF0dGVkVHlwZTtcbiAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG59O1xuRm9ybWF0RXhwcmVzc2lvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBmaXJzdEFyZyA9IGFyZ3NbMV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpcnN0QXJnKSAmJiB0eXBlb2YgZmlyc3RBcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGltYWdlIG9yIHRleHQgc2VjdGlvbi4nKTtcbiAgICB9XG4gICAgdmFyIHNlY3Rpb25zID0gW107XG4gICAgdmFyIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gYXJncy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgIGlmIChuZXh0VG9rZW5NYXlCZU9iamVjdCAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBuZXh0VG9rZW5NYXlCZU9iamVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChhcmdbJ2ZvbnQtc2NhbGUnXSkge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gY29udGV4dC5wYXJzZShhcmdbJ2ZvbnQtc2NhbGUnXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm9udCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJnWyd0ZXh0LWZvbnQnXSkge1xuICAgICAgICAgICAgICAgIGZvbnQgPSBjb250ZXh0LnBhcnNlKGFyZ1sndGV4dC1mb250J10sIDEsIGFycmF5KFN0cmluZ1R5cGUpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHRDb2xvciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJnWyd0ZXh0LWNvbG9yJ10pIHtcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3IgPSBjb250ZXh0LnBhcnNlKGFyZ1sndGV4dC1jb2xvciddLCAxLCBDb2xvclR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghdGV4dENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0RXhwcmVzc2lvbiA9IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbGFzdEV4cHJlc3Npb24uc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgIGxhc3RFeHByZXNzaW9uLmZvbnQgPSBmb250O1xuICAgICAgICAgICAgbGFzdEV4cHJlc3Npb24udGV4dENvbG9yID0gdGV4dENvbG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBraW5kID0gY29udGVudC50eXBlLmtpbmQ7XG4gICAgICAgICAgICBpZiAoa2luZCAhPT0gJ3N0cmluZycgJiYga2luZCAhPT0gJ3ZhbHVlJyAmJiBraW5kICE9PSAnbnVsbCcgJiYga2luZCAhPT0gJ3Jlc29sdmVkSW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0Zvcm1hdHRlZCB0ZXh0IHR5cGUgbXVzdCBiZSBcXCdzdHJpbmdcXCcsIFxcJ3ZhbHVlXFwnLCBcXCdpbWFnZVxcJyBvciBcXCdudWxsXFwnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFRva2VuTWF5QmVPYmplY3QgPSB0cnVlO1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICBzY2FsZTogbnVsbCxcbiAgICAgICAgICAgICAgICBmb250OiBudWxsLFxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGb3JtYXRFeHByZXNzaW9uKHNlY3Rpb25zKTtcbn07XG5Gb3JtYXRFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBldmFsdWF0ZVNlY3Rpb24gPSBmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICB2YXIgZXZhbHVhdGVkQ29udGVudCA9IHNlY3Rpb24uY29udGVudC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBpZiAodHlwZU9mKGV2YWx1YXRlZENvbnRlbnQpID09PSBSZXNvbHZlZEltYWdlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWRTZWN0aW9uKCcnLCBldmFsdWF0ZWRDb250ZW50LCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvcm1hdHRlZFNlY3Rpb24odG9TdHJpbmckMShldmFsdWF0ZWRDb250ZW50KSwgbnVsbCwgc2VjdGlvbi5zY2FsZSA/IHNlY3Rpb24uc2NhbGUuZXZhbHVhdGUoY3R4KSA6IG51bGwsIHNlY3Rpb24uZm9udCA/IHNlY3Rpb24uZm9udC5ldmFsdWF0ZShjdHgpLmpvaW4oJywnKSA6IG51bGwsIHNlY3Rpb24udGV4dENvbG9yID8gc2VjdGlvbi50ZXh0Q29sb3IuZXZhbHVhdGUoY3R4KSA6IG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWQodGhpcy5zZWN0aW9ucy5tYXAoZXZhbHVhdGVTZWN0aW9uKSk7XG59O1xuRm9ybWF0RXhwcmVzc2lvbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLnNlY3Rpb25zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGxpc3RbaV07XG4gICAgICAgIGZuKHNlY3Rpb24uY29udGVudCk7XG4gICAgICAgIGlmIChzZWN0aW9uLnNjYWxlKSB7XG4gICAgICAgICAgICBmbihzZWN0aW9uLnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbi5mb250KSB7XG4gICAgICAgICAgICBmbihzZWN0aW9uLmZvbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uLnRleHRDb2xvcikge1xuICAgICAgICAgICAgZm4oc2VjdGlvbi50ZXh0Q29sb3IpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkZvcm1hdEV4cHJlc3Npb24ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5Gb3JtYXRFeHByZXNzaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5zZWN0aW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBsaXN0W2ldO1xuICAgICAgICBzZXJpYWxpemVkLnB1c2goc2VjdGlvbi5jb250ZW50LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHNlY3Rpb24uc2NhbGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ2ZvbnQtc2NhbGUnXSA9IHNlY3Rpb24uc2NhbGUuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb24uZm9udCkge1xuICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1mb250J10gPSBzZWN0aW9uLmZvbnQuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb24udGV4dENvbG9yKSB7XG4gICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWNvbG9yJ10gPSBzZWN0aW9uLnRleHRDb2xvci5zZXJpYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkLnB1c2gob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIEltYWdlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIEltYWdlRXhwcmVzc2lvbihpbnB1dCkge1xuICAgIHRoaXMudHlwZSA9IFJlc29sdmVkSW1hZ2VUeXBlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbn07XG5JbWFnZUV4cHJlc3Npb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCB0d28gYXJndW1lbnRzLicpO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgU3RyaW5nVHlwZSk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdObyBpbWFnZSBuYW1lIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEltYWdlRXhwcmVzc2lvbihuYW1lKTtcbn07XG5JbWFnZUV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgdmFyIGV2YWx1YXRlZEltYWdlTmFtZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICB2YXIgdmFsdWUgPSBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcoZXZhbHVhdGVkSW1hZ2VOYW1lKTtcbiAgICBpZiAodmFsdWUgJiYgY3R4LmF2YWlsYWJsZUltYWdlcykge1xuICAgICAgICB2YWx1ZS5hdmFpbGFibGUgPSBjdHguYXZhaWxhYmxlSW1hZ2VzLmluZGV4T2YoZXZhbHVhdGVkSW1hZ2VOYW1lKSA+IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuSW1hZ2VFeHByZXNzaW9uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLmlucHV0KTtcbn07XG5JbWFnZUV4cHJlc3Npb24ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5JbWFnZUV4cHJlc3Npb24ucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXG4gICAgXTtcbn07XG5cbnZhciB0eXBlcyQxID0ge1xuICAgICd0by1ib29sZWFuJzogQm9vbGVhblR5cGUsXG4gICAgJ3RvLWNvbG9yJzogQ29sb3JUeXBlLFxuICAgICd0by1udW1iZXInOiBOdW1iZXJUeXBlLFxuICAgICd0by1zdHJpbmcnOiBTdHJpbmdUeXBlXG59O1xudmFyIENvZXJjaW9uID0gZnVuY3Rpb24gQ29lcmNpb24odHlwZSwgYXJncykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbn07XG5Db2VyY2lvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBuYW1lID0gYXJnc1swXTtcbiAgICBpZiAoKG5hbWUgPT09ICd0by1ib29sZWFuJyB8fCBuYW1lID09PSAndG8tc3RyaW5nJykgJiYgYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIG9uZSBhcmd1bWVudC4nKTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB0eXBlcyQxW25hbWVdO1xuICAgIHZhciBwYXJzZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCBpLCBWYWx1ZVR5cGUpO1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQucHVzaChpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29lcmNpb24odHlwZSwgcGFyc2VkKTtcbn07XG5Db2VyY2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2NvbG9yJykge1xuICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLmFyZ3M7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlucHV0ID0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gY3R4LnBhcnNlQ29sb3IoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIDwgMyB8fCBpbnB1dC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ0ludmFsaWQgcmJnYSB2YWx1ZSAnICsgSlNPTi5zdHJpbmdpZnkoaW5wdXQpICsgJzogZXhwZWN0ZWQgYW4gYXJyYXkgY29udGFpbmluZyBlaXRoZXIgdGhyZWUgb3IgZm91ciBudW1lcmljIHZhbHVlcy4nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdmFsaWRhdGVSR0JBKGlucHV0WzBdLCBpbnB1dFsxXSwgaW5wdXRbMl0sIGlucHV0WzNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKGlucHV0WzBdIC8gMjU1LCBpbnB1dFsxXSAvIDI1NSwgaW5wdXRbMl0gLyAyNTUsIGlucHV0WzNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihlcnJvciB8fCAnQ291bGQgbm90IHBhcnNlIGNvbG9yIGZyb20gdmFsdWUgXFwnJyArICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gaW5wdXQgOiBTdHJpbmcoSlNPTi5zdHJpbmdpZnkoaW5wdXQpKSkgKyAnXFwnJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gdGhpcy5hcmdzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGFyZyQxID0gbGlzdCQxW2kkMV07XG4gICAgICAgICAgICB2YWx1ZSA9IGFyZyQxLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG51bSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcgdG8gbnVtYmVyLicpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdmb3JtYXR0ZWQnKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZWQuZnJvbVN0cmluZyh0b1N0cmluZyQxKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSB7XG4gICAgICAgIHJldHVybiBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcodG9TdHJpbmckMSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyQxKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKTtcbiAgICB9XG59O1xuQ29lcmNpb24ucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIHRoaXMuYXJncy5mb3JFYWNoKGZuKTtcbn07XG5Db2VyY2lvbi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmcub3V0cHV0RGVmaW5lZCgpO1xuICAgIH0pO1xufTtcbkNvZXJjaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMudHlwZS5raW5kID09PSAnZm9ybWF0dGVkJykge1xuICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEV4cHJlc3Npb24oW3tcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgc2NhbGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZm9udDogbnVsbCxcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IG51bGxcbiAgICAgICAgICAgIH1dKS5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZS5raW5kID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbWFnZUV4cHJlc3Npb24odGhpcy5hcmdzWzBdKS5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ3RvLScgKyB0aGlzLnR5cGUua2luZF07XG4gICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaChjaGlsZC5zZXJpYWxpemUoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG52YXIgZ2VvbWV0cnlUeXBlcyA9IFtcbiAgICAnVW5rbm93bicsXG4gICAgJ1BvaW50JyxcbiAgICAnTGluZVN0cmluZycsXG4gICAgJ1BvbHlnb24nXG5dO1xudmFyIEV2YWx1YXRpb25Db250ZXh0ID0gZnVuY3Rpb24gRXZhbHVhdGlvbkNvbnRleHQoKSB7XG4gICAgdGhpcy5nbG9iYWxzID0gbnVsbDtcbiAgICB0aGlzLmZlYXR1cmUgPSBudWxsO1xuICAgIHRoaXMuZmVhdHVyZVN0YXRlID0gbnVsbDtcbiAgICB0aGlzLmZvcm1hdHRlZFNlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuX3BhcnNlQ29sb3JDYWNoZSA9IHt9O1xuICAgIHRoaXMuYXZhaWxhYmxlSW1hZ2VzID0gbnVsbDtcbiAgICB0aGlzLmNhbm9uaWNhbCA9IG51bGw7XG59O1xuRXZhbHVhdGlvbkNvbnRleHQucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiAnaWQnIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5pZCA6IG51bGw7XG59O1xuRXZhbHVhdGlvbkNvbnRleHQucHJvdG90eXBlLmdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdlb21ldHJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlID8gdHlwZW9mIHRoaXMuZmVhdHVyZS50eXBlID09PSAnbnVtYmVyJyA/IGdlb21ldHJ5VHlwZXNbdGhpcy5mZWF0dXJlLnR5cGVdIDogdGhpcy5mZWF0dXJlLnR5cGUgOiBudWxsO1xufTtcbkV2YWx1YXRpb25Db250ZXh0LnByb3RvdHlwZS5nZW9tZXRyeSA9IGZ1bmN0aW9uIGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgJ2dlb21ldHJ5JyBpbiB0aGlzLmZlYXR1cmUgPyB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgOiBudWxsO1xufTtcbkV2YWx1YXRpb25Db250ZXh0LnByb3RvdHlwZS5jYW5vbmljYWxJRCA9IGZ1bmN0aW9uIGNhbm9uaWNhbElEKCkge1xuICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbDtcbn07XG5FdmFsdWF0aW9uQ29udGV4dC5wcm90b3R5cGUucHJvcGVydGllcyA9IGZ1bmN0aW9uIHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUucHJvcGVydGllcyB8fCB7fTtcbn07XG5FdmFsdWF0aW9uQ29udGV4dC5wcm90b3R5cGUucGFyc2VDb2xvciA9IGZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXQpIHtcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW2lucHV0XTtcbiAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICBjYWNoZWQgPSB0aGlzLl9wYXJzZUNvbG9yQ2FjaGVbaW5wdXRdID0gQ29sb3IucGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkO1xufTtcblxudmFyIENvbXBvdW5kRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIENvbXBvdW5kRXhwcmVzc2lvbihuYW1lLCB0eXBlLCBldmFsdWF0ZSwgYXJncykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLl9ldmFsdWF0ZSA9IGV2YWx1YXRlO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHJldHVybiB0aGlzLl9ldmFsdWF0ZShjdHgsIHRoaXMuYXJncyk7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFt0aGlzLm5hbWVdLmNvbmNhdCh0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5zZXJpYWxpemUoKTtcbiAgICB9KSk7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIHZhciByZWYkMTtcbiAgICB2YXIgb3AgPSBhcmdzWzBdO1xuICAgIHZhciBkZWZpbml0aW9uID0gQ29tcG91bmRFeHByZXNzaW9uLmRlZmluaXRpb25zW29wXTtcbiAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1Vua25vd24gZXhwcmVzc2lvbiBcIicgKyBvcCArICdcIi4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS4nLCAwKTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBBcnJheS5pc0FycmF5KGRlZmluaXRpb24pID8gZGVmaW5pdGlvblswXSA6IGRlZmluaXRpb24udHlwZTtcbiAgICB2YXIgYXZhaWxhYmxlT3ZlcmxvYWRzID0gQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSA/IFtbXG4gICAgICAgICAgICBkZWZpbml0aW9uWzFdLFxuICAgICAgICAgICAgZGVmaW5pdGlvblsyXVxuICAgICAgICBdXSA6IGRlZmluaXRpb24ub3ZlcmxvYWRzO1xuICAgIHZhciBvdmVybG9hZHMgPSBhdmFpbGFibGVPdmVybG9hZHMuZmlsdGVyKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHJlZlswXTtcbiAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHNpZ25hdHVyZSkgfHwgc2lnbmF0dXJlLmxlbmd0aCA9PT0gYXJncy5sZW5ndGggLSAxO1xuICAgIH0pO1xuICAgIHZhciBzaWduYXR1cmVDb250ZXh0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpJDMgPSAwLCBsaXN0ID0gb3ZlcmxvYWRzOyBpJDMgPCBsaXN0Lmxlbmd0aDsgaSQzICs9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IGxpc3RbaSQzXTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHJlZlswXTtcbiAgICAgICAgdmFyIGV2YWx1YXRlID0gcmVmWzFdO1xuICAgICAgICBzaWduYXR1cmVDb250ZXh0ID0gbmV3IFBhcnNpbmdDb250ZXh0KGNvbnRleHQucmVnaXN0cnksIGNvbnRleHQucGF0aCwgbnVsbCwgY29udGV4dC5zY29wZSk7XG4gICAgICAgIHZhciBwYXJzZWRBcmdzID0gW107XG4gICAgICAgIHZhciBhcmdQYXJzZUZhaWxlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IEFycmF5LmlzQXJyYXkocGFyYW1zKSA/IHBhcmFtc1tpIC0gMV0gOiBwYXJhbXMudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBzaWduYXR1cmVDb250ZXh0LnBhcnNlKGFyZywgMSArIHBhcnNlZEFyZ3MubGVuZ3RoLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBhcmdQYXJzZUZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWRBcmdzLnB1c2gocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnUGFyc2VGYWlsZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSBwYXJzZWRBcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkICcgKyBwYXJhbXMubGVuZ3RoICsgJyBhcmd1bWVudHMsIGJ1dCBmb3VuZCAnICsgcGFyc2VkQXJncy5sZW5ndGggKyAnIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcGFyc2VkQXJncy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSBBcnJheS5pc0FycmF5KHBhcmFtcykgPyBwYXJhbXNbaSQxXSA6IHBhcmFtcy50eXBlO1xuICAgICAgICAgICAgdmFyIGFyZyQxID0gcGFyc2VkQXJnc1tpJDFdO1xuICAgICAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5jb25jYXQoaSQxICsgMSkuY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCBhcmckMS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmF0dXJlQ29udGV4dC5lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kRXhwcmVzc2lvbihvcCwgdHlwZSwgZXZhbHVhdGUsIHBhcnNlZEFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVybG9hZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIChyZWYkMSA9IGNvbnRleHQuZXJyb3JzKS5wdXNoLmFwcGx5KHJlZiQxLCBzaWduYXR1cmVDb250ZXh0LmVycm9ycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkJDEgPSBvdmVybG9hZHMubGVuZ3RoID8gb3ZlcmxvYWRzIDogYXZhaWxhYmxlT3ZlcmxvYWRzO1xuICAgICAgICB2YXIgc2lnbmF0dXJlcyA9IGV4cGVjdGVkJDEubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5U2lnbmF0dXJlKHBhcmFtcyk7XG4gICAgICAgIH0pLmpvaW4oJyB8ICcpO1xuICAgICAgICB2YXIgYWN0dWFsVHlwZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgYXJncy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkJDEgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaSQyXSwgMSArIGFjdHVhbFR5cGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZCQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3R1YWxUeXBlcy5wdXNoKHRvU3RyaW5nKHBhcnNlZCQxLnR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhcmd1bWVudHMgb2YgdHlwZSAnICsgc2lnbmF0dXJlcyArICcsIGJ1dCBmb3VuZCAoJyArIGFjdHVhbFR5cGVzLmpvaW4oJywgJykgKyAnKSBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5Db21wb3VuZEV4cHJlc3Npb24ucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihyZWdpc3RyeSwgZGVmaW5pdGlvbnMpIHtcbiAgICBDb21wb3VuZEV4cHJlc3Npb24uZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICBmb3IgKHZhciBuYW1lIGluIGRlZmluaXRpb25zKSB7XG4gICAgICAgIHJlZ2lzdHJ5W25hbWVdID0gQ29tcG91bmRFeHByZXNzaW9uO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzdHJpbmdpZnlTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlKSkge1xuICAgICAgICByZXR1cm4gJygnICsgc2lnbmF0dXJlLm1hcCh0b1N0cmluZykuam9pbignLCAnKSArICcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJygnICsgdG9TdHJpbmcoc2lnbmF0dXJlLnR5cGUpICsgJy4uLiknO1xuICAgIH1cbn1cblxudmFyIENvbGxhdG9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIENvbGxhdG9yRXhwcmVzc2lvbihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSkge1xuICAgIHRoaXMudHlwZSA9IENvbGxhdG9yVHlwZTtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjYXNlU2Vuc2l0aXZlO1xuICAgIHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlID0gZGlhY3JpdGljU2Vuc2l0aXZlO1xufTtcbkNvbGxhdG9yRXhwcmVzc2lvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIG9uZSBhcmd1bWVudC4nKTtcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignQ29sbGF0b3Igb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG4gICAgdmFyIGNhc2VTZW5zaXRpdmUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2Nhc2Utc2Vuc2l0aXZlJ10gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9uc1snY2FzZS1zZW5zaXRpdmUnXSwgMSwgQm9vbGVhblR5cGUpO1xuICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGRpYWNyaXRpY1NlbnNpdGl2ZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snZGlhY3JpdGljLXNlbnNpdGl2ZSddID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnNbJ2RpYWNyaXRpYy1zZW5zaXRpdmUnXSwgMSwgQm9vbGVhblR5cGUpO1xuICAgIGlmICghZGlhY3JpdGljU2Vuc2l0aXZlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbG9jYWxlID0gbnVsbDtcbiAgICBpZiAob3B0aW9uc1snbG9jYWxlJ10pIHtcbiAgICAgICAgbG9jYWxlID0gY29udGV4dC5wYXJzZShvcHRpb25zWydsb2NhbGUnXSwgMSwgU3RyaW5nVHlwZSk7XG4gICAgICAgIGlmICghbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbGxhdG9yRXhwcmVzc2lvbihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSk7XG59O1xuQ29sbGF0b3JFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHJldHVybiBuZXcgQ29sbGF0b3IodGhpcy5jYXNlU2Vuc2l0aXZlLmV2YWx1YXRlKGN0eCksIHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlLmV2YWx1YXRlKGN0eCksIHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUoY3R4KSA6IG51bGwpO1xufTtcbkNvbGxhdG9yRXhwcmVzc2lvbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5jYXNlU2Vuc2l0aXZlKTtcbiAgICBmbih0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSk7XG4gICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgIGZuKHRoaXMubG9jYWxlKTtcbiAgICB9XG59O1xuQ29sbGF0b3JFeHByZXNzaW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuQ29sbGF0b3JFeHByZXNzaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICBvcHRpb25zWydjYXNlLXNlbnNpdGl2ZSddID0gdGhpcy5jYXNlU2Vuc2l0aXZlLnNlcmlhbGl6ZSgpO1xuICAgIG9wdGlvbnNbJ2RpYWNyaXRpYy1zZW5zaXRpdmUnXSA9IHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlLnNlcmlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICBvcHRpb25zWydsb2NhbGUnXSA9IHRoaXMubG9jYWxlLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICAnY29sbGF0b3InLFxuICAgICAgICBvcHRpb25zXG4gICAgXTtcbn07XG5cbnZhciBFWFRFTlQgPSA4MTkyO1xuZnVuY3Rpb24gdXBkYXRlQkJveChiYm94LCBjb29yZCkge1xuICAgIGJib3hbMF0gPSBNYXRoLm1pbihiYm94WzBdLCBjb29yZFswXSk7XG4gICAgYmJveFsxXSA9IE1hdGgubWluKGJib3hbMV0sIGNvb3JkWzFdKTtcbiAgICBiYm94WzJdID0gTWF0aC5tYXgoYmJveFsyXSwgY29vcmRbMF0pO1xuICAgIGJib3hbM10gPSBNYXRoLm1heChiYm94WzNdLCBjb29yZFsxXSk7XG59XG5mdW5jdGlvbiBtZXJjYXRvclhmcm9tTG5nKGxuZykge1xuICAgIHJldHVybiAoMTgwICsgbG5nKSAvIDM2MDtcbn1cbmZ1bmN0aW9uIG1lcmNhdG9yWWZyb21MYXQobGF0KSB7XG4gICAgcmV0dXJuICgxODAgLSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBsYXQgKiBNYXRoLlBJIC8gMzYwKSkpIC8gMzYwO1xufVxuZnVuY3Rpb24gYm94V2l0aGluQm94KGJib3gxLCBiYm94Mikge1xuICAgIGlmIChiYm94MVswXSA8PSBiYm94MlswXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiYm94MVsyXSA+PSBiYm94MlsyXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiYm94MVsxXSA8PSBiYm94MlsxXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiYm94MVszXSA+PSBiYm94MlszXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VGlsZUNvb3JkaW5hdGVzKHAsIGNhbm9uaWNhbCkge1xuICAgIHZhciB4ID0gbWVyY2F0b3JYZnJvbUxuZyhwWzBdKTtcbiAgICB2YXIgeSA9IG1lcmNhdG9yWWZyb21MYXQocFsxXSk7XG4gICAgdmFyIHRpbGVzQXRab29tID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopO1xuICAgIHJldHVybiBbXG4gICAgICAgIE1hdGgucm91bmQoeCAqIHRpbGVzQXRab29tICogRVhURU5UKSxcbiAgICAgICAgTWF0aC5yb3VuZCh5ICogdGlsZXNBdFpvb20gKiBFWFRFTlQpXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG9uQm91bmRhcnkocCwgcDEsIHAyKSB7XG4gICAgdmFyIHgxID0gcFswXSAtIHAxWzBdO1xuICAgIHZhciB5MSA9IHBbMV0gLSBwMVsxXTtcbiAgICB2YXIgeDIgPSBwWzBdIC0gcDJbMF07XG4gICAgdmFyIHkyID0gcFsxXSAtIHAyWzFdO1xuICAgIHJldHVybiB4MSAqIHkyIC0geDIgKiB5MSA9PT0gMCAmJiB4MSAqIHgyIDw9IDAgJiYgeTEgKiB5MiA8PSAwO1xufVxuZnVuY3Rpb24gcmF5SW50ZXJzZWN0KHAsIHAxLCBwMikge1xuICAgIHJldHVybiBwMVsxXSA+IHBbMV0gIT09IHAyWzFdID4gcFsxXSAmJiBwWzBdIDwgKHAyWzBdIC0gcDFbMF0pICogKHBbMV0gLSBwMVsxXSkgLyAocDJbMV0gLSBwMVsxXSkgKyBwMVswXTtcbn1cbmZ1bmN0aW9uIHBvaW50V2l0aGluUG9seWdvbihwb2ludCwgcmluZ3MpIHtcbiAgICB2YXIgaW5zaWRlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gcmluZy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG4gICAgICAgICAgICBpZiAob25Cb3VuZGFyeShwb2ludCwgcmluZ1tqXSwgcmluZ1tqICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJheUludGVyc2VjdChwb2ludCwgcmluZ1tqXSwgcmluZ1tqICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuZnVuY3Rpb24gcG9pbnRXaXRoaW5Qb2x5Z29ucyhwb2ludCwgcG9seWdvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwb2ludFdpdGhpblBvbHlnb24ocG9pbnQsIHBvbHlnb25zW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGVycCh2MSwgdjIpIHtcbiAgICByZXR1cm4gdjFbMF0gKiB2MlsxXSAtIHYxWzFdICogdjJbMF07XG59XG5mdW5jdGlvbiB0d29TaWRlZChwMSwgcDIsIHExLCBxMikge1xuICAgIHZhciB4MSA9IHAxWzBdIC0gcTFbMF07XG4gICAgdmFyIHkxID0gcDFbMV0gLSBxMVsxXTtcbiAgICB2YXIgeDIgPSBwMlswXSAtIHExWzBdO1xuICAgIHZhciB5MiA9IHAyWzFdIC0gcTFbMV07XG4gICAgdmFyIHgzID0gcTJbMF0gLSBxMVswXTtcbiAgICB2YXIgeTMgPSBxMlsxXSAtIHExWzFdO1xuICAgIHZhciBkZXQxID0geDEgKiB5MyAtIHgzICogeTE7XG4gICAgdmFyIGRldDIgPSB4MiAqIHkzIC0geDMgKiB5MjtcbiAgICBpZiAoZGV0MSA+IDAgJiYgZGV0MiA8IDAgfHwgZGV0MSA8IDAgJiYgZGV0MiA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RMaW5lKGEsIGIsIGMsIGQpIHtcbiAgICB2YXIgdmVjdG9yUCA9IFtcbiAgICAgICAgYlswXSAtIGFbMF0sXG4gICAgICAgIGJbMV0gLSBhWzFdXG4gICAgXTtcbiAgICB2YXIgdmVjdG9yUSA9IFtcbiAgICAgICAgZFswXSAtIGNbMF0sXG4gICAgICAgIGRbMV0gLSBjWzFdXG4gICAgXTtcbiAgICBpZiAocGVycCh2ZWN0b3JRLCB2ZWN0b3JQKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0d29TaWRlZChhLCBiLCBjLCBkKSAmJiB0d29TaWRlZChjLCBkLCBhLCBiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbGluZUludGVyc2VjdFBvbHlnb24ocDEsIHAyLCBwb2x5Z29uKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwb2x5Z29uOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmluZyA9IGxpc3RbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGggLSAxOyArK2opIHtcbiAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0TGluZShwMSwgcDIsIHJpbmdbal0sIHJpbmdbaiArIDFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHBvbHlnb24pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCFwb2ludFdpdGhpblBvbHlnb24obGluZVtpXSwgcG9seWdvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsaW5lLmxlbmd0aCAtIDE7ICsraSQxKSB7XG4gICAgICAgIGlmIChsaW5lSW50ZXJzZWN0UG9seWdvbihsaW5lW2kkMV0sIGxpbmVbaSQxICsgMV0sIHBvbHlnb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaW5lU3RyaW5nV2l0aGluUG9seWdvbnMobGluZSwgcG9seWdvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lU3RyaW5nV2l0aGluUG9seWdvbihsaW5lLCBwb2x5Z29uc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFRpbGVQb2x5Z29uKGNvb3JkaW5hdGVzLCBiYm94LCBjYW5vbmljYWwpIHtcbiAgICB2YXIgcG9seWdvbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb29yZGluYXRlc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gZ2V0VGlsZUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzW2ldW2pdLCBjYW5vbmljYWwpO1xuICAgICAgICAgICAgdXBkYXRlQkJveChiYm94LCBjb29yZCk7XG4gICAgICAgICAgICByaW5nLnB1c2goY29vcmQpO1xuICAgICAgICB9XG4gICAgICAgIHBvbHlnb24ucHVzaChyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlnb247XG59XG5mdW5jdGlvbiBnZXRUaWxlUG9seWdvbnMoY29vcmRpbmF0ZXMsIGJib3gsIGNhbm9uaWNhbCkge1xuICAgIHZhciBwb2x5Z29ucyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBnZXRUaWxlUG9seWdvbihjb29yZGluYXRlc1tpXSwgYmJveCwgY2Fub25pY2FsKTtcbiAgICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlnb25zO1xufVxuZnVuY3Rpb24gdXBkYXRlUG9pbnQocCwgYmJveCwgcG9seUJCb3gsIHdvcmxkU2l6ZSkge1xuICAgIGlmIChwWzBdIDwgcG9seUJCb3hbMF0gfHwgcFswXSA+IHBvbHlCQm94WzJdKSB7XG4gICAgICAgIHZhciBoYWxmV29ybGRTaXplID0gd29ybGRTaXplICogMC41O1xuICAgICAgICB2YXIgc2hpZnQgPSBwWzBdIC0gcG9seUJCb3hbMF0gPiBoYWxmV29ybGRTaXplID8gLXdvcmxkU2l6ZSA6IHBvbHlCQm94WzBdIC0gcFswXSA+IGhhbGZXb3JsZFNpemUgPyB3b3JsZFNpemUgOiAwO1xuICAgICAgICBpZiAoc2hpZnQgPT09IDApIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gcFswXSAtIHBvbHlCQm94WzJdID4gaGFsZldvcmxkU2l6ZSA/IC13b3JsZFNpemUgOiBwb2x5QkJveFsyXSAtIHBbMF0gPiBoYWxmV29ybGRTaXplID8gd29ybGRTaXplIDogMDtcbiAgICAgICAgfVxuICAgICAgICBwWzBdICs9IHNoaWZ0O1xuICAgIH1cbiAgICB1cGRhdGVCQm94KGJib3gsIHApO1xufVxuZnVuY3Rpb24gcmVzZXRCQm94KGJib3gpIHtcbiAgICBiYm94WzBdID0gYmJveFsxXSA9IEluZmluaXR5O1xuICAgIGJib3hbMl0gPSBiYm94WzNdID0gLUluZmluaXR5O1xufVxuZnVuY3Rpb24gZ2V0VGlsZVBvaW50cyhnZW9tZXRyeSwgcG9pbnRCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKSB7XG4gICAgdmFyIHdvcmxkU2l6ZSA9IE1hdGgucG93KDIsIGNhbm9uaWNhbC56KSAqIEVYVEVOVDtcbiAgICB2YXIgc2hpZnRzID0gW1xuICAgICAgICBjYW5vbmljYWwueCAqIEVYVEVOVCxcbiAgICAgICAgY2Fub25pY2FsLnkgKiBFWFRFTlRcbiAgICBdO1xuICAgIHZhciB0aWxlUG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZ2VvbWV0cnk7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBsaXN0JDFbaSQxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwb2ludHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBsaXN0W2ldO1xuICAgICAgICAgICAgdmFyIHAgPSBbXG4gICAgICAgICAgICAgICAgcG9pbnQueCArIHNoaWZ0c1swXSxcbiAgICAgICAgICAgICAgICBwb2ludC55ICsgc2hpZnRzWzFdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdXBkYXRlUG9pbnQocCwgcG9pbnRCQm94LCBwb2x5QkJveCwgd29ybGRTaXplKTtcbiAgICAgICAgICAgIHRpbGVQb2ludHMucHVzaChwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlsZVBvaW50cztcbn1cbmZ1bmN0aW9uIGdldFRpbGVMaW5lcyhnZW9tZXRyeSwgbGluZUJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpIHtcbiAgICB2YXIgd29ybGRTaXplID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopICogRVhURU5UO1xuICAgIHZhciBzaGlmdHMgPSBbXG4gICAgICAgIGNhbm9uaWNhbC54ICogRVhURU5ULFxuICAgICAgICBjYW5vbmljYWwueSAqIEVYVEVOVFxuICAgIF07XG4gICAgdmFyIHRpbGVMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGdlb21ldHJ5OyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgbGluZSA9IGxpc3QkMVtpJDFdO1xuICAgICAgICB2YXIgdGlsZUxpbmUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBsaW5lOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgICAgIHBvaW50LnggKyBzaGlmdHNbMF0sXG4gICAgICAgICAgICAgICAgcG9pbnQueSArIHNoaWZ0c1sxXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHVwZGF0ZUJCb3gobGluZUJCb3gsIHApO1xuICAgICAgICAgICAgdGlsZUxpbmUucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgICB0aWxlTGluZXMucHVzaCh0aWxlTGluZSk7XG4gICAgfVxuICAgIGlmIChsaW5lQkJveFsyXSAtIGxpbmVCQm94WzBdIDw9IHdvcmxkU2l6ZSAvIDIpIHtcbiAgICAgICAgcmVzZXRCQm94KGxpbmVCQm94KTtcbiAgICAgICAgZm9yICh2YXIgaSQzID0gMCwgbGlzdCQzID0gdGlsZUxpbmVzOyBpJDMgPCBsaXN0JDMubGVuZ3RoOyBpJDMgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGxpbmUkMSA9IGxpc3QkM1tpJDNdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMCwgbGlzdCQyID0gbGluZSQxOyBpJDIgPCBsaXN0JDIubGVuZ3RoOyBpJDIgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBwJDEgPSBsaXN0JDJbaSQyXTtcbiAgICAgICAgICAgICAgICB1cGRhdGVQb2ludChwJDEsIGxpbmVCQm94LCBwb2x5QkJveCwgd29ybGRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlsZUxpbmVzO1xufVxuZnVuY3Rpb24gcG9pbnRzV2l0aGluUG9seWdvbnMoY3R4LCBwb2x5Z29uR2VvbWV0cnkpIHtcbiAgICB2YXIgcG9pbnRCQm94ID0gW1xuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIC1JbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5XG4gICAgXTtcbiAgICB2YXIgcG9seUJCb3ggPSBbXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5LFxuICAgICAgICAtSW5maW5pdHlcbiAgICBdO1xuICAgIHZhciBjYW5vbmljYWwgPSBjdHguY2Fub25pY2FsSUQoKTtcbiAgICBpZiAocG9seWdvbkdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICB2YXIgdGlsZVBvbHlnb24gPSBnZXRUaWxlUG9seWdvbihwb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICB2YXIgdGlsZVBvaW50cyA9IGdldFRpbGVQb2ludHMoY3R4Lmdlb21ldHJ5KCksIHBvaW50QkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIGlmICghYm94V2l0aGluQm94KHBvaW50QkJveCwgcG9seUJCb3gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aWxlUG9pbnRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmICghcG9pbnRXaXRoaW5Qb2x5Z29uKHBvaW50LCB0aWxlUG9seWdvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICB2YXIgdGlsZVBvbHlnb25zID0gZ2V0VGlsZVBvbHlnb25zKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIHZhciB0aWxlUG9pbnRzJDEgPSBnZXRUaWxlUG9pbnRzKGN0eC5nZW9tZXRyeSgpLCBwb2ludEJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICBpZiAoIWJveFdpdGhpbkJveChwb2ludEJCb3gsIHBvbHlCQm94KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHRpbGVQb2ludHMkMTsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCQxID0gbGlzdCQxW2kkMV07XG4gICAgICAgICAgICBpZiAoIXBvaW50V2l0aGluUG9seWdvbnMocG9pbnQkMSwgdGlsZVBvbHlnb25zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGxpbmVzV2l0aGluUG9seWdvbnMoY3R4LCBwb2x5Z29uR2VvbWV0cnkpIHtcbiAgICB2YXIgbGluZUJCb3ggPSBbXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5LFxuICAgICAgICAtSW5maW5pdHlcbiAgICBdO1xuICAgIHZhciBwb2x5QkJveCA9IFtcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICAtSW5maW5pdHksXG4gICAgICAgIC1JbmZpbml0eVxuICAgIF07XG4gICAgdmFyIGNhbm9uaWNhbCA9IGN0eC5jYW5vbmljYWxJRCgpO1xuICAgIGlmIChwb2x5Z29uR2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIHZhciB0aWxlUG9seWdvbiA9IGdldFRpbGVQb2x5Z29uKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIHZhciB0aWxlTGluZXMgPSBnZXRUaWxlTGluZXMoY3R4Lmdlb21ldHJ5KCksIGxpbmVCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICAgICAgaWYgKCFib3hXaXRoaW5Cb3gobGluZUJCb3gsIHBvbHlCQm94KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGlsZUxpbmVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKCFsaW5lU3RyaW5nV2l0aGluUG9seWdvbihsaW5lLCB0aWxlUG9seWdvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICB2YXIgdGlsZVBvbHlnb25zID0gZ2V0VGlsZVBvbHlnb25zKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIHZhciB0aWxlTGluZXMkMSA9IGdldFRpbGVMaW5lcyhjdHguZ2VvbWV0cnkoKSwgbGluZUJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICBpZiAoIWJveFdpdGhpbkJveChsaW5lQkJveCwgcG9seUJCb3gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gdGlsZUxpbmVzJDE7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbGluZSQxID0gbGlzdCQxW2kkMV07XG4gICAgICAgICAgICBpZiAoIWxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29ucyhsaW5lJDEsIHRpbGVQb2x5Z29ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG52YXIgV2l0aGluID0gZnVuY3Rpb24gV2l0aGluKGdlb2pzb24sIGdlb21ldHJpZXMpIHtcbiAgICB0aGlzLnR5cGUgPSBCb29sZWFuVHlwZTtcbiAgICB0aGlzLmdlb2pzb24gPSBnZW9qc29uO1xuICAgIHRoaXMuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG59O1xuV2l0aGluLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignXFwnd2l0aGluXFwnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIGJ1dCBmb3VuZCAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmIChpc1ZhbHVlKGFyZ3NbMV0pKSB7XG4gICAgICAgIHZhciBnZW9qc29uID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBnZW9qc29uLmZlYXR1cmVzW2ldLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdQb2x5Z29uJyB8fCB0eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdpdGhpbihnZW9qc29uLCBnZW9qc29uLmZlYXR1cmVzW2ldLmdlb21ldHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgICAgIHZhciB0eXBlJDEgPSBnZW9qc29uLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSQxID09PSAnUG9seWdvbicgfHwgdHlwZSQxID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24uZ2VvbWV0cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb2pzb24udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdcXCd3aXRoaW5cXCcgZXhwcmVzc2lvbiByZXF1aXJlcyB2YWxpZCBnZW9qc29uIG9iamVjdCB0aGF0IGNvbnRhaW5zIHBvbHlnb24gZ2VvbWV0cnkgdHlwZS4nKTtcbn07XG5XaXRoaW4ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgaWYgKGN0eC5nZW9tZXRyeSgpICE9IG51bGwgJiYgY3R4LmNhbm9uaWNhbElEKCkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY3R4Lmdlb21ldHJ5VHlwZSgpID09PSAnUG9pbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzV2l0aGluUG9seWdvbnMoY3R4LCB0aGlzLmdlb21ldHJpZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZXNXaXRoaW5Qb2x5Z29ucyhjdHgsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbldpdGhpbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKCkge1xufTtcbldpdGhpbi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuV2l0aGluLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ3dpdGhpbicsXG4gICAgICAgIHRoaXMuZ2VvanNvblxuICAgIF07XG59O1xuXG5mdW5jdGlvbiBpc0ZlYXR1cmVDb25zdGFudChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ2dldCcgJiYgZS5hcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ2ZlYXR1cmUtc3RhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnaGFzJyAmJiBlLmFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAncHJvcGVydGllcycgfHwgZS5uYW1lID09PSAnZ2VvbWV0cnktdHlwZScgfHwgZS5uYW1lID09PSAnaWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoL15maWx0ZXItLy50ZXN0KGUubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZSBpbnN0YW5jZW9mIFdpdGhpbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIGUuZWFjaENoaWxkKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNGZWF0dXJlQ29uc3RhbnQoYXJnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNTdGF0ZUNvbnN0YW50KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZS5uYW1lID09PSAnZmVhdHVyZS1zdGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBlLmVhY2hDaGlsZChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgIWlzU3RhdGVDb25zdGFudChhcmcpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoZSwgcHJvcGVydGllcykge1xuICAgIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIHByb3BlcnRpZXMuaW5kZXhPZihlLm5hbWUpID49IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBlLmVhY2hDaGlsZChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgIWlzR2xvYmFsUHJvcGVydHlDb25zdGFudChhcmcsIHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBWYXIgPSBmdW5jdGlvbiBWYXIobmFtZSwgYm91bmRFeHByZXNzaW9uKSB7XG4gICAgdGhpcy50eXBlID0gYm91bmRFeHByZXNzaW9uLnR5cGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmJvdW5kRXhwcmVzc2lvbiA9IGJvdW5kRXhwcmVzc2lvbjtcbn07XG5WYXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyIHx8IHR5cGVvZiBhcmdzWzFdICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignXFwndmFyXFwnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RyaW5nIGxpdGVyYWwgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBuYW1lID0gYXJnc1sxXTtcbiAgICBpZiAoIWNvbnRleHQuc2NvcGUuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdVbmtub3duIHZhcmlhYmxlIFwiJyArIG5hbWUgKyAnXCIuIE1ha2Ugc3VyZSBcIicgKyBuYW1lICsgJ1wiIGhhcyBiZWVuIGJvdW5kIGluIGFuIGVuY2xvc2luZyBcImxldFwiIGV4cHJlc3Npb24gYmVmb3JlIHVzaW5nIGl0LicsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZhcihuYW1lLCBjb250ZXh0LnNjb3BlLmdldChuYW1lKSk7XG59O1xuVmFyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHJldHVybiB0aGlzLmJvdW5kRXhwcmVzc2lvbi5ldmFsdWF0ZShjdHgpO1xufTtcblZhci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKCkge1xufTtcblZhci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblZhci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICd2YXInLFxuICAgICAgICB0aGlzLm5hbWVcbiAgICBdO1xufTtcblxudmFyIFBhcnNpbmdDb250ZXh0ID0gZnVuY3Rpb24gUGFyc2luZ0NvbnRleHQocmVnaXN0cnksIHBhdGgsIGV4cGVjdGVkVHlwZSwgc2NvcGUsIGVycm9ycykge1xuICAgIGlmIChwYXRoID09PSB2b2lkIDApXG4gICAgICAgIHBhdGggPSBbXTtcbiAgICBpZiAoc2NvcGUgPT09IHZvaWQgMClcbiAgICAgICAgc2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICBpZiAoZXJyb3JzID09PSB2b2lkIDApXG4gICAgICAgIGVycm9ycyA9IFtdO1xuICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMua2V5ID0gcGF0aC5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuICdbJyArIHBhcnQgKyAnXSc7XG4gICAgfSkuam9pbignJyk7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMuZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlO1xufTtcblBhcnNpbmdDb250ZXh0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGV4cHIsIGluZGV4LCBleHBlY3RlZFR5cGUsIGJpbmRpbmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMClcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIGlmIChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQoaW5kZXgsIGV4cGVjdGVkVHlwZSwgYmluZGluZ3MpLl9wYXJzZShleHByLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlKGV4cHIsIG9wdGlvbnMpO1xufTtcblBhcnNpbmdDb250ZXh0LnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbiBfcGFyc2UoZXhwciwgb3B0aW9ucykge1xuICAgIGlmIChleHByID09PSBudWxsIHx8IHR5cGVvZiBleHByID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZXhwciA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBleHByID09PSAnbnVtYmVyJykge1xuICAgICAgICBleHByID0gW1xuICAgICAgICAgICAgJ2xpdGVyYWwnLFxuICAgICAgICAgICAgZXhwclxuICAgICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbm5vdGF0ZShwYXJzZWQsIHR5cGUsIHR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlQW5ub3RhdGlvbiA9PT0gJ2Fzc2VydCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHR5cGUsIFtwYXJzZWRdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlQW5ub3RhdGlvbiA9PT0gJ2NvZXJjZScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29lcmNpb24odHlwZSwgW3BhcnNlZF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShleHByKSkge1xuICAgICAgICBpZiAoZXhwci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50LiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgW11dLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IGV4cHJbMF07XG4gICAgICAgIGlmICh0eXBlb2Ygb3AgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCdFeHByZXNzaW9uIG5hbWUgbXVzdCBiZSBhIHN0cmluZywgYnV0IGZvdW5kICcgKyB0eXBlb2Ygb3AgKyAnIGluc3RlYWQuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uJywgMCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgRXhwciA9IHRoaXMucmVnaXN0cnlbb3BdO1xuICAgICAgICBpZiAoRXhwcikge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IEV4cHIucGFyc2UoZXhwciwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gdGhpcy5leHBlY3RlZFR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbCA9IHBhcnNlZC50eXBlO1xuICAgICAgICAgICAgICAgIGlmICgoZXhwZWN0ZWQua2luZCA9PT0gJ3N0cmluZycgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ251bWJlcicgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ2Jvb2xlYW4nIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdvYmplY3QnIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdhcnJheScpICYmIGFjdHVhbC5raW5kID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGFubm90YXRlKHBhcnNlZCwgZXhwZWN0ZWQsIG9wdGlvbnMudHlwZUFubm90YXRpb24gfHwgJ2Fzc2VydCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGV4cGVjdGVkLmtpbmQgPT09ICdjb2xvcicgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ2Zvcm1hdHRlZCcgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSAmJiAoYWN0dWFsLmtpbmQgPT09ICd2YWx1ZScgfHwgYWN0dWFsLmtpbmQgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBhbm5vdGF0ZShwYXJzZWQsIGV4cGVjdGVkLCBvcHRpb25zLnR5cGVBbm5vdGF0aW9uIHx8ICdjb2VyY2UnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCBhY3R1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHBhcnNlZCBpbnN0YW5jZW9mIExpdGVyYWwpICYmIHBhcnNlZC50eXBlLmtpbmQgIT09ICdyZXNvbHZlZEltYWdlJyAmJiBpc0NvbnN0YW50KHBhcnNlZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWMgPSBuZXcgRXZhbHVhdGlvbkNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBuZXcgTGl0ZXJhbChwYXJzZWQudHlwZSwgcGFyc2VkLmV2YWx1YXRlKGVjKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1Vua25vd24gZXhwcmVzc2lvbiBcIicgKyBvcCArICdcIi4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS4nLCAwKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignXFwndW5kZWZpbmVkXFwnIHZhbHVlIGludmFsaWQuIFVzZSBudWxsIGluc3RlYWQuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0JhcmUgb2JqZWN0cyBpbnZhbGlkLiBVc2UgW1wibGl0ZXJhbFwiLCB7Li4ufV0gaW5zdGVhZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCBmb3VuZCAnICsgdHlwZW9mIGV4cHIgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxufTtcblBhcnNpbmdDb250ZXh0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQoaW5kZXgsIGV4cGVjdGVkVHlwZSwgYmluZGluZ3MpIHtcbiAgICB2YXIgcGF0aCA9IHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgPyB0aGlzLnBhdGguY29uY2F0KGluZGV4KSA6IHRoaXMucGF0aDtcbiAgICB2YXIgc2NvcGUgPSBiaW5kaW5ncyA/IHRoaXMuc2NvcGUuY29uY2F0KGJpbmRpbmdzKSA6IHRoaXMuc2NvcGU7XG4gICAgcmV0dXJuIG5ldyBQYXJzaW5nQ29udGV4dCh0aGlzLnJlZ2lzdHJ5LCBwYXRoLCBleHBlY3RlZFR5cGUgfHwgbnVsbCwgc2NvcGUsIHRoaXMuZXJyb3JzKTtcbn07XG5QYXJzaW5nQ29udGV4dC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlcnJvciQxKSB7XG4gICAgdmFyIGtleXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGxlbi0tID4gMClcbiAgICAgICAga2V5c1tsZW5dID0gYXJndW1lbnRzW2xlbiArIDFdO1xuICAgIHZhciBrZXkgPSAnJyArIHRoaXMua2V5ICsga2V5cy5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuICdbJyArIGsgKyAnXSc7XG4gICAgfSkuam9pbignJyk7XG4gICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2luZ0Vycm9yKGtleSwgZXJyb3IkMSkpO1xufTtcblBhcnNpbmdDb250ZXh0LnByb3RvdHlwZS5jaGVja1N1YnR5cGUgPSBmdW5jdGlvbiBjaGVja1N1YnR5cGUkMShleHBlY3RlZCwgdCkge1xuICAgIHZhciBlcnJvciA9IGNoZWNrU3VidHlwZShleHBlY3RlZCwgdCk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59O1xuZnVuY3Rpb24gaXNDb25zdGFudChleHByZXNzaW9uKSB7XG4gICAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBWYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29uc3RhbnQoZXhwcmVzc2lvbi5ib3VuZEV4cHJlc3Npb24pO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbiAmJiBleHByZXNzaW9uLm5hbWUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIENvbGxhdG9yRXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgV2l0aGluKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGlzVHlwZUFubm90YXRpb24gPSBleHByZXNzaW9uIGluc3RhbmNlb2YgQ29lcmNpb24gfHwgZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFzc2VydGlvbjtcbiAgICB2YXIgY2hpbGRyZW5Db25zdGFudCA9IHRydWU7XG4gICAgZXhwcmVzc2lvbi5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChpc1R5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICBjaGlsZHJlbkNvbnN0YW50ID0gY2hpbGRyZW5Db25zdGFudCAmJiBpc0NvbnN0YW50KGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkcmVuQ29uc3RhbnQgPSBjaGlsZHJlbkNvbnN0YW50ICYmIGNoaWxkIGluc3RhbmNlb2YgTGl0ZXJhbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hpbGRyZW5Db25zdGFudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0ZlYXR1cmVDb25zdGFudChleHByZXNzaW9uKSAmJiBpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoZXhwcmVzc2lvbiwgW1xuICAgICAgICAnem9vbScsXG4gICAgICAgICdoZWF0bWFwLWRlbnNpdHknLFxuICAgICAgICAnbGluZS1wcm9ncmVzcycsXG4gICAgICAgICdhY2N1bXVsYXRlZCcsXG4gICAgICAgICdpcy1zdXBwb3J0ZWQtc2NyaXB0J1xuICAgIF0pO1xufVxuXG5mdW5jdGlvbiBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHN0b3BzLCBpbnB1dCkge1xuICAgIHZhciBsYXN0SW5kZXggPSBzdG9wcy5sZW5ndGggLSAxO1xuICAgIHZhciBsb3dlckluZGV4ID0gMDtcbiAgICB2YXIgdXBwZXJJbmRleCA9IGxhc3RJbmRleDtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gMDtcbiAgICB2YXIgY3VycmVudFZhbHVlLCBuZXh0VmFsdWU7XG4gICAgd2hpbGUgKGxvd2VySW5kZXggPD0gdXBwZXJJbmRleCkge1xuICAgICAgICBjdXJyZW50SW5kZXggPSBNYXRoLmZsb29yKChsb3dlckluZGV4ICsgdXBwZXJJbmRleCkgLyAyKTtcbiAgICAgICAgY3VycmVudFZhbHVlID0gc3RvcHNbY3VycmVudEluZGV4XTtcbiAgICAgICAgbmV4dFZhbHVlID0gc3RvcHNbY3VycmVudEluZGV4ICsgMV07XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgPD0gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IGxhc3RJbmRleCB8fCBpbnB1dCA8IG5leHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb3dlckluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPiBpbnB1dCkge1xuICAgICAgICAgICAgdXBwZXJJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdJbnB1dCBpcyBub3QgYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5cbnZhciBTdGVwID0gZnVuY3Rpb24gU3RlcCh0eXBlLCBpbnB1dCwgc3RvcHMpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RvcHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByZWYgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgbGFiZWwgPSByZWZbMF07XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcmVmWzFdO1xuICAgICAgICB0aGlzLmxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgfVxufTtcblN0ZXAucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIC0gMSA8IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnLicpO1xuICAgIH1cbiAgICBpZiAoKGFyZ3MubGVuZ3RoIC0gMSkgJSAyICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuJyk7XG4gICAgfVxuICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHN0b3BzID0gW107XG4gICAgdmFyIG91dHB1dFR5cGUgPSBudWxsO1xuICAgIGlmIChjb250ZXh0LmV4cGVjdGVkVHlwZSAmJiBjb250ZXh0LmV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGkgPT09IDEgPyAtSW5maW5pdHkgOiBhcmdzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgdmFyIGxhYmVsS2V5ID0gaTtcbiAgICAgICAgdmFyIHZhbHVlS2V5ID0gaSArIDE7XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcInN0ZXBcIiBleHByZXNzaW9ucyBtdXN0IGJlIGRlZmluZWQgdXNpbmcgbGl0ZXJhbCBudW1lcmljIHZhbHVlcyAobm90IGNvbXB1dGVkIGV4cHJlc3Npb25zKSBmb3IgdGhlIGlucHV0IHZhbHVlcy4nLCBsYWJlbEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3BzLmxlbmd0aCAmJiBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXVswXSA+PSBsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJzdGVwXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBhcnJhbmdlZCB3aXRoIGlucHV0IHZhbHVlcyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuJywgbGFiZWxLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCB2YWx1ZUtleSwgb3V0cHV0VHlwZSk7XG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCBwYXJzZWQudHlwZTtcbiAgICAgICAgc3RvcHMucHVzaChbXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIHBhcnNlZFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdGVwKG91dHB1dFR5cGUsIGlucHV0LCBzdG9wcyk7XG59O1xuU3RlcC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgbGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgdmFyIG91dHB1dHMgPSB0aGlzLm91dHB1dHM7XG4gICAgaWYgKGxhYmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgIGlmICh2YWx1ZSA8PSBsYWJlbHNbMF0pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gICAgdmFyIHN0b3BDb3VudCA9IGxhYmVscy5sZW5ndGg7XG4gICAgaWYgKHZhbHVlID49IGxhYmVsc1tzdG9wQ291bnQgLSAxXSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0c1tzdG9wQ291bnQgLSAxXS5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKGxhYmVscywgdmFsdWUpO1xuICAgIHJldHVybiBvdXRwdXRzW2luZGV4XS5ldmFsdWF0ZShjdHgpO1xufTtcblN0ZXAucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5vdXRwdXRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGxpc3RbaV07XG4gICAgICAgIGZuKGV4cHJlc3Npb24pO1xuICAgIH1cbn07XG5TdGVwLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSk7XG59O1xuU3RlcC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gW1xuICAgICAgICAnc3RlcCcsXG4gICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKClcbiAgICBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5sYWJlbHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm91dHB1dHNbaV0uc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDggQXBwbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgQVBQTEUgSU5DLiBgYEFTIElTJycgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICogUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIEFQUExFIElOQy4gT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZXG4gKiBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBQb3J0ZWQgZnJvbSBXZWJraXRcbiAqIGh0dHA6Ly9zdm4ud2Via2l0Lm9yZy9yZXBvc2l0b3J5L3dlYmtpdC90cnVuay9Tb3VyY2UvV2ViQ29yZS9wbGF0Zm9ybS9ncmFwaGljcy9Vbml0QmV6aWVyLmhcbiAqL1xuXG52YXIgdW5pdGJlemllciA9IFVuaXRCZXppZXI7XG5cbmZ1bmN0aW9uIFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cywgaW1wbGljaXQgZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHMgYXJlICgwLDApIGFuZCAoMSwxKS5cbiAgICB0aGlzLmN4ID0gMy4wICogcDF4O1xuICAgIHRoaXMuYnggPSAzLjAgKiAocDJ4IC0gcDF4KSAtIHRoaXMuY3g7XG4gICAgdGhpcy5heCA9IDEuMCAtIHRoaXMuY3ggLSB0aGlzLmJ4O1xuXG4gICAgdGhpcy5jeSA9IDMuMCAqIHAxeTtcbiAgICB0aGlzLmJ5ID0gMy4wICogKHAyeSAtIHAxeSkgLSB0aGlzLmN5O1xuICAgIHRoaXMuYXkgPSAxLjAgLSB0aGlzLmN5IC0gdGhpcy5ieTtcblxuICAgIHRoaXMucDF4ID0gcDF4O1xuICAgIHRoaXMucDF5ID0gcDJ5O1xuICAgIHRoaXMucDJ4ID0gcDJ4O1xuICAgIHRoaXMucDJ5ID0gcDJ5O1xufVxuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgLy8gYGF4IHReMyArIGJ4IHReMiArIGN4IHQnIGV4cGFuZGVkIHVzaW5nIEhvcm5lcidzIHJ1bGUuXG4gICAgcmV0dXJuICgodGhpcy5heCAqIHQgKyB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVkgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgodGhpcy5heSAqIHQgKyB0aGlzLmJ5KSAqIHQgKyB0aGlzLmN5KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAoMy4wICogdGhpcy5heCAqIHQgKyAyLjAgKiB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgaWYgKHR5cGVvZiBlcHNpbG9uID09PSAndW5kZWZpbmVkJykgeyBlcHNpbG9uID0gMWUtNjsgfVxuXG4gICAgdmFyIHQwLCB0MSwgdDIsIHgyLCBpO1xuXG4gICAgLy8gRmlyc3QgdHJ5IGEgZmV3IGl0ZXJhdGlvbnMgb2YgTmV3dG9uJ3MgbWV0aG9kIC0tIG5vcm1hbGx5IHZlcnkgZmFzdC5cbiAgICBmb3IgKHQyID0geCwgaSA9IDA7IGkgPCA4OyBpKyspIHtcblxuICAgICAgICB4MiA9IHRoaXMuc2FtcGxlQ3VydmVYKHQyKSAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MikgPCBlcHNpbG9uKSB7IHJldHVybiB0MjsgfVxuXG4gICAgICAgIHZhciBkMiA9IHRoaXMuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyhkMikgPCAxZS02KSB7IGJyZWFrOyB9XG5cbiAgICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGZvciByZWxpYWJpbGl0eS5cbiAgICB0MCA9IDAuMDtcbiAgICB0MSA9IDEuMDtcbiAgICB0MiA9IHg7XG5cbiAgICBpZiAodDIgPCB0MCkgeyByZXR1cm4gdDA7IH1cbiAgICBpZiAodDIgPiB0MSkgeyByZXR1cm4gdDE7IH1cblxuICAgIHdoaWxlICh0MCA8IHQxKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MiAtIHgpIDwgZXBzaWxvbikgeyByZXR1cm4gdDI7IH1cblxuICAgICAgICBpZiAoeCA+IHgyKSB7XG4gICAgICAgICAgICB0MCA9IHQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdDEgPSB0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHQyID0gKHQxIC0gdDApICogMC41ICsgdDA7XG4gICAgfVxuXG4gICAgLy8gRmFpbHVyZS5cbiAgICByZXR1cm4gdDI7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVDdXJ2ZVkodGhpcy5zb2x2ZUN1cnZlWCh4LCBlcHNpbG9uKSk7XG59O1xuXG5mdW5jdGlvbiBudW1iZXIoYSwgYiwgdCkge1xuICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xufVxuZnVuY3Rpb24gY29sb3IoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKG51bWJlcihmcm9tLnIsIHRvLnIsIHQpLCBudW1iZXIoZnJvbS5nLCB0by5nLCB0KSwgbnVtYmVyKGZyb20uYiwgdG8uYiwgdCksIG51bWJlcihmcm9tLmEsIHRvLmEsIHQpKTtcbn1cbmZ1bmN0aW9uIGFycmF5JDEoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gZnJvbS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcihkLCB0b1tpXSwgdCk7XG4gICAgfSk7XG59XG5cbnZhciBpbnRlcnBvbGF0ZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBudW1iZXI6IG51bWJlcixcbiAgY29sb3I6IGNvbG9yLFxuICBhcnJheTogYXJyYXkkMVxufSk7XG5cbnZhciBYbiA9IDAuOTUwNDcsIFluID0gMSwgWm4gPSAxLjA4ODgzLCB0MCA9IDQgLyAyOSwgdDEgPSA2IC8gMjksIHQyID0gMyAqIHQxICogdDEsIHQzID0gdDEgKiB0MSAqIHQxLCBkZWcycmFkID0gTWF0aC5QSSAvIDE4MCwgcmFkMmRlZyA9IDE4MCAvIE1hdGguUEk7XG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG59XG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cbmZ1bmN0aW9uIHh5ejJyZ2IoeCkge1xuICAgIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuZnVuY3Rpb24gcmdiMnh5eih4KSB7XG4gICAgeCAvPSAyNTU7XG4gICAgcmV0dXJuIHggPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5mdW5jdGlvbiByZ2JUb0xhYihyZ2JDb2xvcikge1xuICAgIHZhciBiID0gcmdiMnh5eihyZ2JDb2xvci5yKSwgYSA9IHJnYjJ4eXoocmdiQ29sb3IuZyksIGwgPSByZ2IyeHl6KHJnYkNvbG9yLmIpLCB4ID0geHl6MmxhYigoMC40MTI0NTY0ICogYiArIDAuMzU3NTc2MSAqIGEgKyAwLjE4MDQzNzUgKiBsKSAvIFhuKSwgeSA9IHh5ejJsYWIoKDAuMjEyNjcyOSAqIGIgKyAwLjcxNTE1MjIgKiBhICsgMC4wNzIxNzUgKiBsKSAvIFluKSwgeiA9IHh5ejJsYWIoKDAuMDE5MzMzOSAqIGIgKyAwLjExOTE5MiAqIGEgKyAwLjk1MDMwNDEgKiBsKSAvIFpuKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsOiAxMTYgKiB5IC0gMTYsXG4gICAgICAgIGE6IDUwMCAqICh4IC0geSksXG4gICAgICAgIGI6IDIwMCAqICh5IC0geiksXG4gICAgICAgIGFscGhhOiByZ2JDb2xvci5hXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxhYlRvUmdiKGxhYkNvbG9yKSB7XG4gICAgdmFyIHkgPSAobGFiQ29sb3IubCArIDE2KSAvIDExNiwgeCA9IGlzTmFOKGxhYkNvbG9yLmEpID8geSA6IHkgKyBsYWJDb2xvci5hIC8gNTAwLCB6ID0gaXNOYU4obGFiQ29sb3IuYikgPyB5IDogeSAtIGxhYkNvbG9yLmIgLyAyMDA7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih4eXoycmdiKDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeiksIHh5ejJyZ2IoLTAuOTY5MjY2ICogeCArIDEuODc2MDEwOCAqIHkgKyAwLjA0MTU1NiAqIHopLCB4eXoycmdiKDAuMDU1NjQzNCAqIHggLSAwLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeiksIGxhYkNvbG9yLmFscGhhKTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlTGFiKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbDogbnVtYmVyKGZyb20ubCwgdG8ubCwgdCksXG4gICAgICAgIGE6IG51bWJlcihmcm9tLmEsIHRvLmEsIHQpLFxuICAgICAgICBiOiBudW1iZXIoZnJvbS5iLCB0by5iLCB0KSxcbiAgICAgICAgYWxwaGE6IG51bWJlcihmcm9tLmFscGhhLCB0by5hbHBoYSwgdClcbiAgICB9O1xufVxuZnVuY3Rpb24gcmdiVG9IY2wocmdiQ29sb3IpIHtcbiAgICB2YXIgcmVmID0gcmdiVG9MYWIocmdiQ29sb3IpO1xuICAgIHZhciBsID0gcmVmLmw7XG4gICAgdmFyIGEgPSByZWYuYTtcbiAgICB2YXIgYiA9IHJlZi5iO1xuICAgIHZhciBoID0gTWF0aC5hdGFuMihiLCBhKSAqIHJhZDJkZWc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaDogaCA8IDAgPyBoICsgMzYwIDogaCxcbiAgICAgICAgYzogTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpLFxuICAgICAgICBsOiBsLFxuICAgICAgICBhbHBoYTogcmdiQ29sb3IuYVxuICAgIH07XG59XG5mdW5jdGlvbiBoY2xUb1JnYihoY2xDb2xvcikge1xuICAgIHZhciBoID0gaGNsQ29sb3IuaCAqIGRlZzJyYWQsIGMgPSBoY2xDb2xvci5jLCBsID0gaGNsQ29sb3IubDtcbiAgICByZXR1cm4gbGFiVG9SZ2Ioe1xuICAgICAgICBsOiBsLFxuICAgICAgICBhOiBNYXRoLmNvcyhoKSAqIGMsXG4gICAgICAgIGI6IE1hdGguc2luKGgpICogYyxcbiAgICAgICAgYWxwaGE6IGhjbENvbG9yLmFscGhhXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUh1ZShhLCBiLCB0KSB7XG4gICAgdmFyIGQgPSBiIC0gYTtcbiAgICByZXR1cm4gYSArIHQgKiAoZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCk7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUhjbChmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGg6IGludGVycG9sYXRlSHVlKGZyb20uaCwgdG8uaCwgdCksXG4gICAgICAgIGM6IG51bWJlcihmcm9tLmMsIHRvLmMsIHQpLFxuICAgICAgICBsOiBudW1iZXIoZnJvbS5sLCB0by5sLCB0KSxcbiAgICAgICAgYWxwaGE6IG51bWJlcihmcm9tLmFscGhhLCB0by5hbHBoYSwgdClcbiAgICB9O1xufVxudmFyIGxhYiA9IHtcbiAgICBmb3J3YXJkOiByZ2JUb0xhYixcbiAgICByZXZlcnNlOiBsYWJUb1JnYixcbiAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGVMYWJcbn07XG52YXIgaGNsID0ge1xuICAgIGZvcndhcmQ6IHJnYlRvSGNsLFxuICAgIHJldmVyc2U6IGhjbFRvUmdiLFxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZUhjbFxufTtcblxudmFyIGNvbG9yU3BhY2VzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGxhYjogbGFiLFxuICBoY2w6IGhjbFxufSk7XG5cbnZhciBJbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIEludGVycG9sYXRlKHR5cGUsIG9wZXJhdG9yLCBpbnRlcnBvbGF0aW9uLCBpbnB1dCwgc3RvcHMpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RvcHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByZWYgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgbGFiZWwgPSByZWZbMF07XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcmVmWzFdO1xuICAgICAgICB0aGlzLmxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgfVxufTtcbkludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IgPSBmdW5jdGlvbiBpbnRlcnBvbGF0aW9uRmFjdG9yKGludGVycG9sYXRpb24sIGlucHV0LCBsb3dlciwgdXBwZXIpIHtcbiAgICB2YXIgdCA9IDA7XG4gICAgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICB0ID0gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCBpbnRlcnBvbGF0aW9uLmJhc2UsIGxvd2VyLCB1cHBlcik7XG4gICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIHQgPSBleHBvbmVudGlhbEludGVycG9sYXRpb24oaW5wdXQsIDEsIGxvd2VyLCB1cHBlcik7XG4gICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdjdWJpYy1iZXppZXInKSB7XG4gICAgICAgIHZhciBjID0gaW50ZXJwb2xhdGlvbi5jb250cm9sUG9pbnRzO1xuICAgICAgICB2YXIgdWIgPSBuZXcgdW5pdGJlemllcihjWzBdLCBjWzFdLCBjWzJdLCBjWzNdKTtcbiAgICAgICAgdCA9IHViLnNvbHZlKGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgMSwgbG93ZXIsIHVwcGVyKSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcbkludGVycG9sYXRlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIHZhciBvcGVyYXRvciA9IGFyZ3NbMF07XG4gICAgdmFyIGludGVycG9sYXRpb24gPSBhcmdzWzFdO1xuICAgIHZhciBpbnB1dCA9IGFyZ3NbMl07XG4gICAgdmFyIHJlc3QgPSBhcmdzLnNsaWNlKDMpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnRlcnBvbGF0aW9uKSB8fCBpbnRlcnBvbGF0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYW4gaW50ZXJwb2xhdGlvbiB0eXBlIGV4cHJlc3Npb24uJywgMSk7XG4gICAgfVxuICAgIGlmIChpbnRlcnBvbGF0aW9uWzBdID09PSAnbGluZWFyJykge1xuICAgICAgICBpbnRlcnBvbGF0aW9uID0geyBuYW1lOiAnbGluZWFyJyB9O1xuICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvblswXSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICB2YXIgYmFzZSA9IGludGVycG9sYXRpb25bMV07XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGEgbnVtZXJpYyBiYXNlLicsIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGludGVycG9sYXRpb24gPSB7XG4gICAgICAgICAgICBuYW1lOiAnZXhwb25lbnRpYWwnLFxuICAgICAgICAgICAgYmFzZTogYmFzZVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvblswXSA9PT0gJ2N1YmljLWJlemllcicpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBpbnRlcnBvbGF0aW9uLnNsaWNlKDEpO1xuICAgICAgICBpZiAoY29udHJvbFBvaW50cy5sZW5ndGggIT09IDQgfHwgY29udHJvbFBvaW50cy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0ICE9PSAnbnVtYmVyJyB8fCB0IDwgMCB8fCB0ID4gMTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignQ3ViaWMgYmV6aWVyIGludGVycG9sYXRpb24gcmVxdWlyZXMgZm91ciBudW1lcmljIGFyZ3VtZW50cyB3aXRoIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuJywgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJwb2xhdGlvbiA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjdWJpYy1iZXppZXInLFxuICAgICAgICAgICAgY29udHJvbFBvaW50czogY29udHJvbFBvaW50c1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdVbmtub3duIGludGVycG9sYXRpb24gdHlwZSAnICsgU3RyaW5nKGludGVycG9sYXRpb25bMF0pLCAxLCAwKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoIC0gMSA8IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnLicpO1xuICAgIH1cbiAgICBpZiAoKGFyZ3MubGVuZ3RoIC0gMSkgJSAyICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuJyk7XG4gICAgfVxuICAgIGlucHV0ID0gY29udGV4dC5wYXJzZShpbnB1dCwgMiwgTnVtYmVyVHlwZSk7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHN0b3BzID0gW107XG4gICAgdmFyIG91dHB1dFR5cGUgPSBudWxsO1xuICAgIGlmIChvcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlLWhjbCcgfHwgb3BlcmF0b3IgPT09ICdpbnRlcnBvbGF0ZS1sYWInKSB7XG4gICAgICAgIG91dHB1dFR5cGUgPSBDb2xvclR5cGU7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0LmV4cGVjdGVkVHlwZSAmJiBjb250ZXh0LmV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IHJlc3RbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3RbaSArIDFdO1xuICAgICAgICB2YXIgbGFiZWxLZXkgPSBpICsgMztcbiAgICAgICAgdmFyIHZhbHVlS2V5ID0gaSArIDQ7XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgbGFiZWxLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wcy5sZW5ndGggJiYgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV1bMF0gPj0gbGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBtdXN0IGJlIGFycmFuZ2VkIHdpdGggaW5wdXQgdmFsdWVzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4nLCBsYWJlbEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnNlZCA9IGNvbnRleHQucGFyc2UodmFsdWUsIHZhbHVlS2V5LCBvdXRwdXRUeXBlKTtcbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHBhcnNlZC50eXBlO1xuICAgICAgICBzdG9wcy5wdXNoKFtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgcGFyc2VkXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAob3V0cHV0VHlwZS5raW5kICE9PSAnbnVtYmVyJyAmJiBvdXRwdXRUeXBlLmtpbmQgIT09ICdjb2xvcicgJiYgIShvdXRwdXRUeXBlLmtpbmQgPT09ICdhcnJheScgJiYgb3V0cHV0VHlwZS5pdGVtVHlwZS5raW5kID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb3V0cHV0VHlwZS5OID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1R5cGUgJyArIHRvU3RyaW5nKG91dHB1dFR5cGUpICsgJyBpcyBub3QgaW50ZXJwb2xhdGFibGUuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGUob3V0cHV0VHlwZSwgb3BlcmF0b3IsIGludGVycG9sYXRpb24sIGlucHV0LCBzdG9wcyk7XG59O1xuSW50ZXJwb2xhdGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgdmFyIGxhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgIHZhciBvdXRwdXRzID0gdGhpcy5vdXRwdXRzO1xuICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAodmFsdWUgPD0gbGFiZWxzWzBdKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICAgIHZhciBzdG9wQ291bnQgPSBsYWJlbHMubGVuZ3RoO1xuICAgIGlmICh2YWx1ZSA+PSBsYWJlbHNbc3RvcENvdW50IC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbc3RvcENvdW50IC0gMV0uZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhsYWJlbHMsIHZhbHVlKTtcbiAgICB2YXIgbG93ZXIgPSBsYWJlbHNbaW5kZXhdO1xuICAgIHZhciB1cHBlciA9IGxhYmVsc1tpbmRleCArIDFdO1xuICAgIHZhciB0ID0gSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvcih0aGlzLmludGVycG9sYXRpb24sIHZhbHVlLCBsb3dlciwgdXBwZXIpO1xuICAgIHZhciBvdXRwdXRMb3dlciA9IG91dHB1dHNbaW5kZXhdLmV2YWx1YXRlKGN0eCk7XG4gICAgdmFyIG91dHB1dFVwcGVyID0gb3V0cHV0c1tpbmRleCArIDFdLmV2YWx1YXRlKGN0eCk7XG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICdpbnRlcnBvbGF0ZScpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlW3RoaXMudHlwZS5raW5kLnRvTG93ZXJDYXNlKCldKG91dHB1dExvd2VyLCBvdXRwdXRVcHBlciwgdCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUtaGNsJykge1xuICAgICAgICByZXR1cm4gaGNsLnJldmVyc2UoaGNsLmludGVycG9sYXRlKGhjbC5mb3J3YXJkKG91dHB1dExvd2VyKSwgaGNsLmZvcndhcmQob3V0cHV0VXBwZXIpLCB0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxhYi5yZXZlcnNlKGxhYi5pbnRlcnBvbGF0ZShsYWIuZm9yd2FyZChvdXRwdXRMb3dlciksIGxhYi5mb3J3YXJkKG91dHB1dFVwcGVyKSwgdCkpO1xuICAgIH1cbn07XG5JbnRlcnBvbGF0ZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5pbnB1dCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLm91dHB1dHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gbGlzdFtpXTtcbiAgICAgICAgZm4oZXhwcmVzc2lvbik7XG4gICAgfVxufTtcbkludGVycG9sYXRlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSk7XG59O1xuSW50ZXJwb2xhdGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICB2YXIgaW50ZXJwb2xhdGlvbjtcbiAgICBpZiAodGhpcy5pbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGludGVycG9sYXRpb24gPSBbJ2xpbmVhciddO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5iYXNlID09PSAxKSB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uID0gWydsaW5lYXInXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycG9sYXRpb24gPSBbXG4gICAgICAgICAgICAgICAgJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb24uYmFzZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRpb24gPSBbJ2N1YmljLWJlemllciddLmNvbmNhdCh0aGlzLmludGVycG9sYXRpb24uY29udHJvbFBvaW50cyk7XG4gICAgfVxuICAgIHZhciBzZXJpYWxpemVkID0gW1xuICAgICAgICB0aGlzLm9wZXJhdG9yLFxuICAgICAgICBpbnRlcnBvbGF0aW9uLFxuICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXG4gICAgXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLmxhYmVsc1tpXSwgdGhpcy5vdXRwdXRzW2ldLnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuZnVuY3Rpb24gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCBiYXNlLCBsb3dlclZhbHVlLCB1cHBlclZhbHVlKSB7XG4gICAgdmFyIGRpZmZlcmVuY2UgPSB1cHBlclZhbHVlIC0gbG93ZXJWYWx1ZTtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBpbnB1dCAtIGxvd2VyVmFsdWU7XG4gICAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChiYXNlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwcm9ncmVzcyAvIGRpZmZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyhiYXNlLCBwcm9ncmVzcykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCBkaWZmZXJlbmNlKSAtIDEpO1xuICAgIH1cbn1cblxudmFyIENvYWxlc2NlID0gZnVuY3Rpb24gQ29hbGVzY2UodHlwZSwgYXJncykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbn07XG5Db2FsZXNjZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBvdXRwdXRUeXBlID0gbnVsbDtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG4gICAgaWYgKGV4cGVjdGVkVHlwZSAmJiBleHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICBvdXRwdXRUeXBlID0gZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICB2YXIgcGFyc2VkQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gYXJncy5zbGljZSgxKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGFyZyA9IGxpc3RbaV07XG4gICAgICAgIHZhciBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKGFyZywgMSArIHBhcnNlZEFyZ3MubGVuZ3RoLCBvdXRwdXRUeXBlLCB1bmRlZmluZWQsIHsgdHlwZUFubm90YXRpb246ICdvbWl0JyB9KTtcbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHBhcnNlZC50eXBlO1xuICAgICAgICBwYXJzZWRBcmdzLnB1c2gocGFyc2VkKTtcbiAgICB9XG4gICAgdmFyIG5lZWRzQW5ub3RhdGlvbiA9IGV4cGVjdGVkVHlwZSAmJiBwYXJzZWRBcmdzLnNvbWUoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gY2hlY2tTdWJ0eXBlKGV4cGVjdGVkVHlwZSwgYXJnLnR5cGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZWVkc0Fubm90YXRpb24gPyBuZXcgQ29hbGVzY2UoVmFsdWVUeXBlLCBwYXJzZWRBcmdzKSA6IG5ldyBDb2FsZXNjZShvdXRwdXRUeXBlLCBwYXJzZWRBcmdzKTtcbn07XG5Db2FsZXNjZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgYXJnQ291bnQgPSAwO1xuICAgIHZhciByZXF1ZXN0ZWRJbWFnZU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLmFyZ3M7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBhcmcgPSBsaXN0W2ldO1xuICAgICAgICBhcmdDb3VudCsrO1xuICAgICAgICByZXN1bHQgPSBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlICYmICFyZXN1bHQuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBpZiAoIXJlcXVlc3RlZEltYWdlTmFtZSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RlZEltYWdlTmFtZSA9IHJlc3VsdC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChhcmdDb3VudCA9PT0gdGhpcy5hcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcXVlc3RlZEltYWdlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbkNvYWxlc2NlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG59O1xuQ29hbGVzY2UucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnLm91dHB1dERlZmluZWQoKTtcbiAgICB9KTtcbn07XG5Db2FsZXNjZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gWydjb2FsZXNjZSddO1xuICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIExldCA9IGZ1bmN0aW9uIExldChiaW5kaW5ncywgcmVzdWx0KSB7XG4gICAgdGhpcy50eXBlID0gcmVzdWx0LnR5cGU7XG4gICAgdGhpcy5iaW5kaW5ncyA9IFtdLmNvbmNhdChiaW5kaW5ncyk7XG4gICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuTGV0LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5ldmFsdWF0ZShjdHgpO1xufTtcbkxldC5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLmJpbmRpbmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYmluZGluZyA9IGxpc3RbaV07XG4gICAgICAgIGZuKGJpbmRpbmdbMV0pO1xuICAgIH1cbiAgICBmbih0aGlzLnJlc3VsdCk7XG59O1xuTGV0LnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICB2YXIgYmluZGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIHZhciBuYW1lID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIHN0cmluZywgYnV0IGZvdW5kICcgKyB0eXBlb2YgbmFtZSArICcgaW5zdGVhZC4nLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL1teYS16QS1aMC05X10vLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdWYXJpYWJsZSBuYW1lcyBtdXN0IGNvbnRhaW4gb25seSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBvciBcXCdfXFwnLicsIGkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IGNvbnRleHQucGFyc2UoYXJnc1tpICsgMV0sIGkgKyAxKTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZ3MucHVzaChbXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbYXJncy5sZW5ndGggLSAxXSwgYXJncy5sZW5ndGggLSAxLCBjb250ZXh0LmV4cGVjdGVkVHlwZSwgYmluZGluZ3MpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExldChiaW5kaW5ncywgcmVzdWx0KTtcbn07XG5MZXQucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5vdXRwdXREZWZpbmVkKCk7XG59O1xuTGV0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2xldCddO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5iaW5kaW5nczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IGxpc3RbaV07XG4gICAgICAgIHZhciBuYW1lID0gcmVmWzBdO1xuICAgICAgICB2YXIgZXhwciA9IHJlZlsxXTtcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKG5hbWUsIGV4cHIuc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLnB1c2godGhpcy5yZXN1bHQuc2VyaWFsaXplKCkpO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIEF0ID0gZnVuY3Rpb24gQXQodHlwZSwgaW5kZXgsIGlucHV0KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xufTtcbkF0LnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgMiBhcmd1bWVudHMsIGJ1dCBmb3VuZCAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBhcnJheShjb250ZXh0LmV4cGVjdGVkVHlwZSB8fCBWYWx1ZVR5cGUpKTtcbiAgICBpZiAoIWluZGV4IHx8ICFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHQgPSBpbnB1dC50eXBlO1xuICAgIHJldHVybiBuZXcgQXQodC5pdGVtVHlwZSwgaW5kZXgsIGlucHV0KTtcbn07XG5BdC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4LmV2YWx1YXRlKGN0eCk7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kczogJyArIGluZGV4ICsgJyA8IDAuJyk7XG4gICAgfVxuICAgIGlmIChpbmRleCA+PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kczogJyArIGluZGV4ICsgJyA+ICcgKyAoYXJyYXkubGVuZ3RoIC0gMSkgKyAnLicpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IE1hdGguZmxvb3IoaW5kZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0FycmF5IGluZGV4IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGZvdW5kICcgKyBpbmRleCArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W2luZGV4XTtcbn07XG5BdC5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5pbmRleCk7XG4gICAgZm4odGhpcy5pbnB1dCk7XG59O1xuQXQucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5BdC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICdhdCcsXG4gICAgICAgIHRoaXMuaW5kZXguc2VyaWFsaXplKCksXG4gICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKClcbiAgICBdO1xufTtcblxudmFyIEluID0gZnVuY3Rpb24gSW4obmVlZGxlLCBoYXlzdGFjaykge1xuICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlO1xuICAgIHRoaXMubmVlZGxlID0gbmVlZGxlO1xuICAgIHRoaXMuaGF5c3RhY2sgPSBoYXlzdGFjaztcbn07XG5Jbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICB2YXIgbmVlZGxlID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgIHZhciBoYXlzdGFjayA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgVmFsdWVUeXBlKTtcbiAgICBpZiAoIW5lZWRsZSB8fCAhaGF5c3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFR5cGUobmVlZGxlLnR5cGUsIFtcbiAgICAgICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdWxsVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKG5lZWRsZS50eXBlKSArICcgaW5zdGVhZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEluKG5lZWRsZSwgaGF5c3RhY2spO1xufTtcbkluLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBuZWVkbGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShjdHgpO1xuICAgIHZhciBoYXlzdGFjayA9IHRoaXMuaGF5c3RhY2suZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAoIWhheXN0YWNrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShuZWVkbGUsIFtcbiAgICAgICAgICAgICdib29sZWFuJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAnbnVsbCdcbiAgICAgICAgXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZihuZWVkbGUpKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShoYXlzdGFjaywgW1xuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnYXJyYXknXG4gICAgICAgIF0pKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICcgKyB0b1N0cmluZyh0eXBlT2YoaGF5c3RhY2spKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKSA+PSAwO1xufTtcbkluLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLm5lZWRsZSk7XG4gICAgZm4odGhpcy5oYXlzdGFjayk7XG59O1xuSW4ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcbkluLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2luJyxcbiAgICAgICAgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksXG4gICAgICAgIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKClcbiAgICBdO1xufTtcblxudmFyIEluZGV4T2YgPSBmdW5jdGlvbiBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2ssIGZyb21JbmRleCkge1xuICAgIHRoaXMudHlwZSA9IE51bWJlclR5cGU7XG4gICAgdGhpcy5uZWVkbGUgPSBuZWVkbGU7XG4gICAgdGhpcy5oYXlzdGFjayA9IGhheXN0YWNrO1xuICAgIHRoaXMuZnJvbUluZGV4ID0gZnJvbUluZGV4O1xufTtcbkluZGV4T2YucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDIgfHwgYXJncy5sZW5ndGggPj0gNSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgdmFyIG5lZWRsZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTtcbiAgICB2YXIgaGF5c3RhY2sgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7XG4gICAgaWYgKCFuZWVkbGUgfHwgIWhheXN0YWNrKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRUeXBlKG5lZWRsZS50eXBlLCBbXG4gICAgICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVsbFR5cGUsXG4gICAgICAgICAgICBWYWx1ZVR5cGVcbiAgICAgICAgXSkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kICcgKyB0b1N0cmluZyhuZWVkbGUudHlwZSkgKyAnIGluc3RlYWQnKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSBjb250ZXh0LnBhcnNlKGFyZ3NbM10sIDMsIE51bWJlclR5cGUpO1xuICAgICAgICBpZiAoIWZyb21JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2ssIGZyb21JbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2spO1xuICAgIH1cbn07XG5JbmRleE9mLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBuZWVkbGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShjdHgpO1xuICAgIHZhciBoYXlzdGFjayA9IHRoaXMuaGF5c3RhY2suZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKG5lZWRsZSwgW1xuICAgICAgICAgICAgJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICdudWxsJ1xuICAgICAgICBdKSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodHlwZU9mKG5lZWRsZSkpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKGhheXN0YWNrLCBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdhcnJheSdcbiAgICAgICAgXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZihoYXlzdGFjaykpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IHRoaXMuZnJvbUluZGV4LmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKTtcbn07XG5JbmRleE9mLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLm5lZWRsZSk7XG4gICAgZm4odGhpcy5oYXlzdGFjayk7XG4gICAgaWYgKHRoaXMuZnJvbUluZGV4KSB7XG4gICAgICAgIGZuKHRoaXMuZnJvbUluZGV4KTtcbiAgICB9XG59O1xuSW5kZXhPZi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbkluZGV4T2YucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5mcm9tSW5kZXggIT0gbnVsbCAmJiB0aGlzLmZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSB0aGlzLmZyb21JbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdpbmRleC1vZicsXG4gICAgICAgICAgICB0aGlzLm5lZWRsZS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCksXG4gICAgICAgICAgICBmcm9tSW5kZXhcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2luZGV4LW9mJyxcbiAgICAgICAgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksXG4gICAgICAgIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKClcbiAgICBdO1xufTtcblxudmFyIE1hdGNoID0gZnVuY3Rpb24gTWF0Y2goaW5wdXRUeXBlLCBvdXRwdXRUeXBlLCBpbnB1dCwgY2FzZXMsIG91dHB1dHMsIG90aGVyd2lzZSkge1xuICAgIHRoaXMuaW5wdXRUeXBlID0gaW5wdXRUeXBlO1xuICAgIHRoaXMudHlwZSA9IG91dHB1dFR5cGU7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgIHRoaXMub3RoZXJ3aXNlID0gb3RoZXJ3aXNlO1xufTtcbk1hdGNoLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnLicpO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggJSAyICE9PSAxKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuJyk7XG4gICAgfVxuICAgIHZhciBpbnB1dFR5cGU7XG4gICAgdmFyIG91dHB1dFR5cGU7XG4gICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICB2YXIgY2FzZXMgPSB7fTtcbiAgICB2YXIgb3V0cHV0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IGFyZ3NbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbaSArIDFdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGFiZWxzKSkge1xuICAgICAgICAgICAgbGFiZWxzID0gW2xhYmVsc107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhYmVsQ29udGV4dCA9IGNvbnRleHQuY29uY2F0KGkpO1xuICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGJyYW5jaCBsYWJlbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gbGFiZWxzOyBpJDEgPCBsaXN0Lmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGxpc3RbaSQxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFiZWwgIT09ICdudW1iZXInICYmIHR5cGVvZiBsYWJlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKCdCcmFuY2ggbGFiZWxzIG11c3QgYmUgbnVtYmVycyBvciBzdHJpbmdzLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGFiZWwgPT09ICdudW1iZXInICYmIE1hdGguYWJzKGxhYmVsKSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignQnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXJzIG5vIGxhcmdlciB0aGFuICcgKyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiArICcuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ251bWJlcicgJiYgTWF0aC5mbG9vcihsYWJlbCkgIT09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignTnVtZXJpYyBicmFuY2ggbGFiZWxzIG11c3QgYmUgaW50ZWdlciB2YWx1ZXMuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFR5cGUgPSB0eXBlT2YobGFiZWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYWJlbENvbnRleHQuY2hlY2tTdWJ0eXBlKGlucHV0VHlwZSwgdHlwZU9mKGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FzZXNbU3RyaW5nKGxhYmVsKV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignQnJhbmNoIGxhYmVscyBtdXN0IGJlIHVuaXF1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2VzW1N0cmluZyhsYWJlbCldID0gb3V0cHV0cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UodmFsdWUsIGksIG91dHB1dFR5cGUpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcmVzdWx0LnR5cGU7XG4gICAgICAgIG91dHB1dHMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICB2YXIgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG90aGVyd2lzZSA9IGNvbnRleHQucGFyc2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBhcmdzLmxlbmd0aCAtIDEsIG91dHB1dFR5cGUpO1xuICAgIGlmICghb3RoZXJ3aXNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaW5wdXQudHlwZS5raW5kICE9PSAndmFsdWUnICYmIGNvbnRleHQuY29uY2F0KDEpLmNoZWNrU3VidHlwZShpbnB1dFR5cGUsIGlucHV0LnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1hdGNoKGlucHV0VHlwZSwgb3V0cHV0VHlwZSwgaW5wdXQsIGNhc2VzLCBvdXRwdXRzLCBvdGhlcndpc2UpO1xufTtcbk1hdGNoLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICB2YXIgb3V0cHV0ID0gdHlwZU9mKGlucHV0KSA9PT0gdGhpcy5pbnB1dFR5cGUgJiYgdGhpcy5vdXRwdXRzW3RoaXMuY2FzZXNbaW5wdXRdXSB8fCB0aGlzLm90aGVyd2lzZTtcbiAgICByZXR1cm4gb3V0cHV0LmV2YWx1YXRlKGN0eCk7XG59O1xuTWF0Y2gucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgIHRoaXMub3V0cHV0cy5mb3JFYWNoKGZuKTtcbiAgICBmbih0aGlzLm90aGVyd2lzZSk7XG59O1xuTWF0Y2gucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dHMuZXZlcnkoZnVuY3Rpb24gKG91dCkge1xuICAgICAgICByZXR1cm4gb3V0Lm91dHB1dERlZmluZWQoKTtcbiAgICB9KSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7XG59O1xuTWF0Y2gucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICB2YXIgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgJ21hdGNoJyxcbiAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKVxuICAgIF07XG4gICAgdmFyIHNvcnRlZExhYmVscyA9IE9iamVjdC5rZXlzKHRoaXMuY2FzZXMpLnNvcnQoKTtcbiAgICB2YXIgZ3JvdXBlZEJ5T3V0cHV0ID0gW107XG4gICAgdmFyIG91dHB1dExvb2t1cCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc29ydGVkTGFiZWxzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSBvdXRwdXRMb29rdXBbdGhpcy5jYXNlc1tsYWJlbF1dO1xuICAgICAgICBpZiAob3V0cHV0SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3V0cHV0TG9va3VwW3RoaXMuY2FzZXNbbGFiZWxdXSA9IGdyb3VwZWRCeU91dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICBncm91cGVkQnlPdXRwdXQucHVzaChbXG4gICAgICAgICAgICAgICAgdGhpcy5jYXNlc1tsYWJlbF0sXG4gICAgICAgICAgICAgICAgW2xhYmVsXVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncm91cGVkQnlPdXRwdXRbb3V0cHV0SW5kZXhdWzFdLnB1c2gobGFiZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjb2VyY2VMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcyQxLmlucHV0VHlwZS5raW5kID09PSAnbnVtYmVyJyA/IE51bWJlcihsYWJlbCkgOiBsYWJlbDtcbiAgICB9O1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGdyb3VwZWRCeU91dHB1dDsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IGxpc3QkMVtpJDFdO1xuICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSByZWZbMF07XG4gICAgICAgIHZhciBsYWJlbHMgPSByZWZbMV07XG4gICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goY29lcmNlTGFiZWwobGFiZWxzWzBdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2gobGFiZWxzLm1hcChjb2VyY2VMYWJlbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm91dHB1dHNbb3V0cHV0SW5kZXgkMV0uc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLnB1c2godGhpcy5vdGhlcndpc2Uuc2VyaWFsaXplKCkpO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIENhc2UgPSBmdW5jdGlvbiBDYXNlKHR5cGUsIGJyYW5jaGVzLCBvdGhlcndpc2UpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYnJhbmNoZXMgPSBicmFuY2hlcztcbiAgICB0aGlzLm90aGVyd2lzZSA9IG90aGVyd2lzZTtcbn07XG5DYXNlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnLicpO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhbiBvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cy4nKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dFR5cGU7XG4gICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICB2YXIgYnJhbmNoZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCBpLCBCb29sZWFuVHlwZSk7XG4gICAgICAgIGlmICghdGVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UoYXJnc1tpICsgMV0sIGkgKyAxLCBvdXRwdXRUeXBlKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyYW5jaGVzLnB1c2goW1xuICAgICAgICAgICAgdGVzdCxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICBdKTtcbiAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcmVzdWx0LnR5cGU7XG4gICAgfVxuICAgIHZhciBvdGhlcndpc2UgPSBjb250ZXh0LnBhcnNlKGFyZ3NbYXJncy5sZW5ndGggLSAxXSwgYXJncy5sZW5ndGggLSAxLCBvdXRwdXRUeXBlKTtcbiAgICBpZiAoIW90aGVyd2lzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDYXNlKG91dHB1dFR5cGUsIGJyYW5jaGVzLCBvdGhlcndpc2UpO1xufTtcbkNhc2UucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLmJyYW5jaGVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmVmID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIHRlc3QgPSByZWZbMF07XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcmVmWzFdO1xuICAgICAgICBpZiAodGVzdC5ldmFsdWF0ZShjdHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ldmFsdWF0ZShjdHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm90aGVyd2lzZS5ldmFsdWF0ZShjdHgpO1xufTtcbkNhc2UucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5icmFuY2hlczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IGxpc3RbaV07XG4gICAgICAgIHZhciB0ZXN0ID0gcmVmWzBdO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJlZlsxXTtcbiAgICAgICAgZm4odGVzdCk7XG4gICAgICAgIGZuKGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBmbih0aGlzLm90aGVyd2lzZSk7XG59O1xuQ2FzZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnJhbmNoZXMuZXZlcnkoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgXyA9IHJlZlswXTtcbiAgICAgICAgdmFyIG91dCA9IHJlZlsxXTtcbiAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSkgJiYgdGhpcy5vdGhlcndpc2Uub3V0cHV0RGVmaW5lZCgpO1xufTtcbkNhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9IFsnY2FzZSddO1xuICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIFNsaWNlID0gZnVuY3Rpb24gU2xpY2UodHlwZSwgaW5wdXQsIGJlZ2luSW5kZXgsIGVuZEluZGV4KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5iZWdpbkluZGV4ID0gYmVnaW5JbmRleDtcbiAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG59O1xuU2xpY2UucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDIgfHwgYXJncy5sZW5ndGggPj0gNSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgIHZhciBiZWdpbkluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBOdW1iZXJUeXBlKTtcbiAgICBpZiAoIWlucHV0IHx8ICFiZWdpbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRUeXBlKGlucHV0LnR5cGUsIFtcbiAgICAgICAgICAgIGFycmF5KFZhbHVlVHlwZSksXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0pKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICcgKyB0b1N0cmluZyhpbnB1dC50eXBlKSArICcgaW5zdGVhZCcpO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzNdLCAzLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFlbmRJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShpbnB1dC50eXBlLCBpbnB1dCwgYmVnaW5JbmRleCwgZW5kSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoaW5wdXQudHlwZSwgaW5wdXQsIGJlZ2luSW5kZXgpO1xuICAgIH1cbn07XG5TbGljZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7XG4gICAgdmFyIGJlZ2luSW5kZXggPSB0aGlzLmJlZ2luSW5kZXguZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKGlucHV0LCBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdhcnJheSdcbiAgICAgICAgXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodHlwZU9mKGlucHV0KSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVuZEluZGV4KSB7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHRoaXMuZW5kSW5kZXguZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKGJlZ2luSW5kZXgsIGVuZEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnNsaWNlKGJlZ2luSW5kZXgpO1xufTtcblNsaWNlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLmlucHV0KTtcbiAgICBmbih0aGlzLmJlZ2luSW5kZXgpO1xuICAgIGlmICh0aGlzLmVuZEluZGV4KSB7XG4gICAgICAgIGZuKHRoaXMuZW5kSW5kZXgpO1xuICAgIH1cbn07XG5TbGljZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblNsaWNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuZW5kSW5kZXggIT0gbnVsbCAmJiB0aGlzLmVuZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5lbmRJbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdzbGljZScsXG4gICAgICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgZW5kSW5kZXhcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ3NsaWNlJyxcbiAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSxcbiAgICAgICAgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpXG4gICAgXTtcbn07XG5cbmZ1bmN0aW9uIGlzQ29tcGFyYWJsZVR5cGUob3AsIHR5cGUpIHtcbiAgICBpZiAob3AgPT09ICc9PScgfHwgb3AgPT09ICchPScpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUua2luZCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGUua2luZCA9PT0gJ3N0cmluZycgfHwgdHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCB0eXBlLmtpbmQgPT09ICdudWxsJyB8fCB0eXBlLmtpbmQgPT09ICd2YWx1ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGUua2luZCA9PT0gJ3N0cmluZycgfHwgdHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCB0eXBlLmtpbmQgPT09ICd2YWx1ZSc7XG4gICAgfVxufVxuZnVuY3Rpb24gZXEoY3R4LCBhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5mdW5jdGlvbiBuZXEoY3R4LCBhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT09IGI7XG59XG5mdW5jdGlvbiBsdChjdHgsIGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGI7XG59XG5mdW5jdGlvbiBndChjdHgsIGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGI7XG59XG5mdW5jdGlvbiBsdGVxKGN0eCwgYSwgYikge1xuICAgIHJldHVybiBhIDw9IGI7XG59XG5mdW5jdGlvbiBndGVxKGN0eCwgYSwgYikge1xuICAgIHJldHVybiBhID49IGI7XG59XG5mdW5jdGlvbiBlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA9PT0gMDtcbn1cbmZ1bmN0aW9uIG5lcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gICAgcmV0dXJuICFlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKTtcbn1cbmZ1bmN0aW9uIGx0Q29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYy5jb21wYXJlKGEsIGIpIDwgMDtcbn1cbmZ1bmN0aW9uIGd0Q29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYy5jb21wYXJlKGEsIGIpID4gMDtcbn1cbmZ1bmN0aW9uIGx0ZXFDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPD0gMDtcbn1cbmZ1bmN0aW9uIGd0ZXFDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPj0gMDtcbn1cbmZ1bmN0aW9uIG1ha2VDb21wYXJpc29uKG9wLCBjb21wYXJlQmFzaWMsIGNvbXBhcmVXaXRoQ29sbGF0b3IpIHtcbiAgICB2YXIgaXNPcmRlckNvbXBhcmlzb24gPSBvcCAhPT0gJz09JyAmJiBvcCAhPT0gJyE9JztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb21wYXJpc29uKGxocywgcmhzLCBjb2xsYXRvcikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gQm9vbGVhblR5cGU7XG4gICAgICAgICAgICB0aGlzLmxocyA9IGxocztcbiAgICAgICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICAgICAgdGhpcy5jb2xsYXRvciA9IGNvbGxhdG9yO1xuICAgICAgICAgICAgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQgPSBsaHMudHlwZS5raW5kID09PSAndmFsdWUnIHx8IHJocy50eXBlLmtpbmQgPT09ICd2YWx1ZSc7XG4gICAgICAgIH1cbiAgICAgICAgQ29tcGFyaXNvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMyAmJiBhcmdzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCB0d28gb3IgdGhyZWUgYXJndW1lbnRzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wID0gYXJnc1swXTtcbiAgICAgICAgICAgIHZhciBsaHMgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWxocykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0NvbXBhcmFibGVUeXBlKG9wLCBsaHMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb25jYXQoMSkuZXJyb3IoJ1wiJyArIG9wICsgJ1wiIGNvbXBhcmlzb25zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlIFxcJycgKyB0b1N0cmluZyhsaHMudHlwZSkgKyAnXFwnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJocyA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgVmFsdWVUeXBlKTtcbiAgICAgICAgICAgIGlmICghcmhzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQ29tcGFyYWJsZVR5cGUob3AsIHJocy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmNhdCgyKS5lcnJvcignXCInICsgb3AgKyAnXCIgY29tcGFyaXNvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgXFwnJyArIHRvU3RyaW5nKHJocy50eXBlKSArICdcXCcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGhzLnR5cGUua2luZCAhPT0gcmhzLnR5cGUua2luZCAmJiBsaHMudHlwZS5raW5kICE9PSAndmFsdWUnICYmIHJocy50eXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignQ2Fubm90IGNvbXBhcmUgdHlwZXMgXFwnJyArIHRvU3RyaW5nKGxocy50eXBlKSArICdcXCcgYW5kIFxcJycgKyB0b1N0cmluZyhyaHMudHlwZSkgKyAnXFwnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzT3JkZXJDb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgPT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICBsaHMgPSBuZXcgQXNzZXJ0aW9uKHJocy50eXBlLCBbbGhzXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaHMudHlwZS5raW5kICE9PSAndmFsdWUnICYmIHJocy50eXBlLmtpbmQgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmhzID0gbmV3IEFzc2VydGlvbihsaHMudHlwZSwgW3Joc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xsYXRvciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGhzLnR5cGUua2luZCAhPT0gJ3N0cmluZycgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3N0cmluZycgJiYgbGhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJyAmJiByaHMudHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdDYW5ub3QgdXNlIGNvbGxhdG9yIHRvIGNvbXBhcmUgbm9uLXN0cmluZyB0eXBlcy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGF0b3IgPSBjb250ZXh0LnBhcnNlKGFyZ3NbM10sIDMsIENvbGxhdG9yVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb2xsYXRvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBhcmlzb24obGhzLCByaHMsIGNvbGxhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29tcGFyaXNvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgICAgICAgIHZhciBsaHMgPSB0aGlzLmxocy5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgdmFyIHJocyA9IHRoaXMucmhzLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBpZiAoaXNPcmRlckNvbXBhcmlzb24gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbHQgPSB0eXBlT2YobGhzKTtcbiAgICAgICAgICAgICAgICB2YXIgcnQgPSB0eXBlT2YocmhzKTtcbiAgICAgICAgICAgICAgICBpZiAobHQua2luZCAhPT0gcnQua2luZCB8fCAhKGx0LmtpbmQgPT09ICdzdHJpbmcnIHx8IGx0LmtpbmQgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdFeHBlY3RlZCBhcmd1bWVudHMgZm9yIFwiJyArIG9wICsgJ1wiIHRvIGJlIChzdHJpbmcsIHN0cmluZykgb3IgKG51bWJlciwgbnVtYmVyKSwgYnV0IGZvdW5kICgnICsgbHQua2luZCArICcsICcgKyBydC5raW5kICsgJykgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsYXRvciAmJiAhaXNPcmRlckNvbXBhcmlzb24gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbHQkMSA9IHR5cGVPZihsaHMpO1xuICAgICAgICAgICAgICAgIHZhciBydCQxID0gdHlwZU9mKHJocyk7XG4gICAgICAgICAgICAgICAgaWYgKGx0JDEua2luZCAhPT0gJ3N0cmluZycgfHwgcnQkMS5raW5kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZUJhc2ljKGN0eCwgbGhzLCByaHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxhdG9yID8gY29tcGFyZVdpdGhDb2xsYXRvcihjdHgsIGxocywgcmhzLCB0aGlzLmNvbGxhdG9yLmV2YWx1YXRlKGN0eCkpIDogY29tcGFyZUJhc2ljKGN0eCwgbGhzLCByaHMpO1xuICAgICAgICB9O1xuICAgICAgICBDb21wYXJpc29uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgICAgIGZuKHRoaXMubGhzKTtcbiAgICAgICAgICAgIGZuKHRoaXMucmhzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbGxhdG9yKSB7XG4gICAgICAgICAgICAgICAgZm4odGhpcy5jb2xsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIENvbXBhcmlzb24ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIENvbXBhcmlzb24ucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkID0gW29wXTtcbiAgICAgICAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChjaGlsZC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29tcGFyaXNvbjtcbiAgICB9KCk7XG59XG52YXIgRXF1YWxzID0gbWFrZUNvbXBhcmlzb24oJz09JywgZXEsIGVxQ29sbGF0ZSk7XG52YXIgTm90RXF1YWxzID0gbWFrZUNvbXBhcmlzb24oJyE9JywgbmVxLCBuZXFDb2xsYXRlKTtcbnZhciBMZXNzVGhhbiA9IG1ha2VDb21wYXJpc29uKCc8JywgbHQsIGx0Q29sbGF0ZSk7XG52YXIgR3JlYXRlclRoYW4gPSBtYWtlQ29tcGFyaXNvbignPicsIGd0LCBndENvbGxhdGUpO1xudmFyIExlc3NUaGFuT3JFcXVhbCA9IG1ha2VDb21wYXJpc29uKCc8PScsIGx0ZXEsIGx0ZXFDb2xsYXRlKTtcbnZhciBHcmVhdGVyVGhhbk9yRXF1YWwgPSBtYWtlQ29tcGFyaXNvbignPj0nLCBndGVxLCBndGVxQ29sbGF0ZSk7XG5cbnZhciBOdW1iZXJGb3JtYXQgPSBmdW5jdGlvbiBOdW1iZXJGb3JtYXQobnVtYmVyLCBsb2NhbGUsIGN1cnJlbmN5LCBtaW5GcmFjdGlvbkRpZ2l0cywgbWF4RnJhY3Rpb25EaWdpdHMpIHtcbiAgICB0aGlzLnR5cGUgPSBTdHJpbmdUeXBlO1xuICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgICB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID0gbWluRnJhY3Rpb25EaWdpdHM7XG4gICAgdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA9IG1heEZyYWN0aW9uRGlnaXRzO1xufTtcbk51bWJlckZvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIHR3byBhcmd1bWVudHMuJyk7XG4gICAgfVxuICAgIHZhciBudW1iZXIgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIE51bWJlclR5cGUpO1xuICAgIGlmICghbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3NbMl07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdOdW1iZXJGb3JtYXQgb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG4gICAgdmFyIGxvY2FsZSA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnNbJ2xvY2FsZSddKSB7XG4gICAgICAgIGxvY2FsZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbG9jYWxlJ10sIDEsIFN0cmluZ1R5cGUpO1xuICAgICAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGN1cnJlbmN5ID0gbnVsbDtcbiAgICBpZiAob3B0aW9uc1snY3VycmVuY3knXSkge1xuICAgICAgICBjdXJyZW5jeSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snY3VycmVuY3knXSwgMSwgU3RyaW5nVHlwZSk7XG4gICAgICAgIGlmICghY3VycmVuY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBtaW5GcmFjdGlvbkRpZ2l0cyA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnNbJ21pbi1mcmFjdGlvbi1kaWdpdHMnXSkge1xuICAgICAgICBtaW5GcmFjdGlvbkRpZ2l0cyA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbWluLWZyYWN0aW9uLWRpZ2l0cyddLCAxLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFtaW5GcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1heEZyYWN0aW9uRGlnaXRzID0gbnVsbDtcbiAgICBpZiAob3B0aW9uc1snbWF4LWZyYWN0aW9uLWRpZ2l0cyddKSB7XG4gICAgICAgIG1heEZyYWN0aW9uRGlnaXRzID0gY29udGV4dC5wYXJzZShvcHRpb25zWydtYXgtZnJhY3Rpb24tZGlnaXRzJ10sIDEsIE51bWJlclR5cGUpO1xuICAgICAgICBpZiAoIW1heEZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE51bWJlckZvcm1hdChudW1iZXIsIGxvY2FsZSwgY3VycmVuY3ksIG1pbkZyYWN0aW9uRGlnaXRzLCBtYXhGcmFjdGlvbkRpZ2l0cyk7XG59O1xuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZS5ldmFsdWF0ZShjdHgpIDogW10sIHtcbiAgICAgICAgc3R5bGU6IHRoaXMuY3VycmVuY3kgPyAnY3VycmVuY3knIDogJ2RlY2ltYWwnLFxuICAgICAgICBjdXJyZW5jeTogdGhpcy5jdXJyZW5jeSA/IHRoaXMuY3VycmVuY3kuZXZhbHVhdGUoY3R4KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID8gdGhpcy5taW5GcmFjdGlvbkRpZ2l0cy5ldmFsdWF0ZShjdHgpIDogdW5kZWZpbmVkLFxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMgPyB0aGlzLm1heEZyYWN0aW9uRGlnaXRzLmV2YWx1YXRlKGN0eCkgOiB1bmRlZmluZWRcbiAgICB9KS5mb3JtYXQodGhpcy5udW1iZXIuZXZhbHVhdGUoY3R4KSk7XG59O1xuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLm51bWJlcik7XG4gICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgIGZuKHRoaXMubG9jYWxlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVuY3kpIHtcbiAgICAgICAgZm4odGhpcy5jdXJyZW5jeSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIGZuKHRoaXMubWluRnJhY3Rpb25EaWdpdHMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhGcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICBmbih0aGlzLm1heEZyYWN0aW9uRGlnaXRzKTtcbiAgICB9XG59O1xuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICBpZiAodGhpcy5sb2NhbGUpIHtcbiAgICAgICAgb3B0aW9uc1snbG9jYWxlJ10gPSB0aGlzLmxvY2FsZS5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVuY3kpIHtcbiAgICAgICAgb3B0aW9uc1snY3VycmVuY3knXSA9IHRoaXMuY3VycmVuY3kuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIG9wdGlvbnNbJ21pbi1mcmFjdGlvbi1kaWdpdHMnXSA9IHRoaXMubWluRnJhY3Rpb25EaWdpdHMuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heEZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIG9wdGlvbnNbJ21heC1mcmFjdGlvbi1kaWdpdHMnXSA9IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgICdudW1iZXItZm9ybWF0JyxcbiAgICAgICAgdGhpcy5udW1iZXIuc2VyaWFsaXplKCksXG4gICAgICAgIG9wdGlvbnNcbiAgICBdO1xufTtcblxudmFyIExlbmd0aCA9IGZ1bmN0aW9uIExlbmd0aChpbnB1dCkge1xuICAgIHRoaXMudHlwZSA9IE51bWJlclR5cGU7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xufTtcbkxlbmd0aC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIDEgYXJndW1lbnQsIGJ1dCBmb3VuZCAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSk7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlucHV0LnR5cGUua2luZCAhPT0gJ2FycmF5JyAmJiBpbnB1dC50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIGlucHV0LnR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXksIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcoaW5wdXQudHlwZSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGVuZ3RoKGlucHV0KTtcbn07XG5MZW5ndGgucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5sZW5ndGg7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgc3RyaW5nIG9yIGFycmF5LCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZihpbnB1dCkpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbn07XG5MZW5ndGgucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZuKHRoaXMuaW5wdXQpO1xufTtcbkxlbmd0aC5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbkxlbmd0aC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gWydsZW5ndGgnXTtcbiAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbnZhciBleHByZXNzaW9ucyA9IHtcbiAgICAnPT0nOiBFcXVhbHMsXG4gICAgJyE9JzogTm90RXF1YWxzLFxuICAgICc+JzogR3JlYXRlclRoYW4sXG4gICAgJzwnOiBMZXNzVGhhbixcbiAgICAnPj0nOiBHcmVhdGVyVGhhbk9yRXF1YWwsXG4gICAgJzw9JzogTGVzc1RoYW5PckVxdWFsLFxuICAgICdhcnJheSc6IEFzc2VydGlvbixcbiAgICAnYXQnOiBBdCxcbiAgICAnYm9vbGVhbic6IEFzc2VydGlvbixcbiAgICAnY2FzZSc6IENhc2UsXG4gICAgJ2NvYWxlc2NlJzogQ29hbGVzY2UsXG4gICAgJ2NvbGxhdG9yJzogQ29sbGF0b3JFeHByZXNzaW9uLFxuICAgICdmb3JtYXQnOiBGb3JtYXRFeHByZXNzaW9uLFxuICAgICdpbWFnZSc6IEltYWdlRXhwcmVzc2lvbixcbiAgICAnaW4nOiBJbixcbiAgICAnaW5kZXgtb2YnOiBJbmRleE9mLFxuICAgICdpbnRlcnBvbGF0ZSc6IEludGVycG9sYXRlLFxuICAgICdpbnRlcnBvbGF0ZS1oY2wnOiBJbnRlcnBvbGF0ZSxcbiAgICAnaW50ZXJwb2xhdGUtbGFiJzogSW50ZXJwb2xhdGUsXG4gICAgJ2xlbmd0aCc6IExlbmd0aCxcbiAgICAnbGV0JzogTGV0LFxuICAgICdsaXRlcmFsJzogTGl0ZXJhbCxcbiAgICAnbWF0Y2gnOiBNYXRjaCxcbiAgICAnbnVtYmVyJzogQXNzZXJ0aW9uLFxuICAgICdudW1iZXItZm9ybWF0JzogTnVtYmVyRm9ybWF0LFxuICAgICdvYmplY3QnOiBBc3NlcnRpb24sXG4gICAgJ3NsaWNlJzogU2xpY2UsXG4gICAgJ3N0ZXAnOiBTdGVwLFxuICAgICdzdHJpbmcnOiBBc3NlcnRpb24sXG4gICAgJ3RvLWJvb2xlYW4nOiBDb2VyY2lvbixcbiAgICAndG8tY29sb3InOiBDb2VyY2lvbixcbiAgICAndG8tbnVtYmVyJzogQ29lcmNpb24sXG4gICAgJ3RvLXN0cmluZyc6IENvZXJjaW9uLFxuICAgICd2YXInOiBWYXIsXG4gICAgJ3dpdGhpbic6IFdpdGhpblxufTtcbmZ1bmN0aW9uIHJnYmEoY3R4LCByZWYpIHtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgYSA9IHJlZlszXTtcbiAgICByID0gci5ldmFsdWF0ZShjdHgpO1xuICAgIGcgPSBnLmV2YWx1YXRlKGN0eCk7XG4gICAgYiA9IGIuZXZhbHVhdGUoY3R4KTtcbiAgICB2YXIgYWxwaGEgPSBhID8gYS5ldmFsdWF0ZShjdHgpIDogMTtcbiAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZVJHQkEociwgZywgYiwgYWxwaGEpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb2xvcihyIC8gMjU1ICogYWxwaGEsIGcgLyAyNTUgKiBhbHBoYSwgYiAvIDI1NSAqIGFscGhhLCBhbHBoYSk7XG59XG5mdW5jdGlvbiBoYXMoa2V5LCBvYmopIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbn1cbmZ1bmN0aW9uIGdldChrZXksIG9iaikge1xuICAgIHZhciB2ID0gb2JqW2tleV07XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB2O1xufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKHYsIGEsIGksIGopIHtcbiAgICB3aGlsZSAoaSA8PSBqKSB7XG4gICAgICAgIHZhciBtID0gaSArIGogPj4gMTtcbiAgICAgICAgaWYgKGFbbV0gPT09IHYpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW21dID4gdikge1xuICAgICAgICAgICAgaiA9IG0gLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSA9IG0gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHZhcmFyZ3ModHlwZSkge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUgfTtcbn1cbkNvbXBvdW5kRXhwcmVzc2lvbi5yZWdpc3RlcihleHByZXNzaW9ucywge1xuICAgICdlcnJvcic6IFtcbiAgICAgICAgRXJyb3JUeXBlLFxuICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKHYuZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICd0eXBlb2YnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtWYWx1ZVR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHR5cGVPZih2LmV2YWx1YXRlKGN0eCkpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3RvLXJnYmEnOiBbXG4gICAgICAgIGFycmF5KE51bWJlclR5cGUsIDQpLFxuICAgICAgICBbQ29sb3JUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiB2LmV2YWx1YXRlKGN0eCkudG9BcnJheSgpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAncmdiJzogW1xuICAgICAgICBDb2xvclR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZVxuICAgICAgICBdLFxuICAgICAgICByZ2JhXG4gICAgXSxcbiAgICAncmdiYSc6IFtcbiAgICAgICAgQ29sb3JUeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIHJnYmFcbiAgICBdLFxuICAgICdoYXMnOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5UeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXMoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHJlZlswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhcyhrZXkuZXZhbHVhdGUoY3R4KSwgb2JqLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJ2dldCc6IHtcbiAgICAgICAgdHlwZTogVmFsdWVUeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHJlZlswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldChrZXkuZXZhbHVhdGUoY3R4KSwgb2JqLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJ2ZlYXR1cmUtc3RhdGUnOiBbXG4gICAgICAgIFZhbHVlVHlwZSxcbiAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gZ2V0KGtleS5ldmFsdWF0ZShjdHgpLCBjdHguZmVhdHVyZVN0YXRlIHx8IHt9KTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3Byb3BlcnRpZXMnOiBbXG4gICAgICAgIE9iamVjdFR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2dlb21ldHJ5LXR5cGUnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lmdlb21ldHJ5VHlwZSgpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnaWQnOiBbXG4gICAgICAgIFZhbHVlVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguaWQoKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3pvb20nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lmdsb2JhbHMuem9vbTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2hlYXRtYXAtZGVuc2l0eSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguZ2xvYmFscy5oZWF0bWFwRGVuc2l0eSB8fCAwO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnbGluZS1wcm9ncmVzcyc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguZ2xvYmFscy5saW5lUHJvZ3Jlc3MgfHwgMDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2FjY3VtdWxhdGVkJzogW1xuICAgICAgICBWYWx1ZVR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lmdsb2JhbHMuYWNjdW11bGF0ZWQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdHguZ2xvYmFscy5hY2N1bXVsYXRlZDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJysnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIHZhcmFyZ3MoTnVtYmVyVHlwZSksXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBhcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmcgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICcqJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gYXJnczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKj0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnLSc6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyVHlwZSxcbiAgICAgICAgb3ZlcmxvYWRzOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gcmVmWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpIC0gYi5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHJlZlswXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1hLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnLyc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGVcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciBiID0gcmVmWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGEuZXZhbHVhdGUoY3R4KSAvIGIuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJyUnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgYiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJldHVybiBhLmV2YWx1YXRlKGN0eCkgJSBiLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdsbjInOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5MTjI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdwaSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkU7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdeJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZVxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBiID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIGUgPSByZWZbMV07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coYi5ldmFsdWF0ZShjdHgpLCBlLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnc3FydCc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4LmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnbG9nMTAnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpIC8gTWF0aC5MTjEwO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnbG4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnbG9nMic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBuID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKG4uZXZhbHVhdGUoY3R4KSkgLyBNYXRoLkxOMjtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3Npbic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBuID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKG4uZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdjb3MnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNvcyhuLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAndGFuJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC50YW4obi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2FzaW4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFzaW4obi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2Fjb3MnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFjb3Mobi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2F0YW4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4obi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ21pbic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgdmFyYXJncyhOdW1iZXJUeXBlKSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdtYXgnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIHZhcmFyZ3MoTnVtYmVyVHlwZSksXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnYWJzJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3JvdW5kJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IG4uZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIHJldHVybiB2IDwgMCA/IC1NYXRoLnJvdW5kKC12KSA6IE1hdGgucm91bmQodik7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmbG9vcic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBuID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iobi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2NlaWwnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci09PSc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBWYWx1ZVR5cGVcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgayA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0gPT09IHYudmFsdWU7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItaWQtPT0nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBjdHguaWQoKSA9PT0gdi52YWx1ZTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci10eXBlLT09JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gdi52YWx1ZTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci08JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBrID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07XG4gICAgICAgICAgICB2YXIgYSA9IGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV07XG4gICAgICAgICAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPCBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLTwnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciBhID0gY3R4LmlkKCk7XG4gICAgICAgICAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPCBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLT4nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+IGI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItaWQtPic6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtWYWx1ZVR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIGEgPSBjdHguaWQoKTtcbiAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+IGI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItPD0nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA8PSBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLTw9JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1ZhbHVlVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgYSA9IGN0eC5pZCgpO1xuICAgICAgICAgICAgdmFyIGIgPSB2LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDw9IGI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItPj0nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+PSBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLT49JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1ZhbHVlVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgYSA9IGN0eC5pZCgpO1xuICAgICAgICAgICAgdmFyIGIgPSB2LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhID49IGI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItaGFzJzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1ZhbHVlVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gay52YWx1ZSBpbiBjdHgucHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWhhcy1pZCc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmlkKCkgIT09IG51bGwgJiYgY3R4LmlkKCkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci10eXBlLWluJzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW2FycmF5KFN0cmluZ1R5cGUpXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiB2LnZhbHVlLmluZGV4T2YoY3R4Lmdlb21ldHJ5VHlwZSgpKSA+PSAwO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLWluJzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW2FycmF5KFZhbHVlVHlwZSldLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHYudmFsdWUuaW5kZXhPZihjdHguaWQoKSkgPj0gMDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1pbi1zbWFsbCc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBhcnJheShWYWx1ZVR5cGUpXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJldHVybiB2LnZhbHVlLmluZGV4T2YoY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXSkgPj0gMDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1pbi1sYXJnZSc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBhcnJheShWYWx1ZVR5cGUpXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJldHVybiBiaW5hcnlTZWFyY2goY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXSwgdi52YWx1ZSwgMCwgdi52YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2FsbCc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIEJvb2xlYW5UeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gcmVmWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpICYmIGIuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHZhcmFyZ3MoQm9vbGVhblR5cGUpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBhcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZy5ldmFsdWF0ZShjdHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJ2FueSc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIEJvb2xlYW5UeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gcmVmWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpIHx8IGIuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHZhcmFyZ3MoQm9vbGVhblR5cGUpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBhcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLmV2YWx1YXRlKGN0eCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnISc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtCb29sZWFuVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGIgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gIWIuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2lzLXN1cHBvcnRlZC1zY3JpcHQnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHMgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgaXNTdXBwb3J0ZWRTY3JpcHQgPSBjdHguZ2xvYmFscyAmJiBjdHguZ2xvYmFscy5pc1N1cHBvcnRlZFNjcmlwdDtcbiAgICAgICAgICAgIGlmIChpc1N1cHBvcnRlZFNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1N1cHBvcnRlZFNjcmlwdChzLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICd1cGNhc2UnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtTdHJpbmdUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBzLmV2YWx1YXRlKGN0eCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2Rvd25jYXNlJzogW1xuICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHMgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gcy5ldmFsdWF0ZShjdHgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdjb25jYXQnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIHZhcmFyZ3MoVmFsdWVUeXBlKSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9TdHJpbmckMShhcmcuZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3Jlc29sdmVkLWxvY2FsZSc6IFtcbiAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgW0NvbGxhdG9yVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGNvbGxhdG9yID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxhdG9yLmV2YWx1YXRlKGN0eCkucmVzb2x2ZWRMb2NhbGUoKTtcbiAgICAgICAgfVxuICAgIF1cbn0pO1xuXG5mdW5jdGlvbiBzdWNjZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiAnc3VjY2VzcycsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogJ2Vycm9yJyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24oc3BlYykge1xuICAgIHJldHVybiBzcGVjWydwcm9wZXJ0eS10eXBlJ10gPT09ICdkYXRhLWRyaXZlbicgfHwgc3BlY1sncHJvcGVydHktdHlwZSddID09PSAnY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW4nO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNab29tRXhwcmVzc2lvbihzcGVjKSB7XG4gICAgcmV0dXJuICEhc3BlYy5leHByZXNzaW9uICYmIHNwZWMuZXhwcmVzc2lvbi5wYXJhbWV0ZXJzLmluZGV4T2YoJ3pvb20nKSA+IC0xO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNJbnRlcnBvbGF0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gISFzcGVjLmV4cHJlc3Npb24gJiYgc3BlYy5leHByZXNzaW9uLmludGVycG9sYXRlZDtcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24kMSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlkZW50aXR5RnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4O1xufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKSB7XG4gICAgdmFyIGlzQ29sb3IgPSBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2NvbG9yJztcbiAgICB2YXIgem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgPSBwYXJhbWV0ZXJzLnN0b3BzICYmIHR5cGVvZiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdID09PSAnb2JqZWN0JztcbiAgICB2YXIgZmVhdHVyZURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8IHBhcmFtZXRlcnMucHJvcGVydHkgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgem9vbURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8ICFmZWF0dXJlRGVwZW5kZW50O1xuICAgIHZhciB0eXBlID0gcGFyYW1ldGVycy50eXBlIHx8IChzdXBwb3J0c0ludGVycG9sYXRpb24ocHJvcGVydHlTcGVjKSA/ICdleHBvbmVudGlhbCcgOiAnaW50ZXJ2YWwnKTtcbiAgICBpZiAoaXNDb2xvcikge1xuICAgICAgICBwYXJhbWV0ZXJzID0gZXh0ZW5kKHt9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuc3RvcHMpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuc3RvcHMgPSBwYXJhbWV0ZXJzLnN0b3BzLm1hcChmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHN0b3BbMF0sXG4gICAgICAgICAgICAgICAgICAgIENvbG9yLnBhcnNlKHN0b3BbMV0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZGVmYXVsdCA9IENvbG9yLnBhcnNlKHBhcmFtZXRlcnMuZGVmYXVsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmRlZmF1bHQgPSBDb2xvci5wYXJzZShwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlcnMuY29sb3JTcGFjZSAmJiBwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgIT09ICdyZ2InICYmICFjb2xvclNwYWNlc1twYXJhbWV0ZXJzLmNvbG9yU3BhY2VdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb2xvciBzcGFjZTogJyArIHBhcmFtZXRlcnMuY29sb3JTcGFjZSk7XG4gICAgfVxuICAgIHZhciBpbm5lckZ1bjtcbiAgICB2YXIgaGFzaGVkU3RvcHM7XG4gICAgdmFyIGNhdGVnb3JpY2FsS2V5VHlwZTtcbiAgICBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICBpbm5lckZ1biA9IGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnRlcnZhbCcpIHtcbiAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUludGVydmFsRnVuY3Rpb247XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnKSB7XG4gICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uO1xuICAgICAgICBoYXNoZWRTdG9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1ldGVycy5zdG9wczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzdG9wID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGhhc2hlZFN0b3BzW3N0b3BbMF1dID0gc3RvcFsxXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRlZ29yaWNhbEtleVR5cGUgPSB0eXBlb2YgcGFyYW1ldGVycy5zdG9wc1swXVswXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUlkZW50aXR5RnVuY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZ1bmN0aW9uIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICAgIH1cbiAgICBpZiAoem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQpIHtcbiAgICAgICAgdmFyIGZlYXR1cmVGdW5jdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIHpvb21TdG9wcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHBhcmFtZXRlcnMuc3RvcHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIHZhciBzdG9wJDEgPSBwYXJhbWV0ZXJzLnN0b3BzW3NdO1xuICAgICAgICAgICAgdmFyIHpvb20gPSBzdG9wJDFbMF0uem9vbTtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlRnVuY3Rpb25zW3pvb21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25zW3pvb21dID0ge1xuICAgICAgICAgICAgICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbWV0ZXJzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwYXJhbWV0ZXJzLnByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwYXJhbWV0ZXJzLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgem9vbVN0b3BzLnB1c2goem9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25zW3pvb21dLnN0b3BzLnB1c2goW1xuICAgICAgICAgICAgICAgIHN0b3AkMVswXS52YWx1ZSxcbiAgICAgICAgICAgICAgICBzdG9wJDFbMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmZWF0dXJlRnVuY3Rpb25TdG9wcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSB6b29tU3RvcHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeiA9IGxpc3QkMVtpJDFdO1xuICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHMucHVzaChbXG4gICAgICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uc1t6XS56b29tLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUZ1bmN0aW9uKGZlYXR1cmVGdW5jdGlvbnNbel0sIHByb3BlcnR5U3BlYylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uVHlwZSA9IHsgbmFtZTogJ2xpbmVhcicgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdjb21wb3NpdGUnLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvblR5cGU6IGludGVycG9sYXRpb25UeXBlLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkZhY3RvcjogSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvci5iaW5kKHVuZGVmaW5lZCwgaW50ZXJwb2xhdGlvblR5cGUpLFxuICAgICAgICAgICAgem9vbVN0b3BzOiBmZWF0dXJlRnVuY3Rpb25TdG9wcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc1swXTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIGV2YWx1YXRlKHJlZiwgcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHZhciB6b29tID0gcmVmLnpvb207XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BzOiBmZWF0dXJlRnVuY3Rpb25TdG9wcyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogcGFyYW1ldGVycy5iYXNlXG4gICAgICAgICAgICAgICAgfSwgcHJvcGVydHlTcGVjLCB6b29tKS5ldmFsdWF0ZSh6b29tLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHpvb21EZXBlbmRlbnQpIHtcbiAgICAgICAgdmFyIGludGVycG9sYXRpb25UeXBlJDEgPSB0eXBlID09PSAnZXhwb25lbnRpYWwnID8ge1xuICAgICAgICAgICAgbmFtZTogJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgICAgIGJhc2U6IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMVxuICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdjYW1lcmEnLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvblR5cGU6IGludGVycG9sYXRpb25UeXBlJDEsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uRmFjdG9yOiBJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0aW9uRmFjdG9yLmJpbmQodW5kZWZpbmVkLCBpbnRlcnBvbGF0aW9uVHlwZSQxKSxcbiAgICAgICAgICAgIHpvb21TdG9wczogcGFyYW1ldGVycy5zdG9wcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc1swXTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgem9vbSA9IHJlZi56b29tO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckZ1bihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHpvb20sIGhhc2hlZFN0b3BzLCBjYXRlZ29yaWNhbEtleVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAnc291cmNlJyxcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZShfLCBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZmVhdHVyZSAmJiBmZWF0dXJlLnByb3BlcnRpZXMgPyBmZWF0dXJlLnByb3BlcnRpZXNbcGFyYW1ldGVycy5wcm9wZXJ0eV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvYWxlc2NlKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJGdW4ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCB2YWx1ZSwgaGFzaGVkU3RvcHMsIGNhdGVnb3JpY2FsS2V5VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29hbGVzY2UoYSwgYiwgYykge1xuICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxufVxuZnVuY3Rpb24gZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQsIGhhc2hlZFN0b3BzLCBrZXlUeXBlKSB7XG4gICAgdmFyIGV2YWx1YXRlZCA9IHR5cGVvZiBpbnB1dCA9PT0ga2V5VHlwZSA/IGhhc2hlZFN0b3BzW2lucHV0XSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gY29hbGVzY2UoZXZhbHVhdGVkLCBwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJ2YWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0KSB7XG4gICAgaWYgKGdldFR5cGUoaW5wdXQpICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gY29hbGVzY2UocGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG4gICAgfVxuICAgIHZhciBuID0gcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7XG4gICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07XG4gICAgfVxuICAgIGlmIChpbnB1dCA8PSBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPj0gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMF0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzFdO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHBhcmFtZXRlcnMuc3RvcHMubWFwKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgIHJldHVybiBzdG9wWzBdO1xuICAgIH0pLCBpbnB1dCk7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzFdO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQpIHtcbiAgICB2YXIgYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMTtcbiAgICBpZiAoZ2V0VHlwZShpbnB1dCkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBjb2FsZXNjZShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbiAgICB9XG4gICAgdmFyIG4gPSBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDtcbiAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1swXVsxXTtcbiAgICB9XG4gICAgaWYgKGlucHV0IDw9IHBhcmFtZXRlcnMuc3RvcHNbMF1bMF0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07XG4gICAgfVxuICAgIGlmIChpbnB1dCA+PSBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVswXSkge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMV07XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZpbmRTdG9wTGVzc1RoYW5PckVxdWFsVG8ocGFyYW1ldGVycy5zdG9wcy5tYXAoZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIHN0b3BbMF07XG4gICAgfSksIGlucHV0KTtcbiAgICB2YXIgdCA9IGludGVycG9sYXRpb25GYWN0b3IoaW5wdXQsIGJhc2UsIHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzBdLCBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4ICsgMV1bMF0pO1xuICAgIHZhciBvdXRwdXRMb3dlciA9IHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzFdO1xuICAgIHZhciBvdXRwdXRVcHBlciA9IHBhcmFtZXRlcnMuc3RvcHNbaW5kZXggKyAxXVsxXTtcbiAgICB2YXIgaW50ZXJwID0gaW50ZXJwb2xhdGVbcHJvcGVydHlTcGVjLnR5cGVdIHx8IGlkZW50aXR5RnVuY3Rpb247XG4gICAgaWYgKHBhcmFtZXRlcnMuY29sb3JTcGFjZSAmJiBwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgIT09ICdyZ2InKSB7XG4gICAgICAgIHZhciBjb2xvcnNwYWNlID0gY29sb3JTcGFjZXNbcGFyYW1ldGVycy5jb2xvclNwYWNlXTtcbiAgICAgICAgaW50ZXJwID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcnNwYWNlLnJldmVyc2UoY29sb3JzcGFjZS5pbnRlcnBvbGF0ZShjb2xvcnNwYWNlLmZvcndhcmQoYSksIGNvbG9yc3BhY2UuZm9yd2FyZChiKSwgdCkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG91dHB1dExvd2VyLmV2YWx1YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobGVuLS0pXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgICAgICAgICAgIHZhciBldmFsdWF0ZWRMb3dlciA9IG91dHB1dExvd2VyLmV2YWx1YXRlLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICAgICAgdmFyIGV2YWx1YXRlZFVwcGVyID0gb3V0cHV0VXBwZXIuZXZhbHVhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGVkTG93ZXIgPT09IHVuZGVmaW5lZCB8fCBldmFsdWF0ZWRVcHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnAoZXZhbHVhdGVkTG93ZXIsIGV2YWx1YXRlZFVwcGVyLCB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVycChvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIsIHQpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVJZGVudGl0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQpIHtcbiAgICBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgaW5wdXQgPSBDb2xvci5wYXJzZShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2Zvcm1hdHRlZCcpIHtcbiAgICAgICAgaW5wdXQgPSBGb3JtYXR0ZWQuZnJvbVN0cmluZyhpbnB1dC50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICAgICAgaW5wdXQgPSBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcoaW5wdXQudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmIChnZXRUeXBlKGlucHV0KSAhPT0gcHJvcGVydHlTcGVjLnR5cGUgJiYgKHByb3BlcnR5U3BlYy50eXBlICE9PSAnZW51bScgfHwgIXByb3BlcnR5U3BlYy52YWx1ZXNbaW5wdXRdKSkge1xuICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNvYWxlc2NlKGlucHV0LCBwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRpb25GYWN0b3IoaW5wdXQsIGJhc2UsIGxvd2VyVmFsdWUsIHVwcGVyVmFsdWUpIHtcbiAgICB2YXIgZGlmZmVyZW5jZSA9IHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlO1xuICAgIHZhciBwcm9ncmVzcyA9IGlucHV0IC0gbG93ZXJWYWx1ZTtcbiAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGJhc2UgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHByb2dyZXNzIC8gZGlmZmVyZW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKE1hdGgucG93KGJhc2UsIHByb2dyZXNzKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIGRpZmZlcmVuY2UpIC0gMSk7XG4gICAgfVxufVxuXG52YXIgU3R5bGVFeHByZXNzaW9uID0gZnVuY3Rpb24gU3R5bGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHByb3BlcnR5U3BlYykge1xuICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgdGhpcy5fd2FybmluZ0hpc3RvcnkgPSB7fTtcbiAgICB0aGlzLl9ldmFsdWF0b3IgPSBuZXcgRXZhbHVhdGlvbkNvbnRleHQoKTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBwcm9wZXJ0eVNwZWMgPyBnZXREZWZhdWx0VmFsdWUocHJvcGVydHlTcGVjKSA6IG51bGw7XG4gICAgdGhpcy5fZW51bVZhbHVlcyA9IHByb3BlcnR5U3BlYyAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2VudW0nID8gcHJvcGVydHlTcGVjLnZhbHVlcyA6IG51bGw7XG59O1xuU3R5bGVFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nID0gZnVuY3Rpb24gZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmdsb2JhbHMgPSBnbG9iYWxzO1xuICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZVN0YXRlID0gZmVhdHVyZVN0YXRlO1xuICAgIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBjYW5vbmljYWw7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGF2YWlsYWJsZUltYWdlcyB8fCBudWxsO1xuICAgIHRoaXMuX2V2YWx1YXRvci5mb3JtYXR0ZWRTZWN0aW9uID0gZm9ybWF0dGVkU2VjdGlvbjtcbiAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHRoaXMuX2V2YWx1YXRvcik7XG59O1xuU3R5bGVFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IGdsb2JhbHM7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmUgPSBmZWF0dXJlIHx8IG51bGw7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IGZlYXR1cmVTdGF0ZSB8fCBudWxsO1xuICAgIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBjYW5vbmljYWw7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGF2YWlsYWJsZUltYWdlcyB8fCBudWxsO1xuICAgIHRoaXMuX2V2YWx1YXRvci5mb3JtYXR0ZWRTZWN0aW9uID0gZm9ybWF0dGVkU2VjdGlvbiB8fCBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUodGhpcy5fZXZhbHVhdG9yKTtcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiB2YWwgIT09IHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZW51bVZhbHVlcyAmJiAhKHZhbCBpbiB0aGlzLl9lbnVtVmFsdWVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyh0aGlzLl9lbnVtVmFsdWVzKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgICAgICB9KS5qb2luKCcsICcpICsgJywgYnV0IGZvdW5kICcgKyBKU09OLnN0cmluZ2lmeSh2YWwpICsgJyBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3dhcm5pbmdIaXN0b3J5W2UubWVzc2FnZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX3dhcm5pbmdIaXN0b3J5W2UubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWU7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbikgJiYgZXhwcmVzc2lvbi5sZW5ndGggPiAwICYmIHR5cGVvZiBleHByZXNzaW9uWzBdID09PSAnc3RyaW5nJyAmJiBleHByZXNzaW9uWzBdIGluIGV4cHJlc3Npb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNpbmdDb250ZXh0KGV4cHJlc3Npb25zLCBbXSwgcHJvcGVydHlTcGVjID8gZ2V0RXhwZWN0ZWRUeXBlKHByb3BlcnR5U3BlYykgOiB1bmRlZmluZWQpO1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZXIucGFyc2UoZXhwcmVzc2lvbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcHJvcGVydHlTcGVjICYmIHByb3BlcnR5U3BlYy50eXBlID09PSAnc3RyaW5nJyA/IHsgdHlwZUFubm90YXRpb246ICdjb2VyY2UnIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihwYXJzZXIuZXJyb3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3MobmV3IFN0eWxlRXhwcmVzc2lvbihwYXJzZWQsIHByb3BlcnR5U3BlYykpO1xufVxudmFyIFpvb21Db25zdGFudEV4cHJlc3Npb24gPSBmdW5jdGlvbiBab29tQ29uc3RhbnRFeHByZXNzaW9uKGtpbmQsIGV4cHJlc3Npb24pIHtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMuX3N0eWxlRXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgdGhpcy5pc1N0YXRlRGVwZW5kZW50ID0ga2luZCAhPT0gJ2NvbnN0YW50JyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb24uZXhwcmVzc2lvbik7XG59O1xuWm9vbUNvbnN0YW50RXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyA9IGZ1bmN0aW9uIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTtcbn07XG5ab29tQ29uc3RhbnRFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pO1xufTtcbnZhciBab29tRGVwZW5kZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIFpvb21EZXBlbmRlbnRFeHByZXNzaW9uKGtpbmQsIGV4cHJlc3Npb24sIHpvb21TdG9wcywgaW50ZXJwb2xhdGlvblR5cGUpIHtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMuem9vbVN0b3BzID0gem9vbVN0b3BzO1xuICAgIHRoaXMuX3N0eWxlRXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgdGhpcy5pc1N0YXRlRGVwZW5kZW50ID0ga2luZCAhPT0gJ2NhbWVyYScgJiYgIWlzU3RhdGVDb25zdGFudChleHByZXNzaW9uLmV4cHJlc3Npb24pO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBpbnRlcnBvbGF0aW9uVHlwZTtcbn07XG5ab29tRGVwZW5kZW50RXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyA9IGZ1bmN0aW9uIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTtcbn07XG5ab29tRGVwZW5kZW50RXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTtcbn07XG5ab29tRGVwZW5kZW50RXhwcmVzc2lvbi5wcm90b3R5cGUuaW50ZXJwb2xhdGlvbkZhY3RvciA9IGZ1bmN0aW9uIGludGVycG9sYXRpb25GYWN0b3IoaW5wdXQsIGxvd2VyLCB1cHBlcikge1xuICAgIGlmICh0aGlzLmludGVycG9sYXRpb25UeXBlKSB7XG4gICAgICAgIHJldHVybiBJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0aW9uRmFjdG9yKHRoaXMuaW50ZXJwb2xhdGlvblR5cGUsIGlucHV0LCBsb3dlciwgdXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKSB7XG4gICAgZXhwcmVzc2lvbiA9IGNyZWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKTtcbiAgICBpZiAoZXhwcmVzc2lvbi5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxuICAgIHZhciBwYXJzZWQgPSBleHByZXNzaW9uLnZhbHVlLmV4cHJlc3Npb247XG4gICAgdmFyIGlzRmVhdHVyZUNvbnN0YW50JDEgPSBpc0ZlYXR1cmVDb25zdGFudChwYXJzZWQpO1xuICAgIGlmICghaXNGZWF0dXJlQ29uc3RhbnQkMSAmJiAhc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24ocHJvcGVydHlTcGVjKSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoW25ldyBQYXJzaW5nRXJyb3IoJycsICdkYXRhIGV4cHJlc3Npb25zIG5vdCBzdXBwb3J0ZWQnKV0pO1xuICAgIH1cbiAgICB2YXIgaXNab29tQ29uc3RhbnQgPSBpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQocGFyc2VkLCBbJ3pvb20nXSk7XG4gICAgaWYgKCFpc1pvb21Db25zdGFudCAmJiAhc3VwcG9ydHNab29tRXhwcmVzc2lvbihwcm9wZXJ0eVNwZWMpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ3pvb20gZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZCcpXSk7XG4gICAgfVxuICAgIHZhciB6b29tQ3VydmUgPSBmaW5kWm9vbUN1cnZlKHBhcnNlZCk7XG4gICAgaWYgKCF6b29tQ3VydmUgJiYgIWlzWm9vbUNvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ1wiem9vbVwiIGV4cHJlc3Npb24gbWF5IG9ubHkgYmUgdXNlZCBhcyBpbnB1dCB0byBhIHRvcC1sZXZlbCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbi4nKV0pO1xuICAgIH0gZWxzZSBpZiAoem9vbUN1cnZlIGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihbem9vbUN1cnZlXSk7XG4gICAgfSBlbHNlIGlmICh6b29tQ3VydmUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0ZSAmJiAhc3VwcG9ydHNJbnRlcnBvbGF0aW9uKHByb3BlcnR5U3BlYykpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFtuZXcgUGFyc2luZ0Vycm9yKCcnLCAnXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb25zIGNhbm5vdCBiZSB1c2VkIHdpdGggdGhpcyBwcm9wZXJ0eScpXSk7XG4gICAgfVxuICAgIGlmICghem9vbUN1cnZlKSB7XG4gICAgICAgIHJldHVybiBzdWNjZXNzKGlzRmVhdHVyZUNvbnN0YW50JDEgPyBuZXcgWm9vbUNvbnN0YW50RXhwcmVzc2lvbignY29uc3RhbnQnLCBleHByZXNzaW9uLnZhbHVlKSA6IG5ldyBab29tQ29uc3RhbnRFeHByZXNzaW9uKCdzb3VyY2UnLCBleHByZXNzaW9uLnZhbHVlKSk7XG4gICAgfVxuICAgIHZhciBpbnRlcnBvbGF0aW9uVHlwZSA9IHpvb21DdXJ2ZSBpbnN0YW5jZW9mIEludGVycG9sYXRlID8gem9vbUN1cnZlLmludGVycG9sYXRpb24gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN1Y2Nlc3MoaXNGZWF0dXJlQ29uc3RhbnQkMSA/IG5ldyBab29tRGVwZW5kZW50RXhwcmVzc2lvbignY2FtZXJhJywgZXhwcmVzc2lvbi52YWx1ZSwgem9vbUN1cnZlLmxhYmVscywgaW50ZXJwb2xhdGlvblR5cGUpIDogbmV3IFpvb21EZXBlbmRlbnRFeHByZXNzaW9uKCdjb21wb3NpdGUnLCBleHByZXNzaW9uLnZhbHVlLCB6b29tQ3VydmUubGFiZWxzLCBpbnRlcnBvbGF0aW9uVHlwZSkpO1xufVxudmFyIFN0eWxlUHJvcGVydHlGdW5jdGlvbiA9IGZ1bmN0aW9uIFN0eWxlUHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBzcGVjaWZpY2F0aW9uKSB7XG4gICAgdGhpcy5fcGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgdGhpcy5fc3BlY2lmaWNhdGlvbiA9IHNwZWNpZmljYXRpb247XG4gICAgZXh0ZW5kKHRoaXMsIGNyZWF0ZUZ1bmN0aW9uKHRoaXMuX3BhcmFtZXRlcnMsIHRoaXMuX3NwZWNpZmljYXRpb24pKTtcbn07XG5TdHlsZVByb3BlcnR5RnVuY3Rpb24uZGVzZXJpYWxpemUgPSBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZVByb3BlcnR5RnVuY3Rpb24oc2VyaWFsaXplZC5fcGFyYW1ldGVycywgc2VyaWFsaXplZC5fc3BlY2lmaWNhdGlvbik7XG59O1xuU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9wYXJhbWV0ZXJzOiBpbnB1dC5fcGFyYW1ldGVycyxcbiAgICAgICAgX3NwZWNpZmljYXRpb246IGlucHV0Ll9zcGVjaWZpY2F0aW9uXG4gICAgfTtcbn07XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eUV4cHJlc3Npb24odmFsdWUsIHNwZWNpZmljYXRpb24pIHtcbiAgICBpZiAoaXNGdW5jdGlvbiQxKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0eWxlUHJvcGVydHlGdW5jdGlvbih2YWx1ZSwgc3BlY2lmaWNhdGlvbik7XG4gICAgfSBlbHNlIGlmIChpc0V4cHJlc3Npb24odmFsdWUpKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24ucmVzdWx0ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwcmVzc2lvbi52YWx1ZS5tYXAoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnIua2V5ICsgJzogJyArIGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgfSkuam9pbignLCAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbnN0YW50ID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHNwZWNpZmljYXRpb24udHlwZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgY29uc3RhbnQgPSBDb2xvci5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdjb25zdGFudCcsXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kWm9vbUN1cnZlKGV4cHJlc3Npb24pIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIExldCkge1xuICAgICAgICByZXN1bHQgPSBmaW5kWm9vbUN1cnZlKGV4cHJlc3Npb24ucmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2FsZXNjZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHJlc3Npb24uYXJnczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBsaXN0W2ldO1xuICAgICAgICAgICAgcmVzdWx0ID0gZmluZFpvb21DdXJ2ZShhcmcpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFN0ZXAgfHwgZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEludGVycG9sYXRlKSAmJiBleHByZXNzaW9uLmlucHV0IGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIGV4cHJlc3Npb24uaW5wdXQubmFtZSA9PT0gJ3pvb20nKSB7XG4gICAgICAgIHJlc3VsdCA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZXhwcmVzc2lvbi5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZFJlc3VsdCA9IGZpbmRab29tQ3VydmUoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRSZXN1bHQgaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNoaWxkUmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFyZXN1bHQgJiYgY2hpbGRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBQYXJzaW5nRXJyb3IoJycsICdcInpvb21cIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgXCJzdGVwXCIgb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb24uJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICYmIGNoaWxkUmVzdWx0ICYmIHJlc3VsdCAhPT0gY2hpbGRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBQYXJzaW5nRXJyb3IoJycsICdPbmx5IG9uZSB6b29tLWJhc2VkIFwic3RlcFwiIG9yIFwiaW50ZXJwb2xhdGVcIiBzdWJleHByZXNzaW9uIG1heSBiZSB1c2VkIGluIGFuIGV4cHJlc3Npb24uJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0RXhwZWN0ZWRUeXBlKHNwZWMpIHtcbiAgICB2YXIgdHlwZXMgPSB7XG4gICAgICAgIGNvbG9yOiBDb2xvclR5cGUsXG4gICAgICAgIHN0cmluZzogU3RyaW5nVHlwZSxcbiAgICAgICAgbnVtYmVyOiBOdW1iZXJUeXBlLFxuICAgICAgICBlbnVtOiBTdHJpbmdUeXBlLFxuICAgICAgICBib29sZWFuOiBCb29sZWFuVHlwZSxcbiAgICAgICAgZm9ybWF0dGVkOiBGb3JtYXR0ZWRUeXBlLFxuICAgICAgICByZXNvbHZlZEltYWdlOiBSZXNvbHZlZEltYWdlVHlwZVxuICAgIH07XG4gICAgaWYgKHNwZWMudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gYXJyYXkodHlwZXNbc3BlYy52YWx1ZV0gfHwgVmFsdWVUeXBlLCBzcGVjLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlc1tzcGVjLnR5cGVdO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKHNwZWMpIHtcbiAgICBpZiAoc3BlYy50eXBlID09PSAnY29sb3InICYmIGlzRnVuY3Rpb24kMShzcGVjLmRlZmF1bHQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgfSBlbHNlIGlmIChzcGVjLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yLnBhcnNlKHNwZWMuZGVmYXVsdCkgfHwgbnVsbDtcbiAgICB9IGVsc2UgaWYgKHNwZWMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzcGVjLmRlZmF1bHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gW1xuICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgIHZhbHVlXG4gICAgXSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gY29udmVydEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykge1xuICAgIHZhciBzdG9wcyA9IHBhcmFtZXRlcnMuc3RvcHM7XG4gICAgaWYgKCFzdG9wcykge1xuICAgICAgICByZXR1cm4gY29udmVydElkZW50aXR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKTtcbiAgICB9XG4gICAgdmFyIHpvb21BbmRGZWF0dXJlRGVwZW5kZW50ID0gc3RvcHMgJiYgdHlwZW9mIHN0b3BzWzBdWzBdID09PSAnb2JqZWN0JztcbiAgICB2YXIgZmVhdHVyZURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8IHBhcmFtZXRlcnMucHJvcGVydHkgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgem9vbURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8ICFmZWF0dXJlRGVwZW5kZW50O1xuICAgIHN0b3BzID0gc3RvcHMubWFwKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgIGlmICghZmVhdHVyZURlcGVuZGVudCAmJiBwcm9wZXJ0eVNwZWMudG9rZW5zICYmIHR5cGVvZiBzdG9wWzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzdG9wWzBdLFxuICAgICAgICAgICAgICAgIGNvbnZlcnRUb2tlblN0cmluZyhzdG9wWzFdKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc3RvcFswXSxcbiAgICAgICAgICAgIGNvbnZlcnRMaXRlcmFsKHN0b3BbMV0pXG4gICAgICAgIF07XG4gICAgfSk7XG4gICAgaWYgKHpvb21BbmRGZWF0dXJlRGVwZW5kZW50KSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcyk7XG4gICAgfSBlbHNlIGlmICh6b29tRGVwZW5kZW50KSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0Wm9vbUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0SWRlbnRpdHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICB2YXIgZ2V0ID0gW1xuICAgICAgICAnZ2V0JyxcbiAgICAgICAgcGFyYW1ldGVycy5wcm9wZXJ0eVxuICAgIF07XG4gICAgaWYgKHBhcmFtZXRlcnMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ3N0cmluZycgPyBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgIGdldFxuICAgICAgICBdIDogZ2V0O1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdlbnVtJykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ21hdGNoJyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5U3BlYy52YWx1ZXMpLFxuICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgcGFyYW1ldGVycy5kZWZhdWx0XG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBbXG4gICAgICAgICAgICBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2NvbG9yJyA/ICd0by1jb2xvcicgOiBwcm9wZXJ0eVNwZWMudHlwZSxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIGNvbnZlcnRMaXRlcmFsKHBhcmFtZXRlcnMuZGVmYXVsdClcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uLnNwbGljZSgxLCAwLCBwcm9wZXJ0eVNwZWMudmFsdWUsIHByb3BlcnR5U3BlYy5sZW5ndGggfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdGVPcGVyYXRvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3dpdGNoIChwYXJhbWV0ZXJzLmNvbG9yU3BhY2UpIHtcbiAgICBjYXNlICdoY2wnOlxuICAgICAgICByZXR1cm4gJ2ludGVycG9sYXRlLWhjbCc7XG4gICAgY2FzZSAnbGFiJzpcbiAgICAgICAgcmV0dXJuICdpbnRlcnBvbGF0ZS1sYWInO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnaW50ZXJwb2xhdGUnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRab29tQW5kUHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKSB7XG4gICAgdmFyIGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnMgPSB7fTtcbiAgICB2YXIgZmVhdHVyZUZ1bmN0aW9uU3RvcHMgPSB7fTtcbiAgICB2YXIgem9vbVN0b3BzID0gW107XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdG9wcy5sZW5ndGg7IHMrKykge1xuICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW3NdO1xuICAgICAgICB2YXIgem9vbSA9IHN0b3BbMF0uem9vbTtcbiAgICAgICAgaWYgKGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnNbem9vbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6b29tXSA9IHtcbiAgICAgICAgICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtZXRlcnMudHlwZSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyYW1ldGVycy5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBwYXJhbWV0ZXJzLmRlZmF1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25TdG9wc1t6b29tXSA9IFtdO1xuICAgICAgICAgICAgem9vbVN0b3BzLnB1c2goem9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHNbem9vbV0ucHVzaChbXG4gICAgICAgICAgICBzdG9wWzBdLnZhbHVlLFxuICAgICAgICAgICAgc3RvcFsxXVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgdmFyIGZ1bmN0aW9uVHlwZSA9IGdldEZ1bmN0aW9uVHlwZSh7fSwgcHJvcGVydHlTcGVjKTtcbiAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gW1xuICAgICAgICAgICAgZ2V0SW50ZXJwb2xhdGVPcGVyYXRvcihwYXJhbWV0ZXJzKSxcbiAgICAgICAgICAgIFsnbGluZWFyJ10sXG4gICAgICAgICAgICBbJ3pvb20nXVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHpvb21TdG9wczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB6ID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3pdLCBwcm9wZXJ0eVNwZWMsIGZlYXR1cmVGdW5jdGlvblN0b3BzW3pdKTtcbiAgICAgICAgICAgIGFwcGVuZFN0b3BQYWlyKGV4cHJlc3Npb24sIHosIG91dHB1dCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uJDEgPSBbXG4gICAgICAgICAgICAnc3RlcCcsXG4gICAgICAgICAgICBbJ3pvb20nXVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSB6b29tU3RvcHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeiQxID0gbGlzdCQxW2kkMV07XG4gICAgICAgICAgICB2YXIgb3V0cHV0JDEgPSBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3okMV0sIHByb3BlcnR5U3BlYywgZmVhdHVyZUZ1bmN0aW9uU3RvcHNbeiQxXSk7XG4gICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uJDEsIHokMSwgb3V0cHV0JDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShleHByZXNzaW9uJDEpO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbiQxO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvYWxlc2NlJDEoYSwgYikge1xuICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcykge1xuICAgIHZhciB0eXBlID0gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYyk7XG4gICAgdmFyIGdldCA9IFtcbiAgICAgICAgJ2dldCcsXG4gICAgICAgIHBhcmFtZXRlcnMucHJvcGVydHlcbiAgICBdO1xuICAgIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHR5cGVvZiBzdG9wc1swXVswXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gWydjYXNlJ107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RvcHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IGxpc3RbaV07XG4gICAgICAgICAgICBleHByZXNzaW9uLnB1c2goW1xuICAgICAgICAgICAgICAgICc9PScsXG4gICAgICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgICAgIHN0b3BbMF1cbiAgICAgICAgICAgIF0sIHN0b3BbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGV4cHJlc3Npb24ucHVzaChjb252ZXJ0TGl0ZXJhbChjb2FsZXNjZSQxKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpKSk7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NhdGVnb3JpY2FsJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiQxID0gW1xuICAgICAgICAgICAgJ21hdGNoJyxcbiAgICAgICAgICAgIGdldFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBzdG9wczsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzdG9wJDEgPSBsaXN0JDFbaSQxXTtcbiAgICAgICAgICAgIGFwcGVuZFN0b3BQYWlyKGV4cHJlc3Npb24kMSwgc3RvcCQxWzBdLCBzdG9wJDFbMV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBleHByZXNzaW9uJDEucHVzaChjb252ZXJ0TGl0ZXJhbChjb2FsZXNjZSQxKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpKSk7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uJDE7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uJDIgPSBbXG4gICAgICAgICAgICAnc3RlcCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAgICAgZ2V0XG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDAsIGxpc3QkMiA9IHN0b3BzOyBpJDIgPCBsaXN0JDIubGVuZ3RoOyBpJDIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHN0b3AkMiA9IGxpc3QkMltpJDJdO1xuICAgICAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiQyLCBzdG9wJDJbMF0sIHN0b3AkMlsxXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKGV4cHJlc3Npb24kMik7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLmRlZmF1bHQgPT09IHVuZGVmaW5lZCA/IGV4cHJlc3Npb24kMiA6IFtcbiAgICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPT0nLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGVvZicsXG4gICAgICAgICAgICAgICAgICAgIGdldFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ251bWJlcidcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHByZXNzaW9uJDIsXG4gICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgICAgIHZhciBiYXNlID0gcGFyYW1ldGVycy5iYXNlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmJhc2UgOiAxO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiQzID0gW1xuICAgICAgICAgICAgZ2V0SW50ZXJwb2xhdGVPcGVyYXRvcihwYXJhbWV0ZXJzKSxcbiAgICAgICAgICAgIGJhc2UgPT09IDEgPyBbJ2xpbmVhciddIDogW1xuICAgICAgICAgICAgICAgICdleHBvbmVudGlhbCcsXG4gICAgICAgICAgICAgICAgYmFzZVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBnZXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSQzID0gMCwgbGlzdCQzID0gc3RvcHM7IGkkMyA8IGxpc3QkMy5sZW5ndGg7IGkkMyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCQzID0gbGlzdCQzW2kkM107XG4gICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uJDMsIHN0b3AkM1swXSwgc3RvcCQzWzFdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkID8gZXhwcmVzc2lvbiQzIDogW1xuICAgICAgICAgICAgJ2Nhc2UnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc9PScsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAndHlwZW9mJyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAnbnVtYmVyJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb24kMyxcbiAgICAgICAgICAgIGNvbnZlcnRMaXRlcmFsKHBhcmFtZXRlcnMuZGVmYXVsdClcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvcGVydHkgZnVuY3Rpb24gdHlwZSAnICsgdHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFpvb21GdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzLCBpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKVxuICAgICAgICBpbnB1dCA9IFsnem9vbSddO1xuICAgIHZhciB0eXBlID0gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYyk7XG4gICAgdmFyIGV4cHJlc3Npb247XG4gICAgdmFyIGlzU3RlcCA9IGZhbHNlO1xuICAgIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBbXG4gICAgICAgICAgICAnc3RlcCcsXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICBdO1xuICAgICAgICBpc1N0ZXAgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICB2YXIgYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IFtcbiAgICAgICAgICAgIGdldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycyksXG4gICAgICAgICAgICBiYXNlID09PSAxID8gWydsaW5lYXInXSA6IFtcbiAgICAgICAgICAgICAgICAnZXhwb25lbnRpYWwnLFxuICAgICAgICAgICAgICAgIGJhc2VcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB6b29tIGZ1bmN0aW9uIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0b3BzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc3RvcCA9IGxpc3RbaV07XG4gICAgICAgIGFwcGVuZFN0b3BQYWlyKGV4cHJlc3Npb24sIHN0b3BbMF0sIHN0b3BbMV0sIGlzU3RlcCk7XG4gICAgfVxuICAgIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShleHByZXNzaW9uKTtcbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbn1cbmZ1bmN0aW9uIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShleHByZXNzaW9uKSB7XG4gICAgaWYgKGV4cHJlc3Npb25bMF0gPT09ICdzdGVwJyAmJiBleHByZXNzaW9uLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBleHByZXNzaW9uLnB1c2goMCk7XG4gICAgICAgIGV4cHJlc3Npb24ucHVzaChleHByZXNzaW9uWzNdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmRTdG9wUGFpcihjdXJ2ZSwgaW5wdXQsIG91dHB1dCwgaXNTdGVwKSB7XG4gICAgaWYgKGN1cnZlLmxlbmd0aCA+IDMgJiYgaW5wdXQgPT09IGN1cnZlW2N1cnZlLmxlbmd0aCAtIDJdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoaXNTdGVwICYmIGN1cnZlLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgY3VydmUucHVzaChpbnB1dCk7XG4gICAgfVxuICAgIGN1cnZlLnB1c2gob3V0cHV0KTtcbn1cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uVHlwZShwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICBpZiAocGFyYW1ldGVycy50eXBlKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5U3BlYy5leHByZXNzaW9uLmludGVycG9sYXRlZCA/ICdleHBvbmVudGlhbCcgOiAnaW50ZXJ2YWwnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb2tlblN0cmluZyhzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFsnY29uY2F0J107XG4gICAgdmFyIHJlID0gL3soW157fV0rKX0vZztcbiAgICB2YXIgcG9zID0gMDtcbiAgICBmb3IgKHZhciBtYXRjaCA9IHJlLmV4ZWMocyk7IG1hdGNoICE9PSBudWxsOyBtYXRjaCA9IHJlLmV4ZWMocykpIHtcbiAgICAgICAgdmFyIGxpdGVyYWwgPSBzLnNsaWNlKHBvcywgcmUubGFzdEluZGV4IC0gbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgcG9zID0gcmUubGFzdEluZGV4O1xuICAgICAgICBpZiAobGl0ZXJhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChsaXRlcmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChbXG4gICAgICAgICAgICAnZ2V0JyxcbiAgICAgICAgICAgIG1hdGNoWzFdXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgaWYgKHBvcyA8IHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHMuc2xpY2UocG9zKSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAndG8tc3RyaW5nJyxcbiAgICAgICAgICAgIHJlc3VsdFsxXVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciA9PT0gdHJ1ZSB8fCBmaWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyKSB8fCBmaWx0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChmaWx0ZXJbMF0pIHtcbiAgICBjYXNlICdoYXMnOlxuICAgICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aCA+PSAyICYmIGZpbHRlclsxXSAhPT0gJyRpZCcgJiYgZmlsdGVyWzFdICE9PSAnJHR5cGUnO1xuICAgIGNhc2UgJ2luJzpcbiAgICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggPj0gMyAmJiAodHlwZW9mIGZpbHRlclsxXSAhPT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShmaWx0ZXJbMl0pKTtcbiAgICBjYXNlICchaW4nOlxuICAgIGNhc2UgJyFoYXMnOlxuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSAnPT0nOlxuICAgIGNhc2UgJyE9JzpcbiAgICBjYXNlICc+JzpcbiAgICBjYXNlICc+PSc6XG4gICAgY2FzZSAnPCc6XG4gICAgY2FzZSAnPD0nOlxuICAgICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aCAhPT0gMyB8fCAoQXJyYXkuaXNBcnJheShmaWx0ZXJbMV0pIHx8IEFycmF5LmlzQXJyYXkoZmlsdGVyWzJdKSk7XG4gICAgY2FzZSAnYW55JzpcbiAgICBjYXNlICdhbGwnOlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGZpbHRlci5zbGljZSgxKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBmID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmICghaXNFeHByZXNzaW9uRmlsdGVyKGYpICYmIHR5cGVvZiBmICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxudmFyIGZpbHRlclNwZWMgPSB7XG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZSxcbiAgICAndHJhbnNpdGlvbic6IGZhbHNlLFxuICAgICdwcm9wZXJ0eS10eXBlJzogJ2RhdGEtZHJpdmVuJyxcbiAgICAnZXhwcmVzc2lvbic6IHtcbiAgICAgICAgJ2ludGVycG9sYXRlZCc6IGZhbHNlLFxuICAgICAgICAncGFyYW1ldGVycyc6IFtcbiAgICAgICAgICAgICd6b29tJyxcbiAgICAgICAgICAgICdmZWF0dXJlJ1xuICAgICAgICBdXG4gICAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyID09PSBudWxsIHx8IGZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZWVkR2VvbWV0cnk6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICghaXNFeHByZXNzaW9uRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgZmlsdGVyID0gY29udmVydEZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICB2YXIgY29tcGlsZWQgPSBjcmVhdGVFeHByZXNzaW9uKGZpbHRlciwgZmlsdGVyU3BlYyk7XG4gICAgaWYgKGNvbXBpbGVkLnJlc3VsdCA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29tcGlsZWQudmFsdWUubWFwKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnIua2V5ICsgJzogJyArIGVyci5tZXNzYWdlO1xuICAgICAgICB9KS5qb2luKCcsICcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmVlZEdlb21ldHJ5ID0gQXJyYXkuaXNBcnJheShmaWx0ZXIpICYmIGZpbHRlci5sZW5ndGggIT09IDAgJiYgZmlsdGVyWzBdID09PSAnd2l0aGluJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmUsIGNhbm9uaWNhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlZC52YWx1ZS5ldmFsdWF0ZShnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlLCB7fSwgY2Fub25pY2FsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZWVkR2VvbWV0cnk6IG5lZWRHZW9tZXRyeVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBvcCA9IGZpbHRlclswXTtcbiAgICBpZiAoZmlsdGVyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBvcCAhPT0gJ2FueSc7XG4gICAgfVxuICAgIHZhciBjb252ZXJ0ZWQgPSBvcCA9PT0gJz09JyA/IGNvbnZlcnRDb21wYXJpc29uT3AoZmlsdGVyWzFdLCBmaWx0ZXJbMl0sICc9PScpIDogb3AgPT09ICchPScgPyBjb252ZXJ0TmVnYXRpb24oY29udmVydENvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgJz09JykpIDogb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9wID09PSAnPD0nIHx8IG9wID09PSAnPj0nID8gY29udmVydENvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgb3ApIDogb3AgPT09ICdhbnknID8gY29udmVydERpc2p1bmN0aW9uT3AoZmlsdGVyLnNsaWNlKDEpKSA6IG9wID09PSAnYWxsJyA/IFsnYWxsJ10uY29uY2F0KGZpbHRlci5zbGljZSgxKS5tYXAoY29udmVydEZpbHRlcikpIDogb3AgPT09ICdub25lJyA/IFsnYWxsJ10uY29uY2F0KGZpbHRlci5zbGljZSgxKS5tYXAoY29udmVydEZpbHRlcikubWFwKGNvbnZlcnROZWdhdGlvbikpIDogb3AgPT09ICdpbicgPyBjb252ZXJ0SW5PcChmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSkgOiBvcCA9PT0gJyFpbicgPyBjb252ZXJ0TmVnYXRpb24oY29udmVydEluT3AoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMikpKSA6IG9wID09PSAnaGFzJyA/IGNvbnZlcnRIYXNPcChmaWx0ZXJbMV0pIDogb3AgPT09ICchaGFzJyA/IGNvbnZlcnROZWdhdGlvbihjb252ZXJ0SGFzT3AoZmlsdGVyWzFdKSkgOiB0cnVlO1xuICAgIHJldHVybiBjb252ZXJ0ZWQ7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29tcGFyaXNvbk9wKHByb3BlcnR5LCB2YWx1ZSwgb3ApIHtcbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnJHR5cGUnOlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2ZpbHRlci10eXBlLScgKyBvcCxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgY2FzZSAnJGlkJzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdmaWx0ZXItaWQtJyArIG9wLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgXTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2ZpbHRlci0nICsgb3AsXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydERpc2p1bmN0aW9uT3AoZmlsdGVycykge1xuICAgIHJldHVybiBbJ2FueSddLmNvbmNhdChmaWx0ZXJzLm1hcChjb252ZXJ0RmlsdGVyKSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0SW5PcChwcm9wZXJ0eSwgdmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnJHR5cGUnOlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2ZpbHRlci10eXBlLWluJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgdmFsdWVzXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgY2FzZSAnJGlkJzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdmaWx0ZXItaWQtaW4nLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB2YWx1ZXNcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDIwMCAmJiAhdmFsdWVzLnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHYgIT09IHR5cGVvZiB2YWx1ZXNbMF07XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnZmlsdGVyLWluLWxhcmdlJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNvcnQoY29tcGFyZSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnZmlsdGVyLWluLXNtYWxsJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRIYXNPcChwcm9wZXJ0eSkge1xuICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICBjYXNlICckdHlwZSc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJyRpZCc6XG4gICAgICAgIHJldHVybiBbJ2ZpbHRlci1oYXMtaWQnXTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2ZpbHRlci1oYXMnLFxuICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgXTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0TmVnYXRpb24oZmlsdGVyKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJyEnLFxuICAgICAgICBmaWx0ZXJcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RmlsdGVyJDEoZmlsdGVyKSB7XG4gICAgcmV0dXJuIF9jb252ZXJ0RmlsdGVyKGZpbHRlciwge30pO1xufVxuZnVuY3Rpb24gX2NvbnZlcnRGaWx0ZXIoZmlsdGVyLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgdmFyIHJlZiQxO1xuICAgIGlmIChpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH1cbiAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIG9wID0gZmlsdGVyWzBdO1xuICAgIGlmIChmaWx0ZXIubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIG9wICE9PSAnYW55JztcbiAgICB9XG4gICAgdmFyIGNvbnZlcnRlZDtcbiAgICBpZiAob3AgPT09ICc9PScgfHwgb3AgPT09ICchPScgfHwgb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9wID09PSAnPD0nIHx8IG9wID09PSAnPj0nKSB7XG4gICAgICAgIHZhciByZWYgPSBmaWx0ZXI7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVmWzJdO1xuICAgICAgICBjb252ZXJ0ZWQgPSBjb252ZXJ0Q29tcGFyaXNvbk9wJDEocHJvcGVydHksIHZhbHVlLCBvcCwgZXhwZWN0ZWRUeXBlcyk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJ2FueScpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZmlsdGVyLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgdmFyIHR5cGVzID0ge307XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfY29udmVydEZpbHRlcihmLCB0eXBlcyk7XG4gICAgICAgICAgICB2YXIgdHlwZWNoZWNrcyA9IHJ1bnRpbWVUeXBlQ2hlY2tzKHR5cGVzKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlY2hlY2tzID09PSB0cnVlID8gY2hpbGQgOiBbXG4gICAgICAgICAgICAgICAgJ2Nhc2UnLFxuICAgICAgICAgICAgICAgIHR5cGVjaGVja3MsXG4gICAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWydhbnknXS5jb25jYXQoY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICdhbGwnKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiQxID0gZmlsdGVyLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgcmV0dXJuIF9jb252ZXJ0RmlsdGVyKGYsIGV4cGVjdGVkVHlwZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuJDEubGVuZ3RoID4gMSA/IFsnYWxsJ10uY29uY2F0KGNoaWxkcmVuJDEpIDogKHJlZiQxID0gW10pLmNvbmNhdC5hcHBseShyZWYkMSwgY2hpbGRyZW4kMSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnIScsXG4gICAgICAgICAgICBfY29udmVydEZpbHRlcihbJ2FueSddLmNvbmNhdChmaWx0ZXIuc2xpY2UoMSkpLCB7fSlcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnaW4nKSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IGNvbnZlcnRJbk9wJDEoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMikpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICchaW4nKSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IGNvbnZlcnRJbk9wJDEoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMiksIHRydWUpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICdoYXMnKSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IGNvbnZlcnRIYXNPcCQxKGZpbHRlclsxXSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyFoYXMnKSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IFtcbiAgICAgICAgICAgICchJyxcbiAgICAgICAgICAgIGNvbnZlcnRIYXNPcCQxKGZpbHRlclsxXSlcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb252ZXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkO1xufVxuZnVuY3Rpb24gcnVudGltZVR5cGVDaGVja3MoZXhwZWN0ZWRUeXBlcykge1xuICAgIHZhciBjb25kaXRpb25zID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZXhwZWN0ZWRUeXBlcykge1xuICAgICAgICB2YXIgZ2V0ID0gcHJvcGVydHkgPT09ICckaWQnID8gWydpZCddIDogW1xuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICBdO1xuICAgICAgICBjb25kaXRpb25zLnB1c2goW1xuICAgICAgICAgICAgJz09JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAndHlwZW9mJyxcbiAgICAgICAgICAgICAgICBnZXRcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzW3Byb3BlcnR5XVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnNbMF07XG4gICAgfVxuICAgIHJldHVybiBbJ2FsbCddLmNvbmNhdChjb25kaXRpb25zKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRDb21wYXJpc29uT3AkMShwcm9wZXJ0eSwgdmFsdWUsIG9wLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgdmFyIGdldDtcbiAgICBpZiAocHJvcGVydHkgPT09ICckdHlwZScpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9wLFxuICAgICAgICAgICAgWydnZW9tZXRyeS10eXBlJ10sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICckaWQnKSB7XG4gICAgICAgIGdldCA9IFsnaWQnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXQgPSBbXG4gICAgICAgICAgICAnZ2V0JyxcbiAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgIF07XG4gICAgfVxuICAgIGlmIChleHBlY3RlZFR5cGVzICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICBleHBlY3RlZFR5cGVzW3Byb3BlcnR5XSA9IHR5cGU7XG4gICAgfVxuICAgIGlmIChvcCA9PT0gJz09JyAmJiBwcm9wZXJ0eSAhPT0gJyRpZCcgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdhbGwnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdoYXMnLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc9PScsXG4gICAgICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnIT0nICYmIHByb3BlcnR5ICE9PSAnJGlkJyAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2FueScsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJyEnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ2hhcycsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnIT0nLFxuICAgICAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIG9wLFxuICAgICAgICBnZXQsXG4gICAgICAgIHZhbHVlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRJbk9wJDEocHJvcGVydHksIHZhbHVlcywgbmVnYXRlKSB7XG4gICAgaWYgKG5lZ2F0ZSA9PT0gdm9pZCAwKVxuICAgICAgICBuZWdhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmVnYXRlO1xuICAgIH1cbiAgICB2YXIgZ2V0O1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJyR0eXBlJykge1xuICAgICAgICBnZXQgPSBbJ2dlb21ldHJ5LXR5cGUnXTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnJGlkJykge1xuICAgICAgICBnZXQgPSBbJ2lkJ107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0ID0gW1xuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICBdO1xuICAgIH1cbiAgICB2YXIgdW5pZm9ybVR5cGVzID0gdHJ1ZTtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZXNbMF07XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB2YWx1ZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHVuaWZvcm1UeXBlcyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVuaWZvcm1UeXBlcyAmJiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHZhciB1bmlxdWVWYWx1ZXMgPSB2YWx1ZXMuc29ydCgpLmZpbHRlcihmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgPT09IDAgfHwgdmFsdWVzW2kgLSAxXSAhPT0gdjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnbWF0Y2gnLFxuICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgdW5pcXVlVmFsdWVzLFxuICAgICAgICAgICAgIW5lZ2F0ZSxcbiAgICAgICAgICAgIG5lZ2F0ZVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW25lZ2F0ZSA/ICdhbGwnIDogJ2FueSddLmNvbmNhdCh2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZWdhdGUgPyAnIT0nIDogJz09JyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHZcbiAgICAgICAgXTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0SGFzT3AkMShwcm9wZXJ0eSkge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJyR0eXBlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnJGlkJykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJyE9JyxcbiAgICAgICAgICAgIFsnaWQnXSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2hhcycsXG4gICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWlncmF0ZVRvRXhwcmVzc2lvbnMgKHN0eWxlKSB7XG4gICAgdmFyIGNvbnZlcnRlZCA9IFtdO1xuICAgIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmIChsYXllci5maWx0ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmZpbHRlciA9IGNvbnZlcnRGaWx0ZXIkMShsYXllci5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZWFjaFByb3BlcnR5KHN0eWxlLCB7XG4gICAgICAgIHBhaW50OiB0cnVlLFxuICAgICAgICBsYXlvdXQ6IHRydWVcbiAgICB9LCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZSA9IHJlZi5yZWZlcmVuY2U7XG4gICAgICAgIHZhciBzZXQgPSByZWYuc2V0O1xuICAgICAgICBpZiAoaXNFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgc2V0KGNvbnZlcnRGdW5jdGlvbih2YWx1ZSwgcmVmZXJlbmNlKSk7XG4gICAgICAgICAgICBjb252ZXJ0ZWQucHVzaChwYXRoLmpvaW4oJy4nKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJlbmNlLnRva2VucyAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZXQoY29udmVydFRva2VuU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIG1pZ3JhdGUgKHN0eWxlKSB7XG4gICAgdmFyIG1pZ3JhdGVkID0gZmFsc2U7XG4gICAgaWYgKHN0eWxlLnZlcnNpb24gPT09IDcpIHtcbiAgICAgICAgc3R5bGUgPSBtaWdyYXRlVG9WOChzdHlsZSk7XG4gICAgICAgIG1pZ3JhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlLnZlcnNpb24gPT09IDgpIHtcbiAgICAgICAgbWlncmF0ZWQgPSBtaWdyYXRlVG9FeHByZXNzaW9ucyhzdHlsZSk7XG4gICAgICAgIG1pZ3JhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFtaWdyYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBtaWdyYXRlIGZyb20nLCBzdHlsZS52ZXJzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NpdGUgKHN0eWxlKSB7XG4gICAgdmFyIHN0eWxlSURzID0gW107XG4gICAgdmFyIHNvdXJjZUlEcyA9IFtdO1xuICAgIHZhciBjb21wb3NpdGVkU291cmNlTGF5ZXJzID0gW107XG4gICAgZm9yICh2YXIgaWQgaW4gc3R5bGUuc291cmNlcykge1xuICAgICAgICB2YXIgc291cmNlID0gc3R5bGUuc291cmNlc1tpZF07XG4gICAgICAgIGlmIChzb3VyY2UudHlwZSAhPT0gJ3ZlY3RvcicpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCA9IC9ebWFwYm94OlxcL1xcLyguKikvLmV4ZWMoc291cmNlLnVybCk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlSURzLnB1c2goaWQpO1xuICAgICAgICBzb3VyY2VJRHMucHVzaChtYXRjaFsxXSk7XG4gICAgfVxuICAgIGlmIChzdHlsZUlEcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gICAgc3R5bGVJRHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgZGVsZXRlIHN0eWxlLnNvdXJjZXNbaWRdO1xuICAgIH0pO1xuICAgIHZhciBjb21wb3NpdGVJRCA9IHNvdXJjZUlEcy5qb2luKCcsJyk7XG4gICAgc3R5bGUuc291cmNlc1tjb21wb3NpdGVJRF0gPSB7XG4gICAgICAgICd0eXBlJzogJ3ZlY3RvcicsXG4gICAgICAgICd1cmwnOiAnbWFwYm94Oi8vJyArIGNvbXBvc2l0ZUlEXG4gICAgfTtcbiAgICBzdHlsZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKHN0eWxlSURzLmluZGV4T2YobGF5ZXIuc291cmNlKSA+PSAwKSB7XG4gICAgICAgICAgICBsYXllci5zb3VyY2UgPSBjb21wb3NpdGVJRDtcbiAgICAgICAgICAgIGlmICgnc291cmNlLWxheWVyJyBpbiBsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb3NpdGVkU291cmNlTGF5ZXJzLmluZGV4T2YobGF5ZXJbJ3NvdXJjZS1sYXllciddKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmxpY3Rpbmcgc291cmNlIGxheWVyIG5hbWVzJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlZFNvdXJjZUxheWVycy5wdXNoKGxheWVyWydzb3VyY2UtbGF5ZXInXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG52YXIgcmVmUHJvcGVydGllcyA9IFtcbiAgICAndHlwZScsXG4gICAgJ3NvdXJjZScsXG4gICAgJ3NvdXJjZS1sYXllcicsXG4gICAgJ21pbnpvb20nLFxuICAgICdtYXh6b29tJyxcbiAgICAnZmlsdGVyJyxcbiAgICAnbGF5b3V0J1xuXTtcblxuZnVuY3Rpb24gZGVyZWYobGF5ZXIsIHBhcmVudCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBrIGluIGxheWVyKSB7XG4gICAgICAgIGlmIChrICE9PSAncmVmJykge1xuICAgICAgICAgICAgcmVzdWx0W2tdID0gbGF5ZXJba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrIGluIHBhcmVudCkge1xuICAgICAgICAgICAgcmVzdWx0W2tdID0gcGFyZW50W2tdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRlcmVmTGF5ZXJzKGxheWVycykge1xuICAgIGxheWVycyA9IGxheWVycy5zbGljZSgpO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcFtsYXllcnNbaV0uaWRdID0gbGF5ZXJzW2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsYXllcnMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICBpZiAoJ3JlZicgaW4gbGF5ZXJzW2kkMV0pIHtcbiAgICAgICAgICAgIGxheWVyc1tpJDFdID0gZGVyZWYobGF5ZXJzW2kkMV0sIG1hcFtsYXllcnNbaSQxXS5yZWZdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzO1xufVxuXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoISh0eXBlb2YgYiA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cblxudmFyIG9wZXJhdGlvbnMgPSB7XG4gICAgc2V0U3R5bGU6ICdzZXRTdHlsZScsXG4gICAgYWRkTGF5ZXI6ICdhZGRMYXllcicsXG4gICAgcmVtb3ZlTGF5ZXI6ICdyZW1vdmVMYXllcicsXG4gICAgc2V0UGFpbnRQcm9wZXJ0eTogJ3NldFBhaW50UHJvcGVydHknLFxuICAgIHNldExheW91dFByb3BlcnR5OiAnc2V0TGF5b3V0UHJvcGVydHknLFxuICAgIHNldEZpbHRlcjogJ3NldEZpbHRlcicsXG4gICAgYWRkU291cmNlOiAnYWRkU291cmNlJyxcbiAgICByZW1vdmVTb3VyY2U6ICdyZW1vdmVTb3VyY2UnLFxuICAgIHNldEdlb0pTT05Tb3VyY2VEYXRhOiAnc2V0R2VvSlNPTlNvdXJjZURhdGEnLFxuICAgIHNldExheWVyWm9vbVJhbmdlOiAnc2V0TGF5ZXJab29tUmFuZ2UnLFxuICAgIHNldExheWVyUHJvcGVydHk6ICdzZXRMYXllclByb3BlcnR5JyxcbiAgICBzZXRDZW50ZXI6ICdzZXRDZW50ZXInLFxuICAgIHNldFpvb206ICdzZXRab29tJyxcbiAgICBzZXRCZWFyaW5nOiAnc2V0QmVhcmluZycsXG4gICAgc2V0UGl0Y2g6ICdzZXRQaXRjaCcsXG4gICAgc2V0U3ByaXRlOiAnc2V0U3ByaXRlJyxcbiAgICBzZXRHbHlwaHM6ICdzZXRHbHlwaHMnLFxuICAgIHNldFRyYW5zaXRpb246ICdzZXRUcmFuc2l0aW9uJyxcbiAgICBzZXRMaWdodDogJ3NldExpZ2h0J1xufTtcbmZ1bmN0aW9uIGFkZFNvdXJjZShzb3VyY2VJZCwgYWZ0ZXIsIGNvbW1hbmRzKSB7XG4gICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuYWRkU291cmNlLFxuICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICBzb3VyY2VJZCxcbiAgICAgICAgICAgIGFmdGVyW3NvdXJjZUlkXVxuICAgICAgICBdXG4gICAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCkge1xuICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZVNvdXJjZSxcbiAgICAgICAgYXJnczogW3NvdXJjZUlkXVxuICAgIH0pO1xuICAgIHNvdXJjZXNSZW1vdmVkW3NvdXJjZUlkXSA9IHRydWU7XG59XG5mdW5jdGlvbiB1cGRhdGVTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpIHtcbiAgICByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7XG4gICAgYWRkU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gY2FuVXBkYXRlR2VvSlNPTihiZWZvcmUsIGFmdGVyLCBzb3VyY2VJZCkge1xuICAgIHZhciBwcm9wO1xuICAgIGZvciAocHJvcCBpbiBiZWZvcmVbc291cmNlSWRdKSB7XG4gICAgICAgIGlmICghYmVmb3JlW3NvdXJjZUlkXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3AgIT09ICdkYXRhJyAmJiAhZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF1bcHJvcF0sIGFmdGVyW3NvdXJjZUlkXVtwcm9wXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3AgaW4gYWZ0ZXJbc291cmNlSWRdKSB7XG4gICAgICAgIGlmICghYWZ0ZXJbc291cmNlSWRdLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcCAhPT0gJ2RhdGEnICYmICFkZWVwRXF1YWwoYmVmb3JlW3NvdXJjZUlkXVtwcm9wXSwgYWZ0ZXJbc291cmNlSWRdW3Byb3BdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGlmZlNvdXJjZXMoYmVmb3JlLCBhZnRlciwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKSB7XG4gICAgYmVmb3JlID0gYmVmb3JlIHx8IHt9O1xuICAgIGFmdGVyID0gYWZ0ZXIgfHwge307XG4gICAgdmFyIHNvdXJjZUlkO1xuICAgIGZvciAoc291cmNlSWQgaW4gYmVmb3JlKSB7XG4gICAgICAgIGlmICghYmVmb3JlLmhhc093blByb3BlcnR5KHNvdXJjZUlkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhZnRlci5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVNvdXJjZShzb3VyY2VJZCwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHNvdXJjZUlkIGluIGFmdGVyKSB7XG4gICAgICAgIGlmICghYWZ0ZXIuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgIGFkZFNvdXJjZShzb3VyY2VJZCwgYWZ0ZXIsIGNvbW1hbmRzKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF0sIGFmdGVyW3NvdXJjZUlkXSkpIHtcbiAgICAgICAgICAgIGlmIChiZWZvcmVbc291cmNlSWRdLnR5cGUgPT09ICdnZW9qc29uJyAmJiBhZnRlcltzb3VyY2VJZF0udHlwZSA9PT0gJ2dlb2pzb24nICYmIGNhblVwZGF0ZUdlb0pTT04oYmVmb3JlLCBhZnRlciwgc291cmNlSWQpKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0R2VvSlNPTlNvdXJjZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJbc291cmNlSWRdLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZSwgYWZ0ZXIsIGNvbW1hbmRzLCBsYXllcklkLCBrbGFzcywgY29tbWFuZCkge1xuICAgIGJlZm9yZSA9IGJlZm9yZSB8fCB7fTtcbiAgICBhZnRlciA9IGFmdGVyIHx8IHt9O1xuICAgIHZhciBwcm9wO1xuICAgIGZvciAocHJvcCBpbiBiZWZvcmUpIHtcbiAgICAgICAgaWYgKCFiZWZvcmUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZVtwcm9wXSwgYWZ0ZXJbcHJvcF0pKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJbcHJvcF0sXG4gICAgICAgICAgICAgICAgICAgIGtsYXNzXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wIGluIGFmdGVyKSB7XG4gICAgICAgIGlmICghYWZ0ZXIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgYmVmb3JlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVbcHJvcF0sIGFmdGVyW3Byb3BdKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyW3Byb3BdLFxuICAgICAgICAgICAgICAgICAgICBrbGFzc1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGx1Y2tJZChsYXllcikge1xuICAgIHJldHVybiBsYXllci5pZDtcbn1cbmZ1bmN0aW9uIGluZGV4QnlJZChncm91cCwgbGF5ZXIpIHtcbiAgICBncm91cFtsYXllci5pZF0gPSBsYXllcjtcbiAgICByZXR1cm4gZ3JvdXA7XG59XG5mdW5jdGlvbiBkaWZmTGF5ZXJzKGJlZm9yZSwgYWZ0ZXIsIGNvbW1hbmRzKSB7XG4gICAgYmVmb3JlID0gYmVmb3JlIHx8IFtdO1xuICAgIGFmdGVyID0gYWZ0ZXIgfHwgW107XG4gICAgdmFyIGJlZm9yZU9yZGVyID0gYmVmb3JlLm1hcChwbHVja0lkKTtcbiAgICB2YXIgYWZ0ZXJPcmRlciA9IGFmdGVyLm1hcChwbHVja0lkKTtcbiAgICB2YXIgYmVmb3JlSW5kZXggPSBiZWZvcmUucmVkdWNlKGluZGV4QnlJZCwge30pO1xuICAgIHZhciBhZnRlckluZGV4ID0gYWZ0ZXIucmVkdWNlKGluZGV4QnlJZCwge30pO1xuICAgIHZhciB0cmFja2VyID0gYmVmb3JlT3JkZXIuc2xpY2UoKTtcbiAgICB2YXIgY2xlYW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBpLCBkLCBsYXllcklkLCBiZWZvcmVMYXllciwgYWZ0ZXJMYXllciwgaW5zZXJ0QmVmb3JlTGF5ZXJJZCwgcHJvcDtcbiAgICBmb3IgKGkgPSAwLCBkID0gMDsgaSA8IGJlZm9yZU9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxheWVySWQgPSBiZWZvcmVPcmRlcltpXTtcbiAgICAgICAgaWYgKCFhZnRlckluZGV4Lmhhc093blByb3BlcnR5KGxheWVySWQpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZUxheWVyLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtsYXllcklkXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmFja2VyLnNwbGljZSh0cmFja2VyLmluZGV4T2YobGF5ZXJJZCwgZCksIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGQgPSAwOyBpIDwgYWZ0ZXJPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYXllcklkID0gYWZ0ZXJPcmRlclthZnRlck9yZGVyLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgaWYgKHRyYWNrZXJbdHJhY2tlci5sZW5ndGggLSAxIC0gaV0gPT09IGxheWVySWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWZvcmVJbmRleC5oYXNPd25Qcm9wZXJ0eShsYXllcklkKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXJJZF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhY2tlci5zcGxpY2UodHJhY2tlci5sYXN0SW5kZXhPZihsYXllcklkLCB0cmFja2VyLmxlbmd0aCAtIGQpLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQrKztcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkID0gdHJhY2tlclt0cmFja2VyLmxlbmd0aCAtIGldO1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuYWRkTGF5ZXIsXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgYWZ0ZXJJbmRleFtsYXllcklkXSxcbiAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICB0cmFja2VyLnNwbGljZSh0cmFja2VyLmxlbmd0aCAtIGksIDAsIGxheWVySWQpO1xuICAgICAgICBjbGVhbltsYXllcklkXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhZnRlck9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxheWVySWQgPSBhZnRlck9yZGVyW2ldO1xuICAgICAgICBiZWZvcmVMYXllciA9IGJlZm9yZUluZGV4W2xheWVySWRdO1xuICAgICAgICBhZnRlckxheWVyID0gYWZ0ZXJJbmRleFtsYXllcklkXTtcbiAgICAgICAgaWYgKGNsZWFuW2xheWVySWRdIHx8IGRlZXBFcXVhbChiZWZvcmVMYXllciwgYWZ0ZXJMYXllcikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyLnNvdXJjZSwgYWZ0ZXJMYXllci5zb3VyY2UpIHx8ICFkZWVwRXF1YWwoYmVmb3JlTGF5ZXJbJ3NvdXJjZS1sYXllciddLCBhZnRlckxheWVyWydzb3VyY2UtbGF5ZXInXSkgfHwgIWRlZXBFcXVhbChiZWZvcmVMYXllci50eXBlLCBhZnRlckxheWVyLnR5cGUpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZUxheWVyLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtsYXllcklkXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkID0gdHJhY2tlclt0cmFja2VyLmxhc3RJbmRleE9mKGxheWVySWQpICsgMV07XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLmFkZExheWVyLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllcixcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTGF5ZXJJZFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyLmxheW91dCwgYWZ0ZXJMYXllci5sYXlvdXQsIGNvbW1hbmRzLCBsYXllcklkLCBudWxsLCBvcGVyYXRpb25zLnNldExheW91dFByb3BlcnR5KTtcbiAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyLnBhaW50LCBhZnRlckxheWVyLnBhaW50LCBjb21tYW5kcywgbGF5ZXJJZCwgbnVsbCwgb3BlcmF0aW9ucy5zZXRQYWludFByb3BlcnR5KTtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIuZmlsdGVyLCBhZnRlckxheWVyLmZpbHRlcikpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0RmlsdGVyLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllci5maWx0ZXJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllci5taW56b29tLCBhZnRlckxheWVyLm1pbnpvb20pIHx8ICFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIubWF4em9vbSwgYWZ0ZXJMYXllci5tYXh6b29tKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRMYXllclpvb21SYW5nZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyTGF5ZXIubWluem9vbSxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllci5tYXh6b29tXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIGJlZm9yZUxheWVyKSB7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZUxheWVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2xheW91dCcgfHwgcHJvcCA9PT0gJ3BhaW50JyB8fCBwcm9wID09PSAnZmlsdGVyJyB8fCBwcm9wID09PSAnbWV0YWRhdGEnIHx8IHByb3AgPT09ICdtaW56b29tJyB8fCBwcm9wID09PSAnbWF4em9vbScpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wLmluZGV4T2YoJ3BhaW50LicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdLCBjb21tYW5kcywgbGF5ZXJJZCwgcHJvcC5zbGljZSg2KSwgb3BlcmF0aW9ucy5zZXRQYWludFByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllcltwcm9wXSwgYWZ0ZXJMYXllcltwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRMYXllclByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGF5ZXJbcHJvcF1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBhZnRlckxheWVyKSB7XG4gICAgICAgICAgICBpZiAoIWFmdGVyTGF5ZXIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgYmVmb3JlTGF5ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnbGF5b3V0JyB8fCBwcm9wID09PSAncGFpbnQnIHx8IHByb3AgPT09ICdmaWx0ZXInIHx8IHByb3AgPT09ICdtZXRhZGF0YScgfHwgcHJvcCA9PT0gJ21pbnpvb20nIHx8IHByb3AgPT09ICdtYXh6b29tJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AuaW5kZXhPZigncGFpbnQuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlTGF5ZXJbcHJvcF0sIGFmdGVyTGF5ZXJbcHJvcF0sIGNvbW1hbmRzLCBsYXllcklkLCBwcm9wLnNsaWNlKDYpLCBvcGVyYXRpb25zLnNldFBhaW50UHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldExheWVyUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllcltwcm9wXVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkaWZmU3R5bGVzKGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBpZiAoIWJlZm9yZSkge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlcl1cbiAgICAgICAgICAgIH1dO1xuICAgIH1cbiAgICB2YXIgY29tbWFuZHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUudmVyc2lvbiwgYWZ0ZXIudmVyc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXJdXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmNlbnRlciwgYWZ0ZXIuY2VudGVyKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRDZW50ZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmNlbnRlcl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS56b29tLCBhZnRlci56b29tKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRab29tLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci56b29tXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmJlYXJpbmcsIGFmdGVyLmJlYXJpbmcpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEJlYXJpbmcsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmJlYXJpbmddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUucGl0Y2gsIGFmdGVyLnBpdGNoKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRQaXRjaCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIucGl0Y2hdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuc3ByaXRlLCBhZnRlci5zcHJpdGUpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFNwcml0ZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIuc3ByaXRlXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmdseXBocywgYWZ0ZXIuZ2x5cGhzKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRHbHlwaHMsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmdseXBoc11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS50cmFuc2l0aW9uLCBhZnRlci50cmFuc2l0aW9uKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRUcmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci50cmFuc2l0aW9uXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmxpZ2h0LCBhZnRlci5saWdodCkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGlnaHQsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmxpZ2h0XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZXNSZW1vdmVkID0ge307XG4gICAgICAgIHZhciByZW1vdmVPckFkZFNvdXJjZUNvbW1hbmRzID0gW107XG4gICAgICAgIGRpZmZTb3VyY2VzKGJlZm9yZS5zb3VyY2VzLCBhZnRlci5zb3VyY2VzLCByZW1vdmVPckFkZFNvdXJjZUNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7XG4gICAgICAgIHZhciBiZWZvcmVMYXllcnMgPSBbXTtcbiAgICAgICAgaWYgKGJlZm9yZS5sYXllcnMpIHtcbiAgICAgICAgICAgIGJlZm9yZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlc1JlbW92ZWRbbGF5ZXIuc291cmNlXSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlTGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXIuaWRdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb21tYW5kcyA9IGNvbW1hbmRzLmNvbmNhdChyZW1vdmVPckFkZFNvdXJjZUNvbW1hbmRzKTtcbiAgICAgICAgZGlmZkxheWVycyhiZWZvcmVMYXllcnMsIGFmdGVyLmxheWVycywgY29tbWFuZHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gY29tcHV0ZSBzdHlsZSBkaWZmOicsIGUpO1xuICAgICAgICBjb21tYW5kcyA9IFt7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTdHlsZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXJdXG4gICAgICAgICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzO1xufVxuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIG1lc3NhZ2UsIGlkZW50aWZpZXIpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAoa2V5ID8ga2V5ICsgJzogJyA6ICcnKSArIG1lc3NhZ2U7XG4gICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuX19saW5lX18pIHtcbiAgICAgICAgdGhpcy5saW5lID0gdmFsdWUuX19saW5lX187XG4gICAgfVxufTtcblxudmFyIFBhcnNpbmdFcnJvciQxID0gZnVuY3Rpb24gUGFyc2luZ0Vycm9yKGVycm9yKSB7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgdmFyIG1hdGNoID0gZXJyb3IubWVzc2FnZS5tYXRjaCgvbGluZSAoXFxkKykvKTtcbiAgICB0aGlzLmxpbmUgPSBtYXRjaCA/IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgOiAwO1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVDb25zdGFudHMob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgY29uc3RhbnRzID0gb3B0aW9ucy52YWx1ZTtcbiAgICBpZiAoY29uc3RhbnRzKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGNvbnN0YW50cywgJ2NvbnN0YW50cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2OCcpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bmJ1bmRsZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVlcFVuYnVuZGxlKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZGVlcFVuYnVuZGxlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmICEodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSkge1xuICAgICAgICB2YXIgdW5idW5kbGVkVmFsdWUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICB1bmJ1bmRsZWRWYWx1ZVtrZXldID0gZGVlcFVuYnVuZGxlKHZhbHVlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmJ1bmRsZWRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuYnVuZGxlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgb2JqZWN0ID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgZWxlbWVudFNwZWNzID0gb3B0aW9ucy52YWx1ZVNwZWMgfHwge307XG4gICAgdmFyIGVsZW1lbnRWYWxpZGF0b3JzID0gb3B0aW9ucy5vYmplY3RFbGVtZW50VmFsaWRhdG9ycyB8fCB7fTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKG9iamVjdCk7XG4gICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG9iamVjdCwgJ29iamVjdCBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldO1xuICAgIH1cbiAgICBmb3IgKHZhciBvYmplY3RLZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHZhciBlbGVtZW50U3BlY0tleSA9IG9iamVjdEtleS5zcGxpdCgnLicpWzBdO1xuICAgICAgICB2YXIgZWxlbWVudFNwZWMgPSBlbGVtZW50U3BlY3NbZWxlbWVudFNwZWNLZXldIHx8IGVsZW1lbnRTcGVjc1snKiddO1xuICAgICAgICB2YXIgdmFsaWRhdGVFbGVtZW50ID0gdm9pZCAwO1xuICAgICAgICBpZiAoZWxlbWVudFZhbGlkYXRvcnNbZWxlbWVudFNwZWNLZXldKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUVsZW1lbnQgPSBlbGVtZW50VmFsaWRhdG9yc1tlbGVtZW50U3BlY0tleV07XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFNwZWNzW2VsZW1lbnRTcGVjS2V5XSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gdmFsaWRhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFZhbGlkYXRvcnNbJyonXSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gZWxlbWVudFZhbGlkYXRvcnNbJyonXTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50U3BlY3NbJyonXSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gdmFsaWRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0W29iamVjdEtleV0sICd1bmtub3duIHByb3BlcnR5IFwiJyArIG9iamVjdEtleSArICdcIicpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbGVtZW50KHtcbiAgICAgICAgICAgIGtleTogKGtleSA/IGtleSArICcuJyA6IGtleSkgKyBvYmplY3RLZXksXG4gICAgICAgICAgICB2YWx1ZTogb2JqZWN0W29iamVjdEtleV0sXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IGVsZW1lbnRTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICAgIG9iamVjdEtleTogb2JqZWN0S2V5XG4gICAgICAgIH0sIG9iamVjdCkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBlbGVtZW50U3BlY0tleSQxIGluIGVsZW1lbnRTcGVjcykge1xuICAgICAgICBpZiAoZWxlbWVudFZhbGlkYXRvcnNbZWxlbWVudFNwZWNLZXkkMV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50U3BlY3NbZWxlbWVudFNwZWNLZXkkMV0ucmVxdWlyZWQgJiYgZWxlbWVudFNwZWNzW2VsZW1lbnRTcGVjS2V5JDFdWydkZWZhdWx0J10gPT09IHVuZGVmaW5lZCAmJiBvYmplY3RbZWxlbWVudFNwZWNLZXkkMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG9iamVjdCwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCInICsgZWxlbWVudFNwZWNLZXkkMSArICdcIicpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5KG9wdGlvbnMpIHtcbiAgICB2YXIgYXJyYXkgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBhcnJheVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHZhbGlkYXRlQXJyYXlFbGVtZW50ID0gb3B0aW9ucy5hcnJheUVsZW1lbnRWYWxpZGF0b3IgfHwgdmFsaWRhdGU7XG4gICAgaWYgKGdldFR5cGUoYXJyYXkpICE9PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCAnYXJyYXkgZXhwZWN0ZWQsICcgKyBnZXRUeXBlKGFycmF5KSArICcgZm91bmQnKV07XG4gICAgfVxuICAgIGlmIChhcnJheVNwZWMubGVuZ3RoICYmIGFycmF5Lmxlbmd0aCAhPT0gYXJyYXlTcGVjLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgJ2FycmF5IGxlbmd0aCAnICsgYXJyYXlTcGVjLmxlbmd0aCArICcgZXhwZWN0ZWQsIGxlbmd0aCAnICsgYXJyYXkubGVuZ3RoICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgaWYgKGFycmF5U3BlY1snbWluLWxlbmd0aCddICYmIGFycmF5Lmxlbmd0aCA8IGFycmF5U3BlY1snbWluLWxlbmd0aCddKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCAnYXJyYXkgbGVuZ3RoIGF0IGxlYXN0ICcgKyBhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSArICcgZXhwZWN0ZWQsIGxlbmd0aCAnICsgYXJyYXkubGVuZ3RoICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgdmFyIGFycmF5RWxlbWVudFNwZWMgPSB7XG4gICAgICAgICd0eXBlJzogYXJyYXlTcGVjLnZhbHVlLFxuICAgICAgICAndmFsdWVzJzogYXJyYXlTcGVjLnZhbHVlc1xuICAgIH07XG4gICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA8IDcpIHtcbiAgICAgICAgYXJyYXlFbGVtZW50U3BlYy5mdW5jdGlvbiA9IGFycmF5U3BlYy5mdW5jdGlvbjtcbiAgICB9XG4gICAgaWYgKGdldFR5cGUoYXJyYXlTcGVjLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXJyYXlFbGVtZW50U3BlYyA9IGFycmF5U3BlYy52YWx1ZTtcbiAgICB9XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUFycmF5RWxlbWVudCh7XG4gICAgICAgICAgICBhcnJheTogYXJyYXksXG4gICAgICAgICAgICBhcnJheUluZGV4OiBpLFxuICAgICAgICAgICAgdmFsdWU6IGFycmF5W2ldLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBhcnJheUVsZW1lbnRTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgICAgICBrZXk6IGtleSArICdbJyArIGkgKyAnXSdcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICB0eXBlID0gJ05hTic7XG4gICAgfVxuICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ251bWJlciBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldO1xuICAgIH1cbiAgICBpZiAoJ21pbmltdW0nIGluIHZhbHVlU3BlYyAmJiB2YWx1ZSA8IHZhbHVlU3BlYy5taW5pbXVtKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCB2YWx1ZSArICcgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHZhbHVlICcgKyB2YWx1ZVNwZWMubWluaW11bSldO1xuICAgIH1cbiAgICBpZiAoJ21heGltdW0nIGluIHZhbHVlU3BlYyAmJiB2YWx1ZSA+IHZhbHVlU3BlYy5tYXhpbXVtKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCB2YWx1ZSArICcgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlICcgKyB2YWx1ZVNwZWMubWF4aW11bSldO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBmdW5jdGlvblZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciBmdW5jdGlvblR5cGUgPSB1bmJ1bmRsZShvcHRpb25zLnZhbHVlLnR5cGUpO1xuICAgIHZhciBzdG9wS2V5VHlwZTtcbiAgICB2YXIgc3RvcERvbWFpblZhbHVlcyA9IHt9O1xuICAgIHZhciBwcmV2aW91c1N0b3BEb21haW5WYWx1ZTtcbiAgICB2YXIgcHJldmlvdXNTdG9wRG9tYWluWm9vbTtcbiAgICB2YXIgaXNab29tRnVuY3Rpb24gPSBmdW5jdGlvblR5cGUgIT09ICdjYXRlZ29yaWNhbCcgJiYgb3B0aW9ucy52YWx1ZS5wcm9wZXJ0eSA9PT0gdW5kZWZpbmVkO1xuICAgIHZhciBpc1Byb3BlcnR5RnVuY3Rpb24gPSAhaXNab29tRnVuY3Rpb247XG4gICAgdmFyIGlzWm9vbUFuZFByb3BlcnR5RnVuY3Rpb24gPSBnZXRUeXBlKG9wdGlvbnMudmFsdWUuc3RvcHMpID09PSAnYXJyYXknICYmIGdldFR5cGUob3B0aW9ucy52YWx1ZS5zdG9wc1swXSkgPT09ICdhcnJheScgJiYgZ2V0VHlwZShvcHRpb25zLnZhbHVlLnN0b3BzWzBdWzBdKSA9PT0gJ29iamVjdCc7XG4gICAgdmFyIGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMuZnVuY3Rpb24sXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgc3RvcHM6IHZhbGlkYXRlRnVuY3Rpb25TdG9wcyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHZhbGlkYXRlRnVuY3Rpb25EZWZhdWx0XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnaWRlbnRpdHknICYmIGlzWm9vbUZ1bmN0aW9uKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwicHJvcGVydHlcIicpKTtcbiAgICB9XG4gICAgaWYgKGZ1bmN0aW9uVHlwZSAhPT0gJ2lkZW50aXR5JyAmJiAhb3B0aW9ucy52YWx1ZS5zdG9wcykge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInN0b3BzXCInKSk7XG4gICAgfVxuICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdleHBvbmVudGlhbCcgJiYgb3B0aW9ucy52YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiAhc3VwcG9ydHNJbnRlcnBvbGF0aW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnZXhwb25lbnRpYWwgZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0eWxlU3BlYy4kdmVyc2lvbiA+PSA4KSB7XG4gICAgICAgIGlmIChpc1Byb3BlcnR5RnVuY3Rpb24gJiYgIXN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ3Byb3BlcnR5IGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzWm9vbUZ1bmN0aW9uICYmICFzdXBwb3J0c1pvb21FeHByZXNzaW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ3pvb20gZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChmdW5jdGlvblR5cGUgPT09ICdjYXRlZ29yaWNhbCcgfHwgaXNab29tQW5kUHJvcGVydHlGdW5jdGlvbikgJiYgb3B0aW9ucy52YWx1ZS5wcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdcInByb3BlcnR5XCIgcHJvcGVydHkgaXMgcmVxdWlyZWQnKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvblN0b3BzKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnaWRlbnRpdHkgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGEgXCJzdG9wc1wiIHByb3BlcnR5JyldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUFycmF5KHtcbiAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IG9wdGlvbnMudmFsdWVTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgYXJyYXlFbGVtZW50VmFsaWRhdG9yOiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ2FycmF5JyAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHZhbHVlLCAnYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdG9wJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25TdG9wKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdhcnJheSBleHBlY3RlZCwgJyArIGdldFR5cGUodmFsdWUpICsgJyBmb3VuZCcpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2FycmF5IGxlbmd0aCAyIGV4cGVjdGVkLCBsZW5ndGggJyArIHZhbHVlLmxlbmd0aCArICcgZm91bmQnKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzWm9vbUFuZFByb3BlcnR5RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChnZXRUeXBlKHZhbHVlWzBdKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ29iamVjdCBleHBlY3RlZCwgJyArIGdldFR5cGUodmFsdWVbMF0pICsgJyBmb3VuZCcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZVswXS56b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ29iamVjdCBzdG9wIGtleSBtdXN0IGhhdmUgem9vbScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZVswXS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHZhbHVlJyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RvcERvbWFpblpvb20gJiYgcHJldmlvdXNTdG9wRG9tYWluWm9vbSA+IHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWVbMF0uem9vbSwgJ3N0b3Agem9vbSB2YWx1ZXMgbXVzdCBhcHBlYXIgaW4gYXNjZW5kaW5nIG9yZGVyJyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pICE9PSBwcmV2aW91c1N0b3BEb21haW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNTdG9wRG9tYWluWm9vbSA9IHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU3RvcERvbWFpblZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHN0b3BEb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1swXScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogeyB6b29tOiB7fSB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgem9vbTogdmFsaWRhdGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWxpZGF0ZVN0b3BEb21haW5WYWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVTdG9wRG9tYWluVmFsdWUoe1xuICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1swXScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzoge30sXG4gICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICAgICAgfSwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFeHByZXNzaW9uKGRlZXBVbmJ1bmRsZSh2YWx1ZVsxXSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzFdJywgdmFsdWVbMV0sICdleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gZnVuY3Rpb24gc3RvcHMuJyldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICBrZXk6IGtleSArICdbMV0nLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzFdLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBmdW5jdGlvblZhbHVlU3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3RvcERvbWFpblZhbHVlKG9wdGlvbnMsIHN0b3ApIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlKG9wdGlvbnMudmFsdWUpO1xuICAgICAgICB2YXIgdmFsdWUgPSB1bmJ1bmRsZShvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgdmFyIHJlcG9ydFZhbHVlID0gb3B0aW9ucy52YWx1ZSAhPT0gbnVsbCA/IG9wdGlvbnMudmFsdWUgOiBzdG9wO1xuICAgICAgICBpZiAoIXN0b3BLZXlUeXBlKSB7XG4gICAgICAgICAgICBzdG9wS2V5VHlwZSA9IHR5cGU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gc3RvcEtleVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsIHR5cGUgKyAnIHN0b3AgZG9tYWluIHR5cGUgbXVzdCBtYXRjaCBwcmV2aW91cyBzdG9wIGRvbWFpbiB0eXBlICcgKyBzdG9wS2V5VHlwZSldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsICdzdG9wIGRvbWFpbiB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLCBzdHJpbmcsIG9yIGJvb2xlYW4nKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmIGZ1bmN0aW9uVHlwZSAhPT0gJ2NhdGVnb3JpY2FsJykge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnbnVtYmVyIGV4cGVjdGVkLCAnICsgdHlwZSArICcgZm91bmQnO1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKGZ1bmN0aW9uVmFsdWVTcGVjKSAmJiBmdW5jdGlvblR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJ1xcbklmIHlvdSBpbnRlbmRlZCB0byB1c2UgYSBjYXRlZ29yaWNhbCBmdW5jdGlvbiwgc3BlY2lmeSBgXCJ0eXBlXCI6IFwiY2F0ZWdvcmljYWxcImAuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsIG1lc3NhZ2UpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHR5cGUgPT09ICdudW1iZXInICYmICghaXNGaW5pdGUodmFsdWUpIHx8IE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsICdpbnRlZ2VyIGV4cGVjdGVkLCBmb3VuZCAnICsgdmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25UeXBlICE9PSAnY2F0ZWdvcmljYWwnICYmIHR5cGUgPT09ICdudW1iZXInICYmIHByZXZpb3VzU3RvcERvbWFpblZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlcyBtdXN0IGFwcGVhciBpbiBhc2NlbmRpbmcgb3JkZXInKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdjYXRlZ29yaWNhbCcgJiYgdmFsdWUgaW4gc3RvcERvbWFpblZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZScpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3BEb21haW5WYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25EZWZhdWx0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHtcbiAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogZnVuY3Rpb25WYWx1ZVNwZWMsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cHJlc3Npb24ob3B0aW9ucykge1xuICAgIHZhciBleHByZXNzaW9uID0gKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdwcm9wZXJ0eScgPyBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24gOiBjcmVhdGVFeHByZXNzaW9uKShkZWVwVW5idW5kbGUob3B0aW9ucy52YWx1ZSksIG9wdGlvbnMudmFsdWVTcGVjKTtcbiAgICBpZiAoZXhwcmVzc2lvbi5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWUubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoJycgKyBvcHRpb25zLmtleSArIGVycm9yLmtleSwgb3B0aW9ucy52YWx1ZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZXhwcmVzc2lvbk9iaiA9IGV4cHJlc3Npb24udmFsdWUuZXhwcmVzc2lvbiB8fCBleHByZXNzaW9uLnZhbHVlLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbjtcbiAgICBpZiAob3B0aW9ucy5leHByZXNzaW9uQ29udGV4dCA9PT0gJ3Byb3BlcnR5JyAmJiBvcHRpb25zLnByb3BlcnR5S2V5ID09PSAndGV4dC1mb250JyAmJiAhZXhwcmVzc2lvbk9iai5vdXRwdXREZWZpbmVkKCkpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnSW52YWxpZCBkYXRhIGV4cHJlc3Npb24gZm9yIFwiJyArIG9wdGlvbnMucHJvcGVydHlLZXkgKyAnXCIuIE91dHB1dCB2YWx1ZXMgbXVzdCBiZSBjb250YWluZWQgYXMgbGl0ZXJhbHMgd2l0aGluIHRoZSBleHByZXNzaW9uLicpXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdwcm9wZXJ0eScgJiYgb3B0aW9ucy5wcm9wZXJ0eVR5cGUgPT09ICdsYXlvdXQnICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbk9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnXCJmZWF0dXJlLXN0YXRlXCIgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGxheW91dCBwcm9wZXJ0aWVzLicpXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdmaWx0ZXInICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbk9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnXCJmZWF0dXJlLXN0YXRlXCIgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGZpbHRlcnMuJyldO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5leHByZXNzaW9uQ29udGV4dCAmJiBvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0LmluZGV4T2YoJ2NsdXN0ZXInKSA9PT0gMCkge1xuICAgICAgICBpZiAoIWlzR2xvYmFsUHJvcGVydHlDb25zdGFudChleHByZXNzaW9uT2JqLCBbXG4gICAgICAgICAgICAgICAgJ3pvb20nLFxuICAgICAgICAgICAgICAgICdmZWF0dXJlLXN0YXRlJ1xuICAgICAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ1wiem9vbVwiIGFuZCBcImZlYXR1cmUtc3RhdGVcIiBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGNsdXN0ZXIgcHJvcGVydGllcy4nKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdjbHVzdGVyLWluaXRpYWwnICYmICFpc0ZlYXR1cmVDb25zdGFudChleHByZXNzaW9uT2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnRmVhdHVyZSBkYXRhIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggaW5pdGlhbCBleHByZXNzaW9uIHBhcnQgb2YgY2x1c3RlciBwcm9wZXJ0aWVzLicpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQm9vbGVhbihvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcbiAgICBpZiAodHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYm9vbGVhbiBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29sb3Iob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29sb3IgZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgaWYgKGNzc2NvbG9ycGFyc2VyXzEodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29sb3IgZXhwZWN0ZWQsIFwiJyArIHZhbHVlICsgJ1wiIGZvdW5kJyldO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRW51bShvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVNwZWMudmFsdWVzKSkge1xuICAgICAgICBpZiAodmFsdWVTcGVjLnZhbHVlcy5pbmRleE9mKHVuYnVuZGxlKHZhbHVlKSkgPT09IC0xKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdleHBlY3RlZCBvbmUgb2YgWycgKyB2YWx1ZVNwZWMudmFsdWVzLmpvaW4oJywgJykgKyAnXSwgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcgZm91bmQnKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWVTcGVjLnZhbHVlcykuaW5kZXhPZih1bmJ1bmRsZSh2YWx1ZSkpID09PSAtMSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZXhwZWN0ZWQgb25lIG9mIFsnICsgT2JqZWN0LmtleXModmFsdWVTcGVjLnZhbHVlcykuam9pbignLCAnKSArICddLCAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJyBmb3VuZCcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZpbHRlcihvcHRpb25zKSB7XG4gICAgaWYgKGlzRXhwcmVzc2lvbkZpbHRlcihkZWVwVW5idW5kbGUob3B0aW9ucy52YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24oZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ2ZpbHRlcicsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHsgdmFsdWU6ICdib29sZWFuJyB9XG4gICAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVOb25FeHByZXNzaW9uRmlsdGVyKG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlcihvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYXJyYXkgZXhwZWN0ZWQsICcgKyBnZXRUeXBlKHZhbHVlKSArICcgZm91bmQnKV07XG4gICAgfVxuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgdHlwZTtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudCcpXTtcbiAgICB9XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUVudW0oe1xuICAgICAgICBrZXk6IGtleSArICdbMF0nLFxuICAgICAgICB2YWx1ZTogdmFsdWVbMF0sXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmZpbHRlcl9vcGVyYXRvcixcbiAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICB9KSk7XG4gICAgc3dpdGNoICh1bmJ1bmRsZSh2YWx1ZVswXSkpIHtcbiAgICBjYXNlICc8JzpcbiAgICBjYXNlICc8PSc6XG4gICAgY2FzZSAnPic6XG4gICAgY2FzZSAnPj0nOlxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIgJiYgdW5idW5kbGUodmFsdWVbMV0pID09PSAnJHR5cGUnKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcIiR0eXBlXCIgY2Fubm90IGJlIHVzZSB3aXRoIG9wZXJhdG9yIFwiJyArIHZhbHVlWzBdICsgJ1wiJykpO1xuICAgICAgICB9XG4gICAgY2FzZSAnPT0nOlxuICAgIGNhc2UgJyE9JzpcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZmlsdGVyIGFycmF5IGZvciBvcGVyYXRvciBcIicgKyB2YWx1ZVswXSArICdcIiBtdXN0IGhhdmUgMyBlbGVtZW50cycpKTtcbiAgICAgICAgfVxuICAgIGNhc2UgJ2luJzpcbiAgICBjYXNlICchaW4nOlxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJ1sxXScsIHZhbHVlWzFdLCAnc3RyaW5nIGV4cGVjdGVkLCAnICsgdHlwZSArICcgZm91bmQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbaV0pO1xuICAgICAgICAgICAgaWYgKHVuYnVuZGxlKHZhbHVlWzFdKSA9PT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbnVtKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnWycgKyBpICsgJ10nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmdlb21ldHJ5X3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbJyArIGkgKyAnXScsIHZhbHVlW2ldLCAnc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW4gZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlICdhbnknOlxuICAgIGNhc2UgJ2FsbCc6XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IHZhbHVlLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVOb25FeHByZXNzaW9uRmlsdGVyKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSArICdbJyArIGkkMSArICddJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaSQxXSxcbiAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaGFzJzpcbiAgICBjYXNlICchaGFzJzpcbiAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgZm9yIFwiJyArIHZhbHVlWzBdICsgJ1wiIG9wZXJhdG9yIG11c3QgaGF2ZSAyIGVsZW1lbnRzJykpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbMV0nLCB2YWx1ZVsxXSwgJ3N0cmluZyBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJykpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KG9wdGlvbnMsIHByb3BlcnR5VHlwZSkge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBwcm9wZXJ0eUtleSA9IG9wdGlvbnMub2JqZWN0S2V5O1xuICAgIHZhciBsYXllclNwZWMgPSBzdHlsZVNwZWNbcHJvcGVydHlUeXBlICsgJ18nICsgb3B0aW9ucy5sYXllclR5cGVdO1xuICAgIGlmICghbGF5ZXJTcGVjKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHRyYW5zaXRpb25NYXRjaCA9IHByb3BlcnR5S2V5Lm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuICAgIGlmIChwcm9wZXJ0eVR5cGUgPT09ICdwYWludCcgJiYgdHJhbnNpdGlvbk1hdGNoICYmIGxheWVyU3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dICYmIGxheWVyU3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dLnRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMudHJhbnNpdGlvbixcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWMgfHwgbGF5ZXJTcGVjW3Byb3BlcnR5S2V5XTtcbiAgICBpZiAoIXZhbHVlU3BlYykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ3Vua25vd24gcHJvcGVydHkgXCInICsgcHJvcGVydHlLZXkgKyAnXCInKV07XG4gICAgfVxuICAgIHZhciB0b2tlbk1hdGNoO1xuICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ3N0cmluZycgJiYgc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24odmFsdWVTcGVjKSAmJiAhdmFsdWVTcGVjLnRva2VucyAmJiAodG9rZW5NYXRjaCA9IC9eeyhbXn1dKyl9JC8uZXhlYyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCInICsgcHJvcGVydHlLZXkgKyAnXCIgZG9lcyBub3Qgc3VwcG9ydCBpbnRlcnBvbGF0aW9uIHN5bnRheFxcbicgKyAnVXNlIGFuIGlkZW50aXR5IHByb3BlcnR5IGZ1bmN0aW9uIGluc3RlYWQ6IGB7IFwidHlwZVwiOiBcImlkZW50aXR5XCIsIFwicHJvcGVydHlcIjogJyArIEpTT04uc3RyaW5naWZ5KHRva2VuTWF0Y2hbMV0pICsgJyB9YC4nKV07XG4gICAgfVxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZiAob3B0aW9ucy5sYXllclR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eUtleSA9PT0gJ3RleHQtZmllbGQnICYmIHN0eWxlICYmICFzdHlsZS5nbHlwaHMpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ3VzZSBvZiBcInRleHQtZmllbGRcIiByZXF1aXJlcyBhIHN0eWxlIFwiZ2x5cGhzXCIgcHJvcGVydHknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5S2V5ID09PSAndGV4dC1mb250JyAmJiBpc0Z1bmN0aW9uJDEoZGVlcFVuYnVuZGxlKHZhbHVlKSkgJiYgdW5idW5kbGUodmFsdWUudHlwZSkgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1widGV4dC1mb250XCIgZG9lcyBub3Qgc3VwcG9ydCBpZGVudGl0eSBmdW5jdGlvbnMnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogdmFsdWVTcGVjLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ3Byb3BlcnR5JyxcbiAgICAgICAgcHJvcGVydHlUeXBlOiBwcm9wZXJ0eVR5cGUsXG4gICAgICAgIHByb3BlcnR5S2V5OiBwcm9wZXJ0eUtleVxuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQYWludFByb3BlcnR5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVQcm9wZXJ0eShvcHRpb25zLCAncGFpbnQnKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVMYXlvdXRQcm9wZXJ0eShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlUHJvcGVydHkob3B0aW9ucywgJ2xheW91dCcpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUxheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIGxheWVyID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgaWYgKCFsYXllci50eXBlICYmICFsYXllci5yZWYpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnZWl0aGVyIFwidHlwZVwiIG9yIFwicmVmXCIgaXMgcmVxdWlyZWQnKSk7XG4gICAgfVxuICAgIHZhciB0eXBlID0gdW5idW5kbGUobGF5ZXIudHlwZSk7XG4gICAgdmFyIHJlZiA9IHVuYnVuZGxlKGxheWVyLnJlZik7XG4gICAgaWYgKGxheWVyLmlkKSB7XG4gICAgICAgIHZhciBsYXllcklkID0gdW5idW5kbGUobGF5ZXIuaWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMuYXJyYXlJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJMYXllciA9IHN0eWxlLmxheWVyc1tpXTtcbiAgICAgICAgICAgIGlmICh1bmJ1bmRsZShvdGhlckxheWVyLmlkKSA9PT0gbGF5ZXJJZCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5pZCwgJ2R1cGxpY2F0ZSBsYXllciBpZCBcIicgKyBsYXllci5pZCArICdcIiwgcHJldmlvdXNseSB1c2VkIGF0IGxpbmUgJyArIG90aGVyTGF5ZXIuaWQuX19saW5lX18pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3JlZicgaW4gbGF5ZXIpIHtcbiAgICAgICAgW1xuICAgICAgICAgICAgJ3R5cGUnLFxuICAgICAgICAgICAgJ3NvdXJjZScsXG4gICAgICAgICAgICAnc291cmNlLWxheWVyJyxcbiAgICAgICAgICAgICdmaWx0ZXInLFxuICAgICAgICAgICAgJ2xheW91dCdcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBpZiAocCBpbiBsYXllcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllcltwXSwgJ1wiJyArIHAgKyAnXCIgaXMgcHJvaGliaXRlZCBmb3IgcmVmIGxheWVycycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYXJlbnQ7XG4gICAgICAgIHN0eWxlLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgaWYgKHVuYnVuZGxlKGxheWVyLmlkKSA9PT0gcmVmKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbGF5ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnJlZiwgJ3JlZiBsYXllciBcIicgKyByZWYgKyAnXCIgbm90IGZvdW5kJykpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC5yZWYpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5yZWYsICdyZWYgY2Fubm90IHJlZmVyZW5jZSBhbm90aGVyIHJlZiBsYXllcicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSB1bmJ1bmRsZShwYXJlbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICBpZiAoIWxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInNvdXJjZVwiJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHN0eWxlLnNvdXJjZXMgJiYgc3R5bGUuc291cmNlc1tsYXllci5zb3VyY2VdO1xuICAgICAgICAgICAgdmFyIHNvdXJjZVR5cGUgPSBzb3VyY2UgJiYgdW5idW5kbGUoc291cmNlLnR5cGUpO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCAnc291cmNlIFwiJyArIGxheWVyLnNvdXJjZSArICdcIiBub3QgZm91bmQnKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09ICd2ZWN0b3InICYmIHR5cGUgPT09ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ2xheWVyIFwiJyArIGxheWVyLmlkICsgJ1wiIHJlcXVpcmVzIGEgcmFzdGVyIHNvdXJjZScpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3Jhc3RlcicgJiYgdHlwZSAhPT0gJ3Jhc3RlcicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCAnbGF5ZXIgXCInICsgbGF5ZXIuaWQgKyAnXCIgcmVxdWlyZXMgYSB2ZWN0b3Igc291cmNlJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlID09PSAndmVjdG9yJyAmJiAhbGF5ZXJbJ3NvdXJjZS1sYXllciddKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnbGF5ZXIgXCInICsgbGF5ZXIuaWQgKyAnXCIgbXVzdCBzcGVjaWZ5IGEgXCJzb3VyY2UtbGF5ZXJcIicpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3Jhc3Rlci1kZW0nICYmIHR5cGUgIT09ICdoaWxsc2hhZGUnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ3Jhc3Rlci1kZW0gc291cmNlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBsYXllciB0eXBlIFxcJ2hpbGxzaGFkZVxcJy4nKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsaW5lJyAmJiBsYXllci5wYWludCAmJiBsYXllci5wYWludFsnbGluZS1ncmFkaWVudCddICYmIChzb3VyY2VUeXBlICE9PSAnZ2VvanNvbicgfHwgIXNvdXJjZS5saW5lTWV0cmljcykpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIsICdsYXllciBcIicgKyBsYXllci5pZCArICdcIiBzcGVjaWZpZXMgYSBsaW5lLWdyYWRpZW50LCB3aGljaCByZXF1aXJlcyBhIEdlb0pTT04gc291cmNlIHdpdGggYGxpbmVNZXRyaWNzYCBlbmFibGVkLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBsYXllcixcbiAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMubGF5ZXIsXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgJyonOiBmdW5jdGlvbiBfKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiB0eXBlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJy50eXBlJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxheWVyLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmxheWVyLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGxheWVyLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RLZXk6ICd0eXBlJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlcjogdmFsaWRhdGVGaWx0ZXIsXG4gICAgICAgICAgICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnKic6IGZ1bmN0aW9uIF8ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUxheW91dFByb3BlcnR5KGV4dGVuZCh7IGxheWVyVHlwZTogdHlwZSB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYWludDogZnVuY3Rpb24gcGFpbnQob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllcixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyonOiBmdW5jdGlvbiBfKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVQYWludFByb3BlcnR5KGV4dGVuZCh7IGxheWVyVHlwZTogdHlwZSB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdzdHJpbmcgZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG52YXIgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnMgPSB7IHByb21vdGVJZDogdmFsaWRhdGVQcm9tb3RlSWQgfTtcbmZ1bmN0aW9uIHZhbGlkYXRlU291cmNlKG9wdGlvbnMpIHtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICBpZiAoIXZhbHVlLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcInR5cGVcIiBpcyByZXF1aXJlZCcpXTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB1bmJ1bmRsZSh2YWx1ZS50eXBlKTtcbiAgICB2YXIgZXJyb3JzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3ZlY3Rvcic6XG4gICAgY2FzZSAncmFzdGVyJzpcbiAgICBjYXNlICdyYXN0ZXItZGVtJzpcbiAgICAgICAgZXJyb3JzID0gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlY1snc291cmNlXycgKyB0eXBlLnJlcGxhY2UoJy0nLCAnXycpXSxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczogb2JqZWN0RWxlbWVudFZhbGlkYXRvcnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgY2FzZSAnZ2VvanNvbic6XG4gICAgICAgIGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX2dlb2pzb24sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiBvYmplY3RFbGVtZW50VmFsaWRhdG9yc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbHVlLmNsdXN0ZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdmFsdWUuY2x1c3RlclByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gdmFsdWUuY2x1c3RlclByb3BlcnRpZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gcmVmWzBdO1xuICAgICAgICAgICAgICAgIHZhciBtYXBFeHByID0gcmVmWzFdO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VFeHByID0gdHlwZW9mIG9wZXJhdG9yID09PSAnc3RyaW5nJyA/IFtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgIFsnYWNjdW11bGF0ZWQnXSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICBdIDogb3BlcmF0b3I7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCB2YWxpZGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSArICcuJyArIHByb3AgKyAnLm1hcCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXBFeHByLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ2NsdXN0ZXItbWFwJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIHZhbGlkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJy4nICsgcHJvcCArICcucmVkdWNlJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlZHVjZUV4cHIsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Db250ZXh0OiAnY2x1c3Rlci1yZWR1Y2UnXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfdmlkZW8sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnNvdXJjZV9pbWFnZSxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgIH0pO1xuICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG51bGwsICdQbGVhc2UgdXNlIHJ1bnRpbWUgQVBJcyB0byBhZGQgY2FudmFzIHNvdXJjZXMsIHJhdGhlciB0aGFuIGluY2x1ZGluZyB0aGVtIGluIHN0eWxlc2hlZXRzLicsICdzb3VyY2UuY2FudmFzJyldO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUVudW0oe1xuICAgICAgICAgICAga2V5OiBrZXkgKyAnLnR5cGUnLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnR5cGUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ3ZlY3RvcicsXG4gICAgICAgICAgICAgICAgICAgICdyYXN0ZXInLFxuICAgICAgICAgICAgICAgICAgICAncmFzdGVyLWRlbScsXG4gICAgICAgICAgICAgICAgICAgICdnZW9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZGVvJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ltYWdlJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb21vdGVJZChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgaWYgKGdldFR5cGUodmFsdWUpID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVTdHJpbmcoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIHZhbGlkYXRlU3RyaW5nKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSArICcuJyArIHByb3AsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW3Byb3BdXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGlnaHQob3B0aW9ucykge1xuICAgIHZhciBsaWdodCA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciBsaWdodFNwZWMgPSBzdHlsZVNwZWMubGlnaHQ7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHJvb3RUeXBlID0gZ2V0VHlwZShsaWdodCk7XG4gICAgaWYgKGxpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9IGVsc2UgaWYgKHJvb3RUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKCdsaWdodCcsIGxpZ2h0LCAnb2JqZWN0IGV4cGVjdGVkLCAnICsgcm9vdFR5cGUgKyAnIGZvdW5kJyldKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIGxpZ2h0KSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uTWF0Y2ggPSBrZXkubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uTWF0Y2ggJiYgbGlnaHRTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0gJiYgbGlnaHRTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0udHJhbnNpdGlvbikge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpZ2h0W2tleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMudHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaWdodFNwZWNba2V5XSkge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpZ2h0W2tleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBsaWdodFNwZWNba2V5XSxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsaWdodFtrZXldLCAndW5rbm93biBwcm9wZXJ0eSBcIicgKyBrZXkgKyAnXCInKV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0dGVkKG9wdGlvbnMpIHtcbiAgICBpZiAodmFsaWRhdGVTdHJpbmcob3B0aW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbihvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVJbWFnZShvcHRpb25zKSB7XG4gICAgaWYgKHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24ob3B0aW9ucyk7XG59XG5cbnZhciBWQUxJREFUT1JTID0ge1xuICAgICcqJzogZnVuY3Rpb24gXygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgJ2FycmF5JzogdmFsaWRhdGVBcnJheSxcbiAgICAnYm9vbGVhbic6IHZhbGlkYXRlQm9vbGVhbixcbiAgICAnbnVtYmVyJzogdmFsaWRhdGVOdW1iZXIsXG4gICAgJ2NvbG9yJzogdmFsaWRhdGVDb2xvcixcbiAgICAnY29uc3RhbnRzJzogdmFsaWRhdGVDb25zdGFudHMsXG4gICAgJ2VudW0nOiB2YWxpZGF0ZUVudW0sXG4gICAgJ2ZpbHRlcic6IHZhbGlkYXRlRmlsdGVyLFxuICAgICdmdW5jdGlvbic6IHZhbGlkYXRlRnVuY3Rpb24sXG4gICAgJ2xheWVyJzogdmFsaWRhdGVMYXllcixcbiAgICAnb2JqZWN0JzogdmFsaWRhdGVPYmplY3QsXG4gICAgJ3NvdXJjZSc6IHZhbGlkYXRlU291cmNlLFxuICAgICdsaWdodCc6IHZhbGlkYXRlTGlnaHQsXG4gICAgJ3N0cmluZyc6IHZhbGlkYXRlU3RyaW5nLFxuICAgICdmb3JtYXR0ZWQnOiB2YWxpZGF0ZUZvcm1hdHRlZCxcbiAgICAncmVzb2x2ZWRJbWFnZSc6IHZhbGlkYXRlSW1hZ2Vcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGlmICh2YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiBpc0Z1bmN0aW9uJDEodW5idW5kbGUodmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVGdW5jdGlvbihvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlU3BlYy5leHByZXNzaW9uICYmIGlzRXhwcmVzc2lvbihkZWVwVW5idW5kbGUodmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVFeHByZXNzaW9uKG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodmFsdWVTcGVjLnR5cGUgJiYgVkFMSURBVE9SU1t2YWx1ZVNwZWMudHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWxpZCA9IHZhbGlkYXRlT2JqZWN0KGV4dGVuZCh7fSwgb3B0aW9ucywgeyB2YWx1ZVNwZWM6IHZhbHVlU3BlYy50eXBlID8gc3R5bGVTcGVjW3ZhbHVlU3BlYy50eXBlXSA6IHZhbHVlU3BlYyB9KSk7XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlR2x5cGhzVVJMIChvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIGVycm9ycyA9IHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCd7Zm9udHN0YWNrfScpID09PSAtMSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcImdseXBoc1wiIHVybCBtdXN0IGluY2x1ZGUgYSBcIntmb250c3RhY2t9XCIgdG9rZW4nKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCd7cmFuZ2V9JykgPT09IC0xKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1wiZ2x5cGhzXCIgdXJsIG11c3QgaW5jbHVkZSBhIFwie3JhbmdlfVwiIHRva2VuJykpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlTWluKHN0eWxlLCBzdHlsZVNwZWMpIHtcbiAgICBpZiAoc3R5bGVTcGVjID09PSB2b2lkIDApXG4gICAgICAgIHN0eWxlU3BlYyA9IHY4O1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAga2V5OiAnJyxcbiAgICAgICAgdmFsdWU6IHN0eWxlLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy4kcm9vdCxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgIGdseXBoczogdmFsaWRhdGVHbHlwaHNVUkwsXG4gICAgICAgICAgICAnKic6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpO1xuICAgIGlmIChzdHlsZS5jb25zdGFudHMpIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUNvbnN0YW50cyh7XG4gICAgICAgICAgICBrZXk6ICdjb25zdGFudHMnLFxuICAgICAgICAgICAgdmFsdWU6IHN0eWxlLmNvbnN0YW50cyxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvcnRFcnJvcnMoZXJyb3JzKTtcbn1cbnZhbGlkYXRlU3R5bGVNaW4uc291cmNlID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlU291cmNlKTtcbnZhbGlkYXRlU3R5bGVNaW4ubGlnaHQgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVMaWdodCk7XG52YWxpZGF0ZVN0eWxlTWluLmxheWVyID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGF5ZXIpO1xudmFsaWRhdGVTdHlsZU1pbi5maWx0ZXIgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVGaWx0ZXIpO1xudmFsaWRhdGVTdHlsZU1pbi5wYWludFByb3BlcnR5ID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlUGFpbnRQcm9wZXJ0eSk7XG52YWxpZGF0ZVN0eWxlTWluLmxheW91dFByb3BlcnR5ID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGF5b3V0UHJvcGVydHkpO1xuZnVuY3Rpb24gc29ydEVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KGVycm9ycykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5saW5lIC0gYi5saW5lO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gd3JhcENsZWFuRXJyb3JzKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxlbi0tKVxuICAgICAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICAgIHJldHVybiBzb3J0RXJyb3JzKGlubmVyLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICB9O1xufVxuXG52YXIganNvbmxpbnQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uIDAuNC4xNSAqL1xuLypcbiAgUmV0dXJucyBhIFBhcnNlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5cbiAgUGFyc2VyOiB7XG4gICAgeXk6IHt9XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlOiB7XG4gICAgeXk6IHt9LFxuICAgIHRyYWNlOiBmdW5jdGlvbigpLFxuICAgIHN5bWJvbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gbnVtYmVyfSxcbiAgICB0ZXJtaW5hbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbnVtYmVyID09PiBuYW1lfSxcbiAgICBwcm9kdWN0aW9uc186IFsuLi5dLFxuICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlLCAkJCwgXyQpLFxuICAgIHRhYmxlOiBbLi4uXSxcbiAgICBkZWZhdWx0QWN0aW9uczogey4uLn0sXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQpLFxuXG4gICAgbGV4ZXI6IHtcbiAgICAgICAgRU9GOiAxLFxuICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24oaW5wdXQpLFxuICAgICAgICBpbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgdW5wdXQ6IGZ1bmN0aW9uKHN0ciksXG4gICAgICAgIG1vcmU6IGZ1bmN0aW9uKCksXG4gICAgICAgIGxlc3M6IGZ1bmN0aW9uKG4pLFxuICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAgICAgICAgdGVzdF9tYXRjaDogZnVuY3Rpb24ocmVnZXhfbWF0Y2hfYXJyYXksIHJ1bGVfaW5kZXgpLFxuICAgICAgICBuZXh0OiBmdW5jdGlvbigpLFxuICAgICAgICBsZXg6IGZ1bmN0aW9uKCksXG4gICAgICAgIGJlZ2luOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICAgICAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAgICAgICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24oKSxcbiAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24oY29uZGl0aW9uKSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICByYW5nZXM6IGJvb2xlYW4gICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIpXG4gICAgICAgICAgICBmbGV4OiBib29sZWFuICAgICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gZmxleC1saWtlIGxleGluZyBiZWhhdmlvdXIgd2hlcmUgdGhlIHJ1bGVzIGFyZSB0ZXN0ZWQgZXhoYXVzdGl2ZWx5IHRvIGZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gpXG4gICAgICAgICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW4gIChvcHRpb25hbDogdHJ1ZSA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgZWFjaCBtYXRjaGluZyByZWdleCB0aGUgYWN0aW9uIGNvZGUgaXMgaW52b2tlZDsgdGhlIGxleGVyIHRlcm1pbmF0ZXMgdGhlIHNjYW4gd2hlbiBhIHRva2VuIGlzIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24gY29kZSlcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbih5eSwgeXlfLCAkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLCBZWV9TVEFSVCksXG4gICAgICAgIHJ1bGVzOiBbLi4uXSxcbiAgICAgICAgY29uZGl0aW9uczoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IHNldH0sXG4gICAgfVxuICB9XG5cblxuICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7XG4gICAgZmlyc3RfbGluZTogbixcbiAgICBsYXN0X2xpbmU6IG4sXG4gICAgZmlyc3RfY29sdW1uOiBuLFxuICAgIGxhc3RfY29sdW1uOiBuLFxuICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXSAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCByZWd1bGFyIHplcm8tYmFzZWQpXG4gIH1cblxuXG4gIHRoZSBwYXJzZUVycm9yIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGFuZCBwYXJzZXIgZXJyb3JzOiB7XG4gICAgdGV4dDogICAgICAgIChtYXRjaGVkIHRleHQpXG4gICAgdG9rZW46ICAgICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4sIGlmIGFueSlcbiAgICBsaW5lOiAgICAgICAgKHl5bGluZW5vKVxuICB9XG4gIHdoaWxlIHBhcnNlciAoZ3JhbW1hcikgZXJyb3JzIHdpbGwgYWxzbyBwcm92aWRlIHRoZXNlIG1lbWJlcnMsIGkuZS4gcGFyc2VyIGVycm9ycyBkZWxpdmVyIGEgc3VwZXJzZXQgb2YgYXR0cmlidXRlczoge1xuICAgIGxvYzogICAgICAgICAoeXlsbG9jKVxuICAgIGV4cGVjdGVkOiAgICAoc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHNldCBvZiBleHBlY3RlZCB0b2tlbnMpXG4gICAgcmVjb3ZlcmFibGU6IChib29sZWFuOiBUUlVFIHdoZW4gdGhlIHBhcnNlciBoYXMgYSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVycm9yKVxuICB9XG4qL1xudmFyIHBhcnNlciA9IChmdW5jdGlvbigpe1xudmFyIG89ZnVuY3Rpb24oayx2LG8sbCl7Zm9yKG89b3x8e30sbD1rLmxlbmd0aDtsLS07b1trW2xdXT12KXsgfXJldHVybiBvfSwkVjA9WzEsMTJdLCRWMT1bMSwxM10sJFYyPVsxLDldLCRWMz1bMSwxMF0sJFY0PVsxLDExXSwkVjU9WzEsMTRdLCRWNj1bMSwxNV0sJFY3PVsxNCwxOCwyMiwyNF0sJFY4PVsxOCwyMl0sJFY5PVsyMiwyNF07XG52YXIgcGFyc2VyID0ge3RyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCJlcnJvclwiOjIsXCJKU09OU3RyaW5nXCI6MyxcIlNUUklOR1wiOjQsXCJKU09OTnVtYmVyXCI6NSxcIk5VTUJFUlwiOjYsXCJKU09OTnVsbExpdGVyYWxcIjo3LFwiTlVMTFwiOjgsXCJKU09OQm9vbGVhbkxpdGVyYWxcIjo5LFwiVFJVRVwiOjEwLFwiRkFMU0VcIjoxMSxcIkpTT05UZXh0XCI6MTIsXCJKU09OVmFsdWVcIjoxMyxcIkVPRlwiOjE0LFwiSlNPTk9iamVjdFwiOjE1LFwiSlNPTkFycmF5XCI6MTYsXCJ7XCI6MTcsXCJ9XCI6MTgsXCJKU09OTWVtYmVyTGlzdFwiOjE5LFwiSlNPTk1lbWJlclwiOjIwLFwiOlwiOjIxLFwiLFwiOjIyLFwiW1wiOjIzLFwiXVwiOjI0LFwiSlNPTkVsZW1lbnRMaXN0XCI6MjUsXCIkYWNjZXB0XCI6MCxcIiRlbmRcIjoxfSxcbnRlcm1pbmFsc186IHsyOlwiZXJyb3JcIiw0OlwiU1RSSU5HXCIsNjpcIk5VTUJFUlwiLDg6XCJOVUxMXCIsMTA6XCJUUlVFXCIsMTE6XCJGQUxTRVwiLDE0OlwiRU9GXCIsMTc6XCJ7XCIsMTg6XCJ9XCIsMjE6XCI6XCIsMjI6XCIsXCIsMjM6XCJbXCIsMjQ6XCJdXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywxXSxbNSwxXSxbNywxXSxbOSwxXSxbOSwxXSxbMTIsMl0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzE1LDJdLFsxNSwzXSxbMjAsM10sWzE5LDFdLFsxOSwzXSxbMTYsMl0sWzE2LDNdLFsyNSwxXSxbMjUsM11dLFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUgLyogYWN0aW9uWzFdICovLCAkJCAvKiB2c3RhY2sgKi8sIF8kIC8qIGxzdGFjayAqLykge1xuLyogdGhpcyA9PSB5eXZhbCAqL1xuXG52YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xuc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDE6XG4gLy8gcmVwbGFjZSBlc2NhcGVkIGNoYXJhY3RlcnMgd2l0aCBhY3R1YWwgY2hhcmFjdGVyXG4gICAgICAgICAgdGhpcy4kID0gbmV3IFN0cmluZyh5eXRleHQucmVwbGFjZSgvXFxcXChcXFxcfFwiKS9nLCBcIiRcIitcIjFcIilcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcbi9nLCdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxyL2csJ1xccicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHQvZywnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdi9nLCdcXHYnKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxmL2csJ1xcZicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXGIvZywnXFxiJykpO1xuICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9ICB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDI6XG5cbiAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBOdW1iZXIoeXl0ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9ICB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDM6XG5cbiAgICAgICAgICAgIHRoaXMuJCA9IG51bGw7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDQ6XG5cbiAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBCb29sZWFuKHRydWUpO1xuICAgICAgICAgICAgdGhpcy4kLl9fbGluZV9fID0gdGhpcy5fJC5maXJzdF9saW5lO1xuICAgICAgICBcbmJyZWFrO1xuY2FzZSA1OlxuXG4gICAgICAgICAgICB0aGlzLiQgPSBuZXcgQm9vbGVhbihmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDY6XG5yZXR1cm4gdGhpcy4kID0gJCRbJDAtMV07XG5jYXNlIDEzOlxudGhpcy4kID0ge307IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLiQsICdfX2xpbmVfXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl8kLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbmJyZWFrO1xuY2FzZSAxNDogY2FzZSAxOTpcbnRoaXMuJCA9ICQkWyQwLTFdOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG5icmVhaztcbmNhc2UgMTU6XG50aGlzLiQgPSBbJCRbJDAtMl0sICQkWyQwXV07XG5icmVhaztcbmNhc2UgMTY6XG50aGlzLiQgPSB7fTsgdGhpcy4kWyQkWyQwXVswXV0gPSAkJFskMF1bMV07XG5icmVhaztcbmNhc2UgMTc6XG50aGlzLiQgPSAkJFskMC0yXTsgJCRbJDAtMl1bJCRbJDBdWzBdXSA9ICQkWyQwXVsxXTtcbmJyZWFrO1xuY2FzZSAxODpcbnRoaXMuJCA9IFtdOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG5icmVhaztcbmNhc2UgMjA6XG50aGlzLiQgPSBbJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAyMTpcbnRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbn1cbn0sXG50YWJsZTogW3szOjUsNDokVjAsNTo2LDY6JFYxLDc6Myw4OiRWMiw5OjQsMTA6JFYzLDExOiRWNCwxMjoxLDEzOjIsMTU6NywxNjo4LDE3OiRWNSwyMzokVjZ9LHsxOlszXX0sezE0OlsxLDE2XX0sbygkVjcsWzIsN10pLG8oJFY3LFsyLDhdKSxvKCRWNyxbMiw5XSksbygkVjcsWzIsMTBdKSxvKCRWNyxbMiwxMV0pLG8oJFY3LFsyLDEyXSksbygkVjcsWzIsM10pLG8oJFY3LFsyLDRdKSxvKCRWNyxbMiw1XSksbyhbMTQsMTgsMjEsMjIsMjRdLFsyLDFdKSxvKCRWNyxbMiwyXSksezM6MjAsNDokVjAsMTg6WzEsMTddLDE5OjE4LDIwOjE5fSx7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTM6MjMsMTU6NywxNjo4LDE3OiRWNSwyMzokVjYsMjQ6WzEsMjFdLDI1OjIyfSx7MTpbMiw2XX0sbygkVjcsWzIsMTNdKSx7MTg6WzEsMjRdLDIyOlsxLDI1XX0sbygkVjgsWzIsMTZdKSx7MjE6WzEsMjZdfSxvKCRWNyxbMiwxOF0pLHsyMjpbMSwyOF0sMjQ6WzEsMjddfSxvKCRWOSxbMiwyMF0pLG8oJFY3LFsyLDE0XSksezM6MjAsNDokVjAsMjA6Mjl9LHszOjUsNDokVjAsNTo2LDY6JFYxLDc6Myw4OiRWMiw5OjQsMTA6JFYzLDExOiRWNCwxMzozMCwxNTo3LDE2OjgsMTc6JFY1LDIzOiRWNn0sbygkVjcsWzIsMTldKSx7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTM6MzEsMTU6NywxNjo4LDE3OiRWNSwyMzokVjZ9LG8oJFY4LFsyLDE3XSksbygkVjgsWzIsMTVdKSxvKCRWOSxbMiwyMV0pXSxcbmRlZmF1bHRBY3Rpb25zOiB7MTY6WzIsNl19LFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSkge1xuICAgICAgICB0aGlzLnRyYWNlKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgfVxufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcywgc3RhY2sgPSBbMF0sIHZzdGFjayA9IFtudWxsXSwgbHN0YWNrID0gW10sIHRhYmxlID0gdGhpcy50YWJsZSwgeXl0ZXh0ID0gJycsIHl5bGluZW5vID0gMCwgeXlsZW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTtcbiAgICB2YXIgYXJncyA9IGxzdGFjay5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGxleGVyID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICB2YXIgc2hhcmVkU3RhdGUgPSB7IHl5OiB7fSB9O1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICBzaGFyZWRTdGF0ZS55eS5sZXhlciA9IGxleGVyO1xuICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV4ZXIueXlsbG9jID0ge307XG4gICAgfVxuICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG4gICAgdmFyIHJhbmdlcyA9IGxleGVyLm9wdGlvbnMgJiYgbGV4ZXIub3B0aW9ucy5yYW5nZXM7XG4gICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7XG4gICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgICB0b2tlbiA9IGxleGVyLmxleCgpIHx8IEVPRjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgIHZhciBzeW1ib2wsIHN0YXRlLCBhY3Rpb24sIHIsIHl5dmFsID0ge30sIHAsIGxlbiwgbmV3U3RhdGUsIGV4cGVjdGVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xuICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXTtcbiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSAnJztcbiAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gVEVSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKCdcXCcnICsgdGhpcy50ZXJtaW5hbHNfW3BdICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzpcXG4nICsgbGV4ZXIuc2hvd1Bvc2l0aW9uKCkgKyAnXFxuRXhwZWN0aW5nICcgKyBleHBlY3RlZC5qb2luKCcsICcpICsgJywgZ290IFxcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcXCcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6IFVuZXhwZWN0ZWQgJyArIChzeW1ib2wgPT0gRU9GID8gJ2VuZCBvZiBpbnB1dCcgOiAnXFwnJyArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBsZXhlci55eWxpbmVubyxcbiAgICAgICAgICAgICAgICAgICAgbG9jOiB5eWxvYyxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJyArIHN0YXRlICsgJywgdG9rZW46ICcgKyBzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaChsZXhlci55eWxsb2MpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pO1xuICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB5eWxlbmcgPSBsZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIHl5bGluZW5vID0gbGV4ZXIueXlsaW5lbm87XG4gICAgICAgICAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcbiAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aCAtIGxlbl07XG4gICAgICAgICAgICB5eXZhbC5fJCA9IHtcbiAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgbGFzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHl5dmFsLl8kLnJhbmdlID0gW1xuICAgICAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLFxuICAgICAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLnJhbmdlWzFdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uYXBwbHkoeXl2YWwsIFtcbiAgICAgICAgICAgICAgICB5eXRleHQsXG4gICAgICAgICAgICAgICAgeXlsZW5nLFxuICAgICAgICAgICAgICAgIHl5bGluZW5vLFxuICAgICAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5LFxuICAgICAgICAgICAgICAgIGFjdGlvblsxXSxcbiAgICAgICAgICAgICAgICB2c3RhY2ssXG4gICAgICAgICAgICAgICAgbHN0YWNrXG4gICAgICAgICAgICBdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgwLCAtMSAqIGxlbiAqIDIpO1xuICAgICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5dmFsLl8kKTtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1dW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufX07XG4vKiBnZW5lcmF0ZWQgYnkgamlzb24tbGV4IDAuMy40ICovXG52YXIgbGV4ZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBsZXhlciA9ICh7XG5cbkVPRjoxLFxuXG5wYXJzZUVycm9yOmZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgICAgIGlmICh0aGlzLnl5LnBhcnNlcikge1xuICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dFxuc2V0SW5wdXQ6ZnVuY3Rpb24gKGlucHV0LCB5eSkge1xuICAgICAgICB0aGlzLnl5ID0geXkgfHwgdGhpcy55eSB8fCB7fTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2JhY2t0cmFjayA9IHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IDAsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IDEsXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwwXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0XG5pbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG5cbi8vIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhIHN0cmluZykgaW50byB0aGUgaW5wdXRcbnVucHV0OmZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgLy90aGlzLnl5bGVuZyAtPSBsZW47XG4gICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgICAgdmFyIG9sZExpbmVzID0gdGhpcy5tYXRjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gLT0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IHRoaXMueXlsbG9jLnJhbmdlO1xuXG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgKGxpbmVzLmxlbmd0aCA9PT0gb2xkTGluZXMubGVuZ3RoID8gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIDogMClcbiAgICAgICAgICAgICAgICAgKyBvbGRMaW5lc1tvbGRMaW5lcy5sZW5ndGggLSBsaW5lcy5sZW5ndGhdLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgIHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgY2FjaGVzIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kcyBpdCBvbiBuZXh0IGFjdGlvblxubW9yZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgc2lnbmFscyB0aGUgbGV4ZXIgdGhhdCB0aGlzIHJ1bGUgZmFpbHMgdG8gbWF0Y2ggdGhlIGlucHV0LCBzbyB0aGUgbmV4dCBtYXRjaGluZyBydWxlIChyZWdleCkgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxucmVqZWN0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBZb3UgY2FuIG9ubHkgaW52b2tlIHJlamVjdCgpIGluIHRoZSBsZXhlciB3aGVuIHRoZSBsZXhlciBpcyBvZiB0aGUgYmFja3RyYWNraW5nIHBlcnN1YXNpb24gKG9wdGlvbnMuYmFja3RyYWNrX2xleGVyID0gdHJ1ZSkuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbmxlc3M6ZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyBhbHJlYWR5IG1hdGNoZWQgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5wYXN0SW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLic6JycpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG51cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkgKyAobmV4dC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0aGUgbGV4aW5nIGVycm9yIG9jY3VycmVkLCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuc2hvd1Bvc2l0aW9uOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMgKyBcIl5cIjtcbiAgICB9LFxuXG4vLyB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW5cbnRlc3RfbWF0Y2g6ZnVuY3Rpb24gKG1hdGNoLCBpbmRleGVkX3J1bGUpIHtcbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICBiYWNrdXA7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgY29udGV4dFxuICAgICAgICAgICAgYmFja3VwID0ge1xuICAgICAgICAgICAgICAgIHl5bGluZW5vOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgIHl5bGxvYzoge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LFxuICAgICAgICAgICAgICAgIG1hdGNoOiB0aGlzLm1hdGNoLFxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IHRoaXMubWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsXG4gICAgICAgICAgICAgICAgeXlsZW5nOiB0aGlzLnl5bGVuZyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLFxuICAgICAgICAgICAgICAgIF9pbnB1dDogdGhpcy5faW5wdXQsXG4gICAgICAgICAgICAgICAgeXk6IHRoaXMueXksXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgICAgICAgZG9uZTogdGhpcy5kb25lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBiYWNrdXAueXlsbG9jLnJhbmdlID0gdGhpcy55eWxsb2MucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IG1hdGNoWzBdLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggLSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5tYXRjaCgvXFxyP1xcbj8vKVswXS5sZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIGluZGV4ZWRfcnVsZSwgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAvLyByZWNvdmVyIGNvbnRleHRcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYmFja3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGJhY2t1cFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIHRoZSBuZXh0IHJ1bGUgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4vLyByZXR1cm4gbmV4dCBtYXRjaCBpbiBpbnB1dFxubmV4dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICB0ZW1wTWF0Y2gsXG4gICAgICAgICAgICBpbmRleDtcbiAgICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7XG4gICAgICAgICAgICB0aGlzLnl5dGV4dCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wTWF0Y2ggPSB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLnJ1bGVzW3J1bGVzW2ldXSk7XG4gICAgICAgICAgICBpZiAodGVtcE1hdGNoICYmICghbWF0Y2ggfHwgdGVtcE1hdGNoWzBdLmxlbmd0aCA+IG1hdGNoWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRlbXBNYXRjaDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2godGVtcE1hdGNoLCBydWxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIGEgcnVsZSBNSVNtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFVucmVjb2duaXplZCB0ZXh0LlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW5cbmxleDpmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWN0aXZhdGVzIGEgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSAocHVzaGVzIHRoZSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9udG8gdGhlIGNvbmRpdGlvbiBzdGFjaylcbmJlZ2luOmZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgICB9LFxuXG4vLyBwb3AgdGhlIHByZXZpb3VzbHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvZmYgdGhlIGNvbmRpdGlvbiBzdGFja1xucG9wU3RhdGU6ZnVuY3Rpb24gcG9wU3RhdGUoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbMF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBwcm9kdWNlIHRoZSBsZXhlciBydWxlIHNldCB3aGljaCBpcyBhY3RpdmUgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZVxuX2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXV0ucnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW1wiSU5JVElBTFwiXS5ydWxlcztcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGU7IHdoZW4gYW4gaW5kZXggYXJndW1lbnQgaXMgcHJvdmlkZWQgaXQgcHJvZHVjZXMgdGhlIE4tdGggcHJldmlvdXMgY29uZGl0aW9uIHN0YXRlLCBpZiBhdmFpbGFibGVcbnRvcFN0YXRlOmZ1bmN0aW9uIHRvcFN0YXRlKG4pIHtcbiAgICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7XG4gICAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW25dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiSU5JVElBTFwiO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWxpYXMgZm9yIGJlZ2luKGNvbmRpdGlvbilcbnB1c2hTdGF0ZTpmdW5jdGlvbiBwdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICB9LFxuXG4vLyByZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgY3VycmVudGx5IG9uIHRoZSBzdGFja1xuc3RhdGVTdGFja1NpemU6ZnVuY3Rpb24gc3RhdGVTdGFja1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aDtcbiAgICB9LFxub3B0aW9uczoge30sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXkseXlfLCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsWVlfU1RBUlQpIHtcbnN3aXRjaCgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG5jYXNlIDA6Lyogc2tpcCB3aGl0ZXNwYWNlICovXG5icmVhaztcbmNhc2UgMTpyZXR1cm4gNlxuY2FzZSAyOnl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigxLHl5Xy55eWxlbmctMik7IHJldHVybiA0XG5jYXNlIDM6cmV0dXJuIDE3XG5jYXNlIDQ6cmV0dXJuIDE4XG5jYXNlIDU6cmV0dXJuIDIzXG5jYXNlIDY6cmV0dXJuIDI0XG5jYXNlIDc6cmV0dXJuIDIyXG5jYXNlIDg6cmV0dXJuIDIxXG5jYXNlIDk6cmV0dXJuIDEwXG5jYXNlIDEwOnJldHVybiAxMVxuY2FzZSAxMTpyZXR1cm4gOFxuY2FzZSAxMjpyZXR1cm4gMTRcbmNhc2UgMTM6cmV0dXJuICdJTlZBTElEJ1xufVxufSxcbnJ1bGVzOiBbL14oPzpcXHMrKS8sL14oPzooLT8oWzAtOV18WzEtOV1bMC05XSspKShcXC5bMC05XSspPyhbZUVdWy0rXT9bMC05XSspP1xcYikvLC9eKD86XCIoPzpcXFxcW1xcXFxcImJmbnJ0L118XFxcXHVbYS1mQS1GMC05XXs0fXxbXlxcXFxcXDAtXFx4MDlcXHgwYS1cXHgxZlwiXSkqXCIpLywvXig/OlxceykvLC9eKD86XFx9KS8sL14oPzpcXFspLywvXig/OlxcXSkvLC9eKD86LCkvLC9eKD86OikvLC9eKD86dHJ1ZVxcYikvLC9eKD86ZmFsc2VcXGIpLywvXig/Om51bGxcXGIpLywvXig/OiQpLywvXig/Oi4pL10sXG5jb25kaXRpb25zOiB7XCJJTklUSUFMXCI6e1wicnVsZXNcIjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxM10sXCJpbmNsdXNpdmVcIjp0cnVlfX1cbn0pO1xucmV0dXJuIGxleGVyO1xufSkoKTtcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuZnVuY3Rpb24gUGFyc2VyICgpIHtcbiAgdGhpcy55eSA9IHt9O1xufVxuUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xucmV0dXJuIG5ldyBQYXJzZXI7XG59KSgpO1xuXG5cbmlmICh0eXBlb2YgY29tbW9uanNSZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiAnb2JqZWN0JyAhPT0gJ3VuZGVmaW5lZCcpIHtcbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xuZXhwb3J0cy5QYXJzZXIgPSBwYXJzZXIuUGFyc2VyO1xuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlci5wYXJzZS5hcHBseShwYXJzZXIsIGFyZ3VtZW50cyk7IH07XG59XG59KTtcbnZhciBqc29ubGludF8xID0ganNvbmxpbnQucGFyc2VyO1xudmFyIGpzb25saW50XzIgPSBqc29ubGludC5QYXJzZXI7XG52YXIganNvbmxpbnRfMyA9IGpzb25saW50LnBhcnNlO1xuXG5mdW5jdGlvbiByZWFkU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyB8fCBzdHlsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb25saW50LnBhcnNlKHN0eWxlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yJDEoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlKHN0eWxlLCBzdHlsZVNwZWMpIHtcbiAgICBpZiAoc3R5bGVTcGVjID09PSB2b2lkIDApXG4gICAgICAgIHN0eWxlU3BlYyA9IHY4O1xuICAgIHZhciBzID0gc3R5bGU7XG4gICAgdHJ5IHtcbiAgICAgICAgcyA9IHJlYWRTdHlsZShzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBbZV07XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVN0eWxlTWluKHMsIHN0eWxlU3BlYyk7XG59XG5cbnZhciBTVVBQT1JURURfU1BFQ19WRVJTSU9OID0gODtcbnZhciBNQVhfU09VUkNFU19JTl9TVFlMRSA9IDE1O1xuZnVuY3Rpb24gaXNWYWxpZCh2YWx1ZSwgcmVnZXgpIHtcbiAgICBpZiAoIXZhbHVlIHx8IGdldFR5cGUodmFsdWUpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICEhdmFsdWUubWF0Y2gocmVnZXgpO1xufVxuZnVuY3Rpb24gZ2V0U291cmNlQ291bnQoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS51cmwpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS51cmwuc3BsaXQoJywnKS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QWxsb3dlZEtleUVycm9ycyhvYmosIGtleXMsIHBhdGgpIHtcbiAgICB2YXIgYWxsb3dlZCA9IG5ldyBTZXQoa2V5cyk7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoIWFsbG93ZWQuaGFzKGspKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHBhdGggPyBwYXRoICsgJy4nICsgayA6IG51bGw7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKHByb3AsIG9ialtrXSwgJ1Vuc3VwcG9ydGVkIHByb3BlcnR5IFwiJyArIGsgKyAnXCInKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gZ2V0U291cmNlRXJyb3JzKHNvdXJjZSwgaSkge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgc291cmNlS2V5cyA9IFtcbiAgICAgICAgJ3R5cGUnLFxuICAgICAgICAndXJsJyxcbiAgICAgICAgJ3RpbGVTaXplJ1xuICAgIF07XG4gICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBnZXRBbGxvd2VkS2V5RXJyb3JzKHNvdXJjZSwgc291cmNlS2V5cywgJ3NvdXJjZScpKTtcbiAgICB2YXIgc291cmNlVXJsUGF0dGVybiA9IC9ebWFwYm94OlxcL1xcLyhbXi9dKikkLztcbiAgICBpZiAoIWlzVmFsaWQoc291cmNlLnVybCwgc291cmNlVXJsUGF0dGVybikpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcignc291cmNlc1snICsgaSArICddJywgc291cmNlLnVybCwgJ1NvdXJjZSB1cmwgbXVzdCBiZSBhIHZhbGlkIE1hcGJveCB0aWxlc2V0IHVybCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIGdldFNvdXJjZXNFcnJvcnMoc291cmNlcykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZXMpLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgdmFyIHNvdXJjZUVycm9ycyA9IGdldFNvdXJjZUVycm9ycyhzb3VyY2VzW3NdLCBpKTtcbiAgICAgICAgaWYgKCFzb3VyY2VFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50ICsgZ2V0U291cmNlQ291bnQoc291cmNlc1tzXSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBzb3VyY2VFcnJvcnMpO1xuICAgIH0pO1xuICAgIGlmIChjb3VudCA+IE1BWF9TT1VSQ0VTX0lOX1NUWUxFKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3NvdXJjZXMnLCBudWxsLCAnU3R5bGVzIG11c3QgY29udGFpbiAnICsgTUFYX1NPVVJDRVNfSU5fU1RZTEUgKyAnIG9yIGZld2VyIHNvdXJjZXMnKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBnZXRSb290RXJyb3JzKHN0eWxlLCBzcGVjS2V5cykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgb3B0aW9uYWxSb290UHJvcGVydGllcyA9IFtcbiAgICAgICAgJ293bmVyJyxcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ2NhY2hlQ29udHJvbCcsXG4gICAgICAgICdkcmFmdCcsXG4gICAgICAgICdjcmVhdGVkJyxcbiAgICAgICAgJ21vZGlmaWVkJyxcbiAgICAgICAgJ3Zpc2liaWxpdHknXG4gICAgXTtcbiAgICB2YXIgYWxsb3dlZEtleUVycm9ycyA9IGdldEFsbG93ZWRLZXlFcnJvcnMoc3R5bGUsIHNwZWNLZXlzLmNvbmNhdChvcHRpb25hbFJvb3RQcm9wZXJ0aWVzKSk7XG4gICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBhbGxvd2VkS2V5RXJyb3JzKTtcbiAgICBpZiAoc3R5bGUudmVyc2lvbiA+IFNVUFBPUlRFRF9TUEVDX1ZFUlNJT04gfHwgc3R5bGUudmVyc2lvbiA8IFNVUFBPUlRFRF9TUEVDX1ZFUlNJT04pIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcigndmVyc2lvbicsIHN0eWxlLnZlcnNpb24sICdTdHlsZSB2ZXJzaW9uIG11c3QgYmUgJyArIFNVUFBPUlRFRF9TUEVDX1ZFUlNJT04pKTtcbiAgICB9XG4gICAgdmFyIGdseXBoVXJsUGF0dGVybiA9IC9ebWFwYm94OlxcL1xcL2ZvbnRzXFwvKFteL10qKVxcL3tmb250c3RhY2t9XFwve3JhbmdlfS5wYmYkLztcbiAgICBpZiAoIWlzVmFsaWQoc3R5bGUuZ2x5cGhzLCBnbHlwaFVybFBhdHRlcm4pKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ2dseXBocycsIHN0eWxlLmdseXBocywgJ1N0eWxlcyBtdXN0IHJlZmVyZW5jZSBnbHlwaHMgaG9zdGVkIGJ5IE1hcGJveCcpKTtcbiAgICB9XG4gICAgdmFyIHNwcml0ZVVybFBhdHRlcm4gPSAvXm1hcGJveDpcXC9cXC9zcHJpdGVzXFwvKFteL10qKVxcLyhbXi9dKilcXC8/KFteL10qKT8kLztcbiAgICBpZiAoIWlzVmFsaWQoc3R5bGUuc3ByaXRlLCBzcHJpdGVVcmxQYXR0ZXJuKSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKCdzcHJpdGUnLCBzdHlsZS5zcHJpdGUsICdTdHlsZXMgbXVzdCByZWZlcmVuY2Ugc3ByaXRlcyBob3N0ZWQgYnkgTWFwYm94JykpO1xuICAgIH1cbiAgICB2YXIgdmlzaWJpbGl0eVBhdHRlcm4gPSAvXihwdWJsaWN8cHJpdmF0ZSkkLztcbiAgICBpZiAoIWlzVmFsaWQoc3R5bGUudmlzaWJpbGl0eSwgdmlzaWJpbGl0eVBhdHRlcm4pKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3Zpc2liaWxpdHknLCBzdHlsZS52aXNpYmlsaXR5LCAnU3R5bGUgdmlzaWJpbGl0eSBtdXN0IGJlIHB1YmxpYyBvciBwcml2YXRlJykpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNYXBib3hBcGlTdXBwb3J0ZWQoc3R5bGUpIHtcbiAgICB2YXIgcyA9IHN0eWxlO1xuICAgIHRyeSB7XG4gICAgICAgIHMgPSByZWFkU3R5bGUocyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gW2VdO1xuICAgIH1cbiAgICB2YXIgZXJyb3JzID0gdmFsaWRhdGVTdHlsZU1pbihzLCB2OCkuY29uY2F0KGdldFJvb3RFcnJvcnMocywgT2JqZWN0LmtleXModjguJHJvb3QpKSk7XG4gICAgaWYgKHMuc291cmNlcykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGdldFNvdXJjZXNFcnJvcnMocy5zb3VyY2VzKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5cbnZhciBleHByZXNzaW9uJDEgPSB7XG4gICAgU3R5bGVFeHByZXNzaW9uOiBTdHlsZUV4cHJlc3Npb24sXG4gICAgaXNFeHByZXNzaW9uOiBpc0V4cHJlc3Npb24sXG4gICAgaXNFeHByZXNzaW9uRmlsdGVyOiBpc0V4cHJlc3Npb25GaWx0ZXIsXG4gICAgY3JlYXRlRXhwcmVzc2lvbjogY3JlYXRlRXhwcmVzc2lvbixcbiAgICBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb246IGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbixcbiAgICBub3JtYWxpemVQcm9wZXJ0eUV4cHJlc3Npb246IG5vcm1hbGl6ZVByb3BlcnR5RXhwcmVzc2lvbixcbiAgICBab29tQ29uc3RhbnRFeHByZXNzaW9uOiBab29tQ29uc3RhbnRFeHByZXNzaW9uLFxuICAgIFpvb21EZXBlbmRlbnRFeHByZXNzaW9uOiBab29tRGVwZW5kZW50RXhwcmVzc2lvbixcbiAgICBTdHlsZVByb3BlcnR5RnVuY3Rpb246IFN0eWxlUHJvcGVydHlGdW5jdGlvblxufTtcbnZhciBzdHlsZUZ1bmN0aW9uID0ge1xuICAgIGNvbnZlcnRGdW5jdGlvbjogY29udmVydEZ1bmN0aW9uLFxuICAgIGNyZWF0ZUZ1bmN0aW9uOiBjcmVhdGVGdW5jdGlvbixcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uJDFcbn07XG52YXIgdmlzaXQgPSB7XG4gICAgZWFjaFNvdXJjZTogZWFjaFNvdXJjZSxcbiAgICBlYWNoTGF5ZXI6IGVhY2hMYXllcixcbiAgICBlYWNoUHJvcGVydHk6IGVhY2hQcm9wZXJ0eVxufTtcbnZhbGlkYXRlU3R5bGUucGFyc2VkID0gdmFsaWRhdGVTdHlsZTtcbnZhbGlkYXRlU3R5bGUubGF0ZXN0ID0gdmFsaWRhdGVTdHlsZTtcblxuZXhwb3J0IHsgQ29sb3IsIFBhcnNpbmdFcnJvciQxIGFzIFBhcnNpbmdFcnJvciwgVmFsaWRhdGlvbkVycm9yLCBjb21wb3NpdGUsIGNvbnZlcnRGaWx0ZXIkMSBhcyBjb252ZXJ0RmlsdGVyLCBkZXJlZkxheWVycywgZGlmZlN0eWxlcyBhcyBkaWZmLCBleHByZXNzaW9uJDEgYXMgZXhwcmVzc2lvbiwgY3JlYXRlRmlsdGVyIGFzIGZlYXR1cmVGaWx0ZXIsIGZvcm1hdCwgc3R5bGVGdW5jdGlvbiBhcyBmdW5jdGlvbiwgdjggYXMgbGF0ZXN0LCBtaWdyYXRlLCB2OCwgdmFsaWRhdGVTdHlsZSBhcyB2YWxpZGF0ZSwgdmFsaWRhdGVNYXBib3hBcGlTdXBwb3J0ZWQsIHZpc2l0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJ2YXIgZm9udFdlaWdodHMgPSB7XG4gIHRoaW46IDEwMCxcbiAgaGFpcmxpbmU6IDEwMCxcbiAgJ3VsdHJhLWxpZ2h0JzogMTAwLFxuICAnZXh0cmEtbGlnaHQnOiAxMDAsXG4gIGxpZ2h0OiAyMDAsXG4gIGJvb2s6IDMwMCxcbiAgcmVndWxhcjogNDAwLFxuICBub3JtYWw6IDQwMCxcbiAgcGxhaW46IDQwMCxcbiAgcm9tYW46IDQwMCxcbiAgc3RhbmRhcmQ6IDQwMCxcbiAgbWVkaXVtOiA1MDAsXG4gICdzZW1pLWJvbGQnOiA2MDAsXG4gICdkZW1pLWJvbGQnOiA2MDAsXG4gIGJvbGQ6IDcwMCxcbiAgaGVhdnk6IDgwMCxcbiAgYmxhY2s6IDgwMCxcbiAgJ2V4dHJhLWJvbGQnOiA4MDAsXG4gICd1bHRyYS1ibGFjayc6IDkwMCxcbiAgJ2V4dHJhLWJsYWNrJzogOTAwLFxuICAndWx0cmEtYm9sZCc6IDkwMCxcbiAgJ2hlYXZ5LWJsYWNrJzogOTAwLFxuICBmYXQ6IDkwMCxcbiAgcG9zdGVyOiA5MDBcbn07XG52YXIgc3AgPSAnICc7XG52YXIgaXRhbGljUkUgPSAvKGl0YWxpY3xvYmxpcXVlKSQvaTtcblxudmFyIGZvbnRDYWNoZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZvbnRzLCBzaXplLCBsaW5lSGVpZ2h0KSB7XG4gIHZhciBjc3NEYXRhID0gZm9udENhY2hlW2ZvbnRzXTtcbiAgaWYgKCFjc3NEYXRhKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZvbnRzKSkge1xuICAgICAgZm9udHMgPSBbZm9udHNdO1xuICAgIH1cbiAgICB2YXIgd2VpZ2h0ID0gNDAwO1xuICAgIHZhciBzdHlsZSA9ICdub3JtYWwnO1xuICAgIHZhciBmb250RmFtaWxpZXMgPSBbXTtcbiAgICB2YXIgaGF2ZVdlaWdodCwgaGF2ZVN0eWxlO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZvbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBmb250ID0gZm9udHNbaV07XG4gICAgICB2YXIgcGFydHMgPSBmb250LnNwbGl0KCcgJyk7XG4gICAgICB2YXIgbWF5YmVXZWlnaHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG1heWJlV2VpZ2h0ID09ICdub3JtYWwnIHx8IG1heWJlV2VpZ2h0ID09ICdpdGFsaWMnIHx8IG1heWJlV2VpZ2h0ID09ICdvYmxpcXVlJykge1xuICAgICAgICBzdHlsZSA9IGhhdmVTdHlsZSA/IHN0eWxlIDogbWF5YmVXZWlnaHQ7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICBtYXliZVdlaWdodCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGl0YWxpY1JFLnRlc3QobWF5YmVXZWlnaHQpKSB7XG4gICAgICAgIG1heWJlV2VpZ2h0ID0gbWF5YmVXZWlnaHQucmVwbGFjZShpdGFsaWNSRSwgJycpO1xuICAgICAgICBzdHlsZSA9IGhhdmVTdHlsZSA/IHN0eWxlIDogcGFydHNbcGFydHMubGVuZ3RoIC0gMV0ucmVwbGFjZShtYXliZVdlaWdodCwgJycpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgdyBpbiBmb250V2VpZ2h0cykge1xuICAgICAgICBpZiAobWF5YmVXZWlnaHQgPT0gdyB8fCBtYXliZVdlaWdodCA9PSB3LnJlcGxhY2UoJy0nLCAnJykgfHwgbWF5YmVXZWlnaHQgPT0gdy5yZXBsYWNlKCctJywgc3ApKSB7XG4gICAgICAgICAgd2VpZ2h0ID0gaGF2ZVdlaWdodCA/IHdlaWdodCA6IGZvbnRXZWlnaHRzW3ddO1xuICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhdmVXZWlnaHQgJiYgdHlwZW9mIG1heWJlV2VpZ2h0ID09ICdudW1iZXInKSB7XG4gICAgICAgIHdlaWdodCA9IG1heWJlV2VpZ2h0O1xuICAgICAgfVxuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBwYXJ0cy5qb2luKHNwKVxuICAgICAgICAucmVwbGFjZSgnS2xva2FudGVjaCBOb3RvIFNhbnMnLCAnTm90byBTYW5zJyk7XG4gICAgICBpZiAoZm9udEZhbWlseS5pbmRleE9mKHNwKSAhPT0gLTEpIHtcbiAgICAgICAgZm9udEZhbWlseSA9ICdcIicgKyBmb250RmFtaWx5ICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGZvbnRGYW1pbGllcy5wdXNoKGZvbnRGYW1pbHkpO1xuICAgIH1cbiAgICAvLyBDU1MgZm9udCBwcm9wZXJ0eTogZm9udC1zdHlsZSBmb250LXdlaWdodCBmb250LXNpemUvbGluZS1oZWlnaHQgZm9udC1mYW1pbHlcbiAgICBjc3NEYXRhID0gZm9udENhY2hlW2ZvbnRzXSA9IFtzdHlsZSwgd2VpZ2h0LCBmb250RmFtaWxpZXNdO1xuICB9XG4gIHJldHVybiBjc3NEYXRhWzBdICsgc3AgKyBjc3NEYXRhWzFdICsgc3AgKyBzaXplICsgJ3B4JyArIChsaW5lSGVpZ2h0ID8gJy8nICsgbGluZUhlaWdodCA6ICcnKSArIHNwICsgY3NzRGF0YVsyXTtcbn07XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTAuMFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZmFtaWxpZXM7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaWNvbjogJ2ljb25zL2dvb2dsZS5zdmcnLFxuICAgIG5hbWU6ICdnb29nbGUnLFxuICAgIHRpdGxlOiAnR29vZ2xlIEZvbnRzJyxcbiAgICBsaW5rOiAnZ29vZ2xlLmNvbS9mb250cycsXG4gICAgZ2V0TmFtZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbWlsaWVzO1xuICAgIH0sXG4gICAgZ2V0TGluazogZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9mb250cy5nb29nbGUuY29tL3NwZWNpbWVuL1wiICsgKG5hbWUucmVwbGFjZSgvKCApL2csICcrJykpO1xuICAgIH0sXG4gICAgbm9ybWFsaXplTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9O1xuXG4gIGZhbWlsaWVzID0gW1wiQUJlZVplZVwiLCBcIkFiZWxcIiwgXCJBYnJpbCBGYXRmYWNlXCIsIFwiQWNsb25pY2FcIiwgXCJBY21lXCIsIFwiQWN0b3JcIiwgXCJBZGFtaW5hXCIsIFwiQWR2ZW50IFByb1wiLCBcIkFndWFmaW5hIFNjcmlwdFwiLCBcIkFrcm9uaW1cIiwgXCJBbGFkaW5cIiwgXCJBbGRyaWNoXCIsIFwiQWxlZlwiLCBcIkFsZWdyZXlhXCIsIFwiQWxlZ3JleWEgU0NcIiwgXCJBbGVncmV5YSBTYW5zXCIsIFwiQWxlZ3JleWEgU2FucyBTQ1wiLCBcIkFsZXggQnJ1c2hcIiwgXCJBbGZhIFNsYWIgT25lXCIsIFwiQWxpY2VcIiwgXCJBbGlrZVwiLCBcIkFsaWtlIEFuZ3VsYXJcIiwgXCJBbGxhblwiLCBcIkFsbGVydGFcIiwgXCJBbGxlcnRhIFN0ZW5jaWxcIiwgXCJBbGx1cmFcIiwgXCJBbG1lbmRyYVwiLCBcIkFsbWVuZHJhIERpc3BsYXlcIiwgXCJBbG1lbmRyYSBTQ1wiLCBcIkFtYXJhbnRlXCIsIFwiQW1hcmFudGhcIiwgXCJBbWF0aWMgU0NcIiwgXCJBbWV0aHlzdGFcIiwgXCJBbWlyaVwiLCBcIkFtaXRhXCIsIFwiQW5haGVpbVwiLCBcIkFuZGFkYVwiLCBcIkFuZGlrYVwiLCBcIkFuZ2tvclwiLCBcIkFubmllIFVzZSBZb3VyIFRlbGVzY29wZVwiLCBcIkFub255bW91cyBQcm9cIiwgXCJBbnRpY1wiLCBcIkFudGljIERpZG9uZVwiLCBcIkFudGljIFNsYWJcIiwgXCJBbnRvblwiLCBcIkFyYXBleVwiLCBcIkFyYnV0dXNcIiwgXCJBcmJ1dHVzIFNsYWJcIiwgXCJBcmNoaXRlY3RzIERhdWdodGVyXCIsIFwiQXJjaGl2byBCbGFja1wiLCBcIkFyY2hpdm8gTmFycm93XCIsIFwiQXJpbW9cIiwgXCJBcml6b25pYVwiLCBcIkFybWF0YVwiLCBcIkFydGlmaWthXCIsIFwiQXJ2b1wiLCBcIkFyeWFcIiwgXCJBc2FwXCIsIFwiQXNhclwiLCBcIkFzc2V0XCIsIFwiQXN0bG9jaFwiLCBcIkFzdWxcIiwgXCJBdG9taWMgQWdlXCIsIFwiQXVicmV5XCIsIFwiQXVkaW93aWRlXCIsIFwiQXV0b3VyIE9uZVwiLCBcIkF2ZXJhZ2VcIiwgXCJBdmVyYWdlIFNhbnNcIiwgXCJBdmVyaWEgR3J1ZXNhIExpYnJlXCIsIFwiQXZlcmlhIExpYnJlXCIsIFwiQXZlcmlhIFNhbnMgTGlicmVcIiwgXCJBdmVyaWEgU2VyaWYgTGlicmVcIiwgXCJCYWQgU2NyaXB0XCIsIFwiQmFsdGhhemFyXCIsIFwiQmFuZ2Vyc1wiLCBcIkJhc2ljXCIsIFwiQmF0dGFtYmFuZ1wiLCBcIkJhdW1hbnNcIiwgXCJCYXlvblwiLCBcIkJlbGdyYW5vXCIsIFwiQmVsbGV6YVwiLCBcIkJlbmNoTmluZVwiLCBcIkJlbnRoYW1cIiwgXCJCZXJrc2hpcmUgU3dhc2hcIiwgXCJCZXZhblwiLCBcIkJpZ2Vsb3cgUnVsZXNcIiwgXCJCaWdzaG90IE9uZVwiLCBcIkJpbGJvXCIsIFwiQmlsYm8gU3dhc2ggQ2Fwc1wiLCBcIkJpcnlhbmlcIiwgXCJCaXR0ZXJcIiwgXCJCbGFjayBPcHMgT25lXCIsIFwiQm9rb3JcIiwgXCJCb25ib25cIiwgXCJCb29nYWxvb1wiLCBcIkJvd2xieSBPbmVcIiwgXCJCb3dsYnkgT25lIFNDXCIsIFwiQnJhd2xlclwiLCBcIkJyZWUgU2VyaWZcIiwgXCJCdWJibGVndW0gU2Fuc1wiLCBcIkJ1YmJsZXIgT25lXCIsIFwiQnVkYVwiLCBcIkJ1ZW5hcmRcIiwgXCJCdXRjaGVybWFuXCIsIFwiQnV0dGVyZmx5IEtpZHNcIiwgXCJDYWJpblwiLCBcIkNhYmluIENvbmRlbnNlZFwiLCBcIkNhYmluIFNrZXRjaFwiLCBcIkNhZXNhciBEcmVzc2luZ1wiLCBcIkNhZ2xpb3N0cm9cIiwgXCJDYWxsaWdyYWZmaXR0aVwiLCBcIkNhbWJheVwiLCBcIkNhbWJvXCIsIFwiQ2FuZGFsXCIsIFwiQ2FudGFyZWxsXCIsIFwiQ2FudGF0YSBPbmVcIiwgXCJDYW50b3JhIE9uZVwiLCBcIkNhcHJpb2xhXCIsIFwiQ2FyZG9cIiwgXCJDYXJtZVwiLCBcIkNhcnJvaXMgR290aGljXCIsIFwiQ2Fycm9pcyBHb3RoaWMgU0NcIiwgXCJDYXJ0ZXIgT25lXCIsIFwiQ2F0YW1hcmFuXCIsIFwiQ2F1ZGV4XCIsIFwiQ2F2ZWF0XCIsIFwiQ2F2ZWF0IEJydXNoXCIsIFwiQ2VkYXJ2aWxsZSBDdXJzaXZlXCIsIFwiQ2V2aWNoZSBPbmVcIiwgXCJDaGFuZ2EgT25lXCIsIFwiQ2hhbmdvXCIsIFwiQ2hhdSBQaGlsb21lbmUgT25lXCIsIFwiQ2hlbGEgT25lXCIsIFwiQ2hlbHNlYSBNYXJrZXRcIiwgXCJDaGVubGFcIiwgXCJDaGVycnkgQ3JlYW0gU29kYVwiLCBcIkNoZXJyeSBTd2FzaFwiLCBcIkNoZXd5XCIsIFwiQ2hpY2xlXCIsIFwiQ2hpdm9cIiwgXCJDaG9uYnVyaVwiLCBcIkNpbnplbFwiLCBcIkNpbnplbCBEZWNvcmF0aXZlXCIsIFwiQ2xpY2tlciBTY3JpcHRcIiwgXCJDb2RhXCIsIFwiQ29kYSBDYXB0aW9uXCIsIFwiQ29keXN0YXJcIiwgXCJDb21ib1wiLCBcIkNvbWZvcnRhYVwiLCBcIkNvbWluZyBTb29uXCIsIFwiQ29uY2VydCBPbmVcIiwgXCJDb25kaW1lbnRcIiwgXCJDb250ZW50XCIsIFwiQ29udHJhaWwgT25lXCIsIFwiQ29udmVyZ2VuY2VcIiwgXCJDb29raWVcIiwgXCJDb3BzZVwiLCBcIkNvcmJlblwiLCBcIkNvdXJnZXR0ZVwiLCBcIkNvdXNpbmVcIiwgXCJDb3VzdGFyZFwiLCBcIkNvdmVyZWQgQnkgWW91ciBHcmFjZVwiLCBcIkNyYWZ0eSBHaXJsc1wiLCBcIkNyZWVwc3RlclwiLCBcIkNyZXRlIFJvdW5kXCIsIFwiQ3JpbXNvbiBUZXh0XCIsIFwiQ3JvaXNzYW50IE9uZVwiLCBcIkNydXNoZWRcIiwgXCJDdXBydW1cIiwgXCJDdXRpdmVcIiwgXCJDdXRpdmUgTW9ub1wiLCBcIkRhbWlvblwiLCBcIkRhbmNpbmcgU2NyaXB0XCIsIFwiRGFuZ3Jla1wiLCBcIkRhd25pbmcgb2YgYSBOZXcgRGF5XCIsIFwiRGF5cyBPbmVcIiwgXCJEZWtrb1wiLCBcIkRlbGl1c1wiLCBcIkRlbGl1cyBTd2FzaCBDYXBzXCIsIFwiRGVsaXVzIFVuaWNhc2VcIiwgXCJEZWxsYSBSZXNwaXJhXCIsIFwiRGVuayBPbmVcIiwgXCJEZXZvbnNoaXJlXCIsIFwiRGh1cmphdGlcIiwgXCJEaWRhY3QgR290aGljXCIsIFwiRGlwbG9tYXRhXCIsIFwiRGlwbG9tYXRhIFNDXCIsIFwiRG9taW5lXCIsIFwiRG9uZWdhbCBPbmVcIiwgXCJEb3BwaW8gT25lXCIsIFwiRG9yc2FcIiwgXCJEb3Npc1wiLCBcIkRyIFN1Z2l5YW1hXCIsIFwiRHJvaWQgU2Fuc1wiLCBcIkRyb2lkIFNhbnMgTW9ub1wiLCBcIkRyb2lkIFNlcmlmXCIsIFwiRHVydSBTYW5zXCIsIFwiRHluYWxpZ2h0XCIsIFwiRUIgR2FyYW1vbmRcIiwgXCJFYWdsZSBMYWtlXCIsIFwiRWF0ZXJcIiwgXCJFY29ub21pY2FcIiwgXCJFY3phclwiLCBcIkVrIE11a3RhXCIsIFwiRWxlY3Ryb2xpemVcIiwgXCJFbHNpZVwiLCBcIkVsc2llIFN3YXNoIENhcHNcIiwgXCJFbWJsZW1hIE9uZVwiLCBcIkVtaWx5cyBDYW5keVwiLCBcIkVuZ2FnZW1lbnRcIiwgXCJFbmdsZWJlcnRcIiwgXCJFbnJpcXVldGFcIiwgXCJFcmljYSBPbmVcIiwgXCJFc3RlYmFuXCIsIFwiRXVwaG9yaWEgU2NyaXB0XCIsIFwiRXdlcnRcIiwgXCJFeG9cIiwgXCJFeG8gMlwiLCBcIkV4cGxldHVzIFNhbnNcIiwgXCJGYW53b29kIFRleHRcIiwgXCJGYXNjaW5hdGVcIiwgXCJGYXNjaW5hdGUgSW5saW5lXCIsIFwiRmFzdGVyIE9uZVwiLCBcIkZhc3RoYW5kXCIsIFwiRmF1bmEgT25lXCIsIFwiRmVkZXJhbnRcIiwgXCJGZWRlcm9cIiwgXCJGZWxpcGFcIiwgXCJGZW5peFwiLCBcIkZpbmdlciBQYWludFwiLCBcIkZpcmEgTW9ub1wiLCBcIkZpcmEgU2Fuc1wiLCBcIkZqYWxsYSBPbmVcIiwgXCJGam9yZCBPbmVcIiwgXCJGbGFtZW5jb1wiLCBcIkZsYXZvcnNcIiwgXCJGb25kYW1lbnRvXCIsIFwiRm9udGRpbmVyIFN3YW5reVwiLCBcIkZvcnVtXCIsIFwiRnJhbmNvaXMgT25lXCIsIFwiRnJlY2tsZSBGYWNlXCIsIFwiRnJlZGVyaWNrYSB0aGUgR3JlYXRcIiwgXCJGcmVkb2thIE9uZVwiLCBcIkZyZWVoYW5kXCIsIFwiRnJlc2NhXCIsIFwiRnJpam9sZVwiLCBcIkZydWt0dXJcIiwgXCJGdWdheiBPbmVcIiwgXCJHRlMgRGlkb3RcIiwgXCJHRlMgTmVvaGVsbGVuaWNcIiwgXCJHYWJyaWVsYVwiLCBcIkdhZmF0YVwiLCBcIkdhbGRlYW5vXCIsIFwiR2FsaW5kb1wiLCBcIkdlbnRpdW0gQmFzaWNcIiwgXCJHZW50aXVtIEJvb2sgQmFzaWNcIiwgXCJHZW9cIiwgXCJHZW9zdGFyXCIsIFwiR2Vvc3RhciBGaWxsXCIsIFwiR2VybWFuaWEgT25lXCIsIFwiR2lkdWd1XCIsIFwiR2lsZGEgRGlzcGxheVwiLCBcIkdpdmUgWW91IEdsb3J5XCIsIFwiR2xhc3MgQW50aXF1YVwiLCBcIkdsZWdvb1wiLCBcIkdsb3JpYSBIYWxsZWx1amFoXCIsIFwiR29ibGluIE9uZVwiLCBcIkdvY2hpIEhhbmRcIiwgXCJHb3JkaXRhc1wiLCBcIkdvdWR5IEJvb2tsZXR0ZXIgMTkxMVwiLCBcIkdyYWR1YXRlXCIsIFwiR3JhbmQgSG90ZWxcIiwgXCJHcmF2aXRhcyBPbmVcIiwgXCJHcmVhdCBWaWJlc1wiLCBcIkdyaWZmeVwiLCBcIkdydXBwb1wiLCBcIkd1ZGVhXCIsIFwiR3VyYWphZGFcIiwgXCJIYWJpYmlcIiwgXCJIYWxhbnRcIiwgXCJIYW1tZXJzbWl0aCBPbmVcIiwgXCJIYW5hbGVpXCIsIFwiSGFuYWxlaSBGaWxsXCIsIFwiSGFuZGxlZVwiLCBcIkhhbnVtYW5cIiwgXCJIYXBweSBNb25rZXlcIiwgXCJIZWFkbGFuZCBPbmVcIiwgXCJIZW5ueSBQZW5ueVwiLCBcIkhlcnIgVm9uIE11ZWxsZXJob2ZmXCIsIFwiSGluZFwiLCBcIkhpbmQgU2lsaWd1cmlcIiwgXCJIaW5kIFZhZG9kYXJhXCIsIFwiSG9sdHdvb2QgT25lIFNDXCIsIFwiSG9tZW1hZGUgQXBwbGVcIiwgXCJIb21lbmFqZVwiLCBcIklNIEZlbGwgRFcgUGljYVwiLCBcIklNIEZlbGwgRFcgUGljYSBTQ1wiLCBcIklNIEZlbGwgRG91YmxlIFBpY2FcIiwgXCJJTSBGZWxsIERvdWJsZSBQaWNhIFNDXCIsIFwiSU0gRmVsbCBFbmdsaXNoXCIsIFwiSU0gRmVsbCBFbmdsaXNoIFNDXCIsIFwiSU0gRmVsbCBGcmVuY2ggQ2Fub25cIiwgXCJJTSBGZWxsIEZyZW5jaCBDYW5vbiBTQ1wiLCBcIklNIEZlbGwgR3JlYXQgUHJpbWVyXCIsIFwiSU0gRmVsbCBHcmVhdCBQcmltZXIgU0NcIiwgXCJJY2ViZXJnXCIsIFwiSWNlbGFuZFwiLCBcIkltcHJpbWFcIiwgXCJJbmNvbnNvbGF0YVwiLCBcIkluZGVyXCIsIFwiSW5kaWUgRmxvd2VyXCIsIFwiSW5pa2FcIiwgXCJJbmtudXQgQW50aXF1YVwiLCBcIklyaXNoIEdyb3ZlclwiLCBcIklzdG9rIFdlYlwiLCBcIkl0YWxpYW5hXCIsIFwiSXRhbGlhbm5vXCIsIFwiSXRpbVwiLCBcIkphY3F1ZXMgRnJhbmNvaXNcIiwgXCJKYWNxdWVzIEZyYW5jb2lzIFNoYWRvd1wiLCBcIkphbGRpXCIsIFwiSmltIE5pZ2h0c2hhZGVcIiwgXCJKb2NrZXkgT25lXCIsIFwiSm9sbHkgTG9kZ2VyXCIsIFwiSm9zZWZpbiBTYW5zXCIsIFwiSm9zZWZpbiBTbGFiXCIsIFwiSm90aSBPbmVcIiwgXCJKdWRzb25cIiwgXCJKdWxlZVwiLCBcIkp1bGl1cyBTYW5zIE9uZVwiLCBcIkp1bmdlXCIsIFwiSnVyYVwiLCBcIkp1c3QgQW5vdGhlciBIYW5kXCIsIFwiSnVzdCBNZSBBZ2FpbiBEb3duIEhlcmVcIiwgXCJLYWR3YVwiLCBcIkthbGFtXCIsIFwiS2FtZXJvblwiLCBcIkthbnR1bXJ1eVwiLCBcIkthcmxhXCIsIFwiS2FybWFcIiwgXCJLYXVzaGFuIFNjcmlwdFwiLCBcIkthdm9vblwiLCBcIktkYW0gVGhtb3JcIiwgXCJLZWFuaWEgT25lXCIsIFwiS2VsbHkgU2xhYlwiLCBcIktlbmlhXCIsIFwiS2hhbmRcIiwgXCJLaG1lclwiLCBcIktodWxhXCIsIFwiS2l0ZSBPbmVcIiwgXCJLbmV3YXZlXCIsIFwiS290dGEgT25lXCIsIFwiS291bGVuXCIsIFwiS3Jhbmt5XCIsIFwiS3Jlb25cIiwgXCJLcmlzdGlcIiwgXCJLcm9uYSBPbmVcIiwgXCJLdXJhbGVcIiwgXCJMYSBCZWxsZSBBdXJvcmVcIiwgXCJMYWlsYVwiLCBcIkxha2tpIFJlZGR5XCIsIFwiTGFuY2Vsb3RcIiwgXCJMYXRlZWZcIiwgXCJMYXRvXCIsIFwiTGVhZ3VlIFNjcmlwdFwiLCBcIkxlY2tlcmxpIE9uZVwiLCBcIkxlZGdlclwiLCBcIkxla3RvblwiLCBcIkxlbW9uXCIsIFwiTGlicmUgQmFza2VydmlsbGVcIiwgXCJMaWZlIFNhdmVyc1wiLCBcIkxpbGl0YSBPbmVcIiwgXCJMaWx5IFNjcmlwdCBPbmVcIiwgXCJMaW1lbGlnaHRcIiwgXCJMaW5kZW4gSGlsbFwiLCBcIkxvYnN0ZXJcIiwgXCJMb2JzdGVyIFR3b1wiLCBcIkxvbmRyaW5hIE91dGxpbmVcIiwgXCJMb25kcmluYSBTaGFkb3dcIiwgXCJMb25kcmluYSBTa2V0Y2hcIiwgXCJMb25kcmluYSBTb2xpZFwiLCBcIkxvcmFcIiwgXCJMb3ZlIFlhIExpa2UgQSBTaXN0ZXJcIiwgXCJMb3ZlZCBieSB0aGUgS2luZ1wiLCBcIkxvdmVycyBRdWFycmVsXCIsIFwiTHVja2llc3QgR3V5XCIsIFwiTHVzaXRhbmFcIiwgXCJMdXN0cmlhXCIsIFwiTWFjb25kb1wiLCBcIk1hY29uZG8gU3dhc2ggQ2Fwc1wiLCBcIk1hZ3JhXCIsIFwiTWFpZGVuIE9yYW5nZVwiLCBcIk1ha29cIiwgXCJNYWxsYW5uYVwiLCBcIk1hbmRhbGlcIiwgXCJNYXJjZWxsdXNcIiwgXCJNYXJjZWxsdXMgU0NcIiwgXCJNYXJjayBTY3JpcHRcIiwgXCJNYXJnYXJpbmVcIiwgXCJNYXJrbyBPbmVcIiwgXCJNYXJtZWxhZFwiLCBcIk1hcnRlbFwiLCBcIk1hcnRlbCBTYW5zXCIsIFwiTWFydmVsXCIsIFwiTWF0ZVwiLCBcIk1hdGUgU0NcIiwgXCJNYXZlbiBQcm9cIiwgXCJNY0xhcmVuXCIsIFwiTWVkZG9uXCIsIFwiTWVkaWV2YWxTaGFycFwiLCBcIk1lZHVsYSBPbmVcIiwgXCJNZWdyaW1cIiwgXCJNZWllIFNjcmlwdFwiLCBcIk1lcmllbmRhXCIsIFwiTWVyaWVuZGEgT25lXCIsIFwiTWVycml3ZWF0aGVyXCIsIFwiTWVycml3ZWF0aGVyIFNhbnNcIiwgXCJNZXRhbFwiLCBcIk1ldGFsIE1hbmlhXCIsIFwiTWV0YW1vcnBob3VzXCIsIFwiTWV0cm9waG9iaWNcIiwgXCJNaWNocm9tYVwiLCBcIk1pbG9uZ2FcIiwgXCJNaWx0b25pYW5cIiwgXCJNaWx0b25pYW4gVGF0dG9vXCIsIFwiTWluaXZlclwiLCBcIk1pc3MgRmFqYXJkb3NlXCIsIFwiTW9kYWtcIiwgXCJNb2Rlcm4gQW50aXF1YVwiLCBcIk1vbGVuZ29cIiwgXCJNb2xsZVwiLCBcIk1vbmRhXCIsIFwiTW9ub2ZldHRcIiwgXCJNb25vdG9uXCIsIFwiTW9uc2lldXIgTGEgRG91bGFpc2VcIiwgXCJNb250YWdhXCIsIFwiTW9udGV6XCIsIFwiTW9udHNlcnJhdFwiLCBcIk1vbnRzZXJyYXQgQWx0ZXJuYXRlc1wiLCBcIk1vbnRzZXJyYXQgU3VicmF5YWRhXCIsIFwiTW91bFwiLCBcIk1vdWxwYWxpXCIsIFwiTW91bnRhaW5zIG9mIENocmlzdG1hc1wiLCBcIk1vdXNlIE1lbW9pcnNcIiwgXCJNciBCZWRmb3J0XCIsIFwiTXIgRGFmb2VcIiwgXCJNciBEZSBIYXZpbGFuZFwiLCBcIk1ycyBTYWludCBEZWxhZmllbGRcIiwgXCJNcnMgU2hlcHBhcmRzXCIsIFwiTXVsaVwiLCBcIk15c3RlcnkgUXVlc3RcIiwgXCJOVFJcIiwgXCJOZXVjaGFcIiwgXCJOZXV0b25cIiwgXCJOZXcgUm9ja2VyXCIsIFwiTmV3cyBDeWNsZVwiLCBcIk5pY29ubmVcIiwgXCJOaXhpZSBPbmVcIiwgXCJOb2JpbGVcIiwgXCJOb2tvcmFcIiwgXCJOb3JpY2FuXCIsIFwiTm9zaWZlclwiLCBcIk5vdGhpbmcgWW91IENvdWxkIERvXCIsIFwiTm90aWNpYSBUZXh0XCIsIFwiTm90byBTYW5zXCIsIFwiTm90byBTZXJpZlwiLCBcIk5vdmEgQ3V0XCIsIFwiTm92YSBGbGF0XCIsIFwiTm92YSBNb25vXCIsIFwiTm92YSBPdmFsXCIsIFwiTm92YSBSb3VuZFwiLCBcIk5vdmEgU2NyaXB0XCIsIFwiTm92YSBTbGltXCIsIFwiTm92YSBTcXVhcmVcIiwgXCJOdW1hbnNcIiwgXCJOdW5pdG9cIiwgXCJPZG9yIE1lYW4gQ2hleVwiLCBcIk9mZnNpZGVcIiwgXCJPbGQgU3RhbmRhcmQgVFRcIiwgXCJPbGRlbmJ1cmdcIiwgXCJPbGVvIFNjcmlwdFwiLCBcIk9sZW8gU2NyaXB0IFN3YXNoIENhcHNcIiwgXCJPcGVuIFNhbnNcIiwgXCJPcGVuIFNhbnMgQ29uZGVuc2VkXCIsIFwiT3JhbmllbmJhdW1cIiwgXCJPcmJpdHJvblwiLCBcIk9yZWdhbm9cIiwgXCJPcmllbnRhXCIsIFwiT3JpZ2luYWwgU3VyZmVyXCIsIFwiT3N3YWxkXCIsIFwiT3ZlciB0aGUgUmFpbmJvd1wiLCBcIk92ZXJsb2NrXCIsIFwiT3ZlcmxvY2sgU0NcIiwgXCJPdm9cIiwgXCJPeHlnZW5cIiwgXCJPeHlnZW4gTW9ub1wiLCBcIlBUIE1vbm9cIiwgXCJQVCBTYW5zXCIsIFwiUFQgU2FucyBDYXB0aW9uXCIsIFwiUFQgU2FucyBOYXJyb3dcIiwgXCJQVCBTZXJpZlwiLCBcIlBUIFNlcmlmIENhcHRpb25cIiwgXCJQYWNpZmljb1wiLCBcIlBhbGFucXVpblwiLCBcIlBhbGFucXVpbiBEYXJrXCIsIFwiUGFwcmlrYVwiLCBcIlBhcmlzaWVubmVcIiwgXCJQYXNzZXJvIE9uZVwiLCBcIlBhc3Npb24gT25lXCIsIFwiUGF0aHdheSBHb3RoaWMgT25lXCIsIFwiUGF0cmljayBIYW5kXCIsIFwiUGF0cmljayBIYW5kIFNDXCIsIFwiUGF0dWEgT25lXCIsIFwiUGF5dG9uZSBPbmVcIiwgXCJQZWRkYW5hXCIsIFwiUGVyYWx0YVwiLCBcIlBlcm1hbmVudCBNYXJrZXJcIiwgXCJQZXRpdCBGb3JtYWwgU2NyaXB0XCIsIFwiUGV0cm9uYVwiLCBcIlBoaWxvc29waGVyXCIsIFwiUGllZHJhXCIsIFwiUGlueW9uIFNjcmlwdFwiLCBcIlBpcmF0YSBPbmVcIiwgXCJQbGFzdGVyXCIsIFwiUGxheVwiLCBcIlBsYXliYWxsXCIsIFwiUGxheWZhaXIgRGlzcGxheVwiLCBcIlBsYXlmYWlyIERpc3BsYXkgU0NcIiwgXCJQb2Rrb3ZhXCIsIFwiUG9pcmV0IE9uZVwiLCBcIlBvbGxlciBPbmVcIiwgXCJQb2x5XCIsIFwiUG9tcGllcmVcIiwgXCJQb250YW5vIFNhbnNcIiwgXCJQb3BwaW5zXCIsIFwiUG9ydCBMbGlnYXQgU2Fuc1wiLCBcIlBvcnQgTGxpZ2F0IFNsYWJcIiwgXCJQcmFnYXRpIE5hcnJvd1wiLCBcIlByYXRhXCIsIFwiUHJlYWh2aWhlYXJcIiwgXCJQcmVzcyBTdGFydCAyUFwiLCBcIlByaW5jZXNzIFNvZmlhXCIsIFwiUHJvY2lvbm9cIiwgXCJQcm9zdG8gT25lXCIsIFwiUHVyaXRhblwiLCBcIlB1cnBsZSBQdXJzZVwiLCBcIlF1YW5kb1wiLCBcIlF1YW50aWNvXCIsIFwiUXVhdHRyb2NlbnRvXCIsIFwiUXVhdHRyb2NlbnRvIFNhbnNcIiwgXCJRdWVzdHJpYWxcIiwgXCJRdWlja3NhbmRcIiwgXCJRdWludGVzc2VudGlhbFwiLCBcIlF3aWdsZXlcIiwgXCJSYWNpbmcgU2FucyBPbmVcIiwgXCJSYWRsZXlcIiwgXCJSYWpkaGFuaVwiLCBcIlJhbGV3YXlcIiwgXCJSYWxld2F5IERvdHNcIiwgXCJSYW1hYmhhZHJhXCIsIFwiUmFtYXJhamFcIiwgXCJSYW1ibGFcIiwgXCJSYW1tZXR0byBPbmVcIiwgXCJSYW5jaGVyc1wiLCBcIlJhbmNob1wiLCBcIlJhbmdhXCIsIFwiUmF0aW9uYWxlXCIsIFwiUmF2aSBQcmFrYXNoXCIsIFwiUmVkcmVzc2VkXCIsIFwiUmVlbmllIEJlYW5pZVwiLCBcIlJldmFsaWFcIiwgXCJSaG9kaXVtIExpYnJlXCIsIFwiUmliZXllXCIsIFwiUmliZXllIE1hcnJvd1wiLCBcIlJpZ2h0ZW91c1wiLCBcIlJpc3F1ZVwiLCBcIlJvYm90b1wiLCBcIlJvYm90byBDb25kZW5zZWRcIiwgXCJSb2JvdG8gTW9ub1wiLCBcIlJvYm90byBTbGFiXCIsIFwiUm9jaGVzdGVyXCIsIFwiUm9jayBTYWx0XCIsIFwiUm9ra2l0dFwiLCBcIlJvbWFuZXNjb1wiLCBcIlJvcGEgU2Fuc1wiLCBcIlJvc2FyaW9cIiwgXCJSb3Nhcml2b1wiLCBcIlJvdWdlIFNjcmlwdFwiLCBcIlJvemhhIE9uZVwiLCBcIlJ1YmlrXCIsIFwiUnViaWsgTW9ubyBPbmVcIiwgXCJSdWJpayBPbmVcIiwgXCJSdWRhXCIsIFwiUnVmaW5hXCIsIFwiUnVnZSBCb29naWVcIiwgXCJSdWx1a29cIiwgXCJSdW0gUmFpc2luXCIsIFwiUnVzbGFuIERpc3BsYXlcIiwgXCJSdXNzbyBPbmVcIiwgXCJSdXRoaWVcIiwgXCJSeWVcIiwgXCJTYWNyYW1lbnRvXCIsIFwiU2FoaXR5YVwiLCBcIlNhaWxcIiwgXCJTYWxzYVwiLCBcIlNhbmNoZXpcIiwgXCJTYW5jcmVla1wiLCBcIlNhbnNpdGEgT25lXCIsIFwiU2FyYWxhXCIsIFwiU2FyaW5hXCIsIFwiU2FycGFuY2hcIiwgXCJTYXRpc2Z5XCIsIFwiU2NhZGFcIiwgXCJTY2hlaGVyYXphZGVcIiwgXCJTY2hvb2xiZWxsXCIsIFwiU2Vhd2VlZCBTY3JpcHRcIiwgXCJTZXZpbGxhbmFcIiwgXCJTZXltb3VyIE9uZVwiLCBcIlNoYWRvd3MgSW50byBMaWdodFwiLCBcIlNoYWRvd3MgSW50byBMaWdodCBUd29cIiwgXCJTaGFudGlcIiwgXCJTaGFyZVwiLCBcIlNoYXJlIFRlY2hcIiwgXCJTaGFyZSBUZWNoIE1vbm9cIiwgXCJTaG9qdW1hcnVcIiwgXCJTaG9ydCBTdGFja1wiLCBcIlNpZW1yZWFwXCIsIFwiU2lnbWFyIE9uZVwiLCBcIlNpZ25pa2FcIiwgXCJTaWduaWthIE5lZ2F0aXZlXCIsIFwiU2ltb25ldHRhXCIsIFwiU2ludG9ueVwiLCBcIlNpcmluIFN0ZW5jaWxcIiwgXCJTaXggQ2Fwc1wiLCBcIlNrcmFuamlcIiwgXCJTbGFibyAxM3B4XCIsIFwiU2xhYm8gMjdweFwiLCBcIlNsYWNrZXlcIiwgXCJTbW9rdW1cIiwgXCJTbXl0aGVcIiwgXCJTbmlnbGV0XCIsIFwiU25pcHBldFwiLCBcIlNub3didXJzdCBPbmVcIiwgXCJTb2ZhZGkgT25lXCIsIFwiU29maWFcIiwgXCJTb25zaWUgT25lXCIsIFwiU29ydHMgTWlsbCBHb3VkeVwiLCBcIlNvdXJjZSBDb2RlIFByb1wiLCBcIlNvdXJjZSBTYW5zIFByb1wiLCBcIlNvdXJjZSBTZXJpZiBQcm9cIiwgXCJTcGVjaWFsIEVsaXRlXCIsIFwiU3BpY3kgUmljZVwiLCBcIlNwaW5uYWtlclwiLCBcIlNwaXJheFwiLCBcIlNxdWFkYSBPbmVcIiwgXCJTcmVlIEtydXNobmFkZXZhcmF5YVwiLCBcIlN0YWxlbWF0ZVwiLCBcIlN0YWxpbmlzdCBPbmVcIiwgXCJTdGFyZG9zIFN0ZW5jaWxcIiwgXCJTdGludCBVbHRyYSBDb25kZW5zZWRcIiwgXCJTdGludCBVbHRyYSBFeHBhbmRlZFwiLCBcIlN0b2tlXCIsIFwiU3RyYWl0XCIsIFwiU3VlIEVsbGVuIEZyYW5jaXNjb1wiLCBcIlN1bWFuYVwiLCBcIlN1bnNoaW5leVwiLCBcIlN1cGVybWVyY2FkbyBPbmVcIiwgXCJTdXJhXCIsIFwiU3VyYW5uYVwiLCBcIlN1cmF2YXJhbVwiLCBcIlN1d2FubmFwaHVtXCIsIFwiU3dhbmt5IGFuZCBNb28gTW9vXCIsIFwiU3luY29wYXRlXCIsIFwiVGFuZ2VyaW5lXCIsIFwiVGFwcm9tXCIsIFwiVGF1cmlcIiwgXCJUZWtvXCIsIFwiVGVsZXhcIiwgXCJUZW5hbGkgUmFtYWtyaXNobmFcIiwgXCJUZW5vciBTYW5zXCIsIFwiVGV4dCBNZSBPbmVcIiwgXCJUaGUgR2lybCBOZXh0IERvb3JcIiwgXCJUaWVubmVcIiwgXCJUaWxsYW5hXCIsIFwiVGltbWFuYVwiLCBcIlRpbm9zXCIsIFwiVGl0YW4gT25lXCIsIFwiVGl0aWxsaXVtIFdlYlwiLCBcIlRyYWRlIFdpbmRzXCIsIFwiVHJvY2NoaVwiLCBcIlRyb2NodXRcIiwgXCJUcnlra2VyXCIsIFwiVHVscGVuIE9uZVwiLCBcIlVidW50dVwiLCBcIlVidW50dSBDb25kZW5zZWRcIiwgXCJVYnVudHUgTW9ub1wiLCBcIlVsdHJhXCIsIFwiVW5jaWFsIEFudGlxdWFcIiwgXCJVbmRlcmRvZ1wiLCBcIlVuaWNhIE9uZVwiLCBcIlVuaWZyYWt0dXJDb29rXCIsIFwiVW5pZnJha3R1ck1hZ3VudGlhXCIsIFwiVW5rZW1wdFwiLCBcIlVubG9ja1wiLCBcIlVubmFcIiwgXCJWVDMyM1wiLCBcIlZhbXBpcm8gT25lXCIsIFwiVmFyZWxhXCIsIFwiVmFyZWxhIFJvdW5kXCIsIFwiVmFzdCBTaGFkb3dcIiwgXCJWZXNwZXIgTGlicmVcIiwgXCJWaWJ1clwiLCBcIlZpZGFsb2thXCIsIFwiVmlnYVwiLCBcIlZvY2VzXCIsIFwiVm9sa2hvdlwiLCBcIlZvbGxrb3JuXCIsIFwiVm9sdGFpcmVcIiwgXCJXYWl0aW5nIGZvciB0aGUgU3VucmlzZVwiLCBcIldhbGxwb2V0XCIsIFwiV2FsdGVyIFR1cm5jb2F0XCIsIFwiV2FybmVzXCIsIFwiV2VsbGZsZWV0XCIsIFwiV2VuZHkgT25lXCIsIFwiV2lyZSBPbmVcIiwgXCJXb3JrIFNhbnNcIiwgXCJZYW5vbmUgS2FmZmVlc2F0elwiLCBcIllhbnRyYW1hbmF2XCIsIFwiWWVsbG93dGFpbFwiLCBcIlllc2V2YSBPbmVcIiwgXCJZZXN0ZXJ5ZWFyXCIsIFwiWmV5YWRhXCJdO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiaW1wb3J0IHthcHBseSwgYXBwbHlCYWNrZ3JvdW5kLCBhcHBseVN0eWxlfSBmcm9tICcuL2luZGV4JztcclxuaW1wb3J0IHN0eWxlZnVuY3Rpb24gZnJvbSAnLi9zdHlsZWZ1bmN0aW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBhcHBseTogYXBwbHksXHJcbiAgYXBwbHlCYWNrZ3JvdW5kOiBhcHBseUJhY2tncm91bmQsXHJcbiAgYXBwbHlTdHlsZTogYXBwbHlTdHlsZSxcclxuICBzdHlsZWZ1bmN0aW9uOiBzdHlsZWZ1bmN0aW9uXHJcbn07XHJcbiIsIi8qXHJcbm9sLW1hcGJveC1zdHlsZSAtIFVzZSBNYXBib3ggU3R5bGUgb2JqZWN0cyB3aXRoIE9wZW5MYXllcnNcclxuQ29weXJpZ2h0IDIwMTYtcHJlc2VudCBCb3VuZGxlc3MgU3BhdGlhbCwgSW5jLlxyXG5MaWNlbnNlOiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYm91bmRsZXNzZ2VvL29sLW1hcGJveC1nbC1zdHlsZS9tYXN0ZXIvTElDRU5TRVxyXG4qL1xyXG5cclxuaW1wb3J0IFN0eWxlIGZyb20gJ29sL3N0eWxlL1N0eWxlJztcclxuaW1wb3J0IEZpbGwgZnJvbSAnb2wvc3R5bGUvRmlsbCc7XHJcbmltcG9ydCBTdHJva2UgZnJvbSAnb2wvc3R5bGUvU3Ryb2tlJztcclxuaW1wb3J0IEljb24gZnJvbSAnb2wvc3R5bGUvSWNvbic7XHJcbmltcG9ydCBUZXh0IGZyb20gJ29sL3N0eWxlL1RleHQnO1xyXG5pbXBvcnQgQ2lyY2xlIGZyb20gJ29sL3N0eWxlL0NpcmNsZSc7XHJcbmltcG9ydCBQb2ludCBmcm9tICdvbC9nZW9tL1BvaW50JztcclxuaW1wb3J0IHtkZXJlZkxheWVyc30gZnJvbSAnQG1hcGJveC9tYXBib3gtZ2wtc3R5bGUtc3BlYyc7XHJcbmltcG9ydCB7XHJcbiAgZXhwcmVzc2lvbiwgQ29sb3IsXHJcbiAgZnVuY3Rpb24gYXMgZm4sXHJcbiAgbGF0ZXN0IGFzIHNwZWMsXHJcbiAgZmVhdHVyZUZpbHRlciBhcyBjcmVhdGVGaWx0ZXJcclxufSBmcm9tICdAbWFwYm94L21hcGJveC1nbC1zdHlsZS1zcGVjJztcclxuaW1wb3J0IG1iMmNzcyBmcm9tICdtYXBib3gtdG8tY3NzLWZvbnQnO1xyXG5pbXBvcnQge1xyXG4gIGRlZzJyYWQsXHJcbiAgZ2V0Wm9vbUZvclJlc29sdXRpb25cclxufSBmcm9tICcuL3V0aWwnO1xyXG5cclxuXHJcbmNvbnN0IGlzRnVuY3Rpb24gPSBmbi5pc0Z1bmN0aW9uO1xyXG5jb25zdCBjb252ZXJ0RnVuY3Rpb24gPSBmbi5jb252ZXJ0RnVuY3Rpb247XHJcbmNvbnN0IGlzRXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uaXNFeHByZXNzaW9uO1xyXG5jb25zdCBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24gPSBleHByZXNzaW9uLmNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbjtcclxuXHJcbmNvbnN0IHR5cGVzID0ge1xyXG4gICdQb2ludCc6IDEsXHJcbiAgJ011bHRpUG9pbnQnOiAxLFxyXG4gICdMaW5lU3RyaW5nJzogMixcclxuICAnTXVsdGlMaW5lU3RyaW5nJzogMixcclxuICAnUG9seWdvbic6IDMsXHJcbiAgJ011bHRpUG9seWdvbic6IDNcclxufTtcclxuY29uc3QgZXhwcmVzc2lvbkRhdGEgPSBmdW5jdGlvbihyYXdFeHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHtcclxuICBjb25zdCBjb21waWxlZEV4cHJlc3Npb24gPSBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24ocmF3RXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKTtcclxuICBpZiAoY29tcGlsZWRFeHByZXNzaW9uLnJlc3VsdCA9PT0gJ2Vycm9yJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGNvbXBpbGVkRXhwcmVzc2lvbi52YWx1ZS5tYXAoZXJyID0+IGAke2Vyci5rZXl9OiAke2Vyci5tZXNzYWdlfWApLmpvaW4oJywgJykpO1xyXG4gIH1cclxuICByZXR1cm4gY29tcGlsZWRFeHByZXNzaW9uLnZhbHVlO1xyXG59O1xyXG5cclxuY29uc3QgZW1wdHlPYmogPSB7fTtcclxuY29uc3Qgem9vbU9iaiA9IHt6b29tOiAwfTtcclxuY29uc3QgZnVuY3Rpb25DYWNoZSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBHbCBvYmplY3QgbGF5ZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYXlvdXRPclBhaW50ICdsYXlvdXQnIG9yICdwYWludCcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBGZWF0dXJlIHByb3BlcnR5LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZSBHbCBmZWF0dXJlLlxyXG4gKiBAcmV0dXJuIHs/fSBWYWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZShsYXllciwgbGF5b3V0T3JQYWludCwgcHJvcGVydHksIHpvb20sIGZlYXR1cmUpIHtcclxuICBjb25zdCBsYXllcklkID0gbGF5ZXIuaWQ7XHJcbiAgaWYgKCFmdW5jdGlvbkNhY2hlW2xheWVySWRdKSB7XHJcbiAgICBmdW5jdGlvbkNhY2hlW2xheWVySWRdID0ge307XHJcbiAgfVxyXG4gIGNvbnN0IGZ1bmN0aW9ucyA9IGZ1bmN0aW9uQ2FjaGVbbGF5ZXJJZF07XHJcbiAgaWYgKCFmdW5jdGlvbnNbcHJvcGVydHldKSB7XHJcbiAgICBsZXQgdmFsdWUgPSAobGF5ZXJbbGF5b3V0T3JQYWludF0gfHwgZW1wdHlPYmopW3Byb3BlcnR5XTtcclxuICAgIGNvbnN0IHByb3BlcnR5U3BlYyA9IHNwZWNbYCR7bGF5b3V0T3JQYWludH1fJHtsYXllci50eXBlfWBdW3Byb3BlcnR5XTtcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhbHVlID0gcHJvcGVydHlTcGVjLmRlZmF1bHQ7XHJcbiAgICB9XHJcbiAgICBsZXQgaXNFeHByID0gaXNFeHByZXNzaW9uKCh2YWx1ZSkpO1xyXG4gICAgaWYgKCFpc0V4cHIgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgdmFsdWUgPSBjb252ZXJ0RnVuY3Rpb24odmFsdWUsIHByb3BlcnR5U3BlYyk7XHJcbiAgICAgIGlzRXhwciA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNFeHByKSB7XHJcbiAgICAgIGNvbnN0IGNvbXBpbGVkRXhwcmVzc2lvbiA9IGV4cHJlc3Npb25EYXRhKHZhbHVlLCBwcm9wZXJ0eVNwZWMpO1xyXG4gICAgICBmdW5jdGlvbnNbcHJvcGVydHldID0gY29tcGlsZWRFeHByZXNzaW9uLmV2YWx1YXRlLmJpbmQoY29tcGlsZWRFeHByZXNzaW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PSAnY29sb3InKSB7XHJcbiAgICAgICAgdmFsdWUgPSBDb2xvci5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb25zW3Byb3BlcnR5XSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbiAgem9vbU9iai56b29tID0gem9vbTtcclxuICByZXR1cm4gZnVuY3Rpb25zW3Byb3BlcnR5XSh6b29tT2JqLCBmZWF0dXJlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY292ZXJ0SWNvbkFuY2hvcihpY29uQW5jaG9yKSB7XHJcbiAgbGV0IGFuY2hvck9mZnNldCA9IFswLjUsIDAuNV07XHJcbiAgaWYgKFsndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCddLmluZGV4T2YoaWNvbkFuY2hvcikgPiAtMSkge1xyXG4gICAgYW5jaG9yT2Zmc2V0ID0gWzAsIDBdO1xyXG4gIH1cclxuICBpZiAoaWNvbkFuY2hvciA9PT0gJ2xlZnQnKSB7XHJcbiAgICBpY29uQW5jaG9yID0gJ3RvcC1sZWZ0JztcclxuICAgIGFuY2hvck9mZnNldCA9IFswLCAwLjVdO1xyXG4gIH1cclxuICBpZiAoaWNvbkFuY2hvciA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgaWNvbkFuY2hvciA9ICd0b3AtbGVmdCc7XHJcbiAgICBhbmNob3JPZmZzZXQgPSBbMSwgMC41XTtcclxuICB9XHJcbiAgaWYgKGljb25BbmNob3IgPT09ICdib3R0b20nKSB7XHJcbiAgICBpY29uQW5jaG9yID0gJ3RvcC1sZWZ0JztcclxuICAgIGFuY2hvck9mZnNldCA9IFswLjUsIDFdO1xyXG4gIH1cclxuICBpZiAoaWNvbkFuY2hvciA9PT0gJ3RvcCcpIHtcclxuICAgIGljb25BbmNob3IgPSAndG9wLWxlZnQnO1xyXG4gICAgYW5jaG9yT2Zmc2V0ID0gWzAuNSwgMF07XHJcbiAgfVxyXG4gIC8vY2VudGVyXHJcbiAgcmV0dXJuIHtcclxuICAgIGFuY2hvck9mZnNldDogYW5jaG9yT2Zmc2V0LFxyXG4gICAgaWNvbkFuY2hvcjogaWNvbkFuY2hvclxyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IGZvbnRNYXAgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGNob29zZUZvbnQoZm9udHMsIGF2YWlsYWJsZUZvbnRzKSB7XHJcbiAgaWYgKGZvbnRNYXBbZm9udHNdKSB7XHJcbiAgICByZXR1cm4gZm9udE1hcFtmb250c107XHJcbiAgfVxyXG4gIGlmIChhdmFpbGFibGVGb250cykge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZm9udHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICBjb25zdCBmb250ID0gZm9udHNbaV07XHJcbiAgICAgIGlmIChhdmFpbGFibGVGb250cy5pbmRleE9mKGZvbnQpICE9IC0xKSB7XHJcbiAgICAgICAgZm9udE1hcFtmb250c10gPSBmb250O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWZvbnRNYXBbZm9udHNdKSB7XHJcbiAgICAgIC8vIGZhbGxiYWNrIGZvbnRcclxuICAgICAgZm9udE1hcFtmb250c10gPSBmb250c1tmb250cy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgZm9udE1hcFtmb250c10gPSBmb250c1swXTtcclxuICB9XHJcbiAgcmV0dXJuIGZvbnRNYXBbZm9udHNdO1xyXG59XHJcblxyXG5jb25zdCBmaWx0ZXJDYWNoZSA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZXZhbHVhdGVGaWx0ZXIobGF5ZXJJZCwgZmlsdGVyLCBmZWF0dXJlLCB6b29tKSB7XHJcbiAgaWYgKCEobGF5ZXJJZCBpbiBmaWx0ZXJDYWNoZSkpIHtcclxuICAgIGZpbHRlckNhY2hlW2xheWVySWRdID0gY3JlYXRlRmlsdGVyKGZpbHRlcikuZmlsdGVyO1xyXG4gIH1cclxuICB6b29tT2JqLnpvb20gPSB6b29tO1xyXG4gIHJldHVybiBmaWx0ZXJDYWNoZVtsYXllcklkXSh6b29tT2JqLCBmZWF0dXJlKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbG9yV2l0aE9wYWNpdHkoY29sb3IsIG9wYWNpdHkpIHtcclxuICBpZiAoY29sb3IpIHtcclxuICAgIGlmIChjb2xvci5hID09PSAwIHx8IG9wYWNpdHkgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IGEgPSBjb2xvci5hO1xyXG4gICAgb3BhY2l0eSA9IG9wYWNpdHkgPT09IHVuZGVmaW5lZCA/IDEgOiBvcGFjaXR5O1xyXG4gICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKGNvbG9yLnIgKiAyNTUgLyBhKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuZyAqIDI1NSAvIGEpICtcclxuICAgICAgJywnICsgTWF0aC5yb3VuZChjb2xvci5iICogMjU1IC8gYSkgKyAnLCcgKyAoYSAqIG9wYWNpdHkpICsgJyknO1xyXG4gIH1cclxuICByZXR1cm4gY29sb3I7XHJcbn1cclxuXHJcbmNvbnN0IHRlbXBsYXRlUmVnRXggPSAvXihbXl0qKVxceyguKilcXH0oW15dKikkLztcclxuXHJcbmZ1bmN0aW9uIGZyb21UZW1wbGF0ZSh0ZXh0LCBwcm9wZXJ0aWVzKSB7XHJcbiAgbGV0IHBhcnRzO1xyXG4gIGRvIHtcclxuICAgIHBhcnRzID0gdGV4dC5tYXRjaCh0ZW1wbGF0ZVJlZ0V4KTtcclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbcGFydHNbMl1dIHx8ICcnO1xyXG4gICAgICB0ZXh0ID0gcGFydHNbMV0gKyB2YWx1ZSArIHBhcnRzWzNdO1xyXG4gICAgfVxyXG4gIH0gd2hpbGUgKHBhcnRzKTtcclxuICByZXR1cm4gdGV4dDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzdHlsZSBmdW5jdGlvbiBmcm9tIHRoZSBgZ2xTdHlsZWAgb2JqZWN0IGZvciBhbGwgbGF5ZXJzIHRoYXQgdXNlXHJcbiAqIHRoZSBzcGVjaWZpZWQgYHNvdXJjZWAsIHdoaWNoIG5lZWRzIHRvIGJlIGEgYFwidHlwZVwiOiBcInZlY3RvclwiYCBvclxyXG4gKiBgXCJ0eXBlXCI6IFwiZ2VvanNvblwiYCBzb3VyY2UgYW5kIGFwcGxpZXMgaXQgdG8gdGhlIHNwZWNpZmllZCBPcGVuTGF5ZXJzIGxheWVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29sLmxheWVyLlZlY3RvcnxvbC5sYXllci5WZWN0b3JUaWxlfSBvbExheWVyIE9wZW5MYXllcnMgbGF5ZXIgdG9cclxuICogYXBwbHkgdGhlIHN0eWxlIHRvLiBJbiBhZGRpdGlvbiB0byB0aGUgc3R5bGUsIHRoZSBsYXllciB3aWxsIGdldCB0d29cclxuICogcHJvcGVydGllczogYG1hcGJveC1zb3VyY2VgIHdpbGwgYmUgdGhlIGBpZGAgb2YgdGhlIGBnbFN0eWxlYCdzIHNvdXJjZSB1c2VkXHJcbiAqIGZvciB0aGUgbGF5ZXIsIGFuZCBgbWFwYm94LWxheWVyc2Agd2lsbCBiZSBhbiBhcnJheSBvZiB0aGUgYGlkYHMgb2YgdGhlXHJcbiAqIGBnbFN0eWxlYCdzIGxheWVycy5cclxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBnbFN0eWxlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHNvdXJjZSBgc291cmNlYCBrZXkgb3IgYW4gYXJyYXkgb2YgbGF5ZXIgYGlkYHNcclxuICogZnJvbSB0aGUgTWFwYm94IFN0eWxlIG9iamVjdC4gV2hlbiBhIGBzb3VyY2VgIGtleSBpcyBwcm92aWRlZCwgYWxsIGxheWVycyBmb3JcclxuICogdGhlIHNwZWNpZmllZCBzb3VyY2Ugd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgc3R5bGUgZnVuY3Rpb24uIFdoZW4gbGF5ZXIgYGlkYHNcclxuICogYXJlIHByb3ZpZGVkLCB0aGV5IG11c3QgYmUgZnJvbSBsYXllcnMgdGhhdCB1c2UgdGhlIHNhbWUgc291cmNlLlxyXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtyZXNvbHV0aW9ucz1bNzgyNzEuNTE2OTY0MDIwNDgsIDM5MTM1Ljc1ODQ4MjAxMDI0LFxyXG4gKiAxOTU2Ny44NzkyNDEwMDUxMiwgOTc4My45Mzk2MjA1MDI1NiwgNDg5MS45Njk4MTAyNTEyOCwgMjQ0NS45ODQ5MDUxMjU2NCxcclxuICogMTIyMi45OTI0NTI1NjI4MiwgNjExLjQ5NjIyNjI4MTQxLCAzMDUuNzQ4MTEzMTQwNzA1LCAxNTIuODc0MDU2NTcwMzUyNSxcclxuICogNzYuNDM3MDI4Mjg1MTc2MjUsIDM4LjIxODUxNDE0MjU4ODEzLCAxOS4xMDkyNTcwNzEyOTQwNjMsIDkuNTU0NjI4NTM1NjQ3MDMyLFxyXG4gKiA0Ljc3NzMxNDI2NzgyMzUxNiwgMi4zODg2NTcxMzM5MTE3NTgsIDEuMTk0MzI4NTY2OTU1ODc5LCAwLjU5NzE2NDI4MzQ3NzkzOTUsXHJcbiAqIDAuMjk4NTgyMTQxNzM4OTY5NzQsIDAuMTQ5MjkxMDcwODY5NDg0ODcsIDAuMDc0NjQ1NTM1NDM0NzQyNDRdXVxyXG4gKiBSZXNvbHV0aW9ucyBmb3IgbWFwcGluZyByZXNvbHV0aW9uIHRvIHpvb20gbGV2ZWwuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3ByaXRlRGF0YT11bmRlZmluZWRdIFNwcml0ZSBkYXRhIGZyb20gdGhlIHVybCBzcGVjaWZpZWQgaW5cclxuICogdGhlIE1hcGJveCBTdHlsZSBvYmplY3QncyBgc3ByaXRlYCBwcm9wZXJ0eS4gT25seSByZXF1aXJlZCBpZiBhIGBzcHJpdGVgXHJcbiAqIHByb3BlcnR5IGlzIHNwZWNpZmllZCBpbiB0aGUgTWFwYm94IFN0eWxlIG9iamVjdC5cclxuICogQHBhcmFtIHtPYmplY3R9IFtzcHJpdGVJbWFnZVVybD11bmRlZmluZWRdIFNwcml0ZSBpbWFnZSB1cmwgZm9yIHRoZSBzcHJpdGVcclxuICogc3BlY2lmaWVkIGluIHRoZSBNYXBib3ggU3R5bGUgb2JqZWN0J3MgYHNwcml0ZWAgcHJvcGVydHkuIE9ubHkgcmVxdWlyZWQgaWYgYVxyXG4gKiBgc3ByaXRlYCBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQgaW4gdGhlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW2ZvbnRzPXVuZGVmaW5lZF0gQXJyYXkgb2YgYXZhaWxhYmxlIGZvbnRzLCB1c2luZyB0aGVcclxuICogc2FtZSBmb250IG5hbWVzIGFzIHRoZSBNYXBib3ggU3R5bGUgb2JqZWN0LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBzdHlsZVxyXG4gKiBmdW5jdGlvbiB3aWxsIGFsd2F5cyB1c2UgdGhlIGZpcnN0IGZvbnQgZnJvbSB0aGUgZm9udCBhcnJheS5cclxuICogQHJldHVybiB7b2wuc3R5bGUuU3R5bGVGdW5jdGlvbn0gU3R5bGUgZnVuY3Rpb24gZm9yIHVzZSBpblxyXG4gKiBgb2wubGF5ZXIuVmVjdG9yYCBvciBgb2wubGF5ZXIuVmVjdG9yVGlsZWAuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvbExheWVyLCBnbFN0eWxlLCBzb3VyY2UsIHJlc29sdXRpb25zLCBzcHJpdGVEYXRhLCBzcHJpdGVJbWFnZVVybCxzcHJpdGVJbWFnZSwgZm9udHMpIHtcclxuICBpZiAoIXJlc29sdXRpb25zKSB7XHJcbiAgICByZXNvbHV0aW9ucyA9IFtdO1xyXG4gICAgZm9yIChsZXQgcmVzID0gNzgyNzEuNTE2OTY0MDIwNDg7IHJlc29sdXRpb25zLmxlbmd0aCA8IDIxOyByZXMgLz0gMikge1xyXG4gICAgICByZXNvbHV0aW9ucy5wdXNoKHJlcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgZ2xTdHlsZSA9PSAnc3RyaW5nJykge1xyXG4gICAgZ2xTdHlsZSA9IEpTT04ucGFyc2UoZ2xTdHlsZSk7XHJcbiAgfVxyXG4gIGlmIChnbFN0eWxlLnZlcnNpb24gIT0gOCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbFN0eWxlIHZlcnNpb24gOCByZXF1aXJlZC4nKTtcclxuICB9XHJcblxyXG4gIGxldCBzcHJpdGVJbWdTaXplO1xyXG4gIGlmIChzcHJpdGVJbWFnZVVybCAmJiAhc3ByaXRlSW1hZ2UpIHtcclxuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHNwcml0ZUltYWdlID0gaW1nO1xyXG4gICAgICBzcHJpdGVJbWdTaXplID0gW2ltZy53aWR0aCwgaW1nLmhlaWdodF07XHJcbiAgICAgIG9sTGF5ZXIuY2hhbmdlZCgpO1xyXG4gICAgfTtcclxuICAgIGltZy5zcmMgPSBzcHJpdGVJbWFnZVVybDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGN0eCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpLmdldENvbnRleHQoJzJkJyk7XHJcbiAgY29uc3QgbWVhc3VyZUNhY2hlID0ge307XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBUZXh0KHRleHQsIGZvbnQsIGVtKSB7XHJcbiAgICBjb25zdCBrZXkgPSBlbSArICcsJyArIGZvbnQgKyAnLCcgKyB0ZXh0O1xyXG4gICAgbGV0IHdyYXBwZWRUZXh0ID0gbWVhc3VyZUNhY2hlW2tleV07XHJcbiAgICBpZiAoIXdyYXBwZWRUZXh0KSB7XHJcbiAgICAgIGN0eC5mb250ID0gZm9udDtcclxuICAgICAgY29uc3Qgb25lRW0gPSBjdHgubWVhc3VyZVRleHQoJ00nKS53aWR0aDtcclxuICAgICAgY29uc3Qgd2lkdGggPSBvbmVFbSAqIGVtO1xyXG4gICAgICBjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQoJyAnKTtcclxuICAgICAgbGV0IGxpbmUgPSAnJztcclxuICAgICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gd29yZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHdvcmQgPSB3b3Jkc1tpXTtcclxuICAgICAgICBpZiAoKGN0eC5tZWFzdXJlVGV4dChsaW5lICsgd29yZCkud2lkdGggPD0gd2lkdGgpKSB7XHJcbiAgICAgICAgICBsaW5lICs9IChsaW5lID8gJyAnIDogJycpICsgd29yZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKGxpbmUpIHtcclxuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxpbmUgPSB3b3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobGluZSkge1xyXG4gICAgICAgIGxpbmVzLnB1c2gobGluZSk7XHJcbiAgICAgIH1cclxuICAgICAgbWVhc3VyZUNhY2hlW2tleV0gPSB3cmFwcGVkVGV4dCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdyYXBwZWRUZXh0O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYWxsTGF5ZXJzID0gZGVyZWZMYXllcnMoZ2xTdHlsZS5sYXllcnMpO1xyXG5cclxuICBjb25zdCBsYXllcnNCeVNvdXJjZUxheWVyID0ge307XHJcbiAgY29uc3QgbWFwYm94TGF5ZXJzID0gW107XHJcbiAgbGV0IG1hcGJveFNvdXJjZTtcclxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhbGxMYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSBhbGxMYXllcnNbaV07XHJcbiAgICBjb25zdCBsYXllcklkID0gbGF5ZXIuaWQ7XHJcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PSAnc3RyaW5nJyAmJiBsYXllci5zb3VyY2UgPT0gc291cmNlIHx8XHJcbiAgICAgIHNvdXJjZS5pbmRleE9mKGxheWVySWQpICE9PSAtMSkge1xyXG4gICAgICBjb25zdCBzb3VyY2VMYXllciA9IGxheWVyWydzb3VyY2UtbGF5ZXInXTtcclxuICAgICAgaWYgKCFtYXBib3hTb3VyY2UpIHtcclxuICAgICAgICBtYXBib3hTb3VyY2UgPSBsYXllci5zb3VyY2U7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGxheWVycyA9IGxheWVyc0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJdO1xyXG4gICAgICBpZiAoIWxheWVycykge1xyXG4gICAgICAgIGxheWVycyA9IGxheWVyc0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJdID0gW107XHJcbiAgICAgIH1cclxuICAgICAgbGF5ZXJzLnB1c2goe1xyXG4gICAgICAgIGxheWVyOiBsYXllcixcclxuICAgICAgICBpbmRleDogaVxyXG4gICAgICB9KTtcclxuICAgICAgbWFwYm94TGF5ZXJzLnB1c2gobGF5ZXJJZCk7XHJcbiAgICB9XHJcbiAgICAvLyAvLyBUT0RPIHJldmlzaXQgd2hlbiBkaWZmaW5nIGdldHMgYWRkZWRcclxuICAgIGRlbGV0ZSBmdW5jdGlvbkNhY2hlW2xheWVySWRdO1xyXG4gICAgZGVsZXRlIGZpbHRlckNhY2hlW2xheWVySWRdO1xyXG4gIH1cclxuICBjb25zdCBpY29uSW1hZ2VDYWNoZSA9IHt9O1xyXG5cclxuICBjb25zdCBzdHlsZXMgPSBbXTtcclxuICBjb25zdCBwYXR0ZXJuQ2FjaGUgPSB7fTtcclxuXHJcbiAgY29uc3Qgc3R5bGVGdW5jdGlvbiA9IGZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcclxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBmZWF0dXJlLmdldFByb3BlcnRpZXMoKTtcclxuICAgIGZlYXR1cmUuc3R5bGVJZHMgPSBmZWF0dXJlLnN0eWxlSWRzIHx8IHt9O1xyXG4gICAgY29uc3QgbGF5ZXJzID0gbGF5ZXJzQnlTb3VyY2VMYXllcltwcm9wZXJ0aWVzLmxheWVyXTtcclxuICAgIGlmICghbGF5ZXJzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCB6b29tID0gcmVzb2x1dGlvbnMuaW5kZXhPZihyZXNvbHV0aW9uKTtcclxuICAgIGlmICh6b29tID09IC0xKSB7XHJcbiAgICAgIHpvb20gPSBNYXRoLnJvdW5kKGdldFpvb21Gb3JSZXNvbHV0aW9uKHJlc29sdXRpb24sIHJlc29sdXRpb25zKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0eXBlID0gdHlwZXNbZmVhdHVyZS5nZXRHZW9tZXRyeSgpLmdldFR5cGUoKV07XHJcbiAgICBjb25zdCBmID0ge1xyXG4gICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxyXG4gICAgICB0eXBlOiB0eXBlXHJcbiAgICB9O1xyXG4gICAgbGV0IHN0eWxlc0xlbmd0aCA9IC0xO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgY29uc3QgbGF5ZXJEYXRhID0gbGF5ZXJzW2ldO1xyXG4gICAgICBjb25zdCBsYXllciA9IGxheWVyRGF0YS5sYXllcjtcclxuICAgICAgY29uc3QgbGF5ZXJJZCA9IGxheWVyLmlkO1xyXG5cclxuICAgICAgY29uc3QgbGF5b3V0ID0gbGF5ZXIubGF5b3V0IHx8IGVtcHR5T2JqO1xyXG4gICAgICBjb25zdCBwYWludCA9IGxheWVyLnBhaW50IHx8IGVtcHR5T2JqO1xyXG4gICAgICBpZiAobGF5b3V0LnZpc2liaWxpdHkgPT09ICdub25lJyB8fCAoJ21pbnpvb20nIGluIGxheWVyICYmIHpvb20gPCBsYXllci5taW56b29tKSB8fFxyXG4gICAgICAgICgnbWF4em9vbScgaW4gbGF5ZXIgJiYgem9vbSA+PSBsYXllci5tYXh6b29tKSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0gPSBmZWF0dXJlLnN0eWxlSWRzW3pvb21dIHx8IFtdO1xyXG4gICAgICBjb25zdCBmaWx0ZXIgPSBsYXllci5maWx0ZXI7XHJcbiAgICAgIGxldCBpY29uLCBpY29uSW1nO1xyXG4gICAgICBpZiAoIWZpbHRlciB8fCBldmFsdWF0ZUZpbHRlcihsYXllcklkLCBmaWx0ZXIsIGYsIHpvb20pKSB7XHJcbiAgICAgICAgbGV0IGNvbG9yLCBvcGFjaXR5LCBmaWxsLCBzdHJva2UsIHN0cm9rZUNvbG9yLCBzdHlsZTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGxheWVyRGF0YS5pbmRleDtcclxuICAgICAgICBpZiAodHlwZSA9PSAzICYmIGxheWVyLnR5cGUgPT0gJ2ZpbGwnKSB7XHJcbiAgICAgICAgICBvcGFjaXR5ID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdmaWxsLW9wYWNpdHknLCB6b29tLCBmKTtcclxuICAgICAgICAgIGlmICgnZmlsbC1wYXR0ZXJuJyBpbiBwYWludCkge1xyXG4gICAgICAgICAgICBjb25zdCBpY29uSW1hZ2UgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ZpbGwtcGF0dGVybicsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICBpZiAoaWNvbkltYWdlKSB7XHJcbiAgICAgICAgICAgICAgaWNvbiA9IHR5cGVvZiBpY29uSW1hZ2UgPT09ICdzdHJpbmcnID8gZnJvbVRlbXBsYXRlKGljb25JbWFnZSwgcHJvcGVydGllcykgOiBpY29uSW1hZ2UudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICBpZiAoc3ByaXRlSW1hZ2UgJiYgc3ByaXRlRGF0YSAmJiBzcHJpdGVEYXRhW2ljb25dKSB7XHJcbiAgICAgICAgICAgICAgICArK3N0eWxlc0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0ucHVzaChsYXllcklkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlIHx8ICFzdHlsZS5nZXRGaWxsKCkgfHwgc3R5bGUuZ2V0U3Ryb2tlKCkgfHwgc3R5bGUuZ2V0VGV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF0gPSBuZXcgU3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG5ldyBGaWxsKClcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWxsID0gc3R5bGUuZ2V0RmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0WkluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25fY2FjaGVfa2V5ID0gaWNvbiArICcuJyArIG9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IHBhdHRlcm5DYWNoZVtpY29uX2NhY2hlX2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgc3ByaXRlSW1hZ2VEYXRhID0gc3ByaXRlRGF0YVtpY29uXTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHNwcml0ZUltYWdlRGF0YS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHNwcml0ZUltYWdlRGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS54LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS55LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4oY2FudmFzLCAncmVwZWF0Jyk7XHJcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm5DYWNoZVtpY29uX2NhY2hlX2tleV0gPSBwYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmlsbC5zZXRDb2xvcihwYXR0ZXJuKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoJ2ZpbGwtY29sb3InIGluIHBhaW50KSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gY29sb3JXaXRoT3BhY2l0eShnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ZpbGwtY29sb3InLCB6b29tLCBmKSwgb3BhY2l0eSk7XHJcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpIHx8IHN0eWxlLmdldFRleHQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgIGZpbGw6IG5ldyBGaWxsKClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBmaWxsID0gc3R5bGUuZ2V0RmlsbCgpO1xyXG4gICAgICAgICAgICAgIGZpbGwuc2V0Q29sb3IoY29sb3IpO1xyXG4gICAgICAgICAgICAgIHN0eWxlLnNldFpJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCdmaWxsLW91dGxpbmUtY29sb3InIGluIHBhaW50KSB7XHJcbiAgICAgICAgICAgICAgc3Ryb2tlQ29sb3IgPSBjb2xvcldpdGhPcGFjaXR5KGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnZmlsbC1vdXRsaW5lLWNvbG9yJywgem9vbSwgcHJvcGVydGllcyksIG9wYWNpdHkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdmaWxsLWFudGlhbGlhcycgaW4gcGFpbnQpIHtcclxuICAgICAgICAgICAgICBzdHJva2VDb2xvciA9IGNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdHJva2VDb2xvcikge1xyXG4gICAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0U3Ryb2tlKCkgfHwgc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFRleHQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSgpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgc3Ryb2tlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgc3Ryb2tlLnNldENvbG9yKHN0cm9rZUNvbG9yKTtcclxuICAgICAgICAgICAgICBzdHJva2Uuc2V0V2lkdGgoMSk7XHJcbiAgICAgICAgICAgICAgc3R5bGUuc2V0WkluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSAhPSAxICYmIGxheWVyLnR5cGUgPT0gJ2xpbmUnKSB7XHJcbiAgICAgICAgICBjb2xvciA9ICEoJ2xpbmUtcGF0dGVybicgaW4gcGFpbnQpICYmICdsaW5lLWNvbG9yJyBpbiBwYWludCA/XHJcbiAgICAgICAgICAgIGNvbG9yV2l0aE9wYWNpdHkoZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdsaW5lLWNvbG9yJywgem9vbSwgZiksIGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnbGluZS1vcGFjaXR5Jywgem9vbSwgZikpIDpcclxuICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2xpbmUtd2lkdGgnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGlmIChjb2xvciAmJiB3aWR0aCA+IDApIHtcclxuICAgICAgICAgICAgKytzdHlsZXNMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5wdXNoKGxheWVySWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLmdldFN0cm9rZSgpIHx8IHN0eWxlLmdldEZpbGwoKSB8fCBzdHlsZS5nZXRUZXh0KCkpIHtcclxuICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdID0gbmV3IFN0eWxlKHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSgpXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3Ryb2tlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIHN0cm9rZS5zZXRMaW5lQ2FwKGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ2xpbmUtY2FwJywgem9vbSwgZikpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0TGluZUpvaW4oZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnbGluZS1qb2luJywgem9vbSwgZikpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0TWl0ZXJMaW1pdChnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdsaW5lLW1pdGVyLWxpbWl0Jywgem9vbSwgZikpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0Q29sb3IoY29sb3IpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0V2lkdGgod2lkdGgpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0TGluZURhc2gocGFpbnRbJ2xpbmUtZGFzaGFycmF5J10gP1xyXG4gICAgICAgICAgICAgIGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnbGluZS1kYXNoYXJyYXknLCB6b29tLCBmKS5tYXAoZnVuY3Rpb24oeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggKiB3aWR0aDtcclxuICAgICAgICAgICAgICB9KSA6IG51bGwpO1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRaSW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGhhc0ltYWdlID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHRleHQgPSBudWxsO1xyXG4gICAgICAgIGxldCBza2lwTGFiZWw7XHJcbiAgICAgICAgaWYgKCh0eXBlID09IDEgfHwgdHlwZSA9PSAyKSAmJiAnaWNvbi1pbWFnZScgaW4gbGF5b3V0KSB7XHJcbiAgICAgICAgICBjb25zdCBpY29uSW1hZ2UgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdpY29uLWltYWdlJywgem9vbSwgZik7XHJcbiAgICAgICAgICBpZiAoaWNvbkltYWdlKSB7XHJcbiAgICAgICAgICAgIGljb24gPSB0eXBlb2YgaWNvbkltYWdlID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgID8gZnJvbVRlbXBsYXRlKGljb25JbWFnZSwgcHJvcGVydGllcylcclxuICAgICAgICAgICAgICA6IGljb25JbWFnZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBsZXQgc3R5bGVHZW9tID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoc3ByaXRlSW1hZ2UgJiYgc3ByaXRlRGF0YSAmJiBzcHJpdGVEYXRhW2ljb25dKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gMikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcclxuICAgICAgICAgICAgICAgIC8vIG9sIHBhY2thZ2UgYW5kIG9sLWRlYnVnLmpzIG9ubHlcclxuICAgICAgICAgICAgICAgIGlmIChnZW9tLmdldEZsYXRNaWRwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSBnZW9tLmdldEV4dGVudCgpO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5zcXJ0KE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KChleHRlbnRbMl0gLSBleHRlbnRbMF0pIC8gcmVzb2x1dGlvbiwgMiksXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyByZXNvbHV0aW9uLCAyKSkpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDE1MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRklYTUUgRG8gbm90IGhhcmQtY29kZSBhIHNpemUgb2YgMTUwXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVHZW9tID0gbmV3IFBvaW50KGdlb20uZ2V0RmxhdE1pZHBvaW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICh0eXBlICE9PSAyIHx8IHN0eWxlR2VvbSkge1xyXG4gICAgICAgICAgICAgICAgKytzdHlsZXNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5pbmRleE9mKGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0SW1hZ2UoKSB8fCBzdHlsZS5nZXRGaWxsKCkgfHwgc3R5bGUuZ2V0U3Ryb2tlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0R2VvbWV0cnkoc3R5bGVHZW9tKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25TaXplID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnaWNvbi1zaXplJywgem9vbSwgZik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uQ29sb3IgPSBwYWludFsnaWNvbi1jb2xvciddICE9PSB1bmRlZmluZWQgPyBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ljb24tY29sb3InLCB6b29tLCBmKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uVHJhbnNsYXRlID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdpY29uLXRyYW5zbGF0ZScsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvblRyYW5zbGF0ZUFuY2hvciA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnaWNvbi10cmFuc2xhdGUtYW5jaG9yJywgem9vbSwgZik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uQW5jaG9yVmFsdWUgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdpY29uLWFuY2hvcicsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbk9mZnNldCA9IGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ2ljb24tb2Zmc2V0Jywgem9vbSwgZik7XHJcbiAgICAgICAgICAgICAgICBsZXQge1xyXG4gICAgICAgICAgICAgICAgICBhbmNob3JPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgIGljb25BbmNob3IgPSBpY29uQW5jaG9yVmFsdWVcclxuICAgICAgICAgICAgICAgIH0gPSBjb3ZlcnRJY29uQW5jaG9yKGljb25BbmNob3JWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaWNvbl9jYWNoZV9rZXkgPSBpY29uICsgJy4nICsgaWNvblNpemUgKyAnLicgKyBpY29uVHJhbnNsYXRlICsgJy4nICsgaWNvblRyYW5zbGF0ZUFuY2hvciArICcuJyArIGljb25BbmNob3IgKyAnLicgKyBpY29uT2Zmc2V0ICsgJy4nICsgYW5jaG9yT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGljb25Db2xvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICBpY29uX2NhY2hlX2tleSArPSAnLicgKyBpY29uQ29sb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpY29uSW1nID0gaWNvbkltYWdlQ2FjaGVbaWNvbl9jYWNoZV9rZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpY29uSW1nKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNwcml0ZUltYWdlRGF0YSA9IHNwcml0ZURhdGFbaWNvbl07XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBzcHJpdGVJbWFnZURhdGEud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzcHJpdGVJbWFnZURhdGEuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZSxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEueCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEueSxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGljb25Db2xvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1dCBvdXQgdGhlIHNwcml0ZSBhbmQgY29sb3IgaXRcclxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yV2l0aE9wYWNpdHkoaWNvbkNvbG9yLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gMCwgY2MgPSBkYXRhLmRhdGEubGVuZ3RoOyBjIDwgY2M7IGMgKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhW2NdID0gY29sb3JbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGFbYyArIDFdID0gY29sb3JbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGFbYyArIDJdID0gY29sb3JbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZU9mZnNldCA9IFtpY29uVHJhbnNsYXRlWzBdIC8gc3ByaXRlSW1hZ2VEYXRhLndpZHRoLCBpY29uVHJhbnNsYXRlWzFdIC8gc3ByaXRlSW1hZ2VEYXRhLmhlaWdodF07XHJcbiAgICAgICAgICAgICAgICAgIGljb25JbWcgPSBpY29uSW1hZ2VDYWNoZVtpY29uX2NhY2hlX2tleV0gPSBuZXcgSWNvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nOiBjYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yT3JpZ2luOiBpY29uQW5jaG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcjogW2ljb25PZmZzZXRbMF0gKyBhbmNob3JPZmZzZXRbMF0gKyB0cmFuc2xhdGVPZmZzZXRbMF0sIGljb25PZmZzZXRbMV0gKyBhbmNob3JPZmZzZXRbMV0gLSB0cmFuc2xhdGVPZmZzZXRbMV1dLFxyXG4gICAgICAgICAgICAgICAgICAgIGltZ1NpemU6IFtjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBpY29uU2l6ZSAvIHNwcml0ZUltYWdlRGF0YS5waXhlbFJhdGlvXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJvdGF0ZVZhbHVlID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnaWNvbi1yb3RhdGUnLCB6b29tLCBmKTtcclxuICAgICAgICAgICAgICAgIGlmIChyb3RhdGVWYWx1ZS5pbmRleE9mICYmIHJvdGF0ZVZhbHVlLmluZGV4T2YoJ3snKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICByb3RhdGVWYWx1ZSA9IDM2MCAtIGZyb21UZW1wbGF0ZShyb3RhdGVWYWx1ZSwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpY29uSW1nLnNldFJvdGF0aW9uKGRlZzJyYWQocm90YXRlVmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIGljb25JbWcuc2V0T3BhY2l0eShnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ljb24tb3BhY2l0eScsIHpvb20sIGYpKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldEltYWdlKGljb25JbWcpO1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHN0eWxlLmdldFRleHQoKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFRleHQodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFpJbmRleCg5OTk5OSAtIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGhhc0ltYWdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHNraXBMYWJlbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBza2lwTGFiZWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gMSAmJiAnY2lyY2xlLXJhZGl1cycgaW4gcGFpbnQpIHtcclxuICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgaWYgKGZlYXR1cmUuc3R5bGVJZHNbem9vbV0uaW5kZXhPZihsYXllcklkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5wdXNoKGxheWVySWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXTtcclxuICAgICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLmdldEltYWdlKCkgfHwgc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpKSB7XHJcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF0gPSBuZXcgU3R5bGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IGNpcmNsZVJhZGl1cyA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnY2lyY2xlLXJhZGl1cycsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgY2lyY2xlU3Ryb2tlQ29sb3IgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2NpcmNsZS1zdHJva2UtY29sb3InLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IGNpcmNsZUNvbG9yID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdjaXJjbGUtY29sb3InLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IGNpcmNsZU9wYWNpdHkgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2NpcmNsZS1vcGFjaXR5Jywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCBjaXJjbGVTdHJva2VXaWR0aCA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnY2lyY2xlLXN0cm9rZS13aWR0aCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgY2lyY2xlU3Ryb2tlT3BhY2l0eSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnY2lyY2xlLXN0cm9rZS1vcGFjaXR5Jywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCBjYWNoZV9rZXkgPSBjaXJjbGVSYWRpdXMgKyAnLicgKyBjaXJjbGVTdHJva2VDb2xvciArICcuJyArXHJcbiAgICAgICAgICAgIGNpcmNsZUNvbG9yICsgJy4nICsgY2lyY2xlT3BhY2l0eSArICcuJyArIGNpcmNsZVN0cm9rZVdpZHRoICsgJy4nICsgY2lyY2xlU3Ryb2tlT3BhY2l0eTtcclxuICAgICAgICAgIGljb25JbWcgPSBpY29uSW1hZ2VDYWNoZVtjYWNoZV9rZXldO1xyXG4gICAgICAgICAgaWYgKCFpY29uSW1nKSB7XHJcbiAgICAgICAgICAgIGljb25JbWcgPSBuZXcgQ2lyY2xlKHtcclxuICAgICAgICAgICAgICByYWRpdXM6IGNpcmNsZVJhZGl1cyxcclxuICAgICAgICAgICAgICBzdHJva2U6IGNpcmNsZVN0cm9rZVdpZHRoID09PSAwID8gdW5kZWZpbmVkIDogbmV3IFN0cm9rZSh7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogY2lyY2xlU3Ryb2tlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JXaXRoT3BhY2l0eShjaXJjbGVTdHJva2VDb2xvciwgY2lyY2xlU3Ryb2tlT3BhY2l0eSlcclxuICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JXaXRoT3BhY2l0eShjaXJjbGVDb2xvciwgY2lyY2xlT3BhY2l0eSlcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0eWxlLnNldEltYWdlKGljb25JbWcpO1xyXG4gICAgICAgICAgdGV4dCA9IHN0eWxlLmdldFRleHQoKTtcclxuICAgICAgICAgIHN0eWxlLnNldFRleHQodW5kZWZpbmVkKTtcclxuICAgICAgICAgIHN0eWxlLnNldEdlb21ldHJ5KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICBzdHlsZS5zZXRaSW5kZXgoOTk5OTkgLSBpbmRleCk7XHJcbiAgICAgICAgICBoYXNJbWFnZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGFiZWw7XHJcbiAgICAgICAgaWYgKCd0ZXh0LWZpZWxkJyBpbiBsYXlvdXQpIHtcclxuICAgICAgICAgIGNvbnN0IHRleHRGaWVsZCA9IGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3RleHQtZmllbGQnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGxhYmVsID0gZnJvbVRlbXBsYXRlKHRleHRGaWVsZCwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYWJlbCAmJiAhc2tpcExhYmVsKSB7XHJcbiAgICAgICAgICBpZiAoIWhhc0ltYWdlKSB7XHJcbiAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5pbmRleE9mKGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0ucHVzaChsYXllcklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdO1xyXG4gICAgICAgICAgICBpZiAoIXN0eWxlIHx8ICFzdHlsZS5nZXRUZXh0KCkgfHwgc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpKSB7XHJcbiAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlLnNldEltYWdlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHN0eWxlLnNldEdlb21ldHJ5KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIXN0eWxlLmdldFRleHQoKSkge1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRUZXh0KHRleHQgfHwgbmV3IFRleHQoKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0ZXh0ID0gc3R5bGUuZ2V0VGV4dCgpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dFNpemUgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LXNpemUnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRMaW5lSGVpZ2h0ID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAndGV4dC1saW5lLWhlaWdodCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgZm9udCA9IG1iMmNzcyhjaG9vc2VGb250KGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3RleHQtZm9udCcsIHpvb20sIGYpKSwgdGV4dFNpemUpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dFRyYW5zZm9ybSA9IGxheW91dFsndGV4dC10cmFuc2Zvcm0nXTtcclxuICAgICAgICAgIGlmICh0ZXh0VHJhbnNmb3JtID09ICd1cHBlcmNhc2UnKSB7XHJcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWwudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xyXG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCB3cmFwcGVkTGFiZWwgPSB0eXBlID09IDIgPyBsYWJlbCA6IHdyYXBUZXh0KGxhYmVsLCBmb250LCBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LW1heC13aWR0aCcsIHpvb20sIGYpKTtcclxuICAgICAgICAgIHRleHQuc2V0VGV4dCh3cmFwcGVkTGFiZWwpO1xyXG4gICAgICAgICAgdGV4dC5zZXRGb250KGZvbnQpO1xyXG4gICAgICAgICAgdGV4dC5zZXRSb3RhdGlvbihkZWcycmFkKGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3RleHQtcm90YXRlJywgem9vbSwgZikpKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRBbmNob3IgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LWFuY2hvcicsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKGhhc0ltYWdlIHx8IHR5cGUgPT0gMSkgPyAncG9pbnQnIDogZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnc3ltYm9sLXBsYWNlbWVudCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgdGV4dC5zZXRQbGFjZW1lbnQocGxhY2VtZW50KTtcclxuICAgICAgICAgIGxldCB0ZXh0SGFsb1dpZHRoID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICd0ZXh0LWhhbG8td2lkdGgnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRPZmZzZXQgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LW9mZnNldCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dFRyYW5zbGF0ZSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC10cmFuc2xhdGUnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGxldCB2T2Zmc2V0ID0gMDtcclxuICAgICAgICAgIGxldCBoT2Zmc2V0ID0gMDtcclxuICAgICAgICAgIGxldCB0ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgIGlmICh0ZXh0QW5jaG9yLmluZGV4T2YoJ2xlZnQnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgICAgICAgICBoT2Zmc2V0ID0gdGV4dEhhbG9XaWR0aDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFuY2hvci5pbmRleE9mKCdyaWdodCcpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xyXG4gICAgICAgICAgICBoT2Zmc2V0ID0gLXRleHRIYWxvV2lkdGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocGxhY2VtZW50ID09ICdwb2ludCcpIHtcclxuICAgICAgICAgICAgdGV4dC5zZXRUZXh0QWxpZ24odGV4dEFsaWduKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHQuc2V0TWF4QW5nbGUoZGVnMnJhZChnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LW1heC1hbmdsZScsIHpvb20sIGYpKSAqIGxhYmVsLmxlbmd0aCAvIHdyYXBwZWRMYWJlbC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB0ZXh0LnNldFRleHRBbGlnbigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgaWYgKHRleHRBbmNob3IuaW5kZXhPZignYm90dG9tJykgPT0gMCkge1xyXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcclxuICAgICAgICAgICAgdk9mZnNldCA9IC10ZXh0SGFsb1dpZHRoIC0gKDAuNSAqICh0ZXh0TGluZUhlaWdodCAtIDEpKSAqIHRleHRTaXplO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0ZXh0QW5jaG9yLmluZGV4T2YoJ3RvcCcpID09IDApIHtcclxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XHJcbiAgICAgICAgICAgIHZPZmZzZXQgPSB0ZXh0SGFsb1dpZHRoICsgKDAuNSAqICh0ZXh0TGluZUhlaWdodCAtIDEpKSAqIHRleHRTaXplO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGV4dC5zZXRUZXh0QmFzZWxpbmUodGV4dEJhc2VsaW5lKTtcclxuICAgICAgICAgIHRleHQuc2V0T2Zmc2V0WCh0ZXh0T2Zmc2V0WzBdICogdGV4dFNpemUgKyBoT2Zmc2V0ICsgdGV4dFRyYW5zbGF0ZVswXSk7XHJcbiAgICAgICAgICB0ZXh0LnNldE9mZnNldFkodGV4dE9mZnNldFsxXSAqIHRleHRTaXplICsgdk9mZnNldCArIHRleHRUcmFuc2xhdGVbMV0pO1xyXG4gICAgICAgICAgb3BhY2l0eSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC1vcGFjaXR5Jywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0Q29sb3IgPSBuZXcgRmlsbCgpO1xyXG5cclxuICAgICAgICAgIHRleHRDb2xvci5zZXRDb2xvcihjb2xvcldpdGhPcGFjaXR5KGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC1jb2xvcicsIHpvb20sIGYpLCBvcGFjaXR5KSk7XHJcbiAgICAgICAgICB0ZXh0LnNldEZpbGwodGV4dENvbG9yKTtcclxuICAgICAgICAgIGNvbnN0IGhhbG9Db2xvciA9IGNvbG9yV2l0aE9wYWNpdHkoZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICd0ZXh0LWhhbG8tY29sb3InLCB6b29tLCBmKSwgb3BhY2l0eSk7XHJcbiAgICAgICAgICBpZiAoaGFsb0NvbG9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRIYWxvID0gbmV3IFN0cm9rZSgpO1xyXG4gICAgICAgICAgICB0ZXh0SGFsby5zZXRDb2xvcihoYWxvQ29sb3IpO1xyXG4gICAgICAgICAgICB0ZXh0SGFsby5zZXRXaWR0aChnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ3RleHQtaGFsby13aWR0aCcsIHpvb20sIGYpKTtcclxuICAgICAgICAgICAgdGV4dC5zZXRTdHJva2UodGV4dEhhbG8pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dC5zZXRTdHJva2UodW5kZWZpbmVkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0eWxlLnNldFpJbmRleCg5OTk5OSAtIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3R5bGVzTGVuZ3RoID4gLTEpIHtcclxuICAgICAgc3R5bGVzLmxlbmd0aCA9IHN0eWxlc0xlbmd0aCArIDE7XHJcbiAgICAgIHJldHVybiBzdHlsZXM7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgb2xMYXllci5zZXRTdHlsZShzdHlsZUZ1bmN0aW9uKTtcclxuICBvbExheWVyLnNldCgnbWFwYm94LXNvdXJjZScsIG1hcGJveFNvdXJjZSk7XHJcbiAgb2xMYXllci5zZXQoJ21hcGJveC1sYXllcnMnLCBtYXBib3hMYXllcnMpO1xyXG4gIHJldHVybiBzdHlsZUZ1bmN0aW9uO1xyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiBkZWcycmFkKGRlZ3JlZXMpIHtcclxuICByZXR1cm4gZGVncmVlcyAqIE1hdGguUEkgLyAxODA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRab29tRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uLCByZXNvbHV0aW9ucykge1xyXG4gIGxldCBpID0gMDtcclxuICBjb25zdCBpaSA9IHJlc29sdXRpb25zLmxlbmd0aDtcclxuICBmb3IgKDsgaSA8IGlpOyArK2kpIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHJlc29sdXRpb25zW2ldO1xyXG4gICAgaWYgKGNhbmRpZGF0ZSA8IHJlc29sdXRpb24gJiYgaSArIDEgPCBpaSkge1xyXG4gICAgICBjb25zdCB6b29tRmFjdG9yID0gcmVzb2x1dGlvbnNbaV0gLyByZXNvbHV0aW9uc1tpICsgMV07XHJcbiAgICAgIHJldHVybiBpICsgTWF0aC5sb2cocmVzb2x1dGlvbnNbaV0gLyByZXNvbHV0aW9uKSAvIE1hdGgubG9nKHpvb21GYWN0b3IpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gaWkgLSAxO1xyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gb2wuTWFwOyIsIm1vZHVsZS5leHBvcnRzID0gb2wuT2JzZXJ2YWJsZTsiLCJtb2R1bGUuZXhwb3J0cyA9IG9sLmZvcm1hdC5HZW9KU09OOyIsIm1vZHVsZS5leHBvcnRzID0gb2wuZm9ybWF0Lk1WVDsiLCJtb2R1bGUuZXhwb3J0cyA9IG9sLmdlb20uUG9pbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5sYXllci5UaWxlOyIsIm1vZHVsZS5leHBvcnRzID0gb2wubGF5ZXIuVmVjdG9yOyIsIm1vZHVsZS5leHBvcnRzID0gb2wubGF5ZXIuVmVjdG9yVGlsZTsiLCJtb2R1bGUuZXhwb3J0cyA9IG9sLnByb2o7IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5zb3VyY2UuVGlsZUpTT047IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5zb3VyY2UuVmVjdG9yOyIsIm1vZHVsZS5leHBvcnRzID0gb2wuc291cmNlLlZlY3RvclRpbGU7IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5zb3VyY2UuWFlaOyIsIm1vZHVsZS5leHBvcnRzID0gb2wuc3R5bGUuQ2lyY2xlOyIsIm1vZHVsZS5leHBvcnRzID0gb2wuc3R5bGUuRmlsbDsiLCJtb2R1bGUuZXhwb3J0cyA9IG9sLnN0eWxlLkljb247IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5zdHlsZS5TdHJva2U7IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5zdHlsZS5TdHlsZTsiLCJtb2R1bGUuZXhwb3J0cyA9IG9sLnN0eWxlLlRleHQ7IiwibW9kdWxlLmV4cG9ydHMgPSBvbC50aWxlZ3JpZDsiXSwic291cmNlUm9vdCI6IiJ9