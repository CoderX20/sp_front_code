/*!
 * 
 *     ol-mapbox-style
 *     Copyright 2016-present Boundless Spatial
 *     CopyrightÂ© 2000-2018 SuperMap Software Co. Ltd
 *     github: https://github.com/boundlessgeo/ol-mapbox-style
 *     github: https://github.com/SuperMap/ol-mapbox-style
 *     license: BSD 2-Clause "Simplified" License
 *     version: v2.11.2-1
 * 
 */
olms =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./olms.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                                              ol-mapbox-style - Use Mapbox Style objects with OpenLayers
                                                                                                                                                                                                                                                                              Copyright 2016-present Boundless Spatial, Inc.
                                                                                                                                                                                                                                                                              License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE
                                                                                                                                                                                                                                                                              */

exports.applyStyle = applyStyle;
exports.applyBackground = applyBackground;
exports.apply = apply;
exports.getLayer = getLayer;
exports.getSource = getSource;

var _mapboxGlStyleSpec = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec */ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js");

var _mapboxToCssFont = __webpack_require__(/*! mapbox-to-css-font */ "./node_modules/mapbox-to-css-font/index.js");

var _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);

var _stylefunction = __webpack_require__(/*! ./stylefunction */ "./stylefunction.js");

var _stylefunction2 = _interopRequireDefault(_stylefunction);

var _google = __webpack_require__(/*! webfont-matcher/lib/fonts/google */ "./node_modules/webfont-matcher/lib/fonts/google.js");

var _google2 = _interopRequireDefault(_google);

var _proj = __webpack_require__(/*! ol/proj */ "ol/proj");

var _tilegrid = __webpack_require__(/*! ol/tilegrid */ "ol/tilegrid");

var _Map = __webpack_require__(/*! ol/Map */ "ol/Map");

var _Map2 = _interopRequireDefault(_Map);

var _GeoJSON = __webpack_require__(/*! ol/format/GeoJSON */ "ol/format/GeoJSON");

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

var _MVT = __webpack_require__(/*! ol/format/MVT */ "ol/format/MVT");

var _MVT2 = _interopRequireDefault(_MVT);

var _Observable = __webpack_require__(/*! ol/Observable */ "ol/Observable");

var _Tile = __webpack_require__(/*! ol/layer/Tile */ "ol/layer/Tile");

var _Tile2 = _interopRequireDefault(_Tile);

var _Vector = __webpack_require__(/*! ol/layer/Vector */ "ol/layer/Vector");

var _Vector2 = _interopRequireDefault(_Vector);

var _VectorTile = __webpack_require__(/*! ol/layer/VectorTile */ "ol/layer/VectorTile");

var _VectorTile2 = _interopRequireDefault(_VectorTile);

var _TileJSON = __webpack_require__(/*! ol/source/TileJSON */ "ol/source/TileJSON");

var _TileJSON2 = _interopRequireDefault(_TileJSON);

var _Vector3 = __webpack_require__(/*! ol/source/Vector */ "ol/source/Vector");

var _Vector4 = _interopRequireDefault(_Vector3);

var _VectorTile3 = __webpack_require__(/*! ol/source/VectorTile */ "ol/source/VectorTile");

var _VectorTile4 = _interopRequireDefault(_VectorTile3);

var _XYZ = __webpack_require__(/*! ol/source/XYZ */ "ol/source/XYZ");

var _XYZ2 = _interopRequireDefault(_XYZ);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var availableFonts;

function loadFont(fonts) {
  var i, ii;
  if (!Array.isArray(fonts)) {
    var stops = fonts.stops;
    if (stops) {
      for (i = 0, ii = stops.length; i < ii; ++i) {
        loadFont(stops[i][1]);
      }
    }
    return;
  }
  var googleFamilies = _google2.default.getNames();
  var families = fonts.map(function (font) {
    return (0, _mapboxToCssFont2.default)(font, 1).split(' 1px ')[1].replace(/"/g, '');
  });
  for (i = 0, ii = families.length; i < ii; ++i) {
    var family = families[i];
    var font = fonts[i];
    if (googleFamilies.indexOf(family) !== -1) {
      if (!availableFonts) {
        availableFonts = [];
      }
      if (availableFonts.indexOf(font) == -1) {
        availableFonts.push(font);
        var fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+');
        if (!document.querySelector('link[href="' + fontUrl + '"]')) {
          var markup = document.createElement('link');
          markup.href = fontUrl;
          markup.rel = 'stylesheet';
          document.getElementsByTagName('head')[0].appendChild(markup);
        }
      }
      break;
    }
  }
}

var defaultFont = ['Open Sans Regular', 'Arial Regular'];

function preprocess(layer) {
  if ('layout' in layer && 'text-field' in layer.layout) {
    loadFont(layer.layout['text-font'] || defaultFont);
  }
}

var spriteRegEx = /^(.*)(\?.*)$/;

function withPath(url, path) {
  if (path && url.indexOf('http') != 0) {
    url = path + url;
  }
  return url;
}

function toSpriteUrl(url, path, extension) {
  url = withPath(url, path);
  var parts = url.match(spriteRegEx);
  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;
}

/**
 * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`
 * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function
 * will render all layers from the `glStyle` object that use the specified
 * `source`, or a subset of layers from the same source. The source needs to be
 * a `"type": "vector"`, `"type": "geojson"` or `"type": "raster"` source.
 *
 * @param {ol.layer.VectorTile} layer OpenLayers layer.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string} source `source` key or an array of layer `id`s from the
 * Mapbox Style object. When a `source` key is provided, all layers for the
 * specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {string} [path=undefined] Path of the style file. Only required when
 * a relative path is used with the `"sprite"` property of the style.
 * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.
 * @return {Promise} Promise which will be resolved when the style can be used
 * for rendering.
 */
function applyStyle(layer, glStyle, source, path, resolutions) {
  return new Promise(function (resolve, reject) {

    if ((typeof glStyle === 'undefined' ? 'undefined' : _typeof(glStyle)) != 'object') {
      glStyle = JSON.parse(glStyle);
    }
    if (glStyle.version != 8) {
      reject(new Error('glStyle version 8 required.'));
    }
    var spriteScale, spriteData, spriteImageUrl;
    if (glStyle.sprite) {
      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;
      var sizeFactor = spriteScale == 0.5 ? '@2x' : '';
      var spriteUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.json');

      fetch(spriteUrl, { credentials: 'same-origin' }).then(function (response) {
        // if the response is ready return the JSON promise
        if (response.status === 200) {
          return response.json();
        } else if (sizeFactor !== '') {
          // return the JSON promise for the low-resolution sprites.
          sizeFactor = '';
          spriteUrl = toSpriteUrl(glStyle.sprite, path, '.json');
          return fetch(spriteUrl, { credentials: 'same-origin' }).then(function (r) {
            return r.json();
          });
        }
      }).then(function (spritesJson) {
        if (spritesJson === undefined) {
          throw 'No sprites found.';
        }
        spriteData = spritesJson;
        spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.png');
        onChange();
      }).catch(function (err) {
        console.error(err);
        reject(new Error('Sprites cannot be loaded from ' + spriteUrl));
      });
    }

    var style;
    function onChange() {
      if (!style && (!glStyle.sprite || spriteData) && (!availableFonts || availableFonts.length > 0)) {
        style = (0, _stylefunction2.default)(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, availableFonts);
        resolve();
      } else if (style) {
        layer.setStyle(style);
      }
    }

    if (layer instanceof _VectorTile2.default || layer instanceof _Vector2.default) {
      try {
        var layers = glStyle.layers;
        for (var i = 0, ii = layers.length; i < ii; ++i) {
          if (typeof source == 'string' && layers[i].source == source || source.indexOf(layers[i].id) >= 0) {
            preprocess(layers[i]);
          }
        }
        onChange();
      } catch (e) {
        setTimeout(function () {
          reject(e);
        }, 0);
      }
    }
  });
}

function setBackground(map, layer) {
  var background = {
    type: layer.type
  };
  function updateStyle() {
    var element = map.getTargetElement();
    if (!element) {
      return;
    }
    var layout = layer.layout || {};
    var paint = layer.paint || {};
    background['paint'] = paint;
    background.id = 'olms-bg-' + paint['background-opacity'] + paint['background-color'];
    var zoom = map.getView().getZoom();
    if (paint['background-color'] !== undefined) {
      var bg = (0, _stylefunction.getValue)(background, 'paint', 'background-color', zoom, {});
      element.style.background = _mapboxGlStyleSpec.Color.parse(bg).toString();
    }
    if (paint['background-opacity'] !== undefined) {
      element.style.opacity = (0, _stylefunction.getValue)(background, 'paint', 'background-opacity', zoom, {});
    }
    if (layout.visibility == 'none') {
      element.style.backgroundColor = '';
      element.style.opacity = '';
    }
  }
  if (map.getTargetElement()) {
    updateStyle();
  }
  map.on(['change:resolution', 'change:target'], updateStyle);
}

/**
 * Applies properties of the Mapbox Style's first `background` layer to the map.
 * @param {ol.Map} map OpenLayers Map.
 * @param {Object} glStyle Mapbox Style object.
 */
function applyBackground(map, glStyle) {
  glStyle.layers.some(function (l) {
    if (l.type == 'background') {
      setBackground(map, l);
      return true;
    }
  });
}

function getSourceIdByRef(layers, ref) {
  var sourceId;
  layers.some(function (layer) {
    if (layer.id == ref) {
      sourceId = layer.source;
      return true;
    }
  });
  return sourceId;
}

function processStyle(glStyle, map, baseUrl, host, path, accessToken) {
  var view = map.getView();
  if ('center' in glStyle && !view.getCenter()) {
    view.setCenter((0, _proj.fromLonLat)(glStyle.center));
  }
  if ('zoom' in glStyle && view.getZoom() === undefined) {
    view.setZoom(glStyle.zoom);
  }
  if (!view.getCenter() || view.getZoom() === undefined) {
    view.fit(view.getProjection().getExtent(), {
      nearest: true,
      size: map.getSize()
    });
  }
  if (glStyle.sprite) {
    if (glStyle.sprite.indexOf('mapbox://') == 0) {
      glStyle.sprite = baseUrl + '/sprite' + accessToken;
    } else if (glStyle.sprite.indexOf('http') != 0) {
      glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;
    }
  }

  var glLayers = glStyle.layers;
  var geoJsonFormat = new _GeoJSON2.default();
  var layerIds = [];

  function finalizeLayer(layer) {
    if (layerIds.length > 0) {
      map.addLayer(layer);
      var setStyle = function setStyle() {
        applyStyle(layer, glStyle, layerIds, path).then(function () {
          layer.setVisible(true);
        }, function (e) {
          /*eslint no-console: ["error", { allow: ["error"] }] */
          console.error(e);
        });
      };
      if (layer.getSource()) {
        setStyle();
      } else {
        layer.once('change:source', setStyle);
      }
    }
  }

  var glLayer, glSource, glSourceId, id, layer, mapid, url;
  for (var i = 0, ii = glLayers.length; i < ii; ++i) {
    glLayer = glLayers[i];
    if (glLayer.type == 'background') {
      setBackground(map, glLayer);
    } else {
      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);
      if (id != glSourceId) {
        finalizeLayer(layer);
        layerIds = [];
        glSource = glStyle.sources[id];
        url = glSource.url;
        var tiles = glSource.tiles;
        if (url) {
          if (url.indexOf('mapbox://') == 0) {
            mapid = url.replace('mapbox://', '');
            tiles = ['a', 'b', 'c', 'd'].map(function (host) {
              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;
            });
          }
        }

        if (glSource.type == 'vector') {
          layer = tiles ? function () {
            var tileGrid = (0, _tilegrid.createXYZ)({
              tileSize: 512,
              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,
              minZoom: glSource.minzoom
            });
            return new _VectorTile2.default({
              declutter: true,
              maxResolution: tileGrid.getMinZoom() > 0 ? tileGrid.getResolution(tileGrid.getMinZoom()) : undefined,
              source: new _VectorTile4.default({
                attributions: glSource.attribution,
                format: new _MVT2.default(),
                tileGrid: tileGrid,
                urls: tiles
              }),
              visible: false,
              zIndex: i
            });
          }() : function () {
            var layer = new _VectorTile2.default({
              declutter: true,
              visible: false,
              zIndex: i
            });
            var tilejson = new _TileJSON2.default({
              url: url
            });
            var key = tilejson.on('change', function () {
              if (tilejson.getState() == 'ready') {
                var tileJSONDoc = tilejson.getTileJSON();
                var tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];
                for (var i = 0, ii = tiles.length; i < ii; ++i) {
                  var tile = tiles[i];
                  if (tile.indexOf('http') != 0) {
                    tiles[i] = glSource.url + tile;
                  }
                }
                var tileGrid = tilejson.getTileGrid();
                layer.setSource(new _VectorTile4.default({
                  attributions: tilejson.getAttributions() || tileJSONDoc.attribution,
                  format: new _MVT2.default(),
                  tileGrid: (0, _tilegrid.createXYZ)({
                    minZoom: tileGrid.getMinZoom(),
                    maxZoom: tileGrid.getMaxZoom(),
                    tileSize: 512
                  }),
                  urls: tiles
                }));
                if (tileGrid.getMinZoom() > 0) {
                  layer.setMaxResolution(tileGrid.getResolution(tileGrid.getMinZoom()));
                }
                (0, _Observable.unByKey)(key);
              }
            });
            return layer;
          }();
        } else if (glSource.type == 'raster') {
          var source;
          if (!glSource.tiles) {
            source = function () {
              return new _TileJSON2.default({
                url: url,
                crossOrigin: 'anonymous'
              });
            }();
          } else {
            source = new _XYZ2.default({
              attributions: glSource.attribution,
              minZoom: glSource.minzoom,
              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,
              tileSize: glSource.tileSize || 512,
              url: url,
              urls: glSource.tiles,
              crossOrigin: 'anonymous'
            });
          }
          source.setTileLoadFunction(function (tile, src) {
            if (src.indexOf('{bbox-epsg-3857}') != -1) {
              var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());
              src = src.replace('{bbox-epsg-3857}', bbox.toString());
            }
            tile.getImage().src = src;
          });
          layer = new _Tile2.default({
            source: source,
            visible: glLayer.layout ? glLayer.layout.visibility !== 'none' : true
          });
        } else if (glSource.type == 'geojson') {
          var data = glSource.data;
          var features, geoJsonUrl;
          if (typeof data == 'string') {
            geoJsonUrl = withPath(data, path);
          } else {
            features = geoJsonFormat.readFeatures(data, { featureProjection: 'EPSG:3857' });
          }
          layer = new _Vector2.default({
            source: new _Vector4.default({
              attributions: glSource.attribution,
              features: features,
              format: geoJsonFormat,
              url: geoJsonUrl
            }),
            visible: false,
            zIndex: i
          });
        }
        glSourceId = id;
      }
      layerIds.push(glLayer.id);
    }
  }
  finalizeLayer(layer);
  map.set('mapbox-style', glStyle);
}

/**
 * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes
 * the map background, the layers, the center and the zoom.
 *
 * The center and zoom will only be set if present in the Mapbox Style document,
 * and if not already set on the OpenLayers map.
 *
 * Layers will be added to the OpenLayers map, without affecting any layers that
 * might already be set on the map.
 *
 * Layers added by `apply()` will have two additional properties:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * The map returned by this function will have an additional `mapbox-style`
 * property which holds the Mapbox Style object.
 *
 * @param {ol.Map|HTMLElement|string} map Either an existing OpenLayers Map
 * instance, or a HTML element, or the id of a HTML element that will be the
 * target of a new OpenLayers Map.
 * @param {string|Object} style JSON style object or style url pointing to a
 * Mapbox Style object. When using Mapbox APIs, the url must contain an access
 * token and look like
 * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.
 * When passed as JSON style object, all OpenLayers layers created by `apply()`
 * will be immediately available, but they may not have a source yet (i.e. when
 * they are defined by a TileJSON url in the Mapbox Style document). When passed
 * as style url, layers will be added to the map when the Mapbox Style document
 * is loaded and parsed.
 * @return {ol.Map} The OpenLayers Map instance that will be populated with the
 * contents described in the Mapbox Style object.
 */
function apply(map, style) {

  var accessToken, baseUrl, host, path;
  accessToken = baseUrl = host = path = '';

  if (!(map instanceof _Map2.default)) {
    map = new _Map2.default({
      target: map
    });
  }

  if (typeof style === 'string') {
    var parts = style.match(spriteRegEx);
    if (parts) {
      baseUrl = parts[1];
      accessToken = parts.length > 2 ? parts[2] : '';
    }

    fetch(style, {
      credentials: 'same-origin'
    }).then(function (response) {
      return response.json();
    }).then(function (glStyle) {
      var a = document.createElement('A');
      a.href = style;
      path = a.pathname.split('/').slice(0, -1).join('/') + '/';
      host = style.substr(0, style.indexOf(path));

      processStyle(glStyle, map, baseUrl, host, path, accessToken);
    }).catch(function (err) {
      console.error(err);
      throw new Error('Could not load ' + style);
    });
  } else {
    setTimeout(function () {
      processStyle(style, map);
    }, 0);
  }
  return map;
}

/**
 * Get the OpenLayers layer instance that contains the provided Mapbox Style
 * `layer`. Note that multiple Mapbox Style layers are combined in a single
 * OpenLayers layer instance when they use the same Mapbox Style `source`.
 * @param {ol.Map} map OpenLayers Map.
 * @param {string} layerId Mapbox Style layer id.
 * @return {ol.layer.Layer} layer OpenLayers layer instance.
 */
function getLayer(map, layerId) {
  var layers = map.getLayers().getArray();
  for (var i = 0, ii = layers.length; i < ii; ++i) {
    if (layers[i].get('mapbox-layers').indexOf(layerId) !== -1) {
      return layers[i];
    }
  }
}

/**
 * Get the OpenLayers source instance for the provided Mapbox Style `source`.
 * @param {ol.Map} map OpenLayers Map.
 * @param {string} sourceId Mapbox Style source id.
 * @return {ol.layer.Layer} layer OpenLayers layer instance.
 */
function getSource(map, sourceId) {
  var layers = map.getLayers().getArray();
  for (var i = 0, ii = layers.length; i < ii; ++i) {
    var source = layers[i].getSource();
    if (layers[i].get('mapbox-source').indexOf(sourceId) !== -1) {
      return source;
    }
  }
}

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var $version = 8;
var $root = {
    version: {
        required: true,
        type: "enum",
        values: [8],
        doc: "Style specification version number. Must be 8.",
        example: 8
    },
    name: {
        type: "string",
        doc: "A human-readable name for the style.",
        example: "Bright"
    },
    metadata: {
        type: "*",
        doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    center: {
        type: "array",
        value: "number",
        doc: "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: [-73.9749, 40.7736]
    },
    zoom: {
        type: "number",
        doc: "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 12.5
    },
    bearing: {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Default bearing, in degrees. The bearing is the compass direction that is \"up\"; for example, a bearing of 90Â° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 29
    },
    pitch: {
        type: "number",
        "default": 0,
        units: "degrees",
        doc: "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 50
    },
    light: {
        type: "light",
        doc: "The global light source.",
        example: {
            anchor: "viewport",
            color: "white",
            intensity: 0.4
        }
    },
    sources: {
        required: true,
        type: "sources",
        doc: "Data source specifications.",
        example: {
            "mapbox-streets": {
                type: "vector",
                url: "mapbox://mapbox.mapbox-streets-v6"
            }
        }
    },
    sprite: {
        type: "string",
        doc: "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
        example: "mapbox://sprites/mapbox/bright-v8"
    },
    glyphs: {
        type: "string",
        doc: "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
        example: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
    },
    transition: {
        type: "transition",
        doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.",
        example: {
            duration: 300,
            delay: 0
        }
    },
    layers: {
        required: true,
        type: "array",
        value: "layer",
        doc: "Layers will be drawn in the order of this array.",
        example: [{
            id: "water",
            source: "mapbox-streets",
            "source-layer": "water",
            type: "fill",
            paint: {
                "fill-color": "#00ffff"
            }
        }]
    }
};
var sources = {
    "*": {
        type: "source",
        doc: "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."
    }
};
var source = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];
var source_vector = {
    type: {
        required: true,
        type: "enum",
        values: {
            vector: {
                doc: "A vector tile source."
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    scheme: {
        type: "enum",
        values: {
            xyz: {
                doc: "Slippy map tilenames scheme."
            },
            tms: {
                doc: "OSGeo spec scheme."
            }
        },
        "default": "xyz",
        doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    promoteId: {
        type: "promoteId",
        doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers."
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_raster = {
    type: {
        required: true,
        type: "enum",
        values: {
            raster: {
                doc: "A raster tile source."
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    tileSize: {
        type: "number",
        "default": 512,
        units: "pixels",
        doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    scheme: {
        type: "enum",
        values: {
            xyz: {
                doc: "Slippy map tilenames scheme."
            },
            tms: {
                doc: "OSGeo spec scheme."
            }
        },
        "default": "xyz",
        doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_raster_dem = {
    type: {
        required: true,
        type: "enum",
        values: {
            "raster-dem": {
                doc: "A RGB-encoded raster DEM source"
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    tileSize: {
        type: "number",
        "default": 512,
        units: "pixels",
        doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    encoding: {
        type: "enum",
        values: {
            terrarium: {
                doc: "Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info."
            },
            mapbox: {
                doc: "Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info."
            }
        },
        "default": "mapbox",
        doc: "The encoding used by this source. Mapbox Terrain RGB is used by default"
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_geojson = {
    type: {
        required: true,
        type: "enum",
        values: {
            geojson: {
                doc: "A GeoJSON data source."
            }
        },
        doc: "The data type of the GeoJSON source."
    },
    data: {
        type: "*",
        doc: "A URL to a GeoJSON file, or inline GeoJSON."
    },
    maxzoom: {
        type: "number",
        "default": 18,
        doc: "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    buffer: {
        type: "number",
        "default": 128,
        maximum: 512,
        minimum: 0,
        doc: "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."
    },
    tolerance: {
        type: "number",
        "default": 0.375,
        doc: "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
    },
    cluster: {
        type: "boolean",
        "default": false,
        doc: "If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\n * `cluster` Is `true` if the point is a cluster \n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\n * `point_count` Number of original points grouped into this cluster\n * `point_count_abbreviated` An abbreviated point count"
    },
    clusterRadius: {
        type: "number",
        "default": 50,
        minimum: 0,
        doc: "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."
    },
    clusterMaxZoom: {
        type: "number",
        doc: "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered)."
    },
    clusterProperties: {
        type: "*",
        doc: "An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{\"property_name\": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `\"+\"` or `\"max\"`) â it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\n\nExample: `{\"sum\": [\"+\", [\"get\", \"scalerank\"]]}`.\n\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `[\"accumulated\"]` value, e.g.:\n`{\"sum\": [[\"+\", [\"accumulated\"], [\"get\", \"sum\"]], [\"get\", \"scalerank\"]]}`"
    },
    lineMetrics: {
        type: "boolean",
        "default": false,
        doc: "Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values."
    },
    generateId: {
        type: "boolean",
        "default": false,
        doc: "Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values."
    },
    promoteId: {
        type: "promoteId",
        doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`."
    }
};
var source_video = {
    type: {
        required: true,
        type: "enum",
        values: {
            video: {
                doc: "A video data source."
            }
        },
        doc: "The data type of the video source."
    },
    urls: {
        required: true,
        type: "array",
        value: "string",
        doc: "URLs to video content in order of preferred format."
    },
    coordinates: {
        required: true,
        doc: "Corners of video specified in longitude, latitude pairs.",
        type: "array",
        length: 4,
        value: {
            type: "array",
            length: 2,
            value: "number",
            doc: "A single longitude, latitude pair."
        }
    }
};
var source_image = {
    type: {
        required: true,
        type: "enum",
        values: {
            image: {
                doc: "An image data source."
            }
        },
        doc: "The data type of the image source."
    },
    url: {
        required: true,
        type: "string",
        doc: "URL that points to an image."
    },
    coordinates: {
        required: true,
        doc: "Corners of image specified in longitude, latitude pairs.",
        type: "array",
        length: 4,
        value: {
            type: "array",
            length: 2,
            value: "number",
            doc: "A single longitude, latitude pair."
        }
    }
};
var layer = {
    id: {
        type: "string",
        doc: "Unique layer name.",
        required: true
    },
    type: {
        type: "enum",
        values: {
            fill: {
                doc: "A filled polygon with an optional stroked border.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            line: {
                doc: "A stroked line.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            symbol: {
                doc: "An icon or a text label.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            circle: {
                doc: "A filled circle.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            heatmap: {
                doc: "A heatmap.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.41.0",
                        android: "6.0.0",
                        ios: "4.0.0",
                        macos: "0.7.0"
                    }
                }
            },
            "fill-extrusion": {
                doc: "An extruded (3D) polygon.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.27.0",
                        android: "5.1.0",
                        ios: "3.6.0",
                        macos: "0.5.0"
                    }
                }
            },
            raster: {
                doc: "Raster map textures such as satellite imagery.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            hillshade: {
                doc: "Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.43.0",
                        android: "6.0.0",
                        ios: "4.0.0",
                        macos: "0.7.0"
                    }
                }
            },
            background: {
                doc: "The background color or pattern of the map.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            }
        },
        doc: "Rendering type of this layer.",
        required: true
    },
    metadata: {
        type: "*",
        doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    source: {
        type: "string",
        doc: "Name of a source description to be used for this layer. Required for all layer types except `background`."
    },
    "source-layer": {
        type: "string",
        doc: "Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources."
    },
    minzoom: {
        type: "number",
        minimum: 0,
        maximum: 24,
        doc: "The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden."
    },
    maxzoom: {
        type: "number",
        minimum: 0,
        maximum: 24,
        doc: "The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden."
    },
    filter: {
        type: "filter",
        doc: "A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `feature-state` expression is not supported in filter expressions."
    },
    layout: {
        type: "layout",
        doc: "Layout properties for the layer."
    },
    paint: {
        type: "paint",
        doc: "Default paint properties for this layer."
    }
};
var layout = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"];
var layout_background = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_fill = {
    "fill-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0"
            },
            "data-driven styling": {
                js: "1.2.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_circle = {
    "circle-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0"
            },
            "data-driven styling": {
                js: "1.2.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_heatmap = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_line = {
    "line-cap": {
        type: "enum",
        values: {
            butt: {
                doc: "A cap with a squared-off end which is drawn to the exact endpoint of the line."
            },
            round: {
                doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
            },
            square: {
                doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
            }
        },
        "default": "butt",
        doc: "The display of line endings.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-join": {
        type: "enum",
        values: {
            bevel: {
                doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
            },
            round: {
                doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
            },
            miter: {
                doc: "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."
            }
        },
        "default": "miter",
        doc: "The display of lines when joining.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "line-miter-limit": {
        type: "number",
        "default": 2,
        doc: "Used to automatically convert miter joins to bevel joins for sharp angles.",
        requires: [{
            "line-join": "miter"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-round-limit": {
        type: "number",
        "default": 1.05,
        doc: "Used to automatically convert round joins to miter joins for shallow angles.",
        requires: [{
            "line-join": "round"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0"
            },
            "data-driven styling": {
                js: "1.2.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_symbol = {
    "symbol-placement": {
        type: "enum",
        values: {
            point: {
                doc: "The label is placed at the point where the geometry is located."
            },
            line: {
                doc: "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."
            },
            "line-center": {
                doc: "The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries."
            }
        },
        "default": "point",
        doc: "Label placement relative to its geometry.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`line-center` value": {
                js: "0.47.0",
                android: "6.4.0",
                ios: "4.3.0",
                macos: "0.10.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-spacing": {
        type: "number",
        "default": 250,
        minimum: 1,
        units: "pixels",
        doc: "Distance between two symbol anchors.",
        requires: [{
            "symbol-placement": "line"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-avoid-edges": {
        type: "boolean",
        "default": false,
        doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "0.53.0",
                android: "7.4.0",
                ios: "4.11.0",
                macos: "0.14.0"
            },
            "data-driven styling": {
                js: "0.53.0",
                android: "7.4.0",
                ios: "4.11.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "symbol-z-order": {
        type: "enum",
        values: {
            auto: {
                doc: "If `symbol-sort-key` is set, sort based on that. Otherwise sort symbols by their y-position relative to the viewport."
            },
            "viewport-y": {
                doc: "Symbols will be sorted by their y-position relative to the viewport."
            },
            source: {
                doc: "Symbols will be rendered in the same order as the source data with no sorting applied."
            }
        },
        "default": "auto",
        doc: "Controls the order in which overlapping symbols in the same layer are rendered",
        "sdk-support": {
            "basic functionality": {
                js: "0.49.0",
                android: "6.6.0",
                ios: "4.5.0",
                macos: "0.12.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-allow-overlap": {
        type: "boolean",
        "default": false,
        doc: "If true, the icon will be visible even if it collides with other previously drawn symbols.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-ignore-placement": {
        type: "boolean",
        "default": false,
        doc: "If true, other symbols can be visible even if they collide with the icon.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-optional": {
        type: "boolean",
        "default": false,
        doc: "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
        requires: ["icon-image", "text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-rotation-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line."
            },
            viewport: {
                doc: "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
            },
            auto: {
                doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
            }
        },
        "default": "auto",
        doc: "In combination with `symbol-placement`, determines the rotation behavior of icons.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-size": {
        type: "number",
        "default": 1,
        minimum: 0,
        units: "factor of the original icon size",
        doc: "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-text-fit": {
        type: "enum",
        values: {
            none: {
                doc: "The icon is displayed at its intrinsic aspect ratio."
            },
            width: {
                doc: "The icon is scaled in the x-dimension to fit the width of the text."
            },
            height: {
                doc: "The icon is scaled in the y-dimension to fit the height of the text."
            },
            both: {
                doc: "The icon is scaled in both x- and y-dimensions."
            }
        },
        "default": "none",
        doc: "Scales the icon to fit around the associated text.",
        requires: ["icon-image", "text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-text-fit-padding": {
        type: "array",
        value: "number",
        length: 4,
        "default": [0, 0, 0, 0],
        units: "pixels",
        doc: "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",
        requires: ["icon-image", "text-field", {
            "icon-text-fit": ["both", "width", "height"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-image": {
        type: "resolvedImage",
        doc: "Name of image in sprite to use for drawing an image background.",
        tokens: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Rotates the icon clockwise.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.21.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-padding": {
        type: "number",
        "default": 2,
        minimum: 0,
        units: "pixels",
        doc: "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-keep-upright": {
        type: "boolean",
        "default": false,
        doc: "If true, the icon may be flipped to prevent it from being rendered upside-down.",
        requires: ["icon-image", {
            "icon-rotation-alignment": "map"
        }, {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-offset": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        doc: "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-anchor": {
        type: "enum",
        values: {
            center: {
                doc: "The center of the icon is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the icon is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the icon is placed closest to the anchor."
            },
            top: {
                doc: "The top of the icon is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the icon is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the icon is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the icon is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the icon is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the icon is placed closest to the anchor."
            }
        },
        "default": "center",
        doc: "Part of the icon placed closest to the anchor.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The icon is aligned to the plane of the map."
            },
            viewport: {
                doc: "The icon is aligned to the plane of the viewport."
            },
            auto: {
                doc: "Automatically matches the value of `icon-rotation-alignment`."
            }
        },
        "default": "auto",
        doc: "Orientation of icon when map is pitched.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The text is aligned to the plane of the map."
            },
            viewport: {
                doc: "The text is aligned to the plane of the viewport."
            },
            auto: {
                doc: "Automatically matches the value of `text-rotation-alignment`."
            }
        },
        "default": "auto",
        doc: "Orientation of text when map is pitched.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-rotation-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line."
            },
            viewport: {
                doc: "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
            },
            auto: {
                doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
            }
        },
        "default": "auto",
        doc: "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-field": {
        type: "formatted",
        "default": "",
        tokens: true,
        doc: "Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-font": {
        type: "array",
        value: "string",
        "default": ["Open Sans Regular", "Arial Unicode MS Regular"],
        doc: "Font stack to use for displaying text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-size": {
        type: "number",
        "default": 16,
        minimum: 0,
        units: "pixels",
        doc: "Font size.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-max-width": {
        type: "number",
        "default": 10,
        minimum: 0,
        units: "ems",
        doc: "The maximum line width for text wrapping.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-line-height": {
        type: "number",
        "default": 1.2,
        units: "ems",
        doc: "Text leading value for multi-line text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-letter-spacing": {
        type: "number",
        "default": 0,
        units: "ems",
        doc: "Text tracking amount.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-justify": {
        type: "enum",
        values: {
            auto: {
                doc: "The text is aligned towards the anchor position."
            },
            left: {
                doc: "The text is aligned to the left."
            },
            center: {
                doc: "The text is centered."
            },
            right: {
                doc: "The text is aligned to the right."
            }
        },
        "default": "center",
        doc: "Text justification options.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            },
            auto: {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-radial-offset": {
        type: "number",
        units: "ems",
        "default": 0,
        doc: "Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",
        "sdk-support": {
            "basic functionality": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            },
            "data-driven styling": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        requires: ["text-field"],
        "property-type": "data-driven",
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        }
    },
    "text-variable-anchor": {
        type: "array",
        value: "enum",
        values: {
            center: {
                doc: "The center of the text is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the text is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the text is placed closest to the anchor."
            },
            top: {
                doc: "The top of the text is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the text is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the text is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the text is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the text is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the text is placed closest to the anchor."
            }
        },
        requires: ["text-field", {
            "symbol-placement": ["point"]
        }],
        doc: "To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.",
        "sdk-support": {
            "basic functionality": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-anchor": {
        type: "enum",
        values: {
            center: {
                doc: "The center of the text is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the text is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the text is placed closest to the anchor."
            },
            top: {
                doc: "The top of the text is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the text is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the text is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the text is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the text is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the text is placed closest to the anchor."
            }
        },
        "default": "center",
        doc: "Part of the text placed closest to the anchor.",
        requires: ["text-field", {
            "!": "text-variable-anchor"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-max-angle": {
        type: "number",
        "default": 45,
        units: "degrees",
        doc: "Maximum angle change between adjacent characters.",
        requires: ["text-field", {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-writing-mode": {
        type: "array",
        value: "enum",
        values: {
            horizontal: {
                doc: "If a text's language supports horizontal writing mode, symbols with point placement would be laid out horizontally."
            },
            vertical: {
                doc: "If a text's language supports vertical writing mode, symbols with point placement would be laid out vertically."
            }
        },
        doc: "The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesnât support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. The order of elements in an array define priority order for the placement of an orientation variant.",
        requires: ["text-field", {
            "symbol-placement": ["point"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "1.3.0",
                android: "8.3.0",
                ios: "5.3.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Rotates the text clockwise.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-padding": {
        type: "number",
        "default": 2,
        minimum: 0,
        units: "pixels",
        doc: "Size of the additional area around the text bounding box used for detecting symbol collisions.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-keep-upright": {
        type: "boolean",
        "default": true,
        doc: "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
        requires: ["text-field", {
            "text-rotation-alignment": "map"
        }, {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-transform": {
        type: "enum",
        values: {
            none: {
                doc: "The text is not altered."
            },
            uppercase: {
                doc: "Forces all letters to be displayed in uppercase."
            },
            lowercase: {
                doc: "Forces all letters to be displayed in lowercase."
            }
        },
        "default": "none",
        doc: "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-offset": {
        type: "array",
        doc: "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.",
        value: "number",
        units: "ems",
        length: 2,
        "default": [0, 0],
        requires: ["text-field", {
            "!": "text-radial-offset"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-allow-overlap": {
        type: "boolean",
        "default": false,
        doc: "If true, the text will be visible even if it collides with other previously drawn symbols.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-ignore-placement": {
        type: "boolean",
        "default": false,
        doc: "If true, other symbols can be visible even if they collide with the text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-optional": {
        type: "boolean",
        "default": false,
        doc: "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
        requires: ["text-field", "icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_raster = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_hillshade = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        "property-type": "constant"
    }
};
var filter = {
    type: "array",
    value: "*",
    doc: "A filter selects specific features from a layer."
};
var filter_operator = {
    type: "enum",
    values: {
        "==": {
            doc: "`[\"==\", key, value]` equality: `feature[key] = value`"
        },
        "!=": {
            doc: "`[\"!=\", key, value]` inequality: `feature[key] â  value`"
        },
        ">": {
            doc: "`[\">\", key, value]` greater than: `feature[key] > value`"
        },
        ">=": {
            doc: "`[\">=\", key, value]` greater than or equal: `feature[key] â¥ value`"
        },
        "<": {
            doc: "`[\"<\", key, value]` less than: `feature[key] < value`"
        },
        "<=": {
            doc: "`[\"<=\", key, value]` less than or equal: `feature[key] â¤ value`"
        },
        "in": {
            doc: "`[\"in\", key, v0, ..., vn]` set inclusion: `feature[key] â {v0, ..., vn}`"
        },
        "!in": {
            doc: "`[\"!in\", key, v0, ..., vn]` set exclusion: `feature[key] â {v0, ..., vn}`"
        },
        all: {
            doc: "`[\"all\", f0, ..., fn]` logical `AND`: `f0 â§ ... â§ fn`"
        },
        any: {
            doc: "`[\"any\", f0, ..., fn]` logical `OR`: `f0 â¨ ... â¨ fn`"
        },
        none: {
            doc: "`[\"none\", f0, ..., fn]` logical `NOR`: `Â¬f0 â§ ... â§ Â¬fn`"
        },
        has: {
            doc: "`[\"has\", key]` `feature[key]` exists"
        },
        "!has": {
            doc: "`[\"!has\", key]` `feature[key]` does not exist"
        }
    },
    doc: "The filter operator."
};
var geometry_type = {
    type: "enum",
    values: {
        Point: {
            doc: "Filter to point geometries."
        },
        LineString: {
            doc: "Filter to line geometries."
        },
        Polygon: {
            doc: "Filter to polygon geometries."
        }
    },
    doc: "The geometry type for the filter to select."
};
var function_stop = {
    type: "array",
    minimum: 0,
    maximum: 24,
    value: ["number", "color"],
    length: 2,
    doc: "Zoom level and value pair."
};
var expression = {
    type: "array",
    value: "*",
    minimum: 1,
    doc: "An expression defines a function that can be used for data-driven style properties or feature filters."
};
var expression_name = {
    doc: "",
    type: "enum",
    values: {
        "let": {
            doc: "Binds expressions to named variables, which can then be referenced in the result expression using [\"var\", \"variable_name\"].",
            group: "Variable binding",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "var": {
            doc: "References variable bound using \"let\".",
            group: "Variable binding",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        literal: {
            doc: "Provides a literal array or object value.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        array: {
            doc: "Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        at: {
            doc: "Retrieves an item from an array.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "in": {
            doc: "Determines whether an item exists in an array or a substring exists in a string.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "1.6.0"
                }
            }
        },
        "index-of": {
            doc: "Returns the first index at which a given element can be found in an array, or for a string, the first occurrence of the specified value. If a second argument is provided, then the search is started from that position. Returns -1 if the value is not found.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "1.10.0"
                }
            }
        },
        "case": {
            doc: "Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        match: {
            doc: "Selects the output whose label value matches the input value, or the fallback value if no match is found. The input can be any expression (e.g. `[\"get\", \"building_type\"]`). Each label must be either:\n * a single literal value; or\n * an array of literal values, whose values must be all strings or all numbers (e.g. `[100, 101]` or `[\"c\", \"b\"]`). The input matches if any of the values in the array matches, similar to the `\"in\"` operator.\n\nEach label must be unique. If the input type does not match the type of the labels, the result will be the fallback value.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        coalesce: {
            doc: "Evaluates each expression in turn until the first non-null value is obtained, and returns that value.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        step: {
            doc: "Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        interpolate: {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\n\nInterpolation types:\n- `[\"linear\"]`: interpolates linearly between the pair of stops just less than and just greater than the input.\n- `[\"exponential\", base]`: interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\n- `[\"cubic-bezier\", x1, y1, x2, y2]`: interpolates using the cubic bezier curve defined by the given control points.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "interpolate-hcl": {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.49.0"
                }
            }
        },
        "interpolate-lab": {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.49.0"
                }
            }
        },
        ln2: {
            doc: "Returns mathematical constant ln(2).",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        pi: {
            doc: "Returns the mathematical constant pi.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        e: {
            doc: "Returns the mathematical constant e.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "typeof": {
            doc: "Returns a string describing the type of the given value.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        string: {
            doc: "Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        number: {
            doc: "Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        boolean: {
            doc: "Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        object: {
            doc: "Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        collator: {
            doc: "Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        format: {
            doc: "Returns `formatted` text containing annotations for use in mixed-format `text-field` entries. For a `text-field` entries of a string type, following option object's properties are supported: If set, the `text-font` value overrides the font specified by the root layout properties. If set, the `font-scale` value specifies a scaling factor relative to the `text-size` specified in the root layout properties. If set, the `text-color` value overrides the color specified by the root paint properties for this layer.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "text-font": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "font-scale": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "text-color": {
                    js: "1.3.0",
                    android: "7.3.0",
                    ios: "4.10.0",
                    macos: "0.14.0"
                },
                image: {
                    js: "1.6.0"
                }
            }
        },
        image: {
            doc: "Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "1.4.0",
                    android: "8.6.0",
                    ios: "5.6.0"
                }
            }
        },
        "number-format": {
            doc: "Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.54.0"
                }
            }
        },
        "to-string": {
            doc: "Converts the input value to a string. If the input is `null`, the result is `\"\"`. If the input is a boolean, the result is `\"true\"` or `\"false\"`. If the input is a number, it is converted to a string as specified by the [\"NumberToString\" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `\"rgba(r,g,b,a)\"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-number": {
            doc: "Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the [\"ToNumber Applied to the String Type\" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-boolean": {
            doc: "Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-rgba": {
            doc: "Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-color": {
            doc: "Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        rgb: {
            doc: "Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        rgba: {
            doc: "Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        get: {
            doc: "Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns null if the requested property is missing.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        has: {
            doc: "Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        length: {
            doc: "Gets the length of an array or string.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        properties: {
            doc: "Gets the feature properties object.  Note that in some cases, it may be more efficient to use [\"get\", \"property_name\"] directly.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "feature-state": {
            doc: "Retrieves a property value from the current feature's state. Returns null if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\"feature-state\"] can only be used with paint properties that support data-driven styling.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.46.0"
                }
            }
        },
        "geometry-type": {
            doc: "Gets the feature's geometry type: Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        id: {
            doc: "Gets the feature's id, if it has one.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        zoom: {
            doc: "Gets the current zoom level.  Note that in style layout and paint properties, [\"zoom\"] may only appear as the input to a top-level \"step\" or \"interpolate\" expression.",
            group: "Zoom",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "heatmap-density": {
            doc: "Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",
            group: "Heatmap",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "line-progress": {
            doc: "Gets the progress along a gradient line. Can only be used in the `line-gradient` property.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                }
            }
        },
        accumulated: {
            doc: "Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.53.0"
                }
            }
        },
        "+": {
            doc: "Returns the sum of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "*": {
            doc: "Returns the product of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "-": {
            doc: "For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "/": {
            doc: "Returns the result of floating point division of the first input by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "%": {
            doc: "Returns the remainder after integer division of the first input by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "^": {
            doc: "Returns the result of raising the first input to the power specified by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        sqrt: {
            doc: "Returns the square root of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        log10: {
            doc: "Returns the base-ten logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        ln: {
            doc: "Returns the natural logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        log2: {
            doc: "Returns the base-two logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        sin: {
            doc: "Returns the sine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        cos: {
            doc: "Returns the cosine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        tan: {
            doc: "Returns the tangent of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        asin: {
            doc: "Returns the arcsine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        acos: {
            doc: "Returns the arccosine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        atan: {
            doc: "Returns the arctangent of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        min: {
            doc: "Returns the minimum value of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        max: {
            doc: "Returns the maximum value of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        round: {
            doc: "Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `[\"round\", -1.5]` evaluates to -2.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        abs: {
            doc: "Returns the absolute value of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        ceil: {
            doc: "Returns the smallest integer that is greater than or equal to the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        floor: {
            doc: "Returns the largest integer that is less than or equal to the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "==": {
            doc: "Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "!=": {
            doc: "Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        ">": {
            doc: "Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "<": {
            doc: "Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        ">=": {
            doc: "Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "<=": {
            doc: "Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        all: {
            doc: "Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        any: {
            doc: "Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "!": {
            doc: "Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        within: {
            doc: "Returns `true` if the feature being evaluated is inside the pre-defined geometry boundary, `false` otherwise. The expression has one argument which must be a valid GeoJSON Polygon/Multi-Polygon object. The expression only evaluates on `Point` or `LineString` feature. For `Point` feature, The expression will return false if any point of the feature is on the boundary or outside the boundary. For `LineString` feature, the expression will return false if the line is fully outside the boundary, or the line is partially intersecting the boundary, which means either part of the line is outside of the boundary, or end point of the line lies on the boundary.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "1.9.0"
                }
            }
        },
        "is-supported-script": {
            doc: "Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.6.0"
                }
            }
        },
        upcase: {
            doc: "Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        downcase: {
            doc: "Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        concat: {
            doc: "Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "resolved-locale": {
            doc: "Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        slice: {
            doc: "Returns a portion of a string or an array starting from the provided beginning index. If a second argument is provided, then the return portion will run to, but not include, the end index.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "1.10.0"
                }
            }
        }
    }
};
var light = {
    anchor: {
        type: "enum",
        "default": "viewport",
        values: {
            map: {
                doc: "The position of the light source is aligned to the rotation of the map."
            },
            viewport: {
                doc: "The position of the light source is aligned to the rotation of the viewport."
            }
        },
        "property-type": "data-constant",
        transition: false,
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        doc: "Whether extruded geometries are lit relative to the map or viewport.",
        example: "map",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    position: {
        type: "array",
        "default": [1.15, 210, 30],
        length: 3,
        value: "number",
        "property-type": "data-constant",
        transition: true,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        doc: "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0Â° (0Â° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0Â° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0Â°, directly above, to 180Â°, directly below).",
        example: [1.5, 90, 80],
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    color: {
        type: "color",
        "property-type": "data-constant",
        "default": "#ffffff",
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "Color tint for lighting extruded geometries.",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    intensity: {
        type: "number",
        "property-type": "data-constant",
        "default": 0.5,
        minimum: 0,
        maximum: 1,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    }
};
var paint = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"];
var paint_fill = {
    "fill-antialias": {
        type: "boolean",
        "default": true,
        doc: "Whether or not the fill should be antialiased.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-opacity": {
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        doc: "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.21.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-color": {
        type: "color",
        "default": "#000000",
        doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
        transition: true,
        requires: [{
            "!": "fill-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.19.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-outline-color": {
        type: "color",
        doc: "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
        transition: true,
        requires: [{
            "!": "fill-pattern"
        }, {
            "fill-antialias": true
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.19.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The fill is translated relative to the map."
            },
            viewport: {
                doc: "The fill is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `fill-translate`.",
        "default": "map",
        requires: ["fill-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.49.0",
                android: "6.5.0",
                macos: "0.11.0",
                ios: "4.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "cross-faded-data-driven"
    }
};
var paint_line = {
    "line-opacity": {
        type: "number",
        doc: "The opacity at which the line will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-color": {
        type: "color",
        doc: "The color with which the line will be drawn.",
        "default": "#000000",
        transition: true,
        requires: [{
            "!": "line-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.23.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The line is translated relative to the map."
            },
            viewport: {
                doc: "The line is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `line-translate`.",
        "default": "map",
        requires: ["line-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-width": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Stroke thickness.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-gap-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        doc: "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
        transition: true,
        units: "pixels",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-offset": {
        type: "number",
        "default": 0,
        doc: "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
        transition: true,
        units: "pixels",
        "sdk-support": {
            "basic functionality": {
                js: "0.12.1",
                android: "3.0.0",
                ios: "3.1.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Blur applied to the line, in pixels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-dasharray": {
        type: "array",
        value: "number",
        doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        minimum: 0,
        transition: true,
        units: "line widths",
        requires: [{
            "!": "line-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "cross-faded"
    },
    "line-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.49.0",
                android: "6.5.0",
                macos: "0.11.0",
                ios: "4.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "cross-faded-data-driven"
    },
    "line-gradient": {
        type: "color",
        doc: "Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `\"lineMetrics\": true`.",
        transition: false,
        requires: [{
            "!": "line-dasharray"
        }, {
            "!": "line-pattern"
        }, {
            source: "geojson",
            has: {
                lineMetrics: true
            }
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.45.0",
                android: "6.5.0",
                ios: "4.4.0",
                macos: "0.11.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: true,
            parameters: ["line-progress"]
        },
        "property-type": "color-ramp"
    }
};
var paint_circle = {
    "circle-radius": {
        type: "number",
        "default": 5,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Circle radius.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.18.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-color": {
        type: "color",
        "default": "#000000",
        doc: "The fill color of the circle.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.18.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-blur": {
        type: "number",
        "default": 0,
        doc: "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.20.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-opacity": {
        type: "number",
        doc: "The opacity at which the circle will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.20.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The circle is translated relative to the map."
            },
            viewport: {
                doc: "The circle is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `circle-translate`.",
        "default": "map",
        requires: ["circle-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-pitch-scale": {
        type: "enum",
        values: {
            map: {
                doc: "Circles are scaled according to their apparent distance to the camera."
            },
            viewport: {
                doc: "Circles are not scaled."
            }
        },
        "default": "map",
        doc: "Controls the scaling behavior of the circle when the map is pitched.",
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The circle is aligned to the plane of the map."
            },
            viewport: {
                doc: "The circle is aligned to the plane of the viewport."
            }
        },
        "default": "viewport",
        doc: "Orientation of circle when map is pitched.",
        "sdk-support": {
            "basic functionality": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-stroke-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-stroke-color": {
        type: "color",
        "default": "#000000",
        doc: "The stroke color of the circle.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-stroke-opacity": {
        type: "number",
        doc: "The opacity of the circle's stroke.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    }
};
var paint_heatmap = {
    "heatmap-radius": {
        type: "number",
        "default": 30,
        minimum: 1,
        transition: true,
        units: "pixels",
        doc: "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "heatmap-weight": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: false,
        doc: "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "heatmap-intensity": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: true,
        doc: "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "heatmap-color": {
        type: "color",
        "default": ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"],
        doc: "Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `[\"heatmap-density\"]` as input.",
        transition: false,
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: true,
            parameters: ["heatmap-density"]
        },
        "property-type": "color-ramp"
    },
    "heatmap-opacity": {
        type: "number",
        doc: "The global opacity at which the heatmap layer will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_symbol = {
    "icon-opacity": {
        doc: "The opacity at which the icon will be drawn.",
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-color": {
        type: "color",
        "default": "#000000",
        transition: true,
        doc: "The color of the icon. This can only be used with sdf icons.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-color": {
        type: "color",
        "default": "rgba(0, 0, 0, 0)",
        transition: true,
        doc: "The color of the icon's halo. Icon halos can only be used with SDF icons.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Distance of halo to the icon outline.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Fade out the halo towards the outside.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "Icons are translated relative to the map."
            },
            viewport: {
                doc: "Icons are translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `icon-translate`.",
        "default": "map",
        requires: ["icon-image", "icon-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-opacity": {
        type: "number",
        doc: "The opacity at which the text will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-color": {
        type: "color",
        doc: "The color with which the text will be drawn.",
        "default": "#000000",
        transition: true,
        overridable: true,
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-color": {
        type: "color",
        "default": "rgba(0, 0, 0, 0)",
        transition: true,
        doc: "The color of the text's halo, which helps it stand out from backgrounds.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "The halo's fadeout distance towards the outside.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The text is translated relative to the map."
            },
            viewport: {
                doc: "The text is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `text-translate`.",
        "default": "map",
        requires: ["text-field", "text-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_raster = {
    "raster-opacity": {
        type: "number",
        doc: "The opacity at which the image will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-hue-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        transition: true,
        units: "degrees",
        doc: "Rotates hues around the color wheel.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-brightness-min": {
        type: "number",
        doc: "Increase or reduce the brightness of the image. The value is the minimum brightness.",
        "default": 0,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-brightness-max": {
        type: "number",
        doc: "Increase or reduce the brightness of the image. The value is the maximum brightness.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-saturation": {
        type: "number",
        doc: "Increase or reduce the saturation of the image.",
        "default": 0,
        minimum: -1,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-contrast": {
        type: "number",
        doc: "Increase or reduce the contrast of the image.",
        "default": 0,
        minimum: -1,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-resampling": {
        type: "enum",
        doc: "The resampling/interpolation method to use for overscaling, also known as texture magnification filter",
        values: {
            linear: {
                doc: "(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled"
            },
            nearest: {
                doc: "Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled"
            }
        },
        "default": "linear",
        "sdk-support": {
            "basic functionality": {
                js: "0.47.0",
                android: "6.3.0",
                ios: "4.2.0",
                macos: "0.9.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-fade-duration": {
        type: "number",
        "default": 300,
        minimum: 0,
        transition: false,
        units: "milliseconds",
        doc: "Fade duration when a new tile is added.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_hillshade = {
    "hillshade-illumination-direction": {
        type: "number",
        "default": 335,
        minimum: 0,
        maximum: 359,
        doc: "The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.",
        transition: false,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-illumination-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The hillshade illumination is relative to the north direction."
            },
            viewport: {
                doc: "The hillshade illumination is relative to the top of the viewport."
            }
        },
        "default": "viewport",
        doc: "Direction of light source when map is rotated.",
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-exaggeration": {
        type: "number",
        doc: "Intensity of the hillshade",
        "default": 0.5,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-shadow-color": {
        type: "color",
        "default": "#000000",
        doc: "The shading color of areas that face away from the light source.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-highlight-color": {
        type: "color",
        "default": "#FFFFFF",
        doc: "The shading color of areas that faces towards the light source.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-accent-color": {
        type: "color",
        "default": "#000000",
        doc: "The shading color used to accentuate rugged terrain like sharp cliffs and gorges.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_background = {
    "background-color": {
        type: "color",
        "default": "#000000",
        doc: "The color with which the background will be drawn.",
        transition: true,
        requires: [{
            "!": "background-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "background-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "cross-faded"
    },
    "background-opacity": {
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        doc: "The opacity at which the background will be drawn.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var transition = {
    duration: {
        type: "number",
        "default": 300,
        minimum: 0,
        units: "milliseconds",
        doc: "Time allotted for transitions to complete."
    },
    delay: {
        type: "number",
        "default": 0,
        minimum: 0,
        units: "milliseconds",
        doc: "Length of time before a transition begins."
    }
};
var promoteId = {
    "*": {
        type: "string",
        doc: "A name of a feature property to use as ID for feature state."
    }
};
var v8 = {
    $version: $version,
    $root: $root,
    sources: sources,
    source: source,
    source_vector: source_vector,
    source_raster: source_raster,
    source_raster_dem: source_raster_dem,
    source_geojson: source_geojson,
    source_video: source_video,
    source_image: source_image,
    layer: layer,
    layout: layout,
    layout_background: layout_background,
    layout_fill: layout_fill,
    layout_circle: layout_circle,
    layout_heatmap: layout_heatmap,
    "layout_fill-extrusion": {
        visibility: {
            type: "enum",
            values: {
                visible: {
                    doc: "The layer is shown."
                },
                none: {
                    doc: "The layer is not shown."
                }
            },
            "default": "visible",
            doc: "Whether this layer is displayed.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            "property-type": "constant"
        }
    },
    layout_line: layout_line,
    layout_symbol: layout_symbol,
    layout_raster: layout_raster,
    layout_hillshade: layout_hillshade,
    filter: filter,
    filter_operator: filter_operator,
    geometry_type: geometry_type,
    "function": {
        expression: {
            type: "expression",
            doc: "An expression."
        },
        stops: {
            type: "array",
            doc: "An array of stops.",
            value: "function_stop"
        },
        base: {
            type: "number",
            "default": 1,
            minimum: 0,
            doc: "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
        },
        property: {
            type: "string",
            doc: "The name of a feature property to use as the function input.",
            "default": "$zoom"
        },
        type: {
            type: "enum",
            values: {
                identity: {
                    doc: "Return the input value as the output value."
                },
                exponential: {
                    doc: "Generate an output by interpolating between stops just less than and just greater than the function input."
                },
                interval: {
                    doc: "Return the output value of the stop just less than the function input."
                },
                categorical: {
                    doc: "Return the output value of the stop equal to the function input."
                }
            },
            doc: "The interpolation strategy to use in function evaluation.",
            "default": "exponential"
        },
        colorSpace: {
            type: "enum",
            values: {
                rgb: {
                    doc: "Use the RGB color space to interpolate color values"
                },
                lab: {
                    doc: "Use the LAB color space to interpolate color values."
                },
                hcl: {
                    doc: "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."
                }
            },
            doc: "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",
            "default": "rgb"
        },
        "default": {
            type: "*",
            required: false,
            doc: "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances."
        }
    },
    function_stop: function_stop,
    expression: expression,
    expression_name: expression_name,
    light: light,
    paint: paint,
    paint_fill: paint_fill,
    "paint_fill-extrusion": {
        "fill-extrusion-opacity": {
            type: "number",
            "default": 1,
            minimum: 0,
            maximum: 1,
            doc: "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",
            transition: true,
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-color": {
            type: "color",
            "default": "#000000",
            doc: "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",
            transition: true,
            requires: [{
                "!": "fill-extrusion-pattern"
            }],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-translate": {
            type: "array",
            value: "number",
            length: 2,
            "default": [0, 0],
            transition: true,
            units: "pixels",
            doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-translate-anchor": {
            type: "enum",
            values: {
                map: {
                    doc: "The fill extrusion is translated relative to the map."
                },
                viewport: {
                    doc: "The fill extrusion is translated relative to the viewport."
                }
            },
            doc: "Controls the frame of reference for `fill-extrusion-translate`.",
            "default": "map",
            requires: ["fill-extrusion-translate"],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-pattern": {
            type: "resolvedImage",
            transition: true,
            doc: "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.49.0",
                    android: "6.5.0",
                    macos: "0.11.0",
                    ios: "4.4.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom", "feature"]
            },
            "property-type": "cross-faded-data-driven"
        },
        "fill-extrusion-height": {
            type: "number",
            "default": 0,
            minimum: 0,
            units: "meters",
            doc: "The height with which to extrude this layer.",
            transition: true,
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-base": {
            type: "number",
            "default": 0,
            minimum: 0,
            units: "meters",
            doc: "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",
            transition: true,
            requires: ["fill-extrusion-height"],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-vertical-gradient": {
            type: "boolean",
            "default": true,
            doc: "Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.",
            transition: false,
            "sdk-support": {
                "basic functionality": {
                    js: "0.50.0",
                    ios: "4.7.0",
                    macos: "0.13.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        }
    },
    paint_line: paint_line,
    paint_circle: paint_circle,
    paint_heatmap: paint_heatmap,
    paint_symbol: paint_symbol,
    paint_raster: paint_raster,
    paint_hillshade: paint_hillshade,
    paint_background: paint_background,
    transition: transition,
    "property-type": {
        "data-driven": {
            type: "property-type",
            doc: "Property is interpolable and can be represented using a property expression."
        },
        "cross-faded": {
            type: "property-type",
            doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms."
        },
        "cross-faded-data-driven": {
            type: "property-type",
            doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression."
        },
        "color-ramp": {
            type: "property-type",
            doc: "Property should be specified using a color ramp from which the output color can be sampled based on a property calculation."
        },
        "data-constant": {
            type: "property-type",
            doc: "Property is interpolable but cannot be represented using a property expression."
        },
        constant: {
            type: "property-type",
            doc: "Property is constant across all zoom levels and property values."
        }
    },
    promoteId: promoteId
};

// Note: This regex matches even invalid JSON strings, but since weâre
// working on the output of `JSON.stringify` we know that only valid strings
// are present (unless the user supplied a weird `options.indent` but in
// that case we donât care since the output would be invalid anyway).
var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;

var jsonStringifyPrettyCompact = function stringify(passedObj, options) {
    var indent, maxLength, replacer;

    options = options || {};
    indent = JSON.stringify([1], undefined, options.indent === undefined ? 2 : options.indent).slice(2, -3);
    maxLength = indent === "" ? Infinity : options.maxLength === undefined ? 80 : options.maxLength;
    replacer = options.replacer;

    return function _stringify(obj, currentIndent, reserved) {
        // prettier-ignore
        var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;

        if (obj && typeof obj.toJSON === "function") {
            obj = obj.toJSON();
        }

        string = JSON.stringify(obj, replacer);

        if (string === undefined) {
            return string;
        }

        length = maxLength - currentIndent.length - reserved;

        if (string.length <= length) {
            prettified = string.replace(stringOrChar, function (match, stringLiteral) {
                return stringLiteral || match + " ";
            });
            if (prettified.length <= length) {
                return prettified;
            }
        }

        if (replacer != null) {
            obj = JSON.parse(string);
            replacer = undefined;
        }

        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && obj !== null) {
            nextIndent = currentIndent + indent;
            items = [];
            index = 0;

            if (Array.isArray(obj)) {
                start = "[";
                end = "]";
                length = obj.length;
                for (; index < length; index++) {
                    items.push(_stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || "null");
                }
            } else {
                start = "{";
                end = "}";
                keys = Object.keys(obj);
                length = keys.length;
                for (; index < length; index++) {
                    key = keys[index];
                    keyPart = JSON.stringify(key) + ": ";
                    value = _stringify(obj[key], nextIndent, keyPart.length + (index === length - 1 ? 0 : 1));
                    if (value !== undefined) {
                        items.push(keyPart + value);
                    }
                }
            }

            if (items.length > 0) {
                return [start, indent + items.join(",\n" + nextIndent), end].join("\n" + currentIndent);
            }
        }

        return string;
    }(passedObj, "", 0);
};

function sortKeysBy(obj, reference) {
    var result = {};
    for (var key in reference) {
        if (obj[key] !== undefined) {
            result[key] = obj[key];
        }
    }
    for (var key$1 in obj) {
        if (result[key$1] === undefined) {
            result[key$1] = obj[key$1];
        }
    }
    return result;
}
function format(style, space) {
    if (space === void 0) space = 2;
    style = sortKeysBy(style, v8.$root);
    if (style.layers) {
        style.layers = style.layers.map(function (layer) {
            return sortKeysBy(layer, v8.layer);
        });
    }
    return jsonStringifyPrettyCompact(style, { indent: space });
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire() {
    throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
    return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var punycode = createCommonjsModule(function (module, exports) {
    (function (root) {

        /** Detect free variables */
        var freeExports = exports && !exports.nodeType && exports;
        var freeModule = module && !module.nodeType && module;
        var freeGlobal = (typeof commonjsGlobal === "undefined" ? "undefined" : _typeof(commonjsGlobal)) == 'object' && commonjsGlobal;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
            root = freeGlobal;
        }

        /**
         * The `punycode` object.
         * @name punycode
         * @type Object
         */
        var punycode,


        /** Highest positive signed 32-bit float value */
        maxInt = 2147483647,
            // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128,
            // 0x80
        delimiter = '-',
            // '\x2D'

        /** Regular expressions */
        regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/,
            // unprintable ASCII chars + non-ASCII chars
        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
            // RFC 3490 separators

        /** Error messages */
        errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
        },


        /** Convenience shortcuts */
        baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,


        /** Temporary variable */
        key;

        /*--------------------------------------------------------------------------*/

        /**
         * A generic error utility function.
         * @private
         * @param {String} type The error type.
         * @returns {Error} Throws a `RangeError` with the applicable error message.
         */
        function error(type) {
            throw RangeError(errors[type]);
        }

        /**
         * A generic `Array#map` utility function.
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function that gets called for every array
         * item.
         * @returns {Array} A new array of values returned by the callback function.
         */
        function map(array, fn) {
            var length = array.length;
            var result = [];
            while (length--) {
                result[length] = fn(array[length]);
            }
            return result;
        }

        /**
         * A simple `Array#map`-like wrapper to work with domain name strings or email
         * addresses.
         * @private
         * @param {String} domain The domain name or email address.
         * @param {Function} callback The function that gets called for every
         * character.
         * @returns {Array} A new string of characters returned by the callback
         * function.
         */
        function mapDomain(string, fn) {
            var parts = string.split('@');
            var result = '';
            if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@';
                string = parts[1];
            }
            // Avoid `split(regex)` for IE8 compatibility. See #17.
            string = string.replace(regexSeparators, '\x2E');
            var labels = string.split('.');
            var encoded = map(labels, fn).join('.');
            return result + encoded;
        }

        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         * @see `punycode.ucs2.encode`
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode.ucs2
         * @name decode
         * @param {String} string The Unicode input string (UCS-2).
         * @returns {Array} The new array of code points.
         */
        function ucs2decode(string) {
            var output = [],
                counter = 0,
                length = string.length,
                value,
                extra;
            while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                    // high surrogate, and there is a next character
                    extra = string.charCodeAt(counter++);
                    if ((extra & 0xFC00) == 0xDC00) {
                        // low surrogate
                        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                    } else {
                        // unmatched surrogate; only append this code unit, in case the next
                        // code unit is the high surrogate of a surrogate pair
                        output.push(value);
                        counter--;
                    }
                } else {
                    output.push(value);
                }
            }
            return output;
        }

        /**
         * Creates a string based on an array of numeric code points.
         * @see `punycode.ucs2.decode`
         * @memberOf punycode.ucs2
         * @name encode
         * @param {Array} codePoints The array of numeric code points.
         * @returns {String} The new Unicode string (UCS-2).
         */
        function ucs2encode(array) {
            return map(array, function (value) {
                var output = '';
                if (value > 0xFFFF) {
                    value -= 0x10000;
                    output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                    value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
            }).join('');
        }

        /**
         * Converts a basic code point into a digit/integer.
         * @see `digitToBasic()`
         * @private
         * @param {Number} codePoint The basic numeric code point value.
         * @returns {Number} The numeric value of a basic code point (for use in
         * representing integers) in the range `0` to `base - 1`, or `base` if
         * the code point does not represent a value.
         */
        function basicToDigit(codePoint) {
            if (codePoint - 48 < 10) {
                return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
                return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
                return codePoint - 97;
            }
            return base;
        }

        /**
         * Converts a digit/integer into a basic code point.
         * @see `basicToDigit()`
         * @private
         * @param {Number} digit The numeric value of a basic code point.
         * @returns {Number} The basic code point whose value (when used for
         * representing integers) is `digit`, which needs to be in the range
         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
         * used; else, the lowercase form is used. The behavior is undefined
         * if `flag` is non-zero and `digit` has no uppercase form.
         */
        function digitToBasic(digit, flag) {
            //  0..25 map to ASCII a..z or A..Z
            // 26..35 map to ASCII 0..9
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }

        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * http://tools.ietf.org/html/rfc3492#section-3.4
         * @private
         */
        function adapt(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }

        /**
         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
         * symbols.
         * @memberOf punycode
         * @param {String} input The Punycode string of ASCII-only symbols.
         * @returns {String} The resulting string of Unicode symbols.
         */
        function decode(input) {
            // Don't use UCS-2
            var output = [],
                inputLength = input.length,
                out,
                i = 0,
                n = initialN,
                bias = initialBias,
                basic,
                j,
                index,
                oldi,
                w,
                k,
                digit,
                t,

            /** Cached calculation results */
            baseMinusT;

            // Handle the basic code points: let `basic` be the number of input code
            // points before the last delimiter, or `0` if there is none, then copy
            // the first basic code points to the output.

            basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
                basic = 0;
            }

            for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                    error('not-basic');
                }
                output.push(input.charCodeAt(j));
            }

            // Main decoding loop: start just after the last delimiter if any basic code
            // points were copied; start at the beginning otherwise.

            for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

                    if (index >= inputLength) {
                        error('invalid-input');
                    }

                    digit = basicToDigit(input.charCodeAt(index++));

                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error('overflow');
                    }

                    i += digit * w;
                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                    if (digit < t) {
                        break;
                    }

                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                        error('overflow');
                    }

                    w *= baseMinusT;
                }

                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);

                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                    error('overflow');
                }

                n += floor(i / out);
                i %= out;

                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n);
            }

            return ucs2encode(output);
        }

        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         * @memberOf punycode
         * @param {String} input The string of Unicode symbols.
         * @returns {String} The resulting Punycode string of ASCII-only symbols.
         */
        function encode(input) {
            var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],

            /** `inputLength` will hold the number of code points in `input`. */
            inputLength,

            /** Cached calculation results */
            handledCPCountPlusOne,
                baseMinusT,
                qMinusT;

            // Convert the input in UCS-2 to Unicode
            input = ucs2decode(input);

            // Cache the length
            inputLength = input.length;

            // Initialize the state
            n = initialN;
            delta = 0;
            bias = initialBias;

            // Handle the basic code points
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue));
                }
            }

            handledCPCount = basicLength = output.length;

            // `handledCPCount` is the number of code points that have been handled;
            // `basicLength` is the number of basic code points.

            // Finish the basic string - if it is not empty - with a delimiter
            if (basicLength) {
                output.push(delimiter);
            }

            // Main encoding loop:
            while (handledCPCount < inputLength) {

                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                    }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error('overflow');
                }

                delta += (m - n) * handledCPCountPlusOne;
                n = m;

                for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];

                    if (currentValue < n && ++delta > maxInt) {
                        error('overflow');
                    }

                    if (currentValue == n) {
                        // Represent delta as a generalized variable-length integer
                        for (q = delta, k = base;; /* no condition */k += base) {
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (q < t) {
                                break;
                            }
                            qMinusT = q - t;
                            baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }

                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }

                ++delta;
                ++n;
            }
            return output.join('');
        }

        /**
         * Converts a Punycode string representing a domain name or an email address
         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
         * it doesn't matter if you call it on a string that has already been
         * converted to Unicode.
         * @memberOf punycode
         * @param {String} input The Punycoded domain name or email address to
         * convert to Unicode.
         * @returns {String} The Unicode representation of the given Punycode
         * string.
         */
        function toUnicode(input) {
            return mapDomain(input, function (string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
        }

        /**
         * Converts a Unicode string representing a domain name or an email address to
         * Punycode. Only the non-ASCII parts of the domain name will be converted,
         * i.e. it doesn't matter if you call it with a domain that's already in
         * ASCII.
         * @memberOf punycode
         * @param {String} input The domain name or email address to convert, as a
         * Unicode string.
         * @returns {String} The Punycode representation of the given domain name or
         * email address.
         */
        function toASCII(input) {
            return mapDomain(input, function (string) {
                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
            });
        }

        /*--------------------------------------------------------------------------*/

        /** Define the public API */
        punycode = {
            /**
             * A string representing the current Punycode.js version number.
             * @memberOf punycode
             * @type String
             */
            'version': '1.3.2',
            /**
             * An object of methods to convert from JavaScript's internal character
             * representation (UCS-2) to Unicode code points, and back.
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode
             * @type Object
             */
            'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
            },
            'decode': decode,
            'encode': encode,
            'toASCII': toASCII,
            'toUnicode': toUnicode
        };

        /** Expose `punycode` */
        // Some AMD build optimizers, like r.js, check for specific condition patterns
        // like the following:
        if (freeExports && freeModule) {
            if (module.exports == freeExports) {
                // in Node.js or RingoJS v0.8.0+
                freeModule.exports = punycode;
            } else {
                // in Narwhal or RingoJS v0.7.0-
                for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
            }
        } else {
            // in Rhino or a web browser
            root.punycode = punycode;
        }
    })(commonjsGlobal);
});

var util = {
    isString: function isString(arg) {
        return typeof arg === 'string';
    },
    isObject: function isObject(arg) {
        return (typeof arg === "undefined" ? "undefined" : _typeof(arg)) === 'object' && arg !== null;
    },
    isNull: function isNull(arg) {
        return arg === null;
    },
    isNullOrUndefined: function isNullOrUndefined(arg) {
        return arg == null;
    }
};

// Copyright Joyent, Inc. and other Node contributors.

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

var decode = function decode(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr,
            vstr,
            k,
            v;

        if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
        } else {
            kstr = x;
            vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
        } else if (Array.isArray(obj[k])) {
            obj[k].push(v);
        } else {
            obj[k] = [obj[k], v];
        }
    }

    return obj;
};

// Copyright Joyent, Inc. and other Node contributors.

var stringifyPrimitive = function stringifyPrimitive(v) {
    switch (typeof v === "undefined" ? "undefined" : _typeof(v)) {
        case 'string':
            return v;

        case 'boolean':
            return v ? 'true' : 'false';

        case 'number':
            return isFinite(v) ? v : '';

        default:
            return '';
    }
};

var encode = function encode(obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
        obj = undefined;
    }

    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === 'object') {
        return Object.keys(obj).map(function (k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (Array.isArray(obj[k])) {
                return obj[k].map(function (v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
            } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
        }).join(sep);
    }

    if (!name) {
        return '';
    }
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var querystring = createCommonjsModule(function (module, exports) {

    exports.decode = exports.parse = decode;
    exports.encode = exports.stringify = encode;
});
var querystring_1 = querystring.decode;
var querystring_2 = querystring.parse;
var querystring_3 = querystring.encode;
var querystring_4 = querystring.stringify;

var parse = urlParse;
var resolve = urlResolve;
var resolveObject = urlResolveObject;
var format$1 = urlFormat;

var Url_1 = Url;

function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
    'javascript': true,
    'javascript:': true
},

// protocols that never have a hostname.
hostlessProtocol = {
    'javascript': true,
    'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
};

function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && util.isObject(url) && url instanceof Url) {
        return url;
    }

    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
    if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === "undefined" ? "undefined" : _typeof(url)));
    }

    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    var queryIndex = url.indexOf('?'),
        splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
        uSplit = url.split(splitter),
        slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, '/');
    url = uSplit.join(splitter);

    var rest = url;

    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();

    if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                    this.query = querystring.parse(this.search.substr(1));
                } else {
                    this.query = this.search.substr(1);
                }
            } else if (parseQueryString) {
                this.search = '';
                this.query = {};
            }
            return this;
        }
    }

    var proto = protocolPattern.exec(rest);
    if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
    }

    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
        }
    }

    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                hostEnd = hec;
            }
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
            // atSign can be anywhere.
            atSign = rest.lastIndexOf('@');
        } else {
            // atSign must be in auth portion.
            // http://a@b/c@d => host:b auth:a path:/c@d
            atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                hostEnd = hec;
            }
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1) {
            hostEnd = rest.length;
        }

        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        this.parseHost();

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part) {
                    continue;
                }
                if (!part.match(hostnamePartPattern)) {
                    var newpart = '';
                    for (var j = 0, k = part.length; j < k; j++) {
                        if (part.charCodeAt(j) > 127) {
                            // we replace non-ASCII char with a temporary placeholder
                            // we need this to make sure size of hostname is not
                            // broken by replacing non-ASCII by nothing
                            newpart += 'x';
                        } else {
                            newpart += part[j];
                        }
                    }
                    // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                        var validParts = hostparts.slice(0, i);
                        var notHost = hostparts.slice(i + 1);
                        var bit = part.match(hostnamePartStart);
                        if (bit) {
                            validParts.push(bit[1]);
                            notHost.unshift(bit[2]);
                        }
                        if (notHost.length) {
                            rest = '/' + notHost.join('.') + rest;
                        }
                        this.hostname = validParts.join('.');
                        break;
                    }
                }
            }
        }

        if (this.hostname.length > hostnameMaxLen) {
            this.hostname = '';
        } else {
            // hostnames are always lower case.
            this.hostname = this.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
            // IDNA Support: Returns a punycoded representation of "domain".
            // It only converts parts of the domain name that
            // have non-ASCII characters, i.e. it doesn't matter if
            // you call it with a domain that already is ASCII-only.
            this.hostname = punycode.toASCII(this.hostname);
        }

        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host;

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== '/') {
                rest = '/' + rest;
            }
        }
    }

    // now rest is set to the post-host stuff.
    // chop off any delim chars.
    if (!unsafeProtocol[lowerProto]) {

        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
            var ae = autoEscape[i];
            if (rest.indexOf(ae) === -1) {
                continue;
            }
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
                esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
        }
    }

    // chop off from the tail first.
    var hash = rest.indexOf('#');
    if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
            this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
    } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
    }
    if (rest) {
        this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = '/';
    }

    //to support http.request
    if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
    }

    // finally, reconstruct the href based on what has been validated.
    this.href = this.format();
    return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
    // ensure it's an object, and not a string url.
    // If it's an obj, this is a no-op.
    // this way, you can call url_format() on strings
    // to clean up potentially wonky urls.
    if (util.isString(obj)) {
        obj = urlParse(obj);
    }
    if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
    }
    return obj.format();
}

Url.prototype.format = function () {
    var auth = this.auth || '';
    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
    }

    var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';

    if (this.host) {
        host = auth + this.host;
    } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
        if (this.port) {
            host += ':' + this.port;
        }
    }

    if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
    }

    var search = this.search || query && '?' + query || '';

    if (protocol && protocol.substr(-1) !== ':') {
        protocol += ':';
    }

    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
    // unless they had them to begin with.
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') {
            pathname = '/' + pathname;
        }
    } else if (!host) {
        host = '';
    }

    if (hash && hash.charAt(0) !== '#') {
        hash = '#' + hash;
    }
    if (search && search.charAt(0) !== '?') {
        search = '?' + search;
    }

    pathname = pathname.replace(/[?#]/g, function (match) {
        return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');

    return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
    if (!source) {
        return relative;
    }
    return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
    if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
    }

    var result = new Url();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
    }

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === '') {
        result.href = result.format();
        return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== 'protocol') {
                result[rkey] = relative[rkey];
            }
        }

        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
    }

    if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
            }
            result.href = result.format();
            return result;
        }

        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || '').split('/');
            while (relPath.length && !(relative.host = relPath.shift())) {}
            if (!relative.host) {
                relative.host = '';
            }
            if (!relative.hostname) {
                relative.hostname = '';
            }
            if (relPath[0] !== '') {
                relPath.unshift('');
            }
            if (relPath.length < 2) {
                relPath.unshift('');
            }
            result.pathname = relPath.join('/');
        } else {
            result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
            var p = result.pathname || '';
            var s = result.search || '';
            result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }

    var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
        isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
        mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
            if (srcPath[0] === '') {
                srcPath[0] = result.host;
            } else {
                srcPath.unshift(result.host);
            }
        }
        result.host = '';
        if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
                if (relPath[0] === '') {
                    relPath[0] = relative.host;
                } else {
                    relPath.unshift(relative.host);
                }
            }
            relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }

    if (isRelAbs) {
        // it's absolute.
        result.host = relative.host || relative.host === '' ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) {
            srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
    } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
    }

    if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
            result.path = '/' + result.search;
        } else {
            result.path = null;
        }
        result.href = result.format();
        return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
            srcPath.splice(i, 1);
        } else if (last === '..') {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
            srcPath.unshift('..');
        }
    }

    if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
    }

    if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
        srcPath.push('');
    }

    var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }

    mustEndAbs = mustEndAbs || result.host && srcPath.length;

    if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
    }

    if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
    } else {
        result.pathname = srcPath.join('/');
    }

    //to support request.http
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
};

Url.prototype.parseHost = function () {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
        port = port[0];
        if (port !== ':') {
            this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
    }
    if (host) {
        this.hostname = host;
    }
};

var url = {
    parse: parse,
    resolve: resolve,
    resolveObject: resolveObject,
    format: format$1,
    Url: Url_1
};

function getPropertyReference(propertyName) {
    for (var i = 0; i < v8.layout.length; i++) {
        for (var key in v8[v8.layout[i]]) {
            if (key === propertyName) {
                return v8[v8.layout[i]][key];
            }
        }
    }
    for (var i$1 = 0; i$1 < v8.paint.length; i$1++) {
        for (var key$1 in v8[v8.paint[i$1]]) {
            if (key$1 === propertyName) {
                return v8[v8.paint[i$1]][key$1];
            }
        }
    }
    return null;
}
function eachSource(style, callback) {
    for (var k in style.sources) {
        callback(style.sources[k]);
    }
}
function eachLayer(style, callback) {
    for (var i = 0, list = style.layers; i < list.length; i += 1) {
        var layer = list[i];
        callback(layer);
    }
}
function eachProperty(style, options, callback) {
    function inner(layer, propertyType) {
        var properties = layer[propertyType];
        if (!properties) {
            return;
        }
        Object.keys(properties).forEach(function (key) {
            callback({
                path: [layer.id, propertyType, key],
                key: key,
                value: properties[key],
                reference: getPropertyReference(key),
                set: function set(x) {
                    properties[key] = x;
                }
            });
        });
    }
    eachLayer(style, function (layer) {
        if (options.paint) {
            inner(layer, 'paint');
        }
        if (options.layout) {
            inner(layer, 'layout');
        }
    });
}

function eachLayout(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('layout') === 0) {
            callback(layer[k], k);
        }
    }
}
function eachPaint(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('paint') === 0) {
            callback(layer[k], k);
        }
    }
}
function resolveConstant(style, value) {
    if (typeof value === 'string' && value[0] === '@') {
        return resolveConstant(style, style.constants[value]);
    } else {
        return value;
    }
}
function isFunction(value) {
    return Array.isArray(value.stops);
}
function renameProperty(obj, from, to) {
    obj[to] = obj[from];
    delete obj[from];
}
function migrateToV8(style) {
    style.version = 8;
    eachSource(style, function (source) {
        if (source.type === 'video' && source.url !== undefined) {
            renameProperty(source, 'url', 'urls');
        }
        if (source.type === 'video') {
            source.coordinates.forEach(function (coord) {
                return coord.reverse();
            });
        }
    });
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            if (layout['symbol-min-distance'] !== undefined) {
                renameProperty(layout, 'symbol-min-distance', 'symbol-spacing');
            }
        });
        eachPaint(layer, function (paint) {
            if (paint['background-image'] !== undefined) {
                renameProperty(paint, 'background-image', 'background-pattern');
            }
            if (paint['line-image'] !== undefined) {
                renameProperty(paint, 'line-image', 'line-pattern');
            }
            if (paint['fill-image'] !== undefined) {
                renameProperty(paint, 'fill-image', 'fill-pattern');
            }
        });
    });
    eachProperty(style, {
        paint: true,
        layout: true
    }, function (property) {
        var value = resolveConstant(style, property.value);
        if (isFunction(value)) {
            value.stops.forEach(function (stop) {
                stop[1] = resolveConstant(style, stop[1]);
            });
        }
        property.set(value);
    });
    delete style.constants;
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            delete layout['text-max-size'];
            delete layout['icon-max-size'];
        });
        eachPaint(layer, function (paint) {
            if (paint['text-size']) {
                if (!layer.layout) {
                    layer.layout = {};
                }
                layer.layout['text-size'] = paint['text-size'];
                delete paint['text-size'];
            }
            if (paint['icon-size']) {
                if (!layer.layout) {
                    layer.layout = {};
                }
                layer.layout['icon-size'] = paint['icon-size'];
                delete paint['icon-size'];
            }
        });
    });
    function migrateFontstackURL(input) {
        var inputParsed = url.parse(input);
        var inputPathnameParts = inputParsed.pathname.split('/');
        if (inputParsed.protocol !== 'mapbox:') {
            return input;
        } else if (inputParsed.hostname === 'fontstack') {
            return 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf';
        } else if (inputParsed.hostname === 'fonts') {
            return 'mapbox://fonts/' + inputPathnameParts[2] + '/{fontstack}/{range}.pbf';
        }
    }
    if (style.glyphs) {
        style.glyphs = migrateFontstackURL(style.glyphs);
    }
    function migrateFontStack(font) {
        function splitAndTrim(string) {
            return string.split(',').map(function (s) {
                return s.trim();
            });
        }
        if (Array.isArray(font)) {
            return font;
        } else if (typeof font === 'string') {
            return splitAndTrim(font);
        } else if ((typeof font === "undefined" ? "undefined" : _typeof(font)) === 'object') {
            font.stops.forEach(function (stop) {
                stop[1] = splitAndTrim(stop[1]);
            });
            return font;
        } else {
            throw new Error('unexpected font value');
        }
    }
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            if (layout['text-font']) {
                layout['text-font'] = migrateFontStack(layout['text-font']);
            }
        });
    });
    var firstSymbolLayer = 0;
    for (var i = style.layers.length - 1; i >= 0; i--) {
        var layer = style.layers[i];
        if (layer.type !== 'symbol') {
            firstSymbolLayer = i + 1;
            break;
        }
    }
    var symbolLayers = style.layers.splice(firstSymbolLayer);
    symbolLayers.reverse();
    style.layers = style.layers.concat(symbolLayers);
    return style;
}

function extend(output) {
    var inputs = [],
        len = arguments.length - 1;
    while (len-- > 0) {
        inputs[len] = arguments[len + 1];
    }for (var i = 0, list = inputs; i < list.length; i += 1) {
        var input = list[i];
        for (var k in input) {
            output[k] = input[k];
        }
    }
    return output;
}

var ParsingError = function (Error) {
    function ParsingError(key, message) {
        Error.call(this, message);
        this.message = message;
        this.key = key;
    }
    if (Error) ParsingError.__proto__ = Error;
    ParsingError.prototype = Object.create(Error && Error.prototype);
    ParsingError.prototype.constructor = ParsingError;
    return ParsingError;
}(Error);

var Scope = function Scope(parent, bindings) {
    if (bindings === void 0) bindings = [];
    this.parent = parent;
    this.bindings = {};
    for (var i = 0, list = bindings; i < list.length; i += 1) {
        var ref = list[i];
        var name = ref[0];
        var expression = ref[1];
        this.bindings[name] = expression;
    }
};
Scope.prototype.concat = function concat(bindings) {
    return new Scope(this, bindings);
};
Scope.prototype.get = function get(name) {
    if (this.bindings[name]) {
        return this.bindings[name];
    }
    if (this.parent) {
        return this.parent.get(name);
    }
    throw new Error(name + ' not found in scope.');
};
Scope.prototype.has = function has(name) {
    if (this.bindings[name]) {
        return true;
    }
    return this.parent ? this.parent.has(name) : false;
};

var NullType = { kind: 'null' };
var NumberType = { kind: 'number' };
var StringType = { kind: 'string' };
var BooleanType = { kind: 'boolean' };
var ColorType = { kind: 'color' };
var ObjectType = { kind: 'object' };
var ValueType = { kind: 'value' };
var ErrorType = { kind: 'error' };
var CollatorType = { kind: 'collator' };
var FormattedType = { kind: 'formatted' };
var ResolvedImageType = { kind: 'resolvedImage' };
function array(itemType, N) {
    return {
        kind: 'array',
        itemType: itemType,
        N: N
    };
}
function toString(type) {
    if (type.kind === 'array') {
        var itemType = toString(type.itemType);
        return typeof type.N === 'number' ? 'array<' + itemType + ', ' + type.N + '>' : type.itemType.kind === 'value' ? 'array' : 'array<' + itemType + '>';
    } else {
        return type.kind;
    }
}
var valueMemberTypes = [NullType, NumberType, StringType, BooleanType, ColorType, FormattedType, ObjectType, array(ValueType), ResolvedImageType];
function checkSubtype(expected, t) {
    if (t.kind === 'error') {
        return null;
    } else if (expected.kind === 'array') {
        if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {
            return null;
        }
    } else if (expected.kind === t.kind) {
        return null;
    } else if (expected.kind === 'value') {
        for (var i = 0, list = valueMemberTypes; i < list.length; i += 1) {
            var memberType = list[i];
            if (!checkSubtype(memberType, t)) {
                return null;
            }
        }
    }
    return 'Expected ' + toString(expected) + ' but found ' + toString(t) + ' instead.';
}
function isValidType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
        return t.kind === provided.kind;
    });
}
function isValidNativeType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
        if (t === 'null') {
            return provided === null;
        } else if (t === 'array') {
            return Array.isArray(provided);
        } else if (t === 'object') {
            return provided && !Array.isArray(provided) && (typeof provided === "undefined" ? "undefined" : _typeof(provided)) === 'object';
        } else {
            return t === (typeof provided === "undefined" ? "undefined" : _typeof(provided));
        }
    });
}

var csscolorparser = createCommonjsModule(function (module, exports) {
    // (c) Dean McNamee <dean@gmail.com>, 2012.
    //
    // https://github.com/deanm/css-color-parser-js
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to
    // deal in the Software without restriction, including without limitation the
    // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    // sell copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    // IN THE SOFTWARE.

    // http://www.w3.org/TR/css3-color/
    var kCSSColorTable = {
        "transparent": [0, 0, 0, 0], "aliceblue": [240, 248, 255, 1],
        "antiquewhite": [250, 235, 215, 1], "aqua": [0, 255, 255, 1],
        "aquamarine": [127, 255, 212, 1], "azure": [240, 255, 255, 1],
        "beige": [245, 245, 220, 1], "bisque": [255, 228, 196, 1],
        "black": [0, 0, 0, 1], "blanchedalmond": [255, 235, 205, 1],
        "blue": [0, 0, 255, 1], "blueviolet": [138, 43, 226, 1],
        "brown": [165, 42, 42, 1], "burlywood": [222, 184, 135, 1],
        "cadetblue": [95, 158, 160, 1], "chartreuse": [127, 255, 0, 1],
        "chocolate": [210, 105, 30, 1], "coral": [255, 127, 80, 1],
        "cornflowerblue": [100, 149, 237, 1], "cornsilk": [255, 248, 220, 1],
        "crimson": [220, 20, 60, 1], "cyan": [0, 255, 255, 1],
        "darkblue": [0, 0, 139, 1], "darkcyan": [0, 139, 139, 1],
        "darkgoldenrod": [184, 134, 11, 1], "darkgray": [169, 169, 169, 1],
        "darkgreen": [0, 100, 0, 1], "darkgrey": [169, 169, 169, 1],
        "darkkhaki": [189, 183, 107, 1], "darkmagenta": [139, 0, 139, 1],
        "darkolivegreen": [85, 107, 47, 1], "darkorange": [255, 140, 0, 1],
        "darkorchid": [153, 50, 204, 1], "darkred": [139, 0, 0, 1],
        "darksalmon": [233, 150, 122, 1], "darkseagreen": [143, 188, 143, 1],
        "darkslateblue": [72, 61, 139, 1], "darkslategray": [47, 79, 79, 1],
        "darkslategrey": [47, 79, 79, 1], "darkturquoise": [0, 206, 209, 1],
        "darkviolet": [148, 0, 211, 1], "deeppink": [255, 20, 147, 1],
        "deepskyblue": [0, 191, 255, 1], "dimgray": [105, 105, 105, 1],
        "dimgrey": [105, 105, 105, 1], "dodgerblue": [30, 144, 255, 1],
        "firebrick": [178, 34, 34, 1], "floralwhite": [255, 250, 240, 1],
        "forestgreen": [34, 139, 34, 1], "fuchsia": [255, 0, 255, 1],
        "gainsboro": [220, 220, 220, 1], "ghostwhite": [248, 248, 255, 1],
        "gold": [255, 215, 0, 1], "goldenrod": [218, 165, 32, 1],
        "gray": [128, 128, 128, 1], "green": [0, 128, 0, 1],
        "greenyellow": [173, 255, 47, 1], "grey": [128, 128, 128, 1],
        "honeydew": [240, 255, 240, 1], "hotpink": [255, 105, 180, 1],
        "indianred": [205, 92, 92, 1], "indigo": [75, 0, 130, 1],
        "ivory": [255, 255, 240, 1], "khaki": [240, 230, 140, 1],
        "lavender": [230, 230, 250, 1], "lavenderblush": [255, 240, 245, 1],
        "lawngreen": [124, 252, 0, 1], "lemonchiffon": [255, 250, 205, 1],
        "lightblue": [173, 216, 230, 1], "lightcoral": [240, 128, 128, 1],
        "lightcyan": [224, 255, 255, 1], "lightgoldenrodyellow": [250, 250, 210, 1],
        "lightgray": [211, 211, 211, 1], "lightgreen": [144, 238, 144, 1],
        "lightgrey": [211, 211, 211, 1], "lightpink": [255, 182, 193, 1],
        "lightsalmon": [255, 160, 122, 1], "lightseagreen": [32, 178, 170, 1],
        "lightskyblue": [135, 206, 250, 1], "lightslategray": [119, 136, 153, 1],
        "lightslategrey": [119, 136, 153, 1], "lightsteelblue": [176, 196, 222, 1],
        "lightyellow": [255, 255, 224, 1], "lime": [0, 255, 0, 1],
        "limegreen": [50, 205, 50, 1], "linen": [250, 240, 230, 1],
        "magenta": [255, 0, 255, 1], "maroon": [128, 0, 0, 1],
        "mediumaquamarine": [102, 205, 170, 1], "mediumblue": [0, 0, 205, 1],
        "mediumorchid": [186, 85, 211, 1], "mediumpurple": [147, 112, 219, 1],
        "mediumseagreen": [60, 179, 113, 1], "mediumslateblue": [123, 104, 238, 1],
        "mediumspringgreen": [0, 250, 154, 1], "mediumturquoise": [72, 209, 204, 1],
        "mediumvioletred": [199, 21, 133, 1], "midnightblue": [25, 25, 112, 1],
        "mintcream": [245, 255, 250, 1], "mistyrose": [255, 228, 225, 1],
        "moccasin": [255, 228, 181, 1], "navajowhite": [255, 222, 173, 1],
        "navy": [0, 0, 128, 1], "oldlace": [253, 245, 230, 1],
        "olive": [128, 128, 0, 1], "olivedrab": [107, 142, 35, 1],
        "orange": [255, 165, 0, 1], "orangered": [255, 69, 0, 1],
        "orchid": [218, 112, 214, 1], "palegoldenrod": [238, 232, 170, 1],
        "palegreen": [152, 251, 152, 1], "paleturquoise": [175, 238, 238, 1],
        "palevioletred": [219, 112, 147, 1], "papayawhip": [255, 239, 213, 1],
        "peachpuff": [255, 218, 185, 1], "peru": [205, 133, 63, 1],
        "pink": [255, 192, 203, 1], "plum": [221, 160, 221, 1],
        "powderblue": [176, 224, 230, 1], "purple": [128, 0, 128, 1],
        "rebeccapurple": [102, 51, 153, 1],
        "red": [255, 0, 0, 1], "rosybrown": [188, 143, 143, 1],
        "royalblue": [65, 105, 225, 1], "saddlebrown": [139, 69, 19, 1],
        "salmon": [250, 128, 114, 1], "sandybrown": [244, 164, 96, 1],
        "seagreen": [46, 139, 87, 1], "seashell": [255, 245, 238, 1],
        "sienna": [160, 82, 45, 1], "silver": [192, 192, 192, 1],
        "skyblue": [135, 206, 235, 1], "slateblue": [106, 90, 205, 1],
        "slategray": [112, 128, 144, 1], "slategrey": [112, 128, 144, 1],
        "snow": [255, 250, 250, 1], "springgreen": [0, 255, 127, 1],
        "steelblue": [70, 130, 180, 1], "tan": [210, 180, 140, 1],
        "teal": [0, 128, 128, 1], "thistle": [216, 191, 216, 1],
        "tomato": [255, 99, 71, 1], "turquoise": [64, 224, 208, 1],
        "violet": [238, 130, 238, 1], "wheat": [245, 222, 179, 1],
        "white": [255, 255, 255, 1], "whitesmoke": [245, 245, 245, 1],
        "yellow": [255, 255, 0, 1], "yellowgreen": [154, 205, 50, 1] };

    function clamp_css_byte(i) {
        // Clamp to integer 0 .. 255.
        i = Math.round(i); // Seems to be what Chrome does (vs truncation).
        return i < 0 ? 0 : i > 255 ? 255 : i;
    }

    function clamp_css_float(f) {
        // Clamp to float 0.0 .. 1.0.
        return f < 0 ? 0 : f > 1 ? 1 : f;
    }

    function parse_css_int(str) {
        // int or percentage.
        if (str[str.length - 1] === '%') {
            return clamp_css_byte(parseFloat(str) / 100 * 255);
        }
        return clamp_css_byte(parseInt(str));
    }

    function parse_css_float(str) {
        // float or percentage.
        if (str[str.length - 1] === '%') {
            return clamp_css_float(parseFloat(str) / 100);
        }
        return clamp_css_float(parseFloat(str));
    }

    function css_hue_to_rgb(m1, m2, h) {
        if (h < 0) {
            h += 1;
        } else if (h > 1) {
            h -= 1;
        }

        if (h * 6 < 1) {
            return m1 + (m2 - m1) * h * 6;
        }
        if (h * 2 < 1) {
            return m2;
        }
        if (h * 3 < 2) {
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        }
        return m1;
    }

    function parseCSSColor(css_str) {
        // Remove all whitespace, not compliant, but should just be more accepting.
        var str = css_str.replace(/ /g, '').toLowerCase();

        // Color keywords (and transparent) lookup.
        if (str in kCSSColorTable) {
            return kCSSColorTable[str].slice();
        } // dup.

        // #abc and #abc123 syntax.
        if (str[0] === '#') {
            if (str.length === 4) {
                var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xfff)) {
                    return null;
                } // Covers NaN.
                return [(iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1];
            } else if (str.length === 7) {
                var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xffffff)) {
                    return null;
                } // Covers NaN.
                return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];
            }

            return null;
        }

        var op = str.indexOf('('),
            ep = str.indexOf(')');
        if (op !== -1 && ep + 1 === str.length) {
            var fname = str.substr(0, op);
            var params = str.substr(op + 1, ep - (op + 1)).split(',');
            var alpha = 1; // To allow case fallthrough.
            switch (fname) {
                case 'rgba':
                    if (params.length !== 4) {
                        return null;
                    }
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'rgb':
                    if (params.length !== 3) {
                        return null;
                    }
                    return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];
                case 'hsla':
                    if (params.length !== 4) {
                        return null;
                    }
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'hsl':
                    if (params.length !== 3) {
                        return null;
                    }
                    var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1
                    // NOTE(deanm): According to the CSS spec s/l should only be
                    // percentages, but we don't bother and let float or percentage.
                    var s = parse_css_float(params[1]);
                    var l = parse_css_float(params[2]);
                    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                    var m1 = l * 2 - m2;
                    return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];
                default:
                    return null;
            }
        }

        return null;
    }

    try {
        exports.parseCSSColor = parseCSSColor;
    } catch (e) {}
});
var csscolorparser_1 = csscolorparser.parseCSSColor;

var Color = function Color(r, g, b, a) {
    if (a === void 0) a = 1;
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
};
Color.parse = function parse(input) {
    if (!input) {
        return undefined;
    }
    if (input instanceof Color) {
        return input;
    }
    if (typeof input !== 'string') {
        return undefined;
    }
    var rgba = csscolorparser_1(input);
    if (!rgba) {
        return undefined;
    }
    return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
};
Color.prototype.toString = function toString() {
    var ref = this.toArray();
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    return 'rgba(' + Math.round(r) + ',' + Math.round(g) + ',' + Math.round(b) + ',' + a + ')';
};
Color.prototype.toArray = function toArray() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var a = ref.a;
    return a === 0 ? [0, 0, 0, 0] : [r * 255 / a, g * 255 / a, b * 255 / a, a];
};
Color.black = new Color(0, 0, 0, 1);
Color.white = new Color(1, 1, 1, 1);
Color.transparent = new Color(0, 0, 0, 0);
Color.red = new Color(1, 0, 0, 1);

var Collator = function Collator(caseSensitive, diacriticSensitive, locale) {
    if (caseSensitive) {
        this.sensitivity = diacriticSensitive ? 'variant' : 'case';
    } else {
        this.sensitivity = diacriticSensitive ? 'accent' : 'base';
    }
    this.locale = locale;
    this.collator = new Intl.Collator(this.locale ? this.locale : [], {
        sensitivity: this.sensitivity,
        usage: 'search'
    });
};
Collator.prototype.compare = function compare(lhs, rhs) {
    return this.collator.compare(lhs, rhs);
};
Collator.prototype.resolvedLocale = function resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
};

var FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {
    this.text = text;
    this.image = image;
    this.scale = scale;
    this.fontStack = fontStack;
    this.textColor = textColor;
};
var Formatted = function Formatted(sections) {
    this.sections = sections;
};
Formatted.fromString = function fromString(unformatted) {
    return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);
};
Formatted.prototype.isEmpty = function isEmpty() {
    if (this.sections.length === 0) {
        return true;
    }
    return !this.sections.some(function (section) {
        return section.text.length !== 0 || section.image && section.image.name.length !== 0;
    });
};
Formatted.factory = function factory(text) {
    if (text instanceof Formatted) {
        return text;
    } else {
        return Formatted.fromString(text);
    }
};
Formatted.prototype.toString = function toString() {
    if (this.sections.length === 0) {
        return '';
    }
    return this.sections.map(function (section) {
        return section.text;
    }).join('');
};
Formatted.prototype.serialize = function serialize() {
    var serialized = ['format'];
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        if (section.image) {
            serialized.push(['image', section.image.name]);
            continue;
        }
        serialized.push(section.text);
        var options = {};
        if (section.fontStack) {
            options['text-font'] = ['literal', section.fontStack.split(',')];
        }
        if (section.scale) {
            options['font-scale'] = section.scale;
        }
        if (section.textColor) {
            options['text-color'] = ['rgba'].concat(section.textColor.toArray());
        }
        serialized.push(options);
    }
    return serialized;
};

var ResolvedImage = function ResolvedImage(options) {
    this.name = options.name;
    this.available = options.available;
};
ResolvedImage.prototype.toString = function toString() {
    return this.name;
};
ResolvedImage.fromString = function fromString(name) {
    if (!name) {
        return null;
    }
    return new ResolvedImage({
        name: name,
        available: false
    });
};
ResolvedImage.prototype.serialize = function serialize() {
    return ['image', this.name];
};

function validateRGBA(r, g, b, a) {
    if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {
        var value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];
        return 'Invalid rgba value [' + value.join(', ') + ']: \'r\', \'g\', and \'b\' must be between 0 and 255.';
    }
    if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {
        return 'Invalid rgba value [' + [r, g, b, a].join(', ') + ']: \'a\' must be between 0 and 1.';
    }
    return null;
}
function isValue(mixed) {
    if (mixed === null) {
        return true;
    } else if (typeof mixed === 'string') {
        return true;
    } else if (typeof mixed === 'boolean') {
        return true;
    } else if (typeof mixed === 'number') {
        return true;
    } else if (mixed instanceof Color) {
        return true;
    } else if (mixed instanceof Collator) {
        return true;
    } else if (mixed instanceof Formatted) {
        return true;
    } else if (mixed instanceof ResolvedImage) {
        return true;
    } else if (Array.isArray(mixed)) {
        for (var i = 0, list = mixed; i < list.length; i += 1) {
            var item = list[i];
            if (!isValue(item)) {
                return false;
            }
        }
        return true;
    } else if ((typeof mixed === "undefined" ? "undefined" : _typeof(mixed)) === 'object') {
        for (var key in mixed) {
            if (!isValue(mixed[key])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
function typeOf(value) {
    if (value === null) {
        return NullType;
    } else if (typeof value === 'string') {
        return StringType;
    } else if (typeof value === 'boolean') {
        return BooleanType;
    } else if (typeof value === 'number') {
        return NumberType;
    } else if (value instanceof Color) {
        return ColorType;
    } else if (value instanceof Collator) {
        return CollatorType;
    } else if (value instanceof Formatted) {
        return FormattedType;
    } else if (value instanceof ResolvedImage) {
        return ResolvedImageType;
    } else if (Array.isArray(value)) {
        var length = value.length;
        var itemType;
        for (var i = 0, list = value; i < list.length; i += 1) {
            var item = list[i];
            var t = typeOf(item);
            if (!itemType) {
                itemType = t;
            } else if (itemType === t) {
                continue;
            } else {
                itemType = ValueType;
                break;
            }
        }
        return array(itemType || ValueType, length);
    } else {
        return ObjectType;
    }
}
function toString$1(value) {
    var type = typeof value === "undefined" ? "undefined" : _typeof(value);
    if (value === null) {
        return '';
    } else if (type === 'string' || type === 'number' || type === 'boolean') {
        return String(value);
    } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {
        return value.toString();
    } else {
        return JSON.stringify(value);
    }
}

var Literal = function Literal(type, value) {
    this.type = type;
    this.value = value;
};
Literal.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('\'literal\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');
    }
    if (!isValue(args[1])) {
        return context.error('invalid value');
    }
    var value = args[1];
    var type = typeOf(value);
    var expected = context.expectedType;
    if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {
        type = expected;
    }
    return new Literal(type, value);
};
Literal.prototype.evaluate = function evaluate() {
    return this.value;
};
Literal.prototype.eachChild = function eachChild() {};
Literal.prototype.outputDefined = function outputDefined() {
    return true;
};
Literal.prototype.serialize = function serialize() {
    if (this.type.kind === 'array' || this.type.kind === 'object') {
        return ['literal', this.value];
    } else if (this.value instanceof Color) {
        return ['rgba'].concat(this.value.toArray());
    } else if (this.value instanceof Formatted) {
        return this.value.serialize();
    } else {
        return this.value;
    }
};

var RuntimeError = function RuntimeError(message) {
    this.name = 'ExpressionEvaluationError';
    this.message = message;
};
RuntimeError.prototype.toJSON = function toJSON() {
    return this.message;
};

var types = {
    string: StringType,
    number: NumberType,
    boolean: BooleanType,
    object: ObjectType
};
var Assertion = function Assertion(type, args) {
    this.type = type;
    this.args = args;
};
Assertion.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var i = 1;
    var type;
    var name = args[0];
    if (name === 'array') {
        var itemType;
        if (args.length > 2) {
            var type$1 = args[1];
            if (typeof type$1 !== 'string' || !(type$1 in types) || type$1 === 'object') {
                return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
            }
            itemType = types[type$1];
            i++;
        } else {
            itemType = ValueType;
        }
        var N;
        if (args.length > 3) {
            if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
                return context.error('The length argument to "array" must be a positive integer literal', 2);
            }
            N = args[2];
            i++;
        }
        type = array(itemType, N);
    } else {
        type = types[name];
    }
    var parsed = [];
    for (; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) {
            return null;
        }
        parsed.push(input);
    }
    return new Assertion(type, parsed);
};
Assertion.prototype.evaluate = function evaluate(ctx) {
    for (var i = 0; i < this.args.length; i++) {
        var value = this.args[i].evaluate(ctx);
        var error = checkSubtype(this.type, typeOf(value));
        if (!error) {
            return value;
        } else if (i === this.args.length - 1) {
            throw new RuntimeError('Expected value to be of type ' + toString(this.type) + ', but found ' + toString(typeOf(value)) + ' instead.');
        }
    }
    return null;
};
Assertion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Assertion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Assertion.prototype.serialize = function serialize() {
    var type = this.type;
    var serialized = [type.kind];
    if (type.kind === 'array') {
        var itemType = type.itemType;
        if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {
            serialized.push(itemType.kind);
            var N = type.N;
            if (typeof N === 'number' || this.args.length > 1) {
                serialized.push(N);
            }
        }
    }
    return serialized.concat(this.args.map(function (arg) {
        return arg.serialize();
    }));
};

var FormatExpression = function FormatExpression(sections) {
    this.type = FormattedType;
    this.sections = sections;
};
FormatExpression.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var firstArg = args[1];
    if (!Array.isArray(firstArg) && (typeof firstArg === "undefined" ? "undefined" : _typeof(firstArg)) === 'object') {
        return context.error('First argument must be an image or text section.');
    }
    var sections = [];
    var nextTokenMayBeObject = false;
    for (var i = 1; i <= args.length - 1; ++i) {
        var arg = args[i];
        if (nextTokenMayBeObject && (typeof arg === "undefined" ? "undefined" : _typeof(arg)) === 'object' && !Array.isArray(arg)) {
            nextTokenMayBeObject = false;
            var scale = null;
            if (arg['font-scale']) {
                scale = context.parse(arg['font-scale'], 1, NumberType);
                if (!scale) {
                    return null;
                }
            }
            var font = null;
            if (arg['text-font']) {
                font = context.parse(arg['text-font'], 1, array(StringType));
                if (!font) {
                    return null;
                }
            }
            var textColor = null;
            if (arg['text-color']) {
                textColor = context.parse(arg['text-color'], 1, ColorType);
                if (!textColor) {
                    return null;
                }
            }
            var lastExpression = sections[sections.length - 1];
            lastExpression.scale = scale;
            lastExpression.font = font;
            lastExpression.textColor = textColor;
        } else {
            var content = context.parse(args[i], 1, ValueType);
            if (!content) {
                return null;
            }
            var kind = content.type.kind;
            if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage') {
                return context.error('Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.');
            }
            nextTokenMayBeObject = true;
            sections.push({
                content: content,
                scale: null,
                font: null,
                textColor: null
            });
        }
    }
    return new FormatExpression(sections);
};
FormatExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluateSection = function evaluateSection(section) {
        var evaluatedContent = section.content.evaluate(ctx);
        if (typeOf(evaluatedContent) === ResolvedImageType) {
            return new FormattedSection('', evaluatedContent, null, null, null);
        }
        return new FormattedSection(toString$1(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);
    };
    return new Formatted(this.sections.map(evaluateSection));
};
FormatExpression.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        fn(section.content);
        if (section.scale) {
            fn(section.scale);
        }
        if (section.font) {
            fn(section.font);
        }
        if (section.textColor) {
            fn(section.textColor);
        }
    }
};
FormatExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
FormatExpression.prototype.serialize = function serialize() {
    var serialized = ['format'];
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        serialized.push(section.content.serialize());
        var options = {};
        if (section.scale) {
            options['font-scale'] = section.scale.serialize();
        }
        if (section.font) {
            options['text-font'] = section.font.serialize();
        }
        if (section.textColor) {
            options['text-color'] = section.textColor.serialize();
        }
        serialized.push(options);
    }
    return serialized;
};

var ImageExpression = function ImageExpression(input) {
    this.type = ResolvedImageType;
    this.input = input;
};
ImageExpression.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected two arguments.');
    }
    var name = context.parse(args[1], 1, StringType);
    if (!name) {
        return context.error('No image name provided.');
    }
    return new ImageExpression(name);
};
ImageExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluatedImageName = this.input.evaluate(ctx);
    var value = ResolvedImage.fromString(evaluatedImageName);
    if (value && ctx.availableImages) {
        value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
    }
    return value;
};
ImageExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
};
ImageExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
ImageExpression.prototype.serialize = function serialize() {
    return ['image', this.input.serialize()];
};

var types$1 = {
    'to-boolean': BooleanType,
    'to-color': ColorType,
    'to-number': NumberType,
    'to-string': StringType
};
var Coercion = function Coercion(type, args) {
    this.type = type;
    this.args = args;
};
Coercion.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var name = args[0];
    if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2) {
        return context.error('Expected one argument.');
    }
    var type = types$1[name];
    var parsed = [];
    for (var i = 1; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) {
            return null;
        }
        parsed.push(input);
    }
    return new Coercion(type, parsed);
};
Coercion.prototype.evaluate = function evaluate(ctx) {
    if (this.type.kind === 'boolean') {
        return Boolean(this.args[0].evaluate(ctx));
    } else if (this.type.kind === 'color') {
        var input;
        var error;
        for (var i = 0, list = this.args; i < list.length; i += 1) {
            var arg = list[i];
            input = arg.evaluate(ctx);
            error = null;
            if (input instanceof Color) {
                return input;
            } else if (typeof input === 'string') {
                var c = ctx.parseColor(input);
                if (c) {
                    return c;
                }
            } else if (Array.isArray(input)) {
                if (input.length < 3 || input.length > 4) {
                    error = 'Invalid rbga value ' + JSON.stringify(input) + ': expected an array containing either three or four numeric values.';
                } else {
                    error = validateRGBA(input[0], input[1], input[2], input[3]);
                }
                if (!error) {
                    return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
                }
            }
        }
        throw new RuntimeError(error || 'Could not parse color from value \'' + (typeof input === 'string' ? input : String(JSON.stringify(input))) + '\'');
    } else if (this.type.kind === 'number') {
        var value = null;
        for (var i$1 = 0, list$1 = this.args; i$1 < list$1.length; i$1 += 1) {
            var arg$1 = list$1[i$1];
            value = arg$1.evaluate(ctx);
            if (value === null) {
                return 0;
            }
            var num = Number(value);
            if (isNaN(num)) {
                continue;
            }
            return num;
        }
        throw new RuntimeError('Could not convert ' + JSON.stringify(value) + ' to number.');
    } else if (this.type.kind === 'formatted') {
        return Formatted.fromString(toString$1(this.args[0].evaluate(ctx)));
    } else if (this.type.kind === 'resolvedImage') {
        return ResolvedImage.fromString(toString$1(this.args[0].evaluate(ctx)));
    } else {
        return toString$1(this.args[0].evaluate(ctx));
    }
};
Coercion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Coercion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Coercion.prototype.serialize = function serialize() {
    if (this.type.kind === 'formatted') {
        return new FormatExpression([{
            content: this.args[0],
            scale: null,
            font: null,
            textColor: null
        }]).serialize();
    }
    if (this.type.kind === 'resolvedImage') {
        return new ImageExpression(this.args[0]).serialize();
    }
    var serialized = ['to-' + this.type.kind];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];
var EvaluationContext = function EvaluationContext() {
    this.globals = null;
    this.feature = null;
    this.featureState = null;
    this.formattedSection = null;
    this._parseColorCache = {};
    this.availableImages = null;
    this.canonical = null;
};
EvaluationContext.prototype.id = function id() {
    return this.feature && 'id' in this.feature ? this.feature.id : null;
};
EvaluationContext.prototype.geometryType = function geometryType() {
    return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
};
EvaluationContext.prototype.geometry = function geometry() {
    return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
};
EvaluationContext.prototype.canonicalID = function canonicalID() {
    return this.canonical;
};
EvaluationContext.prototype.properties = function properties() {
    return this.feature && this.feature.properties || {};
};
EvaluationContext.prototype.parseColor = function parseColor(input) {
    var cached = this._parseColorCache[input];
    if (!cached) {
        cached = this._parseColorCache[input] = Color.parse(input);
    }
    return cached;
};

var CompoundExpression = function CompoundExpression(name, type, evaluate, args) {
    this.name = name;
    this.type = type;
    this._evaluate = evaluate;
    this.args = args;
};
CompoundExpression.prototype.evaluate = function evaluate(ctx) {
    return this._evaluate(ctx, this.args);
};
CompoundExpression.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
CompoundExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
CompoundExpression.prototype.serialize = function serialize() {
    return [this.name].concat(this.args.map(function (arg) {
        return arg.serialize();
    }));
};
CompoundExpression.parse = function parse(args, context) {
    var ref$1;
    var op = args[0];
    var definition = CompoundExpression.definitions[op];
    if (!definition) {
        return context.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
    }
    var type = Array.isArray(definition) ? definition[0] : definition.type;
    var availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;
    var overloads = availableOverloads.filter(function (ref) {
        var signature = ref[0];
        return !Array.isArray(signature) || signature.length === args.length - 1;
    });
    var signatureContext = null;
    for (var i$3 = 0, list = overloads; i$3 < list.length; i$3 += 1) {
        var ref = list[i$3];
        var params = ref[0];
        var evaluate = ref[1];
        signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);
        var parsedArgs = [];
        var argParseFailed = false;
        for (var i = 1; i < args.length; i++) {
            var arg = args[i];
            var expectedType = Array.isArray(params) ? params[i - 1] : params.type;
            var parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
            if (!parsed) {
                argParseFailed = true;
                break;
            }
            parsedArgs.push(parsed);
        }
        if (argParseFailed) {
            continue;
        }
        if (Array.isArray(params)) {
            if (params.length !== parsedArgs.length) {
                signatureContext.error('Expected ' + params.length + ' arguments, but found ' + parsedArgs.length + ' instead.');
                continue;
            }
        }
        for (var i$1 = 0; i$1 < parsedArgs.length; i$1++) {
            var expected = Array.isArray(params) ? params[i$1] : params.type;
            var arg$1 = parsedArgs[i$1];
            signatureContext.concat(i$1 + 1).checkSubtype(expected, arg$1.type);
        }
        if (signatureContext.errors.length === 0) {
            return new CompoundExpression(op, type, evaluate, parsedArgs);
        }
    }
    if (overloads.length === 1) {
        (ref$1 = context.errors).push.apply(ref$1, signatureContext.errors);
    } else {
        var expected$1 = overloads.length ? overloads : availableOverloads;
        var signatures = expected$1.map(function (ref) {
            var params = ref[0];
            return stringifySignature(params);
        }).join(' | ');
        var actualTypes = [];
        for (var i$2 = 1; i$2 < args.length; i$2++) {
            var parsed$1 = context.parse(args[i$2], 1 + actualTypes.length);
            if (!parsed$1) {
                return null;
            }
            actualTypes.push(toString(parsed$1.type));
        }
        context.error('Expected arguments of type ' + signatures + ', but found (' + actualTypes.join(', ') + ') instead.');
    }
    return null;
};
CompoundExpression.register = function register(registry, definitions) {
    CompoundExpression.definitions = definitions;
    for (var name in definitions) {
        registry[name] = CompoundExpression;
    }
};
function stringifySignature(signature) {
    if (Array.isArray(signature)) {
        return '(' + signature.map(toString).join(', ') + ')';
    } else {
        return '(' + toString(signature.type) + '...)';
    }
}

var CollatorExpression = function CollatorExpression(caseSensitive, diacriticSensitive, locale) {
    this.type = CollatorType;
    this.locale = locale;
    this.caseSensitive = caseSensitive;
    this.diacriticSensitive = diacriticSensitive;
};
CollatorExpression.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected one argument.');
    }
    var options = args[1];
    if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== 'object' || Array.isArray(options)) {
        return context.error('Collator options argument must be an object.');
    }
    var caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);
    if (!caseSensitive) {
        return null;
    }
    var diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);
    if (!diacriticSensitive) {
        return null;
    }
    var locale = null;
    if (options['locale']) {
        locale = context.parse(options['locale'], 1, StringType);
        if (!locale) {
            return null;
        }
    }
    return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
};
CollatorExpression.prototype.evaluate = function evaluate(ctx) {
    return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
};
CollatorExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.caseSensitive);
    fn(this.diacriticSensitive);
    if (this.locale) {
        fn(this.locale);
    }
};
CollatorExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
CollatorExpression.prototype.serialize = function serialize() {
    var options = {};
    options['case-sensitive'] = this.caseSensitive.serialize();
    options['diacritic-sensitive'] = this.diacriticSensitive.serialize();
    if (this.locale) {
        options['locale'] = this.locale.serialize();
    }
    return ['collator', options];
};

var EXTENT = 8192;
function updateBBox(bbox, coord) {
    bbox[0] = Math.min(bbox[0], coord[0]);
    bbox[1] = Math.min(bbox[1], coord[1]);
    bbox[2] = Math.max(bbox[2], coord[0]);
    bbox[3] = Math.max(bbox[3], coord[1]);
}
function mercatorXfromLng(lng) {
    return (180 + lng) / 360;
}
function mercatorYfromLat(lat) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function boxWithinBox(bbox1, bbox2) {
    if (bbox1[0] <= bbox2[0]) {
        return false;
    }
    if (bbox1[2] >= bbox2[2]) {
        return false;
    }
    if (bbox1[1] <= bbox2[1]) {
        return false;
    }
    if (bbox1[3] >= bbox2[3]) {
        return false;
    }
    return true;
}
function getTileCoordinates(p, canonical) {
    var x = mercatorXfromLng(p[0]);
    var y = mercatorYfromLat(p[1]);
    var tilesAtZoom = Math.pow(2, canonical.z);
    return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];
}
function onBoundary(p, p1, p2) {
    var x1 = p[0] - p1[0];
    var y1 = p[1] - p1[1];
    var x2 = p[0] - p2[0];
    var y2 = p[1] - p2[1];
    return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
}
function rayIntersect(p, p1, p2) {
    return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
}
function pointWithinPolygon(point, rings) {
    var inside = false;
    for (var i = 0, len = rings.length; i < len; i++) {
        var ring = rings[i];
        for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {
            if (onBoundary(point, ring[j], ring[j + 1])) {
                return false;
            }
            if (rayIntersect(point, ring[j], ring[j + 1])) {
                inside = !inside;
            }
        }
    }
    return inside;
}
function pointWithinPolygons(point, polygons) {
    for (var i = 0; i < polygons.length; i++) {
        if (pointWithinPolygon(point, polygons[i])) {
            return true;
        }
    }
    return false;
}
function perp(v1, v2) {
    return v1[0] * v2[1] - v1[1] * v2[0];
}
function twoSided(p1, p2, q1, q2) {
    var x1 = p1[0] - q1[0];
    var y1 = p1[1] - q1[1];
    var x2 = p2[0] - q1[0];
    var y2 = p2[1] - q1[1];
    var x3 = q2[0] - q1[0];
    var y3 = q2[1] - q1[1];
    var det1 = x1 * y3 - x3 * y1;
    var det2 = x2 * y3 - x3 * y2;
    if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) {
        return true;
    }
    return false;
}
function lineIntersectLine(a, b, c, d) {
    var vectorP = [b[0] - a[0], b[1] - a[1]];
    var vectorQ = [d[0] - c[0], d[1] - c[1]];
    if (perp(vectorQ, vectorP) === 0) {
        return false;
    }
    if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) {
        return true;
    }
    return false;
}
function lineIntersectPolygon(p1, p2, polygon) {
    for (var i = 0, list = polygon; i < list.length; i += 1) {
        var ring = list[i];
        for (var j = 0; j < ring.length - 1; ++j) {
            if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {
                return true;
            }
        }
    }
    return false;
}
function lineStringWithinPolygon(line, polygon) {
    for (var i = 0; i < line.length; ++i) {
        if (!pointWithinPolygon(line[i], polygon)) {
            return false;
        }
    }
    for (var i$1 = 0; i$1 < line.length - 1; ++i$1) {
        if (lineIntersectPolygon(line[i$1], line[i$1 + 1], polygon)) {
            return false;
        }
    }
    return true;
}
function lineStringWithinPolygons(line, polygons) {
    for (var i = 0; i < polygons.length; i++) {
        if (lineStringWithinPolygon(line, polygons[i])) {
            return true;
        }
    }
    return false;
}
function getTilePolygon(coordinates, bbox, canonical) {
    var polygon = [];
    for (var i = 0; i < coordinates.length; i++) {
        var ring = [];
        for (var j = 0; j < coordinates[i].length; j++) {
            var coord = getTileCoordinates(coordinates[i][j], canonical);
            updateBBox(bbox, coord);
            ring.push(coord);
        }
        polygon.push(ring);
    }
    return polygon;
}
function getTilePolygons(coordinates, bbox, canonical) {
    var polygons = [];
    for (var i = 0; i < coordinates.length; i++) {
        var polygon = getTilePolygon(coordinates[i], bbox, canonical);
        polygons.push(polygon);
    }
    return polygons;
}
function updatePoint(p, bbox, polyBBox, worldSize) {
    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
        var halfWorldSize = worldSize * 0.5;
        var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;
        if (shift === 0) {
            shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
        }
        p[0] += shift;
    }
    updateBBox(bbox, p);
}
function resetBBox(bbox) {
    bbox[0] = bbox[1] = Infinity;
    bbox[2] = bbox[3] = -Infinity;
}
function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
    var tilePoints = [];
    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
        var points = list$1[i$1];
        for (var i = 0, list = points; i < list.length; i += 1) {
            var point = list[i];
            var p = [point.x + shifts[0], point.y + shifts[1]];
            updatePoint(p, pointBBox, polyBBox, worldSize);
            tilePoints.push(p);
        }
    }
    return tilePoints;
}
function getTileLines(geometry, lineBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
    var tileLines = [];
    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
        var line = list$1[i$1];
        var tileLine = [];
        for (var i = 0, list = line; i < list.length; i += 1) {
            var point = list[i];
            var p = [point.x + shifts[0], point.y + shifts[1]];
            updateBBox(lineBBox, p);
            tileLine.push(p);
        }
        tileLines.push(tileLine);
    }
    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
        resetBBox(lineBBox);
        for (var i$3 = 0, list$3 = tileLines; i$3 < list$3.length; i$3 += 1) {
            var line$1 = list$3[i$3];
            for (var i$2 = 0, list$2 = line$1; i$2 < list$2.length; i$2 += 1) {
                var p$1 = list$2[i$2];
                updatePoint(p$1, lineBBox, polyBBox, worldSize);
            }
        }
    }
    return tileLines;
}
function pointsWithinPolygons(ctx, polygonGeometry) {
    var pointBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var canonical = ctx.canonicalID();
    if (polygonGeometry.type === 'Polygon') {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) {
            return false;
        }
        for (var i = 0, list = tilePoints; i < list.length; i += 1) {
            var point = list[i];
            if (!pointWithinPolygon(point, tilePolygon)) {
                return false;
            }
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints$1 = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) {
            return false;
        }
        for (var i$1 = 0, list$1 = tilePoints$1; i$1 < list$1.length; i$1 += 1) {
            var point$1 = list$1[i$1];
            if (!pointWithinPolygons(point$1, tilePolygons)) {
                return false;
            }
        }
    }
    return true;
}
function linesWithinPolygons(ctx, polygonGeometry) {
    var lineBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var canonical = ctx.canonicalID();
    if (polygonGeometry.type === 'Polygon') {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) {
            return false;
        }
        for (var i = 0, list = tileLines; i < list.length; i += 1) {
            var line = list[i];
            if (!lineStringWithinPolygon(line, tilePolygon)) {
                return false;
            }
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines$1 = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) {
            return false;
        }
        for (var i$1 = 0, list$1 = tileLines$1; i$1 < list$1.length; i$1 += 1) {
            var line$1 = list$1[i$1];
            if (!lineStringWithinPolygons(line$1, tilePolygons)) {
                return false;
            }
        }
    }
    return true;
}
var Within = function Within(geojson, geometries) {
    this.type = BooleanType;
    this.geojson = geojson;
    this.geometries = geometries;
};
Within.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('\'within\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');
    }
    if (isValue(args[1])) {
        var geojson = args[1];
        if (geojson.type === 'FeatureCollection') {
            for (var i = 0; i < geojson.features.length; ++i) {
                var type = geojson.features[i].geometry.type;
                if (type === 'Polygon' || type === 'MultiPolygon') {
                    return new Within(geojson, geojson.features[i].geometry);
                }
            }
        } else if (geojson.type === 'Feature') {
            var type$1 = geojson.geometry.type;
            if (type$1 === 'Polygon' || type$1 === 'MultiPolygon') {
                return new Within(geojson, geojson.geometry);
            }
        } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {
            return new Within(geojson, geojson);
        }
    }
    return context.error('\'within\' expression requires valid geojson object that contains polygon geometry type.');
};
Within.prototype.evaluate = function evaluate(ctx) {
    if (ctx.geometry() != null && ctx.canonicalID() != null) {
        if (ctx.geometryType() === 'Point') {
            return pointsWithinPolygons(ctx, this.geometries);
        } else if (ctx.geometryType() === 'LineString') {
            return linesWithinPolygons(ctx, this.geometries);
        }
    }
    return false;
};
Within.prototype.eachChild = function eachChild() {};
Within.prototype.outputDefined = function outputDefined() {
    return true;
};
Within.prototype.serialize = function serialize() {
    return ['within', this.geojson];
};

function isFeatureConstant(e) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'get' && e.args.length === 1) {
            return false;
        } else if (e.name === 'feature-state') {
            return false;
        } else if (e.name === 'has' && e.args.length === 1) {
            return false;
        } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {
            return false;
        } else if (/^filter-/.test(e.name)) {
            return false;
        }
    }
    if (e instanceof Within) {
        return false;
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isFeatureConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isStateConstant(e) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'feature-state') {
            return false;
        }
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isStateConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isGlobalPropertyConstant(e, properties) {
    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {
        return false;
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isGlobalPropertyConstant(arg, properties)) {
            result = false;
        }
    });
    return result;
}

var Var = function Var(name, boundExpression) {
    this.type = boundExpression.type;
    this.name = name;
    this.boundExpression = boundExpression;
};
Var.parse = function parse(args, context) {
    if (args.length !== 2 || typeof args[1] !== 'string') {
        return context.error('\'var\' expression requires exactly one string literal argument.');
    }
    var name = args[1];
    if (!context.scope.has(name)) {
        return context.error('Unknown variable "' + name + '". Make sure "' + name + '" has been bound in an enclosing "let" expression before using it.', 1);
    }
    return new Var(name, context.scope.get(name));
};
Var.prototype.evaluate = function evaluate(ctx) {
    return this.boundExpression.evaluate(ctx);
};
Var.prototype.eachChild = function eachChild() {};
Var.prototype.outputDefined = function outputDefined() {
    return false;
};
Var.prototype.serialize = function serialize() {
    return ['var', this.name];
};

var ParsingContext = function ParsingContext(registry, path, expectedType, scope, errors) {
    if (path === void 0) path = [];
    if (scope === void 0) scope = new Scope();
    if (errors === void 0) errors = [];
    this.registry = registry;
    this.path = path;
    this.key = path.map(function (part) {
        return '[' + part + ']';
    }).join('');
    this.scope = scope;
    this.errors = errors;
    this.expectedType = expectedType;
};
ParsingContext.prototype.parse = function parse(expr, index, expectedType, bindings, options) {
    if (options === void 0) options = {};
    if (index) {
        return this.concat(index, expectedType, bindings)._parse(expr, options);
    }
    return this._parse(expr, options);
};
ParsingContext.prototype._parse = function _parse(expr, options) {
    if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
        expr = ['literal', expr];
    }
    function annotate(parsed, type, typeAnnotation) {
        if (typeAnnotation === 'assert') {
            return new Assertion(type, [parsed]);
        } else if (typeAnnotation === 'coerce') {
            return new Coercion(type, [parsed]);
        } else {
            return parsed;
        }
    }
    if (Array.isArray(expr)) {
        if (expr.length === 0) {
            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
        }
        var op = expr[0];
        if (typeof op !== 'string') {
            this.error('Expression name must be a string, but found ' + (typeof op === "undefined" ? "undefined" : _typeof(op)) + ' instead. If you wanted a literal array, use ["literal", [...]].', 0);
            return null;
        }
        var Expr = this.registry[op];
        if (Expr) {
            var parsed = Expr.parse(expr, this);
            if (!parsed) {
                return null;
            }
            if (this.expectedType) {
                var expected = this.expectedType;
                var actual = parsed.type;
                if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {
                    parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');
                } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {
                    parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');
                } else if (this.checkSubtype(expected, actual)) {
                    return null;
                }
            }
            if (!(parsed instanceof Literal) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {
                var ec = new EvaluationContext();
                try {
                    parsed = new Literal(parsed.type, parsed.evaluate(ec));
                } catch (e) {
                    this.error(e.message);
                    return null;
                }
            }
            return parsed;
        }
        return this.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
    } else if (typeof expr === 'undefined') {
        return this.error('\'undefined\' value invalid. Use null instead.');
    } else if ((typeof expr === "undefined" ? "undefined" : _typeof(expr)) === 'object') {
        return this.error('Bare objects invalid. Use ["literal", {...}] instead.');
    } else {
        return this.error('Expected an array, but found ' + (typeof expr === "undefined" ? "undefined" : _typeof(expr)) + ' instead.');
    }
};
ParsingContext.prototype.concat = function concat(index, expectedType, bindings) {
    var path = typeof index === 'number' ? this.path.concat(index) : this.path;
    var scope = bindings ? this.scope.concat(bindings) : this.scope;
    return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
};
ParsingContext.prototype.error = function error(error$1) {
    var keys = [],
        len = arguments.length - 1;
    while (len-- > 0) {
        keys[len] = arguments[len + 1];
    }var key = '' + this.key + keys.map(function (k) {
        return '[' + k + ']';
    }).join('');
    this.errors.push(new ParsingError(key, error$1));
};
ParsingContext.prototype.checkSubtype = function checkSubtype$1(expected, t) {
    var error = checkSubtype(expected, t);
    if (error) {
        this.error(error);
    }
    return error;
};
function isConstant(expression) {
    if (expression instanceof Var) {
        return isConstant(expression.boundExpression);
    } else if (expression instanceof CompoundExpression && expression.name === 'error') {
        return false;
    } else if (expression instanceof CollatorExpression) {
        return false;
    } else if (expression instanceof Within) {
        return false;
    }
    var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;
    var childrenConstant = true;
    expression.eachChild(function (child) {
        if (isTypeAnnotation) {
            childrenConstant = childrenConstant && isConstant(child);
        } else {
            childrenConstant = childrenConstant && child instanceof Literal;
        }
    });
    if (!childrenConstant) {
        return false;
    }
    return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, ['zoom', 'heatmap-density', 'line-progress', 'accumulated', 'is-supported-script']);
}

function findStopLessThanOrEqualTo(stops, input) {
    var lastIndex = stops.length - 1;
    var lowerIndex = 0;
    var upperIndex = lastIndex;
    var currentIndex = 0;
    var currentValue, nextValue;
    while (lowerIndex <= upperIndex) {
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex];
        nextValue = stops[currentIndex + 1];
        if (currentValue <= input) {
            if (currentIndex === lastIndex || input < nextValue) {
                return currentIndex;
            }
            lowerIndex = currentIndex + 1;
        } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
        } else {
            throw new RuntimeError('Input is not a number.');
        }
    }
    return 0;
}

var Step = function Step(type, input, stops) {
    this.type = type;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];
        this.labels.push(label);
        this.outputs.push(expression);
    }
};
Step.parse = function parse(args, context) {
    if (args.length - 1 < 4) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if ((args.length - 1) % 2 !== 0) {
        return context.error('Expected an even number of arguments.');
    }
    var input = context.parse(args[1], 1, NumberType);
    if (!input) {
        return null;
    }
    var stops = [];
    var outputType = null;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    for (var i = 1; i < args.length; i += 2) {
        var label = i === 1 ? -Infinity : args[i];
        var value = args[i + 1];
        var labelKey = i;
        var valueKey = i + 1;
        if (typeof label !== 'number') {
            return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }
        if (stops.length && stops[stops.length - 1][0] >= label) {
            return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }
        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        stops.push([label, parsed]);
    }
    return new Step(outputType, input, stops);
};
Step.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;
    if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
    }
    var value = this.input.evaluate(ctx);
    if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
    }
    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
    }
    var index = findStopLessThanOrEqualTo(labels, value);
    return outputs[index].evaluate(ctx);
};
Step.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
        var expression = list[i];
        fn(expression);
    }
};
Step.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    });
};
Step.prototype.serialize = function serialize() {
    var serialized = ['step', this.input.serialize()];
    for (var i = 0; i < this.labels.length; i++) {
        if (i > 0) {
            serialized.push(this.labels[i]);
        }
        serialized.push(this.outputs[i].serialize());
    }
    return serialized;
};

/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

var unitbezier = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function (t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function (t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function (t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function (x, epsilon) {
    if (typeof epsilon === 'undefined') {
        epsilon = 1e-6;
    }

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) {
            return t2;
        }

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) {
            break;
        }

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) {
        return t0;
    }
    if (t2 > t1) {
        return t1;
    }

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) {
            return t2;
        }

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function (x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

function number(a, b, t) {
    return a * (1 - t) + b * t;
}
function color(from, to, t) {
    return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
}
function array$1(from, to, t) {
    return from.map(function (d, i) {
        return number(d, to[i], t);
    });
}

var interpolate = /*#__PURE__*/Object.freeze({
    __proto__: null,
    number: number,
    color: color,
    array: array$1
});

var Xn = 0.95047,
    Yn = 1,
    Zn = 1.08883,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1,
    deg2rad = Math.PI / 180,
    rad2deg = 180 / Math.PI;
function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
}
function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2xyz(x) {
    x /= 255;
    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function rgbToLab(rgbColor) {
    var b = rgb2xyz(rgbColor.r),
        a = rgb2xyz(rgbColor.g),
        l = rgb2xyz(rgbColor.b),
        x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
        y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn),
        z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
    return {
        l: 116 * y - 16,
        a: 500 * (x - y),
        b: 200 * (y - z),
        alpha: rgbColor.a
    };
}
function labToRgb(labColor) {
    var y = (labColor.l + 16) / 116,
        x = isNaN(labColor.a) ? y : y + labColor.a / 500,
        z = isNaN(labColor.b) ? y : y - labColor.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
}
function interpolateLab(from, to, t) {
    return {
        l: number(from.l, to.l, t),
        a: number(from.a, to.a, t),
        b: number(from.b, to.b, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
function rgbToHcl(rgbColor) {
    var ref = rgbToLab(rgbColor);
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var h = Math.atan2(b, a) * rad2deg;
    return {
        h: h < 0 ? h + 360 : h,
        c: Math.sqrt(a * a + b * b),
        l: l,
        alpha: rgbColor.a
    };
}
function hclToRgb(hclColor) {
    var h = hclColor.h * deg2rad,
        c = hclColor.c,
        l = hclColor.l;
    return labToRgb({
        l: l,
        a: Math.cos(h) * c,
        b: Math.sin(h) * c,
        alpha: hclColor.alpha
    });
}
function interpolateHue(a, b, t) {
    var d = b - a;
    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
}
function interpolateHcl(from, to, t) {
    return {
        h: interpolateHue(from.h, to.h, t),
        c: number(from.c, to.c, t),
        l: number(from.l, to.l, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
var lab = {
    forward: rgbToLab,
    reverse: labToRgb,
    interpolate: interpolateLab
};
var hcl = {
    forward: rgbToHcl,
    reverse: hclToRgb,
    interpolate: interpolateHcl
};

var colorSpaces = /*#__PURE__*/Object.freeze({
    __proto__: null,
    lab: lab,
    hcl: hcl
});

var Interpolate = function Interpolate(type, operator, interpolation, input, stops) {
    this.type = type;
    this.operator = operator;
    this.interpolation = interpolation;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];
        this.labels.push(label);
        this.outputs.push(expression);
    }
};
Interpolate.interpolationFactor = function interpolationFactor(interpolation, input, lower, upper) {
    var t = 0;
    if (interpolation.name === 'exponential') {
        t = exponentialInterpolation(input, interpolation.base, lower, upper);
    } else if (interpolation.name === 'linear') {
        t = exponentialInterpolation(input, 1, lower, upper);
    } else if (interpolation.name === 'cubic-bezier') {
        var c = interpolation.controlPoints;
        var ub = new unitbezier(c[0], c[1], c[2], c[3]);
        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
    }
    return t;
};
Interpolate.parse = function parse(args, context) {
    var operator = args[0];
    var interpolation = args[1];
    var input = args[2];
    var rest = args.slice(3);
    if (!Array.isArray(interpolation) || interpolation.length === 0) {
        return context.error('Expected an interpolation type expression.', 1);
    }
    if (interpolation[0] === 'linear') {
        interpolation = { name: 'linear' };
    } else if (interpolation[0] === 'exponential') {
        var base = interpolation[1];
        if (typeof base !== 'number') {
            return context.error('Exponential interpolation requires a numeric base.', 1, 1);
        }
        interpolation = {
            name: 'exponential',
            base: base
        };
    } else if (interpolation[0] === 'cubic-bezier') {
        var controlPoints = interpolation.slice(1);
        if (controlPoints.length !== 4 || controlPoints.some(function (t) {
            return typeof t !== 'number' || t < 0 || t > 1;
        })) {
            return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
        }
        interpolation = {
            name: 'cubic-bezier',
            controlPoints: controlPoints
        };
    } else {
        return context.error('Unknown interpolation type ' + String(interpolation[0]), 1, 0);
    }
    if (args.length - 1 < 4) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if ((args.length - 1) % 2 !== 0) {
        return context.error('Expected an even number of arguments.');
    }
    input = context.parse(input, 2, NumberType);
    if (!input) {
        return null;
    }
    var stops = [];
    var outputType = null;
    if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {
        outputType = ColorType;
    } else if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    for (var i = 0; i < rest.length; i += 2) {
        var label = rest[i];
        var value = rest[i + 1];
        var labelKey = i + 3;
        var valueKey = i + 4;
        if (typeof label !== 'number') {
            return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }
        if (stops.length && stops[stops.length - 1][0] >= label) {
            return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }
        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        stops.push([label, parsed]);
    }
    if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
        return context.error('Type ' + toString(outputType) + ' is not interpolatable.');
    }
    return new Interpolate(outputType, operator, interpolation, input, stops);
};
Interpolate.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;
    if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
    }
    var value = this.input.evaluate(ctx);
    if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
    }
    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
    }
    var index = findStopLessThanOrEqualTo(labels, value);
    var lower = labels[index];
    var upper = labels[index + 1];
    var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
    var outputLower = outputs[index].evaluate(ctx);
    var outputUpper = outputs[index + 1].evaluate(ctx);
    if (this.operator === 'interpolate') {
        return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);
    } else if (this.operator === 'interpolate-hcl') {
        return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
    } else {
        return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
    }
};
Interpolate.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
        var expression = list[i];
        fn(expression);
    }
};
Interpolate.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    });
};
Interpolate.prototype.serialize = function serialize() {
    var interpolation;
    if (this.interpolation.name === 'linear') {
        interpolation = ['linear'];
    } else if (this.interpolation.name === 'exponential') {
        if (this.interpolation.base === 1) {
            interpolation = ['linear'];
        } else {
            interpolation = ['exponential', this.interpolation.base];
        }
    } else {
        interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);
    }
    var serialized = [this.operator, interpolation, this.input.serialize()];
    for (var i = 0; i < this.labels.length; i++) {
        serialized.push(this.labels[i], this.outputs[i].serialize());
    }
    return serialized;
};
function exponentialInterpolation(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

var Coalesce = function Coalesce(type, args) {
    this.type = type;
    this.args = args;
};
Coalesce.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expectected at least one argument.');
    }
    var outputType = null;
    var expectedType = context.expectedType;
    if (expectedType && expectedType.kind !== 'value') {
        outputType = expectedType;
    }
    var parsedArgs = [];
    for (var i = 0, list = args.slice(1); i < list.length; i += 1) {
        var arg = list[i];
        var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, { typeAnnotation: 'omit' });
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        parsedArgs.push(parsed);
    }
    var needsAnnotation = expectedType && parsedArgs.some(function (arg) {
        return checkSubtype(expectedType, arg.type);
    });
    return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
};
Coalesce.prototype.evaluate = function evaluate(ctx) {
    var result = null;
    var argCount = 0;
    var requestedImageName;
    for (var i = 0, list = this.args; i < list.length; i += 1) {
        var arg = list[i];
        argCount++;
        result = arg.evaluate(ctx);
        if (result && result instanceof ResolvedImage && !result.available) {
            if (!requestedImageName) {
                requestedImageName = result.name;
            }
            result = null;
            if (argCount === this.args.length) {
                result = requestedImageName;
            }
        }
        if (result !== null) {
            break;
        }
    }
    return result;
};
Coalesce.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Coalesce.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Coalesce.prototype.serialize = function serialize() {
    var serialized = ['coalesce'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var Let = function Let(bindings, result) {
    this.type = result.type;
    this.bindings = [].concat(bindings);
    this.result = result;
};
Let.prototype.evaluate = function evaluate(ctx) {
    return this.result.evaluate(ctx);
};
Let.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
        var binding = list[i];
        fn(binding[1]);
    }
    fn(this.result);
};
Let.parse = function parse(args, context) {
    if (args.length < 4) {
        return context.error('Expected at least 3 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var bindings = [];
    for (var i = 1; i < args.length - 1; i += 2) {
        var name = args[i];
        if (typeof name !== 'string') {
            return context.error('Expected string, but found ' + (typeof name === "undefined" ? "undefined" : _typeof(name)) + ' instead.', i);
        }
        if (/[^a-zA-Z0-9_]/.test(name)) {
            return context.error('Variable names must contain only alphanumeric characters or \'_\'.', i);
        }
        var value = context.parse(args[i + 1], i + 1);
        if (!value) {
            return null;
        }
        bindings.push([name, value]);
    }
    var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
    if (!result) {
        return null;
    }
    return new Let(bindings, result);
};
Let.prototype.outputDefined = function outputDefined() {
    return this.result.outputDefined();
};
Let.prototype.serialize = function serialize() {
    var serialized = ['let'];
    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
        var ref = list[i];
        var name = ref[0];
        var expr = ref[1];
        serialized.push(name, expr.serialize());
    }
    serialized.push(this.result.serialize());
    return serialized;
};

var At = function At(type, index, input) {
    this.type = type;
    this.index = index;
    this.input = input;
};
At.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var index = context.parse(args[1], 1, NumberType);
    var input = context.parse(args[2], 2, array(context.expectedType || ValueType));
    if (!index || !input) {
        return null;
    }
    var t = input.type;
    return new At(t.itemType, index, input);
};
At.prototype.evaluate = function evaluate(ctx) {
    var index = this.index.evaluate(ctx);
    var array = this.input.evaluate(ctx);
    if (index < 0) {
        throw new RuntimeError('Array index out of bounds: ' + index + ' < 0.');
    }
    if (index >= array.length) {
        throw new RuntimeError('Array index out of bounds: ' + index + ' > ' + (array.length - 1) + '.');
    }
    if (index !== Math.floor(index)) {
        throw new RuntimeError('Array index must be an integer, but found ' + index + ' instead.');
    }
    return array[index];
};
At.prototype.eachChild = function eachChild(fn) {
    fn(this.index);
    fn(this.input);
};
At.prototype.outputDefined = function outputDefined() {
    return false;
};
At.prototype.serialize = function serialize() {
    return ['at', this.index.serialize(), this.input.serialize()];
};

var In = function In(needle, haystack) {
    this.type = BooleanType;
    this.needle = needle;
    this.haystack = haystack;
};
In.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack) {
        return null;
    }
    if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');
    }
    return new In(needle, haystack);
};
In.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);
    if (!haystack) {
        return false;
    }
    if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
        throw new RuntimeError('Expected first argument to be of type boolean, string, number or null, but found ' + toString(typeOf(needle)) + ' instead.');
    }
    if (!isValidNativeType(haystack, ['string', 'array'])) {
        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');
    }
    return haystack.indexOf(needle) >= 0;
};
In.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
};
In.prototype.outputDefined = function outputDefined() {
    return true;
};
In.prototype.serialize = function serialize() {
    return ['in', this.needle.serialize(), this.haystack.serialize()];
};

var IndexOf = function IndexOf(needle, haystack, fromIndex) {
    this.type = NumberType;
    this.needle = needle;
    this.haystack = haystack;
    this.fromIndex = fromIndex;
};
IndexOf.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
        return context.error('Expected 3 or 4 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack) {
        return null;
    }
    if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');
    }
    if (args.length === 4) {
        var fromIndex = context.parse(args[3], 3, NumberType);
        if (!fromIndex) {
            return null;
        }
        return new IndexOf(needle, haystack, fromIndex);
    } else {
        return new IndexOf(needle, haystack);
    }
};
IndexOf.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);
    if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
        throw new RuntimeError('Expected first argument to be of type boolean, string, number or null, but found ' + toString(typeOf(needle)) + ' instead.');
    }
    if (!isValidNativeType(haystack, ['string', 'array'])) {
        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');
    }
    if (this.fromIndex) {
        var fromIndex = this.fromIndex.evaluate(ctx);
        return haystack.indexOf(needle, fromIndex);
    }
    return haystack.indexOf(needle);
};
IndexOf.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
    if (this.fromIndex) {
        fn(this.fromIndex);
    }
};
IndexOf.prototype.outputDefined = function outputDefined() {
    return false;
};
IndexOf.prototype.serialize = function serialize() {
    if (this.fromIndex != null && this.fromIndex !== undefined) {
        var fromIndex = this.fromIndex.serialize();
        return ['index-of', this.needle.serialize(), this.haystack.serialize(), fromIndex];
    }
    return ['index-of', this.needle.serialize(), this.haystack.serialize()];
};

var Match = function Match(inputType, outputType, input, cases, outputs, otherwise) {
    this.inputType = inputType;
    this.type = outputType;
    this.input = input;
    this.cases = cases;
    this.outputs = outputs;
    this.otherwise = otherwise;
};
Match.parse = function parse(args, context) {
    if (args.length < 5) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if (args.length % 2 !== 1) {
        return context.error('Expected an even number of arguments.');
    }
    var inputType;
    var outputType;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    var cases = {};
    var outputs = [];
    for (var i = 2; i < args.length - 1; i += 2) {
        var labels = args[i];
        var value = args[i + 1];
        if (!Array.isArray(labels)) {
            labels = [labels];
        }
        var labelContext = context.concat(i);
        if (labels.length === 0) {
            return labelContext.error('Expected at least one branch label.');
        }
        for (var i$1 = 0, list = labels; i$1 < list.length; i$1 += 1) {
            var label = list[i$1];
            if (typeof label !== 'number' && typeof label !== 'string') {
                return labelContext.error('Branch labels must be numbers or strings.');
            } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
                return labelContext.error('Branch labels must be integers no larger than ' + Number.MAX_SAFE_INTEGER + '.');
            } else if (typeof label === 'number' && Math.floor(label) !== label) {
                return labelContext.error('Numeric branch labels must be integer values.');
            } else if (!inputType) {
                inputType = typeOf(label);
            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
                return null;
            }
            if (typeof cases[String(label)] !== 'undefined') {
                return labelContext.error('Branch labels must be unique.');
            }
            cases[String(label)] = outputs.length;
        }
        var result = context.parse(value, i, outputType);
        if (!result) {
            return null;
        }
        outputType = outputType || result.type;
        outputs.push(result);
    }
    var input = context.parse(args[1], 1, ValueType);
    if (!input) {
        return null;
    }
    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) {
        return null;
    }
    if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {
        return null;
    }
    return new Match(inputType, outputType, input, cases, outputs, otherwise);
};
Match.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
    return output.evaluate(ctx);
};
Match.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    this.outputs.forEach(fn);
    fn(this.otherwise);
};
Match.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    }) && this.otherwise.outputDefined();
};
Match.prototype.serialize = function serialize() {
    var this$1 = this;
    var serialized = ['match', this.input.serialize()];
    var sortedLabels = Object.keys(this.cases).sort();
    var groupedByOutput = [];
    var outputLookup = {};
    for (var i = 0, list = sortedLabels; i < list.length; i += 1) {
        var label = list[i];
        var outputIndex = outputLookup[this.cases[label]];
        if (outputIndex === undefined) {
            outputLookup[this.cases[label]] = groupedByOutput.length;
            groupedByOutput.push([this.cases[label], [label]]);
        } else {
            groupedByOutput[outputIndex][1].push(label);
        }
    }
    var coerceLabel = function coerceLabel(label) {
        return this$1.inputType.kind === 'number' ? Number(label) : label;
    };
    for (var i$1 = 0, list$1 = groupedByOutput; i$1 < list$1.length; i$1 += 1) {
        var ref = list$1[i$1];
        var outputIndex = ref[0];
        var labels = ref[1];
        if (labels.length === 1) {
            serialized.push(coerceLabel(labels[0]));
        } else {
            serialized.push(labels.map(coerceLabel));
        }
        serialized.push(this.outputs[outputIndex$1].serialize());
    }
    serialized.push(this.otherwise.serialize());
    return serialized;
};

var Case = function Case(type, branches, otherwise) {
    this.type = type;
    this.branches = branches;
    this.otherwise = otherwise;
};
Case.parse = function parse(args, context) {
    if (args.length < 4) {
        return context.error('Expected at least 3 arguments, but found only ' + (args.length - 1) + '.');
    }
    if (args.length % 2 !== 0) {
        return context.error('Expected an odd number of arguments.');
    }
    var outputType;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    var branches = [];
    for (var i = 1; i < args.length - 1; i += 2) {
        var test = context.parse(args[i], i, BooleanType);
        if (!test) {
            return null;
        }
        var result = context.parse(args[i + 1], i + 1, outputType);
        if (!result) {
            return null;
        }
        branches.push([test, result]);
        outputType = outputType || result.type;
    }
    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) {
        return null;
    }
    return new Case(outputType, branches, otherwise);
};
Case.prototype.evaluate = function evaluate(ctx) {
    for (var i = 0, list = this.branches; i < list.length; i += 1) {
        var ref = list[i];
        var test = ref[0];
        var expression = ref[1];
        if (test.evaluate(ctx)) {
            return expression.evaluate(ctx);
        }
    }
    return this.otherwise.evaluate(ctx);
};
Case.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.branches; i < list.length; i += 1) {
        var ref = list[i];
        var test = ref[0];
        var expression = ref[1];
        fn(test);
        fn(expression);
    }
    fn(this.otherwise);
};
Case.prototype.outputDefined = function outputDefined() {
    return this.branches.every(function (ref) {
        var _ = ref[0];
        var out = ref[1];
        return out.outputDefined();
    }) && this.otherwise.outputDefined();
};
Case.prototype.serialize = function serialize() {
    var serialized = ['case'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var Slice = function Slice(type, input, beginIndex, endIndex) {
    this.type = type;
    this.input = input;
    this.beginIndex = beginIndex;
    this.endIndex = endIndex;
};
Slice.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
        return context.error('Expected 3 or 4 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var input = context.parse(args[1], 1, ValueType);
    var beginIndex = context.parse(args[2], 2, NumberType);
    if (!input || !beginIndex) {
        return null;
    }
    if (!isValidType(input.type, [array(ValueType), StringType, ValueType])) {
        return context.error('Expected first argument to be of type array or string, but found ' + toString(input.type) + ' instead');
    }
    if (args.length === 4) {
        var endIndex = context.parse(args[3], 3, NumberType);
        if (!endIndex) {
            return null;
        }
        return new Slice(input.type, input, beginIndex, endIndex);
    } else {
        return new Slice(input.type, input, beginIndex);
    }
};
Slice.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var beginIndex = this.beginIndex.evaluate(ctx);
    if (!isValidNativeType(input, ['string', 'array'])) {
        throw new RuntimeError('Expected first argument to be of type array or string, but found ' + toString(typeOf(input)) + ' instead.');
    }
    if (this.endIndex) {
        var endIndex = this.endIndex.evaluate(ctx);
        return input.slice(beginIndex, endIndex);
    }
    return input.slice(beginIndex);
};
Slice.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    fn(this.beginIndex);
    if (this.endIndex) {
        fn(this.endIndex);
    }
};
Slice.prototype.outputDefined = function outputDefined() {
    return false;
};
Slice.prototype.serialize = function serialize() {
    if (this.endIndex != null && this.endIndex !== undefined) {
        var endIndex = this.endIndex.serialize();
        return ['slice', this.input.serialize(), this.beginIndex.serialize(), endIndex];
    }
    return ['slice', this.input.serialize(), this.beginIndex.serialize()];
};

function isComparableType(op, type) {
    if (op === '==' || op === '!=') {
        return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';
    } else {
        return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';
    }
}
function eq(ctx, a, b) {
    return a === b;
}
function neq(ctx, a, b) {
    return a !== b;
}
function lt(ctx, a, b) {
    return a < b;
}
function gt(ctx, a, b) {
    return a > b;
}
function lteq(ctx, a, b) {
    return a <= b;
}
function gteq(ctx, a, b) {
    return a >= b;
}
function eqCollate(ctx, a, b, c) {
    return c.compare(a, b) === 0;
}
function neqCollate(ctx, a, b, c) {
    return !eqCollate(ctx, a, b, c);
}
function ltCollate(ctx, a, b, c) {
    return c.compare(a, b) < 0;
}
function gtCollate(ctx, a, b, c) {
    return c.compare(a, b) > 0;
}
function lteqCollate(ctx, a, b, c) {
    return c.compare(a, b) <= 0;
}
function gteqCollate(ctx, a, b, c) {
    return c.compare(a, b) >= 0;
}
function makeComparison(op, compareBasic, compareWithCollator) {
    var isOrderComparison = op !== '==' && op !== '!=';
    return function () {
        function Comparison(lhs, rhs, collator) {
            this.type = BooleanType;
            this.lhs = lhs;
            this.rhs = rhs;
            this.collator = collator;
            this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';
        }
        Comparison.parse = function parse(args, context) {
            if (args.length !== 3 && args.length !== 4) {
                return context.error('Expected two or three arguments.');
            }
            var op = args[0];
            var lhs = context.parse(args[1], 1, ValueType);
            if (!lhs) {
                return null;
            }
            if (!isComparableType(op, lhs.type)) {
                return context.concat(1).error('"' + op + '" comparisons are not supported for type \'' + toString(lhs.type) + '\'.');
            }
            var rhs = context.parse(args[2], 2, ValueType);
            if (!rhs) {
                return null;
            }
            if (!isComparableType(op, rhs.type)) {
                return context.concat(2).error('"' + op + '" comparisons are not supported for type \'' + toString(rhs.type) + '\'.');
            }
            if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                return context.error('Cannot compare types \'' + toString(lhs.type) + '\' and \'' + toString(rhs.type) + '\'.');
            }
            if (isOrderComparison) {
                if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {
                    lhs = new Assertion(rhs.type, [lhs]);
                } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {
                    rhs = new Assertion(lhs.type, [rhs]);
                }
            }
            var collator = null;
            if (args.length === 4) {
                if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                    return context.error('Cannot use collator to compare non-string types.');
                }
                collator = context.parse(args[3], 3, CollatorType);
                if (!collator) {
                    return null;
                }
            }
            return new Comparison(lhs, rhs, collator);
        };
        Comparison.prototype.evaluate = function evaluate(ctx) {
            var lhs = this.lhs.evaluate(ctx);
            var rhs = this.rhs.evaluate(ctx);
            if (isOrderComparison && this.hasUntypedArgument) {
                var lt = typeOf(lhs);
                var rt = typeOf(rhs);
                if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {
                    throw new RuntimeError('Expected arguments for "' + op + '" to be (string, string) or (number, number), but found (' + lt.kind + ', ' + rt.kind + ') instead.');
                }
            }
            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
                var lt$1 = typeOf(lhs);
                var rt$1 = typeOf(rhs);
                if (lt$1.kind !== 'string' || rt$1.kind !== 'string') {
                    return compareBasic(ctx, lhs, rhs);
                }
            }
            return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
        };
        Comparison.prototype.eachChild = function eachChild(fn) {
            fn(this.lhs);
            fn(this.rhs);
            if (this.collator) {
                fn(this.collator);
            }
        };
        Comparison.prototype.outputDefined = function outputDefined() {
            return true;
        };
        Comparison.prototype.serialize = function serialize() {
            var serialized = [op];
            this.eachChild(function (child) {
                serialized.push(child.serialize());
            });
            return serialized;
        };
        return Comparison;
    }();
}
var Equals = makeComparison('==', eq, eqCollate);
var NotEquals = makeComparison('!=', neq, neqCollate);
var LessThan = makeComparison('<', lt, ltCollate);
var GreaterThan = makeComparison('>', gt, gtCollate);
var LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);
var GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);

var NumberFormat = function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {
    this.type = StringType;
    this.number = number;
    this.locale = locale;
    this.currency = currency;
    this.minFractionDigits = minFractionDigits;
    this.maxFractionDigits = maxFractionDigits;
};
NumberFormat.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected two arguments.');
    }
    var number = context.parse(args[1], 1, NumberType);
    if (!number) {
        return null;
    }
    var options = args[2];
    if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== 'object' || Array.isArray(options)) {
        return context.error('NumberFormat options argument must be an object.');
    }
    var locale = null;
    if (options['locale']) {
        locale = context.parse(options['locale'], 1, StringType);
        if (!locale) {
            return null;
        }
    }
    var currency = null;
    if (options['currency']) {
        currency = context.parse(options['currency'], 1, StringType);
        if (!currency) {
            return null;
        }
    }
    var minFractionDigits = null;
    if (options['min-fraction-digits']) {
        minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);
        if (!minFractionDigits) {
            return null;
        }
    }
    var maxFractionDigits = null;
    if (options['max-fraction-digits']) {
        maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);
        if (!maxFractionDigits) {
            return null;
        }
    }
    return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);
};
NumberFormat.prototype.evaluate = function evaluate(ctx) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
        style: this.currency ? 'currency' : 'decimal',
        currency: this.currency ? this.currency.evaluate(ctx) : undefined,
        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
    }).format(this.number.evaluate(ctx));
};
NumberFormat.prototype.eachChild = function eachChild(fn) {
    fn(this.number);
    if (this.locale) {
        fn(this.locale);
    }
    if (this.currency) {
        fn(this.currency);
    }
    if (this.minFractionDigits) {
        fn(this.minFractionDigits);
    }
    if (this.maxFractionDigits) {
        fn(this.maxFractionDigits);
    }
};
NumberFormat.prototype.outputDefined = function outputDefined() {
    return false;
};
NumberFormat.prototype.serialize = function serialize() {
    var options = {};
    if (this.locale) {
        options['locale'] = this.locale.serialize();
    }
    if (this.currency) {
        options['currency'] = this.currency.serialize();
    }
    if (this.minFractionDigits) {
        options['min-fraction-digits'] = this.minFractionDigits.serialize();
    }
    if (this.maxFractionDigits) {
        options['max-fraction-digits'] = this.maxFractionDigits.serialize();
    }
    return ['number-format', this.number.serialize(), options];
};

var Length = function Length(input) {
    this.type = NumberType;
    this.input = input;
};
Length.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected 1 argument, but found ' + (args.length - 1) + ' instead.');
    }
    var input = context.parse(args[1], 1);
    if (!input) {
        return null;
    }
    if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value') {
        return context.error('Expected argument of type string or array, but found ' + toString(input.type) + ' instead.');
    }
    return new Length(input);
};
Length.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    if (typeof input === 'string') {
        return input.length;
    } else if (Array.isArray(input)) {
        return input.length;
    } else {
        throw new RuntimeError('Expected value to be of type string or array, but found ' + toString(typeOf(input)) + ' instead.');
    }
};
Length.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
};
Length.prototype.outputDefined = function outputDefined() {
    return false;
};
Length.prototype.serialize = function serialize() {
    var serialized = ['length'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var expressions = {
    '==': Equals,
    '!=': NotEquals,
    '>': GreaterThan,
    '<': LessThan,
    '>=': GreaterThanOrEqual,
    '<=': LessThanOrEqual,
    'array': Assertion,
    'at': At,
    'boolean': Assertion,
    'case': Case,
    'coalesce': Coalesce,
    'collator': CollatorExpression,
    'format': FormatExpression,
    'image': ImageExpression,
    'in': In,
    'index-of': IndexOf,
    'interpolate': Interpolate,
    'interpolate-hcl': Interpolate,
    'interpolate-lab': Interpolate,
    'length': Length,
    'let': Let,
    'literal': Literal,
    'match': Match,
    'number': Assertion,
    'number-format': NumberFormat,
    'object': Assertion,
    'slice': Slice,
    'step': Step,
    'string': Assertion,
    'to-boolean': Coercion,
    'to-color': Coercion,
    'to-number': Coercion,
    'to-string': Coercion,
    'var': Var,
    'within': Within
};
function rgba(ctx, ref) {
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    r = r.evaluate(ctx);
    g = g.evaluate(ctx);
    b = b.evaluate(ctx);
    var alpha = a ? a.evaluate(ctx) : 1;
    var error = validateRGBA(r, g, b, alpha);
    if (error) {
        throw new RuntimeError(error);
    }
    return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
}
function has(key, obj) {
    return key in obj;
}
function get(key, obj) {
    var v = obj[key];
    return typeof v === 'undefined' ? null : v;
}
function binarySearch(v, a, i, j) {
    while (i <= j) {
        var m = i + j >> 1;
        if (a[m] === v) {
            return true;
        }
        if (a[m] > v) {
            j = m - 1;
        } else {
            i = m + 1;
        }
    }
    return false;
}
function varargs(type) {
    return { type: type };
}
CompoundExpression.register(expressions, {
    'error': [ErrorType, [StringType], function (ctx, ref) {
        var v = ref[0];
        throw new RuntimeError(v.evaluate(ctx));
    }],
    'typeof': [StringType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        return toString(typeOf(v.evaluate(ctx)));
    }],
    'to-rgba': [array(NumberType, 4), [ColorType], function (ctx, ref) {
        var v = ref[0];
        return v.evaluate(ctx).toArray();
    }],
    'rgb': [ColorType, [NumberType, NumberType, NumberType], rgba],
    'rgba': [ColorType, [NumberType, NumberType, NumberType, NumberType], rgba],
    'has': {
        type: BooleanType,
        overloads: [[[StringType], function (ctx, ref) {
            var key = ref[0];
            return has(key.evaluate(ctx), ctx.properties());
        }], [[StringType, ObjectType], function (ctx, ref) {
            var key = ref[0];
            var obj = ref[1];
            return has(key.evaluate(ctx), obj.evaluate(ctx));
        }]]
    },
    'get': {
        type: ValueType,
        overloads: [[[StringType], function (ctx, ref) {
            var key = ref[0];
            return get(key.evaluate(ctx), ctx.properties());
        }], [[StringType, ObjectType], function (ctx, ref) {
            var key = ref[0];
            var obj = ref[1];
            return get(key.evaluate(ctx), obj.evaluate(ctx));
        }]]
    },
    'feature-state': [ValueType, [StringType], function (ctx, ref) {
        var key = ref[0];
        return get(key.evaluate(ctx), ctx.featureState || {});
    }],
    'properties': [ObjectType, [], function (ctx) {
        return ctx.properties();
    }],
    'geometry-type': [StringType, [], function (ctx) {
        return ctx.geometryType();
    }],
    'id': [ValueType, [], function (ctx) {
        return ctx.id();
    }],
    'zoom': [NumberType, [], function (ctx) {
        return ctx.globals.zoom;
    }],
    'heatmap-density': [NumberType, [], function (ctx) {
        return ctx.globals.heatmapDensity || 0;
    }],
    'line-progress': [NumberType, [], function (ctx) {
        return ctx.globals.lineProgress || 0;
    }],
    'accumulated': [ValueType, [], function (ctx) {
        return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;
    }],
    '+': [NumberType, varargs(NumberType), function (ctx, args) {
        var result = 0;
        for (var i = 0, list = args; i < list.length; i += 1) {
            var arg = list[i];
            result += arg.evaluate(ctx);
        }
        return result;
    }],
    '*': [NumberType, varargs(NumberType), function (ctx, args) {
        var result = 1;
        for (var i = 0, list = args; i < list.length; i += 1) {
            var arg = list[i];
            result *= arg.evaluate(ctx);
        }
        return result;
    }],
    '-': {
        type: NumberType,
        overloads: [[[NumberType, NumberType], function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) - b.evaluate(ctx);
        }], [[NumberType], function (ctx, ref) {
            var a = ref[0];
            return -a.evaluate(ctx);
        }]]
    },
    '/': [NumberType, [NumberType, NumberType], function (ctx, ref) {
        var a = ref[0];
        var b = ref[1];
        return a.evaluate(ctx) / b.evaluate(ctx);
    }],
    '%': [NumberType, [NumberType, NumberType], function (ctx, ref) {
        var a = ref[0];
        var b = ref[1];
        return a.evaluate(ctx) % b.evaluate(ctx);
    }],
    'ln2': [NumberType, [], function () {
        return Math.LN2;
    }],
    'pi': [NumberType, [], function () {
        return Math.PI;
    }],
    'e': [NumberType, [], function () {
        return Math.E;
    }],
    '^': [NumberType, [NumberType, NumberType], function (ctx, ref) {
        var b = ref[0];
        var e = ref[1];
        return Math.pow(b.evaluate(ctx), e.evaluate(ctx));
    }],
    'sqrt': [NumberType, [NumberType], function (ctx, ref) {
        var x = ref[0];
        return Math.sqrt(x.evaluate(ctx));
    }],
    'log10': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.log(n.evaluate(ctx)) / Math.LN10;
    }],
    'ln': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.log(n.evaluate(ctx));
    }],
    'log2': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.log(n.evaluate(ctx)) / Math.LN2;
    }],
    'sin': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.sin(n.evaluate(ctx));
    }],
    'cos': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.cos(n.evaluate(ctx));
    }],
    'tan': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.tan(n.evaluate(ctx));
    }],
    'asin': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.asin(n.evaluate(ctx));
    }],
    'acos': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.acos(n.evaluate(ctx));
    }],
    'atan': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.atan(n.evaluate(ctx));
    }],
    'min': [NumberType, varargs(NumberType), function (ctx, args) {
        return Math.min.apply(Math, args.map(function (arg) {
            return arg.evaluate(ctx);
        }));
    }],
    'max': [NumberType, varargs(NumberType), function (ctx, args) {
        return Math.max.apply(Math, args.map(function (arg) {
            return arg.evaluate(ctx);
        }));
    }],
    'abs': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.abs(n.evaluate(ctx));
    }],
    'round': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        var v = n.evaluate(ctx);
        return v < 0 ? -Math.round(-v) : Math.round(v);
    }],
    'floor': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.floor(n.evaluate(ctx));
    }],
    'ceil': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.ceil(n.evaluate(ctx));
    }],
    'filter-==': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        return ctx.properties()[k.value] === v.value;
    }],
    'filter-id-==': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        return ctx.id() === v.value;
    }],
    'filter-type-==': [BooleanType, [StringType], function (ctx, ref) {
        var v = ref[0];
        return ctx.geometryType() === v.value;
    }],
    'filter-<': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a < b;
    }],
    'filter-id-<': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a < b;
    }],
    'filter->': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a > b;
    }],
    'filter-id->': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a > b;
    }],
    'filter-<=': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a <= b;
    }],
    'filter-id-<=': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a <= b;
    }],
    'filter->=': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a >= b;
    }],
    'filter-id->=': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a >= b;
    }],
    'filter-has': [BooleanType, [ValueType], function (ctx, ref) {
        var k = ref[0];
        return k.value in ctx.properties();
    }],
    'filter-has-id': [BooleanType, [], function (ctx) {
        return ctx.id() !== null && ctx.id() !== undefined;
    }],
    'filter-type-in': [BooleanType, [array(StringType)], function (ctx, ref) {
        var v = ref[0];
        return v.value.indexOf(ctx.geometryType()) >= 0;
    }],
    'filter-id-in': [BooleanType, [array(ValueType)], function (ctx, ref) {
        var v = ref[0];
        return v.value.indexOf(ctx.id()) >= 0;
    }],
    'filter-in-small': [BooleanType, [StringType, array(ValueType)], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        return v.value.indexOf(ctx.properties()[k.value]) >= 0;
    }],
    'filter-in-large': [BooleanType, [StringType, array(ValueType)], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);
    }],
    'all': {
        type: BooleanType,
        overloads: [[[BooleanType, BooleanType], function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) && b.evaluate(ctx);
        }], [varargs(BooleanType), function (ctx, args) {
            for (var i = 0, list = args; i < list.length; i += 1) {
                var arg = list[i];
                if (!arg.evaluate(ctx)) {
                    return false;
                }
            }
            return true;
        }]]
    },
    'any': {
        type: BooleanType,
        overloads: [[[BooleanType, BooleanType], function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) || b.evaluate(ctx);
        }], [varargs(BooleanType), function (ctx, args) {
            for (var i = 0, list = args; i < list.length; i += 1) {
                var arg = list[i];
                if (arg.evaluate(ctx)) {
                    return true;
                }
            }
            return false;
        }]]
    },
    '!': [BooleanType, [BooleanType], function (ctx, ref) {
        var b = ref[0];
        return !b.evaluate(ctx);
    }],
    'is-supported-script': [BooleanType, [StringType], function (ctx, ref) {
        var s = ref[0];
        var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;
        if (isSupportedScript) {
            return isSupportedScript(s.evaluate(ctx));
        }
        return true;
    }],
    'upcase': [StringType, [StringType], function (ctx, ref) {
        var s = ref[0];
        return s.evaluate(ctx).toUpperCase();
    }],
    'downcase': [StringType, [StringType], function (ctx, ref) {
        var s = ref[0];
        return s.evaluate(ctx).toLowerCase();
    }],
    'concat': [StringType, varargs(ValueType), function (ctx, args) {
        return args.map(function (arg) {
            return toString$1(arg.evaluate(ctx));
        }).join('');
    }],
    'resolved-locale': [StringType, [CollatorType], function (ctx, ref) {
        var collator = ref[0];
        return collator.evaluate(ctx).resolvedLocale();
    }]
});

function success(value) {
    return {
        result: 'success',
        value: value
    };
}
function error(value) {
    return {
        result: 'error',
        value: value
    };
}

function supportsPropertyExpression(spec) {
    return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';
}
function supportsZoomExpression(spec) {
    return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;
}
function supportsInterpolation(spec) {
    return !!spec.expression && spec.expression.interpolated;
}

function getType(val) {
    if (val instanceof Number) {
        return 'number';
    } else if (val instanceof String) {
        return 'string';
    } else if (val instanceof Boolean) {
        return 'boolean';
    } else if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val === "undefined" ? "undefined" : _typeof(val);
    }
}

function isFunction$1(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && value !== null && !Array.isArray(value);
}
function identityFunction(x) {
    return x;
}
function createFunction(parameters, propertySpec) {
    var isColor = propertySpec.type === 'color';
    var zoomAndFeatureDependent = parameters.stops && _typeof(parameters.stops[0][0]) === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    var type = parameters.type || (supportsInterpolation(propertySpec) ? 'exponential' : 'interval');
    if (isColor) {
        parameters = extend({}, parameters);
        if (parameters.stops) {
            parameters.stops = parameters.stops.map(function (stop) {
                return [stop[0], Color.parse(stop[1])];
            });
        }
        if (parameters.default) {
            parameters.default = Color.parse(parameters.default);
        } else {
            parameters.default = Color.parse(propertySpec.default);
        }
    }
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb' && !colorSpaces[parameters.colorSpace]) {
        throw new Error('Unknown color space: ' + parameters.colorSpace);
    }
    var innerFun;
    var hashedStops;
    var categoricalKeyType;
    if (type === 'exponential') {
        innerFun = evaluateExponentialFunction;
    } else if (type === 'interval') {
        innerFun = evaluateIntervalFunction;
    } else if (type === 'categorical') {
        innerFun = evaluateCategoricalFunction;
        hashedStops = Object.create(null);
        for (var i = 0, list = parameters.stops; i < list.length; i += 1) {
            var stop = list[i];
            hashedStops[stop[0]] = stop[1];
        }
        categoricalKeyType = _typeof(parameters.stops[0][0]);
    } else if (type === 'identity') {
        innerFun = evaluateIdentityFunction;
    } else {
        throw new Error('Unknown function type "' + type + '"');
    }
    if (zoomAndFeatureDependent) {
        var featureFunctions = {};
        var zoomStops = [];
        for (var s = 0; s < parameters.stops.length; s++) {
            var stop$1 = parameters.stops[s];
            var zoom = stop$1[0].zoom;
            if (featureFunctions[zoom] === undefined) {
                featureFunctions[zoom] = {
                    zoom: zoom,
                    type: parameters.type,
                    property: parameters.property,
                    default: parameters.default,
                    stops: []
                };
                zoomStops.push(zoom);
            }
            featureFunctions[zoom].stops.push([stop$1[0].value, stop$1[1]]);
        }
        var featureFunctionStops = [];
        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {
            var z = list$1[i$1];
            featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);
        }
        var interpolationType = { name: 'linear' };
        return {
            kind: 'composite',
            interpolationType: interpolationType,
            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),
            zoomStops: featureFunctionStops.map(function (s) {
                return s[0];
            }),
            evaluate: function evaluate(ref, properties) {
                var zoom = ref.zoom;
                return evaluateExponentialFunction({
                    stops: featureFunctionStops,
                    base: parameters.base
                }, propertySpec, zoom).evaluate(zoom, properties);
            }
        };
    } else if (zoomDependent) {
        var interpolationType$1 = type === 'exponential' ? {
            name: 'exponential',
            base: parameters.base !== undefined ? parameters.base : 1
        } : null;
        return {
            kind: 'camera',
            interpolationType: interpolationType$1,
            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType$1),
            zoomStops: parameters.stops.map(function (s) {
                return s[0];
            }),
            evaluate: function evaluate(ref) {
                var zoom = ref.zoom;
                return innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType);
            }
        };
    } else {
        return {
            kind: 'source',
            evaluate: function evaluate(_, feature) {
                var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;
                if (value === undefined) {
                    return coalesce(parameters.default, propertySpec.default);
                }
                return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);
            }
        };
    }
}
function coalesce(a, b, c) {
    if (a !== undefined) {
        return a;
    }
    if (b !== undefined) {
        return b;
    }
    if (c !== undefined) {
        return c;
    }
}
function evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {
    var evaluated = (typeof input === "undefined" ? "undefined" : _typeof(input)) === keyType ? hashedStops[input] : undefined;
    return coalesce(evaluated, parameters.default, propertySpec.default);
}
function evaluateIntervalFunction(parameters, propertySpec, input) {
    if (getType(input) !== 'number') {
        return coalesce(parameters.default, propertySpec.default);
    }
    var n = parameters.stops.length;
    if (n === 1) {
        return parameters.stops[0][1];
    }
    if (input <= parameters.stops[0][0]) {
        return parameters.stops[0][1];
    }
    if (input >= parameters.stops[n - 1][0]) {
        return parameters.stops[n - 1][1];
    }
    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
        return stop[0];
    }), input);
    return parameters.stops[index][1];
}
function evaluateExponentialFunction(parameters, propertySpec, input) {
    var base = parameters.base !== undefined ? parameters.base : 1;
    if (getType(input) !== 'number') {
        return coalesce(parameters.default, propertySpec.default);
    }
    var n = parameters.stops.length;
    if (n === 1) {
        return parameters.stops[0][1];
    }
    if (input <= parameters.stops[0][0]) {
        return parameters.stops[0][1];
    }
    if (input >= parameters.stops[n - 1][0]) {
        return parameters.stops[n - 1][1];
    }
    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
        return stop[0];
    }), input);
    var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);
    var outputLower = parameters.stops[index][1];
    var outputUpper = parameters.stops[index + 1][1];
    var interp = interpolate[propertySpec.type] || identityFunction;
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {
        var colorspace = colorSpaces[parameters.colorSpace];
        interp = function interp(a, b) {
            return colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));
        };
    }
    if (typeof outputLower.evaluate === 'function') {
        return {
            evaluate: function evaluate() {
                var args = [],
                    len = arguments.length;
                while (len--) {
                    args[len] = arguments[len];
                }var evaluatedLower = outputLower.evaluate.apply(undefined, args);
                var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);
                if (evaluatedLower === undefined || evaluatedUpper === undefined) {
                    return undefined;
                }
                return interp(evaluatedLower, evaluatedUpper, t);
            }
        };
    }
    return interp(outputLower, outputUpper, t);
}
function evaluateIdentityFunction(parameters, propertySpec, input) {
    if (propertySpec.type === 'color') {
        input = Color.parse(input);
    } else if (propertySpec.type === 'formatted') {
        input = Formatted.fromString(input.toString());
    } else if (propertySpec.type === 'resolvedImage') {
        input = ResolvedImage.fromString(input.toString());
    } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {
        input = undefined;
    }
    return coalesce(input, parameters.default, propertySpec.default);
}
function interpolationFactor(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

var StyleExpression = function StyleExpression(expression, propertySpec) {
    this.expression = expression;
    this._warningHistory = {};
    this._evaluator = new EvaluationContext();
    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;
    this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;
};
StyleExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature;
    this._evaluator.featureState = featureState;
    this._evaluator.canonical = canonical;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection;
    return this.expression.evaluate(this._evaluator);
};
StyleExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature || null;
    this._evaluator.featureState = featureState || null;
    this._evaluator.canonical = canonical;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection || null;
    try {
        var val = this.expression.evaluate(this._evaluator);
        if (val === null || val === undefined || typeof val === 'number' && val !== val) {
            return this._defaultValue;
        }
        if (this._enumValues && !(val in this._enumValues)) {
            throw new RuntimeError('Expected value to be one of ' + Object.keys(this._enumValues).map(function (v) {
                return JSON.stringify(v);
            }).join(', ') + ', but found ' + JSON.stringify(val) + ' instead.');
        }
        return val;
    } catch (e) {
        if (!this._warningHistory[e.message]) {
            this._warningHistory[e.message] = true;
            if (typeof console !== 'undefined') {
                console.warn(e.message);
            }
        }
        return this._defaultValue;
    }
};
function isExpression(expression) {
    return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in expressions;
}
function createExpression(expression, propertySpec) {
    var parser = new ParsingContext(expressions, [], propertySpec ? getExpectedType(propertySpec) : undefined);
    var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? { typeAnnotation: 'coerce' } : undefined);
    if (!parsed) {
        return error(parser.errors);
    }
    return success(new StyleExpression(parsed, propertySpec));
}
var ZoomConstantExpression = function ZoomConstantExpression(kind, expression) {
    this.kind = kind;
    this._styleExpression = expression;
    this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);
};
ZoomConstantExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomConstantExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
};
var ZoomDependentExpression = function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {
    this.kind = kind;
    this.zoomStops = zoomStops;
    this._styleExpression = expression;
    this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);
    this.interpolationType = interpolationType;
};
ZoomDependentExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomDependentExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomDependentExpression.prototype.interpolationFactor = function interpolationFactor(input, lower, upper) {
    if (this.interpolationType) {
        return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);
    } else {
        return 0;
    }
};
function createPropertyExpression(expression, propertySpec) {
    expression = createExpression(expression, propertySpec);
    if (expression.result === 'error') {
        return expression;
    }
    var parsed = expression.value.expression;
    var isFeatureConstant$1 = isFeatureConstant(parsed);
    if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {
        return error([new ParsingError('', 'data expressions not supported')]);
    }
    var isZoomConstant = isGlobalPropertyConstant(parsed, ['zoom']);
    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
        return error([new ParsingError('', 'zoom expressions not supported')]);
    }
    var zoomCurve = findZoomCurve(parsed);
    if (!zoomCurve && !isZoomConstant) {
        return error([new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
    } else if (zoomCurve instanceof ParsingError) {
        return error([zoomCurve]);
    } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {
        return error([new ParsingError('', '"interpolate" expressions cannot be used with this property')]);
    }
    if (!zoomCurve) {
        return success(isFeatureConstant$1 ? new ZoomConstantExpression('constant', expression.value) : new ZoomConstantExpression('source', expression.value));
    }
    var interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;
    return success(isFeatureConstant$1 ? new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));
}
var StylePropertyFunction = function StylePropertyFunction(parameters, specification) {
    this._parameters = parameters;
    this._specification = specification;
    extend(this, createFunction(this._parameters, this._specification));
};
StylePropertyFunction.deserialize = function deserialize(serialized) {
    return new StylePropertyFunction(serialized._parameters, serialized._specification);
};
StylePropertyFunction.serialize = function serialize(input) {
    return {
        _parameters: input._parameters,
        _specification: input._specification
    };
};
function normalizePropertyExpression(value, specification) {
    if (isFunction$1(value)) {
        return new StylePropertyFunction(value, specification);
    } else if (isExpression(value)) {
        var expression = createPropertyExpression(value, specification);
        if (expression.result === 'error') {
            throw new Error(expression.value.map(function (err) {
                return err.key + ': ' + err.message;
            }).join(', '));
        }
        return expression.value;
    } else {
        var constant = value;
        if (typeof value === 'string' && specification.type === 'color') {
            constant = Color.parse(value);
        }
        return {
            kind: 'constant',
            evaluate: function evaluate() {
                return constant;
            }
        };
    }
}
function findZoomCurve(expression) {
    var result = null;
    if (expression instanceof Let) {
        result = findZoomCurve(expression.result);
    } else if (expression instanceof Coalesce) {
        for (var i = 0, list = expression.args; i < list.length; i += 1) {
            var arg = list[i];
            result = findZoomCurve(arg);
            if (result) {
                break;
            }
        }
    } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === 'zoom') {
        result = expression;
    }
    if (result instanceof ParsingError) {
        return result;
    }
    expression.eachChild(function (child) {
        var childResult = findZoomCurve(child);
        if (childResult instanceof ParsingError) {
            result = childResult;
        } else if (!result && childResult) {
            result = new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
        } else if (result && childResult && result !== childResult) {
            result = new ParsingError('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
        }
    });
    return result;
}
function getExpectedType(spec) {
    var types = {
        color: ColorType,
        string: StringType,
        number: NumberType,
        enum: StringType,
        boolean: BooleanType,
        formatted: FormattedType,
        resolvedImage: ResolvedImageType
    };
    if (spec.type === 'array') {
        return array(types[spec.value] || ValueType, spec.length);
    }
    return types[spec.type];
}
function getDefaultValue(spec) {
    if (spec.type === 'color' && isFunction$1(spec.default)) {
        return new Color(0, 0, 0, 0);
    } else if (spec.type === 'color') {
        return Color.parse(spec.default) || null;
    } else if (spec.default === undefined) {
        return null;
    } else {
        return spec.default;
    }
}

function convertLiteral(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' ? ['literal', value] : value;
}
function convertFunction(parameters, propertySpec) {
    var stops = parameters.stops;
    if (!stops) {
        return convertIdentityFunction(parameters, propertySpec);
    }
    var zoomAndFeatureDependent = stops && _typeof(stops[0][0]) === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    stops = stops.map(function (stop) {
        if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {
            return [stop[0], convertTokenString(stop[1])];
        }
        return [stop[0], convertLiteral(stop[1])];
    });
    if (zoomAndFeatureDependent) {
        return convertZoomAndPropertyFunction(parameters, propertySpec, stops);
    } else if (zoomDependent) {
        return convertZoomFunction(parameters, propertySpec, stops);
    } else {
        return convertPropertyFunction(parameters, propertySpec, stops);
    }
}
function convertIdentityFunction(parameters, propertySpec) {
    var get = ['get', parameters.property];
    if (parameters.default === undefined) {
        return propertySpec.type === 'string' ? ['string', get] : get;
    } else if (propertySpec.type === 'enum') {
        return ['match', get, Object.keys(propertySpec.values), get, parameters.default];
    } else {
        var expression = [propertySpec.type === 'color' ? 'to-color' : propertySpec.type, get, convertLiteral(parameters.default)];
        if (propertySpec.type === 'array') {
            expression.splice(1, 0, propertySpec.value, propertySpec.length || null);
        }
        return expression;
    }
}
function getInterpolateOperator(parameters) {
    switch (parameters.colorSpace) {
        case 'hcl':
            return 'interpolate-hcl';
        case 'lab':
            return 'interpolate-lab';
        default:
            return 'interpolate';
    }
}
function convertZoomAndPropertyFunction(parameters, propertySpec, stops) {
    var featureFunctionParameters = {};
    var featureFunctionStops = {};
    var zoomStops = [];
    for (var s = 0; s < stops.length; s++) {
        var stop = stops[s];
        var zoom = stop[0].zoom;
        if (featureFunctionParameters[zoom] === undefined) {
            featureFunctionParameters[zoom] = {
                zoom: zoom,
                type: parameters.type,
                property: parameters.property,
                default: parameters.default
            };
            featureFunctionStops[zoom] = [];
            zoomStops.push(zoom);
        }
        featureFunctionStops[zoom].push([stop[0].value, stop[1]]);
    }
    var functionType = getFunctionType({}, propertySpec);
    if (functionType === 'exponential') {
        var expression = [getInterpolateOperator(parameters), ['linear'], ['zoom']];
        for (var i = 0, list = zoomStops; i < list.length; i += 1) {
            var z = list[i];
            var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
            appendStopPair(expression, z, output, false);
        }
        return expression;
    } else {
        var expression$1 = ['step', ['zoom']];
        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {
            var z$1 = list$1[i$1];
            var output$1 = convertPropertyFunction(featureFunctionParameters[z$1], propertySpec, featureFunctionStops[z$1]);
            appendStopPair(expression$1, z$1, output$1, true);
        }
        fixupDegenerateStepCurve(expression$1);
        return expression$1;
    }
}
function coalesce$1(a, b) {
    if (a !== undefined) {
        return a;
    }
    if (b !== undefined) {
        return b;
    }
}
function convertPropertyFunction(parameters, propertySpec, stops) {
    var type = getFunctionType(parameters, propertySpec);
    var get = ['get', parameters.property];
    if (type === 'categorical' && typeof stops[0][0] === 'boolean') {
        var expression = ['case'];
        for (var i = 0, list = stops; i < list.length; i += 1) {
            var stop = list[i];
            expression.push(['==', get, stop[0]], stop[1]);
        }
        expression.push(convertLiteral(coalesce$1(parameters.default, propertySpec.default)));
        return expression;
    } else if (type === 'categorical') {
        var expression$1 = ['match', get];
        for (var i$1 = 0, list$1 = stops; i$1 < list$1.length; i$1 += 1) {
            var stop$1 = list$1[i$1];
            appendStopPair(expression$1, stop$1[0], stop$1[1], false);
        }
        expression$1.push(convertLiteral(coalesce$1(parameters.default, propertySpec.default)));
        return expression$1;
    } else if (type === 'interval') {
        var expression$2 = ['step', ['number', get]];
        for (var i$2 = 0, list$2 = stops; i$2 < list$2.length; i$2 += 1) {
            var stop$2 = list$2[i$2];
            appendStopPair(expression$2, stop$2[0], stop$2[1], true);
        }
        fixupDegenerateStepCurve(expression$2);
        return parameters.default === undefined ? expression$2 : ['case', ['==', ['typeof', get], 'number'], expression$2, convertLiteral(parameters.default)];
    } else if (type === 'exponential') {
        var base = parameters.base !== undefined ? parameters.base : 1;
        var expression$3 = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], ['number', get]];
        for (var i$3 = 0, list$3 = stops; i$3 < list$3.length; i$3 += 1) {
            var stop$3 = list$3[i$3];
            appendStopPair(expression$3, stop$3[0], stop$3[1], false);
        }
        return parameters.default === undefined ? expression$3 : ['case', ['==', ['typeof', get], 'number'], expression$3, convertLiteral(parameters.default)];
    } else {
        throw new Error('Unknown property function type ' + type);
    }
}
function convertZoomFunction(parameters, propertySpec, stops, input) {
    if (input === void 0) input = ['zoom'];
    var type = getFunctionType(parameters, propertySpec);
    var expression;
    var isStep = false;
    if (type === 'interval') {
        expression = ['step', input];
        isStep = true;
    } else if (type === 'exponential') {
        var base = parameters.base !== undefined ? parameters.base : 1;
        expression = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], input];
    } else {
        throw new Error('Unknown zoom function type "' + type + '"');
    }
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var stop = list[i];
        appendStopPair(expression, stop[0], stop[1], isStep);
    }
    fixupDegenerateStepCurve(expression);
    return expression;
}
function fixupDegenerateStepCurve(expression) {
    if (expression[0] === 'step' && expression.length === 3) {
        expression.push(0);
        expression.push(expression[3]);
    }
}
function appendStopPair(curve, input, output, isStep) {
    if (curve.length > 3 && input === curve[curve.length - 2]) {
        return;
    }
    if (!(isStep && curve.length === 2)) {
        curve.push(input);
    }
    curve.push(output);
}
function getFunctionType(parameters, propertySpec) {
    if (parameters.type) {
        return parameters.type;
    } else {
        return propertySpec.expression.interpolated ? 'exponential' : 'interval';
    }
}
function convertTokenString(s) {
    var result = ['concat'];
    var re = /{([^{}]+)}/g;
    var pos = 0;
    for (var match = re.exec(s); match !== null; match = re.exec(s)) {
        var literal = s.slice(pos, re.lastIndex - match[0].length);
        pos = re.lastIndex;
        if (literal.length > 0) {
            result.push(literal);
        }
        result.push(['get', match[1]]);
    }
    if (result.length === 1) {
        return s;
    }
    if (pos < s.length) {
        result.push(s.slice(pos));
    } else if (result.length === 2) {
        return ['to-string', result[1]];
    }
    return result;
}

function isExpressionFilter(filter) {
    if (filter === true || filter === false) {
        return true;
    }
    if (!Array.isArray(filter) || filter.length === 0) {
        return false;
    }
    switch (filter[0]) {
        case 'has':
            return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';
        case 'in':
            return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));
        case '!in':
        case '!has':
        case 'none':
            return false;
        case '==':
        case '!=':
        case '>':
        case '>=':
        case '<':
        case '<=':
            return filter.length !== 3 || Array.isArray(filter[1]) || Array.isArray(filter[2]);
        case 'any':
        case 'all':
            for (var i = 0, list = filter.slice(1); i < list.length; i += 1) {
                var f = list[i];
                if (!isExpressionFilter(f) && typeof f !== 'boolean') {
                    return false;
                }
            }
            return true;
        default:
            return true;
    }
}
var filterSpec = {
    'type': 'boolean',
    'default': false,
    'transition': false,
    'property-type': 'data-driven',
    'expression': {
        'interpolated': false,
        'parameters': ['zoom', 'feature']
    }
};
function createFilter(filter) {
    if (filter === null || filter === undefined) {
        return {
            filter: function filter() {
                return true;
            },
            needGeometry: false
        };
    }
    if (!isExpressionFilter(filter)) {
        filter = convertFilter(filter);
    }
    var compiled = createExpression(filter, filterSpec);
    if (compiled.result === 'error') {
        throw new Error(compiled.value.map(function (err) {
            return err.key + ': ' + err.message;
        }).join(', '));
    } else {
        var needGeometry = Array.isArray(filter) && filter.length !== 0 && filter[0] === 'within';
        return {
            filter: function filter(globalProperties, feature, canonical) {
                return compiled.value.evaluate(globalProperties, feature, {}, canonical);
            },
            needGeometry: needGeometry
        };
    }
}
function compare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
function convertFilter(filter) {
    if (!filter) {
        return true;
    }
    var op = filter[0];
    if (filter.length <= 1) {
        return op !== 'any';
    }
    var converted = op === '==' ? convertComparisonOp(filter[1], filter[2], '==') : op === '!=' ? convertNegation(convertComparisonOp(filter[1], filter[2], '==')) : op === '<' || op === '>' || op === '<=' || op === '>=' ? convertComparisonOp(filter[1], filter[2], op) : op === 'any' ? convertDisjunctionOp(filter.slice(1)) : op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter)) : op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === 'in' ? convertInOp(filter[1], filter.slice(2)) : op === '!in' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === 'has' ? convertHasOp(filter[1]) : op === '!has' ? convertNegation(convertHasOp(filter[1])) : true;
    return converted;
}
function convertComparisonOp(property, value, op) {
    switch (property) {
        case '$type':
            return ['filter-type-' + op, value];
        case '$id':
            return ['filter-id-' + op, value];
        default:
            return ['filter-' + op, property, value];
    }
}
function convertDisjunctionOp(filters) {
    return ['any'].concat(filters.map(convertFilter));
}
function convertInOp(property, values) {
    if (values.length === 0) {
        return false;
    }
    switch (property) {
        case '$type':
            return ['filter-type-in', ['literal', values]];
        case '$id':
            return ['filter-id-in', ['literal', values]];
        default:
            if (values.length > 200 && !values.some(function (v) {
                return (typeof v === "undefined" ? "undefined" : _typeof(v)) !== _typeof(values[0]);
            })) {
                return ['filter-in-large', property, ['literal', values.sort(compare)]];
            } else {
                return ['filter-in-small', property, ['literal', values]];
            }
    }
}
function convertHasOp(property) {
    switch (property) {
        case '$type':
            return true;
        case '$id':
            return ['filter-has-id'];
        default:
            return ['filter-has', property];
    }
}
function convertNegation(filter) {
    return ['!', filter];
}

function convertFilter$1(filter) {
    return _convertFilter(filter, {});
}
function _convertFilter(filter, expectedTypes) {
    var ref$1;
    if (isExpressionFilter(filter)) {
        return filter;
    }
    if (!filter) {
        return true;
    }
    var op = filter[0];
    if (filter.length <= 1) {
        return op !== 'any';
    }
    var converted;
    if (op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=') {
        var ref = filter;
        var property = ref[1];
        var value = ref[2];
        converted = convertComparisonOp$1(property, value, op, expectedTypes);
    } else if (op === 'any') {
        var children = filter.slice(1).map(function (f) {
            var types = {};
            var child = _convertFilter(f, types);
            var typechecks = runtimeTypeChecks(types);
            return typechecks === true ? child : ['case', typechecks, child, false];
        });
        return ['any'].concat(children);
    } else if (op === 'all') {
        var children$1 = filter.slice(1).map(function (f) {
            return _convertFilter(f, expectedTypes);
        });
        return children$1.length > 1 ? ['all'].concat(children$1) : (ref$1 = []).concat.apply(ref$1, children$1);
    } else if (op === 'none') {
        return ['!', _convertFilter(['any'].concat(filter.slice(1)), {})];
    } else if (op === 'in') {
        converted = convertInOp$1(filter[1], filter.slice(2));
    } else if (op === '!in') {
        converted = convertInOp$1(filter[1], filter.slice(2), true);
    } else if (op === 'has') {
        converted = convertHasOp$1(filter[1]);
    } else if (op === '!has') {
        converted = ['!', convertHasOp$1(filter[1])];
    } else {
        converted = true;
    }
    return converted;
}
function runtimeTypeChecks(expectedTypes) {
    var conditions = [];
    for (var property in expectedTypes) {
        var get = property === '$id' ? ['id'] : ['get', property];
        conditions.push(['==', ['typeof', get], expectedTypes[property]]);
    }
    if (conditions.length === 0) {
        return true;
    }
    if (conditions.length === 1) {
        return conditions[0];
    }
    return ['all'].concat(conditions);
}
function convertComparisonOp$1(property, value, op, expectedTypes) {
    var get;
    if (property === '$type') {
        return [op, ['geometry-type'], value];
    } else if (property === '$id') {
        get = ['id'];
    } else {
        get = ['get', property];
    }
    if (expectedTypes && value !== null) {
        var type = typeof value === "undefined" ? "undefined" : _typeof(value);
        expectedTypes[property] = type;
    }
    if (op === '==' && property !== '$id' && value === null) {
        return ['all', ['has', property], ['==', get, null]];
    } else if (op === '!=' && property !== '$id' && value === null) {
        return ['any', ['!', ['has', property]], ['!=', get, null]];
    }
    return [op, get, value];
}
function convertInOp$1(property, values, negate) {
    if (negate === void 0) negate = false;
    if (values.length === 0) {
        return negate;
    }
    var get;
    if (property === '$type') {
        get = ['geometry-type'];
    } else if (property === '$id') {
        get = ['id'];
    } else {
        get = ['get', property];
    }
    var uniformTypes = true;
    var type = _typeof(values[0]);
    for (var i = 0, list = values; i < list.length; i += 1) {
        var value = list[i];
        if ((typeof value === "undefined" ? "undefined" : _typeof(value)) !== type) {
            uniformTypes = false;
            break;
        }
    }
    if (uniformTypes && (type === 'string' || type === 'number')) {
        var uniqueValues = values.sort().filter(function (v, i) {
            return i === 0 || values[i - 1] !== v;
        });
        return ['match', get, uniqueValues, !negate, negate];
    }
    return [negate ? 'all' : 'any'].concat(values.map(function (v) {
        return [negate ? '!=' : '==', get, v];
    }));
}
function convertHasOp$1(property) {
    if (property === '$type') {
        return true;
    } else if (property === '$id') {
        return ['!=', ['id'], null];
    } else {
        return ['has', property];
    }
}

function migrateToExpressions(style) {
    var converted = [];
    eachLayer(style, function (layer) {
        if (layer.filter) {
            layer.filter = convertFilter$1(layer.filter);
        }
    });
    eachProperty(style, {
        paint: true,
        layout: true
    }, function (ref) {
        var path = ref.path;
        var value = ref.value;
        var reference = ref.reference;
        var set = ref.set;
        if (isExpression(value)) {
            return;
        }
        if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && !Array.isArray(value)) {
            set(convertFunction(value, reference));
            converted.push(path.join('.'));
        } else if (reference.tokens && typeof value === 'string') {
            set(convertTokenString(value));
        }
    });
    return style;
}

function migrate(style) {
    var migrated = false;
    if (style.version === 7) {
        style = migrateToV8(style);
        migrated = true;
    }
    if (style.version === 8) {
        migrated = migrateToExpressions(style);
        migrated = true;
    }
    if (!migrated) {
        throw new Error('cannot migrate from', style.version);
    }
    return style;
}

function composite(style) {
    var styleIDs = [];
    var sourceIDs = [];
    var compositedSourceLayers = [];
    for (var id in style.sources) {
        var source = style.sources[id];
        if (source.type !== 'vector') {
            continue;
        }
        var match = /^mapbox:\/\/(.*)/.exec(source.url);
        if (!match) {
            continue;
        }
        styleIDs.push(id);
        sourceIDs.push(match[1]);
    }
    if (styleIDs.length < 2) {
        return style;
    }
    styleIDs.forEach(function (id) {
        delete style.sources[id];
    });
    var compositeID = sourceIDs.join(',');
    style.sources[compositeID] = {
        'type': 'vector',
        'url': 'mapbox://' + compositeID
    };
    style.layers.forEach(function (layer) {
        if (styleIDs.indexOf(layer.source) >= 0) {
            layer.source = compositeID;
            if ('source-layer' in layer) {
                if (compositedSourceLayers.indexOf(layer['source-layer']) >= 0) {
                    throw new Error('Conflicting source layer names');
                } else {
                    compositedSourceLayers.push(layer['source-layer']);
                }
            }
        }
    });
    return style;
}

var refProperties = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];

function deref(layer, parent) {
    var result = {};
    for (var k in layer) {
        if (k !== 'ref') {
            result[k] = layer[k];
        }
    }
    refProperties.forEach(function (k) {
        if (k in parent) {
            result[k] = parent[k];
        }
    });
    return result;
}
function derefLayers(layers) {
    layers = layers.slice();
    var map = Object.create(null);
    for (var i = 0; i < layers.length; i++) {
        map[layers[i].id] = layers[i];
    }
    for (var i$1 = 0; i$1 < layers.length; i$1++) {
        if ('ref' in layers[i$1]) {
            layers[i$1] = deref(layers[i$1], map[layers[i$1].ref]);
        }
    }
    return layers;
}

function deepEqual(a, b) {
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    if ((typeof a === "undefined" ? "undefined" : _typeof(a)) === 'object' && a !== null && b !== null) {
        if (!((typeof b === "undefined" ? "undefined" : _typeof(b)) === 'object')) {
            return false;
        }
        var keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) {
            return false;
        }
        for (var key in a) {
            if (!deepEqual(a[key], b[key])) {
                return false;
            }
        }
        return true;
    }
    return a === b;
}

var operations = {
    setStyle: 'setStyle',
    addLayer: 'addLayer',
    removeLayer: 'removeLayer',
    setPaintProperty: 'setPaintProperty',
    setLayoutProperty: 'setLayoutProperty',
    setFilter: 'setFilter',
    addSource: 'addSource',
    removeSource: 'removeSource',
    setGeoJSONSourceData: 'setGeoJSONSourceData',
    setLayerZoomRange: 'setLayerZoomRange',
    setLayerProperty: 'setLayerProperty',
    setCenter: 'setCenter',
    setZoom: 'setZoom',
    setBearing: 'setBearing',
    setPitch: 'setPitch',
    setSprite: 'setSprite',
    setGlyphs: 'setGlyphs',
    setTransition: 'setTransition',
    setLight: 'setLight'
};
function addSource(sourceId, after, commands) {
    commands.push({
        command: operations.addSource,
        args: [sourceId, after[sourceId]]
    });
}
function removeSource(sourceId, commands, sourcesRemoved) {
    commands.push({
        command: operations.removeSource,
        args: [sourceId]
    });
    sourcesRemoved[sourceId] = true;
}
function updateSource(sourceId, after, commands, sourcesRemoved) {
    removeSource(sourceId, commands, sourcesRemoved);
    addSource(sourceId, after, commands);
}
function canUpdateGeoJSON(before, after, sourceId) {
    var prop;
    for (prop in before[sourceId]) {
        if (!before[sourceId].hasOwnProperty(prop)) {
            continue;
        }
        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {
            return false;
        }
    }
    for (prop in after[sourceId]) {
        if (!after[sourceId].hasOwnProperty(prop)) {
            continue;
        }
        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {
            return false;
        }
    }
    return true;
}
function diffSources(before, after, commands, sourcesRemoved) {
    before = before || {};
    after = after || {};
    var sourceId;
    for (sourceId in before) {
        if (!before.hasOwnProperty(sourceId)) {
            continue;
        }
        if (!after.hasOwnProperty(sourceId)) {
            removeSource(sourceId, commands, sourcesRemoved);
        }
    }
    for (sourceId in after) {
        if (!after.hasOwnProperty(sourceId)) {
            continue;
        }
        if (!before.hasOwnProperty(sourceId)) {
            addSource(sourceId, after, commands);
        } else if (!deepEqual(before[sourceId], after[sourceId])) {
            if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson' && canUpdateGeoJSON(before, after, sourceId)) {
                commands.push({
                    command: operations.setGeoJSONSourceData,
                    args: [sourceId, after[sourceId].data]
                });
            } else {
                updateSource(sourceId, after, commands, sourcesRemoved);
            }
        }
    }
}
function diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {
    before = before || {};
    after = after || {};
    var prop;
    for (prop in before) {
        if (!before.hasOwnProperty(prop)) {
            continue;
        }
        if (!deepEqual(before[prop], after[prop])) {
            commands.push({
                command: command,
                args: [layerId, prop, after[prop], klass]
            });
        }
    }
    for (prop in after) {
        if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) {
            continue;
        }
        if (!deepEqual(before[prop], after[prop])) {
            commands.push({
                command: command,
                args: [layerId, prop, after[prop], klass]
            });
        }
    }
}
function pluckId(layer) {
    return layer.id;
}
function indexById(group, layer) {
    group[layer.id] = layer;
    return group;
}
function diffLayers(before, after, commands) {
    before = before || [];
    after = after || [];
    var beforeOrder = before.map(pluckId);
    var afterOrder = after.map(pluckId);
    var beforeIndex = before.reduce(indexById, {});
    var afterIndex = after.reduce(indexById, {});
    var tracker = beforeOrder.slice();
    var clean = Object.create(null);
    var i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;
    for (i = 0, d = 0; i < beforeOrder.length; i++) {
        layerId = beforeOrder[i];
        if (!afterIndex.hasOwnProperty(layerId)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            tracker.splice(tracker.indexOf(layerId, d), 1);
        } else {
            d++;
        }
    }
    for (i = 0, d = 0; i < afterOrder.length; i++) {
        layerId = afterOrder[afterOrder.length - 1 - i];
        if (tracker[tracker.length - 1 - i] === layerId) {
            continue;
        }
        if (beforeIndex.hasOwnProperty(layerId)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);
        } else {
            d++;
        }
        insertBeforeLayerId = tracker[tracker.length - i];
        commands.push({
            command: operations.addLayer,
            args: [afterIndex[layerId], insertBeforeLayerId]
        });
        tracker.splice(tracker.length - i, 0, layerId);
        clean[layerId] = true;
    }
    for (i = 0; i < afterOrder.length; i++) {
        layerId = afterOrder[i];
        beforeLayer = beforeIndex[layerId];
        afterLayer = afterIndex[layerId];
        if (clean[layerId] || deepEqual(beforeLayer, afterLayer)) {
            continue;
        }
        if (!deepEqual(beforeLayer.source, afterLayer.source) || !deepEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !deepEqual(beforeLayer.type, afterLayer.type)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];
            commands.push({
                command: operations.addLayer,
                args: [afterLayer, insertBeforeLayerId]
            });
            continue;
        }
        diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);
        diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);
        if (!deepEqual(beforeLayer.filter, afterLayer.filter)) {
            commands.push({
                command: operations.setFilter,
                args: [layerId, afterLayer.filter]
            });
        }
        if (!deepEqual(beforeLayer.minzoom, afterLayer.minzoom) || !deepEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {
            commands.push({
                command: operations.setLayerZoomRange,
                args: [layerId, afterLayer.minzoom, afterLayer.maxzoom]
            });
        }
        for (prop in beforeLayer) {
            if (!beforeLayer.hasOwnProperty(prop)) {
                continue;
            }
            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') {
                continue;
            }
            if (prop.indexOf('paint.') === 0) {
                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
            } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {
                commands.push({
                    command: operations.setLayerProperty,
                    args: [layerId, prop, afterLayer[prop]]
                });
            }
        }
        for (prop in afterLayer) {
            if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) {
                continue;
            }
            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') {
                continue;
            }
            if (prop.indexOf('paint.') === 0) {
                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
            } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {
                commands.push({
                    command: operations.setLayerProperty,
                    args: [layerId, prop, afterLayer[prop]]
                });
            }
        }
    }
}
function diffStyles(before, after) {
    if (!before) {
        return [{
            command: operations.setStyle,
            args: [after]
        }];
    }
    var commands = [];
    try {
        if (!deepEqual(before.version, after.version)) {
            return [{
                command: operations.setStyle,
                args: [after]
            }];
        }
        if (!deepEqual(before.center, after.center)) {
            commands.push({
                command: operations.setCenter,
                args: [after.center]
            });
        }
        if (!deepEqual(before.zoom, after.zoom)) {
            commands.push({
                command: operations.setZoom,
                args: [after.zoom]
            });
        }
        if (!deepEqual(before.bearing, after.bearing)) {
            commands.push({
                command: operations.setBearing,
                args: [after.bearing]
            });
        }
        if (!deepEqual(before.pitch, after.pitch)) {
            commands.push({
                command: operations.setPitch,
                args: [after.pitch]
            });
        }
        if (!deepEqual(before.sprite, after.sprite)) {
            commands.push({
                command: operations.setSprite,
                args: [after.sprite]
            });
        }
        if (!deepEqual(before.glyphs, after.glyphs)) {
            commands.push({
                command: operations.setGlyphs,
                args: [after.glyphs]
            });
        }
        if (!deepEqual(before.transition, after.transition)) {
            commands.push({
                command: operations.setTransition,
                args: [after.transition]
            });
        }
        if (!deepEqual(before.light, after.light)) {
            commands.push({
                command: operations.setLight,
                args: [after.light]
            });
        }
        var sourcesRemoved = {};
        var removeOrAddSourceCommands = [];
        diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);
        var beforeLayers = [];
        if (before.layers) {
            before.layers.forEach(function (layer) {
                if (sourcesRemoved[layer.source]) {
                    commands.push({
                        command: operations.removeLayer,
                        args: [layer.id]
                    });
                } else {
                    beforeLayers.push(layer);
                }
            });
        }
        commands = commands.concat(removeOrAddSourceCommands);
        diffLayers(beforeLayers, after.layers, commands);
    } catch (e) {
        console.warn('Unable to compute style diff:', e);
        commands = [{
            command: operations.setStyle,
            args: [after]
        }];
    }
    return commands;
}

var ValidationError = function ValidationError(key, value, message, identifier) {
    this.message = (key ? key + ': ' : '') + message;
    if (identifier) {
        this.identifier = identifier;
    }
    if (value !== null && value !== undefined && value.__line__) {
        this.line = value.__line__;
    }
};

var ParsingError$1 = function ParsingError(error) {
    this.error = error;
    this.message = error.message;
    var match = error.message.match(/line (\d+)/);
    this.line = match ? parseInt(match[1], 10) : 0;
};

function validateConstants(options) {
    var key = options.key;
    var constants = options.value;
    if (constants) {
        return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
    } else {
        return [];
    }
}

function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
        return value.valueOf();
    } else {
        return value;
    }
}
function deepUnbundle(value) {
    if (Array.isArray(value)) {
        return value.map(deepUnbundle);
    } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {
        var unbundledValue = {};
        for (var key in value) {
            unbundledValue[key] = deepUnbundle(value[key]);
        }
        return unbundledValue;
    }
    return unbundle(value);
}

function validateObject(options) {
    var key = options.key;
    var object = options.value;
    var elementSpecs = options.valueSpec || {};
    var elementValidators = options.objectElementValidators || {};
    var style = options.style;
    var styleSpec = options.styleSpec;
    var errors = [];
    var type = getType(object);
    if (type !== 'object') {
        return [new ValidationError(key, object, 'object expected, ' + type + ' found')];
    }
    for (var objectKey in object) {
        var elementSpecKey = objectKey.split('.')[0];
        var elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];
        var validateElement = void 0;
        if (elementValidators[elementSpecKey]) {
            validateElement = elementValidators[elementSpecKey];
        } else if (elementSpecs[elementSpecKey]) {
            validateElement = validate;
        } else if (elementValidators['*']) {
            validateElement = elementValidators['*'];
        } else if (elementSpecs['*']) {
            validateElement = validate;
        } else {
            errors.push(new ValidationError(key, object[objectKey], 'unknown property "' + objectKey + '"'));
            continue;
        }
        errors = errors.concat(validateElement({
            key: (key ? key + '.' : key) + objectKey,
            value: object[objectKey],
            valueSpec: elementSpec,
            style: style,
            styleSpec: styleSpec,
            object: object,
            objectKey: objectKey
        }, object));
    }
    for (var elementSpecKey$1 in elementSpecs) {
        if (elementValidators[elementSpecKey$1]) {
            continue;
        }
        if (elementSpecs[elementSpecKey$1].required && elementSpecs[elementSpecKey$1]['default'] === undefined && object[elementSpecKey$1] === undefined) {
            errors.push(new ValidationError(key, object, 'missing required property "' + elementSpecKey$1 + '"'));
        }
    }
    return errors;
}

function validateArray(options) {
    var array = options.value;
    var arraySpec = options.valueSpec;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var key = options.key;
    var validateArrayElement = options.arrayElementValidator || validate;
    if (getType(array) !== 'array') {
        return [new ValidationError(key, array, 'array expected, ' + getType(array) + ' found')];
    }
    if (arraySpec.length && array.length !== arraySpec.length) {
        return [new ValidationError(key, array, 'array length ' + arraySpec.length + ' expected, length ' + array.length + ' found')];
    }
    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
        return [new ValidationError(key, array, 'array length at least ' + arraySpec['min-length'] + ' expected, length ' + array.length + ' found')];
    }
    var arrayElementSpec = {
        'type': arraySpec.value,
        'values': arraySpec.values
    };
    if (styleSpec.$version < 7) {
        arrayElementSpec.function = arraySpec.function;
    }
    if (getType(arraySpec.value) === 'object') {
        arrayElementSpec = arraySpec.value;
    }
    var errors = [];
    for (var i = 0; i < array.length; i++) {
        errors = errors.concat(validateArrayElement({
            array: array,
            arrayIndex: i,
            value: array[i],
            valueSpec: arrayElementSpec,
            style: style,
            styleSpec: styleSpec,
            key: key + '[' + i + ']'
        }));
    }
    return errors;
}

function validateNumber(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var type = getType(value);
    if (type === 'number' && value !== value) {
        type = 'NaN';
    }
    if (type !== 'number') {
        return [new ValidationError(key, value, 'number expected, ' + type + ' found')];
    }
    if ('minimum' in valueSpec && value < valueSpec.minimum) {
        return [new ValidationError(key, value, value + ' is less than the minimum value ' + valueSpec.minimum)];
    }
    if ('maximum' in valueSpec && value > valueSpec.maximum) {
        return [new ValidationError(key, value, value + ' is greater than the maximum value ' + valueSpec.maximum)];
    }
    return [];
}

function validateFunction(options) {
    var functionValueSpec = options.valueSpec;
    var functionType = unbundle(options.value.type);
    var stopKeyType;
    var stopDomainValues = {};
    var previousStopDomainValue;
    var previousStopDomainZoom;
    var isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;
    var isPropertyFunction = !isZoomFunction;
    var isZoomAndPropertyFunction = getType(options.value.stops) === 'array' && getType(options.value.stops[0]) === 'array' && getType(options.value.stops[0][0]) === 'object';
    var errors = validateObject({
        key: options.key,
        value: options.value,
        valueSpec: options.styleSpec.function,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            stops: validateFunctionStops,
            default: validateFunctionDefault
        }
    });
    if (functionType === 'identity' && isZoomFunction) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "property"'));
    }
    if (functionType !== 'identity' && !options.value.stops) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "stops"'));
    }
    if (functionType === 'exponential' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {
        errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));
    }
    if (options.styleSpec.$version >= 8) {
        if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {
            errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));
        } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {
            errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));
        }
    }
    if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {
        errors.push(new ValidationError(options.key, options.value, '"property" property is required'));
    }
    return errors;
    function validateFunctionStops(options) {
        if (functionType === 'identity') {
            return [new ValidationError(options.key, options.value, 'identity function may not have a "stops" property')];
        }
        var errors = [];
        var value = options.value;
        errors = errors.concat(validateArray({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec,
            style: options.style,
            styleSpec: options.styleSpec,
            arrayElementValidator: validateFunctionStop
        }));
        if (getType(value) === 'array' && value.length === 0) {
            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
        }
        return errors;
    }
    function validateFunctionStop(options) {
        var errors = [];
        var value = options.value;
        var key = options.key;
        if (getType(value) !== 'array') {
            return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];
        }
        if (value.length !== 2) {
            return [new ValidationError(key, value, 'array length 2 expected, length ' + value.length + ' found')];
        }
        if (isZoomAndPropertyFunction) {
            if (getType(value[0]) !== 'object') {
                return [new ValidationError(key, value, 'object expected, ' + getType(value[0]) + ' found')];
            }
            if (value[0].zoom === undefined) {
                return [new ValidationError(key, value, 'object stop key must have zoom')];
            }
            if (value[0].value === undefined) {
                return [new ValidationError(key, value, 'object stop key must have value')];
            }
            if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {
                return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];
            }
            if (unbundle(value[0].zoom) !== previousStopDomainZoom) {
                previousStopDomainZoom = unbundle(value[0].zoom);
                previousStopDomainValue = undefined;
                stopDomainValues = {};
            }
            errors = errors.concat(validateObject({
                key: key + '[0]',
                value: value[0],
                valueSpec: { zoom: {} },
                style: options.style,
                styleSpec: options.styleSpec,
                objectElementValidators: {
                    zoom: validateNumber,
                    value: validateStopDomainValue
                }
            }));
        } else {
            errors = errors.concat(validateStopDomainValue({
                key: key + '[0]',
                value: value[0],
                valueSpec: {},
                style: options.style,
                styleSpec: options.styleSpec
            }, value));
        }
        if (isExpression(deepUnbundle(value[1]))) {
            return errors.concat([new ValidationError(key + '[1]', value[1], 'expressions are not allowed in function stops.')]);
        }
        return errors.concat(validate({
            key: key + '[1]',
            value: value[1],
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        }));
    }
    function validateStopDomainValue(options, stop) {
        var type = getType(options.value);
        var value = unbundle(options.value);
        var reportValue = options.value !== null ? options.value : stop;
        if (!stopKeyType) {
            stopKeyType = type;
        } else if (type !== stopKeyType) {
            return [new ValidationError(options.key, reportValue, type + ' stop domain type must match previous stop domain type ' + stopKeyType)];
        }
        if (type !== 'number' && type !== 'string' && type !== 'boolean') {
            return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];
        }
        if (type !== 'number' && functionType !== 'categorical') {
            var message = 'number expected, ' + type + ' found';
            if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {
                message += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.';
            }
            return [new ValidationError(options.key, reportValue, message)];
        }
        if (functionType === 'categorical' && type === 'number' && (!isFinite(value) || Math.floor(value) !== value)) {
            return [new ValidationError(options.key, reportValue, 'integer expected, found ' + value)];
        }
        if (functionType !== 'categorical' && type === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];
        } else {
            previousStopDomainValue = value;
        }
        if (functionType === 'categorical' && value in stopDomainValues) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];
        } else {
            stopDomainValues[value] = true;
        }
        return [];
    }
    function validateFunctionDefault(options) {
        return validate({
            key: options.key,
            value: options.value,
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        });
    }
}

function validateExpression(options) {
    var expression = (options.expressionContext === 'property' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);
    if (expression.result === 'error') {
        return expression.value.map(function (error) {
            return new ValidationError('' + options.key + error.key, options.value, error.message);
        });
    }
    var expressionObj = expression.value.expression || expression.value._styleExpression.expression;
    if (options.expressionContext === 'property' && options.propertyKey === 'text-font' && !expressionObj.outputDefined()) {
        return [new ValidationError(options.key, options.value, 'Invalid data expression for "' + options.propertyKey + '". Output values must be contained as literals within the expression.')];
    }
    if (options.expressionContext === 'property' && options.propertyType === 'layout' && !isStateConstant(expressionObj)) {
        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with layout properties.')];
    }
    if (options.expressionContext === 'filter' && !isStateConstant(expressionObj)) {
        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with filters.')];
    }
    if (options.expressionContext && options.expressionContext.indexOf('cluster') === 0) {
        if (!isGlobalPropertyConstant(expressionObj, ['zoom', 'feature-state'])) {
            return [new ValidationError(options.key, options.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
        }
        if (options.expressionContext === 'cluster-initial' && !isFeatureConstant(expressionObj)) {
            return [new ValidationError(options.key, options.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];
        }
    }
    return [];
}

function validateBoolean(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);
    if (type !== 'boolean') {
        return [new ValidationError(key, value, 'boolean expected, ' + type + ' found')];
    }
    return [];
}

function validateColor(options) {
    var key = options.key;
    var value = options.value;
    var type = getType(value);
    if (type !== 'string') {
        return [new ValidationError(key, value, 'color expected, ' + type + ' found')];
    }
    if (csscolorparser_1(value) === null) {
        return [new ValidationError(key, value, 'color expected, "' + value + '" found')];
    }
    return [];
}

function validateEnum(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var errors = [];
    if (Array.isArray(valueSpec.values)) {
        if (valueSpec.values.indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, 'expected one of [' + valueSpec.values.join(', ') + '], ' + JSON.stringify(value) + ' found'));
        }
    } else {
        if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, 'expected one of [' + Object.keys(valueSpec.values).join(', ') + '], ' + JSON.stringify(value) + ' found'));
        }
    }
    return errors;
}

function validateFilter(options) {
    if (isExpressionFilter(deepUnbundle(options.value))) {
        return validateExpression(extend({}, options, {
            expressionContext: 'filter',
            valueSpec: { value: 'boolean' }
        }));
    } else {
        return validateNonExpressionFilter(options);
    }
}
function validateNonExpressionFilter(options) {
    var value = options.value;
    var key = options.key;
    if (getType(value) !== 'array') {
        return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];
    }
    var styleSpec = options.styleSpec;
    var type;
    var errors = [];
    if (value.length < 1) {
        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
    }
    errors = errors.concat(validateEnum({
        key: key + '[0]',
        value: value[0],
        valueSpec: styleSpec.filter_operator,
        style: options.style,
        styleSpec: options.styleSpec
    }));
    switch (unbundle(value[0])) {
        case '<':
        case '<=':
        case '>':
        case '>=':
            if (value.length >= 2 && unbundle(value[1]) === '$type') {
                errors.push(new ValidationError(key, value, '"$type" cannot be use with operator "' + value[0] + '"'));
            }
        case '==':
        case '!=':
            if (value.length !== 3) {
                errors.push(new ValidationError(key, value, 'filter array for operator "' + value[0] + '" must have 3 elements'));
            }
        case 'in':
        case '!in':
            if (value.length >= 2) {
                type = getType(value[1]);
                if (type !== 'string') {
                    errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));
                }
            }
            for (var i = 2; i < value.length; i++) {
                type = getType(value[i]);
                if (unbundle(value[1]) === '$type') {
                    errors = errors.concat(validateEnum({
                        key: key + '[' + i + ']',
                        value: value[i],
                        valueSpec: styleSpec.geometry_type,
                        style: options.style,
                        styleSpec: options.styleSpec
                    }));
                } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'string, number, or boolean expected, ' + type + ' found'));
                }
            }
            break;
        case 'any':
        case 'all':
        case 'none':
            for (var i$1 = 1; i$1 < value.length; i$1++) {
                errors = errors.concat(validateNonExpressionFilter({
                    key: key + '[' + i$1 + ']',
                    value: value[i$1],
                    style: options.style,
                    styleSpec: options.styleSpec
                }));
            }
            break;
        case 'has':
        case '!has':
            type = getType(value[1]);
            if (value.length !== 2) {
                errors.push(new ValidationError(key, value, 'filter array for "' + value[0] + '" operator must have 2 elements'));
            } else if (type !== 'string') {
                errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));
            }
            break;
    }
    return errors;
}

function validateProperty(options, propertyType) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec[propertyType + '_' + options.layerType];
    if (!layerSpec) {
        return [];
    }
    var transitionMatch = propertyKey.match(/^(.*)-transition$/);
    if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
        return validate({
            key: key,
            value: value,
            valueSpec: styleSpec.transition,
            style: style,
            styleSpec: styleSpec
        });
    }
    var valueSpec = options.valueSpec || layerSpec[propertyKey];
    if (!valueSpec) {
        return [new ValidationError(key, value, 'unknown property "' + propertyKey + '"')];
    }
    var tokenMatch;
    if (getType(value) === 'string' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {
        return [new ValidationError(key, value, '"' + propertyKey + '" does not support interpolation syntax\n' + 'Use an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(tokenMatch[1]) + ' }`.')];
    }
    var errors = [];
    if (options.layerType === 'symbol') {
        if (propertyKey === 'text-field' && style && !style.glyphs) {
            errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
        }
        if (propertyKey === 'text-font' && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === 'identity') {
            errors.push(new ValidationError(key, value, '"text-font" does not support identity functions'));
        }
    }
    return errors.concat(validate({
        key: options.key,
        value: value,
        valueSpec: valueSpec,
        style: style,
        styleSpec: styleSpec,
        expressionContext: 'property',
        propertyType: propertyType,
        propertyKey: propertyKey
    }));
}

function validatePaintProperty(options) {
    return validateProperty(options, 'paint');
}

function validateLayoutProperty(options) {
    return validateProperty(options, 'layout');
}

function validateLayer(options) {
    var errors = [];
    var layer = options.value;
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    if (!layer.type && !layer.ref) {
        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
    }
    var type = unbundle(layer.type);
    var ref = unbundle(layer.ref);
    if (layer.id) {
        var layerId = unbundle(layer.id);
        for (var i = 0; i < options.arrayIndex; i++) {
            var otherLayer = style.layers[i];
            if (unbundle(otherLayer.id) === layerId) {
                errors.push(new ValidationError(key, layer.id, 'duplicate layer id "' + layer.id + '", previously used at line ' + otherLayer.id.__line__));
            }
        }
    }
    if ('ref' in layer) {
        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
            if (p in layer) {
                errors.push(new ValidationError(key, layer[p], '"' + p + '" is prohibited for ref layers'));
            }
        });
        var parent;
        style.layers.forEach(function (layer) {
            if (unbundle(layer.id) === ref) {
                parent = layer;
            }
        });
        if (!parent) {
            errors.push(new ValidationError(key, layer.ref, 'ref layer "' + ref + '" not found'));
        } else if (parent.ref) {
            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
        } else {
            type = unbundle(parent.type);
        }
    } else if (type !== 'background') {
        if (!layer.source) {
            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
        } else {
            var source = style.sources && style.sources[layer.source];
            var sourceType = source && unbundle(source.type);
            if (!source) {
                errors.push(new ValidationError(key, layer.source, 'source "' + layer.source + '" not found'));
            } else if (sourceType === 'vector' && type === 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "' + layer.id + '" requires a raster source'));
            } else if (sourceType === 'raster' && type !== 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "' + layer.id + '" requires a vector source'));
            } else if (sourceType === 'vector' && !layer['source-layer']) {
                errors.push(new ValidationError(key, layer, 'layer "' + layer.id + '" must specify a "source-layer"'));
            } else if (sourceType === 'raster-dem' && type !== 'hillshade') {
                errors.push(new ValidationError(key, layer.source, 'raster-dem source can only be used with layer type \'hillshade\'.'));
            } else if (type === 'line' && layer.paint && layer.paint['line-gradient'] && (sourceType !== 'geojson' || !source.lineMetrics)) {
                errors.push(new ValidationError(key, layer, 'layer "' + layer.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'));
            }
        }
    }
    errors = errors.concat(validateObject({
        key: key,
        value: layer,
        valueSpec: styleSpec.layer,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            '*': function _() {
                return [];
            },
            type: function type() {
                return validate({
                    key: key + '.type',
                    value: layer.type,
                    valueSpec: styleSpec.layer.type,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    object: layer,
                    objectKey: 'type'
                });
            },
            filter: validateFilter,
            layout: function layout(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function _(options) {
                            return validateLayoutProperty(extend({ layerType: type }, options));
                        }
                    }
                });
            },
            paint: function paint(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function _(options) {
                            return validatePaintProperty(extend({ layerType: type }, options));
                        }
                    }
                });
            }
        }
    }));
    return errors;
}

function validateString(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);
    if (type !== 'string') {
        return [new ValidationError(key, value, 'string expected, ' + type + ' found')];
    }
    return [];
}

var objectElementValidators = { promoteId: validatePromoteId };
function validateSource(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;
    if (!value.type) {
        return [new ValidationError(key, value, '"type" is required')];
    }
    var type = unbundle(value.type);
    var errors;
    switch (type) {
        case 'vector':
        case 'raster':
        case 'raster-dem':
            errors = validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec['source_' + type.replace('-', '_')],
                style: options.style,
                styleSpec: styleSpec,
                objectElementValidators: objectElementValidators
            });
            return errors;
        case 'geojson':
            errors = validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_geojson,
                style: style,
                styleSpec: styleSpec,
                objectElementValidators: objectElementValidators
            });
            if (value.cluster) {
                for (var prop in value.clusterProperties) {
                    var ref = value.clusterProperties[prop];
                    var operator = ref[0];
                    var mapExpr = ref[1];
                    var reduceExpr = typeof operator === 'string' ? [operator, ['accumulated'], ['get', prop]] : operator;
                    errors.push.apply(errors, validateExpression({
                        key: key + '.' + prop + '.map',
                        value: mapExpr,
                        expressionContext: 'cluster-map'
                    }));
                    errors.push.apply(errors, validateExpression({
                        key: key + '.' + prop + '.reduce',
                        value: reduceExpr,
                        expressionContext: 'cluster-reduce'
                    }));
                }
            }
            return errors;
        case 'video':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_video,
                style: style,
                styleSpec: styleSpec
            });
        case 'image':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_image,
                style: style,
                styleSpec: styleSpec
            });
        case 'canvas':
            return [new ValidationError(key, null, 'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.', 'source.canvas')];
        default:
            return validateEnum({
                key: key + '.type',
                value: value.type,
                valueSpec: {
                    values: ['vector', 'raster', 'raster-dem', 'geojson', 'video', 'image']
                },
                style: style,
                styleSpec: styleSpec
            });
    }
}
function validatePromoteId(ref) {
    var key = ref.key;
    var value = ref.value;
    if (getType(value) === 'string') {
        return validateString({
            key: key,
            value: value
        });
    } else {
        var errors = [];
        for (var prop in value) {
            errors.push.apply(errors, validateString({
                key: key + '.' + prop,
                value: value[prop]
            }));
        }
        return errors;
    }
}

function validateLight(options) {
    var light = options.value;
    var styleSpec = options.styleSpec;
    var lightSpec = styleSpec.light;
    var style = options.style;
    var errors = [];
    var rootType = getType(light);
    if (light === undefined) {
        return errors;
    } else if (rootType !== 'object') {
        errors = errors.concat([new ValidationError('light', light, 'object expected, ' + rootType + ' found')]);
        return errors;
    }
    for (var key in light) {
        var transitionMatch = key.match(/^(.*)-transition$/);
        if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: styleSpec.transition,
                style: style,
                styleSpec: styleSpec
            }));
        } else if (lightSpec[key]) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: lightSpec[key],
                style: style,
                styleSpec: styleSpec
            }));
        } else {
            errors = errors.concat([new ValidationError(key, light[key], 'unknown property "' + key + '"')]);
        }
    }
    return errors;
}

function validateFormatted(options) {
    if (validateString(options).length === 0) {
        return [];
    }
    return validateExpression(options);
}

function validateImage(options) {
    if (validateString(options).length === 0) {
        return [];
    }
    return validateExpression(options);
}

var VALIDATORS = {
    '*': function _() {
        return [];
    },
    'array': validateArray,
    'boolean': validateBoolean,
    'number': validateNumber,
    'color': validateColor,
    'constants': validateConstants,
    'enum': validateEnum,
    'filter': validateFilter,
    'function': validateFunction,
    'layer': validateLayer,
    'object': validateObject,
    'source': validateSource,
    'light': validateLight,
    'string': validateString,
    'formatted': validateFormatted,
    'resolvedImage': validateImage
};
function validate(options) {
    var value = options.value;
    var valueSpec = options.valueSpec;
    var styleSpec = options.styleSpec;
    if (valueSpec.expression && isFunction$1(unbundle(value))) {
        return validateFunction(options);
    } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {
        return validateExpression(options);
    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
        return VALIDATORS[valueSpec.type](options);
    } else {
        var valid = validateObject(extend({}, options, { valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec }));
        return valid;
    }
}

function validateGlyphsURL(options) {
    var value = options.value;
    var key = options.key;
    var errors = validateString(options);
    if (errors.length) {
        return errors;
    }
    if (value.indexOf('{fontstack}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
    }
    if (value.indexOf('{range}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
    }
    return errors;
}

function validateStyleMin(style, styleSpec) {
    if (styleSpec === void 0) styleSpec = v8;
    var errors = [];
    errors = errors.concat(validate({
        key: '',
        value: style,
        valueSpec: styleSpec.$root,
        styleSpec: styleSpec,
        style: style,
        objectElementValidators: {
            glyphs: validateGlyphsURL,
            '*': function _() {
                return [];
            }
        }
    }));
    if (style.constants) {
        errors = errors.concat(validateConstants({
            key: 'constants',
            value: style.constants,
            style: style,
            styleSpec: styleSpec
        }));
    }
    return sortErrors(errors);
}
validateStyleMin.source = wrapCleanErrors(validateSource);
validateStyleMin.light = wrapCleanErrors(validateLight);
validateStyleMin.layer = wrapCleanErrors(validateLayer);
validateStyleMin.filter = wrapCleanErrors(validateFilter);
validateStyleMin.paintProperty = wrapCleanErrors(validatePaintProperty);
validateStyleMin.layoutProperty = wrapCleanErrors(validateLayoutProperty);
function sortErrors(errors) {
    return [].concat(errors).sort(function (a, b) {
        return a.line - b.line;
    });
}
function wrapCleanErrors(inner) {
    return function () {
        var args = [],
            len = arguments.length;
        while (len--) {
            args[len] = arguments[len];
        }return sortErrors(inner.apply(this, args));
    };
}

var jsonlint = createCommonjsModule(function (module, exports) {
    /* parser generated by jison 0.4.15 */
    /*
      Returns a Parser object of the following structure:
    
      Parser: {
        yy: {}
      }
    
      Parser.prototype: {
        yy: {},
        trace: function(),
        symbols_: {associative list: name ==> number},
        terminals_: {associative list: number ==> name},
        productions_: [...],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
        table: [...],
        defaultActions: {...},
        parseError: function(str, hash),
        parse: function(input),
    
        lexer: {
            EOF: 1,
            parseError: function(str, hash),
            setInput: function(input),
            input: function(),
            unput: function(str),
            more: function(),
            less: function(n),
            pastInput: function(),
            upcomingInput: function(),
            showPosition: function(),
            test_match: function(regex_match_array, rule_index),
            next: function(),
            lex: function(),
            begin: function(condition),
            popState: function(),
            _currentRules: function(),
            topState: function(),
            pushState: function(condition),
    
            options: {
                ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
            },
    
            performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
            rules: [...],
            conditions: {associative list: name ==> set},
        }
      }
    
    
      token location info (@$, _$, etc.): {
        first_line: n,
        last_line: n,
        first_column: n,
        last_column: n,
        range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
      }
    
    
      the parseError function receives a 'hash' object with these members for lexer and parser errors: {
        text:        (matched text)
        token:       (the produced terminal token, if any)
        line:        (yylineno)
      }
      while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
        loc:         (yylloc)
        expected:    (string describing the set of expected tokens)
        recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
      }
    */
    var parser = function () {
        var o = function o(k, v, _o, l) {
            for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {}return _o;
        },
            $V0 = [1, 12],
            $V1 = [1, 13],
            $V2 = [1, 9],
            $V3 = [1, 10],
            $V4 = [1, 11],
            $V5 = [1, 14],
            $V6 = [1, 15],
            $V7 = [14, 18, 22, 24],
            $V8 = [18, 22],
            $V9 = [22, 24];
        var parser = { trace: function trace() {},
            yy: {},
            symbols_: { "error": 2, "JSONString": 3, "STRING": 4, "JSONNumber": 5, "NUMBER": 6, "JSONNullLiteral": 7, "NULL": 8, "JSONBooleanLiteral": 9, "TRUE": 10, "FALSE": 11, "JSONText": 12, "JSONValue": 13, "EOF": 14, "JSONObject": 15, "JSONArray": 16, "{": 17, "}": 18, "JSONMemberList": 19, "JSONMember": 20, ":": 21, ",": 22, "[": 23, "]": 24, "JSONElementList": 25, "$accept": 0, "$end": 1 },
            terminals_: { 2: "error", 4: "STRING", 6: "NUMBER", 8: "NULL", 10: "TRUE", 11: "FALSE", 14: "EOF", 17: "{", 18: "}", 21: ":", 22: ",", 23: "[", 24: "]" },
            productions_: [0, [3, 1], [5, 1], [7, 1], [9, 1], [9, 1], [12, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [15, 2], [15, 3], [20, 3], [19, 1], [19, 3], [16, 2], [16, 3], [25, 1], [25, 3]],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
                /* this == yyval */

                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1:
                        // replace escaped characters with actual character
                        this.$ = new String(yytext.replace(/\\(\\|")/g, "$" + "1").replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\v/g, '\v').replace(/\\f/g, '\f').replace(/\\b/g, '\b'));
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 2:

                        this.$ = new Number(yytext);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 3:

                        this.$ = null;

                        break;
                    case 4:

                        this.$ = new Boolean(true);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 5:

                        this.$ = new Boolean(false);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 6:
                        return this.$ = $$[$0 - 1];
                    case 13:
                        this.$ = {};Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 14:case 19:
                        this.$ = $$[$0 - 1];Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 15:
                        this.$ = [$$[$0 - 2], $$[$0]];
                        break;
                    case 16:
                        this.$ = {};this.$[$$[$0][0]] = $$[$0][1];
                        break;
                    case 17:
                        this.$ = $$[$0 - 2];$$[$0 - 2][$$[$0][0]] = $$[$0][1];
                        break;
                    case 18:
                        this.$ = [];Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 20:
                        this.$ = [$$[$0]];
                        break;
                    case 21:
                        this.$ = $$[$0 - 2];$$[$0 - 2].push($$[$0]);
                        break;
                }
            },
            table: [{ 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 12: 1, 13: 2, 15: 7, 16: 8, 17: $V5, 23: $V6 }, { 1: [3] }, { 14: [1, 16] }, o($V7, [2, 7]), o($V7, [2, 8]), o($V7, [2, 9]), o($V7, [2, 10]), o($V7, [2, 11]), o($V7, [2, 12]), o($V7, [2, 3]), o($V7, [2, 4]), o($V7, [2, 5]), o([14, 18, 21, 22, 24], [2, 1]), o($V7, [2, 2]), { 3: 20, 4: $V0, 18: [1, 17], 19: 18, 20: 19 }, { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 23, 15: 7, 16: 8, 17: $V5, 23: $V6, 24: [1, 21], 25: 22 }, { 1: [2, 6] }, o($V7, [2, 13]), { 18: [1, 24], 22: [1, 25] }, o($V8, [2, 16]), { 21: [1, 26] }, o($V7, [2, 18]), { 22: [1, 28], 24: [1, 27] }, o($V9, [2, 20]), o($V7, [2, 14]), { 3: 20, 4: $V0, 20: 29 }, { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 30, 15: 7, 16: 8, 17: $V5, 23: $V6 }, o($V7, [2, 19]), { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 31, 15: 7, 16: 8, 17: $V5, 23: $V6 }, o($V8, [2, 17]), o($V8, [2, 15]), o($V9, [2, 21])],
            defaultActions: { 16: [2, 6] },
            parseError: function parseError(str, hash) {
                if (hash.recoverable) {
                    this.trace(str);
                } else {
                    throw new Error(str);
                }
            },
            parse: function parse(input) {
                var self = this,
                    stack = [0],
                    vstack = [null],
                    lstack = [],
                    table = this.table,
                    yytext = '',
                    yylineno = 0,
                    yyleng = 0,
                    TERROR = 2,
                    EOF = 1;
                var args = lstack.slice.call(arguments, 1);
                var lexer = Object.create(this.lexer);
                var sharedState = { yy: {} };
                for (var k in this.yy) {
                    if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                        sharedState.yy[k] = this.yy[k];
                    }
                }
                lexer.setInput(input, sharedState.yy);
                sharedState.yy.lexer = lexer;
                sharedState.yy.parser = this;
                if (typeof lexer.yylloc == 'undefined') {
                    lexer.yylloc = {};
                }
                var yyloc = lexer.yylloc;
                lstack.push(yyloc);
                var ranges = lexer.options && lexer.options.ranges;
                if (typeof sharedState.yy.parseError === 'function') {
                    this.parseError = sharedState.yy.parseError;
                } else {
                    this.parseError = Object.getPrototypeOf(this).parseError;
                }

                function lex() {
                    var token;
                    token = lexer.lex() || EOF;
                    if (typeof token !== 'number') {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                }
                var symbol,
                    state,
                    action,
                    r,
                    yyval = {},
                    p,
                    len,
                    newState,
                    expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    } else {
                        if (symbol === null || typeof symbol == 'undefined') {
                            symbol = lex();
                        }
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                        var errStr = '';
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push('\'' + this.terminals_[p] + '\'');
                            }
                        }
                        if (lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                        } else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                        }
                        this.parseError(errStr, {
                            text: lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: lexer.yylineno,
                            loc: yyloc,
                            expected: expected
                        });
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(lexer.yytext);
                            lstack.push(lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            {
                                yyleng = lexer.yyleng;
                                yytext = lexer.yytext;
                                yylineno = lexer.yylineno;
                                yyloc = lexer.yylloc;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = {
                                first_line: lstack[lstack.length - (len || 1)].first_line,
                                last_line: lstack[lstack.length - 1].last_line,
                                first_column: lstack[lstack.length - (len || 1)].first_column,
                                last_column: lstack[lstack.length - 1].last_column
                            };
                            if (ranges) {
                                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                            }
                            r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
                            if (typeof r !== 'undefined') {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            } };
        /* generated by jison-lex 0.3.4 */
        var lexer = function () {
            var lexer = {

                EOF: 1,

                parseError: function parseError(str, hash) {
                    if (this.yy.parser) {
                        this.yy.parser.parseError(str, hash);
                    } else {
                        throw new Error(str);
                    }
                },

                // resets the lexer, sets new input
                setInput: function setInput(input, yy) {
                    this.yy = yy || this.yy || {};
                    this._input = input;
                    this._more = this._backtrack = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = '';
                    this.conditionStack = ['INITIAL'];
                    this.yylloc = {
                        first_line: 1,
                        first_column: 0,
                        last_line: 1,
                        last_column: 0
                    };
                    if (this.options.ranges) {
                        this.yylloc.range = [0, 0];
                    }
                    this.offset = 0;
                    return this;
                },

                // consumes and returns one char from the input
                input: function input() {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno++;
                        this.yylloc.last_line++;
                    } else {
                        this.yylloc.last_column++;
                    }
                    if (this.options.ranges) {
                        this.yylloc.range[1]++;
                    }

                    this._input = this._input.slice(1);
                    return ch;
                },

                // unshifts one char (or a string) into the input
                unput: function unput(ch) {
                    var len = ch.length;
                    var lines = ch.split(/(?:\r\n?|\n)/g);

                    this._input = ch + this._input;
                    this.yytext = this.yytext.substr(0, this.yytext.length - len);
                    //this.yyleng -= len;
                    this.offset -= len;
                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                    this.match = this.match.substr(0, this.match.length - 1);
                    this.matched = this.matched.substr(0, this.matched.length - 1);

                    if (lines.length - 1) {
                        this.yylineno -= lines.length - 1;
                    }
                    var r = this.yylloc.range;

                    this.yylloc = {
                        first_line: this.yylloc.first_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.first_column,
                        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                    };

                    if (this.options.ranges) {
                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                    }
                    this.yyleng = this.yytext.length;
                    return this;
                },

                // When called from action, caches matched text and appends it on next action
                more: function more() {
                    this._more = true;
                    return this;
                },

                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function reject() {
                    if (this.options.backtrack_lexer) {
                        this._backtrack = true;
                    } else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                    return this;
                },

                // retain first n characters of the match
                less: function less(n) {
                    this.unput(this.match.slice(n));
                },

                // displays already matched input, i.e. for error messages
                pastInput: function pastInput() {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                },

                // displays upcoming input, i.e. for error messages
                upcomingInput: function upcomingInput() {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length);
                    }
                    return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                },

                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function showPosition() {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^";
                },

                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function test_match(match, indexed_rule) {
                    var token, lines, backup;

                    if (this.options.backtrack_lexer) {
                        // save context
                        backup = {
                            yylineno: this.yylineno,
                            yylloc: {
                                first_line: this.yylloc.first_line,
                                last_line: this.last_line,
                                first_column: this.yylloc.first_column,
                                last_column: this.yylloc.last_column
                            },
                            yytext: this.yytext,
                            match: this.match,
                            matches: this.matches,
                            matched: this.matched,
                            yyleng: this.yyleng,
                            offset: this.offset,
                            _more: this._more,
                            _input: this._input,
                            yy: this.yy,
                            conditionStack: this.conditionStack.slice(0),
                            done: this.done
                        };
                        if (this.options.ranges) {
                            backup.yylloc.range = this.yylloc.range.slice(0);
                        }
                    }

                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno += lines.length;
                    }
                    this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                    };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._backtrack = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                    if (this.done && this._input) {
                        this.done = false;
                    }
                    if (token) {
                        return token;
                    } else if (this._backtrack) {
                        // recover context
                        for (var k in backup) {
                            this[k] = backup[k];
                        }
                        return false; // rule action called reject() implying the next rule should be tested instead.
                    }
                    return false;
                },

                // return next match in input
                next: function next() {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input) {
                        this.done = true;
                    }

                    var token, match, tempMatch, index;
                    if (!this._more) {
                        this.yytext = '';
                        this.match = '';
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        tempMatch = this._input.match(this.rules[rules[i]]);
                        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                            match = tempMatch;
                            index = i;
                            if (this.options.backtrack_lexer) {
                                token = this.test_match(tempMatch, rules[i]);
                                if (token !== false) {
                                    return token;
                                } else if (this._backtrack) {
                                    match = false;
                                    continue; // rule action called reject() implying a rule MISmatch.
                                } else {
                                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                    return false;
                                }
                            } else if (!this.options.flex) {
                                break;
                            }
                        }
                    }
                    if (match) {
                        token = this.test_match(match, rules[index]);
                        if (token !== false) {
                            return token;
                        }
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                    if (this._input === "") {
                        return this.EOF;
                    } else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                },

                // return next match that has a token
                lex: function lex() {
                    var r = this.next();
                    if (r) {
                        return r;
                    } else {
                        return this.lex();
                    }
                },

                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function begin(condition) {
                    this.conditionStack.push(condition);
                },

                // pop the previously active lexer condition state off the condition stack
                popState: function popState() {
                    var n = this.conditionStack.length - 1;
                    if (n > 0) {
                        return this.conditionStack.pop();
                    } else {
                        return this.conditionStack[0];
                    }
                },

                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function _currentRules() {
                    if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                    } else {
                        return this.conditions["INITIAL"].rules;
                    }
                },

                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function topState(n) {
                    n = this.conditionStack.length - 1 - Math.abs(n || 0);
                    if (n >= 0) {
                        return this.conditionStack[n];
                    } else {
                        return "INITIAL";
                    }
                },

                // alias for begin(condition)
                pushState: function pushState(condition) {
                    this.begin(condition);
                },

                // return the number of states currently on the stack
                stateStackSize: function stateStackSize() {
                    return this.conditionStack.length;
                },
                options: {},
                performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                    switch ($avoiding_name_collisions) {
                        case 0:
                            /* skip whitespace */
                            break;
                        case 1:
                            return 6;
                        case 2:
                            yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);return 4;
                        case 3:
                            return 17;
                        case 4:
                            return 18;
                        case 5:
                            return 23;
                        case 6:
                            return 24;
                        case 7:
                            return 22;
                        case 8:
                            return 21;
                        case 9:
                            return 10;
                        case 10:
                            return 11;
                        case 11:
                            return 8;
                        case 12:
                            return 14;
                        case 13:
                            return 'INVALID';
                    }
                },
                rules: [/^(?:\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/, /^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/, /^(?:\{)/, /^(?:\})/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?::)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:$)/, /^(?:.)/],
                conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "inclusive": true } }
            };
            return lexer;
        }();
        parser.lexer = lexer;
        function Parser() {
            this.yy = {};
        }
        Parser.prototype = parser;parser.Parser = Parser;
        return new Parser();
    }();

    if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
        exports.parser = parser;
        exports.Parser = parser.Parser;
        exports.parse = function () {
            return parser.parse.apply(parser, arguments);
        };
    }
});
var jsonlint_1 = jsonlint.parser;
var jsonlint_2 = jsonlint.Parser;
var jsonlint_3 = jsonlint.parse;

function readStyle(style) {
    if (style instanceof String || typeof style === 'string' || style instanceof Buffer) {
        try {
            return jsonlint.parse(style.toString());
        } catch (e) {
            throw new ParsingError$1(e);
        }
    }
    return style;
}

function validateStyle(style, styleSpec) {
    if (styleSpec === void 0) styleSpec = v8;
    var s = style;
    try {
        s = readStyle(s);
    } catch (e) {
        return [e];
    }
    return validateStyleMin(s, styleSpec);
}

var SUPPORTED_SPEC_VERSION = 8;
var MAX_SOURCES_IN_STYLE = 15;
function isValid(value, regex) {
    if (!value || getType(value) !== 'string') {
        return true;
    }
    return !!value.match(regex);
}
function getSourceCount(source) {
    if (source.url) {
        return source.url.split(',').length;
    } else {
        return 0;
    }
}
function getAllowedKeyErrors(obj, keys, path) {
    var allowed = new Set(keys);
    var errors = [];
    Object.keys(obj).forEach(function (k) {
        if (!allowed.has(k)) {
            var prop = path ? path + '.' + k : null;
            errors.push(new ValidationError(prop, obj[k], 'Unsupported property "' + k + '"'));
        }
    });
    return errors;
}
function getSourceErrors(source, i) {
    var errors = [];
    var sourceKeys = ['type', 'url', 'tileSize'];
    errors.push.apply(errors, getAllowedKeyErrors(source, sourceKeys, 'source'));
    var sourceUrlPattern = /^mapbox:\/\/([^/]*)$/;
    if (!isValid(source.url, sourceUrlPattern)) {
        errors.push(new ValidationError('sources[' + i + ']', source.url, 'Source url must be a valid Mapbox tileset url'));
    }
    return errors;
}
function getSourcesErrors(sources) {
    var errors = [];
    var count = 0;
    Object.keys(sources).forEach(function (s, i) {
        var sourceErrors = getSourceErrors(sources[s], i);
        if (!sourceErrors.length) {
            count = count + getSourceCount(sources[s]);
        }
        errors.push.apply(errors, sourceErrors);
    });
    if (count > MAX_SOURCES_IN_STYLE) {
        errors.push(new ValidationError('sources', null, 'Styles must contain ' + MAX_SOURCES_IN_STYLE + ' or fewer sources'));
    }
    return errors;
}
function getRootErrors(style, specKeys) {
    var errors = [];
    var optionalRootProperties = ['owner', 'id', 'cacheControl', 'draft', 'created', 'modified', 'visibility'];
    var allowedKeyErrors = getAllowedKeyErrors(style, specKeys.concat(optionalRootProperties));
    errors.push.apply(errors, allowedKeyErrors);
    if (style.version > SUPPORTED_SPEC_VERSION || style.version < SUPPORTED_SPEC_VERSION) {
        errors.push(new ValidationError('version', style.version, 'Style version must be ' + SUPPORTED_SPEC_VERSION));
    }
    var glyphUrlPattern = /^mapbox:\/\/fonts\/([^/]*)\/{fontstack}\/{range}.pbf$/;
    if (!isValid(style.glyphs, glyphUrlPattern)) {
        errors.push(new ValidationError('glyphs', style.glyphs, 'Styles must reference glyphs hosted by Mapbox'));
    }
    var spriteUrlPattern = /^mapbox:\/\/sprites\/([^/]*)\/([^/]*)\/?([^/]*)?$/;
    if (!isValid(style.sprite, spriteUrlPattern)) {
        errors.push(new ValidationError('sprite', style.sprite, 'Styles must reference sprites hosted by Mapbox'));
    }
    var visibilityPattern = /^(public|private)$/;
    if (!isValid(style.visibility, visibilityPattern)) {
        errors.push(new ValidationError('visibility', style.visibility, 'Style visibility must be public or private'));
    }
    return errors;
}
function validateMapboxApiSupported(style) {
    var s = style;
    try {
        s = readStyle(s);
    } catch (e) {
        return [e];
    }
    var errors = validateStyleMin(s, v8).concat(getRootErrors(s, Object.keys(v8.$root)));
    if (s.sources) {
        errors = errors.concat(getSourcesErrors(s.sources));
    }
    return errors;
}

var expression$1 = {
    StyleExpression: StyleExpression,
    isExpression: isExpression,
    isExpressionFilter: isExpressionFilter,
    createExpression: createExpression,
    createPropertyExpression: createPropertyExpression,
    normalizePropertyExpression: normalizePropertyExpression,
    ZoomConstantExpression: ZoomConstantExpression,
    ZoomDependentExpression: ZoomDependentExpression,
    StylePropertyFunction: StylePropertyFunction
};
var styleFunction = {
    convertFunction: convertFunction,
    createFunction: createFunction,
    isFunction: isFunction$1
};
var visit = {
    eachSource: eachSource,
    eachLayer: eachLayer,
    eachProperty: eachProperty
};
validateStyle.parsed = validateStyle;
validateStyle.latest = validateStyle;

exports.Color = Color;
exports.ParsingError = ParsingError$1;
exports.ValidationError = ValidationError;
exports.composite = composite;
exports.convertFilter = convertFilter$1;
exports.derefLayers = derefLayers;
exports.diff = diffStyles;
exports.expression = expression$1;
exports.featureFilter = createFilter;
exports.format = format;
exports.function = styleFunction;
exports.latest = v8;
exports.migrate = migrate;
exports.v8 = v8;
exports.validate = validateStyle;
exports.validateMapboxApiSupported = validateMapboxApiSupported;
exports.visit = visit;
//# sourceMappingURL=index.es.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "./node_modules/mapbox-to-css-font/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mapbox-to-css-font/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fontWeights = {
  thin: 100,
  hairline: 100,
  'ultra-light': 100,
  'extra-light': 100,
  light: 200,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  'semi-bold': 600,
  'demi-bold': 600,
  bold: 700,
  heavy: 800,
  black: 800,
  'extra-bold': 800,
  'ultra-black': 900,
  'extra-black': 900,
  'ultra-bold': 900,
  'heavy-black': 900,
  fat: 900,
  poster: 900
};
var sp = ' ';
var italicRE = /(italic|oblique)$/i;

var fontCache = {};

module.exports = function (fonts, size, lineHeight) {
  var cssData = fontCache[fonts];
  if (!cssData) {
    if (!Array.isArray(fonts)) {
      fonts = [fonts];
    }
    var weight = 400;
    var style = 'normal';
    var fontFamilies = [];
    var haveWeight, haveStyle;
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      var parts = font.split(' ');
      var maybeWeight = parts[parts.length - 1].toLowerCase();
      if (maybeWeight == 'normal' || maybeWeight == 'italic' || maybeWeight == 'oblique') {
        style = haveStyle ? style : maybeWeight;
        parts.pop();
        maybeWeight = parts[parts.length - 1].toLowerCase();
      } else if (italicRE.test(maybeWeight)) {
        maybeWeight = maybeWeight.replace(italicRE, '');
        style = haveStyle ? style : parts[parts.length - 1].replace(maybeWeight, '');
      }
      for (var w in fontWeights) {
        if (maybeWeight == w || maybeWeight == w.replace('-', '') || maybeWeight == w.replace('-', sp)) {
          weight = haveWeight ? weight : fontWeights[w];
          parts.pop();
          break;
        }
      }
      if (!haveWeight && typeof maybeWeight == 'number') {
        weight = maybeWeight;
      }
      var fontFamily = parts.join(sp).replace('Klokantech Noto Sans', 'Noto Sans');
      if (fontFamily.indexOf(sp) !== -1) {
        fontFamily = '"' + fontFamily + '"';
      }
      fontFamilies.push(fontFamily);
    }
    // CSS font property: font-style font-weight font-size/line-height font-family
    cssData = fontCache[fonts] = [style, weight, fontFamilies];
  }
  return cssData[0] + sp + cssData[1] + sp + size + 'px' + (lineHeight ? '/' + lineHeight : '') + sp + cssData[2];
};

/***/ }),

/***/ "./node_modules/webfont-matcher/lib/fonts/google.js":
/*!**********************************************************!*\
  !*** ./node_modules/webfont-matcher/lib/fonts/google.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Generated by CoffeeScript 1.10.0
(function () {
  var families;

  module.exports = {
    icon: 'icons/google.svg',
    name: 'google',
    title: 'Google Fonts',
    link: 'google.com/fonts',
    getNames: function getNames() {
      return families;
    },
    getLink: function getLink(name) {
      return "https://fonts.google.com/specimen/" + name.replace(/( )/g, '+');
    },
    normalizeName: function normalizeName(name) {
      return name;
    }
  };

  families = ["ABeeZee", "Abel", "Abril Fatface", "Aclonica", "Acme", "Actor", "Adamina", "Advent Pro", "Aguafina Script", "Akronim", "Aladin", "Aldrich", "Alef", "Alegreya", "Alegreya SC", "Alegreya Sans", "Alegreya Sans SC", "Alex Brush", "Alfa Slab One", "Alice", "Alike", "Alike Angular", "Allan", "Allerta", "Allerta Stencil", "Allura", "Almendra", "Almendra Display", "Almendra SC", "Amarante", "Amaranth", "Amatic SC", "Amethysta", "Amiri", "Amita", "Anaheim", "Andada", "Andika", "Angkor", "Annie Use Your Telescope", "Anonymous Pro", "Antic", "Antic Didone", "Antic Slab", "Anton", "Arapey", "Arbutus", "Arbutus Slab", "Architects Daughter", "Archivo Black", "Archivo Narrow", "Arimo", "Arizonia", "Armata", "Artifika", "Arvo", "Arya", "Asap", "Asar", "Asset", "Astloch", "Asul", "Atomic Age", "Aubrey", "Audiowide", "Autour One", "Average", "Average Sans", "Averia Gruesa Libre", "Averia Libre", "Averia Sans Libre", "Averia Serif Libre", "Bad Script", "Balthazar", "Bangers", "Basic", "Battambang", "Baumans", "Bayon", "Belgrano", "Belleza", "BenchNine", "Bentham", "Berkshire Swash", "Bevan", "Bigelow Rules", "Bigshot One", "Bilbo", "Bilbo Swash Caps", "Biryani", "Bitter", "Black Ops One", "Bokor", "Bonbon", "Boogaloo", "Bowlby One", "Bowlby One SC", "Brawler", "Bree Serif", "Bubblegum Sans", "Bubbler One", "Buda", "Buenard", "Butcherman", "Butterfly Kids", "Cabin", "Cabin Condensed", "Cabin Sketch", "Caesar Dressing", "Cagliostro", "Calligraffitti", "Cambay", "Cambo", "Candal", "Cantarell", "Cantata One", "Cantora One", "Capriola", "Cardo", "Carme", "Carrois Gothic", "Carrois Gothic SC", "Carter One", "Catamaran", "Caudex", "Caveat", "Caveat Brush", "Cedarville Cursive", "Ceviche One", "Changa One", "Chango", "Chau Philomene One", "Chela One", "Chelsea Market", "Chenla", "Cherry Cream Soda", "Cherry Swash", "Chewy", "Chicle", "Chivo", "Chonburi", "Cinzel", "Cinzel Decorative", "Clicker Script", "Coda", "Coda Caption", "Codystar", "Combo", "Comfortaa", "Coming Soon", "Concert One", "Condiment", "Content", "Contrail One", "Convergence", "Cookie", "Copse", "Corben", "Courgette", "Cousine", "Coustard", "Covered By Your Grace", "Crafty Girls", "Creepster", "Crete Round", "Crimson Text", "Croissant One", "Crushed", "Cuprum", "Cutive", "Cutive Mono", "Damion", "Dancing Script", "Dangrek", "Dawning of a New Day", "Days One", "Dekko", "Delius", "Delius Swash Caps", "Delius Unicase", "Della Respira", "Denk One", "Devonshire", "Dhurjati", "Didact Gothic", "Diplomata", "Diplomata SC", "Domine", "Donegal One", "Doppio One", "Dorsa", "Dosis", "Dr Sugiyama", "Droid Sans", "Droid Sans Mono", "Droid Serif", "Duru Sans", "Dynalight", "EB Garamond", "Eagle Lake", "Eater", "Economica", "Eczar", "Ek Mukta", "Electrolize", "Elsie", "Elsie Swash Caps", "Emblema One", "Emilys Candy", "Engagement", "Englebert", "Enriqueta", "Erica One", "Esteban", "Euphoria Script", "Ewert", "Exo", "Exo 2", "Expletus Sans", "Fanwood Text", "Fascinate", "Fascinate Inline", "Faster One", "Fasthand", "Fauna One", "Federant", "Federo", "Felipa", "Fenix", "Finger Paint", "Fira Mono", "Fira Sans", "Fjalla One", "Fjord One", "Flamenco", "Flavors", "Fondamento", "Fontdiner Swanky", "Forum", "Francois One", "Freckle Face", "Fredericka the Great", "Fredoka One", "Freehand", "Fresca", "Frijole", "Fruktur", "Fugaz One", "GFS Didot", "GFS Neohellenic", "Gabriela", "Gafata", "Galdeano", "Galindo", "Gentium Basic", "Gentium Book Basic", "Geo", "Geostar", "Geostar Fill", "Germania One", "Gidugu", "Gilda Display", "Give You Glory", "Glass Antiqua", "Glegoo", "Gloria Hallelujah", "Goblin One", "Gochi Hand", "Gorditas", "Goudy Bookletter 1911", "Graduate", "Grand Hotel", "Gravitas One", "Great Vibes", "Griffy", "Gruppo", "Gudea", "Gurajada", "Habibi", "Halant", "Hammersmith One", "Hanalei", "Hanalei Fill", "Handlee", "Hanuman", "Happy Monkey", "Headland One", "Henny Penny", "Herr Von Muellerhoff", "Hind", "Hind Siliguri", "Hind Vadodara", "Holtwood One SC", "Homemade Apple", "Homenaje", "IM Fell DW Pica", "IM Fell DW Pica SC", "IM Fell Double Pica", "IM Fell Double Pica SC", "IM Fell English", "IM Fell English SC", "IM Fell French Canon", "IM Fell French Canon SC", "IM Fell Great Primer", "IM Fell Great Primer SC", "Iceberg", "Iceland", "Imprima", "Inconsolata", "Inder", "Indie Flower", "Inika", "Inknut Antiqua", "Irish Grover", "Istok Web", "Italiana", "Italianno", "Itim", "Jacques Francois", "Jacques Francois Shadow", "Jaldi", "Jim Nightshade", "Jockey One", "Jolly Lodger", "Josefin Sans", "Josefin Slab", "Joti One", "Judson", "Julee", "Julius Sans One", "Junge", "Jura", "Just Another Hand", "Just Me Again Down Here", "Kadwa", "Kalam", "Kameron", "Kantumruy", "Karla", "Karma", "Kaushan Script", "Kavoon", "Kdam Thmor", "Keania One", "Kelly Slab", "Kenia", "Khand", "Khmer", "Khula", "Kite One", "Knewave", "Kotta One", "Koulen", "Kranky", "Kreon", "Kristi", "Krona One", "Kurale", "La Belle Aurore", "Laila", "Lakki Reddy", "Lancelot", "Lateef", "Lato", "League Script", "Leckerli One", "Ledger", "Lekton", "Lemon", "Libre Baskerville", "Life Savers", "Lilita One", "Lily Script One", "Limelight", "Linden Hill", "Lobster", "Lobster Two", "Londrina Outline", "Londrina Shadow", "Londrina Sketch", "Londrina Solid", "Lora", "Love Ya Like A Sister", "Loved by the King", "Lovers Quarrel", "Luckiest Guy", "Lusitana", "Lustria", "Macondo", "Macondo Swash Caps", "Magra", "Maiden Orange", "Mako", "Mallanna", "Mandali", "Marcellus", "Marcellus SC", "Marck Script", "Margarine", "Marko One", "Marmelad", "Martel", "Martel Sans", "Marvel", "Mate", "Mate SC", "Maven Pro", "McLaren", "Meddon", "MedievalSharp", "Medula One", "Megrim", "Meie Script", "Merienda", "Merienda One", "Merriweather", "Merriweather Sans", "Metal", "Metal Mania", "Metamorphous", "Metrophobic", "Michroma", "Milonga", "Miltonian", "Miltonian Tattoo", "Miniver", "Miss Fajardose", "Modak", "Modern Antiqua", "Molengo", "Molle", "Monda", "Monofett", "Monoton", "Monsieur La Doulaise", "Montaga", "Montez", "Montserrat", "Montserrat Alternates", "Montserrat Subrayada", "Moul", "Moulpali", "Mountains of Christmas", "Mouse Memoirs", "Mr Bedfort", "Mr Dafoe", "Mr De Haviland", "Mrs Saint Delafield", "Mrs Sheppards", "Muli", "Mystery Quest", "NTR", "Neucha", "Neuton", "New Rocker", "News Cycle", "Niconne", "Nixie One", "Nobile", "Nokora", "Norican", "Nosifer", "Nothing You Could Do", "Noticia Text", "Noto Sans", "Noto Serif", "Nova Cut", "Nova Flat", "Nova Mono", "Nova Oval", "Nova Round", "Nova Script", "Nova Slim", "Nova Square", "Numans", "Nunito", "Odor Mean Chey", "Offside", "Old Standard TT", "Oldenburg", "Oleo Script", "Oleo Script Swash Caps", "Open Sans", "Open Sans Condensed", "Oranienbaum", "Orbitron", "Oregano", "Orienta", "Original Surfer", "Oswald", "Over the Rainbow", "Overlock", "Overlock SC", "Ovo", "Oxygen", "Oxygen Mono", "PT Mono", "PT Sans", "PT Sans Caption", "PT Sans Narrow", "PT Serif", "PT Serif Caption", "Pacifico", "Palanquin", "Palanquin Dark", "Paprika", "Parisienne", "Passero One", "Passion One", "Pathway Gothic One", "Patrick Hand", "Patrick Hand SC", "Patua One", "Paytone One", "Peddana", "Peralta", "Permanent Marker", "Petit Formal Script", "Petrona", "Philosopher", "Piedra", "Pinyon Script", "Pirata One", "Plaster", "Play", "Playball", "Playfair Display", "Playfair Display SC", "Podkova", "Poiret One", "Poller One", "Poly", "Pompiere", "Pontano Sans", "Poppins", "Port Lligat Sans", "Port Lligat Slab", "Pragati Narrow", "Prata", "Preahvihear", "Press Start 2P", "Princess Sofia", "Prociono", "Prosto One", "Puritan", "Purple Purse", "Quando", "Quantico", "Quattrocento", "Quattrocento Sans", "Questrial", "Quicksand", "Quintessential", "Qwigley", "Racing Sans One", "Radley", "Rajdhani", "Raleway", "Raleway Dots", "Ramabhadra", "Ramaraja", "Rambla", "Rammetto One", "Ranchers", "Rancho", "Ranga", "Rationale", "Ravi Prakash", "Redressed", "Reenie Beanie", "Revalia", "Rhodium Libre", "Ribeye", "Ribeye Marrow", "Righteous", "Risque", "Roboto", "Roboto Condensed", "Roboto Mono", "Roboto Slab", "Rochester", "Rock Salt", "Rokkitt", "Romanesco", "Ropa Sans", "Rosario", "Rosarivo", "Rouge Script", "Rozha One", "Rubik", "Rubik Mono One", "Rubik One", "Ruda", "Rufina", "Ruge Boogie", "Ruluko", "Rum Raisin", "Ruslan Display", "Russo One", "Ruthie", "Rye", "Sacramento", "Sahitya", "Sail", "Salsa", "Sanchez", "Sancreek", "Sansita One", "Sarala", "Sarina", "Sarpanch", "Satisfy", "Scada", "Scheherazade", "Schoolbell", "Seaweed Script", "Sevillana", "Seymour One", "Shadows Into Light", "Shadows Into Light Two", "Shanti", "Share", "Share Tech", "Share Tech Mono", "Shojumaru", "Short Stack", "Siemreap", "Sigmar One", "Signika", "Signika Negative", "Simonetta", "Sintony", "Sirin Stencil", "Six Caps", "Skranji", "Slabo 13px", "Slabo 27px", "Slackey", "Smokum", "Smythe", "Sniglet", "Snippet", "Snowburst One", "Sofadi One", "Sofia", "Sonsie One", "Sorts Mill Goudy", "Source Code Pro", "Source Sans Pro", "Source Serif Pro", "Special Elite", "Spicy Rice", "Spinnaker", "Spirax", "Squada One", "Sree Krushnadevaraya", "Stalemate", "Stalinist One", "Stardos Stencil", "Stint Ultra Condensed", "Stint Ultra Expanded", "Stoke", "Strait", "Sue Ellen Francisco", "Sumana", "Sunshiney", "Supermercado One", "Sura", "Suranna", "Suravaram", "Suwannaphum", "Swanky and Moo Moo", "Syncopate", "Tangerine", "Taprom", "Tauri", "Teko", "Telex", "Tenali Ramakrishna", "Tenor Sans", "Text Me One", "The Girl Next Door", "Tienne", "Tillana", "Timmana", "Tinos", "Titan One", "Titillium Web", "Trade Winds", "Trocchi", "Trochut", "Trykker", "Tulpen One", "Ubuntu", "Ubuntu Condensed", "Ubuntu Mono", "Ultra", "Uncial Antiqua", "Underdog", "Unica One", "UnifrakturCook", "UnifrakturMaguntia", "Unkempt", "Unlock", "Unna", "VT323", "Vampiro One", "Varela", "Varela Round", "Vast Shadow", "Vesper Libre", "Vibur", "Vidaloka", "Viga", "Voces", "Volkhov", "Vollkorn", "Voltaire", "Waiting for the Sunrise", "Wallpoet", "Walter Turncoat", "Warnes", "Wellfleet", "Wendy One", "Wire One", "Work Sans", "Yanone Kaffeesatz", "Yantramanav", "Yellowtail", "Yeseva One", "Yesteryear", "Zeyada"];
}).call(undefined);

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "./olms.js":
/*!*****************!*\
  !*** ./olms.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index */ "./index.js");

var _stylefunction = __webpack_require__(/*! ./stylefunction */ "./stylefunction.js");

var _stylefunction2 = _interopRequireDefault(_stylefunction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  apply: _index.apply,
  applyBackground: _index.applyBackground,
  applyStyle: _index.applyStyle,
  stylefunction: _stylefunction2.default
};

/***/ }),

/***/ "./stylefunction.js":
/*!**************************!*\
  !*** ./stylefunction.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValue = getValue;

exports.default = function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, spriteImage, fonts) {
  if (!resolutions) {
    resolutions = [];
    for (var res = 78271.51696402048; resolutions.length < 21; res /= 2) {
      resolutions.push(res);
    }
  }
  if (typeof glStyle == 'string') {
    glStyle = JSON.parse(glStyle);
  }
  if (glStyle.version != 8) {
    throw new Error('glStyle version 8 required.');
  }

  var spriteImgSize = void 0;
  if (spriteImageUrl && !spriteImage) {
    var img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = function () {
      spriteImage = img;
      spriteImgSize = [img.width, img.height];
      olLayer.changed();
    };
    img.src = spriteImageUrl;
  }

  var ctx = document.createElement('CANVAS').getContext('2d');
  var measureCache = {};

  function wrapText(text, font, em) {
    var key = em + ',' + font + ',' + text;
    var wrappedText = measureCache[key];
    if (!wrappedText) {
      ctx.font = font;
      var oneEm = ctx.measureText('M').width;
      var width = oneEm * em;
      var words = text.split(' ');
      var line = '';
      var lines = [];
      for (var i = 0, ii = words.length; i < ii; ++i) {
        var word = words[i];
        if (ctx.measureText(line + word).width <= width) {
          line += (line ? ' ' : '') + word;
        } else {
          if (line) {
            lines.push(line);
          }
          line = word;
        }
      }
      if (line) {
        lines.push(line);
      }
      measureCache[key] = wrappedText = lines.join('\n');
    }
    return wrappedText;
  }

  var allLayers = (0, _mapboxGlStyleSpec.derefLayers)(glStyle.layers);

  var layersBySourceLayer = {};
  var mapboxLayers = [];
  var mapboxSource = void 0;
  for (var i = 0, ii = allLayers.length; i < ii; ++i) {
    var layer = allLayers[i];
    var layerId = layer.id;
    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {
      var sourceLayer = layer['source-layer'];
      if (!mapboxSource) {
        mapboxSource = layer.source;
      }
      var layers = layersBySourceLayer[sourceLayer];
      if (!layers) {
        layers = layersBySourceLayer[sourceLayer] = [];
      }
      layers.push({
        layer: layer,
        index: i
      });
      mapboxLayers.push(layerId);
    }
    // // TODO revisit when diffing gets added
    delete functionCache[layerId];
    delete filterCache[layerId];
  }
  var iconImageCache = {};

  var styles = [];
  var patternCache = {};

  var styleFunction = function styleFunction(feature, resolution) {
    var properties = feature.getProperties();
    feature.styleIds = feature.styleIds || {};
    var layers = layersBySourceLayer[properties.layer];
    if (!layers) {
      return;
    }
    var zoom = resolutions.indexOf(resolution);
    if (zoom == -1) {
      zoom = Math.round((0, _util.getZoomForResolution)(resolution, resolutions));
    }
    var type = types[feature.getGeometry().getType()];
    var f = {
      properties: properties,
      type: type
    };
    var stylesLength = -1;
    for (var _i = 0, _ii = layers.length; _i < _ii; ++_i) {
      var layerData = layers[_i];
      var _layer = layerData.layer;
      var _layerId = _layer.id;

      var layout = _layer.layout || emptyObj;
      var paint = _layer.paint || emptyObj;
      if (layout.visibility === 'none' || 'minzoom' in _layer && zoom < _layer.minzoom || 'maxzoom' in _layer && zoom >= _layer.maxzoom) {
        continue;
      }
      feature.styleIds[zoom] = feature.styleIds[zoom] || [];
      var filter = _layer.filter;
      var icon = void 0,
          iconImg = void 0;
      if (!filter || evaluateFilter(_layerId, filter, f, zoom)) {
        var color = void 0,
            opacity = void 0,
            fill = void 0,
            stroke = void 0,
            strokeColor = void 0,
            style = void 0;
        var index = layerData.index;
        if (type == 3 && _layer.type == 'fill') {
          opacity = getValue(_layer, 'paint', 'fill-opacity', zoom, f);
          if ('fill-pattern' in paint) {
            var iconImage = getValue(_layer, 'paint', 'fill-pattern', zoom, f);
            if (iconImage) {
              icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();
              if (spriteImage && spriteData && spriteData[icon]) {
                ++stylesLength;
                if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                  feature.styleIds[zoom].push(_layerId);
                }
                style = styles[stylesLength];
                if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                  style = styles[stylesLength] = new _Style2.default({
                    fill: new _Fill2.default()
                  });
                }
                fill = style.getFill();
                style.setZIndex(index);
                var icon_cache_key = icon + '.' + opacity;
                var pattern = patternCache[icon_cache_key];
                if (!pattern) {
                  var spriteImageData = spriteData[icon];
                  var canvas = document.createElement('canvas');
                  canvas.width = spriteImageData.width;
                  canvas.height = spriteImageData.height;
                  var _ctx = canvas.getContext('2d');
                  _ctx.globalAlpha = opacity;
                  _ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);
                  pattern = _ctx.createPattern(canvas, 'repeat');
                  patternCache[icon_cache_key] = pattern;
                }
                fill.setColor(pattern);
              }
            }
          } else if ('fill-color' in paint) {
            color = colorWithOpacity(getValue(_layer, 'paint', 'fill-color', zoom, f), opacity);
            if (color) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  fill: new _Fill2.default()
                });
              }
              fill = style.getFill();
              fill.setColor(color);
              style.setZIndex(index);
            }
            if ('fill-outline-color' in paint) {
              strokeColor = colorWithOpacity(getValue(_layer, 'paint', 'fill-outline-color', zoom, properties), opacity);
            } else if ('fill-antialias' in paint) {
              strokeColor = color;
            }
            if (strokeColor) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  stroke: new _Stroke2.default()
                });
              }
              stroke = style.getStroke();
              stroke.setColor(strokeColor);
              stroke.setWidth(1);
              style.setZIndex(index);
            }
          }
        }
        if (type != 1 && _layer.type == 'line') {
          (function () {
            color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(_layer, 'paint', 'line-color', zoom, f), getValue(_layer, 'paint', 'line-opacity', zoom, f)) : undefined;
            var width = getValue(_layer, 'paint', 'line-width', zoom, f);
            if (color && width > 0) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  stroke: new _Stroke2.default()
                });
              }
              stroke = style.getStroke();
              stroke.setLineCap(getValue(_layer, 'layout', 'line-cap', zoom, f));
              stroke.setLineJoin(getValue(_layer, 'layout', 'line-join', zoom, f));
              stroke.setMiterLimit(getValue(_layer, 'layout', 'line-miter-limit', zoom, f));
              stroke.setColor(color);
              stroke.setWidth(width);
              stroke.setLineDash(paint['line-dasharray'] ? getValue(_layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {
                return x * width;
              }) : null);
              style.setZIndex(index);
            }
          })();
        }

        var hasImage = false;
        var text = null;
        var skipLabel = void 0;
        if ((type == 1 || type == 2) && 'icon-image' in layout) {
          var _iconImage = getValue(_layer, 'layout', 'icon-image', zoom, f);
          if (_iconImage) {
            icon = typeof _iconImage === 'string' ? fromTemplate(_iconImage, properties) : _iconImage.toString();
            var styleGeom = undefined;
            if (spriteImage && spriteData && spriteData[icon]) {
              if (type == 2) {
                var geom = feature.getGeometry();
                // ol package and ol-debug.js only
                if (geom.getFlatMidpoint) {
                  var extent = geom.getExtent();
                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));
                  if (size > 150) {
                    //FIXME Do not hard-code a size of 150
                    styleGeom = new _Point2.default(geom.getFlatMidpoint());
                  }
                }
              }
              if (type !== 2 || styleGeom) {
                ++stylesLength;
                if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                  feature.styleIds[zoom].push(_layerId);
                }
                style = styles[stylesLength];
                if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
                  style = styles[stylesLength] = new _Style2.default();
                }
                style.setGeometry(styleGeom);
                var iconSize = getValue(_layer, 'layout', 'icon-size', zoom, f);
                var iconColor = paint['icon-color'] !== undefined ? getValue(_layer, 'paint', 'icon-color', zoom, f) : null;
                var iconTranslate = getValue(_layer, 'paint', 'icon-translate', zoom, f);
                var iconTranslateAnchor = getValue(_layer, 'paint', 'icon-translate-anchor', zoom, f);
                var iconAnchorValue = getValue(_layer, 'layout', 'icon-anchor', zoom, f);
                var iconOffset = getValue(_layer, 'layout', 'icon-offset', zoom, f);

                var _covertIconAnchor = covertIconAnchor(iconAnchorValue),
                    anchorOffset = _covertIconAnchor.anchorOffset,
                    _covertIconAnchor$ico = _covertIconAnchor.iconAnchor,
                    iconAnchor = _covertIconAnchor$ico === undefined ? iconAnchorValue : _covertIconAnchor$ico;

                var _icon_cache_key = icon + '.' + iconSize + '.' + iconTranslate + '.' + iconTranslateAnchor + '.' + iconAnchor + '.' + iconOffset + '.' + anchorOffset;
                if (iconColor !== null) {
                  _icon_cache_key += '.' + iconColor;
                }
                iconImg = iconImageCache[_icon_cache_key];
                if (!iconImg) {
                  var _spriteImageData = spriteData[icon];
                  var _canvas = document.createElement('canvas');
                  _canvas.width = _spriteImageData.width;
                  _canvas.height = _spriteImageData.height;
                  var _ctx2 = _canvas.getContext('2d');
                  _ctx2.drawImage(spriteImage, _spriteImageData.x, _spriteImageData.y, _spriteImageData.width, _spriteImageData.height, 0, 0, _spriteImageData.width, _spriteImageData.height);
                  var data = _ctx2.getImageData(0, 0, _canvas.width, _canvas.height);
                  if (iconColor !== null) {
                    // cut out the sprite and color it
                    color = colorWithOpacity(iconColor, 1);
                    for (var c = 0, cc = data.data.length; c < cc; c += 4) {
                      data.data[c] = color[0];
                      data.data[c + 1] = color[1];
                      data.data[c + 2] = color[2];
                    }
                  }
                  _ctx2.putImageData(data, 0, 0);
                  var translateOffset = [iconTranslate[0] / _spriteImageData.width, iconTranslate[1] / _spriteImageData.height];
                  iconImg = iconImageCache[_icon_cache_key] = new _Icon2.default({
                    img: _canvas,
                    anchorOrigin: iconAnchor,
                    anchor: [iconOffset[0] + anchorOffset[0] + translateOffset[0], iconOffset[1] + anchorOffset[1] - translateOffset[1]],
                    imgSize: [_canvas.width, _canvas.height],
                    scale: iconSize / _spriteImageData.pixelRatio
                  });
                }
                var rotateValue = getValue(_layer, 'layout', 'icon-rotate', zoom, f);
                if (rotateValue.indexOf && rotateValue.indexOf('{') === 0) {
                  rotateValue = 360 - fromTemplate(rotateValue, properties);
                }
                iconImg.setRotation((0, _util.deg2rad)(rotateValue));
                iconImg.setOpacity(getValue(_layer, 'paint', 'icon-opacity', zoom, f));
                style.setImage(iconImg);
                text = style.getText();
                style.setText(undefined);
                style.setZIndex(99999 - index);
                hasImage = true;
                skipLabel = false;
              } else {
                skipLabel = true;
              }
            }
          }
        }

        if (type == 1 && 'circle-radius' in paint) {
          ++stylesLength;
          if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
            feature.styleIds[zoom].push(_layerId);
          }
          style = styles[stylesLength];
          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
            style = styles[stylesLength] = new _Style2.default();
          }
          var circleRadius = getValue(_layer, 'paint', 'circle-radius', zoom, f);
          var circleStrokeColor = getValue(_layer, 'paint', 'circle-stroke-color', zoom, f);
          var circleColor = getValue(_layer, 'paint', 'circle-color', zoom, f);
          var circleOpacity = getValue(_layer, 'paint', 'circle-opacity', zoom, f);
          var circleStrokeWidth = getValue(_layer, 'paint', 'circle-stroke-width', zoom, f);
          var circleStrokeOpacity = getValue(_layer, 'paint', 'circle-stroke-opacity', zoom, f);
          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleOpacity + '.' + circleStrokeWidth + '.' + circleStrokeOpacity;
          iconImg = iconImageCache[cache_key];
          if (!iconImg) {
            iconImg = new _Circle2.default({
              radius: circleRadius,
              stroke: circleStrokeWidth === 0 ? undefined : new _Stroke2.default({
                width: circleStrokeWidth,
                color: colorWithOpacity(circleStrokeColor, circleStrokeOpacity)
              }),
              fill: new _Fill2.default({
                color: colorWithOpacity(circleColor, circleOpacity)
              })
            });
          }
          style.setImage(iconImg);
          text = style.getText();
          style.setText(undefined);
          style.setGeometry(undefined);
          style.setZIndex(99999 - index);
          hasImage = true;
        }

        var label = void 0;
        if ('text-field' in layout) {
          var textField = getValue(_layer, 'layout', 'text-field', zoom, f);
          label = fromTemplate(textField, properties);
        }
        if (label && !skipLabel) {
          if (!hasImage) {
            ++stylesLength;
            if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
              feature.styleIds[zoom].push(_layerId);
            }
            style = styles[stylesLength];
            if (!style || !style.getText() || style.getFill() || style.getStroke()) {
              style = styles[stylesLength] = new _Style2.default();
            }
            style.setImage(undefined);
            style.setGeometry(undefined);
          }
          if (!style.getText()) {
            style.setText(text || new _Text2.default());
          }
          text = style.getText();
          var textSize = getValue(_layer, 'layout', 'text-size', zoom, f);
          var textLineHeight = getValue(_layer, 'layout', 'text-line-height', zoom, f);
          var font = (0, _mapboxToCssFont2.default)(chooseFont(getValue(_layer, 'layout', 'text-font', zoom, f)), textSize);
          var textTransform = layout['text-transform'];
          if (textTransform == 'uppercase') {
            label = label.toUpperCase();
          } else if (textTransform == 'lowercase') {
            label = label.toLowerCase();
          }
          var wrappedLabel = type == 2 ? label : wrapText(label, font, getValue(_layer, 'layout', 'text-max-width', zoom, f));
          text.setText(wrappedLabel);
          text.setFont(font);
          text.setRotation((0, _util.deg2rad)(getValue(_layer, 'layout', 'text-rotate', zoom, f)));
          var textAnchor = getValue(_layer, 'layout', 'text-anchor', zoom, f);
          var placement = hasImage || type == 1 ? 'point' : getValue(_layer, 'layout', 'symbol-placement', zoom, f);
          text.setPlacement(placement);
          var textHaloWidth = getValue(_layer, 'paint', 'text-halo-width', zoom, f);
          var textOffset = getValue(_layer, 'layout', 'text-offset', zoom, f);
          var textTranslate = getValue(_layer, 'paint', 'text-translate', zoom, f);
          var vOffset = 0;
          var hOffset = 0;
          var textAlign = 'center';
          if (textAnchor.indexOf('left') !== -1) {
            textAlign = 'left';
            hOffset = textHaloWidth;
          } else if (textAnchor.indexOf('right') !== -1) {
            textAlign = 'right';
            hOffset = -textHaloWidth;
          }
          if (placement == 'point') {
            text.setTextAlign(textAlign);
          } else {
            text.setMaxAngle((0, _util.deg2rad)(getValue(_layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);
            text.setTextAlign();
          }
          var textBaseline = 'middle';
          if (textAnchor.indexOf('bottom') == 0) {
            textBaseline = 'bottom';
            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;
          } else if (textAnchor.indexOf('top') == 0) {
            textBaseline = 'top';
            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;
          }
          text.setTextBaseline(textBaseline);
          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);
          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);
          opacity = getValue(_layer, 'paint', 'text-opacity', zoom, f);
          var textColor = new _Fill2.default();

          textColor.setColor(colorWithOpacity(getValue(_layer, 'paint', 'text-color', zoom, f), opacity));
          text.setFill(textColor);
          var haloColor = colorWithOpacity(getValue(_layer, 'paint', 'text-halo-color', zoom, f), opacity);
          if (haloColor) {
            var textHalo = new _Stroke2.default();
            textHalo.setColor(haloColor);
            textHalo.setWidth(getValue(_layer, 'paint', 'text-halo-width', zoom, f));
            text.setStroke(textHalo);
          } else {
            text.setStroke(undefined);
          }
          style.setZIndex(99999 - index);
        }
      }
    }

    if (stylesLength > -1) {
      styles.length = stylesLength + 1;
      return styles;
    }
  };

  olLayer.setStyle(styleFunction);
  olLayer.set('mapbox-source', mapboxSource);
  olLayer.set('mapbox-layers', mapboxLayers);
  return styleFunction;
};

var _Style = __webpack_require__(/*! ol/style/Style */ "ol/style/Style");

var _Style2 = _interopRequireDefault(_Style);

var _Fill = __webpack_require__(/*! ol/style/Fill */ "ol/style/Fill");

var _Fill2 = _interopRequireDefault(_Fill);

var _Stroke = __webpack_require__(/*! ol/style/Stroke */ "ol/style/Stroke");

var _Stroke2 = _interopRequireDefault(_Stroke);

var _Icon = __webpack_require__(/*! ol/style/Icon */ "ol/style/Icon");

var _Icon2 = _interopRequireDefault(_Icon);

var _Text = __webpack_require__(/*! ol/style/Text */ "ol/style/Text");

var _Text2 = _interopRequireDefault(_Text);

var _Circle = __webpack_require__(/*! ol/style/Circle */ "ol/style/Circle");

var _Circle2 = _interopRequireDefault(_Circle);

var _Point = __webpack_require__(/*! ol/geom/Point */ "ol/geom/Point");

var _Point2 = _interopRequireDefault(_Point);

var _mapboxGlStyleSpec = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec */ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js");

var _mapboxToCssFont = __webpack_require__(/*! mapbox-to-css-font */ "./node_modules/mapbox-to-css-font/index.js");

var _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);

var _util = __webpack_require__(/*! ./util */ "./util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isFunction = _mapboxGlStyleSpec.function.isFunction; /*
                                                         ol-mapbox-style - Use Mapbox Style objects with OpenLayers
                                                         Copyright 2016-present Boundless Spatial, Inc.
                                                         License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE
                                                         */

var convertFunction = _mapboxGlStyleSpec.function.convertFunction;
var isExpression = _mapboxGlStyleSpec.expression.isExpression;
var createPropertyExpression = _mapboxGlStyleSpec.expression.createPropertyExpression;

var types = {
  'Point': 1,
  'MultiPoint': 1,
  'LineString': 2,
  'MultiLineString': 2,
  'Polygon': 3,
  'MultiPolygon': 3
};
var expressionData = function expressionData(rawExpression, propertySpec) {
  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);
  if (compiledExpression.result === 'error') {
    throw new Error(compiledExpression.value.map(function (err) {
      return err.key + ': ' + err.message;
    }).join(', '));
  }
  return compiledExpression.value;
};

var emptyObj = {};
var zoomObj = { zoom: 0 };
var functionCache = {};

/**
 * @private
 * @param {Object} layer Gl object layer.
 * @param {string} layoutOrPaint 'layout' or 'paint'.
 * @param {string} property Feature property.
 * @param {number} zoom Zoom.
 * @param {Object} feature Gl feature.
 * @return {?} Value.
 */
function getValue(layer, layoutOrPaint, property, zoom, feature) {
  var layerId = layer.id;
  if (!functionCache[layerId]) {
    functionCache[layerId] = {};
  }
  var functions = functionCache[layerId];
  if (!functions[property]) {
    var value = (layer[layoutOrPaint] || emptyObj)[property];
    var propertySpec = _mapboxGlStyleSpec.latest[layoutOrPaint + '_' + layer.type][property];
    if (value === undefined) {
      value = propertySpec.default;
    }
    var isExpr = isExpression(value);
    if (!isExpr && isFunction(value)) {
      value = convertFunction(value, propertySpec);
      isExpr = true;
    }
    if (isExpr) {
      var compiledExpression = expressionData(value, propertySpec);
      functions[property] = compiledExpression.evaluate.bind(compiledExpression);
    } else {
      if (propertySpec.type == 'color') {
        value = _mapboxGlStyleSpec.Color.parse(value);
      }
      functions[property] = function () {
        return value;
      };
    }
  }
  zoomObj.zoom = zoom;
  return functions[property](zoomObj, feature);
}

function covertIconAnchor(iconAnchor) {
  var anchorOffset = [0.5, 0.5];
  if (['top-left', 'top-right', 'bottom-left', 'bottom-right'].includes(iconAnchor)) {
    anchorOffset = [0, 0];
  }
  if (iconAnchor === 'left') {
    iconAnchor = 'top-left';
    anchorOffset = [0, 0.5];
  }
  if (iconAnchor === 'right') {
    iconAnchor = 'top-left';
    anchorOffset = [1, 0.5];
  }
  if (iconAnchor === 'bottom') {
    iconAnchor = 'top-left';
    anchorOffset = [0.5, 1];
  }
  if (iconAnchor === 'top') {
    iconAnchor = 'top-left';
    anchorOffset = [0.5, 0];
  }
  //center
  return {
    anchorOffset: anchorOffset,
    iconAnchor: iconAnchor
  };
}

var fontMap = {};

function chooseFont(fonts, availableFonts) {
  if (fontMap[fonts]) {
    return fontMap[fonts];
  }
  if (availableFonts) {
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      if (availableFonts.indexOf(font) != -1) {
        fontMap[fonts] = font;
        break;
      }
    }
    if (!fontMap[fonts]) {
      // fallback font
      fontMap[fonts] = fonts[fonts.length - 1];
    }
  } else {
    fontMap[fonts] = fonts[0];
  }
  return fontMap[fonts];
}

var filterCache = {};

function evaluateFilter(layerId, filter, feature, zoom) {
  if (!(layerId in filterCache)) {
    filterCache[layerId] = (0, _mapboxGlStyleSpec.featureFilter)(filter).filter;
  }
  zoomObj.zoom = zoom;
  return filterCache[layerId](zoomObj, feature);
}

function colorWithOpacity(color, opacity) {
  if (color) {
    if (color.a === 0 || opacity === 0) {
      return undefined;
    }
    var a = color.a;
    opacity = opacity === undefined ? 1 : opacity;
    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';
  }
  return color;
}

var templateRegEx = /^([^]*)\{(.*)\}([^]*)$/;

function fromTemplate(text, properties) {
  var parts = void 0;
  do {
    parts = text.match(templateRegEx);
    if (parts) {
      var value = properties[parts[2]] || '';
      text = parts[1] + value + parts[3];
    }
  } while (parts);
  return text;
}

/**
 * Creates a style function from the `glStyle` object for all layers that use
 * the specified `source`, which needs to be a `"type": "vector"` or
 * `"type": "geojson"` source and applies it to the specified OpenLayers layer.
 *
 * @param {ol.layer.Vector|ol.layer.VectorTile} olLayer OpenLayers layer to
 * apply the style to. In addition to the style, the layer will get two
 * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used
 * for the layer, and `mapbox-layers` will be an array of the `id`s of the
 * `glStyle`'s layers.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>} source `source` key or an array of layer `id`s
 * from the Mapbox Style object. When a `source` key is provided, all layers for
 * the specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,
 * 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,
 * 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,
 * 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,
 * 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,
 * 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]
 * Resolutions for mapping resolution to zoom level.
 * @param {Object} [spriteData=undefined] Sprite data from the url specified in
 * the Mapbox Style object's `sprite` property. Only required if a `sprite`
 * property is specified in the Mapbox Style object.
 * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite
 * specified in the Mapbox Style object's `sprite` property. Only required if a
 * `sprite` property is specified in the Mapbox Style object.
 * @param {Array<string>} [fonts=undefined] Array of available fonts, using the
 * same font names as the Mapbox Style object. If not provided, the style
 * function will always use the first font from the font array.
 * @return {ol.style.StyleFunction} Style function for use in
 * `ol.layer.Vector` or `ol.layer.VectorTile`.
 */

/***/ }),

/***/ "./util.js":
/*!*****************!*\
  !*** ./util.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deg2rad = deg2rad;
exports.getZoomForResolution = getZoomForResolution;
function deg2rad(degrees) {
  return degrees * Math.PI / 180;
}

function getZoomForResolution(resolution, resolutions) {
  var i = 0;
  var ii = resolutions.length;
  for (; i < ii; ++i) {
    var candidate = resolutions[i];
    if (candidate < resolution && i + 1 < ii) {
      var zoomFactor = resolutions[i] / resolutions[i + 1];
      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);
    }
  }
  return ii - 1;
}

/***/ }),

/***/ "ol/Map":
/*!*************************!*\
  !*** external "ol.Map" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.Map;

/***/ }),

/***/ "ol/Observable":
/*!********************************!*\
  !*** external "ol.Observable" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.Observable;

/***/ }),

/***/ "ol/format/GeoJSON":
/*!************************************!*\
  !*** external "ol.format.GeoJSON" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.format.GeoJSON;

/***/ }),

/***/ "ol/format/MVT":
/*!********************************!*\
  !*** external "ol.format.MVT" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.format.MVT;

/***/ }),

/***/ "ol/geom/Point":
/*!********************************!*\
  !*** external "ol.geom.Point" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.geom.Point;

/***/ }),

/***/ "ol/layer/Tile":
/*!********************************!*\
  !*** external "ol.layer.Tile" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.layer.Tile;

/***/ }),

/***/ "ol/layer/Vector":
/*!**********************************!*\
  !*** external "ol.layer.Vector" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.layer.Vector;

/***/ }),

/***/ "ol/layer/VectorTile":
/*!**************************************!*\
  !*** external "ol.layer.VectorTile" ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.layer.VectorTile;

/***/ }),

/***/ "ol/proj":
/*!**************************!*\
  !*** external "ol.proj" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.proj;

/***/ }),

/***/ "ol/source/TileJSON":
/*!*************************************!*\
  !*** external "ol.source.TileJSON" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.source.TileJSON;

/***/ }),

/***/ "ol/source/Vector":
/*!***********************************!*\
  !*** external "ol.source.Vector" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.source.Vector;

/***/ }),

/***/ "ol/source/VectorTile":
/*!***************************************!*\
  !*** external "ol.source.VectorTile" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.source.VectorTile;

/***/ }),

/***/ "ol/source/XYZ":
/*!********************************!*\
  !*** external "ol.source.XYZ" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.source.XYZ;

/***/ }),

/***/ "ol/style/Circle":
/*!**********************************!*\
  !*** external "ol.style.Circle" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Circle;

/***/ }),

/***/ "ol/style/Fill":
/*!********************************!*\
  !*** external "ol.style.Fill" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Fill;

/***/ }),

/***/ "ol/style/Icon":
/*!********************************!*\
  !*** external "ol.style.Icon" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Icon;

/***/ }),

/***/ "ol/style/Stroke":
/*!**********************************!*\
  !*** external "ol.style.Stroke" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Stroke;

/***/ }),

/***/ "ol/style/Style":
/*!*********************************!*\
  !*** external "ol.style.Style" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Style;

/***/ }),

/***/ "ol/style/Text":
/*!********************************!*\
  !*** external "ol.style.Text" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.style.Text;

/***/ }),

/***/ "ol/tilegrid":
/*!******************************!*\
  !*** external "ol.tilegrid" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ol.tilegrid;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbG1zL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL29sbXMvLi9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL0BtYXBib3gvbWFwYm94LWdsLXN0eWxlLXNwZWMvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvbWFwYm94LXRvLWNzcy1mb250L2luZGV4LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvd2ViZm9udC1tYXRjaGVyL2xpYi9mb250cy9nb29nbGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL29sbXMuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL3N0eWxlZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL3V0aWwuanMiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLk1hcFwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5PYnNlcnZhYmxlXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLmZvcm1hdC5HZW9KU09OXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLmZvcm1hdC5NVlRcIiIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIFwib2wuZ2VvbS5Qb2ludFwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5sYXllci5UaWxlXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLmxheWVyLlZlY3RvclwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5sYXllci5WZWN0b3JUaWxlXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLnByb2pcIiIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIFwib2wuc291cmNlLlRpbGVKU09OXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLnNvdXJjZS5WZWN0b3JcIiIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIFwib2wuc291cmNlLlZlY3RvclRpbGVcIiIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIFwib2wuc291cmNlLlhZWlwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5zdHlsZS5DaXJjbGVcIiIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIFwib2wuc3R5bGUuRmlsbFwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5zdHlsZS5JY29uXCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLnN0eWxlLlN0cm9rZVwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5zdHlsZS5TdHlsZVwiIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwgXCJvbC5zdHlsZS5UZXh0XCIiLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCBcIm9sLnRpbGVncmlkXCIiXSwibmFtZXMiOlsiYXBwbHlTdHlsZSIsImFwcGx5QmFja2dyb3VuZCIsImFwcGx5IiwiZ2V0TGF5ZXIiLCJnZXRTb3VyY2UiLCJhdmFpbGFibGVGb250cyIsImxvYWRGb250IiwiZm9udHMiLCJpIiwiaWkiLCJBcnJheSIsImlzQXJyYXkiLCJzdG9wcyIsImxlbmd0aCIsImdvb2dsZUZhbWlsaWVzIiwiZ29vZ2xlRm9udHMiLCJnZXROYW1lcyIsImZhbWlsaWVzIiwibWFwIiwiZm9udCIsInNwbGl0IiwicmVwbGFjZSIsImZhbWlseSIsImluZGV4T2YiLCJwdXNoIiwiZm9udFVybCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm1hcmt1cCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwicmVsIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJhcHBlbmRDaGlsZCIsImRlZmF1bHRGb250IiwicHJlcHJvY2VzcyIsImxheWVyIiwibGF5b3V0Iiwic3ByaXRlUmVnRXgiLCJ3aXRoUGF0aCIsInVybCIsInBhdGgiLCJ0b1Nwcml0ZVVybCIsImV4dGVuc2lvbiIsInBhcnRzIiwibWF0Y2giLCJnbFN0eWxlIiwic291cmNlIiwicmVzb2x1dGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIkpTT04iLCJwYXJzZSIsInZlcnNpb24iLCJFcnJvciIsInNwcml0ZVNjYWxlIiwic3ByaXRlRGF0YSIsInNwcml0ZUltYWdlVXJsIiwic3ByaXRlIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNpemVGYWN0b3IiLCJzcHJpdGVVcmwiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwidGhlbiIsInJlc3BvbnNlIiwic3RhdHVzIiwianNvbiIsInIiLCJzcHJpdGVzSnNvbiIsInVuZGVmaW5lZCIsIm9uQ2hhbmdlIiwiY2F0Y2giLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJzdHlsZSIsInNldFN0eWxlIiwiVmVjdG9yVGlsZUxheWVyIiwiVmVjdG9yTGF5ZXIiLCJsYXllcnMiLCJpZCIsImUiLCJzZXRUaW1lb3V0Iiwic2V0QmFja2dyb3VuZCIsImJhY2tncm91bmQiLCJ0eXBlIiwidXBkYXRlU3R5bGUiLCJlbGVtZW50IiwiZ2V0VGFyZ2V0RWxlbWVudCIsInBhaW50Iiwiem9vbSIsImdldFZpZXciLCJnZXRab29tIiwiYmciLCJDb2xvciIsInRvU3RyaW5nIiwib3BhY2l0eSIsInZpc2liaWxpdHkiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvbiIsInNvbWUiLCJsIiwiZ2V0U291cmNlSWRCeVJlZiIsInJlZiIsInNvdXJjZUlkIiwicHJvY2Vzc1N0eWxlIiwiYmFzZVVybCIsImhvc3QiLCJhY2Nlc3NUb2tlbiIsInZpZXciLCJnZXRDZW50ZXIiLCJzZXRDZW50ZXIiLCJjZW50ZXIiLCJzZXRab29tIiwiZml0IiwiZ2V0UHJvamVjdGlvbiIsImdldEV4dGVudCIsIm5lYXJlc3QiLCJzaXplIiwiZ2V0U2l6ZSIsImdsTGF5ZXJzIiwiZ2VvSnNvbkZvcm1hdCIsIkdlb0pTT04iLCJsYXllcklkcyIsImZpbmFsaXplTGF5ZXIiLCJhZGRMYXllciIsInNldFZpc2libGUiLCJvbmNlIiwiZ2xMYXllciIsImdsU291cmNlIiwiZ2xTb3VyY2VJZCIsIm1hcGlkIiwic291cmNlcyIsInRpbGVzIiwidGlsZUdyaWQiLCJ0aWxlU2l6ZSIsIm1heFpvb20iLCJtYXh6b29tIiwibWluWm9vbSIsIm1pbnpvb20iLCJkZWNsdXR0ZXIiLCJtYXhSZXNvbHV0aW9uIiwiZ2V0TWluWm9vbSIsImdldFJlc29sdXRpb24iLCJWZWN0b3JUaWxlU291cmNlIiwiYXR0cmlidXRpb25zIiwiYXR0cmlidXRpb24iLCJmb3JtYXQiLCJNVlQiLCJ1cmxzIiwidmlzaWJsZSIsInpJbmRleCIsInRpbGVqc29uIiwiVGlsZUpTT04iLCJrZXkiLCJnZXRTdGF0ZSIsInRpbGVKU09ORG9jIiwiZ2V0VGlsZUpTT04iLCJ0aWxlIiwiZ2V0VGlsZUdyaWQiLCJzZXRTb3VyY2UiLCJnZXRBdHRyaWJ1dGlvbnMiLCJnZXRNYXhab29tIiwic2V0TWF4UmVzb2x1dGlvbiIsImNyb3NzT3JpZ2luIiwiWFlaIiwic2V0VGlsZUxvYWRGdW5jdGlvbiIsInNyYyIsImJib3giLCJnZXRUaWxlQ29vcmRFeHRlbnQiLCJnZXRUaWxlQ29vcmQiLCJnZXRJbWFnZSIsIlRpbGVMYXllciIsImRhdGEiLCJmZWF0dXJlcyIsImdlb0pzb25VcmwiLCJyZWFkRmVhdHVyZXMiLCJmZWF0dXJlUHJvamVjdGlvbiIsIlZlY3RvclNvdXJjZSIsInNldCIsIk1hcCIsInRhcmdldCIsImEiLCJwYXRobmFtZSIsInNsaWNlIiwiam9pbiIsInN1YnN0ciIsImxheWVySWQiLCJnZXRMYXllcnMiLCJnZXRBcnJheSIsImdldCIsIiR2ZXJzaW9uIiwiJHJvb3QiLCJyZXF1aXJlZCIsInZhbHVlcyIsImRvYyIsImV4YW1wbGUiLCJuYW1lIiwibWV0YWRhdGEiLCJ2YWx1ZSIsImJlYXJpbmciLCJwZXJpb2QiLCJ1bml0cyIsInBpdGNoIiwibGlnaHQiLCJhbmNob3IiLCJjb2xvciIsImludGVuc2l0eSIsImdseXBocyIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImRlbGF5Iiwic291cmNlX3ZlY3RvciIsInZlY3RvciIsImJvdW5kcyIsInNjaGVtZSIsInh5eiIsInRtcyIsInByb21vdGVJZCIsInNvdXJjZV9yYXN0ZXIiLCJyYXN0ZXIiLCJzb3VyY2VfcmFzdGVyX2RlbSIsImVuY29kaW5nIiwidGVycmFyaXVtIiwibWFwYm94Iiwic291cmNlX2dlb2pzb24iLCJnZW9qc29uIiwiYnVmZmVyIiwibWF4aW11bSIsIm1pbmltdW0iLCJ0b2xlcmFuY2UiLCJjbHVzdGVyIiwiY2x1c3RlclJhZGl1cyIsImNsdXN0ZXJNYXhab29tIiwiY2x1c3RlclByb3BlcnRpZXMiLCJsaW5lTWV0cmljcyIsImdlbmVyYXRlSWQiLCJzb3VyY2VfdmlkZW8iLCJ2aWRlbyIsImNvb3JkaW5hdGVzIiwic291cmNlX2ltYWdlIiwiaW1hZ2UiLCJmaWxsIiwianMiLCJhbmRyb2lkIiwiaW9zIiwibWFjb3MiLCJsaW5lIiwic3ltYm9sIiwiY2lyY2xlIiwiaGVhdG1hcCIsImhpbGxzaGFkZSIsImZpbHRlciIsImxheW91dF9iYWNrZ3JvdW5kIiwibm9uZSIsImxheW91dF9maWxsIiwiZXhwcmVzc2lvbiIsImludGVycG9sYXRlZCIsInBhcmFtZXRlcnMiLCJsYXlvdXRfY2lyY2xlIiwibGF5b3V0X2hlYXRtYXAiLCJsYXlvdXRfbGluZSIsImJ1dHQiLCJyb3VuZCIsInNxdWFyZSIsImJldmVsIiwibWl0ZXIiLCJyZXF1aXJlcyIsImxheW91dF9zeW1ib2wiLCJwb2ludCIsImF1dG8iLCJ2aWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwiYm90aCIsInRva2VucyIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsInVwcGVyY2FzZSIsImxvd2VyY2FzZSIsImxheW91dF9yYXN0ZXIiLCJsYXlvdXRfaGlsbHNoYWRlIiwiZmlsdGVyX29wZXJhdG9yIiwiYWxsIiwiYW55IiwiaGFzIiwiZ2VvbWV0cnlfdHlwZSIsIlBvaW50IiwiTGluZVN0cmluZyIsIlBvbHlnb24iLCJmdW5jdGlvbl9zdG9wIiwiZXhwcmVzc2lvbl9uYW1lIiwiZ3JvdXAiLCJsaXRlcmFsIiwiYXJyYXkiLCJhdCIsImNvYWxlc2NlIiwic3RlcCIsImludGVycG9sYXRlIiwibG4yIiwicGkiLCJzdHJpbmciLCJudW1iZXIiLCJib29sZWFuIiwib2JqZWN0IiwiY29sbGF0b3IiLCJyZ2IiLCJyZ2JhIiwicHJvcGVydGllcyIsImFjY3VtdWxhdGVkIiwic3FydCIsImxvZzEwIiwibG4iLCJsb2cyIiwic2luIiwiY29zIiwidGFuIiwiYXNpbiIsImFjb3MiLCJhdGFuIiwibWluIiwibWF4IiwiYWJzIiwiY2VpbCIsImZsb29yIiwid2l0aGluIiwidXBjYXNlIiwiZG93bmNhc2UiLCJjb25jYXQiLCJwb3NpdGlvbiIsInBhaW50X2ZpbGwiLCJwYWludF9saW5lIiwicGFpbnRfY2lyY2xlIiwicGFpbnRfaGVhdG1hcCIsInBhaW50X3N5bWJvbCIsIm92ZXJyaWRhYmxlIiwicGFpbnRfcmFzdGVyIiwibGluZWFyIiwicGFpbnRfaGlsbHNoYWRlIiwicGFpbnRfYmFja2dyb3VuZCIsInY4IiwiYmFzZSIsInByb3BlcnR5IiwiaWRlbnRpdHkiLCJleHBvbmVudGlhbCIsImludGVydmFsIiwiY2F0ZWdvcmljYWwiLCJjb2xvclNwYWNlIiwibGFiIiwiaGNsIiwiY29uc3RhbnQiLCJzdHJpbmdPckNoYXIiLCJqc29uU3RyaW5naWZ5UHJldHR5Q29tcGFjdCIsInN0cmluZ2lmeSIsInBhc3NlZE9iaiIsIm9wdGlvbnMiLCJpbmRlbnQiLCJtYXhMZW5ndGgiLCJyZXBsYWNlciIsIkluZmluaXR5IiwiX3N0cmluZ2lmeSIsIm9iaiIsImN1cnJlbnRJbmRlbnQiLCJyZXNlcnZlZCIsImVuZCIsImluZGV4IiwiaXRlbXMiLCJrZXlQYXJ0Iiwia2V5cyIsIm5leHRJbmRlbnQiLCJwcmV0dGlmaWVkIiwic3RhcnQiLCJ0b0pTT04iLCJzdHJpbmdMaXRlcmFsIiwiT2JqZWN0Iiwic29ydEtleXNCeSIsInJlZmVyZW5jZSIsInJlc3VsdCIsImtleSQxIiwic3BhY2UiLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJnbG9iYWwiLCJzZWxmIiwiY29tbW9uanNSZXF1aXJlIiwiY3JlYXRlQ29tbW9uanNNb2R1bGUiLCJmbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJwdW55Y29kZSIsInJvb3QiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJtYXhJbnQiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsIk1hdGgiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJSYW5nZUVycm9yIiwibWFwRG9tYWluIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJvdXRwdXQiLCJjb3VudGVyIiwiZXh0cmEiLCJjaGFyQ29kZUF0IiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJrIiwiZGVjb2RlIiwiaW5wdXQiLCJpbnB1dExlbmd0aCIsIm91dCIsIm4iLCJiaWFzIiwiYmFzaWMiLCJqIiwib2xkaSIsInciLCJ0IiwiYmFzZU1pbnVzVCIsImxhc3RJbmRleE9mIiwic3BsaWNlIiwiZW5jb2RlIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsIm0iLCJxIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsInRvVW5pY29kZSIsInRlc3QiLCJ0b0xvd2VyQ2FzZSIsInRvQVNDSUkiLCJoYXNPd25Qcm9wZXJ0eSIsInV0aWwiLCJpc1N0cmluZyIsImFyZyIsImlzT2JqZWN0IiwiaXNOdWxsIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJwcm9wIiwicHJvdG90eXBlIiwiY2FsbCIsInFzIiwic2VwIiwiZXEiLCJyZWdleHAiLCJtYXhLZXlzIiwibGVuIiwieCIsImlkeCIsImtzdHIiLCJ2c3RyIiwidiIsImRlY29kZVVSSUNvbXBvbmVudCIsInN0cmluZ2lmeVByaW1pdGl2ZSIsImlzRmluaXRlIiwia3MiLCJlbmNvZGVVUklDb21wb25lbnQiLCJxdWVyeXN0cmluZyIsInF1ZXJ5c3RyaW5nXzEiLCJxdWVyeXN0cmluZ18yIiwicXVlcnlzdHJpbmdfMyIsInF1ZXJ5c3RyaW5nXzQiLCJ1cmxQYXJzZSIsInVybFJlc29sdmUiLCJyZXNvbHZlT2JqZWN0IiwidXJsUmVzb2x2ZU9iamVjdCIsImZvcm1hdCQxIiwidXJsRm9ybWF0IiwiVXJsXzEiLCJVcmwiLCJwcm90b2NvbCIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsImhvc3RuYW1lIiwiaGFzaCIsInNlYXJjaCIsInF1ZXJ5IiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsInVuc2FmZVByb3RvY29sIiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInBhcnNlUXVlcnlTdHJpbmciLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJUeXBlRXJyb3IiLCJxdWVyeUluZGV4Iiwic3BsaXR0ZXIiLCJ1U3BsaXQiLCJzbGFzaFJlZ2V4IiwicmVzdCIsInRyaW0iLCJzaW1wbGVQYXRoIiwiZXhlYyIsInByb3RvIiwibG93ZXJQcm90byIsImhvc3RFbmQiLCJoZWMiLCJhdFNpZ24iLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwidW5zaGlmdCIsInAiLCJoIiwiYWUiLCJlc2MiLCJlc2NhcGUiLCJxbSIsInMiLCJjaGFyQXQiLCJyZWxhdGl2ZSIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJyZWxQYXRoIiwic2hpZnQiLCJpc1NvdXJjZUFicyIsImlzUmVsQWJzIiwibXVzdEVuZEFicyIsInJlbW92ZUFsbERvdHMiLCJzcmNQYXRoIiwicHN5Y2hvdGljIiwicG9wIiwiYXV0aEluSG9zdCIsImxhc3QiLCJoYXNUcmFpbGluZ1NsYXNoIiwidXAiLCJpc0Fic29sdXRlIiwiZ2V0UHJvcGVydHlSZWZlcmVuY2UiLCJwcm9wZXJ0eU5hbWUiLCJpJDEiLCJlYWNoU291cmNlIiwiY2FsbGJhY2siLCJlYWNoTGF5ZXIiLCJsaXN0IiwiZWFjaFByb3BlcnR5IiwiaW5uZXIiLCJwcm9wZXJ0eVR5cGUiLCJmb3JFYWNoIiwiZWFjaExheW91dCIsImVhY2hQYWludCIsInJlc29sdmVDb25zdGFudCIsImNvbnN0YW50cyIsImlzRnVuY3Rpb24iLCJyZW5hbWVQcm9wZXJ0eSIsImZyb20iLCJ0byIsIm1pZ3JhdGVUb1Y4IiwiY29vcmQiLCJyZXZlcnNlIiwic3RvcCIsIm1pZ3JhdGVGb250c3RhY2tVUkwiLCJpbnB1dFBhcnNlZCIsImlucHV0UGF0aG5hbWVQYXJ0cyIsIm1pZ3JhdGVGb250U3RhY2siLCJzcGxpdEFuZFRyaW0iLCJmaXJzdFN5bWJvbExheWVyIiwic3ltYm9sTGF5ZXJzIiwiZXh0ZW5kIiwiaW5wdXRzIiwiYXJndW1lbnRzIiwiUGFyc2luZ0Vycm9yIiwibWVzc2FnZSIsIl9fcHJvdG9fXyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiU2NvcGUiLCJwYXJlbnQiLCJiaW5kaW5ncyIsIk51bGxUeXBlIiwia2luZCIsIk51bWJlclR5cGUiLCJTdHJpbmdUeXBlIiwiQm9vbGVhblR5cGUiLCJDb2xvclR5cGUiLCJPYmplY3RUeXBlIiwiVmFsdWVUeXBlIiwiRXJyb3JUeXBlIiwiQ29sbGF0b3JUeXBlIiwiRm9ybWF0dGVkVHlwZSIsIlJlc29sdmVkSW1hZ2VUeXBlIiwiaXRlbVR5cGUiLCJOIiwidmFsdWVNZW1iZXJUeXBlcyIsImNoZWNrU3VidHlwZSIsImV4cGVjdGVkIiwibWVtYmVyVHlwZSIsImlzVmFsaWRUeXBlIiwicHJvdmlkZWQiLCJhbGxvd2VkVHlwZXMiLCJpc1ZhbGlkTmF0aXZlVHlwZSIsImNzc2NvbG9ycGFyc2VyIiwia0NTU0NvbG9yVGFibGUiLCJjbGFtcF9jc3NfYnl0ZSIsImNsYW1wX2Nzc19mbG9hdCIsImYiLCJwYXJzZV9jc3NfaW50Iiwic3RyIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwicGFyc2VfY3NzX2Zsb2F0IiwiY3NzX2h1ZV90b19yZ2IiLCJtMSIsIm0yIiwicGFyc2VDU1NDb2xvciIsImNzc19zdHIiLCJpdiIsIm9wIiwiZXAiLCJmbmFtZSIsInBhcmFtcyIsImFscGhhIiwiY3NzY29sb3JwYXJzZXJfMSIsImciLCJiIiwidG9BcnJheSIsImJsYWNrIiwid2hpdGUiLCJ0cmFuc3BhcmVudCIsInJlZCIsIkNvbGxhdG9yIiwiY2FzZVNlbnNpdGl2ZSIsImRpYWNyaXRpY1NlbnNpdGl2ZSIsImxvY2FsZSIsInNlbnNpdGl2aXR5IiwiSW50bCIsInVzYWdlIiwiY29tcGFyZSIsImxocyIsInJocyIsInJlc29sdmVkTG9jYWxlIiwicmVzb2x2ZWRPcHRpb25zIiwiRm9ybWF0dGVkU2VjdGlvbiIsInRleHQiLCJzY2FsZSIsImZvbnRTdGFjayIsInRleHRDb2xvciIsIkZvcm1hdHRlZCIsInNlY3Rpb25zIiwiZnJvbVN0cmluZyIsInVuZm9ybWF0dGVkIiwiaXNFbXB0eSIsInNlY3Rpb24iLCJmYWN0b3J5Iiwic2VyaWFsaXplIiwic2VyaWFsaXplZCIsIlJlc29sdmVkSW1hZ2UiLCJhdmFpbGFibGUiLCJ2YWxpZGF0ZVJHQkEiLCJpc1ZhbHVlIiwibWl4ZWQiLCJpdGVtIiwidHlwZU9mIiwidG9TdHJpbmckMSIsIkxpdGVyYWwiLCJhcmdzIiwiY29udGV4dCIsImV4cGVjdGVkVHlwZSIsImV2YWx1YXRlIiwiZWFjaENoaWxkIiwib3V0cHV0RGVmaW5lZCIsIlJ1bnRpbWVFcnJvciIsInR5cGVzIiwiQXNzZXJ0aW9uIiwidHlwZSQxIiwicGFyc2VkIiwiY3R4IiwiZXZlcnkiLCJGb3JtYXRFeHByZXNzaW9uIiwiZmlyc3RBcmciLCJuZXh0VG9rZW5NYXlCZU9iamVjdCIsImxhc3RFeHByZXNzaW9uIiwiY29udGVudCIsImV2YWx1YXRlU2VjdGlvbiIsImV2YWx1YXRlZENvbnRlbnQiLCJJbWFnZUV4cHJlc3Npb24iLCJldmFsdWF0ZWRJbWFnZU5hbWUiLCJhdmFpbGFibGVJbWFnZXMiLCJ0eXBlcyQxIiwiQ29lcmNpb24iLCJCb29sZWFuIiwiYyIsInBhcnNlQ29sb3IiLCJsaXN0JDEiLCJhcmckMSIsIm51bSIsIk51bWJlciIsImlzTmFOIiwiY2hpbGQiLCJnZW9tZXRyeVR5cGVzIiwiRXZhbHVhdGlvbkNvbnRleHQiLCJnbG9iYWxzIiwiZmVhdHVyZSIsImZlYXR1cmVTdGF0ZSIsImZvcm1hdHRlZFNlY3Rpb24iLCJfcGFyc2VDb2xvckNhY2hlIiwiY2Fub25pY2FsIiwiZ2VvbWV0cnlUeXBlIiwiZ2VvbWV0cnkiLCJjYW5vbmljYWxJRCIsImNhY2hlZCIsIkNvbXBvdW5kRXhwcmVzc2lvbiIsIl9ldmFsdWF0ZSIsInJlZiQxIiwiZGVmaW5pdGlvbiIsImRlZmluaXRpb25zIiwiYXZhaWxhYmxlT3ZlcmxvYWRzIiwib3ZlcmxvYWRzIiwic2lnbmF0dXJlIiwic2lnbmF0dXJlQ29udGV4dCIsImkkMyIsIlBhcnNpbmdDb250ZXh0IiwicmVnaXN0cnkiLCJzY29wZSIsInBhcnNlZEFyZ3MiLCJhcmdQYXJzZUZhaWxlZCIsImV4cGVjdGVkJDEiLCJzaWduYXR1cmVzIiwic3RyaW5naWZ5U2lnbmF0dXJlIiwiYWN0dWFsVHlwZXMiLCJpJDIiLCJwYXJzZWQkMSIsInJlZ2lzdGVyIiwiQ29sbGF0b3JFeHByZXNzaW9uIiwiRVhURU5UIiwidXBkYXRlQkJveCIsIm1lcmNhdG9yWGZyb21MbmciLCJsbmciLCJtZXJjYXRvcllmcm9tTGF0IiwibGF0IiwiUEkiLCJsb2ciLCJib3hXaXRoaW5Cb3giLCJiYm94MSIsImJib3gyIiwiZ2V0VGlsZUNvb3JkaW5hdGVzIiwieSIsInRpbGVzQXRab29tIiwicG93IiwieiIsIm9uQm91bmRhcnkiLCJwMSIsInAyIiwieDEiLCJ5MSIsIngyIiwieTIiLCJyYXlJbnRlcnNlY3QiLCJwb2ludFdpdGhpblBvbHlnb24iLCJyaW5ncyIsImluc2lkZSIsInJpbmciLCJsZW4yIiwicG9pbnRXaXRoaW5Qb2x5Z29ucyIsInBvbHlnb25zIiwicGVycCIsInYxIiwidjIiLCJ0d29TaWRlZCIsInExIiwicTIiLCJ4MyIsInkzIiwiZGV0MSIsImRldDIiLCJsaW5lSW50ZXJzZWN0TGluZSIsImQiLCJ2ZWN0b3JQIiwidmVjdG9yUSIsImxpbmVJbnRlcnNlY3RQb2x5Z29uIiwicG9seWdvbiIsImxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uIiwibGluZVN0cmluZ1dpdGhpblBvbHlnb25zIiwiZ2V0VGlsZVBvbHlnb24iLCJnZXRUaWxlUG9seWdvbnMiLCJ1cGRhdGVQb2ludCIsInBvbHlCQm94Iiwid29ybGRTaXplIiwiaGFsZldvcmxkU2l6ZSIsInJlc2V0QkJveCIsImdldFRpbGVQb2ludHMiLCJwb2ludEJCb3giLCJzaGlmdHMiLCJ0aWxlUG9pbnRzIiwicG9pbnRzIiwiZ2V0VGlsZUxpbmVzIiwibGluZUJCb3giLCJ0aWxlTGluZXMiLCJ0aWxlTGluZSIsImxpc3QkMyIsImxpbmUkMSIsImxpc3QkMiIsInAkMSIsInBvaW50c1dpdGhpblBvbHlnb25zIiwicG9seWdvbkdlb21ldHJ5IiwidGlsZVBvbHlnb24iLCJ0aWxlUG9seWdvbnMiLCJ0aWxlUG9pbnRzJDEiLCJwb2ludCQxIiwibGluZXNXaXRoaW5Qb2x5Z29ucyIsInRpbGVMaW5lcyQxIiwiV2l0aGluIiwiZ2VvbWV0cmllcyIsImlzRmVhdHVyZUNvbnN0YW50IiwiaXNTdGF0ZUNvbnN0YW50IiwiaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50IiwiVmFyIiwiYm91bmRFeHByZXNzaW9uIiwiZXhwciIsIl9wYXJzZSIsImFubm90YXRlIiwidHlwZUFubm90YXRpb24iLCJFeHByIiwiYWN0dWFsIiwiaXNDb25zdGFudCIsImVjIiwiZXJyb3IkMSIsImNoZWNrU3VidHlwZSQxIiwiaXNUeXBlQW5ub3RhdGlvbiIsImNoaWxkcmVuQ29uc3RhbnQiLCJmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvIiwibGFzdEluZGV4IiwibG93ZXJJbmRleCIsInVwcGVySW5kZXgiLCJjdXJyZW50SW5kZXgiLCJuZXh0VmFsdWUiLCJTdGVwIiwib3V0cHV0cyIsImxhYmVsIiwib3V0cHV0VHlwZSIsImxhYmVsS2V5IiwidmFsdWVLZXkiLCJzdG9wQ291bnQiLCJ1bml0YmV6aWVyIiwiVW5pdEJlemllciIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsImN4IiwiYngiLCJheCIsImN5IiwiYnkiLCJheSIsInNhbXBsZUN1cnZlWCIsInNhbXBsZUN1cnZlWSIsInNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgiLCJzb2x2ZUN1cnZlWCIsImVwc2lsb24iLCJ0MCIsInQxIiwidDIiLCJkMiIsInNvbHZlIiwiYXJyYXkkMSIsImZyZWV6ZSIsIlhuIiwiWW4iLCJabiIsInQzIiwiZGVnMnJhZCIsInJhZDJkZWciLCJ4eXoybGFiIiwibGFiMnh5eiIsInh5ejJyZ2IiLCJyZ2IyeHl6IiwicmdiVG9MYWIiLCJyZ2JDb2xvciIsImxhYlRvUmdiIiwibGFiQ29sb3IiLCJpbnRlcnBvbGF0ZUxhYiIsInJnYlRvSGNsIiwiYXRhbjIiLCJoY2xUb1JnYiIsImhjbENvbG9yIiwiaW50ZXJwb2xhdGVIdWUiLCJpbnRlcnBvbGF0ZUhjbCIsImZvcndhcmQiLCJjb2xvclNwYWNlcyIsIkludGVycG9sYXRlIiwib3BlcmF0b3IiLCJpbnRlcnBvbGF0aW9uIiwiaW50ZXJwb2xhdGlvbkZhY3RvciIsImxvd2VyIiwidXBwZXIiLCJleHBvbmVudGlhbEludGVycG9sYXRpb24iLCJjb250cm9sUG9pbnRzIiwidWIiLCJvdXRwdXRMb3dlciIsIm91dHB1dFVwcGVyIiwibG93ZXJWYWx1ZSIsInVwcGVyVmFsdWUiLCJkaWZmZXJlbmNlIiwicHJvZ3Jlc3MiLCJDb2FsZXNjZSIsIm5lZWRzQW5ub3RhdGlvbiIsImFyZ0NvdW50IiwicmVxdWVzdGVkSW1hZ2VOYW1lIiwiTGV0IiwiYmluZGluZyIsIkF0IiwiSW4iLCJuZWVkbGUiLCJoYXlzdGFjayIsIkluZGV4T2YiLCJmcm9tSW5kZXgiLCJNYXRjaCIsImlucHV0VHlwZSIsImNhc2VzIiwib3RoZXJ3aXNlIiwibGFiZWxDb250ZXh0IiwiTUFYX1NBRkVfSU5URUdFUiIsInRoaXMkMSIsInNvcnRlZExhYmVscyIsInNvcnQiLCJncm91cGVkQnlPdXRwdXQiLCJvdXRwdXRMb29rdXAiLCJvdXRwdXRJbmRleCIsImNvZXJjZUxhYmVsIiwib3V0cHV0SW5kZXgkMSIsIkNhc2UiLCJicmFuY2hlcyIsIl8iLCJTbGljZSIsImJlZ2luSW5kZXgiLCJlbmRJbmRleCIsImlzQ29tcGFyYWJsZVR5cGUiLCJuZXEiLCJsdCIsImd0IiwibHRlcSIsImd0ZXEiLCJlcUNvbGxhdGUiLCJuZXFDb2xsYXRlIiwibHRDb2xsYXRlIiwiZ3RDb2xsYXRlIiwibHRlcUNvbGxhdGUiLCJndGVxQ29sbGF0ZSIsIm1ha2VDb21wYXJpc29uIiwiY29tcGFyZUJhc2ljIiwiY29tcGFyZVdpdGhDb2xsYXRvciIsImlzT3JkZXJDb21wYXJpc29uIiwiQ29tcGFyaXNvbiIsImhhc1VudHlwZWRBcmd1bWVudCIsInJ0IiwibHQkMSIsInJ0JDEiLCJFcXVhbHMiLCJOb3RFcXVhbHMiLCJMZXNzVGhhbiIsIkdyZWF0ZXJUaGFuIiwiTGVzc1RoYW5PckVxdWFsIiwiR3JlYXRlclRoYW5PckVxdWFsIiwiTnVtYmVyRm9ybWF0IiwiY3VycmVuY3kiLCJtaW5GcmFjdGlvbkRpZ2l0cyIsIm1heEZyYWN0aW9uRGlnaXRzIiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwiTGVuZ3RoIiwiZXhwcmVzc2lvbnMiLCJiaW5hcnlTZWFyY2giLCJ2YXJhcmdzIiwiaGVhdG1hcERlbnNpdHkiLCJsaW5lUHJvZ3Jlc3MiLCJMTjIiLCJFIiwiTE4xMCIsImlzU3VwcG9ydGVkU2NyaXB0IiwidG9VcHBlckNhc2UiLCJzdWNjZXNzIiwic3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24iLCJzcGVjIiwic3VwcG9ydHNab29tRXhwcmVzc2lvbiIsInN1cHBvcnRzSW50ZXJwb2xhdGlvbiIsImdldFR5cGUiLCJ2YWwiLCJpc0Z1bmN0aW9uJDEiLCJpZGVudGl0eUZ1bmN0aW9uIiwiY3JlYXRlRnVuY3Rpb24iLCJwcm9wZXJ0eVNwZWMiLCJpc0NvbG9yIiwiem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQiLCJmZWF0dXJlRGVwZW5kZW50Iiwiem9vbURlcGVuZGVudCIsImRlZmF1bHQiLCJpbm5lckZ1biIsImhhc2hlZFN0b3BzIiwiY2F0ZWdvcmljYWxLZXlUeXBlIiwiZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uIiwiZXZhbHVhdGVJbnRlcnZhbEZ1bmN0aW9uIiwiZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uIiwiZXZhbHVhdGVJZGVudGl0eUZ1bmN0aW9uIiwiZmVhdHVyZUZ1bmN0aW9ucyIsInpvb21TdG9wcyIsInN0b3AkMSIsImZlYXR1cmVGdW5jdGlvblN0b3BzIiwiaW50ZXJwb2xhdGlvblR5cGUiLCJiaW5kIiwiaW50ZXJwb2xhdGlvblR5cGUkMSIsImtleVR5cGUiLCJldmFsdWF0ZWQiLCJpbnRlcnAiLCJjb2xvcnNwYWNlIiwiZXZhbHVhdGVkTG93ZXIiLCJldmFsdWF0ZWRVcHBlciIsIlN0eWxlRXhwcmVzc2lvbiIsIl93YXJuaW5nSGlzdG9yeSIsIl9ldmFsdWF0b3IiLCJfZGVmYXVsdFZhbHVlIiwiZ2V0RGVmYXVsdFZhbHVlIiwiX2VudW1WYWx1ZXMiLCJldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nIiwid2FybiIsImlzRXhwcmVzc2lvbiIsImNyZWF0ZUV4cHJlc3Npb24iLCJwYXJzZXIiLCJnZXRFeHBlY3RlZFR5cGUiLCJab29tQ29uc3RhbnRFeHByZXNzaW9uIiwiX3N0eWxlRXhwcmVzc2lvbiIsImlzU3RhdGVEZXBlbmRlbnQiLCJab29tRGVwZW5kZW50RXhwcmVzc2lvbiIsImNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbiIsImlzRmVhdHVyZUNvbnN0YW50JDEiLCJpc1pvb21Db25zdGFudCIsInpvb21DdXJ2ZSIsImZpbmRab29tQ3VydmUiLCJTdHlsZVByb3BlcnR5RnVuY3Rpb24iLCJzcGVjaWZpY2F0aW9uIiwiX3BhcmFtZXRlcnMiLCJfc3BlY2lmaWNhdGlvbiIsImRlc2VyaWFsaXplIiwibm9ybWFsaXplUHJvcGVydHlFeHByZXNzaW9uIiwiY2hpbGRSZXN1bHQiLCJlbnVtIiwiZm9ybWF0dGVkIiwicmVzb2x2ZWRJbWFnZSIsImNvbnZlcnRMaXRlcmFsIiwiY29udmVydEZ1bmN0aW9uIiwiY29udmVydElkZW50aXR5RnVuY3Rpb24iLCJjb252ZXJ0VG9rZW5TdHJpbmciLCJjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24iLCJjb252ZXJ0Wm9vbUZ1bmN0aW9uIiwiY29udmVydFByb3BlcnR5RnVuY3Rpb24iLCJnZXRJbnRlcnBvbGF0ZU9wZXJhdG9yIiwiZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVycyIsImZ1bmN0aW9uVHlwZSIsImdldEZ1bmN0aW9uVHlwZSIsImFwcGVuZFN0b3BQYWlyIiwiZXhwcmVzc2lvbiQxIiwieiQxIiwib3V0cHV0JDEiLCJmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUiLCJjb2FsZXNjZSQxIiwiZXhwcmVzc2lvbiQyIiwic3RvcCQyIiwiZXhwcmVzc2lvbiQzIiwic3RvcCQzIiwiaXNTdGVwIiwiY3VydmUiLCJyZSIsInBvcyIsImlzRXhwcmVzc2lvbkZpbHRlciIsImZpbHRlclNwZWMiLCJjcmVhdGVGaWx0ZXIiLCJuZWVkR2VvbWV0cnkiLCJjb252ZXJ0RmlsdGVyIiwiY29tcGlsZWQiLCJnbG9iYWxQcm9wZXJ0aWVzIiwiY29udmVydGVkIiwiY29udmVydENvbXBhcmlzb25PcCIsImNvbnZlcnROZWdhdGlvbiIsImNvbnZlcnREaXNqdW5jdGlvbk9wIiwiY29udmVydEluT3AiLCJjb252ZXJ0SGFzT3AiLCJmaWx0ZXJzIiwiY29udmVydEZpbHRlciQxIiwiX2NvbnZlcnRGaWx0ZXIiLCJleHBlY3RlZFR5cGVzIiwiY29udmVydENvbXBhcmlzb25PcCQxIiwiY2hpbGRyZW4iLCJ0eXBlY2hlY2tzIiwicnVudGltZVR5cGVDaGVja3MiLCJjaGlsZHJlbiQxIiwiY29udmVydEluT3AkMSIsImNvbnZlcnRIYXNPcCQxIiwiY29uZGl0aW9ucyIsIm5lZ2F0ZSIsInVuaWZvcm1UeXBlcyIsInVuaXF1ZVZhbHVlcyIsIm1pZ3JhdGVUb0V4cHJlc3Npb25zIiwibWlncmF0ZSIsIm1pZ3JhdGVkIiwiY29tcG9zaXRlIiwic3R5bGVJRHMiLCJzb3VyY2VJRHMiLCJjb21wb3NpdGVkU291cmNlTGF5ZXJzIiwiY29tcG9zaXRlSUQiLCJyZWZQcm9wZXJ0aWVzIiwiZGVyZWYiLCJkZXJlZkxheWVycyIsImRlZXBFcXVhbCIsIm9wZXJhdGlvbnMiLCJyZW1vdmVMYXllciIsInNldFBhaW50UHJvcGVydHkiLCJzZXRMYXlvdXRQcm9wZXJ0eSIsInNldEZpbHRlciIsImFkZFNvdXJjZSIsInJlbW92ZVNvdXJjZSIsInNldEdlb0pTT05Tb3VyY2VEYXRhIiwic2V0TGF5ZXJab29tUmFuZ2UiLCJzZXRMYXllclByb3BlcnR5Iiwic2V0QmVhcmluZyIsInNldFBpdGNoIiwic2V0U3ByaXRlIiwic2V0R2x5cGhzIiwic2V0VHJhbnNpdGlvbiIsInNldExpZ2h0IiwiYWZ0ZXIiLCJjb21tYW5kcyIsImNvbW1hbmQiLCJzb3VyY2VzUmVtb3ZlZCIsInVwZGF0ZVNvdXJjZSIsImNhblVwZGF0ZUdlb0pTT04iLCJiZWZvcmUiLCJkaWZmU291cmNlcyIsImRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyIsImtsYXNzIiwicGx1Y2tJZCIsImluZGV4QnlJZCIsImRpZmZMYXllcnMiLCJiZWZvcmVPcmRlciIsImFmdGVyT3JkZXIiLCJiZWZvcmVJbmRleCIsInJlZHVjZSIsImFmdGVySW5kZXgiLCJ0cmFja2VyIiwiY2xlYW4iLCJiZWZvcmVMYXllciIsImFmdGVyTGF5ZXIiLCJpbnNlcnRCZWZvcmVMYXllcklkIiwiZGlmZlN0eWxlcyIsInJlbW92ZU9yQWRkU291cmNlQ29tbWFuZHMiLCJiZWZvcmVMYXllcnMiLCJWYWxpZGF0aW9uRXJyb3IiLCJpZGVudGlmaWVyIiwiX19saW5lX18iLCJQYXJzaW5nRXJyb3IkMSIsInZhbGlkYXRlQ29uc3RhbnRzIiwidW5idW5kbGUiLCJ2YWx1ZU9mIiwiZGVlcFVuYnVuZGxlIiwidW5idW5kbGVkVmFsdWUiLCJ2YWxpZGF0ZU9iamVjdCIsImVsZW1lbnRTcGVjcyIsInZhbHVlU3BlYyIsImVsZW1lbnRWYWxpZGF0b3JzIiwib2JqZWN0RWxlbWVudFZhbGlkYXRvcnMiLCJzdHlsZVNwZWMiLCJvYmplY3RLZXkiLCJlbGVtZW50U3BlY0tleSIsImVsZW1lbnRTcGVjIiwidmFsaWRhdGVFbGVtZW50IiwidmFsaWRhdGUiLCJlbGVtZW50U3BlY0tleSQxIiwidmFsaWRhdGVBcnJheSIsImFycmF5U3BlYyIsInZhbGlkYXRlQXJyYXlFbGVtZW50IiwiYXJyYXlFbGVtZW50VmFsaWRhdG9yIiwiYXJyYXlFbGVtZW50U3BlYyIsImZ1bmN0aW9uIiwiYXJyYXlJbmRleCIsInZhbGlkYXRlTnVtYmVyIiwidmFsaWRhdGVGdW5jdGlvbiIsImZ1bmN0aW9uVmFsdWVTcGVjIiwic3RvcEtleVR5cGUiLCJzdG9wRG9tYWluVmFsdWVzIiwicHJldmlvdXNTdG9wRG9tYWluVmFsdWUiLCJwcmV2aW91c1N0b3BEb21haW5ab29tIiwiaXNab29tRnVuY3Rpb24iLCJpc1Byb3BlcnR5RnVuY3Rpb24iLCJpc1pvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uIiwidmFsaWRhdGVGdW5jdGlvblN0b3BzIiwidmFsaWRhdGVGdW5jdGlvbkRlZmF1bHQiLCJ2YWxpZGF0ZUZ1bmN0aW9uU3RvcCIsInZhbGlkYXRlU3RvcERvbWFpblZhbHVlIiwicmVwb3J0VmFsdWUiLCJ2YWxpZGF0ZUV4cHJlc3Npb24iLCJleHByZXNzaW9uQ29udGV4dCIsImV4cHJlc3Npb25PYmoiLCJwcm9wZXJ0eUtleSIsInZhbGlkYXRlQm9vbGVhbiIsInZhbGlkYXRlQ29sb3IiLCJ2YWxpZGF0ZUVudW0iLCJ2YWxpZGF0ZUZpbHRlciIsInZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlciIsInZhbGlkYXRlUHJvcGVydHkiLCJsYXllclNwZWMiLCJsYXllclR5cGUiLCJ0cmFuc2l0aW9uTWF0Y2giLCJ0b2tlbk1hdGNoIiwidmFsaWRhdGVQYWludFByb3BlcnR5IiwidmFsaWRhdGVMYXlvdXRQcm9wZXJ0eSIsInZhbGlkYXRlTGF5ZXIiLCJvdGhlckxheWVyIiwic291cmNlVHlwZSIsInZhbGlkYXRlU3RyaW5nIiwidmFsaWRhdGVQcm9tb3RlSWQiLCJ2YWxpZGF0ZVNvdXJjZSIsIm1hcEV4cHIiLCJyZWR1Y2VFeHByIiwidmFsaWRhdGVMaWdodCIsImxpZ2h0U3BlYyIsInJvb3RUeXBlIiwidmFsaWRhdGVGb3JtYXR0ZWQiLCJ2YWxpZGF0ZUltYWdlIiwiVkFMSURBVE9SUyIsInZhbGlkIiwidmFsaWRhdGVHbHlwaHNVUkwiLCJ2YWxpZGF0ZVN0eWxlTWluIiwic29ydEVycm9ycyIsIndyYXBDbGVhbkVycm9ycyIsInBhaW50UHJvcGVydHkiLCJsYXlvdXRQcm9wZXJ0eSIsImpzb25saW50IiwibyIsIiRWMCIsIiRWMSIsIiRWMiIsIiRWMyIsIiRWNCIsIiRWNSIsIiRWNiIsIiRWNyIsIiRWOCIsIiRWOSIsInRyYWNlIiwieXkiLCJzeW1ib2xzXyIsInRlcm1pbmFsc18iLCJwcm9kdWN0aW9uc18iLCJwZXJmb3JtQWN0aW9uIiwiYW5vbnltb3VzIiwieXl0ZXh0IiwieXlsZW5nIiwieXlsaW5lbm8iLCJ5eXN0YXRlIiwiJCQiLCJfJCIsIiQwIiwiJCIsImZpcnN0X2xpbmUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ0YWJsZSIsImRlZmF1bHRBY3Rpb25zIiwicGFyc2VFcnJvciIsInJlY292ZXJhYmxlIiwic3RhY2siLCJ2c3RhY2siLCJsc3RhY2siLCJURVJST1IiLCJFT0YiLCJsZXhlciIsInNoYXJlZFN0YXRlIiwic2V0SW5wdXQiLCJ5eWxsb2MiLCJ5eWxvYyIsInJhbmdlcyIsImdldFByb3RvdHlwZU9mIiwibGV4IiwidG9rZW4iLCJzdGF0ZSIsImFjdGlvbiIsInl5dmFsIiwibmV3U3RhdGUiLCJlcnJTdHIiLCJzaG93UG9zaXRpb24iLCJsb2MiLCJsYXN0X2xpbmUiLCJmaXJzdF9jb2x1bW4iLCJsYXN0X2NvbHVtbiIsInJhbmdlIiwiX2lucHV0IiwiX21vcmUiLCJfYmFja3RyYWNrIiwiZG9uZSIsIm1hdGNoZWQiLCJjb25kaXRpb25TdGFjayIsIm9mZnNldCIsImNoIiwibGluZXMiLCJ1bnB1dCIsIm9sZExpbmVzIiwibW9yZSIsImJhY2t0cmFja19sZXhlciIsImxlc3MiLCJwYXN0SW5wdXQiLCJwYXN0IiwidXBjb21pbmdJbnB1dCIsIm5leHQiLCJwcmUiLCJ0ZXN0X21hdGNoIiwiaW5kZXhlZF9ydWxlIiwiYmFja3VwIiwibWF0Y2hlcyIsInRlbXBNYXRjaCIsInJ1bGVzIiwiX2N1cnJlbnRSdWxlcyIsImZsZXgiLCJiZWdpbiIsImNvbmRpdGlvbiIsInBvcFN0YXRlIiwidG9wU3RhdGUiLCJwdXNoU3RhdGUiLCJzdGF0ZVN0YWNrU2l6ZSIsInl5XyIsIiRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMiLCJZWV9TVEFSVCIsIlBhcnNlciIsImpzb25saW50XzEiLCJqc29ubGludF8yIiwianNvbmxpbnRfMyIsInJlYWRTdHlsZSIsIkJ1ZmZlciIsInZhbGlkYXRlU3R5bGUiLCJTVVBQT1JURURfU1BFQ19WRVJTSU9OIiwiTUFYX1NPVVJDRVNfSU5fU1RZTEUiLCJpc1ZhbGlkIiwicmVnZXgiLCJnZXRTb3VyY2VDb3VudCIsImdldEFsbG93ZWRLZXlFcnJvcnMiLCJhbGxvd2VkIiwiU2V0IiwiZ2V0U291cmNlRXJyb3JzIiwic291cmNlS2V5cyIsInNvdXJjZVVybFBhdHRlcm4iLCJnZXRTb3VyY2VzRXJyb3JzIiwiY291bnQiLCJzb3VyY2VFcnJvcnMiLCJnZXRSb290RXJyb3JzIiwic3BlY0tleXMiLCJvcHRpb25hbFJvb3RQcm9wZXJ0aWVzIiwiYWxsb3dlZEtleUVycm9ycyIsImdseXBoVXJsUGF0dGVybiIsInNwcml0ZVVybFBhdHRlcm4iLCJ2aXNpYmlsaXR5UGF0dGVybiIsInZhbGlkYXRlTWFwYm94QXBpU3VwcG9ydGVkIiwic3R5bGVGdW5jdGlvbiIsInZpc2l0IiwibGF0ZXN0IiwiZGlmZiIsImZlYXR1cmVGaWx0ZXIiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsImNvZGUiLCJnZXRMZW5zIiwiYjY0IiwidmFsaWRMZW4iLCJwbGFjZUhvbGRlcnNMZW4iLCJsZW5zIiwiX2J5dGVMZW5ndGgiLCJ0bXAiLCJhcnIiLCJjdXJCeXRlIiwidHJpcGxldFRvQmFzZTY0IiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsImV4dHJhQnl0ZXMiLCJtYXhDaHVua0xlbmd0aCIsImJhc2U2NCIsInJlcXVpcmUiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsImZvbyIsInN1YmFycmF5IiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJBcnJheUJ1ZmZlciIsImZyb21BcnJheUJ1ZmZlciIsImZyb21PYmplY3QiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uZmlndXJhYmxlIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsImlzRW5jb2RpbmciLCJ3cml0ZSIsImZyb21BcnJheUxpa2UiLCJieXRlT2Zmc2V0IiwiaXNCdWZmZXIiLCJjb3B5IiwiaXNuYW4iLCJfaXNCdWZmZXIiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwiaW5zcGVjdCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsImRpciIsImFycmF5SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwicmVtYWluaW5nIiwic3RyTGVuIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJfYXJyIiwicmVzIiwiZmlyc3RCeXRlIiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsInJldCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJkc3QiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsImZvbnRXZWlnaHRzIiwidGhpbiIsImhhaXJsaW5lIiwiYm9vayIsInJlZ3VsYXIiLCJub3JtYWwiLCJwbGFpbiIsInJvbWFuIiwic3RhbmRhcmQiLCJtZWRpdW0iLCJib2xkIiwiaGVhdnkiLCJmYXQiLCJwb3N0ZXIiLCJzcCIsIml0YWxpY1JFIiwiZm9udENhY2hlIiwibGluZUhlaWdodCIsImNzc0RhdGEiLCJ3ZWlnaHQiLCJmb250RmFtaWxpZXMiLCJoYXZlV2VpZ2h0IiwiaGF2ZVN0eWxlIiwibWF5YmVXZWlnaHQiLCJmb250RmFtaWx5IiwiaWNvbiIsInRpdGxlIiwibGluayIsImdldExpbmsiLCJub3JtYWxpemVOYW1lIiwiRnVuY3Rpb24iLCJzdHlsZWZ1bmN0aW9uIiwiZ2V0VmFsdWUiLCJvbExheWVyIiwic3ByaXRlSW1hZ2UiLCJzcHJpdGVJbWdTaXplIiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJjaGFuZ2VkIiwiZ2V0Q29udGV4dCIsIm1lYXN1cmVDYWNoZSIsIndyYXBUZXh0IiwiZW0iLCJ3cmFwcGVkVGV4dCIsIm9uZUVtIiwibWVhc3VyZVRleHQiLCJ3b3JkcyIsIndvcmQiLCJhbGxMYXllcnMiLCJsYXllcnNCeVNvdXJjZUxheWVyIiwibWFwYm94TGF5ZXJzIiwibWFwYm94U291cmNlIiwic291cmNlTGF5ZXIiLCJmdW5jdGlvbkNhY2hlIiwiZmlsdGVyQ2FjaGUiLCJpY29uSW1hZ2VDYWNoZSIsInN0eWxlcyIsInBhdHRlcm5DYWNoZSIsInJlc29sdXRpb24iLCJnZXRQcm9wZXJ0aWVzIiwic3R5bGVJZHMiLCJnZXRHZW9tZXRyeSIsInN0eWxlc0xlbmd0aCIsImxheWVyRGF0YSIsImVtcHR5T2JqIiwiaWNvbkltZyIsImV2YWx1YXRlRmlsdGVyIiwic3Ryb2tlIiwic3Ryb2tlQ29sb3IiLCJpY29uSW1hZ2UiLCJmcm9tVGVtcGxhdGUiLCJnZXRGaWxsIiwiZ2V0U3Ryb2tlIiwiZ2V0VGV4dCIsIlN0eWxlIiwiRmlsbCIsInNldFpJbmRleCIsImljb25fY2FjaGVfa2V5IiwicGF0dGVybiIsInNwcml0ZUltYWdlRGF0YSIsImNhbnZhcyIsImdsb2JhbEFscGhhIiwiZHJhd0ltYWdlIiwiY3JlYXRlUGF0dGVybiIsInNldENvbG9yIiwiY29sb3JXaXRoT3BhY2l0eSIsIlN0cm9rZSIsInNldFdpZHRoIiwic2V0TGluZUNhcCIsInNldExpbmVKb2luIiwic2V0TWl0ZXJMaW1pdCIsInNldExpbmVEYXNoIiwiaGFzSW1hZ2UiLCJza2lwTGFiZWwiLCJzdHlsZUdlb20iLCJnZW9tIiwiZ2V0RmxhdE1pZHBvaW50IiwiZXh0ZW50Iiwic2V0R2VvbWV0cnkiLCJpY29uU2l6ZSIsImljb25Db2xvciIsImljb25UcmFuc2xhdGUiLCJpY29uVHJhbnNsYXRlQW5jaG9yIiwiaWNvbkFuY2hvclZhbHVlIiwiaWNvbk9mZnNldCIsImNvdmVydEljb25BbmNob3IiLCJhbmNob3JPZmZzZXQiLCJpY29uQW5jaG9yIiwiZ2V0SW1hZ2VEYXRhIiwiY2MiLCJwdXRJbWFnZURhdGEiLCJ0cmFuc2xhdGVPZmZzZXQiLCJJY29uIiwiYW5jaG9yT3JpZ2luIiwiaW1nU2l6ZSIsInBpeGVsUmF0aW8iLCJyb3RhdGVWYWx1ZSIsInNldFJvdGF0aW9uIiwic2V0T3BhY2l0eSIsInNldEltYWdlIiwic2V0VGV4dCIsImNpcmNsZVJhZGl1cyIsImNpcmNsZVN0cm9rZUNvbG9yIiwiY2lyY2xlQ29sb3IiLCJjaXJjbGVPcGFjaXR5IiwiY2lyY2xlU3Ryb2tlV2lkdGgiLCJjaXJjbGVTdHJva2VPcGFjaXR5IiwiY2FjaGVfa2V5IiwiQ2lyY2xlIiwicmFkaXVzIiwidGV4dEZpZWxkIiwiVGV4dCIsInRleHRTaXplIiwidGV4dExpbmVIZWlnaHQiLCJjaG9vc2VGb250IiwidGV4dFRyYW5zZm9ybSIsIndyYXBwZWRMYWJlbCIsInNldEZvbnQiLCJ0ZXh0QW5jaG9yIiwicGxhY2VtZW50Iiwic2V0UGxhY2VtZW50IiwidGV4dEhhbG9XaWR0aCIsInRleHRPZmZzZXQiLCJ0ZXh0VHJhbnNsYXRlIiwidk9mZnNldCIsImhPZmZzZXQiLCJ0ZXh0QWxpZ24iLCJzZXRUZXh0QWxpZ24iLCJzZXRNYXhBbmdsZSIsInRleHRCYXNlbGluZSIsInNldFRleHRCYXNlbGluZSIsInNldE9mZnNldFgiLCJzZXRPZmZzZXRZIiwic2V0RmlsbCIsImhhbG9Db2xvciIsInRleHRIYWxvIiwic2V0U3Ryb2tlIiwiZXhwcmVzc2lvbkRhdGEiLCJyYXdFeHByZXNzaW9uIiwiY29tcGlsZWRFeHByZXNzaW9uIiwiem9vbU9iaiIsImxheW91dE9yUGFpbnQiLCJmdW5jdGlvbnMiLCJpc0V4cHIiLCJmb250TWFwIiwidGVtcGxhdGVSZWdFeCIsImdldFpvb21Gb3JSZXNvbHV0aW9uIiwiZGVncmVlcyIsImNhbmRpZGF0ZSIsInpvb21GYWN0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OFFDbEZBOzs7Ozs7UUEyR2dCQSxVLEdBQUFBLFU7UUEwR0FDLGUsR0FBQUEsZTtRQXFQQUMsSyxHQUFBQSxLO1FBb0RBQyxRLEdBQUFBLFE7UUFlQUMsUyxHQUFBQSxTOztBQXZnQmhCOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJQyxjQUFKOztBQUVBLFNBQVNDLFFBQVQsQ0FBa0JDLEtBQWxCLEVBQXlCO0FBQ3ZCLE1BQUlDLENBQUosRUFBT0MsRUFBUDtBQUNBLE1BQUksQ0FBQ0MsTUFBTUMsT0FBTixDQUFjSixLQUFkLENBQUwsRUFBMkI7QUFDekIsUUFBSUssUUFBUUwsTUFBTUssS0FBbEI7QUFDQSxRQUFJQSxLQUFKLEVBQVc7QUFDVCxXQUFLSixJQUFJLENBQUosRUFBT0MsS0FBS0csTUFBTUMsTUFBdkIsRUFBK0JMLElBQUlDLEVBQW5DLEVBQXVDLEVBQUVELENBQXpDLEVBQTRDO0FBQzFDRixpQkFBU00sTUFBTUosQ0FBTixFQUFTLENBQVQsQ0FBVDtBQUNEO0FBQ0Y7QUFDRDtBQUNEO0FBQ0QsTUFBSU0saUJBQWlCQyxpQkFBWUMsUUFBWixFQUFyQjtBQUNBLE1BQUlDLFdBQVdWLE1BQU1XLEdBQU4sQ0FBVSxVQUFTQyxJQUFULEVBQWU7QUFDdEMsV0FBTywrQkFBT0EsSUFBUCxFQUFhLENBQWIsRUFBZ0JDLEtBQWhCLENBQXNCLE9BQXRCLEVBQStCLENBQS9CLEVBQWtDQyxPQUFsQyxDQUEwQyxJQUExQyxFQUFnRCxFQUFoRCxDQUFQO0FBQ0QsR0FGYyxDQUFmO0FBR0EsT0FBS2IsSUFBSSxDQUFKLEVBQU9DLEtBQUtRLFNBQVNKLE1BQTFCLEVBQWtDTCxJQUFJQyxFQUF0QyxFQUEwQyxFQUFFRCxDQUE1QyxFQUErQztBQUM3QyxRQUFJYyxTQUFTTCxTQUFTVCxDQUFULENBQWI7QUFDQSxRQUFJVyxPQUFPWixNQUFNQyxDQUFOLENBQVg7QUFDQSxRQUFJTSxlQUFlUyxPQUFmLENBQXVCRCxNQUF2QixNQUFtQyxDQUFDLENBQXhDLEVBQTJDO0FBQ3pDLFVBQUksQ0FBQ2pCLGNBQUwsRUFBcUI7QUFDbkJBLHlCQUFpQixFQUFqQjtBQUNEO0FBQ0QsVUFBSUEsZUFBZWtCLE9BQWYsQ0FBdUJKLElBQXZCLEtBQWdDLENBQUMsQ0FBckMsRUFBd0M7QUFDdENkLHVCQUFlbUIsSUFBZixDQUFvQkwsSUFBcEI7QUFDQSxZQUFJTSxVQUFVLDZDQUE2Q0gsT0FBT0QsT0FBUCxDQUFlLElBQWYsRUFBcUIsR0FBckIsQ0FBM0Q7QUFDQSxZQUFJLENBQUNLLFNBQVNDLGFBQVQsQ0FBdUIsZ0JBQWdCRixPQUFoQixHQUEwQixJQUFqRCxDQUFMLEVBQTZEO0FBQzNELGNBQUlHLFNBQVNGLFNBQVNHLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBYjtBQUNBRCxpQkFBT0UsSUFBUCxHQUFjTCxPQUFkO0FBQ0FHLGlCQUFPRyxHQUFQLEdBQWEsWUFBYjtBQUNBTCxtQkFBU00sb0JBQVQsQ0FBOEIsTUFBOUIsRUFBc0MsQ0FBdEMsRUFBeUNDLFdBQXpDLENBQXFETCxNQUFyRDtBQUNEO0FBQ0Y7QUFDRDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxJQUFJTSxjQUFjLENBQUMsbUJBQUQsRUFBc0IsZUFBdEIsQ0FBbEI7O0FBRUEsU0FBU0MsVUFBVCxDQUFvQkMsS0FBcEIsRUFBMkI7QUFDekIsTUFBSSxZQUFZQSxLQUFaLElBQXFCLGdCQUFnQkEsTUFBTUMsTUFBL0MsRUFBdUQ7QUFDckQvQixhQUFTOEIsTUFBTUMsTUFBTixDQUFhLFdBQWIsS0FBNkJILFdBQXRDO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJSSxjQUFjLGNBQWxCOztBQUVBLFNBQVNDLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQXVCQyxJQUF2QixFQUE2QjtBQUMzQixNQUFJQSxRQUFRRCxJQUFJakIsT0FBSixDQUFZLE1BQVosS0FBdUIsQ0FBbkMsRUFBc0M7QUFDcENpQixVQUFNQyxPQUFPRCxHQUFiO0FBQ0Q7QUFDRCxTQUFPQSxHQUFQO0FBQ0Q7O0FBRUQsU0FBU0UsV0FBVCxDQUFxQkYsR0FBckIsRUFBMEJDLElBQTFCLEVBQWdDRSxTQUFoQyxFQUEyQztBQUN6Q0gsUUFBTUQsU0FBU0MsR0FBVCxFQUFjQyxJQUFkLENBQU47QUFDQSxNQUFJRyxRQUFRSixJQUFJSyxLQUFKLENBQVVQLFdBQVYsQ0FBWjtBQUNBLFNBQU9NLFFBQ0xBLE1BQU0sQ0FBTixJQUFXRCxTQUFYLElBQXdCQyxNQUFNL0IsTUFBTixHQUFlLENBQWYsR0FBbUIrQixNQUFNLENBQU4sQ0FBbkIsR0FBOEIsRUFBdEQsQ0FESyxHQUVMSixNQUFNRyxTQUZSO0FBR0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQk8sU0FBUzNDLFVBQVQsQ0FBb0JvQyxLQUFwQixFQUEyQlUsT0FBM0IsRUFBb0NDLE1BQXBDLEVBQTRDTixJQUE1QyxFQUFrRE8sV0FBbEQsRUFBK0Q7QUFDcEUsU0FBTyxJQUFJQyxPQUFKLENBQVksVUFBU0MsT0FBVCxFQUFrQkMsTUFBbEIsRUFBMEI7O0FBRTNDLFFBQUksUUFBT0wsT0FBUCx5Q0FBT0EsT0FBUCxNQUFrQixRQUF0QixFQUFnQztBQUM5QkEsZ0JBQVVNLEtBQUtDLEtBQUwsQ0FBV1AsT0FBWCxDQUFWO0FBQ0Q7QUFDRCxRQUFJQSxRQUFRUSxPQUFSLElBQW1CLENBQXZCLEVBQTBCO0FBQ3hCSCxhQUFPLElBQUlJLEtBQUosQ0FBVSw2QkFBVixDQUFQO0FBQ0Q7QUFDRCxRQUFJQyxXQUFKLEVBQWlCQyxVQUFqQixFQUE2QkMsY0FBN0I7QUFDQSxRQUFJWixRQUFRYSxNQUFaLEVBQW9CO0FBQ2xCSCxvQkFBY0ksT0FBT0MsZ0JBQVAsSUFBMkIsR0FBM0IsR0FBaUMsR0FBakMsR0FBdUMsQ0FBckQ7QUFDQSxVQUFJQyxhQUFhTixlQUFlLEdBQWYsR0FBcUIsS0FBckIsR0FBNkIsRUFBOUM7QUFDQSxVQUFJTyxZQUFZckIsWUFBWUksUUFBUWEsTUFBcEIsRUFBNEJsQixJQUE1QixFQUFrQ3FCLGFBQWEsT0FBL0MsQ0FBaEI7O0FBRUFFLFlBQU1ELFNBQU4sRUFBaUIsRUFBQ0UsYUFBYSxhQUFkLEVBQWpCLEVBQ0dDLElBREgsQ0FDUSxVQUFTQyxRQUFULEVBQW1CO0FBQ3ZCO0FBQ0EsWUFBSUEsU0FBU0MsTUFBVCxLQUFvQixHQUF4QixFQUE2QjtBQUMzQixpQkFBT0QsU0FBU0UsSUFBVCxFQUFQO0FBQ0QsU0FGRCxNQUVPLElBQUlQLGVBQWUsRUFBbkIsRUFBdUI7QUFDNUI7QUFDQUEsdUJBQWEsRUFBYjtBQUNBQyxzQkFBWXJCLFlBQVlJLFFBQVFhLE1BQXBCLEVBQTRCbEIsSUFBNUIsRUFBa0MsT0FBbEMsQ0FBWjtBQUNBLGlCQUFPdUIsTUFBTUQsU0FBTixFQUFpQixFQUFDRSxhQUFhLGFBQWQsRUFBakIsRUFBK0NDLElBQS9DLENBQW9EO0FBQUEsbUJBQUtJLEVBQUVELElBQUYsRUFBTDtBQUFBLFdBQXBELENBQVA7QUFDRDtBQUNGLE9BWEgsRUFZR0gsSUFaSCxDQVlRLFVBQVNLLFdBQVQsRUFBc0I7QUFDMUIsWUFBSUEsZ0JBQWdCQyxTQUFwQixFQUErQjtBQUM3QixnQkFBTSxtQkFBTjtBQUNEO0FBQ0RmLHFCQUFhYyxXQUFiO0FBQ0FiLHlCQUFpQmhCLFlBQVlJLFFBQVFhLE1BQXBCLEVBQTRCbEIsSUFBNUIsRUFBa0NxQixhQUFhLE1BQS9DLENBQWpCO0FBQ0FXO0FBQ0QsT0FuQkgsRUFvQkdDLEtBcEJILENBb0JTLFVBQVNDLEdBQVQsRUFBYztBQUNuQkMsZ0JBQVFDLEtBQVIsQ0FBY0YsR0FBZDtBQUNBeEIsZUFBTyxJQUFJSSxLQUFKLENBQVUsbUNBQW1DUSxTQUE3QyxDQUFQO0FBQ0QsT0F2Qkg7QUF3QkQ7O0FBRUQsUUFBSWUsS0FBSjtBQUNBLGFBQVNMLFFBQVQsR0FBb0I7QUFDbEIsVUFBSSxDQUFDSyxLQUFELEtBQVcsQ0FBQ2hDLFFBQVFhLE1BQVQsSUFBbUJGLFVBQTlCLE1BQThDLENBQUNwRCxjQUFELElBQW1CQSxlQUFlUSxNQUFmLEdBQXdCLENBQXpGLENBQUosRUFBaUc7QUFDL0ZpRSxnQkFBUSw2QkFBbUIxQyxLQUFuQixFQUEwQlUsT0FBMUIsRUFBbUNDLE1BQW5DLEVBQTJDQyxXQUEzQyxFQUF3RFMsVUFBeEQsRUFBb0VDLGNBQXBFLEVBQW9GckQsY0FBcEYsQ0FBUjtBQUNBNkM7QUFDRCxPQUhELE1BR08sSUFBSTRCLEtBQUosRUFBVztBQUNoQjFDLGNBQU0yQyxRQUFOLENBQWVELEtBQWY7QUFDRDtBQUNGOztBQUVELFFBQUkxQyxpQkFBaUI0QyxvQkFBakIsSUFBb0M1QyxpQkFBaUI2QyxnQkFBekQsRUFBc0U7QUFDcEUsVUFBSTtBQUNGLFlBQUlDLFNBQVNwQyxRQUFRb0MsTUFBckI7QUFDQSxhQUFLLElBQUkxRSxJQUFJLENBQVIsRUFBV0MsS0FBS3lFLE9BQU9yRSxNQUE1QixFQUFvQ0wsSUFBSUMsRUFBeEMsRUFBNEMsRUFBRUQsQ0FBOUMsRUFBaUQ7QUFDL0MsY0FBSSxPQUFPdUMsTUFBUCxJQUFpQixRQUFqQixJQUE2Qm1DLE9BQU8xRSxDQUFQLEVBQVV1QyxNQUFWLElBQW9CQSxNQUFqRCxJQUEyREEsT0FBT3hCLE9BQVAsQ0FBZTJELE9BQU8xRSxDQUFQLEVBQVUyRSxFQUF6QixLQUFnQyxDQUEvRixFQUFrRztBQUNoR2hELHVCQUFXK0MsT0FBTzFFLENBQVAsQ0FBWDtBQUNEO0FBQ0Y7QUFDRGlFO0FBQ0QsT0FSRCxDQVFFLE9BQU9XLENBQVAsRUFBVTtBQUNWQyxtQkFBVyxZQUFXO0FBQ3BCbEMsaUJBQU9pQyxDQUFQO0FBQ0QsU0FGRCxFQUVHLENBRkg7QUFHRDtBQUNGO0FBQ0YsR0FqRU0sQ0FBUDtBQWtFRDs7QUFFRCxTQUFTRSxhQUFULENBQXVCcEUsR0FBdkIsRUFBNEJrQixLQUE1QixFQUFtQztBQUNqQyxNQUFNbUQsYUFBYTtBQUNqQkMsVUFBTXBELE1BQU1vRDtBQURLLEdBQW5CO0FBR0EsV0FBU0MsV0FBVCxHQUF1QjtBQUNyQixRQUFJQyxVQUFVeEUsSUFBSXlFLGdCQUFKLEVBQWQ7QUFDQSxRQUFJLENBQUNELE9BQUwsRUFBYztBQUNaO0FBQ0Q7QUFDRCxRQUFJckQsU0FBU0QsTUFBTUMsTUFBTixJQUFnQixFQUE3QjtBQUNBLFFBQUl1RCxRQUFReEQsTUFBTXdELEtBQU4sSUFBZSxFQUEzQjtBQUNBTCxlQUFXLE9BQVgsSUFBc0JLLEtBQXRCO0FBQ0FMLGVBQVdKLEVBQVgsR0FBZ0IsYUFBYVMsTUFBTSxvQkFBTixDQUFiLEdBQTJDQSxNQUFNLGtCQUFOLENBQTNEO0FBQ0EsUUFBSUMsT0FBTzNFLElBQUk0RSxPQUFKLEdBQWNDLE9BQWQsRUFBWDtBQUNBLFFBQUlILE1BQU0sa0JBQU4sTUFBOEJwQixTQUFsQyxFQUE2QztBQUMzQyxVQUFNd0IsS0FBSyw2QkFBU1QsVUFBVCxFQUFxQixPQUFyQixFQUE4QixrQkFBOUIsRUFBa0RNLElBQWxELEVBQXdELEVBQXhELENBQVg7QUFDQUgsY0FBUVosS0FBUixDQUFjUyxVQUFkLEdBQTJCVSx5QkFBTTVDLEtBQU4sQ0FBWTJDLEVBQVosRUFBZ0JFLFFBQWhCLEVBQTNCO0FBQ0Q7QUFDRCxRQUFJTixNQUFNLG9CQUFOLE1BQWdDcEIsU0FBcEMsRUFBK0M7QUFDN0NrQixjQUFRWixLQUFSLENBQWNxQixPQUFkLEdBQXdCLDZCQUFTWixVQUFULEVBQXFCLE9BQXJCLEVBQThCLG9CQUE5QixFQUFvRE0sSUFBcEQsRUFBMEQsRUFBMUQsQ0FBeEI7QUFDRDtBQUNELFFBQUl4RCxPQUFPK0QsVUFBUCxJQUFxQixNQUF6QixFQUFpQztBQUMvQlYsY0FBUVosS0FBUixDQUFjdUIsZUFBZCxHQUFnQyxFQUFoQztBQUNBWCxjQUFRWixLQUFSLENBQWNxQixPQUFkLEdBQXdCLEVBQXhCO0FBQ0Q7QUFDRjtBQUNELE1BQUlqRixJQUFJeUUsZ0JBQUosRUFBSixFQUE0QjtBQUMxQkY7QUFDRDtBQUNEdkUsTUFBSW9GLEVBQUosQ0FBTyxDQUFDLG1CQUFELEVBQXNCLGVBQXRCLENBQVAsRUFBK0NiLFdBQS9DO0FBQ0Q7O0FBRUQ7Ozs7O0FBS08sU0FBU3hGLGVBQVQsQ0FBeUJpQixHQUF6QixFQUE4QjRCLE9BQTlCLEVBQXVDO0FBQzVDQSxVQUFRb0MsTUFBUixDQUFlcUIsSUFBZixDQUFvQixVQUFTQyxDQUFULEVBQVk7QUFDOUIsUUFBSUEsRUFBRWhCLElBQUYsSUFBVSxZQUFkLEVBQTRCO0FBQzFCRixvQkFBY3BFLEdBQWQsRUFBbUJzRixDQUFuQjtBQUNBLGFBQU8sSUFBUDtBQUNEO0FBQ0YsR0FMRDtBQU1EOztBQUVELFNBQVNDLGdCQUFULENBQTBCdkIsTUFBMUIsRUFBa0N3QixHQUFsQyxFQUF1QztBQUNyQyxNQUFJQyxRQUFKO0FBQ0F6QixTQUFPcUIsSUFBUCxDQUFZLFVBQVNuRSxLQUFULEVBQWdCO0FBQzFCLFFBQUlBLE1BQU0rQyxFQUFOLElBQVl1QixHQUFoQixFQUFxQjtBQUNuQkMsaUJBQVd2RSxNQUFNVyxNQUFqQjtBQUNBLGFBQU8sSUFBUDtBQUNEO0FBQ0YsR0FMRDtBQU1BLFNBQU80RCxRQUFQO0FBQ0Q7O0FBRUQsU0FBU0MsWUFBVCxDQUFzQjlELE9BQXRCLEVBQStCNUIsR0FBL0IsRUFBb0MyRixPQUFwQyxFQUE2Q0MsSUFBN0MsRUFBbURyRSxJQUFuRCxFQUF5RHNFLFdBQXpELEVBQXNFO0FBQ3BFLE1BQUlDLE9BQU85RixJQUFJNEUsT0FBSixFQUFYO0FBQ0EsTUFBSSxZQUFZaEQsT0FBWixJQUF1QixDQUFDa0UsS0FBS0MsU0FBTCxFQUE1QixFQUE4QztBQUM1Q0QsU0FBS0UsU0FBTCxDQUFlLHNCQUFXcEUsUUFBUXFFLE1BQW5CLENBQWY7QUFDRDtBQUNELE1BQUksVUFBVXJFLE9BQVYsSUFBcUJrRSxLQUFLakIsT0FBTCxPQUFtQnZCLFNBQTVDLEVBQXVEO0FBQ3JEd0MsU0FBS0ksT0FBTCxDQUFhdEUsUUFBUStDLElBQXJCO0FBQ0Q7QUFDRCxNQUFJLENBQUNtQixLQUFLQyxTQUFMLEVBQUQsSUFBcUJELEtBQUtqQixPQUFMLE9BQW1CdkIsU0FBNUMsRUFBdUQ7QUFDckR3QyxTQUFLSyxHQUFMLENBQVNMLEtBQUtNLGFBQUwsR0FBcUJDLFNBQXJCLEVBQVQsRUFBMkM7QUFDekNDLGVBQVMsSUFEZ0M7QUFFekNDLFlBQU12RyxJQUFJd0csT0FBSjtBQUZtQyxLQUEzQztBQUlEO0FBQ0QsTUFBSTVFLFFBQVFhLE1BQVosRUFBb0I7QUFDbEIsUUFBSWIsUUFBUWEsTUFBUixDQUFlcEMsT0FBZixDQUF1QixXQUF2QixLQUF1QyxDQUEzQyxFQUE4QztBQUM1Q3VCLGNBQVFhLE1BQVIsR0FBaUJrRCxVQUFVLFNBQVYsR0FBc0JFLFdBQXZDO0FBQ0QsS0FGRCxNQUVPLElBQUlqRSxRQUFRYSxNQUFSLENBQWVwQyxPQUFmLENBQXVCLE1BQXZCLEtBQWtDLENBQXRDLEVBQXlDO0FBQzlDdUIsY0FBUWEsTUFBUixHQUFpQixDQUFDbUQsT0FBUUEsT0FBT3JFLElBQWYsR0FBdUIsRUFBeEIsSUFBOEJLLFFBQVFhLE1BQXRDLEdBQStDb0QsV0FBaEU7QUFDRDtBQUNGOztBQUVELE1BQUlZLFdBQVc3RSxRQUFRb0MsTUFBdkI7QUFDQSxNQUFJMEMsZ0JBQWdCLElBQUlDLGlCQUFKLEVBQXBCO0FBQ0EsTUFBSUMsV0FBVyxFQUFmOztBQUVBLFdBQVNDLGFBQVQsQ0FBdUIzRixLQUF2QixFQUE4QjtBQUM1QixRQUFJMEYsU0FBU2pILE1BQVQsR0FBa0IsQ0FBdEIsRUFBeUI7QUFDdkJLLFVBQUk4RyxRQUFKLENBQWE1RixLQUFiO0FBQ0EsVUFBSTJDLFdBQVcsU0FBWEEsUUFBVyxHQUFXO0FBQ3hCL0UsbUJBQVdvQyxLQUFYLEVBQWtCVSxPQUFsQixFQUEyQmdGLFFBQTNCLEVBQXFDckYsSUFBckMsRUFBMkN5QixJQUEzQyxDQUFnRCxZQUFXO0FBQ3pEOUIsZ0JBQU02RixVQUFOLENBQWlCLElBQWpCO0FBQ0QsU0FGRCxFQUVHLFVBQVM3QyxDQUFULEVBQVk7QUFDYjtBQUNBUixrQkFBUUMsS0FBUixDQUFjTyxDQUFkO0FBQ0QsU0FMRDtBQU1ELE9BUEQ7QUFRQSxVQUFJaEQsTUFBTWhDLFNBQU4sRUFBSixFQUF1QjtBQUNyQjJFO0FBQ0QsT0FGRCxNQUVPO0FBQ0wzQyxjQUFNOEYsSUFBTixDQUFXLGVBQVgsRUFBNEJuRCxRQUE1QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxNQUFJb0QsT0FBSixFQUFhQyxRQUFiLEVBQXVCQyxVQUF2QixFQUFtQ2xELEVBQW5DLEVBQXVDL0MsS0FBdkMsRUFBOENrRyxLQUE5QyxFQUFxRDlGLEdBQXJEO0FBQ0EsT0FBSyxJQUFJaEMsSUFBSSxDQUFSLEVBQVdDLEtBQUtrSCxTQUFTOUcsTUFBOUIsRUFBc0NMLElBQUlDLEVBQTFDLEVBQThDLEVBQUVELENBQWhELEVBQW1EO0FBQ2pEMkgsY0FBVVIsU0FBU25ILENBQVQsQ0FBVjtBQUNBLFFBQUkySCxRQUFRM0MsSUFBUixJQUFnQixZQUFwQixFQUFrQztBQUNoQ0Ysb0JBQWNwRSxHQUFkLEVBQW1CaUgsT0FBbkI7QUFDRCxLQUZELE1BRU87QUFDTGhELFdBQUtnRCxRQUFRcEYsTUFBUixJQUFrQjBELGlCQUFpQmtCLFFBQWpCLEVBQTJCUSxRQUFRekIsR0FBbkMsQ0FBdkI7QUFDQSxVQUFJdkIsTUFBTWtELFVBQVYsRUFBc0I7QUFDcEJOLHNCQUFjM0YsS0FBZDtBQUNBMEYsbUJBQVcsRUFBWDtBQUNBTSxtQkFBV3RGLFFBQVF5RixPQUFSLENBQWdCcEQsRUFBaEIsQ0FBWDtBQUNBM0MsY0FBTTRGLFNBQVM1RixHQUFmO0FBQ0EsWUFBSWdHLFFBQVFKLFNBQVNJLEtBQXJCO0FBQ0EsWUFBSWhHLEdBQUosRUFBUztBQUNQLGNBQUlBLElBQUlqQixPQUFKLENBQVksV0FBWixLQUE0QixDQUFoQyxFQUFtQztBQUNqQytHLG9CQUFROUYsSUFBSW5CLE9BQUosQ0FBWSxXQUFaLEVBQXlCLEVBQXpCLENBQVI7QUFDQW1ILG9CQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCdEgsR0FBckIsQ0FBeUIsVUFBUzRGLElBQVQsRUFBZTtBQUM5QyxxQkFBTyxhQUFhQSxJQUFiLEdBQW9CLHVCQUFwQixHQUE4Q3dCLEtBQTlDLEdBQ0gsZUFERyxJQUVGRixTQUFTNUMsSUFBVCxJQUFpQixRQUFqQixHQUE0QixZQUE1QixHQUEyQyxLQUZ6QyxJQUdIdUIsV0FISjtBQUlELGFBTE8sQ0FBUjtBQU1EO0FBQ0Y7O0FBRUQsWUFBSXFCLFNBQVM1QyxJQUFULElBQWlCLFFBQXJCLEVBQStCO0FBQzdCcEQsa0JBQVFvRyxRQUFTLFlBQVc7QUFDMUIsZ0JBQUlDLFdBQVcseUJBQVU7QUFDdkJDLHdCQUFVLEdBRGE7QUFFdkJDLHVCQUFTLGFBQWFQLFFBQWIsR0FBd0JBLFNBQVNRLE9BQWpDLEdBQTJDLEVBRjdCO0FBR3ZCQyx1QkFBU1QsU0FBU1U7QUFISyxhQUFWLENBQWY7QUFLQSxtQkFBTyxJQUFJOUQsb0JBQUosQ0FBb0I7QUFDekIrRCx5QkFBVyxJQURjO0FBRXpCQyw2QkFBZVAsU0FBU1EsVUFBVCxLQUF3QixDQUF4QixHQUNiUixTQUFTUyxhQUFULENBQXVCVCxTQUFTUSxVQUFULEVBQXZCLENBRGEsR0FDbUN6RSxTQUh6QjtBQUl6QnpCLHNCQUFRLElBQUlvRyxvQkFBSixDQUFxQjtBQUMzQkMsOEJBQWNoQixTQUFTaUIsV0FESTtBQUUzQkMsd0JBQVEsSUFBSUMsYUFBSixFQUZtQjtBQUczQmQsMEJBQVVBLFFBSGlCO0FBSTNCZSxzQkFBTWhCO0FBSnFCLGVBQXJCLENBSmlCO0FBVXpCaUIsdUJBQVMsS0FWZ0I7QUFXekJDLHNCQUFRbEo7QUFYaUIsYUFBcEIsQ0FBUDtBQWFELFdBbkJlLEVBQVIsR0FtQkEsWUFBVztBQUNqQixnQkFBSTRCLFFBQVEsSUFBSTRDLG9CQUFKLENBQW9CO0FBQzlCK0QseUJBQVcsSUFEbUI7QUFFOUJVLHVCQUFTLEtBRnFCO0FBRzlCQyxzQkFBUWxKO0FBSHNCLGFBQXBCLENBQVo7QUFLQSxnQkFBSW1KLFdBQVcsSUFBSUMsa0JBQUosQ0FBYTtBQUMxQnBILG1CQUFLQTtBQURxQixhQUFiLENBQWY7QUFHQSxnQkFBSXFILE1BQU1GLFNBQVNyRCxFQUFULENBQVksUUFBWixFQUFzQixZQUFXO0FBQ3pDLGtCQUFJcUQsU0FBU0csUUFBVCxNQUF1QixPQUEzQixFQUFvQztBQUNsQyxvQkFBSUMsY0FBY0osU0FBU0ssV0FBVCxFQUFsQjtBQUNBLG9CQUFJeEIsUUFBUTlILE1BQU1DLE9BQU4sQ0FBY29KLFlBQVl2QixLQUExQixJQUFtQ3VCLFlBQVl2QixLQUEvQyxHQUF1RCxDQUFDdUIsWUFBWXZCLEtBQWIsQ0FBbkU7QUFDQSxxQkFBSyxJQUFJaEksSUFBSSxDQUFSLEVBQVdDLEtBQUsrSCxNQUFNM0gsTUFBM0IsRUFBbUNMLElBQUlDLEVBQXZDLEVBQTJDLEVBQUVELENBQTdDLEVBQWdEO0FBQzlDLHNCQUFJeUosT0FBT3pCLE1BQU1oSSxDQUFOLENBQVg7QUFDQSxzQkFBSXlKLEtBQUsxSSxPQUFMLENBQWEsTUFBYixLQUF3QixDQUE1QixFQUErQjtBQUM3QmlILDBCQUFNaEksQ0FBTixJQUFXNEgsU0FBUzVGLEdBQVQsR0FBZXlILElBQTFCO0FBQ0Q7QUFDRjtBQUNELG9CQUFJeEIsV0FBV2tCLFNBQVNPLFdBQVQsRUFBZjtBQUNBOUgsc0JBQU0rSCxTQUFOLENBQWdCLElBQUloQixvQkFBSixDQUFxQjtBQUNuQ0MsZ0NBQWNPLFNBQVNTLGVBQVQsTUFBOEJMLFlBQVlWLFdBRHJCO0FBRW5DQywwQkFBUSxJQUFJQyxhQUFKLEVBRjJCO0FBR25DZCw0QkFBVSx5QkFBVTtBQUNsQkksNkJBQVNKLFNBQVNRLFVBQVQsRUFEUztBQUVsQk4sNkJBQVNGLFNBQVM0QixVQUFULEVBRlM7QUFHbEIzQiw4QkFBVTtBQUhRLG1CQUFWLENBSHlCO0FBUW5DYyx3QkFBTWhCO0FBUjZCLGlCQUFyQixDQUFoQjtBQVVBLG9CQUFJQyxTQUFTUSxVQUFULEtBQXdCLENBQTVCLEVBQStCO0FBQzdCN0csd0JBQU1rSSxnQkFBTixDQUNFN0IsU0FBU1MsYUFBVCxDQUF1QlQsU0FBU1EsVUFBVCxFQUF2QixDQURGO0FBRUQ7QUFDRCx5Q0FBUVksR0FBUjtBQUNEO0FBQ0YsYUEzQlMsQ0FBVjtBQTRCQSxtQkFBT3pILEtBQVA7QUFDRCxXQXRDTSxFQW5CUDtBQTBERCxTQTNERCxNQTJETyxJQUFJZ0csU0FBUzVDLElBQVQsSUFBaUIsUUFBckIsRUFBK0I7QUFDcEMsY0FBSXpDLE1BQUo7QUFDQSxjQUFJLENBQUNxRixTQUFTSSxLQUFkLEVBQXFCO0FBQ25CekYscUJBQVUsWUFBVztBQUNuQixxQkFBTyxJQUFJNkcsa0JBQUosQ0FBYTtBQUNsQnBILHFCQUFLQSxHQURhO0FBRWxCK0gsNkJBQWE7QUFGSyxlQUFiLENBQVA7QUFJRCxhQUxRLEVBQVQ7QUFNRCxXQVBELE1BT087QUFDTHhILHFCQUFTLElBQUl5SCxhQUFKLENBQVE7QUFDZnBCLDRCQUFjaEIsU0FBU2lCLFdBRFI7QUFFZlIsdUJBQVNULFNBQVNVLE9BRkg7QUFHZkgsdUJBQVMsYUFBYVAsUUFBYixHQUF3QkEsU0FBU1EsT0FBakMsR0FBMkMsRUFIckM7QUFJZkYsd0JBQVVOLFNBQVNNLFFBQVQsSUFBcUIsR0FKaEI7QUFLZmxHLG1CQUFLQSxHQUxVO0FBTWZnSCxvQkFBTXBCLFNBQVNJLEtBTkE7QUFPZitCLDJCQUFhO0FBUEUsYUFBUixDQUFUO0FBU0Q7QUFDRHhILGlCQUFPMEgsbUJBQVAsQ0FBMkIsVUFBU1IsSUFBVCxFQUFlUyxHQUFmLEVBQW9CO0FBQzdDLGdCQUFJQSxJQUFJbkosT0FBSixDQUFZLGtCQUFaLEtBQW1DLENBQUMsQ0FBeEMsRUFBMkM7QUFDekMsa0JBQUlvSixPQUFPNUgsT0FBT21ILFdBQVAsR0FBcUJVLGtCQUFyQixDQUF3Q1gsS0FBS1ksWUFBTCxFQUF4QyxDQUFYO0FBQ0FILG9CQUFNQSxJQUFJckosT0FBSixDQUFZLGtCQUFaLEVBQWdDc0osS0FBS3pFLFFBQUwsRUFBaEMsQ0FBTjtBQUNEO0FBQ0QrRCxpQkFBS2EsUUFBTCxHQUFnQkosR0FBaEIsR0FBc0JBLEdBQXRCO0FBQ0QsV0FORDtBQU9BdEksa0JBQVEsSUFBSTJJLGNBQUosQ0FBYztBQUNwQmhJLG9CQUFRQSxNQURZO0FBRXBCMEcscUJBQVN0QixRQUFROUYsTUFBUixHQUFpQjhGLFFBQVE5RixNQUFSLENBQWUrRCxVQUFmLEtBQThCLE1BQS9DLEdBQXdEO0FBRjdDLFdBQWQsQ0FBUjtBQUlELFNBL0JNLE1BK0JBLElBQUlnQyxTQUFTNUMsSUFBVCxJQUFpQixTQUFyQixFQUFnQztBQUNyQyxjQUFJd0YsT0FBTzVDLFNBQVM0QyxJQUFwQjtBQUNBLGNBQUlDLFFBQUosRUFBY0MsVUFBZDtBQUNBLGNBQUksT0FBT0YsSUFBUCxJQUFlLFFBQW5CLEVBQTZCO0FBQzNCRSx5QkFBYTNJLFNBQVN5SSxJQUFULEVBQWV2SSxJQUFmLENBQWI7QUFDRCxXQUZELE1BRU87QUFDTHdJLHVCQUFXckQsY0FBY3VELFlBQWQsQ0FBMkJILElBQTNCLEVBQWlDLEVBQUNJLG1CQUFtQixXQUFwQixFQUFqQyxDQUFYO0FBQ0Q7QUFDRGhKLGtCQUFRLElBQUk2QyxnQkFBSixDQUFnQjtBQUN0QmxDLG9CQUFRLElBQUlzSSxnQkFBSixDQUFpQjtBQUN2QmpDLDRCQUFjaEIsU0FBU2lCLFdBREE7QUFFdkI0Qix3QkFBVUEsUUFGYTtBQUd2QjNCLHNCQUFRMUIsYUFIZTtBQUl2QnBGLG1CQUFLMEk7QUFKa0IsYUFBakIsQ0FEYztBQU90QnpCLHFCQUFTLEtBUGE7QUFRdEJDLG9CQUFRbEo7QUFSYyxXQUFoQixDQUFSO0FBVUQ7QUFDRDZILHFCQUFhbEQsRUFBYjtBQUNEO0FBQ0QyQyxlQUFTdEcsSUFBVCxDQUFjMkcsUUFBUWhELEVBQXRCO0FBQ0Q7QUFDRjtBQUNENEMsZ0JBQWMzRixLQUFkO0FBQ0FsQixNQUFJb0ssR0FBSixDQUFRLGNBQVIsRUFBd0J4SSxPQUF4QjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNPLFNBQVM1QyxLQUFULENBQWVnQixHQUFmLEVBQW9CNEQsS0FBcEIsRUFBMkI7O0FBRWhDLE1BQUlpQyxXQUFKLEVBQWlCRixPQUFqQixFQUEwQkMsSUFBMUIsRUFBZ0NyRSxJQUFoQztBQUNBc0UsZ0JBQWNGLFVBQVVDLE9BQU9yRSxPQUFPLEVBQXRDOztBQUVBLE1BQUksRUFBRXZCLGVBQWVxSyxhQUFqQixDQUFKLEVBQTJCO0FBQ3pCckssVUFBTSxJQUFJcUssYUFBSixDQUFRO0FBQ1pDLGNBQVF0SztBQURJLEtBQVIsQ0FBTjtBQUdEOztBQUVELE1BQUksT0FBTzRELEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsUUFBSWxDLFFBQVFrQyxNQUFNakMsS0FBTixDQUFZUCxXQUFaLENBQVo7QUFDQSxRQUFJTSxLQUFKLEVBQVc7QUFDVGlFLGdCQUFVakUsTUFBTSxDQUFOLENBQVY7QUFDQW1FLG9CQUFjbkUsTUFBTS9CLE1BQU4sR0FBZSxDQUFmLEdBQW1CK0IsTUFBTSxDQUFOLENBQW5CLEdBQThCLEVBQTVDO0FBQ0Q7O0FBRURvQixVQUFNYyxLQUFOLEVBQWE7QUFDWGIsbUJBQWE7QUFERixLQUFiLEVBR0dDLElBSEgsQ0FHUSxVQUFTQyxRQUFULEVBQW1CO0FBQ3ZCLGFBQU9BLFNBQVNFLElBQVQsRUFBUDtBQUNELEtBTEgsRUFNR0gsSUFOSCxDQU1RLFVBQVNwQixPQUFULEVBQWtCO0FBQ3RCLFVBQUkySSxJQUFJL0osU0FBU0csYUFBVCxDQUF1QixHQUF2QixDQUFSO0FBQ0E0SixRQUFFM0osSUFBRixHQUFTZ0QsS0FBVDtBQUNBckMsYUFBT2dKLEVBQUVDLFFBQUYsQ0FBV3RLLEtBQVgsQ0FBaUIsR0FBakIsRUFBc0J1SyxLQUF0QixDQUE0QixDQUE1QixFQUErQixDQUFDLENBQWhDLEVBQW1DQyxJQUFuQyxDQUF3QyxHQUF4QyxJQUErQyxHQUF0RDtBQUNBOUUsYUFBT2hDLE1BQU0rRyxNQUFOLENBQWEsQ0FBYixFQUFnQi9HLE1BQU12RCxPQUFOLENBQWNrQixJQUFkLENBQWhCLENBQVA7O0FBRUFtRSxtQkFBYTlELE9BQWIsRUFBc0I1QixHQUF0QixFQUEyQjJGLE9BQTNCLEVBQW9DQyxJQUFwQyxFQUEwQ3JFLElBQTFDLEVBQWdEc0UsV0FBaEQ7QUFDRCxLQWJILEVBY0dyQyxLQWRILENBY1MsVUFBU0MsR0FBVCxFQUFjO0FBQ25CQyxjQUFRQyxLQUFSLENBQWNGLEdBQWQ7QUFDQSxZQUFNLElBQUlwQixLQUFKLENBQVUsb0JBQW9CdUIsS0FBOUIsQ0FBTjtBQUNELEtBakJIO0FBa0JELEdBekJELE1BeUJPO0FBQ0xPLGVBQVcsWUFBVztBQUNwQnVCLG1CQUFhOUIsS0FBYixFQUFvQjVELEdBQXBCO0FBQ0QsS0FGRCxFQUVHLENBRkg7QUFHRDtBQUNELFNBQU9BLEdBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRTyxTQUFTZixRQUFULENBQWtCZSxHQUFsQixFQUF1QjRLLE9BQXZCLEVBQWdDO0FBQ3JDLE1BQU01RyxTQUFTaEUsSUFBSTZLLFNBQUosR0FBZ0JDLFFBQWhCLEVBQWY7QUFDQSxPQUFLLElBQUl4TCxJQUFJLENBQVIsRUFBV0MsS0FBS3lFLE9BQU9yRSxNQUE1QixFQUFvQ0wsSUFBSUMsRUFBeEMsRUFBNEMsRUFBRUQsQ0FBOUMsRUFBaUQ7QUFDL0MsUUFBSTBFLE9BQU8xRSxDQUFQLEVBQVV5TCxHQUFWLENBQWMsZUFBZCxFQUErQjFLLE9BQS9CLENBQXVDdUssT0FBdkMsTUFBb0QsQ0FBQyxDQUF6RCxFQUE0RDtBQUMxRCxhQUFPNUcsT0FBTzFFLENBQVAsQ0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7O0FBTU8sU0FBU0osU0FBVCxDQUFtQmMsR0FBbkIsRUFBd0J5RixRQUF4QixFQUFrQztBQUN2QyxNQUFNekIsU0FBU2hFLElBQUk2SyxTQUFKLEdBQWdCQyxRQUFoQixFQUFmO0FBQ0EsT0FBSyxJQUFJeEwsSUFBSSxDQUFSLEVBQVdDLEtBQUt5RSxPQUFPckUsTUFBNUIsRUFBb0NMLElBQUlDLEVBQXhDLEVBQTRDLEVBQUVELENBQTlDLEVBQWlEO0FBQy9DLFFBQU11QyxTQUFTbUMsT0FBTzFFLENBQVAsRUFBVUosU0FBVixFQUFmO0FBQ0EsUUFBSThFLE9BQU8xRSxDQUFQLEVBQVV5TCxHQUFWLENBQWMsZUFBZCxFQUErQjFLLE9BQS9CLENBQXVDb0YsUUFBdkMsTUFBcUQsQ0FBQyxDQUExRCxFQUE2RDtBQUMzRCxhQUFPNUQsTUFBUDtBQUNEO0FBQ0Y7QUFDRixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JoQkQsSUFBSW1KLFdBQVcsQ0FBZjtBQUNBLElBQUlDLFFBQVE7QUFDWDdJLGFBQVM7QUFDUjhJLGtCQUFVLElBREY7QUFFUjVHLGNBQU0sTUFGRTtBQUdSNkcsZ0JBQVEsQ0FDUCxDQURPLENBSEE7QUFNUkMsYUFBSyxnREFORztBQU9SQyxpQkFBUztBQVBELEtBREU7QUFVWEMsVUFBTTtBQUNMaEgsY0FBTSxRQUREO0FBRUw4RyxhQUFLLHNDQUZBO0FBR0xDLGlCQUFTO0FBSEosS0FWSztBQWVYRSxjQUFVO0FBQ1RqSCxjQUFNLEdBREc7QUFFVDhHLGFBQUs7QUFGSSxLQWZDO0FBbUJYbkYsWUFBUTtBQUNQM0IsY0FBTSxPQURDO0FBRVBrSCxlQUFPLFFBRkE7QUFHUEosYUFBSyw2S0FIRTtBQUlQQyxpQkFBUyxDQUNSLENBQUMsT0FETyxFQUVSLE9BRlE7QUFKRixLQW5CRztBQTRCWDFHLFVBQU07QUFDTEwsY0FBTSxRQUREO0FBRUw4RyxhQUFLLGlKQUZBO0FBR0xDLGlCQUFTO0FBSEosS0E1Qks7QUFpQ1hJLGFBQVM7QUFDUm5ILGNBQU0sUUFERTtBQUVSLG1CQUFXLENBRkg7QUFHUm9ILGdCQUFRLEdBSEE7QUFJUkMsZUFBTyxTQUpDO0FBS1JQLGFBQUssNFFBTEc7QUFNUkMsaUJBQVM7QUFORCxLQWpDRTtBQXlDWE8sV0FBTztBQUNOdEgsY0FBTSxRQURBO0FBRU4sbUJBQVcsQ0FGTDtBQUdOcUgsZUFBTyxTQUhEO0FBSU5QLGFBQUssa1NBSkM7QUFLTkMsaUJBQVM7QUFMSCxLQXpDSTtBQWdEWFEsV0FBTztBQUNOdkgsY0FBTSxPQURBO0FBRU44RyxhQUFLLDBCQUZDO0FBR05DLGlCQUFTO0FBQ1JTLG9CQUFRLFVBREE7QUFFUkMsbUJBQU8sT0FGQztBQUdSQyx1QkFBVztBQUhIO0FBSEgsS0FoREk7QUF5RFgzRSxhQUFTO0FBQ1I2RCxrQkFBVSxJQURGO0FBRVI1RyxjQUFNLFNBRkU7QUFHUjhHLGFBQUssNkJBSEc7QUFJUkMsaUJBQVM7QUFDUiw4QkFBa0I7QUFDakIvRyxzQkFBTSxRQURXO0FBRWpCaEQscUJBQUs7QUFGWTtBQURWO0FBSkQsS0F6REU7QUFvRVhtQixZQUFRO0FBQ1A2QixjQUFNLFFBREM7QUFFUDhHLGFBQUssNGFBRkU7QUFHUEMsaUJBQVM7QUFIRixLQXBFRztBQXlFWFksWUFBUTtBQUNQM0gsY0FBTSxRQURDO0FBRVA4RyxhQUFLLCtVQUZFO0FBR1BDLGlCQUFTO0FBSEYsS0F6RUc7QUE4RVhhLGdCQUFZO0FBQ1g1SCxjQUFNLFlBREs7QUFFWDhHLGFBQUsscVJBRk07QUFHWEMsaUJBQVM7QUFDUmMsc0JBQVUsR0FERjtBQUVSQyxtQkFBTztBQUZDO0FBSEUsS0E5RUQ7QUFzRlhwSSxZQUFRO0FBQ1BrSCxrQkFBVSxJQURIO0FBRVA1RyxjQUFNLE9BRkM7QUFHUGtILGVBQU8sT0FIQTtBQUlQSixhQUFLLGtEQUpFO0FBS1BDLGlCQUFTLENBQ1I7QUFDQ3BILGdCQUFJLE9BREw7QUFFQ3BDLG9CQUFRLGdCQUZUO0FBR0MsNEJBQWdCLE9BSGpCO0FBSUN5QyxrQkFBTSxNQUpQO0FBS0NJLG1CQUFPO0FBQ04sOEJBQWM7QUFEUjtBQUxSLFNBRFE7QUFMRjtBQXRGRyxDQUFaO0FBd0dBLElBQUkyQyxVQUFVO0FBQ2IsU0FBSztBQUNKL0MsY0FBTSxRQURGO0FBRUo4RyxhQUFLO0FBRkQ7QUFEUSxDQUFkO0FBTUEsSUFBSXZKLFNBQVMsQ0FDWixlQURZLEVBRVosZUFGWSxFQUdaLG1CQUhZLEVBSVosZ0JBSlksRUFLWixjQUxZLEVBTVosY0FOWSxDQUFiO0FBUUEsSUFBSXdLLGdCQUFnQjtBQUNuQi9ILFVBQU07QUFDTDRHLGtCQUFVLElBREw7QUFFTDVHLGNBQU0sTUFGRDtBQUdMNkcsZ0JBQVE7QUFDUG1CLG9CQUFRO0FBQ1BsQixxQkFBSztBQURFO0FBREQsU0FISDtBQVFMQSxhQUFLO0FBUkEsS0FEYTtBQVduQjlKLFNBQUs7QUFDSmdELGNBQU0sUUFERjtBQUVKOEcsYUFBSztBQUZELEtBWGM7QUFlbkI5RCxXQUFPO0FBQ05oRCxjQUFNLE9BREE7QUFFTmtILGVBQU8sUUFGRDtBQUdOSixhQUFLO0FBSEMsS0FmWTtBQW9CbkJtQixZQUFRO0FBQ1BqSSxjQUFNLE9BREM7QUFFUGtILGVBQU8sUUFGQTtBQUdQN0wsZ0JBQVEsQ0FIRDtBQUlQLG1CQUFXLENBQ1YsQ0FBQyxHQURTLEVBRVYsQ0FBQyxTQUZTLEVBR1YsR0FIVSxFQUlWLFNBSlUsQ0FKSjtBQVVQeUwsYUFBSztBQVZFLEtBcEJXO0FBZ0NuQm9CLFlBQVE7QUFDUGxJLGNBQU0sTUFEQztBQUVQNkcsZ0JBQVE7QUFDUHNCLGlCQUFLO0FBQ0pyQixxQkFBSztBQURELGFBREU7QUFJUHNCLGlCQUFLO0FBQ0p0QixxQkFBSztBQUREO0FBSkUsU0FGRDtBQVVQLG1CQUFXLEtBVko7QUFXUEEsYUFBSztBQVhFLEtBaENXO0FBNkNuQnhELGFBQVM7QUFDUnRELGNBQU0sUUFERTtBQUVSLG1CQUFXLENBRkg7QUFHUjhHLGFBQUs7QUFIRyxLQTdDVTtBQWtEbkIxRCxhQUFTO0FBQ1JwRCxjQUFNLFFBREU7QUFFUixtQkFBVyxFQUZIO0FBR1I4RyxhQUFLO0FBSEcsS0FsRFU7QUF1RG5CakQsaUJBQWE7QUFDWjdELGNBQU0sUUFETTtBQUVaOEcsYUFBSztBQUZPLEtBdkRNO0FBMkRuQnVCLGVBQVc7QUFDVnJJLGNBQU0sV0FESTtBQUVWOEcsYUFBSztBQUZLLEtBM0RRO0FBK0RuQixTQUFLO0FBQ0o5RyxjQUFNLEdBREY7QUFFSjhHLGFBQUs7QUFGRDtBQS9EYyxDQUFwQjtBQW9FQSxJQUFJd0IsZ0JBQWdCO0FBQ25CdEksVUFBTTtBQUNMNEcsa0JBQVUsSUFETDtBQUVMNUcsY0FBTSxNQUZEO0FBR0w2RyxnQkFBUTtBQUNQMEIsb0JBQVE7QUFDUHpCLHFCQUFLO0FBREU7QUFERCxTQUhIO0FBUUxBLGFBQUs7QUFSQSxLQURhO0FBV25COUosU0FBSztBQUNKZ0QsY0FBTSxRQURGO0FBRUo4RyxhQUFLO0FBRkQsS0FYYztBQWVuQjlELFdBQU87QUFDTmhELGNBQU0sT0FEQTtBQUVOa0gsZUFBTyxRQUZEO0FBR05KLGFBQUs7QUFIQyxLQWZZO0FBb0JuQm1CLFlBQVE7QUFDUGpJLGNBQU0sT0FEQztBQUVQa0gsZUFBTyxRQUZBO0FBR1A3TCxnQkFBUSxDQUhEO0FBSVAsbUJBQVcsQ0FDVixDQUFDLEdBRFMsRUFFVixDQUFDLFNBRlMsRUFHVixHQUhVLEVBSVYsU0FKVSxDQUpKO0FBVVB5TCxhQUFLO0FBVkUsS0FwQlc7QUFnQ25CeEQsYUFBUztBQUNSdEQsY0FBTSxRQURFO0FBRVIsbUJBQVcsQ0FGSDtBQUdSOEcsYUFBSztBQUhHLEtBaENVO0FBcUNuQjFELGFBQVM7QUFDUnBELGNBQU0sUUFERTtBQUVSLG1CQUFXLEVBRkg7QUFHUjhHLGFBQUs7QUFIRyxLQXJDVTtBQTBDbkI1RCxjQUFVO0FBQ1RsRCxjQUFNLFFBREc7QUFFVCxtQkFBVyxHQUZGO0FBR1RxSCxlQUFPLFFBSEU7QUFJVFAsYUFBSztBQUpJLEtBMUNTO0FBZ0RuQm9CLFlBQVE7QUFDUGxJLGNBQU0sTUFEQztBQUVQNkcsZ0JBQVE7QUFDUHNCLGlCQUFLO0FBQ0pyQixxQkFBSztBQURELGFBREU7QUFJUHNCLGlCQUFLO0FBQ0p0QixxQkFBSztBQUREO0FBSkUsU0FGRDtBQVVQLG1CQUFXLEtBVko7QUFXUEEsYUFBSztBQVhFLEtBaERXO0FBNkRuQmpELGlCQUFhO0FBQ1o3RCxjQUFNLFFBRE07QUFFWjhHLGFBQUs7QUFGTyxLQTdETTtBQWlFbkIsU0FBSztBQUNKOUcsY0FBTSxHQURGO0FBRUo4RyxhQUFLO0FBRkQ7QUFqRWMsQ0FBcEI7QUFzRUEsSUFBSTBCLG9CQUFvQjtBQUN2QnhJLFVBQU07QUFDTDRHLGtCQUFVLElBREw7QUFFTDVHLGNBQU0sTUFGRDtBQUdMNkcsZ0JBQVE7QUFDUCwwQkFBYztBQUNiQyxxQkFBSztBQURRO0FBRFAsU0FISDtBQVFMQSxhQUFLO0FBUkEsS0FEaUI7QUFXdkI5SixTQUFLO0FBQ0pnRCxjQUFNLFFBREY7QUFFSjhHLGFBQUs7QUFGRCxLQVhrQjtBQWV2QjlELFdBQU87QUFDTmhELGNBQU0sT0FEQTtBQUVOa0gsZUFBTyxRQUZEO0FBR05KLGFBQUs7QUFIQyxLQWZnQjtBQW9CdkJtQixZQUFRO0FBQ1BqSSxjQUFNLE9BREM7QUFFUGtILGVBQU8sUUFGQTtBQUdQN0wsZ0JBQVEsQ0FIRDtBQUlQLG1CQUFXLENBQ1YsQ0FBQyxHQURTLEVBRVYsQ0FBQyxTQUZTLEVBR1YsR0FIVSxFQUlWLFNBSlUsQ0FKSjtBQVVQeUwsYUFBSztBQVZFLEtBcEJlO0FBZ0N2QnhELGFBQVM7QUFDUnRELGNBQU0sUUFERTtBQUVSLG1CQUFXLENBRkg7QUFHUjhHLGFBQUs7QUFIRyxLQWhDYztBQXFDdkIxRCxhQUFTO0FBQ1JwRCxjQUFNLFFBREU7QUFFUixtQkFBVyxFQUZIO0FBR1I4RyxhQUFLO0FBSEcsS0FyQ2M7QUEwQ3ZCNUQsY0FBVTtBQUNUbEQsY0FBTSxRQURHO0FBRVQsbUJBQVcsR0FGRjtBQUdUcUgsZUFBTyxRQUhFO0FBSVRQLGFBQUs7QUFKSSxLQTFDYTtBQWdEdkJqRCxpQkFBYTtBQUNaN0QsY0FBTSxRQURNO0FBRVo4RyxhQUFLO0FBRk8sS0FoRFU7QUFvRHZCMkIsY0FBVTtBQUNUekksY0FBTSxNQURHO0FBRVQ2RyxnQkFBUTtBQUNQNkIsdUJBQVc7QUFDVjVCLHFCQUFLO0FBREssYUFESjtBQUlQNkIsb0JBQVE7QUFDUDdCLHFCQUFLO0FBREU7QUFKRCxTQUZDO0FBVVQsbUJBQVcsUUFWRjtBQVdUQSxhQUFLO0FBWEksS0FwRGE7QUFpRXZCLFNBQUs7QUFDSjlHLGNBQU0sR0FERjtBQUVKOEcsYUFBSztBQUZEO0FBakVrQixDQUF4QjtBQXNFQSxJQUFJOEIsaUJBQWlCO0FBQ3BCNUksVUFBTTtBQUNMNEcsa0JBQVUsSUFETDtBQUVMNUcsY0FBTSxNQUZEO0FBR0w2RyxnQkFBUTtBQUNQZ0MscUJBQVM7QUFDUi9CLHFCQUFLO0FBREc7QUFERixTQUhIO0FBUUxBLGFBQUs7QUFSQSxLQURjO0FBV3BCdEIsVUFBTTtBQUNMeEYsY0FBTSxHQUREO0FBRUw4RyxhQUFLO0FBRkEsS0FYYztBQWVwQjFELGFBQVM7QUFDUnBELGNBQU0sUUFERTtBQUVSLG1CQUFXLEVBRkg7QUFHUjhHLGFBQUs7QUFIRyxLQWZXO0FBb0JwQmpELGlCQUFhO0FBQ1o3RCxjQUFNLFFBRE07QUFFWjhHLGFBQUs7QUFGTyxLQXBCTztBQXdCcEJnQyxZQUFRO0FBQ1A5SSxjQUFNLFFBREM7QUFFUCxtQkFBVyxHQUZKO0FBR1ArSSxpQkFBUyxHQUhGO0FBSVBDLGlCQUFTLENBSkY7QUFLUGxDLGFBQUs7QUFMRSxLQXhCWTtBQStCcEJtQyxlQUFXO0FBQ1ZqSixjQUFNLFFBREk7QUFFVixtQkFBVyxLQUZEO0FBR1Y4RyxhQUFLO0FBSEssS0EvQlM7QUFvQ3BCb0MsYUFBUztBQUNSbEosY0FBTSxTQURFO0FBRVIsbUJBQVcsS0FGSDtBQUdSOEcsYUFBSztBQUhHLEtBcENXO0FBeUNwQnFDLG1CQUFlO0FBQ2RuSixjQUFNLFFBRFE7QUFFZCxtQkFBVyxFQUZHO0FBR2RnSixpQkFBUyxDQUhLO0FBSWRsQyxhQUFLO0FBSlMsS0F6Q0s7QUErQ3BCc0Msb0JBQWdCO0FBQ2ZwSixjQUFNLFFBRFM7QUFFZjhHLGFBQUs7QUFGVSxLQS9DSTtBQW1EcEJ1Qyx1QkFBbUI7QUFDbEJySixjQUFNLEdBRFk7QUFFbEI4RyxhQUFLO0FBRmEsS0FuREM7QUF1RHBCd0MsaUJBQWE7QUFDWnRKLGNBQU0sU0FETTtBQUVaLG1CQUFXLEtBRkM7QUFHWjhHLGFBQUs7QUFITyxLQXZETztBQTREcEJ5QyxnQkFBWTtBQUNYdkosY0FBTSxTQURLO0FBRVgsbUJBQVcsS0FGQTtBQUdYOEcsYUFBSztBQUhNLEtBNURRO0FBaUVwQnVCLGVBQVc7QUFDVnJJLGNBQU0sV0FESTtBQUVWOEcsYUFBSztBQUZLO0FBakVTLENBQXJCO0FBc0VBLElBQUkwQyxlQUFlO0FBQ2xCeEosVUFBTTtBQUNMNEcsa0JBQVUsSUFETDtBQUVMNUcsY0FBTSxNQUZEO0FBR0w2RyxnQkFBUTtBQUNQNEMsbUJBQU87QUFDTjNDLHFCQUFLO0FBREM7QUFEQSxTQUhIO0FBUUxBLGFBQUs7QUFSQSxLQURZO0FBV2xCOUMsVUFBTTtBQUNMNEMsa0JBQVUsSUFETDtBQUVMNUcsY0FBTSxPQUZEO0FBR0xrSCxlQUFPLFFBSEY7QUFJTEosYUFBSztBQUpBLEtBWFk7QUFpQmxCNEMsaUJBQWE7QUFDWjlDLGtCQUFVLElBREU7QUFFWkUsYUFBSywwREFGTztBQUdaOUcsY0FBTSxPQUhNO0FBSVozRSxnQkFBUSxDQUpJO0FBS1o2TCxlQUFPO0FBQ05sSCxrQkFBTSxPQURBO0FBRU4zRSxvQkFBUSxDQUZGO0FBR042TCxtQkFBTyxRQUhEO0FBSU5KLGlCQUFLO0FBSkM7QUFMSztBQWpCSyxDQUFuQjtBQThCQSxJQUFJNkMsZUFBZTtBQUNsQjNKLFVBQU07QUFDTDRHLGtCQUFVLElBREw7QUFFTDVHLGNBQU0sTUFGRDtBQUdMNkcsZ0JBQVE7QUFDUCtDLG1CQUFPO0FBQ045QyxxQkFBSztBQURDO0FBREEsU0FISDtBQVFMQSxhQUFLO0FBUkEsS0FEWTtBQVdsQjlKLFNBQUs7QUFDSjRKLGtCQUFVLElBRE47QUFFSjVHLGNBQU0sUUFGRjtBQUdKOEcsYUFBSztBQUhELEtBWGE7QUFnQmxCNEMsaUJBQWE7QUFDWjlDLGtCQUFVLElBREU7QUFFWkUsYUFBSywwREFGTztBQUdaOUcsY0FBTSxPQUhNO0FBSVozRSxnQkFBUSxDQUpJO0FBS1o2TCxlQUFPO0FBQ05sSCxrQkFBTSxPQURBO0FBRU4zRSxvQkFBUSxDQUZGO0FBR042TCxtQkFBTyxRQUhEO0FBSU5KLGlCQUFLO0FBSkM7QUFMSztBQWhCSyxDQUFuQjtBQTZCQSxJQUFJbEssUUFBUTtBQUNYK0MsUUFBSTtBQUNISyxjQUFNLFFBREg7QUFFSDhHLGFBQUssb0JBRkY7QUFHSEYsa0JBQVU7QUFIUCxLQURPO0FBTVg1RyxVQUFNO0FBQ0xBLGNBQU0sTUFERDtBQUVMNkcsZ0JBQVE7QUFDUGdELGtCQUFNO0FBQ0wvQyxxQkFBSyxtREFEQTtBQUVMLCtCQUFlO0FBQ2QsMkNBQXVCO0FBQ3RCZ0QsNEJBQUksUUFEa0I7QUFFdEJDLGlDQUFTLE9BRmE7QUFHdEJDLDZCQUFLLE9BSGlCO0FBSXRCQywrQkFBTztBQUplO0FBRFQ7QUFGVixhQURDO0FBWVBDLGtCQUFNO0FBQ0xwRCxxQkFBSyxpQkFEQTtBQUVMLCtCQUFlO0FBQ2QsMkNBQXVCO0FBQ3RCZ0QsNEJBQUksUUFEa0I7QUFFdEJDLGlDQUFTLE9BRmE7QUFHdEJDLDZCQUFLLE9BSGlCO0FBSXRCQywrQkFBTztBQUplO0FBRFQ7QUFGVixhQVpDO0FBdUJQRSxvQkFBUTtBQUNQckQscUJBQUssMEJBREU7QUFFUCwrQkFBZTtBQUNkLDJDQUF1QjtBQUN0QmdELDRCQUFJLFFBRGtCO0FBRXRCQyxpQ0FBUyxPQUZhO0FBR3RCQyw2QkFBSyxPQUhpQjtBQUl0QkMsK0JBQU87QUFKZTtBQURUO0FBRlIsYUF2QkQ7QUFrQ1BHLG9CQUFRO0FBQ1B0RCxxQkFBSyxrQkFERTtBQUVQLCtCQUFlO0FBQ2QsMkNBQXVCO0FBQ3RCZ0QsNEJBQUksUUFEa0I7QUFFdEJDLGlDQUFTLE9BRmE7QUFHdEJDLDZCQUFLLE9BSGlCO0FBSXRCQywrQkFBTztBQUplO0FBRFQ7QUFGUixhQWxDRDtBQTZDUEkscUJBQVM7QUFDUnZELHFCQUFLLFlBREc7QUFFUiwrQkFBZTtBQUNkLDJDQUF1QjtBQUN0QmdELDRCQUFJLFFBRGtCO0FBRXRCQyxpQ0FBUyxPQUZhO0FBR3RCQyw2QkFBSyxPQUhpQjtBQUl0QkMsK0JBQU87QUFKZTtBQURUO0FBRlAsYUE3Q0Y7QUF3RFAsOEJBQWtCO0FBQ2pCbkQscUJBQUssMkJBRFk7QUFFakIsK0JBQWU7QUFDZCwyQ0FBdUI7QUFDdEJnRCw0QkFBSSxRQURrQjtBQUV0QkMsaUNBQVMsT0FGYTtBQUd0QkMsNkJBQUssT0FIaUI7QUFJdEJDLCtCQUFPO0FBSmU7QUFEVDtBQUZFLGFBeERYO0FBbUVQMUIsb0JBQVE7QUFDUHpCLHFCQUFLLGdEQURFO0FBRVAsK0JBQWU7QUFDZCwyQ0FBdUI7QUFDdEJnRCw0QkFBSSxRQURrQjtBQUV0QkMsaUNBQVMsT0FGYTtBQUd0QkMsNkJBQUssT0FIaUI7QUFJdEJDLCtCQUFPO0FBSmU7QUFEVDtBQUZSLGFBbkVEO0FBOEVQSyx1QkFBVztBQUNWeEQscUJBQUsscUpBREs7QUFFViwrQkFBZTtBQUNkLDJDQUF1QjtBQUN0QmdELDRCQUFJLFFBRGtCO0FBRXRCQyxpQ0FBUyxPQUZhO0FBR3RCQyw2QkFBSyxPQUhpQjtBQUl0QkMsK0JBQU87QUFKZTtBQURUO0FBRkwsYUE5RUo7QUF5RlBsSyx3QkFBWTtBQUNYK0cscUJBQUssNkNBRE07QUFFWCwrQkFBZTtBQUNkLDJDQUF1QjtBQUN0QmdELDRCQUFJLFFBRGtCO0FBRXRCQyxpQ0FBUyxPQUZhO0FBR3RCQyw2QkFBSyxPQUhpQjtBQUl0QkMsK0JBQU87QUFKZTtBQURUO0FBRko7QUF6RkwsU0FGSDtBQXVHTG5ELGFBQUssK0JBdkdBO0FBd0dMRixrQkFBVTtBQXhHTCxLQU5LO0FBZ0hYSyxjQUFVO0FBQ1RqSCxjQUFNLEdBREc7QUFFVDhHLGFBQUs7QUFGSSxLQWhIQztBQW9IWHZKLFlBQVE7QUFDUHlDLGNBQU0sUUFEQztBQUVQOEcsYUFBSztBQUZFLEtBcEhHO0FBd0hYLG9CQUFnQjtBQUNmOUcsY0FBTSxRQURTO0FBRWY4RyxhQUFLO0FBRlUsS0F4SEw7QUE0SFh4RCxhQUFTO0FBQ1J0RCxjQUFNLFFBREU7QUFFUmdKLGlCQUFTLENBRkQ7QUFHUkQsaUJBQVMsRUFIRDtBQUlSakMsYUFBSztBQUpHLEtBNUhFO0FBa0lYMUQsYUFBUztBQUNScEQsY0FBTSxRQURFO0FBRVJnSixpQkFBUyxDQUZEO0FBR1JELGlCQUFTLEVBSEQ7QUFJUmpDLGFBQUs7QUFKRyxLQWxJRTtBQXdJWHlELFlBQVE7QUFDUHZLLGNBQU0sUUFEQztBQUVQOEcsYUFBSztBQUZFLEtBeElHO0FBNElYakssWUFBUTtBQUNQbUQsY0FBTSxRQURDO0FBRVA4RyxhQUFLO0FBRkUsS0E1SUc7QUFnSlgxRyxXQUFPO0FBQ05KLGNBQU0sT0FEQTtBQUVOOEcsYUFBSztBQUZDO0FBaEpJLENBQVo7QUFxSkEsSUFBSWpLLFNBQVMsQ0FDWixhQURZLEVBRVosYUFGWSxFQUdaLGVBSFksRUFJWixnQkFKWSxFQUtaLHVCQUxZLEVBTVosZUFOWSxFQU9aLGVBUFksRUFRWixrQkFSWSxFQVNaLG1CQVRZLENBQWI7QUFXQSxJQUFJMk4sb0JBQW9CO0FBQ3ZCNUosZ0JBQVk7QUFDWFosY0FBTSxNQURLO0FBRVg2RyxnQkFBUTtBQUNQNUMscUJBQVM7QUFDUjZDLHFCQUFLO0FBREcsYUFERjtBQUlQMkQsa0JBQU07QUFDTDNELHFCQUFLO0FBREE7QUFKQyxTQUZHO0FBVVgsbUJBQVcsU0FWQTtBQVdYQSxhQUFLLGtDQVhNO0FBWVgsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVpKO0FBb0JYLHlCQUFpQjtBQXBCTjtBQURXLENBQXhCO0FBd0JBLElBQUlTLGNBQWM7QUFDakIscUJBQWlCO0FBQ2hCMUssY0FBTSxRQURVO0FBRWhCOEcsYUFBSywwSUFGVztBQUdoQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJO0FBRGtCLGFBRFQ7QUFJZCxtQ0FBdUI7QUFDdEJBLG9CQUFJO0FBRGtCO0FBSlQsU0FIQztBQVdoQmEsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0FYSTtBQWtCaEIseUJBQWlCO0FBbEJELEtBREE7QUFxQmpCakssZ0JBQVk7QUFDWFosY0FBTSxNQURLO0FBRVg2RyxnQkFBUTtBQUNQNUMscUJBQVM7QUFDUjZDLHFCQUFLO0FBREcsYUFERjtBQUlQMkQsa0JBQU07QUFDTDNELHFCQUFLO0FBREE7QUFKQyxTQUZHO0FBVVgsbUJBQVcsU0FWQTtBQVdYQSxhQUFLLGtDQVhNO0FBWVgsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVpKO0FBb0JYLHlCQUFpQjtBQXBCTjtBQXJCSyxDQUFsQjtBQTRDQSxJQUFJYSxnQkFBZ0I7QUFDbkIsdUJBQW1CO0FBQ2xCOUssY0FBTSxRQURZO0FBRWxCOEcsYUFBSywwSUFGYTtBQUdsQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJO0FBRGtCLGFBRFQ7QUFJZCxtQ0FBdUI7QUFDdEJBLG9CQUFJO0FBRGtCO0FBSlQsU0FIRztBQVdsQmEsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0FYTTtBQWtCbEIseUJBQWlCO0FBbEJDLEtBREE7QUFxQm5CakssZ0JBQVk7QUFDWFosY0FBTSxNQURLO0FBRVg2RyxnQkFBUTtBQUNQNUMscUJBQVM7QUFDUjZDLHFCQUFLO0FBREcsYUFERjtBQUlQMkQsa0JBQU07QUFDTDNELHFCQUFLO0FBREE7QUFKQyxTQUZHO0FBVVgsbUJBQVcsU0FWQTtBQVdYQSxhQUFLLGtDQVhNO0FBWVgsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVpKO0FBb0JYLHlCQUFpQjtBQXBCTjtBQXJCTyxDQUFwQjtBQTRDQSxJQUFJYyxpQkFBaUI7QUFDcEJuSyxnQkFBWTtBQUNYWixjQUFNLE1BREs7QUFFWDZHLGdCQUFRO0FBQ1A1QyxxQkFBUztBQUNSNkMscUJBQUs7QUFERyxhQURGO0FBSVAyRCxrQkFBTTtBQUNMM0QscUJBQUs7QUFEQTtBQUpDLFNBRkc7QUFVWCxtQkFBVyxTQVZBO0FBV1hBLGFBQUssa0NBWE07QUFZWCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBWko7QUFvQlgseUJBQWlCO0FBcEJOO0FBRFEsQ0FBckI7QUF3QkEsSUFBSWUsY0FBYztBQUNqQixnQkFBWTtBQUNYaEwsY0FBTSxNQURLO0FBRVg2RyxnQkFBUTtBQUNQb0Usa0JBQU07QUFDTG5FLHFCQUFLO0FBREEsYUFEQztBQUlQb0UsbUJBQU87QUFDTnBFLHFCQUFLO0FBREMsYUFKQTtBQU9QcUUsb0JBQVE7QUFDUHJFLHFCQUFLO0FBREU7QUFQRCxTQUZHO0FBYVgsbUJBQVcsTUFiQTtBQWNYQSxhQUFLLDhCQWRNO0FBZVgsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQWZKO0FBdUJYVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBdkJEO0FBNkJYLHlCQUFpQjtBQTdCTixLQURLO0FBZ0NqQixpQkFBYTtBQUNaN0ssY0FBTSxNQURNO0FBRVo2RyxnQkFBUTtBQUNQdUUsbUJBQU87QUFDTnRFLHFCQUFLO0FBREMsYUFEQTtBQUlQb0UsbUJBQU87QUFDTnBFLHFCQUFLO0FBREMsYUFKQTtBQU9QdUUsbUJBQU87QUFDTnZFLHFCQUFLO0FBREM7QUFQQSxTQUZJO0FBYVosbUJBQVcsT0FiQztBQWNaQSxhQUFLLG9DQWRPO0FBZVosdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FmSDtBQTZCWlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0E3QkE7QUFvQ1oseUJBQWlCO0FBcENMLEtBaENJO0FBc0VqQix3QkFBb0I7QUFDbkI3SyxjQUFNLFFBRGE7QUFFbkIsbUJBQVcsQ0FGUTtBQUduQjhHLGFBQUssNEVBSGM7QUFJbkJ3RSxrQkFBVSxDQUNUO0FBQ0MseUJBQWE7QUFEZCxTQURTLENBSlM7QUFTbkIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVRJO0FBaUJuQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWpCTztBQXVCbkIseUJBQWlCO0FBdkJFLEtBdEVIO0FBK0ZqQix3QkFBb0I7QUFDbkI3SyxjQUFNLFFBRGE7QUFFbkIsbUJBQVcsSUFGUTtBQUduQjhHLGFBQUssOEVBSGM7QUFJbkJ3RSxrQkFBVSxDQUNUO0FBQ0MseUJBQWE7QUFEZCxTQURTLENBSlM7QUFTbkIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVRJO0FBaUJuQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWpCTztBQXVCbkIseUJBQWlCO0FBdkJFLEtBL0ZIO0FBd0hqQixxQkFBaUI7QUFDaEI3SyxjQUFNLFFBRFU7QUFFaEI4RyxhQUFLLDBJQUZXO0FBR2hCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCZ0Qsb0JBQUk7QUFEa0IsYUFEVDtBQUlkLG1DQUF1QjtBQUN0QkEsb0JBQUk7QUFEa0I7QUFKVCxTQUhDO0FBV2hCYSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQVhJO0FBa0JoQix5QkFBaUI7QUFsQkQsS0F4SEE7QUE0SWpCakssZ0JBQVk7QUFDWFosY0FBTSxNQURLO0FBRVg2RyxnQkFBUTtBQUNQNUMscUJBQVM7QUFDUjZDLHFCQUFLO0FBREcsYUFERjtBQUlQMkQsa0JBQU07QUFDTDNELHFCQUFLO0FBREE7QUFKQyxTQUZHO0FBVVgsbUJBQVcsU0FWQTtBQVdYQSxhQUFLLGtDQVhNO0FBWVgsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVpKO0FBb0JYLHlCQUFpQjtBQXBCTjtBQTVJSyxDQUFsQjtBQW1LQSxJQUFJc0IsZ0JBQWdCO0FBQ25CLHdCQUFvQjtBQUNuQnZMLGNBQU0sTUFEYTtBQUVuQjZHLGdCQUFRO0FBQ1AyRSxtQkFBTztBQUNOMUUscUJBQUs7QUFEQyxhQURBO0FBSVBvRCxrQkFBTTtBQUNMcEQscUJBQUs7QUFEQSxhQUpDO0FBT1AsMkJBQWU7QUFDZEEscUJBQUs7QUFEUztBQVBSLFNBRlc7QUFhbkIsbUJBQVcsT0FiUTtBQWNuQkEsYUFBSywyQ0FkYztBQWVuQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQWZJO0FBNkJuQlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQTdCTztBQW1DbkIseUJBQWlCO0FBbkNFLEtBREQ7QUFzQ25CLHNCQUFrQjtBQUNqQjdLLGNBQU0sUUFEVztBQUVqQixtQkFBVyxHQUZNO0FBR2pCZ0osaUJBQVMsQ0FIUTtBQUlqQjNCLGVBQU8sUUFKVTtBQUtqQlAsYUFBSyxzQ0FMWTtBQU1qQndFLGtCQUFVLENBQ1Q7QUFDQyxnQ0FBb0I7QUFEckIsU0FEUyxDQU5PO0FBV2pCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FYRTtBQW1CakJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FuQks7QUF5QmpCLHlCQUFpQjtBQXpCQSxLQXRDQztBQWlFbkIsMEJBQXNCO0FBQ3JCN0ssY0FBTSxTQURlO0FBRXJCLG1CQUFXLEtBRlU7QUFHckI4RyxhQUFLLDRhQUhnQjtBQUlyQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBSk07QUFZckJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FaUztBQWtCckIseUJBQWlCO0FBbEJJLEtBakVIO0FBcUZuQix1QkFBbUI7QUFDbEI3SyxjQUFNLFFBRFk7QUFFbEI4RyxhQUFLLDJZQUZhO0FBR2xCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCZ0Qsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLFFBSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxRQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBSEc7QUFpQmxCVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQWpCTTtBQXdCbEIseUJBQWlCO0FBeEJDLEtBckZBO0FBK0duQixzQkFBa0I7QUFDakI3SyxjQUFNLE1BRFc7QUFFakI2RyxnQkFBUTtBQUNQNEUsa0JBQU07QUFDTDNFLHFCQUFLO0FBREEsYUFEQztBQUlQLDBCQUFjO0FBQ2JBLHFCQUFLO0FBRFEsYUFKUDtBQU9Qdkosb0JBQVE7QUFDUHVKLHFCQUFLO0FBREU7QUFQRCxTQUZTO0FBYWpCLG1CQUFXLE1BYk07QUFjakJBLGFBQUssZ0ZBZFk7QUFlakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQWZFO0FBdUJqQlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQXZCSztBQTZCakIseUJBQWlCO0FBN0JBLEtBL0dDO0FBOEluQiwwQkFBc0I7QUFDckI3SyxjQUFNLFNBRGU7QUFFckIsbUJBQVcsS0FGVTtBQUdyQjhHLGFBQUssNEZBSGdCO0FBSXJCd0Usa0JBQVUsQ0FDVCxZQURTLENBSlc7QUFPckIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVBNO0FBZXJCVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZlM7QUFxQnJCLHlCQUFpQjtBQXJCSSxLQTlJSDtBQXFLbkIsNkJBQXlCO0FBQ3hCN0ssY0FBTSxTQURrQjtBQUV4QixtQkFBVyxLQUZhO0FBR3hCOEcsYUFBSywyRUFIbUI7QUFJeEJ3RSxrQkFBVSxDQUNULFlBRFMsQ0FKYztBQU94Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBUFM7QUFleEJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmWTtBQXFCeEIseUJBQWlCO0FBckJPLEtBcktOO0FBNExuQixxQkFBaUI7QUFDaEI3SyxjQUFNLFNBRFU7QUFFaEIsbUJBQVcsS0FGSztBQUdoQjhHLGFBQUssK0hBSFc7QUFJaEJ3RSxrQkFBVSxDQUNULFlBRFMsRUFFVCxZQUZTLENBSk07QUFRaEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVJDO0FBZ0JoQlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWhCSTtBQXNCaEIseUJBQWlCO0FBdEJELEtBNUxFO0FBb05uQiwrQkFBMkI7QUFDMUI3SyxjQUFNLE1BRG9CO0FBRTFCNkcsZ0JBQVE7QUFDUG5MLGlCQUFLO0FBQ0pvTCxxQkFBSztBQURELGFBREU7QUFJUDRFLHNCQUFVO0FBQ1Q1RSxxQkFBSztBQURJLGFBSkg7QUFPUDJFLGtCQUFNO0FBQ0wzRSxxQkFBSztBQURBO0FBUEMsU0FGa0I7QUFhMUIsbUJBQVcsTUFiZTtBQWMxQkEsYUFBSyxvRkFkcUI7QUFlMUJ3RSxrQkFBVSxDQUNULFlBRFMsQ0FmZ0I7QUFrQjFCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCw0QkFBZ0I7QUFDZkgsb0JBQUksUUFEVztBQUVmQyx5QkFBUyxPQUZNO0FBR2ZDLHFCQUFLLE9BSFU7QUFJZkMsdUJBQU87QUFKUTtBQVBGLFNBbEJXO0FBZ0MxQlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWhDYztBQXNDMUIseUJBQWlCO0FBdENTLEtBcE5SO0FBNFBuQixpQkFBYTtBQUNaN0ssY0FBTSxRQURNO0FBRVosbUJBQVcsQ0FGQztBQUdaZ0osaUJBQVMsQ0FIRztBQUlaM0IsZUFBTyxrQ0FKSztBQUtaUCxhQUFLLGtOQUxPO0FBTVp3RSxrQkFBVSxDQUNULFlBRFMsQ0FORTtBQVNaLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBVEg7QUF1QlpVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBdkJBO0FBOEJaLHlCQUFpQjtBQTlCTCxLQTVQTTtBQTRSbkIscUJBQWlCO0FBQ2hCN0ssY0FBTSxNQURVO0FBRWhCNkcsZ0JBQVE7QUFDUDRELGtCQUFNO0FBQ0wzRCxxQkFBSztBQURBLGFBREM7QUFJUDZFLG1CQUFPO0FBQ043RSxxQkFBSztBQURDLGFBSkE7QUFPUDhFLG9CQUFRO0FBQ1A5RSxxQkFBSztBQURFLGFBUEQ7QUFVUCtFLGtCQUFNO0FBQ0wvRSxxQkFBSztBQURBO0FBVkMsU0FGUTtBQWdCaEIsbUJBQVcsTUFoQks7QUFpQmhCQSxhQUFLLG9EQWpCVztBQWtCaEJ3RSxrQkFBVSxDQUNULFlBRFMsRUFFVCxZQUZTLENBbEJNO0FBc0JoQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBdEJDO0FBOEJoQlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQTlCSTtBQW9DaEIseUJBQWlCO0FBcENELEtBNVJFO0FBa1VuQiw2QkFBeUI7QUFDeEI3SyxjQUFNLE9BRGtCO0FBRXhCa0gsZUFBTyxRQUZpQjtBQUd4QjdMLGdCQUFRLENBSGdCO0FBSXhCLG1CQUFXLENBQ1YsQ0FEVSxFQUVWLENBRlUsRUFHVixDQUhVLEVBSVYsQ0FKVSxDQUphO0FBVXhCZ00sZUFBTyxRQVZpQjtBQVd4QlAsYUFBSyw4SEFYbUI7QUFZeEJ3RSxrQkFBVSxDQUNULFlBRFMsRUFFVCxZQUZTLEVBR1Q7QUFDQyw2QkFBaUIsQ0FDaEIsTUFEZ0IsRUFFaEIsT0FGZ0IsRUFHaEIsUUFIZ0I7QUFEbEIsU0FIUyxDQVpjO0FBdUJ4Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBdkJTO0FBK0J4QlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQS9CWTtBQXFDeEIseUJBQWlCO0FBckNPLEtBbFVOO0FBeVduQixrQkFBYztBQUNiN0ssY0FBTSxlQURPO0FBRWI4RyxhQUFLLGlFQUZRO0FBR2JnRixnQkFBUSxJQUhLO0FBSWIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJoQyxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FKRjtBQWtCYlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0FsQkM7QUF5QmIseUJBQWlCO0FBekJKLEtBeldLO0FBb1luQixtQkFBZTtBQUNkN0ssY0FBTSxRQURRO0FBRWQsbUJBQVcsQ0FGRztBQUdkb0gsZ0JBQVEsR0FITTtBQUlkQyxlQUFPLFNBSk87QUFLZFAsYUFBSyw2QkFMUztBQU1kd0Usa0JBQVUsQ0FDVCxZQURTLENBTkk7QUFTZCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVREO0FBdUJkVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQXZCRTtBQThCZCx5QkFBaUI7QUE5QkgsS0FwWUk7QUFvYW5CLG9CQUFnQjtBQUNmN0ssY0FBTSxRQURTO0FBRWYsbUJBQVcsQ0FGSTtBQUdmZ0osaUJBQVMsQ0FITTtBQUlmM0IsZUFBTyxRQUpRO0FBS2ZQLGFBQUssZ0dBTFU7QUFNZndFLGtCQUFVLENBQ1QsWUFEUyxDQU5LO0FBU2YsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVRBO0FBaUJmVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBakJHO0FBdUJmLHlCQUFpQjtBQXZCRixLQXBhRztBQTZibkIseUJBQXFCO0FBQ3BCN0ssY0FBTSxTQURjO0FBRXBCLG1CQUFXLEtBRlM7QUFHcEI4RyxhQUFLLGlGQUhlO0FBSXBCd0Usa0JBQVUsQ0FDVCxZQURTLEVBRVQ7QUFDQyx1Q0FBMkI7QUFENUIsU0FGUyxFQUtUO0FBQ0MsZ0NBQW9CLENBQ25CLE1BRG1CLEVBRW5CLGFBRm1CO0FBRHJCLFNBTFMsQ0FKVTtBQWdCcEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQWhCSztBQXdCcEJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0F4QlE7QUE4QnBCLHlCQUFpQjtBQTlCRyxLQTdiRjtBQTZkbkIsbUJBQWU7QUFDZDdLLGNBQU0sT0FEUTtBQUVka0gsZUFBTyxRQUZPO0FBR2Q3TCxnQkFBUSxDQUhNO0FBSWQsbUJBQVcsQ0FDVixDQURVLEVBRVYsQ0FGVSxDQUpHO0FBUWR5TCxhQUFLLHNUQVJTO0FBU2R3RSxrQkFBVSxDQUNULFlBRFMsQ0FUSTtBQVlkLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBWkQ7QUEwQmRVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBMUJFO0FBaUNkLHlCQUFpQjtBQWpDSCxLQTdkSTtBQWdnQm5CLG1CQUFlO0FBQ2Q3SyxjQUFNLE1BRFE7QUFFZDZHLGdCQUFRO0FBQ1BsRixvQkFBUTtBQUNQbUYscUJBQUs7QUFERSxhQUREO0FBSVBpRixrQkFBTTtBQUNMakYscUJBQUs7QUFEQSxhQUpDO0FBT1BrRixtQkFBTztBQUNObEYscUJBQUs7QUFEQyxhQVBBO0FBVVBtRixpQkFBSztBQUNKbkYscUJBQUs7QUFERCxhQVZFO0FBYVBvRixvQkFBUTtBQUNQcEYscUJBQUs7QUFERSxhQWJEO0FBZ0JQLHdCQUFZO0FBQ1hBLHFCQUFLO0FBRE0sYUFoQkw7QUFtQlAseUJBQWE7QUFDWkEscUJBQUs7QUFETyxhQW5CTjtBQXNCUCwyQkFBZTtBQUNkQSxxQkFBSztBQURTLGFBdEJSO0FBeUJQLDRCQUFnQjtBQUNmQSxxQkFBSztBQURVO0FBekJULFNBRk07QUErQmQsbUJBQVcsUUEvQkc7QUFnQ2RBLGFBQUssZ0RBaENTO0FBaUNkd0Usa0JBQVUsQ0FDVCxZQURTLENBakNJO0FBb0NkLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBcENEO0FBa0RkVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQWxERTtBQXlEZCx5QkFBaUI7QUF6REgsS0FoZ0JJO0FBMmpCbkIsNEJBQXdCO0FBQ3ZCN0ssY0FBTSxNQURpQjtBQUV2QjZHLGdCQUFRO0FBQ1BuTCxpQkFBSztBQUNKb0wscUJBQUs7QUFERCxhQURFO0FBSVA0RSxzQkFBVTtBQUNUNUUscUJBQUs7QUFESSxhQUpIO0FBT1AyRSxrQkFBTTtBQUNMM0UscUJBQUs7QUFEQTtBQVBDLFNBRmU7QUFhdkIsbUJBQVcsTUFiWTtBQWN2QkEsYUFBSywwQ0Fka0I7QUFldkJ3RSxrQkFBVSxDQUNULFlBRFMsQ0FmYTtBQWtCdkIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQWxCUTtBQTBCdkJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0ExQlc7QUFnQ3ZCLHlCQUFpQjtBQWhDTSxLQTNqQkw7QUE2bEJuQiw0QkFBd0I7QUFDdkI3SyxjQUFNLE1BRGlCO0FBRXZCNkcsZ0JBQVE7QUFDUG5MLGlCQUFLO0FBQ0pvTCxxQkFBSztBQURELGFBREU7QUFJUDRFLHNCQUFVO0FBQ1Q1RSxxQkFBSztBQURJLGFBSkg7QUFPUDJFLGtCQUFNO0FBQ0wzRSxxQkFBSztBQURBO0FBUEMsU0FGZTtBQWF2QixtQkFBVyxNQWJZO0FBY3ZCQSxhQUFLLDBDQWRrQjtBQWV2QndFLGtCQUFVLENBQ1QsWUFEUyxDQWZhO0FBa0J2Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsNEJBQWdCO0FBQ2ZILG9CQUFJLFFBRFc7QUFFZkMseUJBQVMsT0FGTTtBQUdmQyxxQkFBSyxPQUhVO0FBSWZDLHVCQUFPO0FBSlE7QUFQRixTQWxCUTtBQWdDdkJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FoQ1c7QUFzQ3ZCLHlCQUFpQjtBQXRDTSxLQTdsQkw7QUFxb0JuQiwrQkFBMkI7QUFDMUI3SyxjQUFNLE1BRG9CO0FBRTFCNkcsZ0JBQVE7QUFDUG5MLGlCQUFLO0FBQ0pvTCxxQkFBSztBQURELGFBREU7QUFJUDRFLHNCQUFVO0FBQ1Q1RSxxQkFBSztBQURJLGFBSkg7QUFPUDJFLGtCQUFNO0FBQ0wzRSxxQkFBSztBQURBO0FBUEMsU0FGa0I7QUFhMUIsbUJBQVcsTUFiZTtBQWMxQkEsYUFBSyxxSEFkcUI7QUFlMUJ3RSxrQkFBVSxDQUNULFlBRFMsQ0FmZ0I7QUFrQjFCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCw0QkFBZ0I7QUFDZkgsb0JBQUksUUFEVztBQUVmQyx5QkFBUyxPQUZNO0FBR2ZDLHFCQUFLLE9BSFU7QUFJZkMsdUJBQU87QUFKUTtBQVBGLFNBbEJXO0FBZ0MxQlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWhDYztBQXNDMUIseUJBQWlCO0FBdENTLEtBcm9CUjtBQTZxQm5CLGtCQUFjO0FBQ2I3SyxjQUFNLFdBRE87QUFFYixtQkFBVyxFQUZFO0FBR2I4TCxnQkFBUSxJQUhLO0FBSWJoRixhQUFLLGdKQUpRO0FBS2IsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FMRjtBQW1CYlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0FuQkM7QUEwQmIseUJBQWlCO0FBMUJKLEtBN3FCSztBQXlzQm5CLGlCQUFhO0FBQ1o3SyxjQUFNLE9BRE07QUFFWmtILGVBQU8sUUFGSztBQUdaLG1CQUFXLENBQ1YsbUJBRFUsRUFFViwwQkFGVSxDQUhDO0FBT1pKLGFBQUssd0NBUE87QUFRWndFLGtCQUFVLENBQ1QsWUFEUyxDQVJFO0FBV1osdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FYSDtBQXlCWlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0F6QkE7QUFnQ1oseUJBQWlCO0FBaENMLEtBenNCTTtBQTJ1Qm5CLGlCQUFhO0FBQ1o3SyxjQUFNLFFBRE07QUFFWixtQkFBVyxFQUZDO0FBR1pnSixpQkFBUyxDQUhHO0FBSVozQixlQUFPLFFBSks7QUFLWlAsYUFBSyxZQUxPO0FBTVp3RSxrQkFBVSxDQUNULFlBRFMsQ0FORTtBQVNaLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBVEg7QUF1QlpVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBdkJBO0FBOEJaLHlCQUFpQjtBQTlCTCxLQTN1Qk07QUEyd0JuQixzQkFBa0I7QUFDakI3SyxjQUFNLFFBRFc7QUFFakIsbUJBQVcsRUFGTTtBQUdqQmdKLGlCQUFTLENBSFE7QUFJakIzQixlQUFPLEtBSlU7QUFLakJQLGFBQUssMkNBTFk7QUFNakJ3RSxrQkFBVSxDQUNULFlBRFMsQ0FOTztBQVNqQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVRFO0FBdUJqQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0F2Qks7QUE4QmpCLHlCQUFpQjtBQTlCQSxLQTN3QkM7QUEyeUJuQix3QkFBb0I7QUFDbkI3SyxjQUFNLFFBRGE7QUFFbkIsbUJBQVcsR0FGUTtBQUduQnFILGVBQU8sS0FIWTtBQUluQlAsYUFBSyx5Q0FKYztBQUtuQndFLGtCQUFVLENBQ1QsWUFEUyxDQUxTO0FBUW5CLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FSSTtBQWdCbkJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FoQk87QUFzQm5CLHlCQUFpQjtBQXRCRSxLQTN5QkQ7QUFtMEJuQiwyQkFBdUI7QUFDdEI3SyxjQUFNLFFBRGdCO0FBRXRCLG1CQUFXLENBRlc7QUFHdEJxSCxlQUFPLEtBSGU7QUFJdEJQLGFBQUssdUJBSmlCO0FBS3RCd0Usa0JBQVUsQ0FDVCxZQURTLENBTFk7QUFRdEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FSTztBQXNCdEJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBdEJVO0FBNkJ0Qix5QkFBaUI7QUE3QkssS0FuMEJKO0FBazJCbkIsb0JBQWdCO0FBQ2Y3SyxjQUFNLE1BRFM7QUFFZjZHLGdCQUFRO0FBQ1A0RSxrQkFBTTtBQUNMM0UscUJBQUs7QUFEQSxhQURDO0FBSVBpRixrQkFBTTtBQUNMakYscUJBQUs7QUFEQSxhQUpDO0FBT1BuRixvQkFBUTtBQUNQbUYscUJBQUs7QUFERSxhQVBEO0FBVVBrRixtQkFBTztBQUNObEYscUJBQUs7QUFEQztBQVZBLFNBRk87QUFnQmYsbUJBQVcsUUFoQkk7QUFpQmZBLGFBQUssNkJBakJVO0FBa0Jmd0Usa0JBQVUsQ0FDVCxZQURTLENBbEJLO0FBcUJmLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQVBUO0FBYWR3QixrQkFBTTtBQUNMM0Isb0JBQUksUUFEQztBQUVMQyx5QkFBUyxPQUZKO0FBR0xDLHFCQUFLLFFBSEE7QUFJTEMsdUJBQU87QUFKRjtBQWJRLFNBckJBO0FBeUNmVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQXpDRztBQWdEZix5QkFBaUI7QUFoREYsS0FsMkJHO0FBbzVCbkIsMEJBQXNCO0FBQ3JCN0ssY0FBTSxRQURlO0FBRXJCcUgsZUFBTyxLQUZjO0FBR3JCLG1CQUFXLENBSFU7QUFJckJQLGFBQUssMExBSmdCO0FBS3JCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCZ0Qsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLFFBSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxRQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBTE07QUFtQnJCcUIsa0JBQVUsQ0FDVCxZQURTLENBbkJXO0FBc0JyQix5QkFBaUIsYUF0Qkk7QUF1QnJCWCxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRDtBQXZCUyxLQXA1Qkg7QUFtN0JuQiw0QkFBd0I7QUFDdkI3SyxjQUFNLE9BRGlCO0FBRXZCa0gsZUFBTyxNQUZnQjtBQUd2QkwsZ0JBQVE7QUFDUGxGLG9CQUFRO0FBQ1BtRixxQkFBSztBQURFLGFBREQ7QUFJUGlGLGtCQUFNO0FBQ0xqRixxQkFBSztBQURBLGFBSkM7QUFPUGtGLG1CQUFPO0FBQ05sRixxQkFBSztBQURDLGFBUEE7QUFVUG1GLGlCQUFLO0FBQ0puRixxQkFBSztBQURELGFBVkU7QUFhUG9GLG9CQUFRO0FBQ1BwRixxQkFBSztBQURFLGFBYkQ7QUFnQlAsd0JBQVk7QUFDWEEscUJBQUs7QUFETSxhQWhCTDtBQW1CUCx5QkFBYTtBQUNaQSxxQkFBSztBQURPLGFBbkJOO0FBc0JQLDJCQUFlO0FBQ2RBLHFCQUFLO0FBRFMsYUF0QlI7QUF5QlAsNEJBQWdCO0FBQ2ZBLHFCQUFLO0FBRFU7QUF6QlQsU0FIZTtBQWdDdkJ3RSxrQkFBVSxDQUNULFlBRFMsRUFFVDtBQUNDLGdDQUFvQixDQUNuQixPQURtQjtBQURyQixTQUZTLENBaENhO0FBd0N2QnhFLGFBQUssdVlBeENrQjtBQXlDdkIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssUUFIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQXpDUTtBQWlEdkJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FqRFc7QUF1RHZCLHlCQUFpQjtBQXZETSxLQW43Qkw7QUE0K0JuQixtQkFBZTtBQUNkN0ssY0FBTSxNQURRO0FBRWQ2RyxnQkFBUTtBQUNQbEYsb0JBQVE7QUFDUG1GLHFCQUFLO0FBREUsYUFERDtBQUlQaUYsa0JBQU07QUFDTGpGLHFCQUFLO0FBREEsYUFKQztBQU9Qa0YsbUJBQU87QUFDTmxGLHFCQUFLO0FBREMsYUFQQTtBQVVQbUYsaUJBQUs7QUFDSm5GLHFCQUFLO0FBREQsYUFWRTtBQWFQb0Ysb0JBQVE7QUFDUHBGLHFCQUFLO0FBREUsYUFiRDtBQWdCUCx3QkFBWTtBQUNYQSxxQkFBSztBQURNLGFBaEJMO0FBbUJQLHlCQUFhO0FBQ1pBLHFCQUFLO0FBRE8sYUFuQk47QUFzQlAsMkJBQWU7QUFDZEEscUJBQUs7QUFEUyxhQXRCUjtBQXlCUCw0QkFBZ0I7QUFDZkEscUJBQUs7QUFEVTtBQXpCVCxTQUZNO0FBK0JkLG1CQUFXLFFBL0JHO0FBZ0NkQSxhQUFLLGdEQWhDUztBQWlDZHdFLGtCQUFVLENBQ1QsWUFEUyxFQUVUO0FBQ0MsaUJBQUs7QUFETixTQUZTLENBakNJO0FBdUNkLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBdkNEO0FBcURkVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQXJERTtBQTREZCx5QkFBaUI7QUE1REgsS0E1K0JJO0FBMGlDbkIsc0JBQWtCO0FBQ2pCN0ssY0FBTSxRQURXO0FBRWpCLG1CQUFXLEVBRk07QUFHakJxSCxlQUFPLFNBSFU7QUFJakJQLGFBQUssbURBSlk7QUFLakJ3RSxrQkFBVSxDQUNULFlBRFMsRUFFVDtBQUNDLGdDQUFvQixDQUNuQixNQURtQixFQUVuQixhQUZtQjtBQURyQixTQUZTLENBTE87QUFjakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQWRFO0FBc0JqQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQXRCSztBQTRCakIseUJBQWlCO0FBNUJBLEtBMWlDQztBQXdrQ25CLHlCQUFxQjtBQUNwQjdLLGNBQU0sT0FEYztBQUVwQmtILGVBQU8sTUFGYTtBQUdwQkwsZ0JBQVE7QUFDUHNGLHdCQUFZO0FBQ1hyRixxQkFBSztBQURNLGFBREw7QUFJUHNGLHNCQUFVO0FBQ1R0RixxQkFBSztBQURJO0FBSkgsU0FIWTtBQVdwQkEsYUFBSyx5YkFYZTtBQVlwQndFLGtCQUFVLENBQ1QsWUFEUyxFQUVUO0FBQ0MsZ0NBQW9CLENBQ25CLE9BRG1CO0FBRHJCLFNBRlMsQ0FaVTtBQW9CcEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxPQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQXBCSztBQTRCcEJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0E1QlE7QUFrQ3BCLHlCQUFpQjtBQWxDRyxLQXhrQ0Y7QUE0bUNuQixtQkFBZTtBQUNkN0ssY0FBTSxRQURRO0FBRWQsbUJBQVcsQ0FGRztBQUdkb0gsZ0JBQVEsR0FITTtBQUlkQyxlQUFPLFNBSk87QUFLZFAsYUFBSyw2QkFMUztBQU1kd0Usa0JBQVUsQ0FDVCxZQURTLENBTkk7QUFTZCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVREO0FBdUJkVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQXZCRTtBQThCZCx5QkFBaUI7QUE5QkgsS0E1bUNJO0FBNG9DbkIsb0JBQWdCO0FBQ2Y3SyxjQUFNLFFBRFM7QUFFZixtQkFBVyxDQUZJO0FBR2ZnSixpQkFBUyxDQUhNO0FBSWYzQixlQUFPLFFBSlE7QUFLZlAsYUFBSyxnR0FMVTtBQU1md0Usa0JBQVUsQ0FDVCxZQURTLENBTks7QUFTZix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBVEE7QUFpQmZVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FqQkc7QUF1QmYseUJBQWlCO0FBdkJGLEtBNW9DRztBQXFxQ25CLHlCQUFxQjtBQUNwQjdLLGNBQU0sU0FEYztBQUVwQixtQkFBVyxJQUZTO0FBR3BCOEcsYUFBSyw0RkFIZTtBQUlwQndFLGtCQUFVLENBQ1QsWUFEUyxFQUVUO0FBQ0MsdUNBQTJCO0FBRDVCLFNBRlMsRUFLVDtBQUNDLGdDQUFvQixDQUNuQixNQURtQixFQUVuQixhQUZtQjtBQURyQixTQUxTLENBSlU7QUFnQnBCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FoQks7QUF3QnBCVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBeEJRO0FBOEJwQix5QkFBaUI7QUE5QkcsS0FycUNGO0FBcXNDbkIsc0JBQWtCO0FBQ2pCN0ssY0FBTSxNQURXO0FBRWpCNkcsZ0JBQVE7QUFDUDRELGtCQUFNO0FBQ0wzRCxxQkFBSztBQURBLGFBREM7QUFJUHVGLHVCQUFXO0FBQ1Z2RixxQkFBSztBQURLLGFBSko7QUFPUHdGLHVCQUFXO0FBQ1Z4RixxQkFBSztBQURLO0FBUEosU0FGUztBQWFqQixtQkFBVyxNQWJNO0FBY2pCQSxhQUFLLGlGQWRZO0FBZWpCd0Usa0JBQVUsQ0FDVCxZQURTLENBZk87QUFrQmpCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBbEJFO0FBZ0NqQlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0FoQ0s7QUF1Q2pCLHlCQUFpQjtBQXZDQSxLQXJzQ0M7QUE4dUNuQixtQkFBZTtBQUNkN0ssY0FBTSxPQURRO0FBRWQ4RyxhQUFLLDZTQUZTO0FBR2RJLGVBQU8sUUFITztBQUlkRyxlQUFPLEtBSk87QUFLZGhNLGdCQUFRLENBTE07QUFNZCxtQkFBVyxDQUNWLENBRFUsRUFFVixDQUZVLENBTkc7QUFVZGlRLGtCQUFVLENBQ1QsWUFEUyxFQUVUO0FBQ0MsaUJBQUs7QUFETixTQUZTLENBVkk7QUFnQmQsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FoQkQ7QUE4QmRVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBOUJFO0FBcUNkLHlCQUFpQjtBQXJDSCxLQTl1Q0k7QUFxeENuQiwwQkFBc0I7QUFDckI3SyxjQUFNLFNBRGU7QUFFckIsbUJBQVcsS0FGVTtBQUdyQjhHLGFBQUssNEZBSGdCO0FBSXJCd0Usa0JBQVUsQ0FDVCxZQURTLENBSlc7QUFPckIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVBNO0FBZXJCVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZlM7QUFxQnJCLHlCQUFpQjtBQXJCSSxLQXJ4Q0g7QUE0eUNuQiw2QkFBeUI7QUFDeEI3SyxjQUFNLFNBRGtCO0FBRXhCLG1CQUFXLEtBRmE7QUFHeEI4RyxhQUFLLDJFQUhtQjtBQUl4QndFLGtCQUFVLENBQ1QsWUFEUyxDQUpjO0FBT3hCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FQUztBQWV4QlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWZZO0FBcUJ4Qix5QkFBaUI7QUFyQk8sS0E1eUNOO0FBbTBDbkIscUJBQWlCO0FBQ2hCN0ssY0FBTSxTQURVO0FBRWhCLG1CQUFXLEtBRks7QUFHaEI4RyxhQUFLLCtIQUhXO0FBSWhCd0Usa0JBQVUsQ0FDVCxZQURTLEVBRVQsWUFGUyxDQUpNO0FBUWhCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FSQztBQWdCaEJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FoQkk7QUFzQmhCLHlCQUFpQjtBQXRCRCxLQW4wQ0U7QUEyMUNuQmpLLGdCQUFZO0FBQ1haLGNBQU0sTUFESztBQUVYNkcsZ0JBQVE7QUFDUDVDLHFCQUFTO0FBQ1I2QyxxQkFBSztBQURHLGFBREY7QUFJUDJELGtCQUFNO0FBQ0wzRCxxQkFBSztBQURBO0FBSkMsU0FGRztBQVVYLG1CQUFXLFNBVkE7QUFXWEEsYUFBSyxrQ0FYTTtBQVlYLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCZ0Qsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FaSjtBQW9CWCx5QkFBaUI7QUFwQk47QUEzMUNPLENBQXBCO0FBazNDQSxJQUFJc0MsZ0JBQWdCO0FBQ25CM0wsZ0JBQVk7QUFDWFosY0FBTSxNQURLO0FBRVg2RyxnQkFBUTtBQUNQNUMscUJBQVM7QUFDUjZDLHFCQUFLO0FBREcsYUFERjtBQUlQMkQsa0JBQU07QUFDTDNELHFCQUFLO0FBREE7QUFKQyxTQUZHO0FBVVgsbUJBQVcsU0FWQTtBQVdYQSxhQUFLLGtDQVhNO0FBWVgsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVpKO0FBb0JYLHlCQUFpQjtBQXBCTjtBQURPLENBQXBCO0FBd0JBLElBQUl1QyxtQkFBbUI7QUFDdEI1TCxnQkFBWTtBQUNYWixjQUFNLE1BREs7QUFFWDZHLGdCQUFRO0FBQ1A1QyxxQkFBUztBQUNSNkMscUJBQUs7QUFERyxhQURGO0FBSVAyRCxrQkFBTTtBQUNMM0QscUJBQUs7QUFEQTtBQUpDLFNBRkc7QUFVWCxtQkFBVyxTQVZBO0FBV1hBLGFBQUssa0NBWE07QUFZWCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBWko7QUFvQlgseUJBQWlCO0FBcEJOO0FBRFUsQ0FBdkI7QUF3QkEsSUFBSU0sU0FBUztBQUNadkssVUFBTSxPQURNO0FBRVprSCxXQUFPLEdBRks7QUFHWkosU0FBSztBQUhPLENBQWI7QUFLQSxJQUFJMkYsa0JBQWtCO0FBQ3JCek0sVUFBTSxNQURlO0FBRXJCNkcsWUFBUTtBQUNQLGNBQU07QUFDTEMsaUJBQUs7QUFEQSxTQURDO0FBSVAsY0FBTTtBQUNMQSxpQkFBSztBQURBLFNBSkM7QUFPUCxhQUFLO0FBQ0pBLGlCQUFLO0FBREQsU0FQRTtBQVVQLGNBQU07QUFDTEEsaUJBQUs7QUFEQSxTQVZDO0FBYVAsYUFBSztBQUNKQSxpQkFBSztBQURELFNBYkU7QUFnQlAsY0FBTTtBQUNMQSxpQkFBSztBQURBLFNBaEJDO0FBbUJQLGNBQU07QUFDTEEsaUJBQUs7QUFEQSxTQW5CQztBQXNCUCxlQUFPO0FBQ05BLGlCQUFLO0FBREMsU0F0QkE7QUF5QlA0RixhQUFLO0FBQ0o1RixpQkFBSztBQURELFNBekJFO0FBNEJQNkYsYUFBSztBQUNKN0YsaUJBQUs7QUFERCxTQTVCRTtBQStCUDJELGNBQU07QUFDTDNELGlCQUFLO0FBREEsU0EvQkM7QUFrQ1A4RixhQUFLO0FBQ0o5RixpQkFBSztBQURELFNBbENFO0FBcUNQLGdCQUFRO0FBQ1BBLGlCQUFLO0FBREU7QUFyQ0QsS0FGYTtBQTJDckJBLFNBQUs7QUEzQ2dCLENBQXRCO0FBNkNBLElBQUkrRixnQkFBZ0I7QUFDbkI3TSxVQUFNLE1BRGE7QUFFbkI2RyxZQUFRO0FBQ1BpRyxlQUFPO0FBQ05oRyxpQkFBSztBQURDLFNBREE7QUFJUGlHLG9CQUFZO0FBQ1hqRyxpQkFBSztBQURNLFNBSkw7QUFPUGtHLGlCQUFTO0FBQ1JsRyxpQkFBSztBQURHO0FBUEYsS0FGVztBQWFuQkEsU0FBSztBQWJjLENBQXBCO0FBZUEsSUFBSW1HLGdCQUFnQjtBQUNuQmpOLFVBQU0sT0FEYTtBQUVuQmdKLGFBQVMsQ0FGVTtBQUduQkQsYUFBUyxFQUhVO0FBSW5CN0IsV0FBTyxDQUNOLFFBRE0sRUFFTixPQUZNLENBSlk7QUFRbkI3TCxZQUFRLENBUlc7QUFTbkJ5TCxTQUFLO0FBVGMsQ0FBcEI7QUFXQSxJQUFJNkQsYUFBYTtBQUNoQjNLLFVBQU0sT0FEVTtBQUVoQmtILFdBQU8sR0FGUztBQUdoQjhCLGFBQVMsQ0FITztBQUloQmxDLFNBQUs7QUFKVyxDQUFqQjtBQU1BLElBQUlvRyxrQkFBa0I7QUFDckJwRyxTQUFLLEVBRGdCO0FBRXJCOUcsVUFBTSxNQUZlO0FBR3JCNkcsWUFBUTtBQUNQLGVBQU87QUFDTkMsaUJBQUssaUlBREM7QUFFTnFHLG1CQUFPLGtCQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhULFNBREE7QUFhUCxlQUFPO0FBQ05uRCxpQkFBSywwQ0FEQztBQUVOcUcsbUJBQU8sa0JBRkQ7QUFHTiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFQsU0FiQTtBQXlCUG1ELGlCQUFTO0FBQ1J0RyxpQkFBSywyQ0FERztBQUVScUcsbUJBQU8sT0FGQztBQUdSLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIUCxTQXpCRjtBQXFDUG9ELGVBQU87QUFDTnZHLGlCQUFLLHVPQURDO0FBRU5xRyxtQkFBTyxPQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhULFNBckNBO0FBaURQcUQsWUFBSTtBQUNIeEcsaUJBQUssa0NBREY7QUFFSHFHLG1CQUFPLFFBRko7QUFHSCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFosU0FqREc7QUE2RFAsY0FBTTtBQUNMbkQsaUJBQUssa0ZBREE7QUFFTHFHLG1CQUFPLFFBRkY7QUFHTCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJO0FBRGtCO0FBRFQ7QUFIVixTQTdEQztBQXNFUCxvQkFBWTtBQUNYaEQsaUJBQUssaVFBRE07QUFFWHFHLG1CQUFPLFFBRkk7QUFHWCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJO0FBRGtCO0FBRFQ7QUFISixTQXRFTDtBQStFUCxnQkFBUTtBQUNQaEQsaUJBQUssaUhBREU7QUFFUHFHLG1CQUFPLFVBRkE7QUFHUCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFIsU0EvRUQ7QUEyRlA1TSxlQUFPO0FBQ055SixpQkFBSyxra0JBREM7QUFFTnFHLG1CQUFPLFVBRkQ7QUFHTiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFQsU0EzRkE7QUF1R1BzRCxrQkFBVTtBQUNUekcsaUJBQUssdUdBREk7QUFFVHFHLG1CQUFPLFVBRkU7QUFHVCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSE4sU0F2R0g7QUFtSFB1RCxjQUFNO0FBQ0wxRyxpQkFBSyx1WkFEQTtBQUVMcUcsbUJBQU8sdUJBRkY7QUFHTCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFYsU0FuSEM7QUErSFB3RCxxQkFBYTtBQUNaM0csaUJBQUssdTNCQURPO0FBRVpxRyxtQkFBTyx1QkFGSztBQUdaLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFISCxTQS9ITjtBQTJJUCwyQkFBbUI7QUFDbEJuRCxpQkFBSyx1UEFEYTtBQUVsQnFHLG1CQUFPLHVCQUZXO0FBR2xCLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUk7QUFEa0I7QUFEVDtBQUhHLFNBM0laO0FBb0pQLDJCQUFtQjtBQUNsQmhELGlCQUFLLHlPQURhO0FBRWxCcUcsbUJBQU8sdUJBRlc7QUFHbEIsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSTtBQURrQjtBQURUO0FBSEcsU0FwSlo7QUE2SlA0RCxhQUFLO0FBQ0o1RyxpQkFBSyxzQ0FERDtBQUVKcUcsbUJBQU8sTUFGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIWCxTQTdKRTtBQXlLUDBELFlBQUk7QUFDSDdHLGlCQUFLLHVDQURGO0FBRUhxRyxtQkFBTyxNQUZKO0FBR0gsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhaLFNBektHO0FBcUxQckssV0FBRztBQUNGa0gsaUJBQUssc0NBREg7QUFFRnFHLG1CQUFPLE1BRkw7QUFHRiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSGIsU0FyTEk7QUFpTVAsa0JBQVU7QUFDVG5ELGlCQUFLLDBEQURJO0FBRVRxRyxtQkFBTyxPQUZFO0FBR1QsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhOLFNBak1IO0FBNk1QMkQsZ0JBQVE7QUFDUDlHLGlCQUFLLHNNQURFO0FBRVBxRyxtQkFBTyxPQUZBO0FBR1AsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhSLFNBN01EO0FBeU5QNEQsZ0JBQVE7QUFDUC9HLGlCQUFLLHNNQURFO0FBRVBxRyxtQkFBTyxPQUZBO0FBR1AsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhSLFNBek5EO0FBcU9QNkQsaUJBQVM7QUFDUmhILGlCQUFLLHlNQURHO0FBRVJxRyxtQkFBTyxPQUZDO0FBR1IsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhQLFNBck9GO0FBaVBQOEQsZ0JBQVE7QUFDUGpILGlCQUFLLHdNQURFO0FBRVBxRyxtQkFBTyxPQUZBO0FBR1AsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhSLFNBalBEO0FBNlBQK0Qsa0JBQVU7QUFDVGxILGlCQUFLLDRiQURJO0FBRVRxRyxtQkFBTyxPQUZFO0FBR1QsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhOLFNBN1BIO0FBeVFQbkcsZ0JBQVE7QUFDUGdELGlCQUFLLG1nQkFERTtBQUVQcUcsbUJBQU8sT0FGQTtBQUdQLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplLGlCQURUO0FBT2QsNkJBQWE7QUFDWkgsd0JBQUksUUFEUTtBQUVaQyw2QkFBUyxPQUZHO0FBR1pDLHlCQUFLLE9BSE87QUFJWkMsMkJBQU87QUFKSyxpQkFQQztBQWFkLDhCQUFjO0FBQ2JILHdCQUFJLFFBRFM7QUFFYkMsNkJBQVMsT0FGSTtBQUdiQyx5QkFBSyxPQUhRO0FBSWJDLDJCQUFPO0FBSk0saUJBYkE7QUFtQmQsOEJBQWM7QUFDYkgsd0JBQUksT0FEUztBQUViQyw2QkFBUyxPQUZJO0FBR2JDLHlCQUFLLFFBSFE7QUFJYkMsMkJBQU87QUFKTSxpQkFuQkE7QUF5QmRMLHVCQUFPO0FBQ05FLHdCQUFJO0FBREU7QUF6Qk87QUFIUixTQXpRRDtBQTBTUEYsZUFBTztBQUNOOUMsaUJBQUssK2NBREM7QUFFTnFHLG1CQUFPLE9BRkQ7QUFHTiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLE9BRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSztBQUhpQjtBQURUO0FBSFQsU0ExU0E7QUFxVFAseUJBQWlCO0FBQ2hCbEQsaUJBQUssa2FBRFc7QUFFaEJxRyxtQkFBTyxPQUZTO0FBR2hCLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUk7QUFEa0I7QUFEVDtBQUhDLFNBclRWO0FBOFRQLHFCQUFhO0FBQ1poRCxpQkFBSywwdUJBRE87QUFFWnFHLG1CQUFPLE9BRks7QUFHWiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSEgsU0E5VE47QUEwVVAscUJBQWE7QUFDWm5ELGlCQUFLLHlqQkFETztBQUVacUcsbUJBQU8sT0FGSztBQUdaLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFISCxTQTFVTjtBQXNWUCxzQkFBYztBQUNibkQsaUJBQUssd0pBRFE7QUFFYnFHLG1CQUFPLE9BRk07QUFHYiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSEYsU0F0VlA7QUFrV1AsbUJBQVc7QUFDVm5ELGlCQUFLLGtIQURLO0FBRVZxRyxtQkFBTyxPQUZHO0FBR1YsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhMLFNBbFdKO0FBOFdQLG9CQUFZO0FBQ1huRCxpQkFBSyw2TkFETTtBQUVYcUcsbUJBQU8sT0FGSTtBQUdYLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFISixTQTlXTDtBQTBYUGdFLGFBQUs7QUFDSm5ILGlCQUFLLDRMQUREO0FBRUpxRyxtQkFBTyxPQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBMVhFO0FBc1lQaUUsY0FBTTtBQUNMcEgsaUJBQUssb05BREE7QUFFTHFHLG1CQUFPLE9BRkY7QUFHTCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFYsU0F0WUM7QUFrWlB4RCxhQUFLO0FBQ0pLLGlCQUFLLCtLQUREO0FBRUpxRyxtQkFBTyxRQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBbFpFO0FBOFpQMkMsYUFBSztBQUNKOUYsaUJBQUssMklBREQ7QUFFSnFHLG1CQUFPLFFBRkg7QUFHSiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFgsU0E5WkU7QUEwYVA1TyxnQkFBUTtBQUNQeUwsaUJBQUssd0NBREU7QUFFUHFHLG1CQUFPLFFBRkE7QUFHUCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFIsU0ExYUQ7QUFzYlBrRSxvQkFBWTtBQUNYckgsaUJBQUssc0lBRE07QUFFWHFHLG1CQUFPLGNBRkk7QUFHWCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSEosU0F0Ykw7QUFrY1AseUJBQWlCO0FBQ2hCbkQsaUJBQUssNmRBRFc7QUFFaEJxRyxtQkFBTyxjQUZTO0FBR2hCLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUk7QUFEa0I7QUFEVDtBQUhDLFNBbGNWO0FBMmNQLHlCQUFpQjtBQUNoQmhELGlCQUFLLDBHQURXO0FBRWhCcUcsbUJBQU8sY0FGUztBQUdoQiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSEMsU0EzY1Y7QUF1ZFB0SyxZQUFJO0FBQ0htSCxpQkFBSyx1Q0FERjtBQUVIcUcsbUJBQU8sY0FGSjtBQUdILDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIWixTQXZkRztBQW1lUDVKLGNBQU07QUFDTHlHLGlCQUFLLDhLQURBO0FBRUxxRyxtQkFBTyxNQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhWLFNBbmVDO0FBK2VQLDJCQUFtQjtBQUNsQm5ELGlCQUFLLGdOQURhO0FBRWxCcUcsbUJBQU8sU0FGVztBQUdsQiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSEcsU0EvZVo7QUEyZlAseUJBQWlCO0FBQ2hCbkQsaUJBQUssNEZBRFc7QUFFaEJxRyxtQkFBTyxjQUZTO0FBR2hCLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIQyxTQTNmVjtBQXVnQlBtRSxxQkFBYTtBQUNadEgsaUJBQUssNElBRE87QUFFWnFHLG1CQUFPLGNBRks7QUFHWiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJO0FBRGtCO0FBRFQ7QUFISCxTQXZnQk47QUFnaEJQLGFBQUs7QUFDSmhELGlCQUFLLGdDQUREO0FBRUpxRyxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBaGhCRTtBQTRoQlAsYUFBSztBQUNKbkQsaUJBQUssb0NBREQ7QUFFSnFHLG1CQUFPLE1BRkg7QUFHSiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFgsU0E1aEJFO0FBd2lCUCxhQUFLO0FBQ0puRCxpQkFBSyxxSkFERDtBQUVKcUcsbUJBQU8sTUFGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIWCxTQXhpQkU7QUFvakJQLGFBQUs7QUFDSm5ELGlCQUFLLGlGQUREO0FBRUpxRyxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBcGpCRTtBQWdrQlAsYUFBSztBQUNKbkQsaUJBQUssZ0ZBREQ7QUFFSnFHLG1CQUFPLE1BRkg7QUFHSiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFgsU0Foa0JFO0FBNGtCUCxhQUFLO0FBQ0puRCxpQkFBSyxxRkFERDtBQUVKcUcsbUJBQU8sTUFGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIWCxTQTVrQkU7QUF3bEJQb0UsY0FBTTtBQUNMdkgsaUJBQUssdUNBREE7QUFFTHFHLG1CQUFPLE1BRkY7QUFHTCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFYsU0F4bEJDO0FBb21CUHFFLGVBQU87QUFDTnhILGlCQUFLLDhDQURDO0FBRU5xRyxtQkFBTyxNQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhULFNBcG1CQTtBQWduQlBzRSxZQUFJO0FBQ0h6SCxpQkFBSyw2Q0FERjtBQUVIcUcsbUJBQU8sTUFGSjtBQUdILDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIWixTQWhuQkc7QUE0bkJQdUUsY0FBTTtBQUNMMUgsaUJBQUssOENBREE7QUFFTHFHLG1CQUFPLE1BRkY7QUFHTCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFYsU0E1bkJDO0FBd29CUHdFLGFBQUs7QUFDSjNILGlCQUFLLGdDQUREO0FBRUpxRyxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBeG9CRTtBQW9wQlB5RSxhQUFLO0FBQ0o1SCxpQkFBSyxrQ0FERDtBQUVKcUcsbUJBQU8sTUFGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIWCxTQXBwQkU7QUFncUJQMEUsYUFBSztBQUNKN0gsaUJBQUssbUNBREQ7QUFFSnFHLG1CQUFPLE1BRkg7QUFHSiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFgsU0FocUJFO0FBNHFCUDJFLGNBQU07QUFDTDlILGlCQUFLLG1DQURBO0FBRUxxRyxtQkFBTyxNQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhWLFNBNXFCQztBQXdyQlA0RSxjQUFNO0FBQ0wvSCxpQkFBSyxxQ0FEQTtBQUVMcUcsbUJBQU8sTUFGRjtBQUdMLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIVixTQXhyQkM7QUFvc0JQNkUsY0FBTTtBQUNMaEksaUJBQUssc0NBREE7QUFFTHFHLG1CQUFPLE1BRkY7QUFHTCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFYsU0Fwc0JDO0FBZ3RCUDhFLGFBQUs7QUFDSmpJLGlCQUFLLDBDQUREO0FBRUpxRyxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBaHRCRTtBQTR0QlArRSxhQUFLO0FBQ0psSSxpQkFBSywwQ0FERDtBQUVKcUcsbUJBQU8sTUFGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIWCxTQTV0QkU7QUF3dUJQaUIsZUFBTztBQUNOcEUsaUJBQUssdUlBREM7QUFFTnFHLG1CQUFPLE1BRkQ7QUFHTiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFQsU0F4dUJBO0FBb3ZCUGdGLGFBQUs7QUFDSm5JLGlCQUFLLDBDQUREO0FBRUpxRyxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBcHZCRTtBQWd3QlBpRixjQUFNO0FBQ0xwSSxpQkFBSywwRUFEQTtBQUVMcUcsbUJBQU8sTUFGRjtBQUdMLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIVixTQWh3QkM7QUE0d0JQa0YsZUFBTztBQUNOckksaUJBQUssc0VBREM7QUFFTnFHLG1CQUFPLE1BRkQ7QUFHTiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSFQsU0E1d0JBO0FBd3hCUCxjQUFNO0FBQ0xuRCxpQkFBSyxrWEFEQTtBQUVMcUcsbUJBQU8sVUFGRjtBQUdMLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplLGlCQURUO0FBT2QrRCwwQkFBVTtBQUNUbEUsd0JBQUksUUFESztBQUVUQyw2QkFBUyxPQUZBO0FBR1RDLHlCQUFLLE9BSEk7QUFJVEMsMkJBQU87QUFKRTtBQVBJO0FBSFYsU0F4eEJDO0FBMHlCUCxjQUFNO0FBQ0xuRCxpQkFBSyxzWEFEQTtBQUVMcUcsbUJBQU8sVUFGRjtBQUdMLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplLGlCQURUO0FBT2QrRCwwQkFBVTtBQUNUbEUsd0JBQUksUUFESztBQUVUQyw2QkFBUyxPQUZBO0FBR1RDLHlCQUFLLE9BSEk7QUFJVEMsMkJBQU87QUFKRTtBQVBJO0FBSFYsU0ExeUJDO0FBNHpCUCxhQUFLO0FBQ0puRCxpQkFBSyw0YkFERDtBQUVKcUcsbUJBQU8sVUFGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplLGlCQURUO0FBT2QrRCwwQkFBVTtBQUNUbEUsd0JBQUksUUFESztBQUVUQyw2QkFBUyxPQUZBO0FBR1RDLHlCQUFLLE9BSEk7QUFJVEMsMkJBQU87QUFKRTtBQVBJO0FBSFgsU0E1ekJFO0FBODBCUCxhQUFLO0FBQ0puRCxpQkFBSyx5YkFERDtBQUVKcUcsbUJBQU8sVUFGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplLGlCQURUO0FBT2QrRCwwQkFBVTtBQUNUbEUsd0JBQUksUUFESztBQUVUQyw2QkFBUyxPQUZBO0FBR1RDLHlCQUFLLE9BSEk7QUFJVEMsMkJBQU87QUFKRTtBQVBJO0FBSFgsU0E5MEJFO0FBZzJCUCxjQUFNO0FBQ0xuRCxpQkFBSywrYkFEQTtBQUVMcUcsbUJBQU8sVUFGRjtBQUdMLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplLGlCQURUO0FBT2QrRCwwQkFBVTtBQUNUbEUsd0JBQUksUUFESztBQUVUQyw2QkFBUyxPQUZBO0FBR1RDLHlCQUFLLE9BSEk7QUFJVEMsMkJBQU87QUFKRTtBQVBJO0FBSFYsU0FoMkJDO0FBazNCUCxjQUFNO0FBQ0xuRCxpQkFBSyw0YkFEQTtBQUVMcUcsbUJBQU8sVUFGRjtBQUdMLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplLGlCQURUO0FBT2QrRCwwQkFBVTtBQUNUbEUsd0JBQUksUUFESztBQUVUQyw2QkFBUyxPQUZBO0FBR1RDLHlCQUFLLE9BSEk7QUFJVEMsMkJBQU87QUFKRTtBQVBJO0FBSFYsU0FsM0JDO0FBbzRCUHlDLGFBQUs7QUFDSjVGLGlCQUFLLDZQQUREO0FBRUpxRyxtQkFBTyxVQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBcDRCRTtBQWc1QlAwQyxhQUFLO0FBQ0o3RixpQkFBSyw4UEFERDtBQUVKcUcsbUJBQU8sVUFGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIWCxTQWg1QkU7QUE0NUJQLGFBQUs7QUFDSm5ELGlCQUFLLCtGQUREO0FBRUpxRyxtQkFBTyxVQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBNTVCRTtBQXc2QlBtRixnQkFBUTtBQUNQdEksaUJBQUssb3BCQURFO0FBRVBxRyxtQkFBTyxVQUZBO0FBR1AsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSTtBQURrQjtBQURUO0FBSFIsU0F4NkJEO0FBaTdCUCwrQkFBdUI7QUFDdEJoRCxpQkFBSywwVUFEaUI7QUFFdEJxRyxtQkFBTyxRQUZlO0FBR3RCLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTO0FBRmE7QUFEVDtBQUhPLFNBajdCaEI7QUEyN0JQc0YsZ0JBQVE7QUFDUHZJLGlCQUFLLG9MQURFO0FBRVBxRyxtQkFBTyxRQUZBO0FBR1AsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJyRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVDtBQUhSLFNBMzdCRDtBQXU4QlBxRixrQkFBVTtBQUNUeEksaUJBQUssb0xBREk7QUFFVHFHLG1CQUFPLFFBRkU7QUFHVCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSE4sU0F2OEJIO0FBbTlCUHNGLGdCQUFRO0FBQ1B6SSxpQkFBSyw2SEFERTtBQUVQcUcsbUJBQU8sUUFGQTtBQUdQLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCckQsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQ7QUFIUixTQW45QkQ7QUErOUJQLDJCQUFtQjtBQUNsQm5ELGlCQUFLLDRNQURhO0FBRWxCcUcsbUJBQU8sUUFGVztBQUdsQiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURUO0FBSEcsU0EvOUJaO0FBMitCUDlELGVBQU87QUFDTlcsaUJBQUssOExBREM7QUFFTnFHLG1CQUFPLFFBRkQ7QUFHTiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnJELHdCQUFJO0FBRGtCO0FBRFQ7QUFIVDtBQTMrQkE7QUFIYSxDQUF0QjtBQXkvQkEsSUFBSXZDLFFBQVE7QUFDWEMsWUFBUTtBQUNQeEgsY0FBTSxNQURDO0FBRVAsbUJBQVcsVUFGSjtBQUdQNkcsZ0JBQVE7QUFDUG5MLGlCQUFLO0FBQ0pvTCxxQkFBSztBQURELGFBREU7QUFJUDRFLHNCQUFVO0FBQ1Q1RSxxQkFBSztBQURJO0FBSkgsU0FIRDtBQVdQLHlCQUFpQixlQVhWO0FBWVBjLG9CQUFZLEtBWkw7QUFhUCtDLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FiTDtBQW1CUC9ELGFBQUssc0VBbkJFO0FBb0JQQyxpQkFBUyxLQXBCRjtBQXFCUCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QitDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURUO0FBckJSLEtBREc7QUErQlh1RixjQUFVO0FBQ1R4UCxjQUFNLE9BREc7QUFFVCxtQkFBVyxDQUNWLElBRFUsRUFFVixHQUZVLEVBR1YsRUFIVSxDQUZGO0FBT1QzRSxnQkFBUSxDQVBDO0FBUVQ2TCxlQUFPLFFBUkU7QUFTVCx5QkFBaUIsZUFUUjtBQVVUVSxvQkFBWSxJQVZIO0FBV1QrQyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBWEg7QUFpQlQvRCxhQUFLLGdpQkFqQkk7QUFrQlRDLGlCQUFTLENBQ1IsR0FEUSxFQUVSLEVBRlEsRUFHUixFQUhRLENBbEJBO0FBdUJULHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCK0Msb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQ7QUF2Qk4sS0EvQkM7QUErRFh4QyxXQUFPO0FBQ056SCxjQUFNLE9BREE7QUFFTix5QkFBaUIsZUFGWDtBQUdOLG1CQUFXLFNBSEw7QUFJTjJLLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FKTjtBQVVOakQsb0JBQVksSUFWTjtBQVdOZCxhQUFLLDhDQVhDO0FBWU4sdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVDtBQVpULEtBL0RJO0FBb0ZYdkMsZUFBVztBQUNWMUgsY0FBTSxRQURJO0FBRVYseUJBQWlCLGVBRlA7QUFHVixtQkFBVyxHQUhEO0FBSVZnSixpQkFBUyxDQUpDO0FBS1ZELGlCQUFTLENBTEM7QUFNVjRCLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FORjtBQVlWakQsb0JBQVksSUFaRjtBQWFWZCxhQUFLLHVHQWJLO0FBY1YsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVDtBQWRMO0FBcEZBLENBQVo7QUE0R0EsSUFBSTdKLFFBQVEsQ0FDWCxZQURXLEVBRVgsWUFGVyxFQUdYLGNBSFcsRUFJWCxlQUpXLEVBS1gsc0JBTFcsRUFNWCxjQU5XLEVBT1gsY0FQVyxFQVFYLGlCQVJXLEVBU1gsa0JBVFcsQ0FBWjtBQVdBLElBQUlxUCxhQUFhO0FBQ2hCLHNCQUFrQjtBQUNqQnpQLGNBQU0sU0FEVztBQUVqQixtQkFBVyxJQUZNO0FBR2pCOEcsYUFBSyxnREFIWTtBQUlqQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBSkU7QUFZakJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FaSztBQWtCakIseUJBQWlCO0FBbEJBLEtBREY7QUFxQmhCLG9CQUFnQjtBQUNmN0ssY0FBTSxRQURTO0FBRWYsbUJBQVcsQ0FGSTtBQUdmZ0osaUJBQVMsQ0FITTtBQUlmRCxpQkFBUyxDQUpNO0FBS2ZqQyxhQUFLLDJKQUxVO0FBTWZjLG9CQUFZLElBTkc7QUFPZix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmtDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVBBO0FBcUJmVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FyQkc7QUE2QmYseUJBQWlCO0FBN0JGLEtBckJBO0FBb0RoQixrQkFBYztBQUNiN0ssY0FBTSxPQURPO0FBRWIsbUJBQVcsU0FGRTtBQUdiOEcsYUFBSyxpTUFIUTtBQUliYyxvQkFBWSxJQUpDO0FBS2IwRCxrQkFBVSxDQUNUO0FBQ0MsaUJBQUs7QUFETixTQURTLENBTEc7QUFVYix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVZGO0FBd0JiVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0F4QkM7QUFnQ2IseUJBQWlCO0FBaENKLEtBcERFO0FBc0ZoQiwwQkFBc0I7QUFDckI3SyxjQUFNLE9BRGU7QUFFckI4RyxhQUFLLGtGQUZnQjtBQUdyQmMsb0JBQVksSUFIUztBQUlyQjBELGtCQUFVLENBQ1Q7QUFDQyxpQkFBSztBQUROLFNBRFMsRUFJVDtBQUNDLDhCQUFrQjtBQURuQixTQUpTLENBSlc7QUFZckIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FaTTtBQTBCckJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQTFCUztBQWtDckIseUJBQWlCO0FBbENJLEtBdEZOO0FBMEhoQixzQkFBa0I7QUFDakI3SyxjQUFNLE9BRFc7QUFFakJrSCxlQUFPLFFBRlU7QUFHakI3TCxnQkFBUSxDQUhTO0FBSWpCLG1CQUFXLENBQ1YsQ0FEVSxFQUVWLENBRlUsQ0FKTTtBQVFqQnVNLG9CQUFZLElBUks7QUFTakJQLGVBQU8sUUFUVTtBQVVqQlAsYUFBSyw4RkFWWTtBQVdqQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBWEU7QUFtQmpCVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBbkJLO0FBeUJqQix5QkFBaUI7QUF6QkEsS0ExSEY7QUFxSmhCLDZCQUF5QjtBQUN4QjdLLGNBQU0sTUFEa0I7QUFFeEI2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQNEUsc0JBQVU7QUFDVDVFLHFCQUFLO0FBREk7QUFKSCxTQUZnQjtBQVV4QkEsYUFBSyx1REFWbUI7QUFXeEIsbUJBQVcsS0FYYTtBQVl4QndFLGtCQUFVLENBQ1QsZ0JBRFMsQ0FaYztBQWV4Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBZlM7QUF1QnhCVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBdkJZO0FBNkJ4Qix5QkFBaUI7QUE3Qk8sS0FySlQ7QUFvTGhCLG9CQUFnQjtBQUNmN0ssY0FBTSxlQURTO0FBRWY0SCxvQkFBWSxJQUZHO0FBR2ZkLGFBQUssd09BSFU7QUFJZix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkUsdUJBQU8sUUFIZTtBQUl0QkQscUJBQUs7QUFKaUI7QUFQVCxTQUpBO0FBa0JmVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQWxCRztBQXlCZix5QkFBaUI7QUF6QkY7QUFwTEEsQ0FBakI7QUFnTkEsSUFBSTZFLGFBQWE7QUFDaEIsb0JBQWdCO0FBQ2YxUCxjQUFNLFFBRFM7QUFFZjhHLGFBQUssOENBRlU7QUFHZixtQkFBVyxDQUhJO0FBSWZrQyxpQkFBUyxDQUpNO0FBS2ZELGlCQUFTLENBTE07QUFNZm5CLG9CQUFZLElBTkc7QUFPZix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmtDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVBBO0FBcUJmVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FyQkc7QUE2QmYseUJBQWlCO0FBN0JGLEtBREE7QUFnQ2hCLGtCQUFjO0FBQ2I3SyxjQUFNLE9BRE87QUFFYjhHLGFBQUssOENBRlE7QUFHYixtQkFBVyxTQUhFO0FBSWJjLG9CQUFZLElBSkM7QUFLYjBELGtCQUFVLENBQ1Q7QUFDQyxpQkFBSztBQUROLFNBRFMsQ0FMRztBQVViLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBVkY7QUF3QmJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXhCQztBQWdDYix5QkFBaUI7QUFoQ0osS0FoQ0U7QUFrRWhCLHNCQUFrQjtBQUNqQjdLLGNBQU0sT0FEVztBQUVqQmtILGVBQU8sUUFGVTtBQUdqQjdMLGdCQUFRLENBSFM7QUFJakIsbUJBQVcsQ0FDVixDQURVLEVBRVYsQ0FGVSxDQUpNO0FBUWpCdU0sb0JBQVksSUFSSztBQVNqQlAsZUFBTyxRQVRVO0FBVWpCUCxhQUFLLDhGQVZZO0FBV2pCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCZ0Qsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FYRTtBQW1CakJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FuQks7QUF5QmpCLHlCQUFpQjtBQXpCQSxLQWxFRjtBQTZGaEIsNkJBQXlCO0FBQ3hCN0ssY0FBTSxNQURrQjtBQUV4QjZHLGdCQUFRO0FBQ1BuTCxpQkFBSztBQUNKb0wscUJBQUs7QUFERCxhQURFO0FBSVA0RSxzQkFBVTtBQUNUNUUscUJBQUs7QUFESTtBQUpILFNBRmdCO0FBVXhCQSxhQUFLLHVEQVZtQjtBQVd4QixtQkFBVyxLQVhhO0FBWXhCd0Usa0JBQVUsQ0FDVCxnQkFEUyxDQVpjO0FBZXhCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FmUztBQXVCeEJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0F2Qlk7QUE2QnhCLHlCQUFpQjtBQTdCTyxLQTdGVDtBQTRIaEIsa0JBQWM7QUFDYjdLLGNBQU0sUUFETztBQUViLG1CQUFXLENBRkU7QUFHYmdKLGlCQUFTLENBSEk7QUFJYnBCLG9CQUFZLElBSkM7QUFLYlAsZUFBTyxRQUxNO0FBTWJQLGFBQUssbUJBTlE7QUFPYix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVBGO0FBcUJiVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FyQkM7QUE2QmIseUJBQWlCO0FBN0JKLEtBNUhFO0FBMkpoQixzQkFBa0I7QUFDakI3SyxjQUFNLFFBRFc7QUFFakIsbUJBQVcsQ0FGTTtBQUdqQmdKLGlCQUFTLENBSFE7QUFJakJsQyxhQUFLLGtHQUpZO0FBS2pCYyxvQkFBWSxJQUxLO0FBTWpCUCxlQUFPLFFBTlU7QUFPakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5QyxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FQRTtBQXFCakJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXJCSztBQTZCakIseUJBQWlCO0FBN0JBLEtBM0pGO0FBMExoQixtQkFBZTtBQUNkN0ssY0FBTSxRQURRO0FBRWQsbUJBQVcsQ0FGRztBQUdkOEcsYUFBSyx5UUFIUztBQUlkYyxvQkFBWSxJQUpFO0FBS2RQLGVBQU8sUUFMTztBQU1kLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUMsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBTkQ7QUFvQmRVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXBCRTtBQTRCZCx5QkFBaUI7QUE1QkgsS0ExTEM7QUF3TmhCLGlCQUFhO0FBQ1o3SyxjQUFNLFFBRE07QUFFWixtQkFBVyxDQUZDO0FBR1pnSixpQkFBUyxDQUhHO0FBSVpwQixvQkFBWSxJQUpBO0FBS1pQLGVBQU8sUUFMSztBQU1aUCxhQUFLLHNDQU5PO0FBT1osdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FQSDtBQXFCWlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBckJBO0FBNkJaLHlCQUFpQjtBQTdCTCxLQXhORztBQXVQaEIsc0JBQWtCO0FBQ2pCN0ssY0FBTSxPQURXO0FBRWpCa0gsZUFBTyxRQUZVO0FBR2pCSixhQUFLLGdhQUhZO0FBSWpCa0MsaUJBQVMsQ0FKUTtBQUtqQnBCLG9CQUFZLElBTEs7QUFNakJQLGVBQU8sYUFOVTtBQU9qQmlFLGtCQUFVLENBQ1Q7QUFDQyxpQkFBSztBQUROLFNBRFMsQ0FQTztBQVlqQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBUFQsU0FaRTtBQXNCakJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0F0Qks7QUE0QmpCLHlCQUFpQjtBQTVCQSxLQXZQRjtBQXFSaEIsb0JBQWdCO0FBQ2Y3SyxjQUFNLGVBRFM7QUFFZjRILG9CQUFZLElBRkc7QUFHZmQsYUFBSyw2TkFIVTtBQUlmLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCZ0Qsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCRSx1QkFBTyxRQUhlO0FBSXRCRCxxQkFBSztBQUppQjtBQVBULFNBSkE7QUFrQmZXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBbEJHO0FBeUJmLHlCQUFpQjtBQXpCRixLQXJSQTtBQWdUaEIscUJBQWlCO0FBQ2hCN0ssY0FBTSxPQURVO0FBRWhCOEcsYUFBSyxvSUFGVztBQUdoQmMsb0JBQVksS0FISTtBQUloQjBELGtCQUFVLENBQ1Q7QUFDQyxpQkFBSztBQUROLFNBRFMsRUFJVDtBQUNDLGlCQUFLO0FBRE4sU0FKUyxFQU9UO0FBQ0MvTixvQkFBUSxTQURUO0FBRUNxUCxpQkFBSztBQUNKdEQsNkJBQWE7QUFEVDtBQUZOLFNBUFMsQ0FKTTtBQWtCaEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJRLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBUFQsU0FsQkM7QUE0QmhCVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsZUFEVztBQUZELFNBNUJJO0FBa0NoQix5QkFBaUI7QUFsQ0Q7QUFoVEQsQ0FBakI7QUFxVkEsSUFBSThFLGVBQWU7QUFDbEIscUJBQWlCO0FBQ2hCM1AsY0FBTSxRQURVO0FBRWhCLG1CQUFXLENBRks7QUFHaEJnSixpQkFBUyxDQUhPO0FBSWhCcEIsb0JBQVksSUFKSTtBQUtoQlAsZUFBTyxRQUxTO0FBTWhCUCxhQUFLLGdCQU5XO0FBT2hCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCZ0Qsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBUEM7QUFxQmhCVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FyQkk7QUE2QmhCLHlCQUFpQjtBQTdCRCxLQURDO0FBZ0NsQixvQkFBZ0I7QUFDZjdLLGNBQU0sT0FEUztBQUVmLG1CQUFXLFNBRkk7QUFHZjhHLGFBQUssK0JBSFU7QUFJZmMsb0JBQVksSUFKRztBQUtmLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCa0Msb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBTEE7QUFtQmZVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQW5CRztBQTJCZix5QkFBaUI7QUEzQkYsS0FoQ0U7QUE2RGxCLG1CQUFlO0FBQ2Q3SyxjQUFNLFFBRFE7QUFFZCxtQkFBVyxDQUZHO0FBR2Q4RyxhQUFLLCtGQUhTO0FBSWRjLG9CQUFZLElBSkU7QUFLZCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmtDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQUxEO0FBbUJkVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FuQkU7QUEyQmQseUJBQWlCO0FBM0JILEtBN0RHO0FBMEZsQixzQkFBa0I7QUFDakI3SyxjQUFNLFFBRFc7QUFFakI4RyxhQUFLLGdEQUZZO0FBR2pCLG1CQUFXLENBSE07QUFJakJrQyxpQkFBUyxDQUpRO0FBS2pCRCxpQkFBUyxDQUxRO0FBTWpCbkIsb0JBQVksSUFOSztBQU9qQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmtDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVBFO0FBcUJqQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBckJLO0FBNkJqQix5QkFBaUI7QUE3QkEsS0ExRkE7QUF5SGxCLHdCQUFvQjtBQUNuQjdLLGNBQU0sT0FEYTtBQUVuQmtILGVBQU8sUUFGWTtBQUduQjdMLGdCQUFRLENBSFc7QUFJbkIsbUJBQVcsQ0FDVixDQURVLEVBRVYsQ0FGVSxDQUpRO0FBUW5CdU0sb0JBQVksSUFSTztBQVNuQlAsZUFBTyxRQVRZO0FBVW5CUCxhQUFLLDhGQVZjO0FBV25CLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCZ0Qsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FYSTtBQW1CbkJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FuQk87QUF5Qm5CLHlCQUFpQjtBQXpCRSxLQXpIRjtBQW9KbEIsK0JBQTJCO0FBQzFCN0ssY0FBTSxNQURvQjtBQUUxQjZHLGdCQUFRO0FBQ1BuTCxpQkFBSztBQUNKb0wscUJBQUs7QUFERCxhQURFO0FBSVA0RSxzQkFBVTtBQUNUNUUscUJBQUs7QUFESTtBQUpILFNBRmtCO0FBVTFCQSxhQUFLLHlEQVZxQjtBQVcxQixtQkFBVyxLQVhlO0FBWTFCd0Usa0JBQVUsQ0FDVCxrQkFEUyxDQVpnQjtBQWUxQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBZlc7QUF1QjFCVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBdkJjO0FBNkIxQix5QkFBaUI7QUE3QlMsS0FwSlQ7QUFtTGxCLDBCQUFzQjtBQUNyQjdLLGNBQU0sTUFEZTtBQUVyQjZHLGdCQUFRO0FBQ1BuTCxpQkFBSztBQUNKb0wscUJBQUs7QUFERCxhQURFO0FBSVA0RSxzQkFBVTtBQUNUNUUscUJBQUs7QUFESTtBQUpILFNBRmE7QUFVckIsbUJBQVcsS0FWVTtBQVdyQkEsYUFBSyxzRUFYZ0I7QUFZckIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVpNO0FBb0JyQlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQXBCUztBQTBCckIseUJBQWlCO0FBMUJJLEtBbkxKO0FBK01sQiw4QkFBMEI7QUFDekI3SyxjQUFNLE1BRG1CO0FBRXpCNkcsZ0JBQVE7QUFDUG5MLGlCQUFLO0FBQ0pvTCxxQkFBSztBQURELGFBREU7QUFJUDRFLHNCQUFVO0FBQ1Q1RSxxQkFBSztBQURJO0FBSkgsU0FGaUI7QUFVekIsbUJBQVcsVUFWYztBQVd6QkEsYUFBSyw0Q0FYb0I7QUFZekIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVpVO0FBb0J6QlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQXBCYTtBQTBCekIseUJBQWlCO0FBMUJRLEtBL01SO0FBMk9sQiwyQkFBdUI7QUFDdEI3SyxjQUFNLFFBRGdCO0FBRXRCLG1CQUFXLENBRlc7QUFHdEJnSixpQkFBUyxDQUhhO0FBSXRCcEIsb0JBQVksSUFKVTtBQUt0QlAsZUFBTyxRQUxlO0FBTXRCUCxhQUFLLHNGQU5pQjtBQU90Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVBPO0FBcUJ0QlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBckJVO0FBNkJ0Qix5QkFBaUI7QUE3QkssS0EzT0w7QUEwUWxCLDJCQUF1QjtBQUN0QjdLLGNBQU0sT0FEZ0I7QUFFdEIsbUJBQVcsU0FGVztBQUd0QjhHLGFBQUssaUNBSGlCO0FBSXRCYyxvQkFBWSxJQUpVO0FBS3RCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCa0Msb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBTE87QUFtQnRCVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FuQlU7QUEyQnRCLHlCQUFpQjtBQTNCSyxLQTFRTDtBQXVTbEIsNkJBQXlCO0FBQ3hCN0ssY0FBTSxRQURrQjtBQUV4QjhHLGFBQUsscUNBRm1CO0FBR3hCLG1CQUFXLENBSGE7QUFJeEJrQyxpQkFBUyxDQUplO0FBS3hCRCxpQkFBUyxDQUxlO0FBTXhCbkIsb0JBQVksSUFOWTtBQU94Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmtDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVBTO0FBcUJ4QlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBckJZO0FBNkJ4Qix5QkFBaUI7QUE3Qk87QUF2U1AsQ0FBbkI7QUF1VUEsSUFBSStFLGdCQUFnQjtBQUNuQixzQkFBa0I7QUFDakI1UCxjQUFNLFFBRFc7QUFFakIsbUJBQVcsRUFGTTtBQUdqQmdKLGlCQUFTLENBSFE7QUFJakJwQixvQkFBWSxJQUpLO0FBS2pCUCxlQUFPLFFBTFU7QUFNakJQLGFBQUsseUhBTlk7QUFPakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FQRTtBQXFCakJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXJCSztBQTZCakIseUJBQWlCO0FBN0JBLEtBREM7QUFnQ25CLHNCQUFrQjtBQUNqQjdLLGNBQU0sUUFEVztBQUVqQixtQkFBVyxDQUZNO0FBR2pCZ0osaUJBQVMsQ0FIUTtBQUlqQnBCLG9CQUFZLEtBSks7QUFLakJkLGFBQUssNE1BTFk7QUFNakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FORTtBQW9CakJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXBCSztBQTRCakIseUJBQWlCO0FBNUJBLEtBaENDO0FBOERuQix5QkFBcUI7QUFDcEI3SyxjQUFNLFFBRGM7QUFFcEIsbUJBQVcsQ0FGUztBQUdwQmdKLGlCQUFTLENBSFc7QUFJcEJwQixvQkFBWSxJQUpRO0FBS3BCZCxhQUFLLCtJQUxlO0FBTXBCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCZ0Qsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FOSztBQWNwQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWRRO0FBb0JwQix5QkFBaUI7QUFwQkcsS0E5REY7QUFvRm5CLHFCQUFpQjtBQUNoQjdLLGNBQU0sT0FEVTtBQUVoQixtQkFBVyxDQUNWLGFBRFUsRUFFVixDQUNDLFFBREQsQ0FGVSxFQUtWLENBQ0MsaUJBREQsQ0FMVSxFQVFWLENBUlUsRUFTVixvQkFUVSxFQVVWLEdBVlUsRUFXVixXQVhVLEVBWVYsR0FaVSxFQWFWLE1BYlUsRUFjVixHQWRVLEVBZVYsTUFmVSxFQWdCVixHQWhCVSxFQWlCVixRQWpCVSxFQWtCVixDQWxCVSxFQW1CVixLQW5CVSxDQUZLO0FBdUJoQjhHLGFBQUssK0lBdkJXO0FBd0JoQmMsb0JBQVksS0F4Qkk7QUF5QmhCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCa0Msb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFQVCxTQXpCQztBQW1DaEJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxpQkFEVztBQUZELFNBbkNJO0FBeUNoQix5QkFBaUI7QUF6Q0QsS0FwRkU7QUErSG5CLHVCQUFtQjtBQUNsQjdLLGNBQU0sUUFEWTtBQUVsQjhHLGFBQUssOERBRmE7QUFHbEIsbUJBQVcsQ0FITztBQUlsQmtDLGlCQUFTLENBSlM7QUFLbEJELGlCQUFTLENBTFM7QUFNbEJuQixvQkFBWSxJQU5NO0FBT2xCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCa0Msb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FQRztBQWVsQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWZNO0FBcUJsQix5QkFBaUI7QUFyQkM7QUEvSEEsQ0FBcEI7QUF1SkEsSUFBSWdGLGVBQWU7QUFDbEIsb0JBQWdCO0FBQ2YvSSxhQUFLLDhDQURVO0FBRWY5RyxjQUFNLFFBRlM7QUFHZixtQkFBVyxDQUhJO0FBSWZnSixpQkFBUyxDQUpNO0FBS2ZELGlCQUFTLENBTE07QUFNZm5CLG9CQUFZLElBTkc7QUFPZjBELGtCQUFVLENBQ1QsWUFEUyxDQVBLO0FBVWYsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FWQTtBQXdCZlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBeEJHO0FBZ0NmLHlCQUFpQjtBQWhDRixLQURFO0FBbUNsQixrQkFBYztBQUNiN0ssY0FBTSxPQURPO0FBRWIsbUJBQVcsU0FGRTtBQUdiNEgsb0JBQVksSUFIQztBQUliZCxhQUFLLDhEQUpRO0FBS2J3RSxrQkFBVSxDQUNULFlBRFMsQ0FMRztBQVFiLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBUkY7QUFzQmJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXRCQztBQThCYix5QkFBaUI7QUE5QkosS0FuQ0k7QUFtRWxCLHVCQUFtQjtBQUNsQjdLLGNBQU0sT0FEWTtBQUVsQixtQkFBVyxrQkFGTztBQUdsQjRILG9CQUFZLElBSE07QUFJbEJkLGFBQUssMkVBSmE7QUFLbEJ3RSxrQkFBVSxDQUNULFlBRFMsQ0FMUTtBQVFsQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVJHO0FBc0JsQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBdEJNO0FBOEJsQix5QkFBaUI7QUE5QkMsS0FuRUQ7QUFtR2xCLHVCQUFtQjtBQUNsQjdLLGNBQU0sUUFEWTtBQUVsQixtQkFBVyxDQUZPO0FBR2xCZ0osaUJBQVMsQ0FIUztBQUlsQnBCLG9CQUFZLElBSk07QUFLbEJQLGVBQU8sUUFMVztBQU1sQlAsYUFBSyx1Q0FOYTtBQU9sQndFLGtCQUFVLENBQ1QsWUFEUyxDQVBRO0FBVWxCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBVkc7QUF3QmxCVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0F4Qk07QUFnQ2xCLHlCQUFpQjtBQWhDQyxLQW5HRDtBQXFJbEIsc0JBQWtCO0FBQ2pCN0ssY0FBTSxRQURXO0FBRWpCLG1CQUFXLENBRk07QUFHakJnSixpQkFBUyxDQUhRO0FBSWpCcEIsb0JBQVksSUFKSztBQUtqQlAsZUFBTyxRQUxVO0FBTWpCUCxhQUFLLHdDQU5ZO0FBT2pCd0Usa0JBQVUsQ0FDVCxZQURTLENBUE87QUFVakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FWRTtBQXdCakJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXhCSztBQWdDakIseUJBQWlCO0FBaENBLEtBcklBO0FBdUtsQixzQkFBa0I7QUFDakI3SyxjQUFNLE9BRFc7QUFFakJrSCxlQUFPLFFBRlU7QUFHakI3TCxnQkFBUSxDQUhTO0FBSWpCLG1CQUFXLENBQ1YsQ0FEVSxFQUVWLENBRlUsQ0FKTTtBQVFqQnVNLG9CQUFZLElBUks7QUFTakJQLGVBQU8sUUFUVTtBQVVqQlAsYUFBSyw0SkFWWTtBQVdqQndFLGtCQUFVLENBQ1QsWUFEUyxDQVhPO0FBY2pCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FkRTtBQXNCakJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0F0Qks7QUE0QmpCLHlCQUFpQjtBQTVCQSxLQXZLQTtBQXFNbEIsNkJBQXlCO0FBQ3hCN0ssY0FBTSxNQURrQjtBQUV4QjZHLGdCQUFRO0FBQ1BuTCxpQkFBSztBQUNKb0wscUJBQUs7QUFERCxhQURFO0FBSVA0RSxzQkFBVTtBQUNUNUUscUJBQUs7QUFESTtBQUpILFNBRmdCO0FBVXhCQSxhQUFLLHVEQVZtQjtBQVd4QixtQkFBVyxLQVhhO0FBWXhCd0Usa0JBQVUsQ0FDVCxZQURTLEVBRVQsZ0JBRlMsQ0FaYztBQWdCeEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQWhCUztBQXdCeEJVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0F4Qlk7QUE4QnhCLHlCQUFpQjtBQTlCTyxLQXJNUDtBQXFPbEIsb0JBQWdCO0FBQ2Y3SyxjQUFNLFFBRFM7QUFFZjhHLGFBQUssOENBRlU7QUFHZixtQkFBVyxDQUhJO0FBSWZrQyxpQkFBUyxDQUpNO0FBS2ZELGlCQUFTLENBTE07QUFNZm5CLG9CQUFZLElBTkc7QUFPZjBELGtCQUFVLENBQ1QsWUFEUyxDQVBLO0FBVWYsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FWQTtBQXdCZlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBeEJHO0FBZ0NmLHlCQUFpQjtBQWhDRixLQXJPRTtBQXVRbEIsa0JBQWM7QUFDYjdLLGNBQU0sT0FETztBQUViOEcsYUFBSyw4Q0FGUTtBQUdiLG1CQUFXLFNBSEU7QUFJYmMsb0JBQVksSUFKQztBQUtia0kscUJBQWEsSUFMQTtBQU1ieEUsa0JBQVUsQ0FDVCxZQURTLENBTkc7QUFTYix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVRGO0FBdUJiVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0F2QkM7QUErQmIseUJBQWlCO0FBL0JKLEtBdlFJO0FBd1NsQix1QkFBbUI7QUFDbEI3SyxjQUFNLE9BRFk7QUFFbEIsbUJBQVcsa0JBRk87QUFHbEI0SCxvQkFBWSxJQUhNO0FBSWxCZCxhQUFLLDBFQUphO0FBS2xCd0Usa0JBQVUsQ0FDVCxZQURTLENBTFE7QUFRbEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ4QixvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0Qkgsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBUFQsU0FSRztBQXNCbEJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXRCTTtBQThCbEIseUJBQWlCO0FBOUJDLEtBeFNEO0FBd1VsQix1QkFBbUI7QUFDbEI3SyxjQUFNLFFBRFk7QUFFbEIsbUJBQVcsQ0FGTztBQUdsQmdKLGlCQUFTLENBSFM7QUFJbEJwQixvQkFBWSxJQUpNO0FBS2xCUCxlQUFPLFFBTFc7QUFNbEJQLGFBQUssb0ZBTmE7QUFPbEJ3RSxrQkFBVSxDQUNULFlBRFMsQ0FQUTtBQVVsQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCSCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFQVCxTQVZHO0FBd0JsQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBeEJNO0FBZ0NsQix5QkFBaUI7QUFoQ0MsS0F4VUQ7QUEwV2xCLHNCQUFrQjtBQUNqQjdLLGNBQU0sUUFEVztBQUVqQixtQkFBVyxDQUZNO0FBR2pCZ0osaUJBQVMsQ0FIUTtBQUlqQnBCLG9CQUFZLElBSks7QUFLakJQLGVBQU8sUUFMVTtBQU1qQlAsYUFBSyxrREFOWTtBQU9qQndFLGtCQUFVLENBQ1QsWUFEUyxDQVBPO0FBVWpCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJILG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQVBULFNBVkU7QUF3QmpCVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0F4Qks7QUFnQ2pCLHlCQUFpQjtBQWhDQSxLQTFXQTtBQTRZbEIsc0JBQWtCO0FBQ2pCN0ssY0FBTSxPQURXO0FBRWpCa0gsZUFBTyxRQUZVO0FBR2pCN0wsZ0JBQVEsQ0FIUztBQUlqQixtQkFBVyxDQUNWLENBRFUsRUFFVixDQUZVLENBSk07QUFRakJ1TSxvQkFBWSxJQVJLO0FBU2pCUCxlQUFPLFFBVFU7QUFVakJQLGFBQUssNEpBVlk7QUFXakJ3RSxrQkFBVSxDQUNULFlBRFMsQ0FYTztBQWNqQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnhCLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBZEU7QUFzQmpCVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBdEJLO0FBNEJqQix5QkFBaUI7QUE1QkEsS0E1WUE7QUEwYWxCLDZCQUF5QjtBQUN4QjdLLGNBQU0sTUFEa0I7QUFFeEI2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQNEUsc0JBQVU7QUFDVDVFLHFCQUFLO0FBREk7QUFKSCxTQUZnQjtBQVV4QkEsYUFBSyx1REFWbUI7QUFXeEIsbUJBQVcsS0FYYTtBQVl4QndFLGtCQUFVLENBQ1QsWUFEUyxFQUVULGdCQUZTLENBWmM7QUFnQnhCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FoQlM7QUF3QnhCVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBeEJZO0FBOEJ4Qix5QkFBaUI7QUE5Qk87QUExYVAsQ0FBbkI7QUEyY0EsSUFBSWtGLGVBQWU7QUFDbEIsc0JBQWtCO0FBQ2pCL1AsY0FBTSxRQURXO0FBRWpCOEcsYUFBSywrQ0FGWTtBQUdqQixtQkFBVyxDQUhNO0FBSWpCa0MsaUJBQVMsQ0FKUTtBQUtqQkQsaUJBQVMsQ0FMUTtBQU1qQm5CLG9CQUFZLElBTks7QUFPakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJrQyxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVBFO0FBZWpCVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZks7QUFxQmpCLHlCQUFpQjtBQXJCQSxLQURBO0FBd0JsQix5QkFBcUI7QUFDcEI3SyxjQUFNLFFBRGM7QUFFcEIsbUJBQVcsQ0FGUztBQUdwQm9ILGdCQUFRLEdBSFk7QUFJcEJRLG9CQUFZLElBSlE7QUFLcEJQLGVBQU8sU0FMYTtBQU1wQlAsYUFBSyxzQ0FOZTtBQU9wQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBUEs7QUFlcEJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmUTtBQXFCcEIseUJBQWlCO0FBckJHLEtBeEJIO0FBK0NsQiw2QkFBeUI7QUFDeEI3SyxjQUFNLFFBRGtCO0FBRXhCOEcsYUFBSyxzRkFGbUI7QUFHeEIsbUJBQVcsQ0FIYTtBQUl4QmtDLGlCQUFTLENBSmU7QUFLeEJELGlCQUFTLENBTGU7QUFNeEJuQixvQkFBWSxJQU5ZO0FBT3hCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCa0Msb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FQUztBQWV4QlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWZZO0FBcUJ4Qix5QkFBaUI7QUFyQk8sS0EvQ1A7QUFzRWxCLDZCQUF5QjtBQUN4QjdLLGNBQU0sUUFEa0I7QUFFeEI4RyxhQUFLLHNGQUZtQjtBQUd4QixtQkFBVyxDQUhhO0FBSXhCa0MsaUJBQVMsQ0FKZTtBQUt4QkQsaUJBQVMsQ0FMZTtBQU14Qm5CLG9CQUFZLElBTlk7QUFPeEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJrQyxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVBTO0FBZXhCVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZlk7QUFxQnhCLHlCQUFpQjtBQXJCTyxLQXRFUDtBQTZGbEIseUJBQXFCO0FBQ3BCN0ssY0FBTSxRQURjO0FBRXBCOEcsYUFBSyxpREFGZTtBQUdwQixtQkFBVyxDQUhTO0FBSXBCa0MsaUJBQVMsQ0FBQyxDQUpVO0FBS3BCRCxpQkFBUyxDQUxXO0FBTXBCbkIsb0JBQVksSUFOUTtBQU9wQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmtDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBUEs7QUFlcEJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmUTtBQXFCcEIseUJBQWlCO0FBckJHLEtBN0ZIO0FBb0hsQix1QkFBbUI7QUFDbEI3SyxjQUFNLFFBRFk7QUFFbEI4RyxhQUFLLCtDQUZhO0FBR2xCLG1CQUFXLENBSE87QUFJbEJrQyxpQkFBUyxDQUFDLENBSlE7QUFLbEJELGlCQUFTLENBTFM7QUFNbEJuQixvQkFBWSxJQU5NO0FBT2xCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCa0Msb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FQRztBQWVsQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWZNO0FBcUJsQix5QkFBaUI7QUFyQkMsS0FwSEQ7QUEySWxCLHlCQUFxQjtBQUNwQjdLLGNBQU0sTUFEYztBQUVwQjhHLGFBQUssd0dBRmU7QUFHcEJELGdCQUFRO0FBQ1BtSixvQkFBUTtBQUNQbEoscUJBQUs7QUFERSxhQUREO0FBSVA5RSxxQkFBUztBQUNSOEUscUJBQUs7QUFERztBQUpGLFNBSFk7QUFXcEIsbUJBQVcsUUFYUztBQVlwQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBWks7QUFvQnBCVSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBcEJRO0FBMEJwQix5QkFBaUI7QUExQkcsS0EzSUg7QUF1S2xCLDRCQUF3QjtBQUN2QjdLLGNBQU0sUUFEaUI7QUFFdkIsbUJBQVcsR0FGWTtBQUd2QmdKLGlCQUFTLENBSGM7QUFJdkJwQixvQkFBWSxLQUpXO0FBS3ZCUCxlQUFPLGNBTGdCO0FBTXZCUCxhQUFLLHlDQU5rQjtBQU92Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBUFE7QUFldkJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmVztBQXFCdkIseUJBQWlCO0FBckJNO0FBdktOLENBQW5CO0FBK0xBLElBQUlvRixrQkFBa0I7QUFDckIsd0NBQW9DO0FBQ25DalEsY0FBTSxRQUQ2QjtBQUVuQyxtQkFBVyxHQUZ3QjtBQUduQ2dKLGlCQUFTLENBSDBCO0FBSW5DRCxpQkFBUyxHQUowQjtBQUtuQ2pDLGFBQUssZ09BTDhCO0FBTW5DYyxvQkFBWSxLQU51QjtBQU9uQyx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmtDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBUG9CO0FBZW5DVSxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZnVCO0FBcUJuQyx5QkFBaUI7QUFyQmtCLEtBRGY7QUF3QnJCLHFDQUFpQztBQUNoQzdLLGNBQU0sTUFEMEI7QUFFaEM2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQNEUsc0JBQVU7QUFDVDVFLHFCQUFLO0FBREk7QUFKSCxTQUZ3QjtBQVVoQyxtQkFBVyxVQVZxQjtBQVdoQ0EsYUFBSyxnREFYMkI7QUFZaEMsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJnRCxvQkFBSSxRQURrQjtBQUV0QkMseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEJDLHVCQUFPO0FBSmU7QUFEVCxTQVppQjtBQW9CaENVLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FwQm9CO0FBMEJoQyx5QkFBaUI7QUExQmUsS0F4Qlo7QUFvRHJCLDhCQUEwQjtBQUN6QjdLLGNBQU0sUUFEbUI7QUFFekI4RyxhQUFLLDRCQUZvQjtBQUd6QixtQkFBVyxHQUhjO0FBSXpCa0MsaUJBQVMsQ0FKZ0I7QUFLekJELGlCQUFTLENBTGdCO0FBTXpCbkIsb0JBQVksSUFOYTtBQU96Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmtDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBUFU7QUFlekJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmYTtBQXFCekIseUJBQWlCO0FBckJRLEtBcERMO0FBMkVyQiw4QkFBMEI7QUFDekI3SyxjQUFNLE9BRG1CO0FBRXpCLG1CQUFXLFNBRmM7QUFHekI4RyxhQUFLLGtFQUhvQjtBQUl6QmMsb0JBQVksSUFKYTtBQUt6Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmtDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBTFU7QUFhekJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FiYTtBQW1CekIseUJBQWlCO0FBbkJRLEtBM0VMO0FBZ0dyQixpQ0FBNkI7QUFDNUI3SyxjQUFNLE9BRHNCO0FBRTVCLG1CQUFXLFNBRmlCO0FBRzVCOEcsYUFBSyxpRUFIdUI7QUFJNUJjLG9CQUFZLElBSmdCO0FBSzVCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCa0Msb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FMYTtBQWE1QlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWJnQjtBQW1CNUIseUJBQWlCO0FBbkJXLEtBaEdSO0FBcUhyQiw4QkFBMEI7QUFDekI3SyxjQUFNLE9BRG1CO0FBRXpCLG1CQUFXLFNBRmM7QUFHekI4RyxhQUFLLG1GQUhvQjtBQUl6QmMsb0JBQVksSUFKYTtBQUt6Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmtDLG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZTtBQURULFNBTFU7QUFhekJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FiYTtBQW1CekIseUJBQWlCO0FBbkJRO0FBckhMLENBQXRCO0FBMklBLElBQUlxRixtQkFBbUI7QUFDdEIsd0JBQW9CO0FBQ25CbFEsY0FBTSxPQURhO0FBRW5CLG1CQUFXLFNBRlE7QUFHbkI4RyxhQUFLLG9EQUhjO0FBSW5CYyxvQkFBWSxJQUpPO0FBS25CMEQsa0JBQVUsQ0FDVDtBQUNDLGlCQUFLO0FBRE4sU0FEUyxDQUxTO0FBVW5CLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeEIsb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FWSTtBQWtCbkJVLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FsQk87QUF3Qm5CLHlCQUFpQjtBQXhCRSxLQURFO0FBMkJ0QiwwQkFBc0I7QUFDckI3SyxjQUFNLGVBRGU7QUFFckI0SCxvQkFBWSxJQUZTO0FBR3JCZCxhQUFLLGdQQUhnQjtBQUlyQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QmdELG9CQUFJLFFBRGtCO0FBRXRCQyx5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QkMsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBUFQsU0FKTTtBQWNyQlUsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWRTO0FBb0JyQix5QkFBaUI7QUFwQkksS0EzQkE7QUFpRHRCLDBCQUFzQjtBQUNyQjdLLGNBQU0sUUFEZTtBQUVyQixtQkFBVyxDQUZVO0FBR3JCZ0osaUJBQVMsQ0FIWTtBQUlyQkQsaUJBQVMsQ0FKWTtBQUtyQmpDLGFBQUssb0RBTGdCO0FBTXJCYyxvQkFBWSxJQU5TO0FBT3JCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCa0Msb0JBQUksUUFEa0I7QUFFdEJDLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCQyx1QkFBTztBQUplO0FBRFQsU0FQTTtBQWVyQlUsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWZTO0FBcUJyQix5QkFBaUI7QUFyQkk7QUFqREEsQ0FBdkI7QUF5RUEsSUFBSWpELGFBQWE7QUFDaEJDLGNBQVU7QUFDVDdILGNBQU0sUUFERztBQUVULG1CQUFXLEdBRkY7QUFHVGdKLGlCQUFTLENBSEE7QUFJVDNCLGVBQU8sY0FKRTtBQUtUUCxhQUFLO0FBTEksS0FETTtBQVFoQmdCLFdBQU87QUFDTjlILGNBQU0sUUFEQTtBQUVOLG1CQUFXLENBRkw7QUFHTmdKLGlCQUFTLENBSEg7QUFJTjNCLGVBQU8sY0FKRDtBQUtOUCxhQUFLO0FBTEM7QUFSUyxDQUFqQjtBQWdCQSxJQUFJdUIsWUFBWTtBQUNmLFNBQUs7QUFDSnJJLGNBQU0sUUFERjtBQUVKOEcsYUFBSztBQUZEO0FBRFUsQ0FBaEI7QUFNQSxJQUFJcUosS0FBSztBQUNSekosY0FBVUEsUUFERjtBQUVSQyxXQUFPQSxLQUZDO0FBR1I1RCxhQUFTQSxPQUhEO0FBSVJ4RixZQUFRQSxNQUpBO0FBS1J3SyxtQkFBZUEsYUFMUDtBQU1STyxtQkFBZUEsYUFOUDtBQU9SRSx1QkFBbUJBLGlCQVBYO0FBUVJJLG9CQUFnQkEsY0FSUjtBQVNSWSxrQkFBY0EsWUFUTjtBQVVSRyxrQkFBY0EsWUFWTjtBQVdSL00sV0FBT0EsS0FYQztBQVlSQyxZQUFRQSxNQVpBO0FBYVIyTix1QkFBbUJBLGlCQWJYO0FBY1JFLGlCQUFhQSxXQWRMO0FBZVJJLG1CQUFlQSxhQWZQO0FBZ0JSQyxvQkFBZ0JBLGNBaEJSO0FBaUJSLDZCQUF5QjtBQUN6Qm5LLG9CQUFZO0FBQ1haLGtCQUFNLE1BREs7QUFFWDZHLG9CQUFRO0FBQ1A1Qyx5QkFBUztBQUNSNkMseUJBQUs7QUFERyxpQkFERjtBQUlQMkQsc0JBQU07QUFDTDNELHlCQUFLO0FBREE7QUFKQyxhQUZHO0FBVVgsdUJBQVcsU0FWQTtBQVdYQSxpQkFBSyxrQ0FYTTtBQVlYLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCZ0Qsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQsYUFaSjtBQW9CWCw2QkFBaUI7QUFwQk47QUFEYSxLQWpCakI7QUF5Q1JlLGlCQUFhQSxXQXpDTDtBQTBDUk8sbUJBQWVBLGFBMUNQO0FBMkNSZ0IsbUJBQWVBLGFBM0NQO0FBNENSQyxzQkFBa0JBLGdCQTVDVjtBQTZDUmpDLFlBQVFBLE1BN0NBO0FBOENSa0MscUJBQWlCQSxlQTlDVDtBQStDUkksbUJBQWVBLGFBL0NQO0FBZ0RSLGdCQUFZO0FBQ1psQyxvQkFBWTtBQUNYM0ssa0JBQU0sWUFESztBQUVYOEcsaUJBQUs7QUFGTSxTQURBO0FBS1oxTCxlQUFPO0FBQ040RSxrQkFBTSxPQURBO0FBRU44RyxpQkFBSyxvQkFGQztBQUdOSSxtQkFBTztBQUhELFNBTEs7QUFVWmtKLGNBQU07QUFDTHBRLGtCQUFNLFFBREQ7QUFFTCx1QkFBVyxDQUZOO0FBR0xnSixxQkFBUyxDQUhKO0FBSUxsQyxpQkFBSztBQUpBLFNBVk07QUFnQlp1SixrQkFBVTtBQUNUclEsa0JBQU0sUUFERztBQUVUOEcsaUJBQUssOERBRkk7QUFHVCx1QkFBVztBQUhGLFNBaEJFO0FBcUJaOUcsY0FBTTtBQUNMQSxrQkFBTSxNQUREO0FBRUw2RyxvQkFBUTtBQUNQeUosMEJBQVU7QUFDVHhKLHlCQUFLO0FBREksaUJBREg7QUFJUHlKLDZCQUFhO0FBQ1p6Six5QkFBSztBQURPLGlCQUpOO0FBT1AwSiwwQkFBVTtBQUNUMUoseUJBQUs7QUFESSxpQkFQSDtBQVVQMkosNkJBQWE7QUFDWjNKLHlCQUFLO0FBRE87QUFWTixhQUZIO0FBZ0JMQSxpQkFBSywyREFoQkE7QUFpQkwsdUJBQVc7QUFqQk4sU0FyQk07QUF3Q1o0SixvQkFBWTtBQUNYMVEsa0JBQU0sTUFESztBQUVYNkcsb0JBQVE7QUFDUG9ILHFCQUFLO0FBQ0puSCx5QkFBSztBQURELGlCQURFO0FBSVA2SixxQkFBSztBQUNKN0oseUJBQUs7QUFERCxpQkFKRTtBQU9QOEoscUJBQUs7QUFDSjlKLHlCQUFLO0FBREQ7QUFQRSxhQUZHO0FBYVhBLGlCQUFLLHNRQWJNO0FBY1gsdUJBQVc7QUFkQSxTQXhDQTtBQXdEWixtQkFBVztBQUNWOUcsa0JBQU0sR0FESTtBQUVWNEcsc0JBQVUsS0FGQTtBQUdWRSxpQkFBSztBQUhLO0FBeERDLEtBaERKO0FBOEdSbUcsbUJBQWVBLGFBOUdQO0FBK0dSdEMsZ0JBQVlBLFVBL0dKO0FBZ0hSdUMscUJBQWlCQSxlQWhIVDtBQWlIUjNGLFdBQU9BLEtBakhDO0FBa0hSbkgsV0FBT0EsS0FsSEM7QUFtSFJxUCxnQkFBWUEsVUFuSEo7QUFvSFIsNEJBQXdCO0FBQ3hCLGtDQUEwQjtBQUN6QnpQLGtCQUFNLFFBRG1CO0FBRXpCLHVCQUFXLENBRmM7QUFHekJnSixxQkFBUyxDQUhnQjtBQUl6QkQscUJBQVMsQ0FKZ0I7QUFLekJqQyxpQkFBSyxvSkFMb0I7QUFNekJjLHdCQUFZLElBTmE7QUFPekIsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJrQyx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFEVCxhQVBVO0FBZXpCVSx3QkFBWTtBQUNYQyw4QkFBYyxJQURIO0FBRVhDLDRCQUFZLENBQ1gsTUFEVztBQUZELGFBZmE7QUFxQnpCLDZCQUFpQjtBQXJCUSxTQURGO0FBd0J4QixnQ0FBd0I7QUFDdkI3SyxrQkFBTSxPQURpQjtBQUV2Qix1QkFBVyxTQUZZO0FBR3ZCOEcsaUJBQUssbVRBSGtCO0FBSXZCYyx3QkFBWSxJQUpXO0FBS3ZCMEQsc0JBQVUsQ0FDVDtBQUNDLHFCQUFLO0FBRE4sYUFEUyxDQUxhO0FBVXZCLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCeEIsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplLGlCQURUO0FBT2QsdUNBQXVCO0FBQ3RCSCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmU7QUFQVCxhQVZRO0FBd0J2QlUsd0JBQVk7QUFDWEMsOEJBQWMsSUFESDtBQUVYQyw0QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELGFBeEJXO0FBZ0N2Qiw2QkFBaUI7QUFoQ00sU0F4QkE7QUEwRHhCLG9DQUE0QjtBQUMzQjdLLGtCQUFNLE9BRHFCO0FBRTNCa0gsbUJBQU8sUUFGb0I7QUFHM0I3TCxvQkFBUSxDQUhtQjtBQUkzQix1QkFBVyxDQUNWLENBRFUsRUFFVixDQUZVLENBSmdCO0FBUTNCdU0sd0JBQVksSUFSZTtBQVMzQlAsbUJBQU8sUUFUb0I7QUFVM0JQLGlCQUFLLGtIQVZzQjtBQVczQiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QmdELHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQURULGFBWFk7QUFtQjNCVSx3QkFBWTtBQUNYQyw4QkFBYyxJQURIO0FBRVhDLDRCQUFZLENBQ1gsTUFEVztBQUZELGFBbkJlO0FBeUIzQiw2QkFBaUI7QUF6QlUsU0ExREo7QUFxRnhCLDJDQUFtQztBQUNsQzdLLGtCQUFNLE1BRDRCO0FBRWxDNkcsb0JBQVE7QUFDUG5MLHFCQUFLO0FBQ0pvTCx5QkFBSztBQURELGlCQURFO0FBSVA0RSwwQkFBVTtBQUNUNUUseUJBQUs7QUFESTtBQUpILGFBRjBCO0FBVWxDQSxpQkFBSyxpRUFWNkI7QUFXbEMsdUJBQVcsS0FYdUI7QUFZbEN3RSxzQkFBVSxDQUNULDBCQURTLENBWndCO0FBZWxDLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCeEIsd0JBQUksUUFEa0I7QUFFdEJDLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCQywyQkFBTztBQUplO0FBRFQsYUFmbUI7QUF1QmxDVSx3QkFBWTtBQUNYQyw4QkFBYyxLQURIO0FBRVhDLDRCQUFZLENBQ1gsTUFEVztBQUZELGFBdkJzQjtBQTZCbEMsNkJBQWlCO0FBN0JpQixTQXJGWDtBQW9IeEIsa0NBQTBCO0FBQ3pCN0ssa0JBQU0sZUFEbUI7QUFFekI0SCx3QkFBWSxJQUZhO0FBR3pCZCxpQkFBSyxxUEFIb0I7QUFJekIsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJnRCx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmUsaUJBRFQ7QUFPZCx1Q0FBdUI7QUFDdEJILHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCRSwyQkFBTyxRQUhlO0FBSXRCRCx5QkFBSztBQUppQjtBQVBULGFBSlU7QUFrQnpCVyx3QkFBWTtBQUNYQyw4QkFBYyxLQURIO0FBRVhDLDRCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxhQWxCYTtBQXlCekIsNkJBQWlCO0FBekJRLFNBcEhGO0FBK0l4QixpQ0FBeUI7QUFDeEI3SyxrQkFBTSxRQURrQjtBQUV4Qix1QkFBVyxDQUZhO0FBR3hCZ0oscUJBQVMsQ0FIZTtBQUl4QjNCLG1CQUFPLFFBSmlCO0FBS3hCUCxpQkFBSyw4Q0FMbUI7QUFNeEJjLHdCQUFZLElBTlk7QUFPeEIsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJrQyx3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmUsaUJBRFQ7QUFPZCx1Q0FBdUI7QUFDdEJILHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQVBULGFBUFM7QUFxQnhCVSx3QkFBWTtBQUNYQyw4QkFBYyxJQURIO0FBRVhDLDRCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsYUFyQlk7QUE2QnhCLDZCQUFpQjtBQTdCTyxTQS9JRDtBQThLeEIsK0JBQXVCO0FBQ3RCN0ssa0JBQU0sUUFEZ0I7QUFFdEIsdUJBQVcsQ0FGVztBQUd0QmdKLHFCQUFTLENBSGE7QUFJdEIzQixtQkFBTyxRQUplO0FBS3RCUCxpQkFBSyxpSEFMaUI7QUFNdEJjLHdCQUFZLElBTlU7QUFPdEIwRCxzQkFBVSxDQUNULHVCQURTLENBUFk7QUFVdEIsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJ4Qix3QkFBSSxRQURrQjtBQUV0QkMsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEJDLDJCQUFPO0FBSmUsaUJBRFQ7QUFPZCx1Q0FBdUI7QUFDdEJILHdCQUFJLFFBRGtCO0FBRXRCQyw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QkMsMkJBQU87QUFKZTtBQVBULGFBVk87QUF3QnRCVSx3QkFBWTtBQUNYQyw4QkFBYyxJQURIO0FBRVhDLDRCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsYUF4QlU7QUFnQ3RCLDZCQUFpQjtBQWhDSyxTQTlLQztBQWdOeEIsNENBQW9DO0FBQ25DN0ssa0JBQU0sU0FENkI7QUFFbkMsdUJBQVcsSUFGd0I7QUFHbkM4RyxpQkFBSywwSUFIOEI7QUFJbkNjLHdCQUFZLEtBSnVCO0FBS25DLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCa0Msd0JBQUksUUFEa0I7QUFFdEJFLHlCQUFLLE9BRmlCO0FBR3RCQywyQkFBTztBQUhlO0FBRFQsYUFMb0I7QUFZbkNVLHdCQUFZO0FBQ1hDLDhCQUFjLEtBREg7QUFFWEMsNEJBQVksQ0FDWCxNQURXO0FBRkQsYUFadUI7QUFrQm5DLDZCQUFpQjtBQWxCa0I7QUFoTlosS0FwSGhCO0FBeVZSNkUsZ0JBQVlBLFVBelZKO0FBMFZSQyxrQkFBY0EsWUExVk47QUEyVlJDLG1CQUFlQSxhQTNWUDtBQTRWUkMsa0JBQWNBLFlBNVZOO0FBNlZSRSxrQkFBY0EsWUE3Vk47QUE4VlJFLHFCQUFpQkEsZUE5VlQ7QUErVlJDLHNCQUFrQkEsZ0JBL1ZWO0FBZ1dSdEksZ0JBQVlBLFVBaFdKO0FBaVdSLHFCQUFpQjtBQUNqQix1QkFBZTtBQUNkNUgsa0JBQU0sZUFEUTtBQUVkOEcsaUJBQUs7QUFGUyxTQURFO0FBS2pCLHVCQUFlO0FBQ2Q5RyxrQkFBTSxlQURRO0FBRWQ4RyxpQkFBSztBQUZTLFNBTEU7QUFTakIsbUNBQTJCO0FBQzFCOUcsa0JBQU0sZUFEb0I7QUFFMUI4RyxpQkFBSztBQUZxQixTQVRWO0FBYWpCLHNCQUFjO0FBQ2I5RyxrQkFBTSxlQURPO0FBRWI4RyxpQkFBSztBQUZRLFNBYkc7QUFpQmpCLHlCQUFpQjtBQUNoQjlHLGtCQUFNLGVBRFU7QUFFaEI4RyxpQkFBSztBQUZXLFNBakJBO0FBcUJqQitKLGtCQUFVO0FBQ1Q3USxrQkFBTSxlQURHO0FBRVQ4RyxpQkFBSztBQUZJO0FBckJPLEtBaldUO0FBMlhSdUIsZUFBV0E7QUEzWEgsQ0FBVDs7QUE4WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJeUksZUFBZSwyQkFBbkI7O0FBRUEsSUFBSUMsNkJBQTZCLFNBQVNDLFNBQVQsQ0FBbUJDLFNBQW5CLEVBQThCQyxPQUE5QixFQUF1QztBQUN0RSxRQUFJQyxNQUFKLEVBQVlDLFNBQVosRUFBdUJDLFFBQXZCOztBQUVBSCxjQUFVQSxXQUFXLEVBQXJCO0FBQ0FDLGFBQVN2VCxLQUFLb1QsU0FBTCxDQUNQLENBQUMsQ0FBRCxDQURPLEVBRVBoUyxTQUZPLEVBR1BrUyxRQUFRQyxNQUFSLEtBQW1CblMsU0FBbkIsR0FBK0IsQ0FBL0IsR0FBbUNrUyxRQUFRQyxNQUhwQyxFQUlQaEwsS0FKTyxDQUlELENBSkMsRUFJRSxDQUFDLENBSkgsQ0FBVDtBQUtBaUwsZ0JBQ0VELFdBQVcsRUFBWCxHQUNJRyxRQURKLEdBRUlKLFFBQVFFLFNBQVIsS0FBc0JwUyxTQUF0QixHQUNBLEVBREEsR0FFQWtTLFFBQVFFLFNBTGQ7QUFNQUMsZUFBV0gsUUFBUUcsUUFBbkI7O0FBRUEsV0FBUSxTQUFTRSxVQUFULENBQW9CQyxHQUFwQixFQUF5QkMsYUFBekIsRUFBd0NDLFFBQXhDLEVBQWtEO0FBQ3hEO0FBQ0EsWUFBSUMsR0FBSixFQUFTQyxLQUFULEVBQWdCQyxLQUFoQixFQUF1QnhOLEdBQXZCLEVBQTRCeU4sT0FBNUIsRUFBcUNDLElBQXJDLEVBQTJDMVcsTUFBM0MsRUFBbUQyVyxVQUFuRCxFQUErREMsVUFBL0QsRUFBMkVDLEtBQTNFLEVBQWtGdEUsTUFBbEYsRUFBMEYxRyxLQUExRjs7QUFFQSxZQUFJc0ssT0FBTyxPQUFPQSxJQUFJVyxNQUFYLEtBQXNCLFVBQWpDLEVBQTZDO0FBQzNDWCxrQkFBTUEsSUFBSVcsTUFBSixFQUFOO0FBQ0Q7O0FBRUR2RSxpQkFBU2hRLEtBQUtvVCxTQUFMLENBQWVRLEdBQWYsRUFBb0JILFFBQXBCLENBQVQ7O0FBRUEsWUFBSXpELFdBQVc1TyxTQUFmLEVBQTBCO0FBQ3hCLG1CQUFPNE8sTUFBUDtBQUNEOztBQUVEdlMsaUJBQVMrVixZQUFZSyxjQUFjcFcsTUFBMUIsR0FBbUNxVyxRQUE1Qzs7QUFFQSxZQUFJOUQsT0FBT3ZTLE1BQVAsSUFBaUJBLE1BQXJCLEVBQTZCO0FBQzNCNFcseUJBQWFyRSxPQUFPL1IsT0FBUCxDQUFlaVYsWUFBZixFQUE2QixVQUFTelQsS0FBVCxFQUFnQitVLGFBQWhCLEVBQStCO0FBQ3ZFLHVCQUFPQSxpQkFBaUIvVSxRQUFRLEdBQWhDO0FBQ0QsYUFGWSxDQUFiO0FBR0EsZ0JBQUk0VSxXQUFXNVcsTUFBWCxJQUFxQkEsTUFBekIsRUFBaUM7QUFDL0IsdUJBQU80VyxVQUFQO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJWixZQUFZLElBQWhCLEVBQXNCO0FBQ3BCRyxrQkFBTTVULEtBQUtDLEtBQUwsQ0FBVytQLE1BQVgsQ0FBTjtBQUNBeUQsdUJBQVdyUyxTQUFYO0FBQ0Q7O0FBRUQsWUFBSSxRQUFPd1MsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQWYsSUFBMkJBLFFBQVEsSUFBdkMsRUFBNkM7QUFDM0NRLHlCQUFhUCxnQkFBZ0JOLE1BQTdCO0FBQ0FVLG9CQUFRLEVBQVI7QUFDQUQsb0JBQVEsQ0FBUjs7QUFFQSxnQkFBSTFXLE1BQU1DLE9BQU4sQ0FBY3FXLEdBQWQsQ0FBSixFQUF3QjtBQUN0QlUsd0JBQVEsR0FBUjtBQUNBUCxzQkFBTSxHQUFOO0FBQ0F0Vyx5QkFBU21XLElBQUluVyxNQUFiO0FBQ0EsdUJBQU91VyxRQUFRdlcsTUFBZixFQUF1QnVXLE9BQXZCLEVBQWdDO0FBQzlCQywwQkFBTTdWLElBQU4sQ0FDRXVWLFdBQVdDLElBQUlJLEtBQUosQ0FBWCxFQUF1QkksVUFBdkIsRUFBbUNKLFVBQVV2VyxTQUFTLENBQW5CLEdBQXVCLENBQXZCLEdBQTJCLENBQTlELEtBQ0UsTUFGSjtBQUlEO0FBQ0YsYUFWRCxNQVVPO0FBQ0w2Vyx3QkFBUSxHQUFSO0FBQ0FQLHNCQUFNLEdBQU47QUFDQUksdUJBQU9NLE9BQU9OLElBQVAsQ0FBWVAsR0FBWixDQUFQO0FBQ0FuVyx5QkFBUzBXLEtBQUsxVyxNQUFkO0FBQ0EsdUJBQU91VyxRQUFRdlcsTUFBZixFQUF1QnVXLE9BQXZCLEVBQWdDO0FBQzlCdk4sMEJBQU0wTixLQUFLSCxLQUFMLENBQU47QUFDQUUsOEJBQVVsVSxLQUFLb1QsU0FBTCxDQUFlM00sR0FBZixJQUFzQixJQUFoQztBQUNBNkMsNEJBQVFxSyxXQUNOQyxJQUFJbk4sR0FBSixDQURNLEVBRU4yTixVQUZNLEVBR05GLFFBQVF6VyxNQUFSLElBQWtCdVcsVUFBVXZXLFNBQVMsQ0FBbkIsR0FBdUIsQ0FBdkIsR0FBMkIsQ0FBN0MsQ0FITSxDQUFSO0FBS0Esd0JBQUk2TCxVQUFVbEksU0FBZCxFQUF5QjtBQUN2QjZTLDhCQUFNN1YsSUFBTixDQUFXOFYsVUFBVTVLLEtBQXJCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELGdCQUFJMkssTUFBTXhXLE1BQU4sR0FBZSxDQUFuQixFQUFzQjtBQUNwQix1QkFBTyxDQUFDNlcsS0FBRCxFQUFRZixTQUFTVSxNQUFNekwsSUFBTixDQUFXLFFBQVE0TCxVQUFuQixDQUFqQixFQUFpREwsR0FBakQsRUFBc0R2TCxJQUF0RCxDQUNMLE9BQU9xTCxhQURGLENBQVA7QUFHRDtBQUNGOztBQUVELGVBQU83RCxNQUFQO0FBQ0QsS0F4RU0sQ0F3RUpxRCxTQXhFSSxFQXdFTyxFQXhFUCxFQXdFVyxDQXhFWCxDQUFQO0FBeUVELENBMUZEOztBQTRGQSxTQUFTcUIsVUFBVCxDQUFvQmQsR0FBcEIsRUFBeUJlLFNBQXpCLEVBQW9DO0FBQ2hDLFFBQUlDLFNBQVMsRUFBYjtBQUNBLFNBQUssSUFBSW5PLEdBQVQsSUFBZ0JrTyxTQUFoQixFQUEyQjtBQUN2QixZQUFJZixJQUFJbk4sR0FBSixNQUFhckYsU0FBakIsRUFBNEI7QUFDeEJ3VCxtQkFBT25PLEdBQVAsSUFBY21OLElBQUluTixHQUFKLENBQWQ7QUFDSDtBQUNKO0FBQ0QsU0FBSyxJQUFJb08sS0FBVCxJQUFrQmpCLEdBQWxCLEVBQXVCO0FBQ25CLFlBQUlnQixPQUFPQyxLQUFQLE1BQWtCelQsU0FBdEIsRUFBaUM7QUFDN0J3VCxtQkFBT0MsS0FBUCxJQUFnQmpCLElBQUlpQixLQUFKLENBQWhCO0FBQ0g7QUFDSjtBQUNELFdBQU9ELE1BQVA7QUFDSDtBQUNELFNBQVMxTyxNQUFULENBQWdCeEUsS0FBaEIsRUFBdUJvVCxLQUF2QixFQUE4QjtBQUMxQixRQUFJQSxVQUFVLEtBQUssQ0FBbkIsRUFDSUEsUUFBUSxDQUFSO0FBQ0pwVCxZQUFRZ1QsV0FBV2hULEtBQVgsRUFBa0I2USxHQUFHeEosS0FBckIsQ0FBUjtBQUNBLFFBQUlySCxNQUFNSSxNQUFWLEVBQWtCO0FBQ2RKLGNBQU1JLE1BQU4sR0FBZUosTUFBTUksTUFBTixDQUFhaEUsR0FBYixDQUFpQixVQUFVa0IsS0FBVixFQUFpQjtBQUM3QyxtQkFBTzBWLFdBQVcxVixLQUFYLEVBQWtCdVQsR0FBR3ZULEtBQXJCLENBQVA7QUFDSCxTQUZjLENBQWY7QUFHSDtBQUNELFdBQU9tVSwyQkFBMkJ6UixLQUEzQixFQUFrQyxFQUFFNlIsUUFBUXVCLEtBQVYsRUFBbEMsQ0FBUDtBQUNIOztBQUVELElBQUlDLGlCQUFpQixPQUFPQyxVQUFQLEtBQXNCLFdBQXRCLEdBQW9DQSxVQUFwQyxHQUFpRCxPQUFPeFUsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUMsT0FBT3lVLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDLE9BQU9DLElBQVAsS0FBZ0IsV0FBaEIsR0FBOEJBLElBQTlCLEdBQXFDLEVBQTdMOztBQUVBLFNBQVNDLGVBQVQsR0FBNEI7QUFDM0IsVUFBTSxJQUFJaFYsS0FBSixDQUFVLHdFQUFWLENBQU47QUFDQTs7QUFFRCxTQUFTaVYsb0JBQVQsQ0FBOEJDLEVBQTlCLEVBQWtDQyxNQUFsQyxFQUEwQztBQUN6QyxXQUFPQSxTQUFTLEVBQUVDLFNBQVMsRUFBWCxFQUFULEVBQTBCRixHQUFHQyxNQUFILEVBQVdBLE9BQU9DLE9BQWxCLENBQTFCLEVBQXNERCxPQUFPQyxPQUFwRTtBQUNBOztBQUVELElBQUlDLFdBQVdKLHFCQUFxQixVQUFVRSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjtBQUM5RCxlQUFTRSxJQUFULEVBQWU7O0FBRWY7QUFDQSxZQUFJQyxjQUFlSCxXQUNsQixDQUFDQSxRQUFRSSxRQURTLElBQ0dKLE9BRHRCO0FBRUEsWUFBSUssYUFBY04sVUFDakIsQ0FBQ0EsT0FBT0ssUUFEUyxJQUNHTCxNQURyQjtBQUVBLFlBQUlPLGFBQWEsUUFBT2QsY0FBUCx5Q0FBT0EsY0FBUCxNQUF5QixRQUF6QixJQUFxQ0EsY0FBdEQ7QUFDQSxZQUNDYyxXQUFXWixNQUFYLEtBQXNCWSxVQUF0QixJQUNBQSxXQUFXclYsTUFBWCxLQUFzQnFWLFVBRHRCLElBRUFBLFdBQVdYLElBQVgsS0FBb0JXLFVBSHJCLEVBSUU7QUFDREosbUJBQU9JLFVBQVA7QUFDQTs7QUFFRDs7Ozs7QUFLQSxZQUFJTCxRQUFKOzs7QUFFQTtBQUNBTSxpQkFBUyxVQUhUO0FBQUEsWUFHcUI7O0FBRXJCO0FBQ0F0RCxlQUFPLEVBTlA7QUFBQSxZQU9BdUQsT0FBTyxDQVBQO0FBQUEsWUFRQUMsT0FBTyxFQVJQO0FBQUEsWUFTQUMsT0FBTyxFQVRQO0FBQUEsWUFVQUMsT0FBTyxHQVZQO0FBQUEsWUFXQUMsY0FBYyxFQVhkO0FBQUEsWUFZQUMsV0FBVyxHQVpYO0FBQUEsWUFZZ0I7QUFDaEJDLG9CQUFZLEdBYlo7QUFBQSxZQWFpQjs7QUFFakI7QUFDQUMsd0JBQWdCLE9BaEJoQjtBQUFBLFlBaUJBQyxnQkFBZ0IsY0FqQmhCO0FBQUEsWUFpQmdDO0FBQ2hDQywwQkFBa0IsMkJBbEJsQjtBQUFBLFlBa0IrQzs7QUFFL0M7QUFDQUMsaUJBQVM7QUFDUix3QkFBWSxpREFESjtBQUVSLHlCQUFhLGdEQUZMO0FBR1IsNkJBQWlCO0FBSFQsU0FyQlQ7OztBQTJCQTtBQUNBQyx3QkFBZ0JsRSxPQUFPdUQsSUE1QnZCO0FBQUEsWUE2QkF4RSxRQUFRb0YsS0FBS3BGLEtBN0JiO0FBQUEsWUE4QkFxRixxQkFBcUJDLE9BQU9DLFlBOUI1Qjs7O0FBZ0NBO0FBQ0FyUSxXQWpDQTs7QUFtQ0E7O0FBRUE7Ozs7OztBQU1BLGlCQUFTaEYsS0FBVCxDQUFlVyxJQUFmLEVBQXFCO0FBQ3BCLGtCQUFNMlUsV0FBV04sT0FBT3JVLElBQVAsQ0FBWCxDQUFOO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUUEsaUJBQVN0RSxHQUFULENBQWEyUixLQUFiLEVBQW9CNEYsRUFBcEIsRUFBd0I7QUFDdkIsZ0JBQUk1WCxTQUFTZ1MsTUFBTWhTLE1BQW5CO0FBQ0EsZ0JBQUltWCxTQUFTLEVBQWI7QUFDQSxtQkFBT25YLFFBQVAsRUFBaUI7QUFDaEJtWCx1QkFBT25YLE1BQVAsSUFBaUI0WCxHQUFHNUYsTUFBTWhTLE1BQU4sQ0FBSCxDQUFqQjtBQUNBO0FBQ0QsbUJBQU9tWCxNQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxpQkFBU29DLFNBQVQsQ0FBbUJoSCxNQUFuQixFQUEyQnFGLEVBQTNCLEVBQStCO0FBQzlCLGdCQUFJN1YsUUFBUXdRLE9BQU9oUyxLQUFQLENBQWEsR0FBYixDQUFaO0FBQ0EsZ0JBQUk0VyxTQUFTLEVBQWI7QUFDQSxnQkFBSXBWLE1BQU0vQixNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDckI7QUFDQTtBQUNBbVgseUJBQVNwVixNQUFNLENBQU4sSUFBVyxHQUFwQjtBQUNBd1EseUJBQVN4USxNQUFNLENBQU4sQ0FBVDtBQUNBO0FBQ0Q7QUFDQXdRLHFCQUFTQSxPQUFPL1IsT0FBUCxDQUFldVksZUFBZixFQUFnQyxNQUFoQyxDQUFUO0FBQ0EsZ0JBQUlTLFNBQVNqSCxPQUFPaFMsS0FBUCxDQUFhLEdBQWIsQ0FBYjtBQUNBLGdCQUFJa1osVUFBVXBaLElBQUltWixNQUFKLEVBQVk1QixFQUFaLEVBQWdCN00sSUFBaEIsQ0FBcUIsR0FBckIsQ0FBZDtBQUNBLG1CQUFPb00sU0FBU3NDLE9BQWhCO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFhQSxpQkFBU0MsVUFBVCxDQUFvQm5ILE1BQXBCLEVBQTRCO0FBQzNCLGdCQUFJb0gsU0FBUyxFQUFiO0FBQUEsZ0JBQ0lDLFVBQVUsQ0FEZDtBQUFBLGdCQUVJNVosU0FBU3VTLE9BQU92UyxNQUZwQjtBQUFBLGdCQUdJNkwsS0FISjtBQUFBLGdCQUlJZ08sS0FKSjtBQUtBLG1CQUFPRCxVQUFVNVosTUFBakIsRUFBeUI7QUFDeEI2TCx3QkFBUTBHLE9BQU91SCxVQUFQLENBQWtCRixTQUFsQixDQUFSO0FBQ0Esb0JBQUkvTixTQUFTLE1BQVQsSUFBbUJBLFNBQVMsTUFBNUIsSUFBc0MrTixVQUFVNVosTUFBcEQsRUFBNEQ7QUFDM0Q7QUFDQTZaLDRCQUFRdEgsT0FBT3VILFVBQVAsQ0FBa0JGLFNBQWxCLENBQVI7QUFDQSx3QkFBSSxDQUFDQyxRQUFRLE1BQVQsS0FBb0IsTUFBeEIsRUFBZ0M7QUFBRTtBQUNqQ0YsK0JBQU9oWixJQUFQLENBQVksQ0FBQyxDQUFDa0wsUUFBUSxLQUFULEtBQW1CLEVBQXBCLEtBQTJCZ08sUUFBUSxLQUFuQyxJQUE0QyxPQUF4RDtBQUNBLHFCQUZELE1BRU87QUFDTjtBQUNBO0FBQ0FGLCtCQUFPaFosSUFBUCxDQUFZa0wsS0FBWjtBQUNBK047QUFDQTtBQUNELGlCQVhELE1BV087QUFDTkQsMkJBQU9oWixJQUFQLENBQVlrTCxLQUFaO0FBQ0E7QUFDRDtBQUNELG1CQUFPOE4sTUFBUDtBQUNBOztBQUVEOzs7Ozs7OztBQVFBLGlCQUFTSSxVQUFULENBQW9CL0gsS0FBcEIsRUFBMkI7QUFDMUIsbUJBQU8zUixJQUFJMlIsS0FBSixFQUFXLFVBQVNuRyxLQUFULEVBQWdCO0FBQ2pDLG9CQUFJOE4sU0FBUyxFQUFiO0FBQ0Esb0JBQUk5TixRQUFRLE1BQVosRUFBb0I7QUFDbkJBLDZCQUFTLE9BQVQ7QUFDQThOLDhCQUFVUixtQkFBbUJ0TixVQUFVLEVBQVYsR0FBZSxLQUFmLEdBQXVCLE1BQTFDLENBQVY7QUFDQUEsNEJBQVEsU0FBU0EsUUFBUSxLQUF6QjtBQUNBO0FBQ0Q4TiwwQkFBVVIsbUJBQW1CdE4sS0FBbkIsQ0FBVjtBQUNBLHVCQUFPOE4sTUFBUDtBQUNBLGFBVE0sRUFTSjVPLElBVEksQ0FTQyxFQVRELENBQVA7QUFVQTs7QUFFRDs7Ozs7Ozs7O0FBU0EsaUJBQVNpUCxZQUFULENBQXNCQyxTQUF0QixFQUFpQztBQUNoQyxnQkFBSUEsWUFBWSxFQUFaLEdBQWlCLEVBQXJCLEVBQXlCO0FBQ3hCLHVCQUFPQSxZQUFZLEVBQW5CO0FBQ0E7QUFDRCxnQkFBSUEsWUFBWSxFQUFaLEdBQWlCLEVBQXJCLEVBQXlCO0FBQ3hCLHVCQUFPQSxZQUFZLEVBQW5CO0FBQ0E7QUFDRCxnQkFBSUEsWUFBWSxFQUFaLEdBQWlCLEVBQXJCLEVBQXlCO0FBQ3hCLHVCQUFPQSxZQUFZLEVBQW5CO0FBQ0E7QUFDRCxtQkFBT2xGLElBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQSxpQkFBU21GLFlBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCQyxJQUE3QixFQUFtQztBQUNsQztBQUNBO0FBQ0EsbUJBQU9ELFFBQVEsRUFBUixHQUFhLE1BQU1BLFFBQVEsRUFBZCxDQUFiLElBQWtDLENBQUNDLFFBQVEsQ0FBVCxLQUFlLENBQWpELENBQVA7QUFDQTs7QUFFRDs7Ozs7QUFLQSxpQkFBU0MsS0FBVCxDQUFlQyxLQUFmLEVBQXNCQyxTQUF0QixFQUFpQ0MsU0FBakMsRUFBNEM7QUFDM0MsZ0JBQUlDLElBQUksQ0FBUjtBQUNBSCxvQkFBUUUsWUFBWTFHLE1BQU13RyxRQUFRN0IsSUFBZCxDQUFaLEdBQWtDNkIsU0FBUyxDQUFuRDtBQUNBQSxxQkFBU3hHLE1BQU13RyxRQUFRQyxTQUFkLENBQVQ7QUFDQSxtQkFBSyx1QkFBeUJELFFBQVFyQixnQkFBZ0JWLElBQWhCLElBQXdCLENBQTlELEVBQWlFa0MsS0FBSzFGLElBQXRFLEVBQTRFO0FBQzNFdUYsd0JBQVF4RyxNQUFNd0csUUFBUXJCLGFBQWQsQ0FBUjtBQUNBO0FBQ0QsbUJBQU9uRixNQUFNMkcsSUFBSSxDQUFDeEIsZ0JBQWdCLENBQWpCLElBQXNCcUIsS0FBdEIsSUFBK0JBLFFBQVE5QixJQUF2QyxDQUFWLENBQVA7QUFDQTs7QUFFRDs7Ozs7OztBQU9BLGlCQUFTa0MsTUFBVCxDQUFnQkMsS0FBaEIsRUFBdUI7QUFDdEI7QUFDQSxnQkFBSWhCLFNBQVMsRUFBYjtBQUFBLGdCQUNJaUIsY0FBY0QsTUFBTTNhLE1BRHhCO0FBQUEsZ0JBRUk2YSxHQUZKO0FBQUEsZ0JBR0lsYixJQUFJLENBSFI7QUFBQSxnQkFJSW1iLElBQUluQyxRQUpSO0FBQUEsZ0JBS0lvQyxPQUFPckMsV0FMWDtBQUFBLGdCQU1Jc0MsS0FOSjtBQUFBLGdCQU9JQyxDQVBKO0FBQUEsZ0JBUUkxRSxLQVJKO0FBQUEsZ0JBU0kyRSxJQVRKO0FBQUEsZ0JBVUlDLENBVko7QUFBQSxnQkFXSVYsQ0FYSjtBQUFBLGdCQVlJTixLQVpKO0FBQUEsZ0JBYUlpQixDQWJKOztBQWNJO0FBQ0FDLHNCQWZKOztBQWlCQTtBQUNBO0FBQ0E7O0FBRUFMLG9CQUFRTCxNQUFNVyxXQUFOLENBQWtCMUMsU0FBbEIsQ0FBUjtBQUNBLGdCQUFJb0MsUUFBUSxDQUFaLEVBQWU7QUFDZEEsd0JBQVEsQ0FBUjtBQUNBOztBQUVELGlCQUFLQyxJQUFJLENBQVQsRUFBWUEsSUFBSUQsS0FBaEIsRUFBdUIsRUFBRUMsQ0FBekIsRUFBNEI7QUFDM0I7QUFDQSxvQkFBSU4sTUFBTWIsVUFBTixDQUFpQm1CLENBQWpCLEtBQXVCLElBQTNCLEVBQWlDO0FBQ2hDalgsMEJBQU0sV0FBTjtBQUNBO0FBQ0QyVix1QkFBT2haLElBQVAsQ0FBWWdhLE1BQU1iLFVBQU4sQ0FBaUJtQixDQUFqQixDQUFaO0FBQ0E7O0FBRUQ7QUFDQTs7QUFFQSxpQkFBSzFFLFFBQVF5RSxRQUFRLENBQVIsR0FBWUEsUUFBUSxDQUFwQixHQUF3QixDQUFyQyxFQUF3Q3pFLFFBQVFxRSxXQUFoRCxHQUE2RCx5QkFBMkI7O0FBRXZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBS00sT0FBT3ZiLENBQVAsRUFBVXdiLElBQUksQ0FBZCxFQUFpQlYsSUFBSTFGLElBQTFCLEdBQWdDLGtCQUFvQjBGLEtBQUsxRixJQUF6RCxFQUErRDs7QUFFOUQsd0JBQUl3QixTQUFTcUUsV0FBYixFQUEwQjtBQUN6QjVXLDhCQUFNLGVBQU47QUFDQTs7QUFFRG1XLDRCQUFRSCxhQUFhVyxNQUFNYixVQUFOLENBQWlCdkQsT0FBakIsQ0FBYixDQUFSOztBQUVBLHdCQUFJNEQsU0FBU3BGLElBQVQsSUFBaUJvRixRQUFRckcsTUFBTSxDQUFDdUUsU0FBUzFZLENBQVYsSUFBZXdiLENBQXJCLENBQTdCLEVBQXNEO0FBQ3JEblgsOEJBQU0sVUFBTjtBQUNBOztBQUVEckUseUJBQUt3YSxRQUFRZ0IsQ0FBYjtBQUNBQyx3QkFBSVgsS0FBS00sSUFBTCxHQUFZekMsSUFBWixHQUFvQm1DLEtBQUtNLE9BQU94QyxJQUFaLEdBQW1CQSxJQUFuQixHQUEwQmtDLElBQUlNLElBQXREOztBQUVBLHdCQUFJWixRQUFRaUIsQ0FBWixFQUFlO0FBQ2Q7QUFDQTs7QUFFREMsaUNBQWF0RyxPQUFPcUcsQ0FBcEI7QUFDQSx3QkFBSUQsSUFBSXJILE1BQU11RSxTQUFTZ0QsVUFBZixDQUFSLEVBQW9DO0FBQ25DclgsOEJBQU0sVUFBTjtBQUNBOztBQUVEbVgseUJBQUtFLFVBQUw7QUFFQTs7QUFFRFIsc0JBQU1sQixPQUFPM1osTUFBUCxHQUFnQixDQUF0QjtBQUNBK2EsdUJBQU9WLE1BQU0xYSxJQUFJdWIsSUFBVixFQUFnQkwsR0FBaEIsRUFBcUJLLFFBQVEsQ0FBN0IsQ0FBUDs7QUFFQTtBQUNBO0FBQ0Esb0JBQUlwSCxNQUFNblUsSUFBSWtiLEdBQVYsSUFBaUJ4QyxTQUFTeUMsQ0FBOUIsRUFBaUM7QUFDaEM5VywwQkFBTSxVQUFOO0FBQ0E7O0FBRUQ4VyxxQkFBS2hILE1BQU1uVSxJQUFJa2IsR0FBVixDQUFMO0FBQ0FsYixxQkFBS2tiLEdBQUw7O0FBRUE7QUFDQWxCLHVCQUFPNEIsTUFBUCxDQUFjNWIsR0FBZCxFQUFtQixDQUFuQixFQUFzQm1iLENBQXRCO0FBRUE7O0FBRUQsbUJBQU9mLFdBQVdKLE1BQVgsQ0FBUDtBQUNBOztBQUVEOzs7Ozs7O0FBT0EsaUJBQVM2QixNQUFULENBQWdCYixLQUFoQixFQUF1QjtBQUN0QixnQkFBSUcsQ0FBSjtBQUFBLGdCQUNJUixLQURKO0FBQUEsZ0JBRUltQixjQUZKO0FBQUEsZ0JBR0lDLFdBSEo7QUFBQSxnQkFJSVgsSUFKSjtBQUFBLGdCQUtJRSxDQUxKO0FBQUEsZ0JBTUlVLENBTko7QUFBQSxnQkFPSUMsQ0FQSjtBQUFBLGdCQVFJbkIsQ0FSSjtBQUFBLGdCQVNJVyxDQVRKO0FBQUEsZ0JBVUlTLFlBVko7QUFBQSxnQkFXSWxDLFNBQVMsRUFYYjs7QUFZSTtBQUNBaUIsdUJBYko7O0FBY0k7QUFDQWtCLGlDQWZKO0FBQUEsZ0JBZ0JJVCxVQWhCSjtBQUFBLGdCQWlCSVUsT0FqQko7O0FBbUJBO0FBQ0FwQixvQkFBUWpCLFdBQVdpQixLQUFYLENBQVI7O0FBRUE7QUFDQUMsMEJBQWNELE1BQU0zYSxNQUFwQjs7QUFFQTtBQUNBOGEsZ0JBQUluQyxRQUFKO0FBQ0EyQixvQkFBUSxDQUFSO0FBQ0FTLG1CQUFPckMsV0FBUDs7QUFFQTtBQUNBLGlCQUFLdUMsSUFBSSxDQUFULEVBQVlBLElBQUlMLFdBQWhCLEVBQTZCLEVBQUVLLENBQS9CLEVBQWtDO0FBQ2pDWSwrQkFBZWxCLE1BQU1NLENBQU4sQ0FBZjtBQUNBLG9CQUFJWSxlQUFlLElBQW5CLEVBQXlCO0FBQ3hCbEMsMkJBQU9oWixJQUFQLENBQVl3WSxtQkFBbUIwQyxZQUFuQixDQUFaO0FBQ0E7QUFDRDs7QUFFREosNkJBQWlCQyxjQUFjL0IsT0FBTzNaLE1BQXRDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBSTBiLFdBQUosRUFBaUI7QUFDaEIvQix1QkFBT2haLElBQVAsQ0FBWWlZLFNBQVo7QUFDQTs7QUFFRDtBQUNBLG1CQUFPNkMsaUJBQWlCYixXQUF4QixFQUFxQzs7QUFFcEM7QUFDQTtBQUNBLHFCQUFLZSxJQUFJdEQsTUFBSixFQUFZNEMsSUFBSSxDQUFyQixFQUF3QkEsSUFBSUwsV0FBNUIsRUFBeUMsRUFBRUssQ0FBM0MsRUFBOEM7QUFDN0NZLG1DQUFlbEIsTUFBTU0sQ0FBTixDQUFmO0FBQ0Esd0JBQUlZLGdCQUFnQmYsQ0FBaEIsSUFBcUJlLGVBQWVGLENBQXhDLEVBQTJDO0FBQzFDQSw0QkFBSUUsWUFBSjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBQyx3Q0FBd0JMLGlCQUFpQixDQUF6QztBQUNBLG9CQUFJRSxJQUFJYixDQUFKLEdBQVFoSCxNQUFNLENBQUN1RSxTQUFTaUMsS0FBVixJQUFtQndCLHFCQUF6QixDQUFaLEVBQTZEO0FBQzVEOVgsMEJBQU0sVUFBTjtBQUNBOztBQUVEc1cseUJBQVMsQ0FBQ3FCLElBQUliLENBQUwsSUFBVWdCLHFCQUFuQjtBQUNBaEIsb0JBQUlhLENBQUo7O0FBRUEscUJBQUtWLElBQUksQ0FBVCxFQUFZQSxJQUFJTCxXQUFoQixFQUE2QixFQUFFSyxDQUEvQixFQUFrQztBQUNqQ1ksbUNBQWVsQixNQUFNTSxDQUFOLENBQWY7O0FBRUEsd0JBQUlZLGVBQWVmLENBQWYsSUFBb0IsRUFBRVIsS0FBRixHQUFVakMsTUFBbEMsRUFBMEM7QUFDekNyVSw4QkFBTSxVQUFOO0FBQ0E7O0FBRUQsd0JBQUk2WCxnQkFBZ0JmLENBQXBCLEVBQXVCO0FBQ3RCO0FBQ0EsNkJBQUtjLElBQUl0QixLQUFKLEVBQVdHLElBQUkxRixJQUFwQixHQUEwQixrQkFBb0IwRixLQUFLMUYsSUFBbkQsRUFBeUQ7QUFDeERxRyxnQ0FBSVgsS0FBS00sSUFBTCxHQUFZekMsSUFBWixHQUFvQm1DLEtBQUtNLE9BQU94QyxJQUFaLEdBQW1CQSxJQUFuQixHQUEwQmtDLElBQUlNLElBQXREO0FBQ0EsZ0NBQUlhLElBQUlSLENBQVIsRUFBVztBQUNWO0FBQ0E7QUFDRFcsc0NBQVVILElBQUlSLENBQWQ7QUFDQUMseUNBQWF0RyxPQUFPcUcsQ0FBcEI7QUFDQXpCLG1DQUFPaFosSUFBUCxDQUNDd1ksbUJBQW1CZSxhQUFha0IsSUFBSVcsVUFBVVYsVUFBM0IsRUFBdUMsQ0FBdkMsQ0FBbkIsQ0FERDtBQUdBTyxnQ0FBSTlILE1BQU1pSSxVQUFVVixVQUFoQixDQUFKO0FBQ0E7O0FBRUQxQiwrQkFBT2haLElBQVAsQ0FBWXdZLG1CQUFtQmUsYUFBYTBCLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBbkIsQ0FBWjtBQUNBYiwrQkFBT1YsTUFBTUMsS0FBTixFQUFhd0IscUJBQWIsRUFBb0NMLGtCQUFrQkMsV0FBdEQsQ0FBUDtBQUNBcEIsZ0NBQVEsQ0FBUjtBQUNBLDBCQUFFbUIsY0FBRjtBQUNBO0FBQ0Q7O0FBRUQsa0JBQUVuQixLQUFGO0FBQ0Esa0JBQUVRLENBQUY7QUFFQTtBQUNELG1CQUFPbkIsT0FBTzVPLElBQVAsQ0FBWSxFQUFaLENBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQSxpQkFBU2lSLFNBQVQsQ0FBbUJyQixLQUFuQixFQUEwQjtBQUN6QixtQkFBT3BCLFVBQVVvQixLQUFWLEVBQWlCLFVBQVNwSSxNQUFULEVBQWlCO0FBQ3hDLHVCQUFPc0csY0FBY29ELElBQWQsQ0FBbUIxSixNQUFuQixJQUNKbUksT0FBT25JLE9BQU96SCxLQUFQLENBQWEsQ0FBYixFQUFnQm9SLFdBQWhCLEVBQVAsQ0FESSxHQUVKM0osTUFGSDtBQUdBLGFBSk0sQ0FBUDtBQUtBOztBQUVEOzs7Ozs7Ozs7OztBQVdBLGlCQUFTNEosT0FBVCxDQUFpQnhCLEtBQWpCLEVBQXdCO0FBQ3ZCLG1CQUFPcEIsVUFBVW9CLEtBQVYsRUFBaUIsVUFBU3BJLE1BQVQsRUFBaUI7QUFDeEMsdUJBQU91RyxjQUFjbUQsSUFBZCxDQUFtQjFKLE1BQW5CLElBQ0osU0FBU2lKLE9BQU9qSixNQUFQLENBREwsR0FFSkEsTUFGSDtBQUdBLGFBSk0sQ0FBUDtBQUtBOztBQUVEOztBQUVBO0FBQ0F3RixtQkFBVztBQUNWOzs7OztBQUtBLHVCQUFXLE9BTkQ7QUFPVjs7Ozs7OztBQU9BLG9CQUFRO0FBQ1AsMEJBQVUyQixVQURIO0FBRVAsMEJBQVVLO0FBRkgsYUFkRTtBQWtCVixzQkFBVVcsTUFsQkE7QUFtQlYsc0JBQVVjLE1BbkJBO0FBb0JWLHVCQUFXVyxPQXBCRDtBQXFCVix5QkFBYUg7QUFyQkgsU0FBWDs7QUF3QkE7QUFDQTtBQUNBO0FBQ0EsWUFBSS9ELGVBQWVFLFVBQW5CLEVBQStCO0FBQzlCLGdCQUFJTixPQUFPQyxPQUFQLElBQWtCRyxXQUF0QixFQUFtQztBQUFFO0FBQ3BDRSwyQkFBV0wsT0FBWCxHQUFxQkMsUUFBckI7QUFDQSxhQUZELE1BRU87QUFBRTtBQUNSLHFCQUFLL08sR0FBTCxJQUFZK08sUUFBWixFQUFzQjtBQUNyQkEsNkJBQVNxRSxjQUFULENBQXdCcFQsR0FBeEIsTUFBaUNpUCxZQUFZalAsR0FBWixJQUFtQitPLFNBQVMvTyxHQUFULENBQXBEO0FBQ0E7QUFDRDtBQUNELFNBUkQsTUFRTztBQUFFO0FBQ1JnUCxpQkFBS0QsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQTtBQUVELEtBeGdCQSxFQXdnQkNULGNBeGdCRCxDQUFEO0FBeWdCQyxDQTFnQmMsQ0FBZjs7QUE0Z0JBLElBQUkrRSxPQUFPO0FBQ1RDLGNBQVUsa0JBQVNDLEdBQVQsRUFBYztBQUN0QixlQUFPLE9BQU9BLEdBQVAsS0FBZ0IsUUFBdkI7QUFDRCxLQUhRO0FBSVRDLGNBQVUsa0JBQVNELEdBQVQsRUFBYztBQUN0QixlQUFPLFFBQU9BLEdBQVAseUNBQU9BLEdBQVAsT0FBZ0IsUUFBaEIsSUFBNEJBLFFBQVEsSUFBM0M7QUFDRCxLQU5RO0FBT1RFLFlBQVEsZ0JBQVNGLEdBQVQsRUFBYztBQUNwQixlQUFPQSxRQUFRLElBQWY7QUFDRCxLQVRRO0FBVVRHLHVCQUFtQiwyQkFBU0gsR0FBVCxFQUFjO0FBQy9CLGVBQU9BLE9BQU8sSUFBZDtBQUNEO0FBWlEsQ0FBWDs7QUFlQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTSCxjQUFULENBQXdCakcsR0FBeEIsRUFBNkJ3RyxJQUE3QixFQUFtQztBQUNqQyxXQUFPM0YsT0FBTzRGLFNBQVAsQ0FBaUJSLGNBQWpCLENBQWdDUyxJQUFoQyxDQUFxQzFHLEdBQXJDLEVBQTBDd0csSUFBMUMsQ0FBUDtBQUNEOztBQUVELElBQUlqQyxTQUFTLFNBQVRBLE1BQVMsQ0FBU29DLEVBQVQsRUFBYUMsR0FBYixFQUFrQkMsRUFBbEIsRUFBc0JuSCxPQUF0QixFQUErQjtBQUMxQ2tILFVBQU1BLE9BQU8sR0FBYjtBQUNBQyxTQUFLQSxNQUFNLEdBQVg7QUFDQSxRQUFJN0csTUFBTSxFQUFWOztBQUVBLFFBQUksT0FBTzJHLEVBQVAsS0FBYyxRQUFkLElBQTBCQSxHQUFHOWMsTUFBSCxLQUFjLENBQTVDLEVBQStDO0FBQzdDLGVBQU9tVyxHQUFQO0FBQ0Q7O0FBRUQsUUFBSThHLFNBQVMsS0FBYjtBQUNBSCxTQUFLQSxHQUFHdmMsS0FBSCxDQUFTd2MsR0FBVCxDQUFMOztBQUVBLFFBQUlHLFVBQVUsSUFBZDtBQUNBLFFBQUlySCxXQUFXLE9BQU9BLFFBQVFxSCxPQUFmLEtBQTJCLFFBQTFDLEVBQW9EO0FBQ2xEQSxrQkFBVXJILFFBQVFxSCxPQUFsQjtBQUNEOztBQUVELFFBQUlDLE1BQU1MLEdBQUc5YyxNQUFiO0FBQ0E7QUFDQSxRQUFJa2QsVUFBVSxDQUFWLElBQWVDLE1BQU1ELE9BQXpCLEVBQWtDO0FBQ2hDQyxjQUFNRCxPQUFOO0FBQ0Q7O0FBRUQsU0FBSyxJQUFJdmQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJd2QsR0FBcEIsRUFBeUIsRUFBRXhkLENBQTNCLEVBQThCO0FBQzVCLFlBQUl5ZCxJQUFJTixHQUFHbmQsQ0FBSCxFQUFNYSxPQUFOLENBQWN5YyxNQUFkLEVBQXNCLEtBQXRCLENBQVI7QUFBQSxZQUNJSSxNQUFNRCxFQUFFMWMsT0FBRixDQUFVc2MsRUFBVixDQURWO0FBQUEsWUFFSU0sSUFGSjtBQUFBLFlBRVVDLElBRlY7QUFBQSxZQUVnQjlDLENBRmhCO0FBQUEsWUFFbUIrQyxDQUZuQjs7QUFJQSxZQUFJSCxPQUFPLENBQVgsRUFBYztBQUNaQyxtQkFBT0YsRUFBRXBTLE1BQUYsQ0FBUyxDQUFULEVBQVlxUyxHQUFaLENBQVA7QUFDQUUsbUJBQU9ILEVBQUVwUyxNQUFGLENBQVNxUyxNQUFNLENBQWYsQ0FBUDtBQUNELFNBSEQsTUFHTztBQUNMQyxtQkFBT0YsQ0FBUDtBQUNBRyxtQkFBTyxFQUFQO0FBQ0Q7O0FBRUQ5QyxZQUFJZ0QsbUJBQW1CSCxJQUFuQixDQUFKO0FBQ0FFLFlBQUlDLG1CQUFtQkYsSUFBbkIsQ0FBSjs7QUFFQSxZQUFJLENBQUNuQixlQUFlakcsR0FBZixFQUFvQnNFLENBQXBCLENBQUwsRUFBNkI7QUFDM0J0RSxnQkFBSXNFLENBQUosSUFBUytDLENBQVQ7QUFDRCxTQUZELE1BRU8sSUFBSTNkLE1BQU1DLE9BQU4sQ0FBY3FXLElBQUlzRSxDQUFKLENBQWQsQ0FBSixFQUEyQjtBQUNoQ3RFLGdCQUFJc0UsQ0FBSixFQUFPOVosSUFBUCxDQUFZNmMsQ0FBWjtBQUNELFNBRk0sTUFFQTtBQUNMckgsZ0JBQUlzRSxDQUFKLElBQVMsQ0FBQ3RFLElBQUlzRSxDQUFKLENBQUQsRUFBUytDLENBQVQsQ0FBVDtBQUNEO0FBQ0Y7O0FBRUQsV0FBT3JILEdBQVA7QUFDRCxDQWpERDs7QUFtREE7O0FBRUEsSUFBSXVILHFCQUFxQixTQUFyQkEsa0JBQXFCLENBQVNGLENBQVQsRUFBWTtBQUNuQyxtQkFBZUEsQ0FBZix5Q0FBZUEsQ0FBZjtBQUNFLGFBQUssUUFBTDtBQUNFLG1CQUFPQSxDQUFQOztBQUVGLGFBQUssU0FBTDtBQUNFLG1CQUFPQSxJQUFJLE1BQUosR0FBYSxPQUFwQjs7QUFFRixhQUFLLFFBQUw7QUFDRSxtQkFBT0csU0FBU0gsQ0FBVCxJQUFjQSxDQUFkLEdBQWtCLEVBQXpCOztBQUVGO0FBQ0UsbUJBQU8sRUFBUDtBQVhKO0FBYUQsQ0FkRDs7QUFnQkEsSUFBSWhDLFNBQVMsU0FBVEEsTUFBUyxDQUFTckYsR0FBVCxFQUFjNEcsR0FBZCxFQUFtQkMsRUFBbkIsRUFBdUJyUixJQUF2QixFQUE2QjtBQUN4Q29SLFVBQU1BLE9BQU8sR0FBYjtBQUNBQyxTQUFLQSxNQUFNLEdBQVg7QUFDQSxRQUFJN0csUUFBUSxJQUFaLEVBQWtCO0FBQ2hCQSxjQUFNeFMsU0FBTjtBQUNEOztBQUVELFFBQUksUUFBT3dTLEdBQVAseUNBQU9BLEdBQVAsT0FBZSxRQUFuQixFQUE2QjtBQUMzQixlQUFPYSxPQUFPTixJQUFQLENBQVlQLEdBQVosRUFBaUI5VixHQUFqQixDQUFxQixVQUFTb2EsQ0FBVCxFQUFZO0FBQ3RDLGdCQUFJbUQsS0FBS0MsbUJBQW1CSCxtQkFBbUJqRCxDQUFuQixDQUFuQixJQUE0Q3VDLEVBQXJEO0FBQ0EsZ0JBQUluZCxNQUFNQyxPQUFOLENBQWNxVyxJQUFJc0UsQ0FBSixDQUFkLENBQUosRUFBMkI7QUFDekIsdUJBQU90RSxJQUFJc0UsQ0FBSixFQUFPcGEsR0FBUCxDQUFXLFVBQVNtZCxDQUFULEVBQVk7QUFDNUIsMkJBQU9JLEtBQUtDLG1CQUFtQkgsbUJBQW1CRixDQUFuQixDQUFuQixDQUFaO0FBQ0QsaUJBRk0sRUFFSnpTLElBRkksQ0FFQ2dTLEdBRkQsQ0FBUDtBQUdELGFBSkQsTUFJTztBQUNMLHVCQUFPYSxLQUFLQyxtQkFBbUJILG1CQUFtQnZILElBQUlzRSxDQUFKLENBQW5CLENBQW5CLENBQVo7QUFDRDtBQUNGLFNBVE0sRUFTSjFQLElBVEksQ0FTQ2dTLEdBVEQsQ0FBUDtBQVdEOztBQUVELFFBQUksQ0FBQ3BSLElBQUwsRUFBVztBQUFFLGVBQU8sRUFBUDtBQUFZO0FBQ3pCLFdBQU9rUyxtQkFBbUJILG1CQUFtQi9SLElBQW5CLENBQW5CLElBQStDcVIsRUFBL0MsR0FDQWEsbUJBQW1CSCxtQkFBbUJ2SCxHQUFuQixDQUFuQixDQURQO0FBRUQsQ0F4QkQ7O0FBMEJBLElBQUkySCxjQUFjbkcscUJBQXFCLFVBQVVFLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCOztBQUVsRUEsWUFBUTRDLE1BQVIsR0FBaUI1QyxRQUFRdFYsS0FBUixHQUFnQmtZLE1BQWpDO0FBQ0E1QyxZQUFRMEQsTUFBUixHQUFpQjFELFFBQVFuQyxTQUFSLEdBQW9CNkYsTUFBckM7QUFDQyxDQUppQixDQUFsQjtBQUtBLElBQUl1QyxnQkFBZ0JELFlBQVlwRCxNQUFoQztBQUNBLElBQUlzRCxnQkFBZ0JGLFlBQVl0YixLQUFoQztBQUNBLElBQUl5YixnQkFBZ0JILFlBQVl0QyxNQUFoQztBQUNBLElBQUkwQyxnQkFBZ0JKLFlBQVluSSxTQUFoQzs7QUFFQSxJQUFJblQsUUFBUTJiLFFBQVo7QUFDQSxJQUFJOWIsVUFBVStiLFVBQWQ7QUFDQSxJQUFJQyxnQkFBZ0JDLGdCQUFwQjtBQUNBLElBQUlDLFdBQVdDLFNBQWY7O0FBRUEsSUFBSUMsUUFBUUMsR0FBWjs7QUFFQSxTQUFTQSxHQUFULEdBQWU7QUFDYixTQUFLQyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxTQUFLQyxJQUFMLEdBQVksSUFBWjtBQUNBLFNBQUs1WSxJQUFMLEdBQVksSUFBWjtBQUNBLFNBQUs2WSxJQUFMLEdBQVksSUFBWjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxTQUFLQyxJQUFMLEdBQVksSUFBWjtBQUNBLFNBQUtDLE1BQUwsR0FBYyxJQUFkO0FBQ0EsU0FBS0MsS0FBTCxHQUFhLElBQWI7QUFDQSxTQUFLclUsUUFBTCxHQUFnQixJQUFoQjtBQUNBLFNBQUtqSixJQUFMLEdBQVksSUFBWjtBQUNBLFNBQUtYLElBQUwsR0FBWSxJQUFaO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLElBQUlrZSxrQkFBa0IsbUJBQXRCO0FBQUEsSUFDSUMsY0FBYyxVQURsQjs7O0FBR0k7QUFDQUMsb0JBQW9CLG9DQUp4Qjs7O0FBTUk7QUFDQTtBQUNBQyxTQUFTLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLEVBQTBCLElBQTFCLEVBQWdDLElBQWhDLEVBQXNDLElBQXRDLENBUmI7OztBQVVJO0FBQ0FDLFNBQVMsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsSUFBaEIsRUFBc0IsR0FBdEIsRUFBMkIsR0FBM0IsRUFBZ0NyTCxNQUFoQyxDQUF1Q29MLE1BQXZDLENBWGI7OztBQWFJO0FBQ0FFLGFBQWEsQ0FBQyxJQUFELEVBQU90TCxNQUFQLENBQWNxTCxNQUFkLENBZGpCOztBQWVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0FFLGVBQWUsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsRUFBMEJ2TCxNQUExQixDQUFpQ3NMLFVBQWpDLENBbkJuQjtBQUFBLElBb0JJRSxrQkFBa0IsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsQ0FwQnRCO0FBQUEsSUFxQklDLGlCQUFpQixHQXJCckI7QUFBQSxJQXNCSUMsc0JBQXNCLHdCQXRCMUI7QUFBQSxJQXVCSUMsb0JBQW9CLDhCQXZCeEI7O0FBd0JJO0FBQ0FDLGlCQUFpQjtBQUNmLGtCQUFjLElBREM7QUFFZixtQkFBZTtBQUZBLENBekJyQjs7QUE2Qkk7QUFDQUMsbUJBQW1CO0FBQ2pCLGtCQUFjLElBREc7QUFFakIsbUJBQWU7QUFGRSxDQTlCdkI7O0FBa0NJO0FBQ0FDLGtCQUFrQjtBQUNoQixZQUFRLElBRFE7QUFFaEIsYUFBUyxJQUZPO0FBR2hCLFdBQU8sSUFIUztBQUloQixjQUFVLElBSk07QUFLaEIsWUFBUSxJQUxRO0FBTWhCLGFBQVMsSUFOTztBQU9oQixjQUFVLElBUE07QUFRaEIsWUFBUSxJQVJRO0FBU2hCLGVBQVcsSUFUSztBQVVoQixhQUFTO0FBVk8sQ0FuQ3RCOztBQWdEQSxTQUFTN0IsUUFBVCxDQUFrQnhjLEdBQWxCLEVBQXVCc2UsZ0JBQXZCLEVBQXlDQyxpQkFBekMsRUFBNEQ7QUFDMUQsUUFBSXZlLE9BQU8wYSxLQUFLRyxRQUFMLENBQWM3YSxHQUFkLENBQVAsSUFBNkJBLGVBQWUrYyxHQUFoRCxFQUFxRDtBQUFFLGVBQU8vYyxHQUFQO0FBQWE7O0FBRXBFLFFBQUl3ZSxJQUFJLElBQUl6QixHQUFKLEVBQVI7QUFDQXlCLE1BQUUzZCxLQUFGLENBQVFiLEdBQVIsRUFBYXNlLGdCQUFiLEVBQStCQyxpQkFBL0I7QUFDQSxXQUFPQyxDQUFQO0FBQ0Q7O0FBRUR6QixJQUFJOUIsU0FBSixDQUFjcGEsS0FBZCxHQUFzQixVQUFTYixHQUFULEVBQWNzZSxnQkFBZCxFQUFnQ0MsaUJBQWhDLEVBQW1EO0FBQ3ZFLFFBQUksQ0FBQzdELEtBQUtDLFFBQUwsQ0FBYzNhLEdBQWQsQ0FBTCxFQUF5QjtBQUN2QixjQUFNLElBQUl5ZSxTQUFKLENBQWMsbURBQWtEemUsR0FBbEQseUNBQWtEQSxHQUFsRCxFQUFkLENBQU47QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxRQUFJMGUsYUFBYTFlLElBQUlqQixPQUFKLENBQVksR0FBWixDQUFqQjtBQUFBLFFBQ0k0ZixXQUNLRCxlQUFlLENBQUMsQ0FBaEIsSUFBcUJBLGFBQWExZSxJQUFJakIsT0FBSixDQUFZLEdBQVosQ0FBbkMsR0FBdUQsR0FBdkQsR0FBNkQsR0FGckU7QUFBQSxRQUdJNmYsU0FBUzVlLElBQUlwQixLQUFKLENBQVUrZixRQUFWLENBSGI7QUFBQSxRQUlJRSxhQUFhLEtBSmpCO0FBS0FELFdBQU8sQ0FBUCxJQUFZQSxPQUFPLENBQVAsRUFBVS9mLE9BQVYsQ0FBa0JnZ0IsVUFBbEIsRUFBOEIsR0FBOUIsQ0FBWjtBQUNBN2UsVUFBTTRlLE9BQU94VixJQUFQLENBQVl1VixRQUFaLENBQU47O0FBRUEsUUFBSUcsT0FBTzllLEdBQVg7O0FBRUE7QUFDQTtBQUNBOGUsV0FBT0EsS0FBS0MsSUFBTCxFQUFQOztBQUVBLFFBQUksQ0FBQ1IsaUJBQUQsSUFBc0J2ZSxJQUFJcEIsS0FBSixDQUFVLEdBQVYsRUFBZVAsTUFBZixLQUEwQixDQUFwRCxFQUF1RDtBQUNyRDtBQUNBLFlBQUkyZ0IsYUFBYXRCLGtCQUFrQnVCLElBQWxCLENBQXVCSCxJQUF2QixDQUFqQjtBQUNBLFlBQUlFLFVBQUosRUFBZ0I7QUFDZCxpQkFBSy9lLElBQUwsR0FBWTZlLElBQVo7QUFDQSxpQkFBS3hmLElBQUwsR0FBWXdmLElBQVo7QUFDQSxpQkFBSzVWLFFBQUwsR0FBZ0I4VixXQUFXLENBQVgsQ0FBaEI7QUFDQSxnQkFBSUEsV0FBVyxDQUFYLENBQUosRUFBbUI7QUFDakIscUJBQUsxQixNQUFMLEdBQWMwQixXQUFXLENBQVgsQ0FBZDtBQUNBLG9CQUFJVixnQkFBSixFQUFzQjtBQUNwQix5QkFBS2YsS0FBTCxHQUFhcEIsWUFBWXRiLEtBQVosQ0FBa0IsS0FBS3ljLE1BQUwsQ0FBWWpVLE1BQVosQ0FBbUIsQ0FBbkIsQ0FBbEIsQ0FBYjtBQUNELGlCQUZELE1BRU87QUFDTCx5QkFBS2tVLEtBQUwsR0FBYSxLQUFLRCxNQUFMLENBQVlqVSxNQUFaLENBQW1CLENBQW5CLENBQWI7QUFDRDtBQUNGLGFBUEQsTUFPTyxJQUFJaVYsZ0JBQUosRUFBc0I7QUFDM0IscUJBQUtoQixNQUFMLEdBQWMsRUFBZDtBQUNBLHFCQUFLQyxLQUFMLEdBQWEsRUFBYjtBQUNEO0FBQ0QsbUJBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBRUQsUUFBSTJCLFFBQVExQixnQkFBZ0J5QixJQUFoQixDQUFxQkgsSUFBckIsQ0FBWjtBQUNBLFFBQUlJLEtBQUosRUFBVztBQUNUQSxnQkFBUUEsTUFBTSxDQUFOLENBQVI7QUFDQSxZQUFJQyxhQUFhRCxNQUFNM0UsV0FBTixFQUFqQjtBQUNBLGFBQUt5QyxRQUFMLEdBQWdCbUMsVUFBaEI7QUFDQUwsZUFBT0EsS0FBS3pWLE1BQUwsQ0FBWTZWLE1BQU03Z0IsTUFBbEIsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSWtnQixxQkFBcUJXLEtBQXJCLElBQThCSixLQUFLemUsS0FBTCxDQUFXLHNCQUFYLENBQWxDLEVBQXNFO0FBQ3BFLFlBQUk0YyxVQUFVNkIsS0FBS3pWLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZixNQUFzQixJQUFwQztBQUNBLFlBQUk0VCxXQUFXLEVBQUVpQyxTQUFTZCxpQkFBaUJjLEtBQWpCLENBQVgsQ0FBZixFQUFvRDtBQUNsREosbUJBQU9BLEtBQUt6VixNQUFMLENBQVksQ0FBWixDQUFQO0FBQ0EsaUJBQUs0VCxPQUFMLEdBQWUsSUFBZjtBQUNEO0FBQ0Y7O0FBRUQsUUFBSSxDQUFDbUIsaUJBQWlCYyxLQUFqQixDQUFELEtBQ0NqQyxXQUFZaUMsU0FBUyxDQUFDYixnQkFBZ0JhLEtBQWhCLENBRHZCLENBQUosRUFDcUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQUlFLFVBQVUsQ0FBQyxDQUFmO0FBQ0EsYUFBSyxJQUFJcGhCLElBQUksQ0FBYixFQUFnQkEsSUFBSStmLGdCQUFnQjFmLE1BQXBDLEVBQTRDTCxHQUE1QyxFQUFpRDtBQUMvQyxnQkFBSXFoQixNQUFNUCxLQUFLL2YsT0FBTCxDQUFhZ2YsZ0JBQWdCL2YsQ0FBaEIsQ0FBYixDQUFWO0FBQ0EsZ0JBQUlxaEIsUUFBUSxDQUFDLENBQVQsS0FBZUQsWUFBWSxDQUFDLENBQWIsSUFBa0JDLE1BQU1ELE9BQXZDLENBQUosRUFDRTtBQUFFQSwwQkFBVUMsR0FBVjtBQUFnQjtBQUNyQjs7QUFFRDtBQUNBO0FBQ0EsWUFBSW5DLElBQUosRUFBVW9DLE1BQVY7QUFDQSxZQUFJRixZQUFZLENBQUMsQ0FBakIsRUFBb0I7QUFDbEI7QUFDQUUscUJBQVNSLEtBQUtuRixXQUFMLENBQWlCLEdBQWpCLENBQVQ7QUFDRCxTQUhELE1BR087QUFDTDtBQUNBO0FBQ0EyRixxQkFBU1IsS0FBS25GLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0J5RixPQUF0QixDQUFUO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFlBQUlFLFdBQVcsQ0FBQyxDQUFoQixFQUFtQjtBQUNqQnBDLG1CQUFPNEIsS0FBSzNWLEtBQUwsQ0FBVyxDQUFYLEVBQWNtVyxNQUFkLENBQVA7QUFDQVIsbUJBQU9BLEtBQUszVixLQUFMLENBQVdtVyxTQUFTLENBQXBCLENBQVA7QUFDQSxpQkFBS3BDLElBQUwsR0FBWXBCLG1CQUFtQm9CLElBQW5CLENBQVo7QUFDRDs7QUFFRDtBQUNBa0Msa0JBQVUsQ0FBQyxDQUFYO0FBQ0EsYUFBSyxJQUFJcGhCLElBQUksQ0FBYixFQUFnQkEsSUFBSThmLGFBQWF6ZixNQUFqQyxFQUF5Q0wsR0FBekMsRUFBOEM7QUFDNUMsZ0JBQUlxaEIsTUFBTVAsS0FBSy9mLE9BQUwsQ0FBYStlLGFBQWE5ZixDQUFiLENBQWIsQ0FBVjtBQUNBLGdCQUFJcWhCLFFBQVEsQ0FBQyxDQUFULEtBQWVELFlBQVksQ0FBQyxDQUFiLElBQWtCQyxNQUFNRCxPQUF2QyxDQUFKLEVBQ0U7QUFBRUEsMEJBQVVDLEdBQVY7QUFBZ0I7QUFDckI7QUFDRDtBQUNBLFlBQUlELFlBQVksQ0FBQyxDQUFqQixFQUNFO0FBQUVBLHNCQUFVTixLQUFLemdCLE1BQWY7QUFBd0I7O0FBRTVCLGFBQUtpRyxJQUFMLEdBQVl3YSxLQUFLM1YsS0FBTCxDQUFXLENBQVgsRUFBY2lXLE9BQWQsQ0FBWjtBQUNBTixlQUFPQSxLQUFLM1YsS0FBTCxDQUFXaVcsT0FBWCxDQUFQOztBQUVBO0FBQ0EsYUFBS0csU0FBTDs7QUFFQTtBQUNBO0FBQ0EsYUFBS25DLFFBQUwsR0FBZ0IsS0FBS0EsUUFBTCxJQUFpQixFQUFqQzs7QUFFQTtBQUNBO0FBQ0EsWUFBSW9DLGVBQWUsS0FBS3BDLFFBQUwsQ0FBYyxDQUFkLE1BQXFCLEdBQXJCLElBQ2YsS0FBS0EsUUFBTCxDQUFjLEtBQUtBLFFBQUwsQ0FBYy9lLE1BQWQsR0FBdUIsQ0FBckMsTUFBNEMsR0FEaEQ7O0FBR0E7QUFDQSxZQUFJLENBQUNtaEIsWUFBTCxFQUFtQjtBQUNqQixnQkFBSUMsWUFBWSxLQUFLckMsUUFBTCxDQUFjeGUsS0FBZCxDQUFvQixJQUFwQixDQUFoQjtBQUNBLGlCQUFLLElBQUlaLElBQUksQ0FBUixFQUFXZ0csSUFBSXliLFVBQVVwaEIsTUFBOUIsRUFBc0NMLElBQUlnRyxDQUExQyxFQUE2Q2hHLEdBQTdDLEVBQWtEO0FBQ2hELG9CQUFJMGhCLE9BQU9ELFVBQVV6aEIsQ0FBVixDQUFYO0FBQ0Esb0JBQUksQ0FBQzBoQixJQUFMLEVBQVc7QUFBRTtBQUFXO0FBQ3hCLG9CQUFJLENBQUNBLEtBQUtyZixLQUFMLENBQVc0ZCxtQkFBWCxDQUFMLEVBQXNDO0FBQ3BDLHdCQUFJMEIsVUFBVSxFQUFkO0FBQ0EseUJBQUssSUFBSXJHLElBQUksQ0FBUixFQUFXUixJQUFJNEcsS0FBS3JoQixNQUF6QixFQUFpQ2liLElBQUlSLENBQXJDLEVBQXdDUSxHQUF4QyxFQUE2QztBQUMzQyw0QkFBSW9HLEtBQUt2SCxVQUFMLENBQWdCbUIsQ0FBaEIsSUFBcUIsR0FBekIsRUFBOEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0FxRyx1Q0FBVyxHQUFYO0FBQ0QseUJBTEQsTUFLTztBQUNMQSx1Q0FBV0QsS0FBS3BHLENBQUwsQ0FBWDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLHdCQUFJLENBQUNxRyxRQUFRdGYsS0FBUixDQUFjNGQsbUJBQWQsQ0FBTCxFQUF5QztBQUN2Qyw0QkFBSTJCLGFBQWFILFVBQVV0VyxLQUFWLENBQWdCLENBQWhCLEVBQW1CbkwsQ0FBbkIsQ0FBakI7QUFDQSw0QkFBSTZoQixVQUFVSixVQUFVdFcsS0FBVixDQUFnQm5MLElBQUksQ0FBcEIsQ0FBZDtBQUNBLDRCQUFJOGhCLE1BQU1KLEtBQUtyZixLQUFMLENBQVc2ZCxpQkFBWCxDQUFWO0FBQ0EsNEJBQUk0QixHQUFKLEVBQVM7QUFDUEYsdUNBQVc1Z0IsSUFBWCxDQUFnQjhnQixJQUFJLENBQUosQ0FBaEI7QUFDQUQsb0NBQVFFLE9BQVIsQ0FBZ0JELElBQUksQ0FBSixDQUFoQjtBQUNEO0FBQ0QsNEJBQUlELFFBQVF4aEIsTUFBWixFQUFvQjtBQUNsQnlnQixtQ0FBTyxNQUFNZSxRQUFRelcsSUFBUixDQUFhLEdBQWIsQ0FBTixHQUEwQjBWLElBQWpDO0FBQ0Q7QUFDRCw2QkFBSzFCLFFBQUwsR0FBZ0J3QyxXQUFXeFcsSUFBWCxDQUFnQixHQUFoQixDQUFoQjtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsWUFBSSxLQUFLZ1UsUUFBTCxDQUFjL2UsTUFBZCxHQUF1QjJmLGNBQTNCLEVBQTJDO0FBQ3pDLGlCQUFLWixRQUFMLEdBQWdCLEVBQWhCO0FBQ0QsU0FGRCxNQUVPO0FBQ0w7QUFDQSxpQkFBS0EsUUFBTCxHQUFnQixLQUFLQSxRQUFMLENBQWM3QyxXQUFkLEVBQWhCO0FBQ0Q7O0FBRUQsWUFBSSxDQUFDaUYsWUFBTCxFQUFtQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFLcEMsUUFBTCxHQUFnQmhILFNBQVNvRSxPQUFULENBQWlCLEtBQUs0QyxRQUF0QixDQUFoQjtBQUNEOztBQUVELFlBQUk0QyxJQUFJLEtBQUs3QyxJQUFMLEdBQVksTUFBTSxLQUFLQSxJQUF2QixHQUE4QixFQUF0QztBQUNBLFlBQUk4QyxJQUFJLEtBQUs3QyxRQUFMLElBQWlCLEVBQXpCO0FBQ0EsYUFBSzlZLElBQUwsR0FBWTJiLElBQUlELENBQWhCO0FBQ0EsYUFBSzFnQixJQUFMLElBQWEsS0FBS2dGLElBQWxCOztBQUVBO0FBQ0E7QUFDQSxZQUFJa2IsWUFBSixFQUFrQjtBQUNoQixpQkFBS3BDLFFBQUwsR0FBZ0IsS0FBS0EsUUFBTCxDQUFjL1QsTUFBZCxDQUFxQixDQUFyQixFQUF3QixLQUFLK1QsUUFBTCxDQUFjL2UsTUFBZCxHQUF1QixDQUEvQyxDQUFoQjtBQUNBLGdCQUFJeWdCLEtBQUssQ0FBTCxNQUFZLEdBQWhCLEVBQXFCO0FBQ25CQSx1QkFBTyxNQUFNQSxJQUFiO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0E7QUFDQSxRQUFJLENBQUNYLGVBQWVnQixVQUFmLENBQUwsRUFBaUM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLGFBQUssSUFBSW5oQixJQUFJLENBQVIsRUFBV2dHLElBQUk2WixXQUFXeGYsTUFBL0IsRUFBdUNMLElBQUlnRyxDQUEzQyxFQUE4Q2hHLEdBQTlDLEVBQW1EO0FBQ2pELGdCQUFJa2lCLEtBQUtyQyxXQUFXN2YsQ0FBWCxDQUFUO0FBQ0EsZ0JBQUk4Z0IsS0FBSy9mLE9BQUwsQ0FBYW1oQixFQUFiLE1BQXFCLENBQUMsQ0FBMUIsRUFDRTtBQUFFO0FBQVc7QUFDZixnQkFBSUMsTUFBTWpFLG1CQUFtQmdFLEVBQW5CLENBQVY7QUFDQSxnQkFBSUMsUUFBUUQsRUFBWixFQUFnQjtBQUNkQyxzQkFBTUMsT0FBT0YsRUFBUCxDQUFOO0FBQ0Q7QUFDRHBCLG1CQUFPQSxLQUFLbGdCLEtBQUwsQ0FBV3NoQixFQUFYLEVBQWU5VyxJQUFmLENBQW9CK1csR0FBcEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBR0Q7QUFDQSxRQUFJOUMsT0FBT3lCLEtBQUsvZixPQUFMLENBQWEsR0FBYixDQUFYO0FBQ0EsUUFBSXNlLFNBQVMsQ0FBQyxDQUFkLEVBQWlCO0FBQ2Y7QUFDQSxhQUFLQSxJQUFMLEdBQVl5QixLQUFLelYsTUFBTCxDQUFZZ1UsSUFBWixDQUFaO0FBQ0F5QixlQUFPQSxLQUFLM1YsS0FBTCxDQUFXLENBQVgsRUFBY2tVLElBQWQsQ0FBUDtBQUNEO0FBQ0QsUUFBSWdELEtBQUt2QixLQUFLL2YsT0FBTCxDQUFhLEdBQWIsQ0FBVDtBQUNBLFFBQUlzaEIsT0FBTyxDQUFDLENBQVosRUFBZTtBQUNiLGFBQUsvQyxNQUFMLEdBQWN3QixLQUFLelYsTUFBTCxDQUFZZ1gsRUFBWixDQUFkO0FBQ0EsYUFBSzlDLEtBQUwsR0FBYXVCLEtBQUt6VixNQUFMLENBQVlnWCxLQUFLLENBQWpCLENBQWI7QUFDQSxZQUFJL0IsZ0JBQUosRUFBc0I7QUFDcEIsaUJBQUtmLEtBQUwsR0FBYXBCLFlBQVl0YixLQUFaLENBQWtCLEtBQUswYyxLQUF2QixDQUFiO0FBQ0Q7QUFDRHVCLGVBQU9BLEtBQUszVixLQUFMLENBQVcsQ0FBWCxFQUFja1gsRUFBZCxDQUFQO0FBQ0QsS0FQRCxNQU9PLElBQUkvQixnQkFBSixFQUFzQjtBQUMzQjtBQUNBLGFBQUtoQixNQUFMLEdBQWMsRUFBZDtBQUNBLGFBQUtDLEtBQUwsR0FBYSxFQUFiO0FBQ0Q7QUFDRCxRQUFJdUIsSUFBSixFQUFVO0FBQUUsYUFBSzVWLFFBQUwsR0FBZ0I0VixJQUFoQjtBQUF1QjtBQUNuQyxRQUFJVCxnQkFBZ0JjLFVBQWhCLEtBQ0EsS0FBSy9CLFFBREwsSUFDaUIsQ0FBQyxLQUFLbFUsUUFEM0IsRUFDcUM7QUFDbkMsYUFBS0EsUUFBTCxHQUFnQixHQUFoQjtBQUNEOztBQUVEO0FBQ0EsUUFBSSxLQUFLQSxRQUFMLElBQWlCLEtBQUtvVSxNQUExQixFQUFrQztBQUNoQyxZQUFJMEMsSUFBSSxLQUFLOVcsUUFBTCxJQUFpQixFQUF6QjtBQUNBLFlBQUlvWCxJQUFJLEtBQUtoRCxNQUFMLElBQWUsRUFBdkI7QUFDQSxhQUFLcmQsSUFBTCxHQUFZK2YsSUFBSU0sQ0FBaEI7QUFDRDs7QUFFRDtBQUNBLFNBQUtoaEIsSUFBTCxHQUFZLEtBQUt3SCxNQUFMLEVBQVo7QUFDQSxXQUFPLElBQVA7QUFDRCxDQW5RRDs7QUFxUUE7QUFDQSxTQUFTK1YsU0FBVCxDQUFtQnJJLEdBQW5CLEVBQXdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSWtHLEtBQUtDLFFBQUwsQ0FBY25HLEdBQWQsQ0FBSixFQUF3QjtBQUFFQSxjQUFNZ0ksU0FBU2hJLEdBQVQsQ0FBTjtBQUFzQjtBQUNoRCxRQUFJLEVBQUVBLGVBQWV1SSxHQUFqQixDQUFKLEVBQTJCO0FBQUUsZUFBT0EsSUFBSTlCLFNBQUosQ0FBY25VLE1BQWQsQ0FBcUJvVSxJQUFyQixDQUEwQjFHLEdBQTFCLENBQVA7QUFBd0M7QUFDckUsV0FBT0EsSUFBSTFOLE1BQUosRUFBUDtBQUNEOztBQUVEaVcsSUFBSTlCLFNBQUosQ0FBY25VLE1BQWQsR0FBdUIsWUFBVztBQUNoQyxRQUFJb1csT0FBTyxLQUFLQSxJQUFMLElBQWEsRUFBeEI7QUFDQSxRQUFJQSxJQUFKLEVBQVU7QUFDUkEsZUFBT2hCLG1CQUFtQmdCLElBQW5CLENBQVA7QUFDQUEsZUFBT0EsS0FBS3JlLE9BQUwsQ0FBYSxNQUFiLEVBQXFCLEdBQXJCLENBQVA7QUFDQXFlLGdCQUFRLEdBQVI7QUFDRDs7QUFFRCxRQUFJRixXQUFXLEtBQUtBLFFBQUwsSUFBaUIsRUFBaEM7QUFBQSxRQUNJOVQsV0FBVyxLQUFLQSxRQUFMLElBQWlCLEVBRGhDO0FBQUEsUUFFSW1VLE9BQU8sS0FBS0EsSUFBTCxJQUFhLEVBRnhCO0FBQUEsUUFHSS9ZLE9BQU8sS0FIWDtBQUFBLFFBSUlpWixRQUFRLEVBSlo7O0FBTUEsUUFBSSxLQUFLalosSUFBVCxFQUFlO0FBQ2JBLGVBQU80WSxPQUFPLEtBQUs1WSxJQUFuQjtBQUNELEtBRkQsTUFFTyxJQUFJLEtBQUs4WSxRQUFULEVBQW1CO0FBQ3hCOVksZUFBTzRZLFFBQVEsS0FBS0UsUUFBTCxDQUFjcmUsT0FBZCxDQUFzQixHQUF0QixNQUErQixDQUFDLENBQWhDLEdBQ1gsS0FBS3FlLFFBRE0sR0FFWCxNQUFNLEtBQUtBLFFBQVgsR0FBc0IsR0FGbkIsQ0FBUDtBQUdBLFlBQUksS0FBS0QsSUFBVCxFQUFlO0FBQ2I3WSxvQkFBUSxNQUFNLEtBQUs2WSxJQUFuQjtBQUNEO0FBQ0Y7O0FBRUQsUUFBSSxLQUFLSSxLQUFMLElBQ0E3QyxLQUFLRyxRQUFMLENBQWMsS0FBSzBDLEtBQW5CLENBREEsSUFFQWxJLE9BQU9OLElBQVAsQ0FBWSxLQUFLd0ksS0FBakIsRUFBd0JsZixNQUY1QixFQUVvQztBQUNsQ2tmLGdCQUFRcEIsWUFBWW5JLFNBQVosQ0FBc0IsS0FBS3VKLEtBQTNCLENBQVI7QUFDRDs7QUFFRCxRQUFJRCxTQUFTLEtBQUtBLE1BQUwsSUFBZ0JDLFNBQVUsTUFBTUEsS0FBaEMsSUFBMkMsRUFBeEQ7O0FBRUEsUUFBSVAsWUFBWUEsU0FBUzNULE1BQVQsQ0FBZ0IsQ0FBQyxDQUFqQixNQUF3QixHQUF4QyxFQUE2QztBQUFFMlQsb0JBQVksR0FBWjtBQUFrQjs7QUFFakU7QUFDQTtBQUNBLFFBQUksS0FBS0MsT0FBTCxJQUNBLENBQUMsQ0FBQ0QsUUFBRCxJQUFhcUIsZ0JBQWdCckIsUUFBaEIsQ0FBZCxLQUE0QzFZLFNBQVMsS0FEekQsRUFDZ0U7QUFDOURBLGVBQU8sUUFBUUEsUUFBUSxFQUFoQixDQUFQO0FBQ0EsWUFBSTRFLFlBQVlBLFNBQVNxWCxNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQXZDLEVBQTRDO0FBQUVyWCx1QkFBVyxNQUFNQSxRQUFqQjtBQUE0QjtBQUMzRSxLQUpELE1BSU8sSUFBSSxDQUFDNUUsSUFBTCxFQUFXO0FBQ2hCQSxlQUFPLEVBQVA7QUFDRDs7QUFFRCxRQUFJK1ksUUFBUUEsS0FBS2tELE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQS9CLEVBQW9DO0FBQUVsRCxlQUFPLE1BQU1BLElBQWI7QUFBb0I7QUFDMUQsUUFBSUMsVUFBVUEsT0FBT2lELE1BQVAsQ0FBYyxDQUFkLE1BQXFCLEdBQW5DLEVBQXdDO0FBQUVqRCxpQkFBUyxNQUFNQSxNQUFmO0FBQXdCOztBQUVsRXBVLGVBQVdBLFNBQVNySyxPQUFULENBQWlCLE9BQWpCLEVBQTBCLFVBQVN3QixLQUFULEVBQWdCO0FBQ25ELGVBQU82YixtQkFBbUI3YixLQUFuQixDQUFQO0FBQ0QsS0FGVSxDQUFYO0FBR0FpZCxhQUFTQSxPQUFPemUsT0FBUCxDQUFlLEdBQWYsRUFBb0IsS0FBcEIsQ0FBVDs7QUFFQSxXQUFPbWUsV0FBVzFZLElBQVgsR0FBa0I0RSxRQUFsQixHQUE2Qm9VLE1BQTdCLEdBQXNDRCxJQUE3QztBQUNELENBdEREOztBQXdEQSxTQUFTWixVQUFULENBQW9CbGMsTUFBcEIsRUFBNEJpZ0IsUUFBNUIsRUFBc0M7QUFDcEMsV0FBT2hFLFNBQVNqYyxNQUFULEVBQWlCLEtBQWpCLEVBQXdCLElBQXhCLEVBQThCRyxPQUE5QixDQUFzQzhmLFFBQXRDLENBQVA7QUFDRDs7QUFFRHpELElBQUk5QixTQUFKLENBQWN2YSxPQUFkLEdBQXdCLFVBQVM4ZixRQUFULEVBQW1CO0FBQ3pDLFdBQU8sS0FBSzlELGFBQUwsQ0FBbUJGLFNBQVNnRSxRQUFULEVBQW1CLEtBQW5CLEVBQTBCLElBQTFCLENBQW5CLEVBQW9EMVosTUFBcEQsRUFBUDtBQUNELENBRkQ7O0FBSUEsU0FBUzZWLGdCQUFULENBQTBCcGMsTUFBMUIsRUFBa0NpZ0IsUUFBbEMsRUFBNEM7QUFDMUMsUUFBSSxDQUFDamdCLE1BQUwsRUFBYTtBQUFFLGVBQU9pZ0IsUUFBUDtBQUFrQjtBQUNqQyxXQUFPaEUsU0FBU2pjLE1BQVQsRUFBaUIsS0FBakIsRUFBd0IsSUFBeEIsRUFBOEJtYyxhQUE5QixDQUE0QzhELFFBQTVDLENBQVA7QUFDRDs7QUFFRHpELElBQUk5QixTQUFKLENBQWN5QixhQUFkLEdBQThCLFVBQVM4RCxRQUFULEVBQW1CO0FBQy9DLFFBQUk5RixLQUFLQyxRQUFMLENBQWM2RixRQUFkLENBQUosRUFBNkI7QUFDM0IsWUFBSWpoQixNQUFNLElBQUl3ZCxHQUFKLEVBQVY7QUFDQXhkLFlBQUlzQixLQUFKLENBQVUyZixRQUFWLEVBQW9CLEtBQXBCLEVBQTJCLElBQTNCO0FBQ0FBLG1CQUFXamhCLEdBQVg7QUFDRDs7QUFFRCxRQUFJaVcsU0FBUyxJQUFJdUgsR0FBSixFQUFiO0FBQ0EsUUFBSTBELFFBQVFwTCxPQUFPTixJQUFQLENBQVksSUFBWixDQUFaO0FBQ0EsU0FBSyxJQUFJMkwsS0FBSyxDQUFkLEVBQWlCQSxLQUFLRCxNQUFNcGlCLE1BQTVCLEVBQW9DcWlCLElBQXBDLEVBQTBDO0FBQ3hDLFlBQUlDLE9BQU9GLE1BQU1DLEVBQU4sQ0FBWDtBQUNBbEwsZUFBT21MLElBQVAsSUFBZSxLQUFLQSxJQUFMLENBQWY7QUFDRDs7QUFFRDtBQUNBO0FBQ0FuTCxXQUFPNkgsSUFBUCxHQUFjbUQsU0FBU25ELElBQXZCOztBQUVBO0FBQ0EsUUFBSW1ELFNBQVNsaEIsSUFBVCxLQUFrQixFQUF0QixFQUEwQjtBQUN4QmtXLGVBQU9sVyxJQUFQLEdBQWNrVyxPQUFPMU8sTUFBUCxFQUFkO0FBQ0EsZUFBTzBPLE1BQVA7QUFDRDs7QUFFRDtBQUNBLFFBQUlnTCxTQUFTdkQsT0FBVCxJQUFvQixDQUFDdUQsU0FBU3hELFFBQWxDLEVBQTRDO0FBQzFDO0FBQ0EsWUFBSTRELFFBQVF2TCxPQUFPTixJQUFQLENBQVl5TCxRQUFaLENBQVo7QUFDQSxhQUFLLElBQUlLLEtBQUssQ0FBZCxFQUFpQkEsS0FBS0QsTUFBTXZpQixNQUE1QixFQUFvQ3dpQixJQUFwQyxFQUEwQztBQUN4QyxnQkFBSUMsT0FBT0YsTUFBTUMsRUFBTixDQUFYO0FBQ0EsZ0JBQUlDLFNBQVMsVUFBYixFQUNFO0FBQUV0TCx1QkFBT3NMLElBQVAsSUFBZU4sU0FBU00sSUFBVCxDQUFmO0FBQWdDO0FBQ3JDOztBQUVEO0FBQ0EsWUFBSXpDLGdCQUFnQjdJLE9BQU93SCxRQUF2QixLQUNBeEgsT0FBTzRILFFBRFAsSUFDbUIsQ0FBQzVILE9BQU90TSxRQUQvQixFQUN5QztBQUN2Q3NNLG1CQUFPdlYsSUFBUCxHQUFjdVYsT0FBT3RNLFFBQVAsR0FBa0IsR0FBaEM7QUFDRDs7QUFFRHNNLGVBQU9sVyxJQUFQLEdBQWNrVyxPQUFPMU8sTUFBUCxFQUFkO0FBQ0EsZUFBTzBPLE1BQVA7QUFDRDs7QUFFRCxRQUFJZ0wsU0FBU3hELFFBQVQsSUFBcUJ3RCxTQUFTeEQsUUFBVCxLQUFzQnhILE9BQU93SCxRQUF0RCxFQUFnRTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSSxDQUFDcUIsZ0JBQWdCbUMsU0FBU3hELFFBQXpCLENBQUwsRUFBeUM7QUFDdkMsZ0JBQUlqSSxPQUFPTSxPQUFPTixJQUFQLENBQVl5TCxRQUFaLENBQVg7QUFDQSxpQkFBSyxJQUFJM0UsSUFBSSxDQUFiLEVBQWdCQSxJQUFJOUcsS0FBSzFXLE1BQXpCLEVBQWlDd2QsR0FBakMsRUFBc0M7QUFDcEMsb0JBQUkvQyxJQUFJL0QsS0FBSzhHLENBQUwsQ0FBUjtBQUNBckcsdUJBQU9zRCxDQUFQLElBQVkwSCxTQUFTMUgsQ0FBVCxDQUFaO0FBQ0Q7QUFDRHRELG1CQUFPbFcsSUFBUCxHQUFja1csT0FBTzFPLE1BQVAsRUFBZDtBQUNBLG1CQUFPME8sTUFBUDtBQUNEOztBQUVEQSxlQUFPd0gsUUFBUCxHQUFrQndELFNBQVN4RCxRQUEzQjtBQUNBLFlBQUksQ0FBQ3dELFNBQVNsYyxJQUFWLElBQWtCLENBQUM4WixpQkFBaUJvQyxTQUFTeEQsUUFBMUIsQ0FBdkIsRUFBNEQ7QUFDMUQsZ0JBQUkrRCxVQUFVLENBQUNQLFNBQVN0WCxRQUFULElBQXFCLEVBQXRCLEVBQTBCdEssS0FBMUIsQ0FBZ0MsR0FBaEMsQ0FBZDtBQUNBLG1CQUFPbWlCLFFBQVExaUIsTUFBUixJQUFrQixFQUFFbWlCLFNBQVNsYyxJQUFULEdBQWdCeWMsUUFBUUMsS0FBUixFQUFsQixDQUF6QixFQUE0RCxDQUFHO0FBQy9ELGdCQUFJLENBQUNSLFNBQVNsYyxJQUFkLEVBQW9CO0FBQUVrYyx5QkFBU2xjLElBQVQsR0FBZ0IsRUFBaEI7QUFBcUI7QUFDM0MsZ0JBQUksQ0FBQ2tjLFNBQVNwRCxRQUFkLEVBQXdCO0FBQUVvRCx5QkFBU3BELFFBQVQsR0FBb0IsRUFBcEI7QUFBeUI7QUFDbkQsZ0JBQUkyRCxRQUFRLENBQVIsTUFBZSxFQUFuQixFQUF1QjtBQUFFQSx3QkFBUWhCLE9BQVIsQ0FBZ0IsRUFBaEI7QUFBc0I7QUFDL0MsZ0JBQUlnQixRQUFRMWlCLE1BQVIsR0FBaUIsQ0FBckIsRUFBd0I7QUFBRTBpQix3QkFBUWhCLE9BQVIsQ0FBZ0IsRUFBaEI7QUFBc0I7QUFDaER2SyxtQkFBT3RNLFFBQVAsR0FBa0I2WCxRQUFRM1gsSUFBUixDQUFhLEdBQWIsQ0FBbEI7QUFDRCxTQVJELE1BUU87QUFDTG9NLG1CQUFPdE0sUUFBUCxHQUFrQnNYLFNBQVN0WCxRQUEzQjtBQUNEO0FBQ0RzTSxlQUFPOEgsTUFBUCxHQUFnQmtELFNBQVNsRCxNQUF6QjtBQUNBOUgsZUFBTytILEtBQVAsR0FBZWlELFNBQVNqRCxLQUF4QjtBQUNBL0gsZUFBT2xSLElBQVAsR0FBY2tjLFNBQVNsYyxJQUFULElBQWlCLEVBQS9CO0FBQ0FrUixlQUFPMEgsSUFBUCxHQUFjc0QsU0FBU3RELElBQXZCO0FBQ0ExSCxlQUFPNEgsUUFBUCxHQUFrQm9ELFNBQVNwRCxRQUFULElBQXFCb0QsU0FBU2xjLElBQWhEO0FBQ0FrUixlQUFPMkgsSUFBUCxHQUFjcUQsU0FBU3JELElBQXZCO0FBQ0E7QUFDQSxZQUFJM0gsT0FBT3RNLFFBQVAsSUFBbUJzTSxPQUFPOEgsTUFBOUIsRUFBc0M7QUFDcEMsZ0JBQUkwQyxJQUFJeEssT0FBT3RNLFFBQVAsSUFBbUIsRUFBM0I7QUFDQSxnQkFBSW9YLElBQUk5SyxPQUFPOEgsTUFBUCxJQUFpQixFQUF6QjtBQUNBOUgsbUJBQU92VixJQUFQLEdBQWMrZixJQUFJTSxDQUFsQjtBQUNEO0FBQ0Q5SyxlQUFPeUgsT0FBUCxHQUFpQnpILE9BQU95SCxPQUFQLElBQWtCdUQsU0FBU3ZELE9BQTVDO0FBQ0F6SCxlQUFPbFcsSUFBUCxHQUFja1csT0FBTzFPLE1BQVAsRUFBZDtBQUNBLGVBQU8wTyxNQUFQO0FBQ0Q7O0FBRUQsUUFBSXlMLGNBQWV6TCxPQUFPdE0sUUFBUCxJQUFtQnNNLE9BQU90TSxRQUFQLENBQWdCcVgsTUFBaEIsQ0FBdUIsQ0FBdkIsTUFBOEIsR0FBcEU7QUFBQSxRQUNJVyxXQUNJVixTQUFTbGMsSUFBVCxJQUNBa2MsU0FBU3RYLFFBQVQsSUFBcUJzWCxTQUFTdFgsUUFBVCxDQUFrQnFYLE1BQWxCLENBQXlCLENBQXpCLE1BQWdDLEdBSDdEO0FBQUEsUUFLSVksYUFBY0QsWUFBWUQsV0FBWixJQUNDekwsT0FBT2xSLElBQVAsSUFBZWtjLFNBQVN0WCxRQU4zQztBQUFBLFFBT0lrWSxnQkFBZ0JELFVBUHBCO0FBQUEsUUFRSUUsVUFBVTdMLE9BQU90TSxRQUFQLElBQW1Cc00sT0FBT3RNLFFBQVAsQ0FBZ0J0SyxLQUFoQixDQUFzQixHQUF0QixDQUFuQixJQUFpRCxFQVIvRDtBQUFBLFFBU0ltaUIsVUFBVVAsU0FBU3RYLFFBQVQsSUFBcUJzWCxTQUFTdFgsUUFBVCxDQUFrQnRLLEtBQWxCLENBQXdCLEdBQXhCLENBQXJCLElBQXFELEVBVG5FO0FBQUEsUUFVSTBpQixZQUFZOUwsT0FBT3dILFFBQVAsSUFBbUIsQ0FBQ3FCLGdCQUFnQjdJLE9BQU93SCxRQUF2QixDQVZwQzs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSXNFLFNBQUosRUFBZTtBQUNiOUwsZUFBTzRILFFBQVAsR0FBa0IsRUFBbEI7QUFDQTVILGVBQU8ySCxJQUFQLEdBQWMsSUFBZDtBQUNBLFlBQUkzSCxPQUFPbFIsSUFBWCxFQUFpQjtBQUNmLGdCQUFJK2MsUUFBUSxDQUFSLE1BQWUsRUFBbkIsRUFBdUI7QUFBRUEsd0JBQVEsQ0FBUixJQUFhN0wsT0FBT2xSLElBQXBCO0FBQTJCLGFBQXBELE1BQ0s7QUFBRStjLHdCQUFRdEIsT0FBUixDQUFnQnZLLE9BQU9sUixJQUF2QjtBQUErQjtBQUN2QztBQUNEa1IsZUFBT2xSLElBQVAsR0FBYyxFQUFkO0FBQ0EsWUFBSWtjLFNBQVN4RCxRQUFiLEVBQXVCO0FBQ3JCd0QscUJBQVNwRCxRQUFULEdBQW9CLElBQXBCO0FBQ0FvRCxxQkFBU3JELElBQVQsR0FBZ0IsSUFBaEI7QUFDQSxnQkFBSXFELFNBQVNsYyxJQUFiLEVBQW1CO0FBQ2pCLG9CQUFJeWMsUUFBUSxDQUFSLE1BQWUsRUFBbkIsRUFBdUI7QUFBRUEsNEJBQVEsQ0FBUixJQUFhUCxTQUFTbGMsSUFBdEI7QUFBNkIsaUJBQXRELE1BQ0s7QUFBRXljLDRCQUFRaEIsT0FBUixDQUFnQlMsU0FBU2xjLElBQXpCO0FBQWlDO0FBQ3pDO0FBQ0RrYyxxQkFBU2xjLElBQVQsR0FBZ0IsSUFBaEI7QUFDRDtBQUNENmMscUJBQWFBLGVBQWVKLFFBQVEsQ0FBUixNQUFlLEVBQWYsSUFBcUJNLFFBQVEsQ0FBUixNQUFlLEVBQW5ELENBQWI7QUFDRDs7QUFFRCxRQUFJSCxRQUFKLEVBQWM7QUFDWjtBQUNBMUwsZUFBT2xSLElBQVAsR0FBZWtjLFNBQVNsYyxJQUFULElBQWlCa2MsU0FBU2xjLElBQVQsS0FBa0IsRUFBcEMsR0FDQWtjLFNBQVNsYyxJQURULEdBQ2dCa1IsT0FBT2xSLElBRHJDO0FBRUFrUixlQUFPNEgsUUFBUCxHQUFtQm9ELFNBQVNwRCxRQUFULElBQXFCb0QsU0FBU3BELFFBQVQsS0FBc0IsRUFBNUMsR0FDQW9ELFNBQVNwRCxRQURULEdBQ29CNUgsT0FBTzRILFFBRDdDO0FBRUE1SCxlQUFPOEgsTUFBUCxHQUFnQmtELFNBQVNsRCxNQUF6QjtBQUNBOUgsZUFBTytILEtBQVAsR0FBZWlELFNBQVNqRCxLQUF4QjtBQUNBOEQsa0JBQVVOLE9BQVY7QUFDQTtBQUNELEtBVkQsTUFVTyxJQUFJQSxRQUFRMWlCLE1BQVosRUFBb0I7QUFDekI7QUFDQTtBQUNBLFlBQUksQ0FBQ2dqQixPQUFMLEVBQWM7QUFBRUEsc0JBQVUsRUFBVjtBQUFlO0FBQy9CQSxnQkFBUUUsR0FBUjtBQUNBRixrQkFBVUEsUUFBUTlPLE1BQVIsQ0FBZXdPLE9BQWYsQ0FBVjtBQUNBdkwsZUFBTzhILE1BQVAsR0FBZ0JrRCxTQUFTbEQsTUFBekI7QUFDQTlILGVBQU8rSCxLQUFQLEdBQWVpRCxTQUFTakQsS0FBeEI7QUFDRCxLQVJNLE1BUUEsSUFBSSxDQUFDN0MsS0FBS0ssaUJBQUwsQ0FBdUJ5RixTQUFTbEQsTUFBaEMsQ0FBTCxFQUE4QztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxZQUFJZ0UsU0FBSixFQUFlO0FBQ2I5TCxtQkFBTzRILFFBQVAsR0FBa0I1SCxPQUFPbFIsSUFBUCxHQUFjK2MsUUFBUUwsS0FBUixFQUFoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFJUSxhQUFhaE0sT0FBT2xSLElBQVAsSUFBZWtSLE9BQU9sUixJQUFQLENBQVl2RixPQUFaLENBQW9CLEdBQXBCLElBQTJCLENBQTFDLEdBQ0F5VyxPQUFPbFIsSUFBUCxDQUFZMUYsS0FBWixDQUFrQixHQUFsQixDQURBLEdBQ3lCLEtBRDFDO0FBRUEsZ0JBQUk0aUIsVUFBSixFQUFnQjtBQUNkaE0sdUJBQU8wSCxJQUFQLEdBQWNzRSxXQUFXUixLQUFYLEVBQWQ7QUFDQXhMLHVCQUFPbFIsSUFBUCxHQUFja1IsT0FBTzRILFFBQVAsR0FBa0JvRSxXQUFXUixLQUFYLEVBQWhDO0FBQ0Q7QUFDRjtBQUNEeEwsZUFBTzhILE1BQVAsR0FBZ0JrRCxTQUFTbEQsTUFBekI7QUFDQTlILGVBQU8rSCxLQUFQLEdBQWVpRCxTQUFTakQsS0FBeEI7QUFDQTtBQUNBLFlBQUksQ0FBQzdDLEtBQUtJLE1BQUwsQ0FBWXRGLE9BQU90TSxRQUFuQixDQUFELElBQWlDLENBQUN3UixLQUFLSSxNQUFMLENBQVl0RixPQUFPOEgsTUFBbkIsQ0FBdEMsRUFBa0U7QUFDaEU5SCxtQkFBT3ZWLElBQVAsR0FBYyxDQUFDdVYsT0FBT3RNLFFBQVAsR0FBa0JzTSxPQUFPdE0sUUFBekIsR0FBb0MsRUFBckMsS0FDQ3NNLE9BQU84SCxNQUFQLEdBQWdCOUgsT0FBTzhILE1BQXZCLEdBQWdDLEVBRGpDLENBQWQ7QUFFRDtBQUNEOUgsZUFBT2xXLElBQVAsR0FBY2tXLE9BQU8xTyxNQUFQLEVBQWQ7QUFDQSxlQUFPME8sTUFBUDtBQUNEOztBQUVELFFBQUksQ0FBQzZMLFFBQVFoakIsTUFBYixFQUFxQjtBQUNuQjtBQUNBO0FBQ0FtWCxlQUFPdE0sUUFBUCxHQUFrQixJQUFsQjtBQUNBO0FBQ0EsWUFBSXNNLE9BQU84SCxNQUFYLEVBQW1CO0FBQ2pCOUgsbUJBQU92VixJQUFQLEdBQWMsTUFBTXVWLE9BQU84SCxNQUEzQjtBQUNELFNBRkQsTUFFTztBQUNMOUgsbUJBQU92VixJQUFQLEdBQWMsSUFBZDtBQUNEO0FBQ0R1VixlQUFPbFcsSUFBUCxHQUFja1csT0FBTzFPLE1BQVAsRUFBZDtBQUNBLGVBQU8wTyxNQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsUUFBSWlNLE9BQU9KLFFBQVFsWSxLQUFSLENBQWMsQ0FBQyxDQUFmLEVBQWtCLENBQWxCLENBQVg7QUFDQSxRQUFJdVksbUJBQ0EsQ0FBQ2xNLE9BQU9sUixJQUFQLElBQWVrYyxTQUFTbGMsSUFBeEIsSUFBZ0MrYyxRQUFRaGpCLE1BQVIsR0FBaUIsQ0FBbEQsTUFDQ29qQixTQUFTLEdBQVQsSUFBZ0JBLFNBQVMsSUFEMUIsS0FDbUNBLFNBQVMsRUFGaEQ7O0FBSUE7QUFDQTtBQUNBLFFBQUlFLEtBQUssQ0FBVDtBQUNBLFNBQUssSUFBSTNqQixJQUFJcWpCLFFBQVFoakIsTUFBckIsRUFBNkJMLEtBQUssQ0FBbEMsRUFBcUNBLEdBQXJDLEVBQTBDO0FBQ3hDeWpCLGVBQU9KLFFBQVFyakIsQ0FBUixDQUFQO0FBQ0EsWUFBSXlqQixTQUFTLEdBQWIsRUFBa0I7QUFDaEJKLG9CQUFRekgsTUFBUixDQUFlNWIsQ0FBZixFQUFrQixDQUFsQjtBQUNELFNBRkQsTUFFTyxJQUFJeWpCLFNBQVMsSUFBYixFQUFtQjtBQUN4Qkosb0JBQVF6SCxNQUFSLENBQWU1YixDQUFmLEVBQWtCLENBQWxCO0FBQ0EyakI7QUFDRCxTQUhNLE1BR0EsSUFBSUEsRUFBSixFQUFRO0FBQ2JOLG9CQUFRekgsTUFBUixDQUFlNWIsQ0FBZixFQUFrQixDQUFsQjtBQUNBMmpCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFFBQUksQ0FBQ1IsVUFBRCxJQUFlLENBQUNDLGFBQXBCLEVBQW1DO0FBQ2pDLGVBQU9PLElBQVAsRUFBYUEsRUFBYixFQUFpQjtBQUNmTixvQkFBUXRCLE9BQVIsQ0FBZ0IsSUFBaEI7QUFDRDtBQUNGOztBQUVELFFBQUlvQixjQUFjRSxRQUFRLENBQVIsTUFBZSxFQUE3QixLQUNDLENBQUNBLFFBQVEsQ0FBUixDQUFELElBQWVBLFFBQVEsQ0FBUixFQUFXZCxNQUFYLENBQWtCLENBQWxCLE1BQXlCLEdBRHpDLENBQUosRUFDbUQ7QUFDakRjLGdCQUFRdEIsT0FBUixDQUFnQixFQUFoQjtBQUNEOztBQUVELFFBQUkyQixvQkFBcUJMLFFBQVFqWSxJQUFSLENBQWEsR0FBYixFQUFrQkMsTUFBbEIsQ0FBeUIsQ0FBQyxDQUExQixNQUFpQyxHQUExRCxFQUFnRTtBQUM5RGdZLGdCQUFRcmlCLElBQVIsQ0FBYSxFQUFiO0FBQ0Q7O0FBRUQsUUFBSTRpQixhQUFhUCxRQUFRLENBQVIsTUFBZSxFQUFmLElBQ1pBLFFBQVEsQ0FBUixLQUFjQSxRQUFRLENBQVIsRUFBV2QsTUFBWCxDQUFrQixDQUFsQixNQUF5QixHQUQ1Qzs7QUFHQTtBQUNBLFFBQUllLFNBQUosRUFBZTtBQUNiOUwsZUFBTzRILFFBQVAsR0FBa0I1SCxPQUFPbFIsSUFBUCxHQUFjc2QsYUFBYSxFQUFiLEdBQ0FQLFFBQVFoakIsTUFBUixHQUFpQmdqQixRQUFRTCxLQUFSLEVBQWpCLEdBQW1DLEVBRG5FO0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBSVEsYUFBYWhNLE9BQU9sUixJQUFQLElBQWVrUixPQUFPbFIsSUFBUCxDQUFZdkYsT0FBWixDQUFvQixHQUFwQixJQUEyQixDQUExQyxHQUNBeVcsT0FBT2xSLElBQVAsQ0FBWTFGLEtBQVosQ0FBa0IsR0FBbEIsQ0FEQSxHQUN5QixLQUQxQztBQUVBLFlBQUk0aUIsVUFBSixFQUFnQjtBQUNkaE0sbUJBQU8wSCxJQUFQLEdBQWNzRSxXQUFXUixLQUFYLEVBQWQ7QUFDQXhMLG1CQUFPbFIsSUFBUCxHQUFja1IsT0FBTzRILFFBQVAsR0FBa0JvRSxXQUFXUixLQUFYLEVBQWhDO0FBQ0Q7QUFDRjs7QUFFREcsaUJBQWFBLGNBQWUzTCxPQUFPbFIsSUFBUCxJQUFlK2MsUUFBUWhqQixNQUFuRDs7QUFFQSxRQUFJOGlCLGNBQWMsQ0FBQ1MsVUFBbkIsRUFBK0I7QUFDN0JQLGdCQUFRdEIsT0FBUixDQUFnQixFQUFoQjtBQUNEOztBQUVELFFBQUksQ0FBQ3NCLFFBQVFoakIsTUFBYixFQUFxQjtBQUNuQm1YLGVBQU90TSxRQUFQLEdBQWtCLElBQWxCO0FBQ0FzTSxlQUFPdlYsSUFBUCxHQUFjLElBQWQ7QUFDRCxLQUhELE1BR087QUFDTHVWLGVBQU90TSxRQUFQLEdBQWtCbVksUUFBUWpZLElBQVIsQ0FBYSxHQUFiLENBQWxCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJLENBQUNzUixLQUFLSSxNQUFMLENBQVl0RixPQUFPdE0sUUFBbkIsQ0FBRCxJQUFpQyxDQUFDd1IsS0FBS0ksTUFBTCxDQUFZdEYsT0FBTzhILE1BQW5CLENBQXRDLEVBQWtFO0FBQ2hFOUgsZUFBT3ZWLElBQVAsR0FBYyxDQUFDdVYsT0FBT3RNLFFBQVAsR0FBa0JzTSxPQUFPdE0sUUFBekIsR0FBb0MsRUFBckMsS0FDQ3NNLE9BQU84SCxNQUFQLEdBQWdCOUgsT0FBTzhILE1BQXZCLEdBQWdDLEVBRGpDLENBQWQ7QUFFRDtBQUNEOUgsV0FBTzBILElBQVAsR0FBY3NELFNBQVN0RCxJQUFULElBQWlCMUgsT0FBTzBILElBQXRDO0FBQ0ExSCxXQUFPeUgsT0FBUCxHQUFpQnpILE9BQU95SCxPQUFQLElBQWtCdUQsU0FBU3ZELE9BQTVDO0FBQ0F6SCxXQUFPbFcsSUFBUCxHQUFja1csT0FBTzFPLE1BQVAsRUFBZDtBQUNBLFdBQU8wTyxNQUFQO0FBQ0QsQ0E1UUQ7O0FBOFFBdUgsSUFBSTlCLFNBQUosQ0FBY3NFLFNBQWQsR0FBMEIsWUFBVztBQUNuQyxRQUFJamIsT0FBTyxLQUFLQSxJQUFoQjtBQUNBLFFBQUk2WSxPQUFPTSxZQUFZd0IsSUFBWixDQUFpQjNhLElBQWpCLENBQVg7QUFDQSxRQUFJNlksSUFBSixFQUFVO0FBQ1JBLGVBQU9BLEtBQUssQ0FBTCxDQUFQO0FBQ0EsWUFBSUEsU0FBUyxHQUFiLEVBQWtCO0FBQ2hCLGlCQUFLQSxJQUFMLEdBQVlBLEtBQUs5VCxNQUFMLENBQVksQ0FBWixDQUFaO0FBQ0Q7QUFDRC9FLGVBQU9BLEtBQUsrRSxNQUFMLENBQVksQ0FBWixFQUFlL0UsS0FBS2pHLE1BQUwsR0FBYzhlLEtBQUs5ZSxNQUFsQyxDQUFQO0FBQ0Q7QUFDRCxRQUFJaUcsSUFBSixFQUFVO0FBQUUsYUFBSzhZLFFBQUwsR0FBZ0I5WSxJQUFoQjtBQUF1QjtBQUNwQyxDQVhEOztBQWFBLElBQUl0RSxNQUFNO0FBQ1RhLFdBQU9BLEtBREU7QUFFVEgsYUFBU0EsT0FGQTtBQUdUZ2MsbUJBQWVBLGFBSE47QUFJVDVWLFlBQVE4VixRQUpDO0FBS1RHLFNBQUtEO0FBTEksQ0FBVjs7QUFRQSxTQUFTK0Usb0JBQVQsQ0FBOEJDLFlBQTlCLEVBQTRDO0FBQ3hDLFNBQUssSUFBSTlqQixJQUFJLENBQWIsRUFBZ0JBLElBQUltVixHQUFHdFQsTUFBSCxDQUFVeEIsTUFBOUIsRUFBc0NMLEdBQXRDLEVBQTJDO0FBQ3ZDLGFBQUssSUFBSXFKLEdBQVQsSUFBZ0I4TCxHQUFHQSxHQUFHdFQsTUFBSCxDQUFVN0IsQ0FBVixDQUFILENBQWhCLEVBQWtDO0FBQzlCLGdCQUFJcUosUUFBUXlhLFlBQVosRUFBMEI7QUFDdEIsdUJBQU8zTyxHQUFHQSxHQUFHdFQsTUFBSCxDQUFVN0IsQ0FBVixDQUFILEVBQWlCcUosR0FBakIsQ0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNELFNBQUssSUFBSTBhLE1BQU0sQ0FBZixFQUFrQkEsTUFBTTVPLEdBQUcvUCxLQUFILENBQVMvRSxNQUFqQyxFQUF5QzBqQixLQUF6QyxFQUFnRDtBQUM1QyxhQUFLLElBQUl0TSxLQUFULElBQWtCdEMsR0FBR0EsR0FBRy9QLEtBQUgsQ0FBUzJlLEdBQVQsQ0FBSCxDQUFsQixFQUFxQztBQUNqQyxnQkFBSXRNLFVBQVVxTSxZQUFkLEVBQTRCO0FBQ3hCLHVCQUFPM08sR0FBR0EsR0FBRy9QLEtBQUgsQ0FBUzJlLEdBQVQsQ0FBSCxFQUFrQnRNLEtBQWxCLENBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSDtBQUNELFNBQVN1TSxVQUFULENBQW9CMWYsS0FBcEIsRUFBMkIyZixRQUEzQixFQUFxQztBQUNqQyxTQUFLLElBQUluSixDQUFULElBQWN4VyxNQUFNeUQsT0FBcEIsRUFBNkI7QUFDekJrYyxpQkFBUzNmLE1BQU15RCxPQUFOLENBQWMrUyxDQUFkLENBQVQ7QUFDSDtBQUNKO0FBQ0QsU0FBU29KLFNBQVQsQ0FBbUI1ZixLQUFuQixFQUEwQjJmLFFBQTFCLEVBQW9DO0FBQ2hDLFNBQUssSUFBSWprQixJQUFJLENBQVIsRUFBV21rQixPQUFPN2YsTUFBTUksTUFBN0IsRUFBcUMxRSxJQUFJbWtCLEtBQUs5akIsTUFBOUMsRUFBc0RMLEtBQUssQ0FBM0QsRUFBOEQ7QUFDMUQsWUFBSTRCLFFBQVF1aUIsS0FBS25rQixDQUFMLENBQVo7QUFDQWlrQixpQkFBU3JpQixLQUFUO0FBQ0g7QUFDSjtBQUNELFNBQVN3aUIsWUFBVCxDQUFzQjlmLEtBQXRCLEVBQTZCNFIsT0FBN0IsRUFBc0MrTixRQUF0QyxFQUFnRDtBQUM1QyxhQUFTSSxLQUFULENBQWV6aUIsS0FBZixFQUFzQjBpQixZQUF0QixFQUFvQztBQUNoQyxZQUFJblIsYUFBYXZSLE1BQU0waUIsWUFBTixDQUFqQjtBQUNBLFlBQUksQ0FBQ25SLFVBQUwsRUFBaUI7QUFDYjtBQUNIO0FBQ0RrRSxlQUFPTixJQUFQLENBQVk1RCxVQUFaLEVBQXdCb1IsT0FBeEIsQ0FBZ0MsVUFBVWxiLEdBQVYsRUFBZTtBQUMzQzRhLHFCQUFTO0FBQ0xoaUIsc0JBQU0sQ0FDRkwsTUFBTStDLEVBREosRUFFRjJmLFlBRkUsRUFHRmpiLEdBSEUsQ0FERDtBQU1MQSxxQkFBS0EsR0FOQTtBQU9MNkMsdUJBQU9pSCxXQUFXOUosR0FBWCxDQVBGO0FBUUxrTywyQkFBV3NNLHFCQUFxQnhhLEdBQXJCLENBUk47QUFTTHlCLHFCQUFLLFNBQVNBLEdBQVQsQ0FBYTJTLENBQWIsRUFBZ0I7QUFDakJ0SywrQkFBVzlKLEdBQVgsSUFBa0JvVSxDQUFsQjtBQUNIO0FBWEksYUFBVDtBQWFILFNBZEQ7QUFlSDtBQUNEeUcsY0FBVTVmLEtBQVYsRUFBaUIsVUFBVTFDLEtBQVYsRUFBaUI7QUFDOUIsWUFBSXNVLFFBQVE5USxLQUFaLEVBQW1CO0FBQ2ZpZixrQkFBTXppQixLQUFOLEVBQWEsT0FBYjtBQUNIO0FBQ0QsWUFBSXNVLFFBQVFyVSxNQUFaLEVBQW9CO0FBQ2hCd2lCLGtCQUFNemlCLEtBQU4sRUFBYSxRQUFiO0FBQ0g7QUFDSixLQVBEO0FBUUg7O0FBRUQsU0FBUzRpQixVQUFULENBQW9CNWlCLEtBQXBCLEVBQTJCcWlCLFFBQTNCLEVBQXFDO0FBQ2pDLFNBQUssSUFBSW5KLENBQVQsSUFBY2xaLEtBQWQsRUFBcUI7QUFDakIsWUFBSWtaLEVBQUUvWixPQUFGLENBQVUsUUFBVixNQUF3QixDQUE1QixFQUErQjtBQUMzQmtqQixxQkFBU3JpQixNQUFNa1osQ0FBTixDQUFULEVBQW1CQSxDQUFuQjtBQUNIO0FBQ0o7QUFDSjtBQUNELFNBQVMySixTQUFULENBQW1CN2lCLEtBQW5CLEVBQTBCcWlCLFFBQTFCLEVBQW9DO0FBQ2hDLFNBQUssSUFBSW5KLENBQVQsSUFBY2xaLEtBQWQsRUFBcUI7QUFDakIsWUFBSWtaLEVBQUUvWixPQUFGLENBQVUsT0FBVixNQUF1QixDQUEzQixFQUE4QjtBQUMxQmtqQixxQkFBU3JpQixNQUFNa1osQ0FBTixDQUFULEVBQW1CQSxDQUFuQjtBQUNIO0FBQ0o7QUFDSjtBQUNELFNBQVM0SixlQUFULENBQXlCcGdCLEtBQXpCLEVBQWdDNEgsS0FBaEMsRUFBdUM7QUFDbkMsUUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQWpCLElBQTZCQSxNQUFNLENBQU4sTUFBYSxHQUE5QyxFQUFtRDtBQUMvQyxlQUFPd1ksZ0JBQWdCcGdCLEtBQWhCLEVBQXVCQSxNQUFNcWdCLFNBQU4sQ0FBZ0J6WSxLQUFoQixDQUF2QixDQUFQO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsZUFBT0EsS0FBUDtBQUNIO0FBQ0o7QUFDRCxTQUFTMFksVUFBVCxDQUFvQjFZLEtBQXBCLEVBQTJCO0FBQ3ZCLFdBQU9oTSxNQUFNQyxPQUFOLENBQWMrTCxNQUFNOUwsS0FBcEIsQ0FBUDtBQUNIO0FBQ0QsU0FBU3lrQixjQUFULENBQXdCck8sR0FBeEIsRUFBNkJzTyxJQUE3QixFQUFtQ0MsRUFBbkMsRUFBdUM7QUFDbkN2TyxRQUFJdU8sRUFBSixJQUFVdk8sSUFBSXNPLElBQUosQ0FBVjtBQUNBLFdBQU90TyxJQUFJc08sSUFBSixDQUFQO0FBQ0g7QUFDRCxTQUFTRSxXQUFULENBQXNCMWdCLEtBQXRCLEVBQTZCO0FBQ3pCQSxVQUFNeEIsT0FBTixHQUFnQixDQUFoQjtBQUNBa2hCLGVBQVcxZixLQUFYLEVBQWtCLFVBQVUvQixNQUFWLEVBQWtCO0FBQ2hDLFlBQUlBLE9BQU95QyxJQUFQLEtBQWdCLE9BQWhCLElBQTJCekMsT0FBT1AsR0FBUCxLQUFlZ0MsU0FBOUMsRUFBeUQ7QUFDckQ2Z0IsMkJBQWV0aUIsTUFBZixFQUF1QixLQUF2QixFQUE4QixNQUE5QjtBQUNIO0FBQ0QsWUFBSUEsT0FBT3lDLElBQVAsS0FBZ0IsT0FBcEIsRUFBNkI7QUFDekJ6QyxtQkFBT21NLFdBQVAsQ0FBbUI2VixPQUFuQixDQUEyQixVQUFVVSxLQUFWLEVBQWlCO0FBQ3hDLHVCQUFPQSxNQUFNQyxPQUFOLEVBQVA7QUFDSCxhQUZEO0FBR0g7QUFDSixLQVREO0FBVUFoQixjQUFVNWYsS0FBVixFQUFpQixVQUFVMUMsS0FBVixFQUFpQjtBQUM5QjRpQixtQkFBVzVpQixLQUFYLEVBQWtCLFVBQVVDLE1BQVYsRUFBa0I7QUFDaEMsZ0JBQUlBLE9BQU8scUJBQVAsTUFBa0NtQyxTQUF0QyxFQUFpRDtBQUM3QzZnQiwrQkFBZWhqQixNQUFmLEVBQXVCLHFCQUF2QixFQUE4QyxnQkFBOUM7QUFDSDtBQUNKLFNBSkQ7QUFLQTRpQixrQkFBVTdpQixLQUFWLEVBQWlCLFVBQVV3RCxLQUFWLEVBQWlCO0FBQzlCLGdCQUFJQSxNQUFNLGtCQUFOLE1BQThCcEIsU0FBbEMsRUFBNkM7QUFDekM2Z0IsK0JBQWV6ZixLQUFmLEVBQXNCLGtCQUF0QixFQUEwQyxvQkFBMUM7QUFDSDtBQUNELGdCQUFJQSxNQUFNLFlBQU4sTUFBd0JwQixTQUE1QixFQUF1QztBQUNuQzZnQiwrQkFBZXpmLEtBQWYsRUFBc0IsWUFBdEIsRUFBb0MsY0FBcEM7QUFDSDtBQUNELGdCQUFJQSxNQUFNLFlBQU4sTUFBd0JwQixTQUE1QixFQUF1QztBQUNuQzZnQiwrQkFBZXpmLEtBQWYsRUFBc0IsWUFBdEIsRUFBb0MsY0FBcEM7QUFDSDtBQUNKLFNBVkQ7QUFXSCxLQWpCRDtBQWtCQWdmLGlCQUFhOWYsS0FBYixFQUFvQjtBQUNoQmMsZUFBTyxJQURTO0FBRWhCdkQsZ0JBQVE7QUFGUSxLQUFwQixFQUdHLFVBQVV3VCxRQUFWLEVBQW9CO0FBQ25CLFlBQUluSixRQUFRd1ksZ0JBQWdCcGdCLEtBQWhCLEVBQXVCK1EsU0FBU25KLEtBQWhDLENBQVo7QUFDQSxZQUFJMFksV0FBVzFZLEtBQVgsQ0FBSixFQUF1QjtBQUNuQkEsa0JBQU05TCxLQUFOLENBQVlta0IsT0FBWixDQUFvQixVQUFVWSxJQUFWLEVBQWdCO0FBQ2hDQSxxQkFBSyxDQUFMLElBQVVULGdCQUFnQnBnQixLQUFoQixFQUF1QjZnQixLQUFLLENBQUwsQ0FBdkIsQ0FBVjtBQUNILGFBRkQ7QUFHSDtBQUNEOVAsaUJBQVN2SyxHQUFULENBQWFvQixLQUFiO0FBQ0gsS0FYRDtBQVlBLFdBQU81SCxNQUFNcWdCLFNBQWI7QUFDQVQsY0FBVTVmLEtBQVYsRUFBaUIsVUFBVTFDLEtBQVYsRUFBaUI7QUFDOUI0aUIsbUJBQVc1aUIsS0FBWCxFQUFrQixVQUFVQyxNQUFWLEVBQWtCO0FBQ2hDLG1CQUFPQSxPQUFPLGVBQVAsQ0FBUDtBQUNBLG1CQUFPQSxPQUFPLGVBQVAsQ0FBUDtBQUNILFNBSEQ7QUFJQTRpQixrQkFBVTdpQixLQUFWLEVBQWlCLFVBQVV3RCxLQUFWLEVBQWlCO0FBQzlCLGdCQUFJQSxNQUFNLFdBQU4sQ0FBSixFQUF3QjtBQUNwQixvQkFBSSxDQUFDeEQsTUFBTUMsTUFBWCxFQUFtQjtBQUNmRCwwQkFBTUMsTUFBTixHQUFlLEVBQWY7QUFDSDtBQUNERCxzQkFBTUMsTUFBTixDQUFhLFdBQWIsSUFBNEJ1RCxNQUFNLFdBQU4sQ0FBNUI7QUFDQSx1QkFBT0EsTUFBTSxXQUFOLENBQVA7QUFDSDtBQUNELGdCQUFJQSxNQUFNLFdBQU4sQ0FBSixFQUF3QjtBQUNwQixvQkFBSSxDQUFDeEQsTUFBTUMsTUFBWCxFQUFtQjtBQUNmRCwwQkFBTUMsTUFBTixHQUFlLEVBQWY7QUFDSDtBQUNERCxzQkFBTUMsTUFBTixDQUFhLFdBQWIsSUFBNEJ1RCxNQUFNLFdBQU4sQ0FBNUI7QUFDQSx1QkFBT0EsTUFBTSxXQUFOLENBQVA7QUFDSDtBQUNKLFNBZkQ7QUFnQkgsS0FyQkQ7QUFzQkEsYUFBU2dnQixtQkFBVCxDQUE2QnBLLEtBQTdCLEVBQW9DO0FBQ2hDLFlBQUlxSyxjQUFjcmpCLElBQUlhLEtBQUosQ0FBVW1ZLEtBQVYsQ0FBbEI7QUFDQSxZQUFJc0sscUJBQXFCRCxZQUFZbmEsUUFBWixDQUFxQnRLLEtBQXJCLENBQTJCLEdBQTNCLENBQXpCO0FBQ0EsWUFBSXlrQixZQUFZckcsUUFBWixLQUF5QixTQUE3QixFQUF3QztBQUNwQyxtQkFBT2hFLEtBQVA7QUFDSCxTQUZELE1BRU8sSUFBSXFLLFlBQVlqRyxRQUFaLEtBQXlCLFdBQTdCLEVBQTBDO0FBQzdDLG1CQUFPLCtDQUFQO0FBQ0gsU0FGTSxNQUVBLElBQUlpRyxZQUFZakcsUUFBWixLQUF5QixPQUE3QixFQUFzQztBQUN6QyxtQkFBTyxvQkFBb0JrRyxtQkFBbUIsQ0FBbkIsQ0FBcEIsR0FBNEMsMEJBQW5EO0FBQ0g7QUFDSjtBQUNELFFBQUloaEIsTUFBTXFJLE1BQVYsRUFBa0I7QUFDZHJJLGNBQU1xSSxNQUFOLEdBQWV5WSxvQkFBb0I5Z0IsTUFBTXFJLE1BQTFCLENBQWY7QUFDSDtBQUNELGFBQVM0WSxnQkFBVCxDQUEwQjVrQixJQUExQixFQUFnQztBQUM1QixpQkFBUzZrQixZQUFULENBQXNCNVMsTUFBdEIsRUFBOEI7QUFDMUIsbUJBQU9BLE9BQU9oUyxLQUFQLENBQWEsR0FBYixFQUFrQkYsR0FBbEIsQ0FBc0IsVUFBVTRoQixDQUFWLEVBQWE7QUFDdEMsdUJBQU9BLEVBQUV2QixJQUFGLEVBQVA7QUFDSCxhQUZNLENBQVA7QUFHSDtBQUNELFlBQUk3Z0IsTUFBTUMsT0FBTixDQUFjUSxJQUFkLENBQUosRUFBeUI7QUFDckIsbUJBQU9BLElBQVA7QUFDSCxTQUZELE1BRU8sSUFBSSxPQUFPQSxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQ2pDLG1CQUFPNmtCLGFBQWE3a0IsSUFBYixDQUFQO0FBQ0gsU0FGTSxNQUVBLElBQUksUUFBT0EsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUFwQixFQUE4QjtBQUNqQ0EsaUJBQUtQLEtBQUwsQ0FBV21rQixPQUFYLENBQW1CLFVBQVVZLElBQVYsRUFBZ0I7QUFDL0JBLHFCQUFLLENBQUwsSUFBVUssYUFBYUwsS0FBSyxDQUFMLENBQWIsQ0FBVjtBQUNILGFBRkQ7QUFHQSxtQkFBT3hrQixJQUFQO0FBQ0gsU0FMTSxNQUtBO0FBQ0gsa0JBQU0sSUFBSW9DLEtBQUosQ0FBVSx1QkFBVixDQUFOO0FBQ0g7QUFDSjtBQUNEbWhCLGNBQVU1ZixLQUFWLEVBQWlCLFVBQVUxQyxLQUFWLEVBQWlCO0FBQzlCNGlCLG1CQUFXNWlCLEtBQVgsRUFBa0IsVUFBVUMsTUFBVixFQUFrQjtBQUNoQyxnQkFBSUEsT0FBTyxXQUFQLENBQUosRUFBeUI7QUFDckJBLHVCQUFPLFdBQVAsSUFBc0IwakIsaUJBQWlCMWpCLE9BQU8sV0FBUCxDQUFqQixDQUF0QjtBQUNIO0FBQ0osU0FKRDtBQUtILEtBTkQ7QUFPQSxRQUFJNGpCLG1CQUFtQixDQUF2QjtBQUNBLFNBQUssSUFBSXpsQixJQUFJc0UsTUFBTUksTUFBTixDQUFhckUsTUFBYixHQUFzQixDQUFuQyxFQUFzQ0wsS0FBSyxDQUEzQyxFQUE4Q0EsR0FBOUMsRUFBbUQ7QUFDL0MsWUFBSTRCLFFBQVEwQyxNQUFNSSxNQUFOLENBQWExRSxDQUFiLENBQVo7QUFDQSxZQUFJNEIsTUFBTW9ELElBQU4sS0FBZSxRQUFuQixFQUE2QjtBQUN6QnlnQiwrQkFBbUJ6bEIsSUFBSSxDQUF2QjtBQUNBO0FBQ0g7QUFDSjtBQUNELFFBQUkwbEIsZUFBZXBoQixNQUFNSSxNQUFOLENBQWFrWCxNQUFiLENBQW9CNkosZ0JBQXBCLENBQW5CO0FBQ0FDLGlCQUFhUixPQUFiO0FBQ0E1Z0IsVUFBTUksTUFBTixHQUFlSixNQUFNSSxNQUFOLENBQWE2UCxNQUFiLENBQW9CbVIsWUFBcEIsQ0FBZjtBQUNBLFdBQU9waEIsS0FBUDtBQUNIOztBQUVELFNBQVNxaEIsTUFBVCxDQUFpQjNMLE1BQWpCLEVBQXlCO0FBQ3JCLFFBQUk0TCxTQUFTLEVBQWI7QUFBQSxRQUFpQnBJLE1BQU1xSSxVQUFVeGxCLE1BQVYsR0FBbUIsQ0FBMUM7QUFDQSxXQUFPbWQsUUFBUSxDQUFmO0FBQ0lvSSxlQUFPcEksR0FBUCxJQUFjcUksVUFBVXJJLE1BQU0sQ0FBaEIsQ0FBZDtBQURKLEtBRUEsS0FBSyxJQUFJeGQsSUFBSSxDQUFSLEVBQVdta0IsT0FBT3lCLE1BQXZCLEVBQStCNWxCLElBQUlta0IsS0FBSzlqQixNQUF4QyxFQUFnREwsS0FBSyxDQUFyRCxFQUF3RDtBQUNwRCxZQUFJZ2IsUUFBUW1KLEtBQUtua0IsQ0FBTCxDQUFaO0FBQ0EsYUFBSyxJQUFJOGEsQ0FBVCxJQUFjRSxLQUFkLEVBQXFCO0FBQ2pCaEIsbUJBQU9jLENBQVAsSUFBWUUsTUFBTUYsQ0FBTixDQUFaO0FBQ0g7QUFDSjtBQUNELFdBQU9kLE1BQVA7QUFDSDs7QUFFRCxJQUFJOEwsZUFBZSxVQUFVL2lCLEtBQVYsRUFBaUI7QUFDaEMsYUFBUytpQixZQUFULENBQXNCemMsR0FBdEIsRUFBMkIwYyxPQUEzQixFQUFvQztBQUNoQ2hqQixjQUFNbWEsSUFBTixDQUFXLElBQVgsRUFBaUI2SSxPQUFqQjtBQUNBLGFBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNBLGFBQUsxYyxHQUFMLEdBQVdBLEdBQVg7QUFDSDtBQUNELFFBQUl0RyxLQUFKLEVBQ0kraUIsYUFBYUUsU0FBYixHQUF5QmpqQixLQUF6QjtBQUNKK2lCLGlCQUFhN0ksU0FBYixHQUF5QjVGLE9BQU80TyxNQUFQLENBQWNsakIsU0FBU0EsTUFBTWthLFNBQTdCLENBQXpCO0FBQ0E2SSxpQkFBYTdJLFNBQWIsQ0FBdUJpSixXQUF2QixHQUFxQ0osWUFBckM7QUFDQSxXQUFPQSxZQUFQO0FBQ0gsQ0FYa0IsQ0FXakIvaUIsS0FYaUIsQ0FBbkI7O0FBYUEsSUFBSW9qQixRQUFRLFNBQVNBLEtBQVQsQ0FBZUMsTUFBZixFQUF1QkMsUUFBdkIsRUFBaUM7QUFDekMsUUFBSUEsYUFBYSxLQUFLLENBQXRCLEVBQ0lBLFdBQVcsRUFBWDtBQUNKLFNBQUtELE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUtDLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQSxTQUFLLElBQUlybUIsSUFBSSxDQUFSLEVBQVdta0IsT0FBT2tDLFFBQXZCLEVBQWlDcm1CLElBQUlta0IsS0FBSzlqQixNQUExQyxFQUFrREwsS0FBSyxDQUF2RCxFQUEwRDtBQUN0RCxZQUFJa0csTUFBTWllLEtBQUtua0IsQ0FBTCxDQUFWO0FBQ0EsWUFBSWdNLE9BQU85RixJQUFJLENBQUosQ0FBWDtBQUNBLFlBQUl5SixhQUFhekosSUFBSSxDQUFKLENBQWpCO0FBQ0EsYUFBS21nQixRQUFMLENBQWNyYSxJQUFkLElBQXNCMkQsVUFBdEI7QUFDSDtBQUNKLENBWEQ7QUFZQXdXLE1BQU1sSixTQUFOLENBQWdCMUksTUFBaEIsR0FBeUIsU0FBU0EsTUFBVCxDQUFnQjhSLFFBQWhCLEVBQTBCO0FBQy9DLFdBQU8sSUFBSUYsS0FBSixDQUFVLElBQVYsRUFBZ0JFLFFBQWhCLENBQVA7QUFDSCxDQUZEO0FBR0FGLE1BQU1sSixTQUFOLENBQWdCeFIsR0FBaEIsR0FBc0IsU0FBU0EsR0FBVCxDQUFhTyxJQUFiLEVBQW1CO0FBQ3JDLFFBQUksS0FBS3FhLFFBQUwsQ0FBY3JhLElBQWQsQ0FBSixFQUF5QjtBQUNyQixlQUFPLEtBQUtxYSxRQUFMLENBQWNyYSxJQUFkLENBQVA7QUFDSDtBQUNELFFBQUksS0FBS29hLE1BQVQsRUFBaUI7QUFDYixlQUFPLEtBQUtBLE1BQUwsQ0FBWTNhLEdBQVosQ0FBZ0JPLElBQWhCLENBQVA7QUFDSDtBQUNELFVBQU0sSUFBSWpKLEtBQUosQ0FBVWlKLE9BQU8sc0JBQWpCLENBQU47QUFDSCxDQVJEO0FBU0FtYSxNQUFNbEosU0FBTixDQUFnQnJMLEdBQWhCLEdBQXNCLFNBQVNBLEdBQVQsQ0FBYTVGLElBQWIsRUFBbUI7QUFDckMsUUFBSSxLQUFLcWEsUUFBTCxDQUFjcmEsSUFBZCxDQUFKLEVBQXlCO0FBQ3JCLGVBQU8sSUFBUDtBQUNIO0FBQ0QsV0FBTyxLQUFLb2EsTUFBTCxHQUFjLEtBQUtBLE1BQUwsQ0FBWXhVLEdBQVosQ0FBZ0I1RixJQUFoQixDQUFkLEdBQXNDLEtBQTdDO0FBQ0gsQ0FMRDs7QUFPQSxJQUFJc2EsV0FBVyxFQUFFQyxNQUFNLE1BQVIsRUFBZjtBQUNBLElBQUlDLGFBQWEsRUFBRUQsTUFBTSxRQUFSLEVBQWpCO0FBQ0EsSUFBSUUsYUFBYSxFQUFFRixNQUFNLFFBQVIsRUFBakI7QUFDQSxJQUFJRyxjQUFjLEVBQUVILE1BQU0sU0FBUixFQUFsQjtBQUNBLElBQUlJLFlBQVksRUFBRUosTUFBTSxPQUFSLEVBQWhCO0FBQ0EsSUFBSUssYUFBYSxFQUFFTCxNQUFNLFFBQVIsRUFBakI7QUFDQSxJQUFJTSxZQUFZLEVBQUVOLE1BQU0sT0FBUixFQUFoQjtBQUNBLElBQUlPLFlBQVksRUFBRVAsTUFBTSxPQUFSLEVBQWhCO0FBQ0EsSUFBSVEsZUFBZSxFQUFFUixNQUFNLFVBQVIsRUFBbkI7QUFDQSxJQUFJUyxnQkFBZ0IsRUFBRVQsTUFBTSxXQUFSLEVBQXBCO0FBQ0EsSUFBSVUsb0JBQW9CLEVBQUVWLE1BQU0sZUFBUixFQUF4QjtBQUNBLFNBQVNsVSxLQUFULENBQWU2VSxRQUFmLEVBQXlCQyxDQUF6QixFQUE0QjtBQUN4QixXQUFPO0FBQ0haLGNBQU0sT0FESDtBQUVIVyxrQkFBVUEsUUFGUDtBQUdIQyxXQUFHQTtBQUhBLEtBQVA7QUFLSDtBQUNELFNBQVN6aEIsUUFBVCxDQUFrQlYsSUFBbEIsRUFBd0I7QUFDcEIsUUFBSUEsS0FBS3VoQixJQUFMLEtBQWMsT0FBbEIsRUFBMkI7QUFDdkIsWUFBSVcsV0FBV3hoQixTQUFTVixLQUFLa2lCLFFBQWQsQ0FBZjtBQUNBLGVBQU8sT0FBT2xpQixLQUFLbWlCLENBQVosS0FBa0IsUUFBbEIsR0FBNkIsV0FBV0QsUUFBWCxHQUFzQixJQUF0QixHQUE2QmxpQixLQUFLbWlCLENBQWxDLEdBQXNDLEdBQW5FLEdBQXlFbmlCLEtBQUtraUIsUUFBTCxDQUFjWCxJQUFkLEtBQXVCLE9BQXZCLEdBQWlDLE9BQWpDLEdBQTJDLFdBQVdXLFFBQVgsR0FBc0IsR0FBako7QUFDSCxLQUhELE1BR087QUFDSCxlQUFPbGlCLEtBQUt1aEIsSUFBWjtBQUNIO0FBQ0o7QUFDRCxJQUFJYSxtQkFBbUIsQ0FDbkJkLFFBRG1CLEVBRW5CRSxVQUZtQixFQUduQkMsVUFIbUIsRUFJbkJDLFdBSm1CLEVBS25CQyxTQUxtQixFQU1uQkssYUFObUIsRUFPbkJKLFVBUG1CLEVBUW5CdlUsTUFBTXdVLFNBQU4sQ0FSbUIsRUFTbkJJLGlCQVRtQixDQUF2QjtBQVdBLFNBQVNJLFlBQVQsQ0FBc0JDLFFBQXRCLEVBQWdDN0wsQ0FBaEMsRUFBbUM7QUFDL0IsUUFBSUEsRUFBRThLLElBQUYsS0FBVyxPQUFmLEVBQXdCO0FBQ3BCLGVBQU8sSUFBUDtBQUNILEtBRkQsTUFFTyxJQUFJZSxTQUFTZixJQUFULEtBQWtCLE9BQXRCLEVBQStCO0FBQ2xDLFlBQUk5SyxFQUFFOEssSUFBRixLQUFXLE9BQVgsS0FBdUI5SyxFQUFFMEwsQ0FBRixLQUFRLENBQVIsSUFBYTFMLEVBQUV5TCxRQUFGLENBQVdYLElBQVgsS0FBb0IsT0FBakMsSUFBNEMsQ0FBQ2MsYUFBYUMsU0FBU0osUUFBdEIsRUFBZ0N6TCxFQUFFeUwsUUFBbEMsQ0FBcEUsTUFBcUgsT0FBT0ksU0FBU0gsQ0FBaEIsS0FBc0IsUUFBdEIsSUFBa0NHLFNBQVNILENBQVQsS0FBZTFMLEVBQUUwTCxDQUF4SyxDQUFKLEVBQWdMO0FBQzVLLG1CQUFPLElBQVA7QUFDSDtBQUNKLEtBSk0sTUFJQSxJQUFJRyxTQUFTZixJQUFULEtBQWtCOUssRUFBRThLLElBQXhCLEVBQThCO0FBQ2pDLGVBQU8sSUFBUDtBQUNILEtBRk0sTUFFQSxJQUFJZSxTQUFTZixJQUFULEtBQWtCLE9BQXRCLEVBQStCO0FBQ2xDLGFBQUssSUFBSXZtQixJQUFJLENBQVIsRUFBV21rQixPQUFPaUQsZ0JBQXZCLEVBQXlDcG5CLElBQUlta0IsS0FBSzlqQixNQUFsRCxFQUEwREwsS0FBSyxDQUEvRCxFQUFrRTtBQUM5RCxnQkFBSXVuQixhQUFhcEQsS0FBS25rQixDQUFMLENBQWpCO0FBQ0EsZ0JBQUksQ0FBQ3FuQixhQUFhRSxVQUFiLEVBQXlCOUwsQ0FBekIsQ0FBTCxFQUFrQztBQUM5Qix1QkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsV0FBTyxjQUFjL1YsU0FBUzRoQixRQUFULENBQWQsR0FBbUMsYUFBbkMsR0FBbUQ1aEIsU0FBUytWLENBQVQsQ0FBbkQsR0FBaUUsV0FBeEU7QUFDSDtBQUNELFNBQVMrTCxXQUFULENBQXFCQyxRQUFyQixFQUErQkMsWUFBL0IsRUFBNkM7QUFDekMsV0FBT0EsYUFBYTNoQixJQUFiLENBQWtCLFVBQVUwVixDQUFWLEVBQWE7QUFDbEMsZUFBT0EsRUFBRThLLElBQUYsS0FBV2tCLFNBQVNsQixJQUEzQjtBQUNILEtBRk0sQ0FBUDtBQUdIO0FBQ0QsU0FBU29CLGlCQUFULENBQTJCRixRQUEzQixFQUFxQ0MsWUFBckMsRUFBbUQ7QUFDL0MsV0FBT0EsYUFBYTNoQixJQUFiLENBQWtCLFVBQVUwVixDQUFWLEVBQWE7QUFDbEMsWUFBSUEsTUFBTSxNQUFWLEVBQWtCO0FBQ2QsbUJBQU9nTSxhQUFhLElBQXBCO0FBQ0gsU0FGRCxNQUVPLElBQUloTSxNQUFNLE9BQVYsRUFBbUI7QUFDdEIsbUJBQU92YixNQUFNQyxPQUFOLENBQWNzbkIsUUFBZCxDQUFQO0FBQ0gsU0FGTSxNQUVBLElBQUloTSxNQUFNLFFBQVYsRUFBb0I7QUFDdkIsbUJBQU9nTSxZQUFZLENBQUN2bkIsTUFBTUMsT0FBTixDQUFjc25CLFFBQWQsQ0FBYixJQUF3QyxRQUFPQSxRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQW5FO0FBQ0gsU0FGTSxNQUVBO0FBQ0gsbUJBQU9oTSxjQUFhZ00sUUFBYix5Q0FBYUEsUUFBYixFQUFQO0FBQ0g7QUFDSixLQVZNLENBQVA7QUFXSDs7QUFFRCxJQUFJRyxpQkFBaUI1UCxxQkFBcUIsVUFBVUUsTUFBVixFQUFrQkMsT0FBbEIsRUFBMkI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBSTBQLGlCQUFpQjtBQUNuQix1QkFBZSxDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssQ0FBTCxFQUFPLENBQVAsQ0FESSxFQUNPLGFBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBRHBCO0FBRW5CLHdCQUFnQixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FGRyxFQUVjLFFBQVEsQ0FBQyxDQUFELEVBQUcsR0FBSCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBRnRCO0FBR25CLHNCQUFjLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQUhLLEVBR1ksU0FBUyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FIckI7QUFJbkIsaUJBQVMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBSlUsRUFJTyxVQUFVLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQUpqQjtBQUtuQixpQkFBUyxDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssQ0FBTCxFQUFPLENBQVAsQ0FMVSxFQUtDLGtCQUFrQixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FMbkI7QUFNbkIsZ0JBQVEsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLEdBQUwsRUFBUyxDQUFULENBTlcsRUFNRSxjQUFjLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLEVBQVksQ0FBWixDQU5oQjtBQU9uQixpQkFBUyxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsRUFBUixFQUFXLENBQVgsQ0FQVSxFQU9LLGFBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBUGxCO0FBUW5CLHFCQUFhLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLEVBQVksQ0FBWixDQVJNLEVBUVUsY0FBYyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsQ0FBVCxFQUFXLENBQVgsQ0FSeEI7QUFTbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEVBQVQsRUFBWSxDQUFaLENBVE0sRUFTVSxTQUFTLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULEVBQVksQ0FBWixDQVRuQjtBQVVuQiwwQkFBa0IsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBVkMsRUFVZ0IsWUFBWSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FWNUI7QUFXbkIsbUJBQVcsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEVBQVIsRUFBVyxDQUFYLENBWFEsRUFXTyxRQUFRLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLEVBQVcsQ0FBWCxDQVhmO0FBWW5CLG9CQUFZLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxHQUFMLEVBQVMsQ0FBVCxDQVpPLEVBWU0sWUFBWSxDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sR0FBUCxFQUFXLENBQVgsQ0FabEI7QUFhbkIseUJBQWlCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULEVBQVksQ0FBWixDQWJFLEVBYWMsWUFBWSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FiMUI7QUFjbkIscUJBQWEsQ0FBQyxDQUFELEVBQUcsR0FBSCxFQUFPLENBQVAsRUFBUyxDQUFULENBZE0sRUFjTyxZQUFZLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQWRuQjtBQWVuQixxQkFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FmTSxFQWVXLGVBQWUsQ0FBQyxHQUFELEVBQUssQ0FBTCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBZjFCO0FBZ0JuQiwwQkFBa0IsQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEVBQVIsRUFBVyxDQUFYLENBaEJDLEVBZ0JjLGNBQWMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLENBQVQsRUFBVyxDQUFYLENBaEI1QjtBQWlCbkIsc0JBQWMsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEdBQVIsRUFBWSxDQUFaLENBakJLLEVBaUJXLFdBQVcsQ0FBQyxHQUFELEVBQUssQ0FBTCxFQUFPLENBQVAsRUFBUyxDQUFULENBakJ0QjtBQWtCbkIsc0JBQWMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbEJLLEVBa0JZLGdCQUFnQixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FsQjVCO0FBbUJuQix5QkFBaUIsQ0FBQyxFQUFELEVBQUksRUFBSixFQUFPLEdBQVAsRUFBVyxDQUFYLENBbkJFLEVBbUJhLGlCQUFpQixDQUFDLEVBQUQsRUFBSSxFQUFKLEVBQU8sRUFBUCxFQUFVLENBQVYsQ0FuQjlCO0FBb0JuQix5QkFBaUIsQ0FBQyxFQUFELEVBQUksRUFBSixFQUFPLEVBQVAsRUFBVSxDQUFWLENBcEJFLEVBb0JZLGlCQUFpQixDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sR0FBUCxFQUFXLENBQVgsQ0FwQjdCO0FBcUJuQixzQkFBYyxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sR0FBUCxFQUFXLENBQVgsQ0FyQkssRUFxQlUsWUFBWSxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsR0FBUixFQUFZLENBQVosQ0FyQnRCO0FBc0JuQix1QkFBZSxDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sR0FBUCxFQUFXLENBQVgsQ0F0QkksRUFzQlcsV0FBVyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F0QnRCO0FBdUJuQixtQkFBVyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F2QlEsRUF1QlMsY0FBYyxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsR0FBUixFQUFZLENBQVosQ0F2QnZCO0FBd0JuQixxQkFBYSxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsRUFBUixFQUFXLENBQVgsQ0F4Qk0sRUF3QlMsZUFBZSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F4QnhCO0FBeUJuQix1QkFBZSxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsRUFBUixFQUFXLENBQVgsQ0F6QkksRUF5QlcsV0FBVyxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sR0FBUCxFQUFXLENBQVgsQ0F6QnRCO0FBMEJuQixxQkFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0ExQk0sRUEwQlcsY0FBYyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0ExQnpCO0FBMkJuQixnQkFBUSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsQ0FBVCxFQUFXLENBQVgsQ0EzQlcsRUEyQkksYUFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsRUFBVCxFQUFZLENBQVosQ0EzQmpCO0FBNEJuQixnQkFBUSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0E1QlcsRUE0Qk0sU0FBUyxDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sQ0FBUCxFQUFTLENBQVQsQ0E1QmY7QUE2Qm5CLHVCQUFlLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULEVBQVksQ0FBWixDQTdCSSxFQTZCWSxRQUFRLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQTdCcEI7QUE4Qm5CLG9CQUFZLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQTlCTyxFQThCVSxXQUFXLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQTlCckI7QUErQm5CLHFCQUFhLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLEVBQVcsQ0FBWCxDQS9CTSxFQStCUyxVQUFVLENBQUMsRUFBRCxFQUFJLENBQUosRUFBTSxHQUFOLEVBQVUsQ0FBVixDQS9CbkI7QUFnQ25CLGlCQUFTLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQWhDVSxFQWdDTyxTQUFTLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQWhDaEI7QUFpQ25CLG9CQUFZLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQWpDTyxFQWlDVSxpQkFBaUIsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBakMzQjtBQWtDbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLENBQVQsRUFBVyxDQUFYLENBbENNLEVBa0NTLGdCQUFnQixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FsQ3pCO0FBbUNuQixxQkFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FuQ00sRUFtQ1csY0FBYyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FuQ3pCO0FBb0NuQixxQkFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FwQ00sRUFvQ1csd0JBQXdCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXBDbkM7QUFxQ25CLHFCQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXJDTSxFQXFDVyxjQUFjLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXJDekI7QUFzQ25CLHFCQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXRDTSxFQXNDVyxhQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXRDeEI7QUF1Q25CLHVCQUFlLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXZDSSxFQXVDYSxpQkFBaUIsQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEdBQVIsRUFBWSxDQUFaLENBdkM5QjtBQXdDbkIsd0JBQWdCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXhDRyxFQXdDYyxrQkFBa0IsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBeENoQztBQXlDbkIsMEJBQWtCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXpDQyxFQXlDZ0Isa0JBQWtCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXpDbEM7QUEwQ25CLHVCQUFlLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQTFDSSxFQTBDYSxRQUFRLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxDQUFQLEVBQVMsQ0FBVCxDQTFDckI7QUEyQ25CLHFCQUFhLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLEVBQVcsQ0FBWCxDQTNDTSxFQTJDUyxTQUFTLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQTNDbEI7QUE0Q25CLG1CQUFXLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLEVBQVcsQ0FBWCxDQTVDUSxFQTRDTyxVQUFVLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLEVBQVMsQ0FBVCxDQTVDakI7QUE2Q25CLDRCQUFvQixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0E3Q0QsRUE2Q2tCLGNBQWMsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLEdBQUwsRUFBUyxDQUFULENBN0NoQztBQThDbkIsd0JBQWdCLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLEVBQVksQ0FBWixDQTlDRyxFQThDYSxnQkFBZ0IsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBOUM3QjtBQStDbkIsMEJBQWtCLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLEVBQVksQ0FBWixDQS9DQyxFQStDZSxtQkFBbUIsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBL0NsQztBQWdEbkIsNkJBQXFCLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLEVBQVcsQ0FBWCxDQWhERixFQWdEaUIsbUJBQW1CLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLEVBQVksQ0FBWixDQWhEcEM7QUFpRG5CLDJCQUFtQixDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsR0FBUixFQUFZLENBQVosQ0FqREEsRUFpRGdCLGdCQUFnQixDQUFDLEVBQUQsRUFBSSxFQUFKLEVBQU8sR0FBUCxFQUFXLENBQVgsQ0FqRGhDO0FBa0RuQixxQkFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FsRE0sRUFrRFcsYUFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FsRHhCO0FBbURuQixvQkFBWSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FuRE8sRUFtRFUsZUFBZSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FuRHpCO0FBb0RuQixnQkFBUSxDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssR0FBTCxFQUFTLENBQVQsQ0FwRFcsRUFvREUsV0FBVyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FwRGI7QUFxRG5CLGlCQUFTLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULEVBQVcsQ0FBWCxDQXJEVSxFQXFESyxhQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULEVBQVksQ0FBWixDQXJEbEI7QUFzRG5CLGtCQUFVLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULEVBQVcsQ0FBWCxDQXREUyxFQXNETSxhQUFhLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxDQUFSLEVBQVUsQ0FBVixDQXREbkI7QUF1RG5CLGtCQUFVLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXZEUyxFQXVEUSxpQkFBaUIsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBdkR6QjtBQXdEbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBeERNLEVBd0RXLGlCQUFpQixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F4RDVCO0FBeURuQix5QkFBaUIsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBekRFLEVBeURlLGNBQWMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBekQ3QjtBQTBEbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBMURNLEVBMERXLFFBQVEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEVBQVQsRUFBWSxDQUFaLENBMURuQjtBQTJEbkIsZ0JBQVEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBM0RXLEVBMkRNLFFBQVEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBM0RkO0FBNERuQixzQkFBYyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0E1REssRUE0RFksVUFBVSxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sR0FBUCxFQUFXLENBQVgsQ0E1RHRCO0FBNkRuQix5QkFBaUIsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEdBQVIsRUFBWSxDQUFaLENBN0RFO0FBOERuQixlQUFPLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLEVBQVMsQ0FBVCxDQTlEWSxFQThEQyxhQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQTlEZDtBQStEbkIscUJBQWEsQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEdBQVIsRUFBWSxDQUFaLENBL0RNLEVBK0RVLGVBQWUsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEVBQVIsRUFBVyxDQUFYLENBL0R6QjtBQWdFbkIsa0JBQVUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBaEVTLEVBZ0VRLGNBQWMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEVBQVQsRUFBWSxDQUFaLENBaEV0QjtBQWlFbkIsb0JBQVksQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEVBQVIsRUFBVyxDQUFYLENBakVPLEVBaUVRLFlBQVksQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBakVwQjtBQWtFbkIsa0JBQVUsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEVBQVIsRUFBVyxDQUFYLENBbEVTLEVBa0VNLFVBQVUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbEVoQjtBQW1FbkIsbUJBQVcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbkVRLEVBbUVTLGFBQWEsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEdBQVIsRUFBWSxDQUFaLENBbkV0QjtBQW9FbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBcEVNLEVBb0VXLGFBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBcEV4QjtBQXFFbkIsZ0JBQVEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBckVXLEVBcUVNLGVBQWUsQ0FBQyxDQUFELEVBQUcsR0FBSCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBckVyQjtBQXNFbkIscUJBQWEsQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEdBQVIsRUFBWSxDQUFaLENBdEVNLEVBc0VVLE9BQU8sQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBdEVqQjtBQXVFbkIsZ0JBQVEsQ0FBQyxDQUFELEVBQUcsR0FBSCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBdkVXLEVBdUVJLFdBQVcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBdkVmO0FBd0VuQixrQkFBVSxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsRUFBUixFQUFXLENBQVgsQ0F4RVMsRUF3RU0sYUFBYSxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsR0FBUixFQUFZLENBQVosQ0F4RW5CO0FBeUVuQixrQkFBVSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F6RVMsRUF5RVEsU0FBUyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F6RWpCO0FBMEVuQixpQkFBUyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0ExRVUsRUEwRU8sY0FBYyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0ExRXJCO0FBMkVuQixrQkFBVSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsQ0FBVCxFQUFXLENBQVgsQ0EzRVMsRUEyRU0sZUFBZSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsRUFBVCxFQUFZLENBQVosQ0EzRXJCLEVBQXJCOztBQTZFQSxhQUFTQyxjQUFULENBQXdCOW5CLENBQXhCLEVBQTJCO0FBQUc7QUFDNUJBLFlBQUl1WixLQUFLckosS0FBTCxDQUFXbFEsQ0FBWCxDQUFKLENBRHlCLENBQ0w7QUFDcEIsZUFBT0EsSUFBSSxDQUFKLEdBQVEsQ0FBUixHQUFZQSxJQUFJLEdBQUosR0FBVSxHQUFWLEdBQWdCQSxDQUFuQztBQUNEOztBQUVELGFBQVMrbkIsZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEI7QUFBRztBQUM3QixlQUFPQSxJQUFJLENBQUosR0FBUSxDQUFSLEdBQVlBLElBQUksQ0FBSixHQUFRLENBQVIsR0FBWUEsQ0FBL0I7QUFDRDs7QUFFRCxhQUFTQyxhQUFULENBQXVCQyxHQUF2QixFQUE0QjtBQUFHO0FBQzdCLFlBQUlBLElBQUlBLElBQUk3bkIsTUFBSixHQUFhLENBQWpCLE1BQXdCLEdBQTVCLEVBQ0U7QUFBRSxtQkFBT3luQixlQUFlSyxXQUFXRCxHQUFYLElBQWtCLEdBQWxCLEdBQXdCLEdBQXZDLENBQVA7QUFBcUQ7QUFDekQsZUFBT0osZUFBZU0sU0FBU0YsR0FBVCxDQUFmLENBQVA7QUFDRDs7QUFFRCxhQUFTRyxlQUFULENBQXlCSCxHQUF6QixFQUE4QjtBQUFHO0FBQy9CLFlBQUlBLElBQUlBLElBQUk3bkIsTUFBSixHQUFhLENBQWpCLE1BQXdCLEdBQTVCLEVBQ0U7QUFBRSxtQkFBTzBuQixnQkFBZ0JJLFdBQVdELEdBQVgsSUFBa0IsR0FBbEMsQ0FBUDtBQUFnRDtBQUNwRCxlQUFPSCxnQkFBZ0JJLFdBQVdELEdBQVgsQ0FBaEIsQ0FBUDtBQUNEOztBQUVELGFBQVNJLGNBQVQsQ0FBd0JDLEVBQXhCLEVBQTRCQyxFQUE1QixFQUFnQ3ZHLENBQWhDLEVBQW1DO0FBQ2pDLFlBQUlBLElBQUksQ0FBUixFQUFXO0FBQUVBLGlCQUFLLENBQUw7QUFBUyxTQUF0QixNQUNLLElBQUlBLElBQUksQ0FBUixFQUFXO0FBQUVBLGlCQUFLLENBQUw7QUFBUzs7QUFFM0IsWUFBSUEsSUFBSSxDQUFKLEdBQVEsQ0FBWixFQUFlO0FBQUUsbUJBQU9zRyxLQUFLLENBQUNDLEtBQUtELEVBQU4sSUFBWXRHLENBQVosR0FBZ0IsQ0FBNUI7QUFBZ0M7QUFDakQsWUFBSUEsSUFBSSxDQUFKLEdBQVEsQ0FBWixFQUFlO0FBQUUsbUJBQU91RyxFQUFQO0FBQVk7QUFDN0IsWUFBSXZHLElBQUksQ0FBSixHQUFRLENBQVosRUFBZTtBQUFFLG1CQUFPc0csS0FBSyxDQUFDQyxLQUFLRCxFQUFOLEtBQWEsSUFBRSxDQUFGLEdBQU10RyxDQUFuQixJQUF3QixDQUFwQztBQUF3QztBQUN6RCxlQUFPc0csRUFBUDtBQUNEOztBQUVELGFBQVNFLGFBQVQsQ0FBdUJDLE9BQXZCLEVBQWdDO0FBQzlCO0FBQ0EsWUFBSVIsTUFBTVEsUUFBUTduQixPQUFSLENBQWdCLElBQWhCLEVBQXNCLEVBQXRCLEVBQTBCMGIsV0FBMUIsRUFBVjs7QUFFQTtBQUNBLFlBQUkyTCxPQUFPTCxjQUFYLEVBQTJCO0FBQUUsbUJBQU9BLGVBQWVLLEdBQWYsRUFBb0IvYyxLQUFwQixFQUFQO0FBQXFDLFNBTHBDLENBS3NDOztBQUVwRTtBQUNBLFlBQUkrYyxJQUFJLENBQUosTUFBVyxHQUFmLEVBQW9CO0FBQ2xCLGdCQUFJQSxJQUFJN25CLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixvQkFBSXNvQixLQUFLUCxTQUFTRixJQUFJN2MsTUFBSixDQUFXLENBQVgsQ0FBVCxFQUF3QixFQUF4QixDQUFULENBRG9CLENBQ21CO0FBQ3ZDLG9CQUFJLEVBQUVzZCxNQUFNLENBQU4sSUFBV0EsTUFBTSxLQUFuQixDQUFKLEVBQStCO0FBQUUsMkJBQU8sSUFBUDtBQUFjLGlCQUYzQixDQUU2QjtBQUNqRCx1QkFBTyxDQUFFLENBQUNBLEtBQUssS0FBTixLQUFnQixDQUFqQixHQUF1QixDQUFDQSxLQUFLLEtBQU4sS0FBZ0IsQ0FBeEMsRUFDRUEsS0FBSyxJQUFOLEdBQWUsQ0FBQ0EsS0FBSyxJQUFOLEtBQWUsQ0FEL0IsRUFFRUEsS0FBSyxHQUFOLEdBQWMsQ0FBQ0EsS0FBSyxHQUFOLEtBQWMsQ0FGN0IsRUFHQyxDQUhELENBQVA7QUFJRCxhQVBELE1BT08sSUFBSVQsSUFBSTduQixNQUFKLEtBQWUsQ0FBbkIsRUFBc0I7QUFDM0Isb0JBQUlzb0IsS0FBS1AsU0FBU0YsSUFBSTdjLE1BQUosQ0FBVyxDQUFYLENBQVQsRUFBd0IsRUFBeEIsQ0FBVCxDQUQyQixDQUNZO0FBQ3ZDLG9CQUFJLEVBQUVzZCxNQUFNLENBQU4sSUFBV0EsTUFBTSxRQUFuQixDQUFKLEVBQWtDO0FBQUUsMkJBQU8sSUFBUDtBQUFjLGlCQUZ2QixDQUV5QjtBQUNwRCx1QkFBTyxDQUFDLENBQUNBLEtBQUssUUFBTixLQUFtQixFQUFwQixFQUNDLENBQUNBLEtBQUssTUFBTixLQUFpQixDQURsQixFQUVDQSxLQUFLLElBRk4sRUFHQyxDQUhELENBQVA7QUFJRDs7QUFFRCxtQkFBTyxJQUFQO0FBQ0Q7O0FBRUQsWUFBSUMsS0FBS1YsSUFBSW5uQixPQUFKLENBQVksR0FBWixDQUFUO0FBQUEsWUFBMkI4bkIsS0FBS1gsSUFBSW5uQixPQUFKLENBQVksR0FBWixDQUFoQztBQUNBLFlBQUk2bkIsT0FBTyxDQUFDLENBQVIsSUFBYUMsS0FBSyxDQUFMLEtBQVdYLElBQUk3bkIsTUFBaEMsRUFBd0M7QUFDdEMsZ0JBQUl5b0IsUUFBUVosSUFBSTdjLE1BQUosQ0FBVyxDQUFYLEVBQWN1ZCxFQUFkLENBQVo7QUFDQSxnQkFBSUcsU0FBU2IsSUFBSTdjLE1BQUosQ0FBV3VkLEtBQUcsQ0FBZCxFQUFpQkMsTUFBSUQsS0FBRyxDQUFQLENBQWpCLEVBQTRCaG9CLEtBQTVCLENBQWtDLEdBQWxDLENBQWI7QUFDQSxnQkFBSW9vQixRQUFRLENBQVosQ0FIc0MsQ0FHdEI7QUFDaEIsb0JBQVFGLEtBQVI7QUFDRSxxQkFBSyxNQUFMO0FBQ0Usd0JBQUlDLE9BQU8xb0IsTUFBUCxLQUFrQixDQUF0QixFQUF5QjtBQUFFLCtCQUFPLElBQVA7QUFBYztBQUN6QzJvQiw0QkFBUVgsZ0JBQWdCVSxPQUFPeEYsR0FBUCxFQUFoQixDQUFSO0FBQ0E7QUFDRixxQkFBSyxLQUFMO0FBQ0Usd0JBQUl3RixPQUFPMW9CLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUI7QUFBRSwrQkFBTyxJQUFQO0FBQWM7QUFDekMsMkJBQU8sQ0FBQzRuQixjQUFjYyxPQUFPLENBQVAsQ0FBZCxDQUFELEVBQ0NkLGNBQWNjLE9BQU8sQ0FBUCxDQUFkLENBREQsRUFFQ2QsY0FBY2MsT0FBTyxDQUFQLENBQWQsQ0FGRCxFQUdDQyxLQUhELENBQVA7QUFJRixxQkFBSyxNQUFMO0FBQ0Usd0JBQUlELE9BQU8xb0IsTUFBUCxLQUFrQixDQUF0QixFQUF5QjtBQUFFLCtCQUFPLElBQVA7QUFBYztBQUN6QzJvQiw0QkFBUVgsZ0JBQWdCVSxPQUFPeEYsR0FBUCxFQUFoQixDQUFSO0FBQ0E7QUFDRixxQkFBSyxLQUFMO0FBQ0Usd0JBQUl3RixPQUFPMW9CLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUI7QUFBRSwrQkFBTyxJQUFQO0FBQWM7QUFDekMsd0JBQUk0aEIsSUFBSyxDQUFFa0csV0FBV1ksT0FBTyxDQUFQLENBQVgsSUFBd0IsR0FBekIsR0FBZ0MsR0FBakMsSUFBd0MsR0FBekMsR0FBZ0QsR0FBeEQsQ0FGRixDQUVnRTtBQUM5RDtBQUNBO0FBQ0Esd0JBQUl6RyxJQUFJK0YsZ0JBQWdCVSxPQUFPLENBQVAsQ0FBaEIsQ0FBUjtBQUNBLHdCQUFJL2lCLElBQUlxaUIsZ0JBQWdCVSxPQUFPLENBQVAsQ0FBaEIsQ0FBUjtBQUNBLHdCQUFJUCxLQUFLeGlCLEtBQUssR0FBTCxHQUFXQSxLQUFLc2MsSUFBSSxDQUFULENBQVgsR0FBeUJ0YyxJQUFJc2MsQ0FBSixHQUFRdGMsSUFBSXNjLENBQTlDO0FBQ0Esd0JBQUlpRyxLQUFLdmlCLElBQUksQ0FBSixHQUFRd2lCLEVBQWpCO0FBQ0EsMkJBQU8sQ0FBQ1YsZUFBZVEsZUFBZUMsRUFBZixFQUFtQkMsRUFBbkIsRUFBdUJ2RyxJQUFFLElBQUUsQ0FBM0IsSUFBZ0MsR0FBL0MsQ0FBRCxFQUNDNkYsZUFBZVEsZUFBZUMsRUFBZixFQUFtQkMsRUFBbkIsRUFBdUJ2RyxDQUF2QixJQUE0QixHQUEzQyxDQURELEVBRUM2RixlQUFlUSxlQUFlQyxFQUFmLEVBQW1CQyxFQUFuQixFQUF1QnZHLElBQUUsSUFBRSxDQUEzQixJQUFnQyxHQUEvQyxDQUZELEVBR0MrRyxLQUhELENBQVA7QUFJRjtBQUNFLDJCQUFPLElBQVA7QUE3Qko7QUErQkQ7O0FBRUQsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBSTtBQUFFN1EsZ0JBQVFzUSxhQUFSLEdBQXdCQSxhQUF4QjtBQUF3QyxLQUE5QyxDQUErQyxPQUFNN2pCLENBQU4sRUFBUyxDQUFHO0FBQzFELENBMU1vQixDQUFyQjtBQTJNQSxJQUFJcWtCLG1CQUFtQnJCLGVBQWVhLGFBQXRDOztBQUVBLElBQUloakIsUUFBUSxTQUFTQSxLQUFULENBQWUzQixDQUFmLEVBQWtCb2xCLENBQWxCLEVBQXFCQyxDQUFyQixFQUF3QmxlLENBQXhCLEVBQTJCO0FBQ25DLFFBQUlBLE1BQU0sS0FBSyxDQUFmLEVBQ0lBLElBQUksQ0FBSjtBQUNKLFNBQUtuSCxDQUFMLEdBQVNBLENBQVQ7QUFDQSxTQUFLb2xCLENBQUwsR0FBU0EsQ0FBVDtBQUNBLFNBQUtDLENBQUwsR0FBU0EsQ0FBVDtBQUNBLFNBQUtsZSxDQUFMLEdBQVNBLENBQVQ7QUFDSCxDQVBEO0FBUUF4RixNQUFNNUMsS0FBTixHQUFjLFNBQVNBLEtBQVQsQ0FBZW1ZLEtBQWYsRUFBc0I7QUFDaEMsUUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDUixlQUFPaFgsU0FBUDtBQUNIO0FBQ0QsUUFBSWdYLGlCQUFpQnZWLEtBQXJCLEVBQTRCO0FBQ3hCLGVBQU91VixLQUFQO0FBQ0g7QUFDRCxRQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0IsZUFBT2hYLFNBQVA7QUFDSDtBQUNELFFBQUlrUCxPQUFPK1YsaUJBQWlCak8sS0FBakIsQ0FBWDtBQUNBLFFBQUksQ0FBQzlILElBQUwsRUFBVztBQUNQLGVBQU9sUCxTQUFQO0FBQ0g7QUFDRCxXQUFPLElBQUl5QixLQUFKLENBQVV5TixLQUFLLENBQUwsSUFBVSxHQUFWLEdBQWdCQSxLQUFLLENBQUwsQ0FBMUIsRUFBbUNBLEtBQUssQ0FBTCxJQUFVLEdBQVYsR0FBZ0JBLEtBQUssQ0FBTCxDQUFuRCxFQUE0REEsS0FBSyxDQUFMLElBQVUsR0FBVixHQUFnQkEsS0FBSyxDQUFMLENBQTVFLEVBQXFGQSxLQUFLLENBQUwsQ0FBckYsQ0FBUDtBQUNILENBZkQ7QUFnQkF6TixNQUFNd1gsU0FBTixDQUFnQnZYLFFBQWhCLEdBQTJCLFNBQVNBLFFBQVQsR0FBb0I7QUFDM0MsUUFBSVEsTUFBTSxLQUFLa2pCLE9BQUwsRUFBVjtBQUNBLFFBQUl0bEIsSUFBSW9DLElBQUksQ0FBSixDQUFSO0FBQ0EsUUFBSWdqQixJQUFJaGpCLElBQUksQ0FBSixDQUFSO0FBQ0EsUUFBSWlqQixJQUFJampCLElBQUksQ0FBSixDQUFSO0FBQ0EsUUFBSStFLElBQUkvRSxJQUFJLENBQUosQ0FBUjtBQUNBLFdBQU8sVUFBVXFULEtBQUtySixLQUFMLENBQVdwTSxDQUFYLENBQVYsR0FBMEIsR0FBMUIsR0FBZ0N5VixLQUFLckosS0FBTCxDQUFXZ1osQ0FBWCxDQUFoQyxHQUFnRCxHQUFoRCxHQUFzRDNQLEtBQUtySixLQUFMLENBQVdpWixDQUFYLENBQXRELEdBQXNFLEdBQXRFLEdBQTRFbGUsQ0FBNUUsR0FBZ0YsR0FBdkY7QUFDSCxDQVBEO0FBUUF4RixNQUFNd1gsU0FBTixDQUFnQm1NLE9BQWhCLEdBQTBCLFNBQVNBLE9BQVQsR0FBbUI7QUFDekMsUUFBSWxqQixNQUFNLElBQVY7QUFDQSxRQUFJcEMsSUFBSW9DLElBQUlwQyxDQUFaO0FBQ0EsUUFBSW9sQixJQUFJaGpCLElBQUlnakIsQ0FBWjtBQUNBLFFBQUlDLElBQUlqakIsSUFBSWlqQixDQUFaO0FBQ0EsUUFBSWxlLElBQUkvRSxJQUFJK0UsQ0FBWjtBQUNBLFdBQU9BLE1BQU0sQ0FBTixHQUFVLENBQ2IsQ0FEYSxFQUViLENBRmEsRUFHYixDQUhhLEVBSWIsQ0FKYSxDQUFWLEdBS0gsQ0FDQW5ILElBQUksR0FBSixHQUFVbUgsQ0FEVixFQUVBaWUsSUFBSSxHQUFKLEdBQVVqZSxDQUZWLEVBR0FrZSxJQUFJLEdBQUosR0FBVWxlLENBSFYsRUFJQUEsQ0FKQSxDQUxKO0FBV0gsQ0FqQkQ7QUFrQkF4RixNQUFNNGpCLEtBQU4sR0FBYyxJQUFJNWpCLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFkO0FBQ0FBLE1BQU02akIsS0FBTixHQUFjLElBQUk3akIsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQWQ7QUFDQUEsTUFBTThqQixXQUFOLEdBQW9CLElBQUk5akIsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQXBCO0FBQ0FBLE1BQU0rakIsR0FBTixHQUFZLElBQUkvakIsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQVo7O0FBRUEsSUFBSWdrQixXQUFXLFNBQVNBLFFBQVQsQ0FBa0JDLGFBQWxCLEVBQWlDQyxrQkFBakMsRUFBcURDLE1BQXJELEVBQTZEO0FBQ3hFLFFBQUlGLGFBQUosRUFBbUI7QUFDZixhQUFLRyxXQUFMLEdBQW1CRixxQkFBcUIsU0FBckIsR0FBaUMsTUFBcEQ7QUFDSCxLQUZELE1BRU87QUFDSCxhQUFLRSxXQUFMLEdBQW1CRixxQkFBcUIsUUFBckIsR0FBZ0MsTUFBbkQ7QUFDSDtBQUNELFNBQUtDLE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUs1VyxRQUFMLEdBQWdCLElBQUk4VyxLQUFLTCxRQUFULENBQWtCLEtBQUtHLE1BQUwsR0FBYyxLQUFLQSxNQUFuQixHQUE0QixFQUE5QyxFQUFrRDtBQUM5REMscUJBQWEsS0FBS0EsV0FENEM7QUFFOURFLGVBQU87QUFGdUQsS0FBbEQsQ0FBaEI7QUFJSCxDQVhEO0FBWUFOLFNBQVN4TSxTQUFULENBQW1CK00sT0FBbkIsR0FBNkIsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0JDLEdBQXRCLEVBQTJCO0FBQ3BELFdBQU8sS0FBS2xYLFFBQUwsQ0FBY2dYLE9BQWQsQ0FBc0JDLEdBQXRCLEVBQTJCQyxHQUEzQixDQUFQO0FBQ0gsQ0FGRDtBQUdBVCxTQUFTeE0sU0FBVCxDQUFtQmtOLGNBQW5CLEdBQW9DLFNBQVNBLGNBQVQsR0FBMEI7QUFDMUQsV0FBTyxJQUFJTCxLQUFLTCxRQUFULENBQWtCLEtBQUtHLE1BQUwsR0FBYyxLQUFLQSxNQUFuQixHQUE0QixFQUE5QyxFQUFrRFEsZUFBbEQsR0FBb0VSLE1BQTNFO0FBQ0gsQ0FGRDs7QUFJQSxJQUFJUyxtQkFBbUIsU0FBU0EsZ0JBQVQsQ0FBMEJDLElBQTFCLEVBQWdDMWIsS0FBaEMsRUFBdUMyYixLQUF2QyxFQUE4Q0MsU0FBOUMsRUFBeURDLFNBQXpELEVBQW9FO0FBQ3ZGLFNBQUtILElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUsxYixLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLMmIsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNILENBTkQ7QUFPQSxJQUFJQyxZQUFZLFNBQVNBLFNBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCO0FBQ3pDLFNBQUtBLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0gsQ0FGRDtBQUdBRCxVQUFVRSxVQUFWLEdBQXVCLFNBQVNBLFVBQVQsQ0FBb0JDLFdBQXBCLEVBQWlDO0FBQ3BELFdBQU8sSUFBSUgsU0FBSixDQUFjLENBQUMsSUFBSUwsZ0JBQUosQ0FBcUJRLFdBQXJCLEVBQWtDLElBQWxDLEVBQXdDLElBQXhDLEVBQThDLElBQTlDLEVBQW9ELElBQXBELENBQUQsQ0FBZCxDQUFQO0FBQ0gsQ0FGRDtBQUdBSCxVQUFVek4sU0FBVixDQUFvQjZOLE9BQXBCLEdBQThCLFNBQVNBLE9BQVQsR0FBbUI7QUFDN0MsUUFBSSxLQUFLSCxRQUFMLENBQWN0cUIsTUFBZCxLQUF5QixDQUE3QixFQUFnQztBQUM1QixlQUFPLElBQVA7QUFDSDtBQUNELFdBQU8sQ0FBQyxLQUFLc3FCLFFBQUwsQ0FBYzVrQixJQUFkLENBQW1CLFVBQVVnbEIsT0FBVixFQUFtQjtBQUMxQyxlQUFPQSxRQUFRVCxJQUFSLENBQWFqcUIsTUFBYixLQUF3QixDQUF4QixJQUE2QjBxQixRQUFRbmMsS0FBUixJQUFpQm1jLFFBQVFuYyxLQUFSLENBQWM1QyxJQUFkLENBQW1CM0wsTUFBbkIsS0FBOEIsQ0FBbkY7QUFDSCxLQUZPLENBQVI7QUFHSCxDQVBEO0FBUUFxcUIsVUFBVU0sT0FBVixHQUFvQixTQUFTQSxPQUFULENBQWlCVixJQUFqQixFQUF1QjtBQUN2QyxRQUFJQSxnQkFBZ0JJLFNBQXBCLEVBQStCO0FBQzNCLGVBQU9KLElBQVA7QUFDSCxLQUZELE1BRU87QUFDSCxlQUFPSSxVQUFVRSxVQUFWLENBQXFCTixJQUFyQixDQUFQO0FBQ0g7QUFDSixDQU5EO0FBT0FJLFVBQVV6TixTQUFWLENBQW9CdlgsUUFBcEIsR0FBK0IsU0FBU0EsUUFBVCxHQUFvQjtBQUMvQyxRQUFJLEtBQUtpbEIsUUFBTCxDQUFjdHFCLE1BQWQsS0FBeUIsQ0FBN0IsRUFBZ0M7QUFDNUIsZUFBTyxFQUFQO0FBQ0g7QUFDRCxXQUFPLEtBQUtzcUIsUUFBTCxDQUFjanFCLEdBQWQsQ0FBa0IsVUFBVXFxQixPQUFWLEVBQW1CO0FBQ3hDLGVBQU9BLFFBQVFULElBQWY7QUFDSCxLQUZNLEVBRUpsZixJQUZJLENBRUMsRUFGRCxDQUFQO0FBR0gsQ0FQRDtBQVFBc2YsVUFBVXpOLFNBQVYsQ0FBb0JnTyxTQUFwQixHQUFnQyxTQUFTQSxTQUFULEdBQXFCO0FBQ2pELFFBQUlDLGFBQWEsQ0FBQyxRQUFELENBQWpCO0FBQ0EsU0FBSyxJQUFJbHJCLElBQUksQ0FBUixFQUFXbWtCLE9BQU8sS0FBS3dHLFFBQTVCLEVBQXNDM3FCLElBQUlta0IsS0FBSzlqQixNQUEvQyxFQUF1REwsS0FBSyxDQUE1RCxFQUErRDtBQUMzRCxZQUFJK3FCLFVBQVU1RyxLQUFLbmtCLENBQUwsQ0FBZDtBQUNBLFlBQUkrcUIsUUFBUW5jLEtBQVosRUFBbUI7QUFDZnNjLHVCQUFXbHFCLElBQVgsQ0FBZ0IsQ0FDWixPQURZLEVBRVorcEIsUUFBUW5jLEtBQVIsQ0FBYzVDLElBRkYsQ0FBaEI7QUFJQTtBQUNIO0FBQ0RrZixtQkFBV2xxQixJQUFYLENBQWdCK3BCLFFBQVFULElBQXhCO0FBQ0EsWUFBSXBVLFVBQVUsRUFBZDtBQUNBLFlBQUk2VSxRQUFRUCxTQUFaLEVBQXVCO0FBQ25CdFUsb0JBQVEsV0FBUixJQUF1QixDQUNuQixTQURtQixFQUVuQjZVLFFBQVFQLFNBQVIsQ0FBa0I1cEIsS0FBbEIsQ0FBd0IsR0FBeEIsQ0FGbUIsQ0FBdkI7QUFJSDtBQUNELFlBQUltcUIsUUFBUVIsS0FBWixFQUFtQjtBQUNmclUsb0JBQVEsWUFBUixJQUF3QjZVLFFBQVFSLEtBQWhDO0FBQ0g7QUFDRCxZQUFJUSxRQUFRTixTQUFaLEVBQXVCO0FBQ25CdlUsb0JBQVEsWUFBUixJQUF3QixDQUFDLE1BQUQsRUFBUzNCLE1BQVQsQ0FBZ0J3VyxRQUFRTixTQUFSLENBQWtCckIsT0FBbEIsRUFBaEIsQ0FBeEI7QUFDSDtBQUNEOEIsbUJBQVdscUIsSUFBWCxDQUFnQmtWLE9BQWhCO0FBQ0g7QUFDRCxXQUFPZ1YsVUFBUDtBQUNILENBNUJEOztBQThCQSxJQUFJQyxnQkFBZ0IsU0FBU0EsYUFBVCxDQUF1QmpWLE9BQXZCLEVBQWdDO0FBQ2hELFNBQUtsSyxJQUFMLEdBQVlrSyxRQUFRbEssSUFBcEI7QUFDQSxTQUFLb2YsU0FBTCxHQUFpQmxWLFFBQVFrVixTQUF6QjtBQUNILENBSEQ7QUFJQUQsY0FBY2xPLFNBQWQsQ0FBd0J2WCxRQUF4QixHQUFtQyxTQUFTQSxRQUFULEdBQW9CO0FBQ25ELFdBQU8sS0FBS3NHLElBQVo7QUFDSCxDQUZEO0FBR0FtZixjQUFjUCxVQUFkLEdBQTJCLFNBQVNBLFVBQVQsQ0FBb0I1ZSxJQUFwQixFQUEwQjtBQUNqRCxRQUFJLENBQUNBLElBQUwsRUFBVztBQUNQLGVBQU8sSUFBUDtBQUNIO0FBQ0QsV0FBTyxJQUFJbWYsYUFBSixDQUFrQjtBQUNyQm5mLGNBQU1BLElBRGU7QUFFckJvZixtQkFBVztBQUZVLEtBQWxCLENBQVA7QUFJSCxDQVJEO0FBU0FELGNBQWNsTyxTQUFkLENBQXdCZ08sU0FBeEIsR0FBb0MsU0FBU0EsU0FBVCxHQUFxQjtBQUNyRCxXQUFPLENBQ0gsT0FERyxFQUVILEtBQUtqZixJQUZGLENBQVA7QUFJSCxDQUxEOztBQU9BLFNBQVNxZixZQUFULENBQXNCdm5CLENBQXRCLEVBQXlCb2xCLENBQXpCLEVBQTRCQyxDQUE1QixFQUErQmxlLENBQS9CLEVBQWtDO0FBQzlCLFFBQUksRUFBRSxPQUFPbkgsQ0FBUCxLQUFhLFFBQWIsSUFBeUJBLEtBQUssQ0FBOUIsSUFBbUNBLEtBQUssR0FBeEMsSUFBK0MsT0FBT29sQixDQUFQLEtBQWEsUUFBNUQsSUFBd0VBLEtBQUssQ0FBN0UsSUFBa0ZBLEtBQUssR0FBdkYsSUFBOEYsT0FBT0MsQ0FBUCxLQUFhLFFBQTNHLElBQXVIQSxLQUFLLENBQTVILElBQWlJQSxLQUFLLEdBQXhJLENBQUosRUFBa0o7QUFDOUksWUFBSWpkLFFBQVEsT0FBT2pCLENBQVAsS0FBYSxRQUFiLEdBQXdCLENBQ2hDbkgsQ0FEZ0MsRUFFaENvbEIsQ0FGZ0MsRUFHaENDLENBSGdDLEVBSWhDbGUsQ0FKZ0MsQ0FBeEIsR0FLUixDQUNBbkgsQ0FEQSxFQUVBb2xCLENBRkEsRUFHQUMsQ0FIQSxDQUxKO0FBVUEsZUFBTyx5QkFBeUJqZCxNQUFNZCxJQUFOLENBQVcsSUFBWCxDQUF6QixHQUE0Qyx1REFBbkQ7QUFDSDtBQUNELFFBQUksRUFBRSxPQUFPSCxDQUFQLEtBQWEsV0FBYixJQUE0QixPQUFPQSxDQUFQLEtBQWEsUUFBYixJQUF5QkEsS0FBSyxDQUE5QixJQUFtQ0EsS0FBSyxDQUF0RSxDQUFKLEVBQThFO0FBQzFFLGVBQU8seUJBQXlCLENBQzVCbkgsQ0FENEIsRUFFNUJvbEIsQ0FGNEIsRUFHNUJDLENBSDRCLEVBSTVCbGUsQ0FKNEIsRUFLOUJHLElBTDhCLENBS3pCLElBTHlCLENBQXpCLEdBS1EsbUNBTGY7QUFNSDtBQUNELFdBQU8sSUFBUDtBQUNIO0FBQ0QsU0FBU2tnQixPQUFULENBQWlCQyxLQUFqQixFQUF3QjtBQUNwQixRQUFJQSxVQUFVLElBQWQsRUFBb0I7QUFDaEIsZUFBTyxJQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUksT0FBT0EsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUNsQyxlQUFPLElBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFNBQXJCLEVBQWdDO0FBQ25DLGVBQU8sSUFBUDtBQUNILEtBRk0sTUFFQSxJQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDbEMsZUFBTyxJQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUlBLGlCQUFpQjlsQixLQUFyQixFQUE0QjtBQUMvQixlQUFPLElBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSThsQixpQkFBaUI5QixRQUFyQixFQUErQjtBQUNsQyxlQUFPLElBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSThCLGlCQUFpQmIsU0FBckIsRUFBZ0M7QUFDbkMsZUFBTyxJQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUlhLGlCQUFpQkosYUFBckIsRUFBb0M7QUFDdkMsZUFBTyxJQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUlqckIsTUFBTUMsT0FBTixDQUFjb3JCLEtBQWQsQ0FBSixFQUEwQjtBQUM3QixhQUFLLElBQUl2ckIsSUFBSSxDQUFSLEVBQVdta0IsT0FBT29ILEtBQXZCLEVBQThCdnJCLElBQUlta0IsS0FBSzlqQixNQUF2QyxFQUErQ0wsS0FBSyxDQUFwRCxFQUF1RDtBQUNuRCxnQkFBSXdyQixPQUFPckgsS0FBS25rQixDQUFMLENBQVg7QUFDQSxnQkFBSSxDQUFDc3JCLFFBQVFFLElBQVIsQ0FBTCxFQUFvQjtBQUNoQix1QkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNILEtBUk0sTUFRQSxJQUFJLFFBQU9ELEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFBckIsRUFBK0I7QUFDbEMsYUFBSyxJQUFJbGlCLEdBQVQsSUFBZ0JraUIsS0FBaEIsRUFBdUI7QUFDbkIsZ0JBQUksQ0FBQ0QsUUFBUUMsTUFBTWxpQixHQUFOLENBQVIsQ0FBTCxFQUEwQjtBQUN0Qix1QkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNILEtBUE0sTUFPQTtBQUNILGVBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxTQUFTb2lCLE1BQVQsQ0FBZ0J2ZixLQUFoQixFQUF1QjtBQUNuQixRQUFJQSxVQUFVLElBQWQsRUFBb0I7QUFDaEIsZUFBT29hLFFBQVA7QUFDSCxLQUZELE1BRU8sSUFBSSxPQUFPcGEsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUNsQyxlQUFPdWEsVUFBUDtBQUNILEtBRk0sTUFFQSxJQUFJLE9BQU92YSxLQUFQLEtBQWlCLFNBQXJCLEVBQWdDO0FBQ25DLGVBQU93YSxXQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUksT0FBT3hhLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDbEMsZUFBT3NhLFVBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSXRhLGlCQUFpQnpHLEtBQXJCLEVBQTRCO0FBQy9CLGVBQU9raEIsU0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJemEsaUJBQWlCdWQsUUFBckIsRUFBK0I7QUFDbEMsZUFBTzFDLFlBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSTdhLGlCQUFpQndlLFNBQXJCLEVBQWdDO0FBQ25DLGVBQU8xRCxhQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUk5YSxpQkFBaUJpZixhQUFyQixFQUFvQztBQUN2QyxlQUFPbEUsaUJBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSS9tQixNQUFNQyxPQUFOLENBQWMrTCxLQUFkLENBQUosRUFBMEI7QUFDN0IsWUFBSTdMLFNBQVM2TCxNQUFNN0wsTUFBbkI7QUFDQSxZQUFJNm1CLFFBQUo7QUFDQSxhQUFLLElBQUlsbkIsSUFBSSxDQUFSLEVBQVdta0IsT0FBT2pZLEtBQXZCLEVBQThCbE0sSUFBSW1rQixLQUFLOWpCLE1BQXZDLEVBQStDTCxLQUFLLENBQXBELEVBQXVEO0FBQ25ELGdCQUFJd3JCLE9BQU9ySCxLQUFLbmtCLENBQUwsQ0FBWDtBQUNBLGdCQUFJeWIsSUFBSWdRLE9BQU9ELElBQVAsQ0FBUjtBQUNBLGdCQUFJLENBQUN0RSxRQUFMLEVBQWU7QUFDWEEsMkJBQVd6TCxDQUFYO0FBQ0gsYUFGRCxNQUVPLElBQUl5TCxhQUFhekwsQ0FBakIsRUFBb0I7QUFDdkI7QUFDSCxhQUZNLE1BRUE7QUFDSHlMLDJCQUFXTCxTQUFYO0FBQ0E7QUFDSDtBQUNKO0FBQ0QsZUFBT3hVLE1BQU02VSxZQUFZTCxTQUFsQixFQUE2QnhtQixNQUE3QixDQUFQO0FBQ0gsS0FoQk0sTUFnQkE7QUFDSCxlQUFPdW1CLFVBQVA7QUFDSDtBQUNKO0FBQ0QsU0FBUzhFLFVBQVQsQ0FBb0J4ZixLQUFwQixFQUEyQjtBQUN2QixRQUFJbEgsY0FBY2tILEtBQWQseUNBQWNBLEtBQWQsQ0FBSjtBQUNBLFFBQUlBLFVBQVUsSUFBZCxFQUFvQjtBQUNoQixlQUFPLEVBQVA7QUFDSCxLQUZELE1BRU8sSUFBSWxILFNBQVMsUUFBVCxJQUFxQkEsU0FBUyxRQUE5QixJQUEwQ0EsU0FBUyxTQUF2RCxFQUFrRTtBQUNyRSxlQUFPeVUsT0FBT3ZOLEtBQVAsQ0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJQSxpQkFBaUJ6RyxLQUFqQixJQUEwQnlHLGlCQUFpQndlLFNBQTNDLElBQXdEeGUsaUJBQWlCaWYsYUFBN0UsRUFBNEY7QUFDL0YsZUFBT2pmLE1BQU14RyxRQUFOLEVBQVA7QUFDSCxLQUZNLE1BRUE7QUFDSCxlQUFPOUMsS0FBS29ULFNBQUwsQ0FBZTlKLEtBQWYsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQsSUFBSXlmLFVBQVUsU0FBU0EsT0FBVCxDQUFpQjNtQixJQUFqQixFQUF1QmtILEtBQXZCLEVBQThCO0FBQ3hDLFNBQUtsSCxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLa0gsS0FBTCxHQUFhQSxLQUFiO0FBQ0gsQ0FIRDtBQUlBeWYsUUFBUTlvQixLQUFSLEdBQWdCLFNBQVNBLEtBQVQsQ0FBZStvQixJQUFmLEVBQXFCQyxPQUFyQixFQUE4QjtBQUMxQyxRQUFJRCxLQUFLdnJCLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYyxzRUFBc0V1bkIsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBcEYsSUFBeUYsV0FBdkcsQ0FBUDtBQUNIO0FBQ0QsUUFBSSxDQUFDaXJCLFFBQVFNLEtBQUssQ0FBTCxDQUFSLENBQUwsRUFBdUI7QUFDbkIsZUFBT0MsUUFBUXhuQixLQUFSLENBQWMsZUFBZCxDQUFQO0FBQ0g7QUFDRCxRQUFJNkgsUUFBUTBmLEtBQUssQ0FBTCxDQUFaO0FBQ0EsUUFBSTVtQixPQUFPeW1CLE9BQU92ZixLQUFQLENBQVg7QUFDQSxRQUFJb2IsV0FBV3VFLFFBQVFDLFlBQXZCO0FBQ0EsUUFBSTltQixLQUFLdWhCLElBQUwsS0FBYyxPQUFkLElBQXlCdmhCLEtBQUttaUIsQ0FBTCxLQUFXLENBQXBDLElBQXlDRyxRQUF6QyxJQUFxREEsU0FBU2YsSUFBVCxLQUFrQixPQUF2RSxLQUFtRixPQUFPZSxTQUFTSCxDQUFoQixLQUFzQixRQUF0QixJQUFrQ0csU0FBU0gsQ0FBVCxLQUFlLENBQXBJLENBQUosRUFBNEk7QUFDeEluaUIsZUFBT3NpQixRQUFQO0FBQ0g7QUFDRCxXQUFPLElBQUlxRSxPQUFKLENBQVkzbUIsSUFBWixFQUFrQmtILEtBQWxCLENBQVA7QUFDSCxDQWREO0FBZUF5ZixRQUFRMU8sU0FBUixDQUFrQjhPLFFBQWxCLEdBQTZCLFNBQVNBLFFBQVQsR0FBb0I7QUFDN0MsV0FBTyxLQUFLN2YsS0FBWjtBQUNILENBRkQ7QUFHQXlmLFFBQVExTyxTQUFSLENBQWtCK08sU0FBbEIsR0FBOEIsU0FBU0EsU0FBVCxHQUFxQixDQUNsRCxDQUREO0FBRUFMLFFBQVExTyxTQUFSLENBQWtCZ1AsYUFBbEIsR0FBa0MsU0FBU0EsYUFBVCxHQUF5QjtBQUN2RCxXQUFPLElBQVA7QUFDSCxDQUZEO0FBR0FOLFFBQVExTyxTQUFSLENBQWtCZ08sU0FBbEIsR0FBOEIsU0FBU0EsU0FBVCxHQUFxQjtBQUMvQyxRQUFJLEtBQUtqbUIsSUFBTCxDQUFVdWhCLElBQVYsS0FBbUIsT0FBbkIsSUFBOEIsS0FBS3ZoQixJQUFMLENBQVV1aEIsSUFBVixLQUFtQixRQUFyRCxFQUErRDtBQUMzRCxlQUFPLENBQ0gsU0FERyxFQUVILEtBQUtyYSxLQUZGLENBQVA7QUFJSCxLQUxELE1BS08sSUFBSSxLQUFLQSxLQUFMLFlBQXNCekcsS0FBMUIsRUFBaUM7QUFDcEMsZUFBTyxDQUFDLE1BQUQsRUFBUzhPLE1BQVQsQ0FBZ0IsS0FBS3JJLEtBQUwsQ0FBV2tkLE9BQVgsRUFBaEIsQ0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJLEtBQUtsZCxLQUFMLFlBQXNCd2UsU0FBMUIsRUFBcUM7QUFDeEMsZUFBTyxLQUFLeGUsS0FBTCxDQUFXK2UsU0FBWCxFQUFQO0FBQ0gsS0FGTSxNQUVBO0FBQ0gsZUFBTyxLQUFLL2UsS0FBWjtBQUNIO0FBQ0osQ0FiRDs7QUFlQSxJQUFJZ2dCLGVBQWUsU0FBU0EsWUFBVCxDQUFzQm5HLE9BQXRCLEVBQStCO0FBQzlDLFNBQUsvWixJQUFMLEdBQVksMkJBQVo7QUFDQSxTQUFLK1osT0FBTCxHQUFlQSxPQUFmO0FBQ0gsQ0FIRDtBQUlBbUcsYUFBYWpQLFNBQWIsQ0FBdUI5RixNQUF2QixHQUFnQyxTQUFTQSxNQUFULEdBQWtCO0FBQzlDLFdBQU8sS0FBSzRPLE9BQVo7QUFDSCxDQUZEOztBQUlBLElBQUlvRyxRQUFRO0FBQ1J2WixZQUFRNlQsVUFEQTtBQUVSNVQsWUFBUTJULFVBRkE7QUFHUjFULGFBQVM0VCxXQUhEO0FBSVIzVCxZQUFRNlQ7QUFKQSxDQUFaO0FBTUEsSUFBSXdGLFlBQVksU0FBU0EsU0FBVCxDQUFtQnBuQixJQUFuQixFQUF5QjRtQixJQUF6QixFQUErQjtBQUMzQyxTQUFLNW1CLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUs0bUIsSUFBTCxHQUFZQSxJQUFaO0FBQ0gsQ0FIRDtBQUlBUSxVQUFVdnBCLEtBQVYsR0FBa0IsU0FBU0EsS0FBVCxDQUFlK29CLElBQWYsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzVDLFFBQUlELEtBQUt2ckIsTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ2pCLGVBQU93ckIsUUFBUXhuQixLQUFSLENBQWMsaUNBQWQsQ0FBUDtBQUNIO0FBQ0QsUUFBSXJFLElBQUksQ0FBUjtBQUNBLFFBQUlnRixJQUFKO0FBQ0EsUUFBSWdILE9BQU80ZixLQUFLLENBQUwsQ0FBWDtBQUNBLFFBQUk1ZixTQUFTLE9BQWIsRUFBc0I7QUFDbEIsWUFBSWtiLFFBQUo7QUFDQSxZQUFJMEUsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbEIsRUFBcUI7QUFDakIsZ0JBQUlnc0IsU0FBU1QsS0FBSyxDQUFMLENBQWI7QUFDQSxnQkFBSSxPQUFPUyxNQUFQLEtBQWtCLFFBQWxCLElBQThCLEVBQUVBLFVBQVVGLEtBQVosQ0FBOUIsSUFBb0RFLFdBQVcsUUFBbkUsRUFBNkU7QUFDekUsdUJBQU9SLFFBQVF4bkIsS0FBUixDQUFjLDBFQUFkLEVBQTBGLENBQTFGLENBQVA7QUFDSDtBQUNENmlCLHVCQUFXaUYsTUFBTUUsTUFBTixDQUFYO0FBQ0Fyc0I7QUFDSCxTQVBELE1BT087QUFDSGtuQix1QkFBV0wsU0FBWDtBQUNIO0FBQ0QsWUFBSU0sQ0FBSjtBQUNBLFlBQUl5RSxLQUFLdnJCLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNqQixnQkFBSXVyQixLQUFLLENBQUwsTUFBWSxJQUFaLEtBQXFCLE9BQU9BLEtBQUssQ0FBTCxDQUFQLEtBQW1CLFFBQW5CLElBQStCQSxLQUFLLENBQUwsSUFBVSxDQUF6QyxJQUE4Q0EsS0FBSyxDQUFMLE1BQVlyUyxLQUFLcEYsS0FBTCxDQUFXeVgsS0FBSyxDQUFMLENBQVgsQ0FBL0UsQ0FBSixFQUF5RztBQUNyRyx1QkFBT0MsUUFBUXhuQixLQUFSLENBQWMsbUVBQWQsRUFBbUYsQ0FBbkYsQ0FBUDtBQUNIO0FBQ0Q4aUIsZ0JBQUl5RSxLQUFLLENBQUwsQ0FBSjtBQUNBNXJCO0FBQ0g7QUFDRGdGLGVBQU9xTixNQUFNNlUsUUFBTixFQUFnQkMsQ0FBaEIsQ0FBUDtBQUNILEtBckJELE1BcUJPO0FBQ0huaUIsZUFBT21uQixNQUFNbmdCLElBQU4sQ0FBUDtBQUNIO0FBQ0QsUUFBSXNnQixTQUFTLEVBQWI7QUFDQSxXQUFPdHNCLElBQUk0ckIsS0FBS3ZyQixNQUFoQixFQUF3QkwsR0FBeEIsRUFBNkI7QUFDekIsWUFBSWdiLFFBQVE2USxRQUFRaHBCLEtBQVIsQ0FBYytvQixLQUFLNXJCLENBQUwsQ0FBZCxFQUF1QkEsQ0FBdkIsRUFBMEI2bUIsU0FBMUIsQ0FBWjtBQUNBLFlBQUksQ0FBQzdMLEtBQUwsRUFBWTtBQUNSLG1CQUFPLElBQVA7QUFDSDtBQUNEc1IsZUFBT3RyQixJQUFQLENBQVlnYSxLQUFaO0FBQ0g7QUFDRCxXQUFPLElBQUlvUixTQUFKLENBQWNwbkIsSUFBZCxFQUFvQnNuQixNQUFwQixDQUFQO0FBQ0gsQ0F4Q0Q7QUF5Q0FGLFVBQVVuUCxTQUFWLENBQW9COE8sUUFBcEIsR0FBK0IsU0FBU0EsUUFBVCxDQUFrQlEsR0FBbEIsRUFBdUI7QUFDbEQsU0FBSyxJQUFJdnNCLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLNHJCLElBQUwsQ0FBVXZyQixNQUE5QixFQUFzQ0wsR0FBdEMsRUFBMkM7QUFDdkMsWUFBSWtNLFFBQVEsS0FBSzBmLElBQUwsQ0FBVTVyQixDQUFWLEVBQWErckIsUUFBYixDQUFzQlEsR0FBdEIsQ0FBWjtBQUNBLFlBQUlsb0IsUUFBUWdqQixhQUFhLEtBQUtyaUIsSUFBbEIsRUFBd0J5bUIsT0FBT3ZmLEtBQVAsQ0FBeEIsQ0FBWjtBQUNBLFlBQUksQ0FBQzdILEtBQUwsRUFBWTtBQUNSLG1CQUFPNkgsS0FBUDtBQUNILFNBRkQsTUFFTyxJQUFJbE0sTUFBTSxLQUFLNHJCLElBQUwsQ0FBVXZyQixNQUFWLEdBQW1CLENBQTdCLEVBQWdDO0FBQ25DLGtCQUFNLElBQUk2ckIsWUFBSixDQUFpQixrQ0FBa0N4bUIsU0FBUyxLQUFLVixJQUFkLENBQWxDLEdBQXdELGNBQXhELEdBQXlFVSxTQUFTK2xCLE9BQU92ZixLQUFQLENBQVQsQ0FBekUsR0FBbUcsV0FBcEgsQ0FBTjtBQUNIO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSCxDQVhEO0FBWUFrZ0IsVUFBVW5QLFNBQVYsQ0FBb0IrTyxTQUFwQixHQUFnQyxTQUFTQSxTQUFULENBQW1CL1QsRUFBbkIsRUFBdUI7QUFDbkQsU0FBSzJULElBQUwsQ0FBVXJILE9BQVYsQ0FBa0J0TSxFQUFsQjtBQUNILENBRkQ7QUFHQW1VLFVBQVVuUCxTQUFWLENBQW9CZ1AsYUFBcEIsR0FBb0MsU0FBU0EsYUFBVCxHQUF5QjtBQUN6RCxXQUFPLEtBQUtMLElBQUwsQ0FBVVksS0FBVixDQUFnQixVQUFVNVAsR0FBVixFQUFlO0FBQ2xDLGVBQU9BLElBQUlxUCxhQUFKLEVBQVA7QUFDSCxLQUZNLENBQVA7QUFHSCxDQUpEO0FBS0FHLFVBQVVuUCxTQUFWLENBQW9CZ08sU0FBcEIsR0FBZ0MsU0FBU0EsU0FBVCxHQUFxQjtBQUNqRCxRQUFJam1CLE9BQU8sS0FBS0EsSUFBaEI7QUFDQSxRQUFJa21CLGFBQWEsQ0FBQ2xtQixLQUFLdWhCLElBQU4sQ0FBakI7QUFDQSxRQUFJdmhCLEtBQUt1aEIsSUFBTCxLQUFjLE9BQWxCLEVBQTJCO0FBQ3ZCLFlBQUlXLFdBQVdsaUIsS0FBS2tpQixRQUFwQjtBQUNBLFlBQUlBLFNBQVNYLElBQVQsS0FBa0IsUUFBbEIsSUFBOEJXLFNBQVNYLElBQVQsS0FBa0IsUUFBaEQsSUFBNERXLFNBQVNYLElBQVQsS0FBa0IsU0FBbEYsRUFBNkY7QUFDekYyRSx1QkFBV2xxQixJQUFYLENBQWdCa21CLFNBQVNYLElBQXpCO0FBQ0EsZ0JBQUlZLElBQUluaUIsS0FBS21pQixDQUFiO0FBQ0EsZ0JBQUksT0FBT0EsQ0FBUCxLQUFhLFFBQWIsSUFBeUIsS0FBS3lFLElBQUwsQ0FBVXZyQixNQUFWLEdBQW1CLENBQWhELEVBQW1EO0FBQy9DNnFCLDJCQUFXbHFCLElBQVgsQ0FBZ0JtbUIsQ0FBaEI7QUFDSDtBQUNKO0FBQ0o7QUFDRCxXQUFPK0QsV0FBVzNXLE1BQVgsQ0FBa0IsS0FBS3FYLElBQUwsQ0FBVWxyQixHQUFWLENBQWMsVUFBVWtjLEdBQVYsRUFBZTtBQUNsRCxlQUFPQSxJQUFJcU8sU0FBSixFQUFQO0FBQ0gsS0FGd0IsQ0FBbEIsQ0FBUDtBQUdILENBaEJEOztBQWtCQSxJQUFJd0IsbUJBQW1CLFNBQVNBLGdCQUFULENBQTBCOUIsUUFBMUIsRUFBb0M7QUFDdkQsU0FBSzNsQixJQUFMLEdBQVlnaUIsYUFBWjtBQUNBLFNBQUsyRCxRQUFMLEdBQWdCQSxRQUFoQjtBQUNILENBSEQ7QUFJQThCLGlCQUFpQjVwQixLQUFqQixHQUF5QixTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDbkQsUUFBSUQsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbEIsRUFBcUI7QUFDakIsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYyxpQ0FBZCxDQUFQO0FBQ0g7QUFDRCxRQUFJcW9CLFdBQVdkLEtBQUssQ0FBTCxDQUFmO0FBQ0EsUUFBSSxDQUFDMXJCLE1BQU1DLE9BQU4sQ0FBY3VzQixRQUFkLENBQUQsSUFBNEIsUUFBT0EsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUFwRCxFQUE4RDtBQUMxRCxlQUFPYixRQUFReG5CLEtBQVIsQ0FBYyxrREFBZCxDQUFQO0FBQ0g7QUFDRCxRQUFJc21CLFdBQVcsRUFBZjtBQUNBLFFBQUlnQyx1QkFBdUIsS0FBM0I7QUFDQSxTQUFLLElBQUkzc0IsSUFBSSxDQUFiLEVBQWdCQSxLQUFLNHJCLEtBQUt2ckIsTUFBTCxHQUFjLENBQW5DLEVBQXNDLEVBQUVMLENBQXhDLEVBQTJDO0FBQ3ZDLFlBQUk0YyxNQUFNZ1AsS0FBSzVyQixDQUFMLENBQVY7QUFDQSxZQUFJMnNCLHdCQUF3QixRQUFPL1AsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQXZDLElBQW1ELENBQUMxYyxNQUFNQyxPQUFOLENBQWN5YyxHQUFkLENBQXhELEVBQTRFO0FBQ3hFK1AsbUNBQXVCLEtBQXZCO0FBQ0EsZ0JBQUlwQyxRQUFRLElBQVo7QUFDQSxnQkFBSTNOLElBQUksWUFBSixDQUFKLEVBQXVCO0FBQ25CMk4sd0JBQVFzQixRQUFRaHBCLEtBQVIsQ0FBYytaLElBQUksWUFBSixDQUFkLEVBQWlDLENBQWpDLEVBQW9DNEosVUFBcEMsQ0FBUjtBQUNBLG9CQUFJLENBQUMrRCxLQUFMLEVBQVk7QUFDUiwyQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELGdCQUFJNXBCLE9BQU8sSUFBWDtBQUNBLGdCQUFJaWMsSUFBSSxXQUFKLENBQUosRUFBc0I7QUFDbEJqYyx1QkFBT2tyQixRQUFRaHBCLEtBQVIsQ0FBYytaLElBQUksV0FBSixDQUFkLEVBQWdDLENBQWhDLEVBQW1DdkssTUFBTW9VLFVBQU4sQ0FBbkMsQ0FBUDtBQUNBLG9CQUFJLENBQUM5bEIsSUFBTCxFQUFXO0FBQ1AsMkJBQU8sSUFBUDtBQUNIO0FBQ0o7QUFDRCxnQkFBSThwQixZQUFZLElBQWhCO0FBQ0EsZ0JBQUk3TixJQUFJLFlBQUosQ0FBSixFQUF1QjtBQUNuQjZOLDRCQUFZb0IsUUFBUWhwQixLQUFSLENBQWMrWixJQUFJLFlBQUosQ0FBZCxFQUFpQyxDQUFqQyxFQUFvQytKLFNBQXBDLENBQVo7QUFDQSxvQkFBSSxDQUFDOEQsU0FBTCxFQUFnQjtBQUNaLDJCQUFPLElBQVA7QUFDSDtBQUNKO0FBQ0QsZ0JBQUltQyxpQkFBaUJqQyxTQUFTQSxTQUFTdHFCLE1BQVQsR0FBa0IsQ0FBM0IsQ0FBckI7QUFDQXVzQiwyQkFBZXJDLEtBQWYsR0FBdUJBLEtBQXZCO0FBQ0FxQywyQkFBZWpzQixJQUFmLEdBQXNCQSxJQUF0QjtBQUNBaXNCLDJCQUFlbkMsU0FBZixHQUEyQkEsU0FBM0I7QUFDSCxTQTNCRCxNQTJCTztBQUNILGdCQUFJb0MsVUFBVWhCLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUs1ckIsQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCNm1CLFNBQTFCLENBQWQ7QUFDQSxnQkFBSSxDQUFDZ0csT0FBTCxFQUFjO0FBQ1YsdUJBQU8sSUFBUDtBQUNIO0FBQ0QsZ0JBQUl0RyxPQUFPc0csUUFBUTduQixJQUFSLENBQWF1aEIsSUFBeEI7QUFDQSxnQkFBSUEsU0FBUyxRQUFULElBQXFCQSxTQUFTLE9BQTlCLElBQXlDQSxTQUFTLE1BQWxELElBQTREQSxTQUFTLGVBQXpFLEVBQTBGO0FBQ3RGLHVCQUFPc0YsUUFBUXhuQixLQUFSLENBQWMsMkVBQWQsQ0FBUDtBQUNIO0FBQ0Rzb0IsbUNBQXVCLElBQXZCO0FBQ0FoQyxxQkFBUzNwQixJQUFULENBQWM7QUFDVjZyQix5QkFBU0EsT0FEQztBQUVWdEMsdUJBQU8sSUFGRztBQUdWNXBCLHNCQUFNLElBSEk7QUFJVjhwQiwyQkFBVztBQUpELGFBQWQ7QUFNSDtBQUNKO0FBQ0QsV0FBTyxJQUFJZ0MsZ0JBQUosQ0FBcUI5QixRQUFyQixDQUFQO0FBQ0gsQ0ExREQ7QUEyREE4QixpQkFBaUJ4UCxTQUFqQixDQUEyQjhPLFFBQTNCLEdBQXNDLFNBQVNBLFFBQVQsQ0FBa0JRLEdBQWxCLEVBQXVCO0FBQ3pELFFBQUlPLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBVS9CLE9BQVYsRUFBbUI7QUFDckMsWUFBSWdDLG1CQUFtQmhDLFFBQVE4QixPQUFSLENBQWdCZCxRQUFoQixDQUF5QlEsR0FBekIsQ0FBdkI7QUFDQSxZQUFJZCxPQUFPc0IsZ0JBQVAsTUFBNkI5RixpQkFBakMsRUFBb0Q7QUFDaEQsbUJBQU8sSUFBSW9ELGdCQUFKLENBQXFCLEVBQXJCLEVBQXlCMEMsZ0JBQXpCLEVBQTJDLElBQTNDLEVBQWlELElBQWpELEVBQXVELElBQXZELENBQVA7QUFDSDtBQUNELGVBQU8sSUFBSTFDLGdCQUFKLENBQXFCcUIsV0FBV3FCLGdCQUFYLENBQXJCLEVBQW1ELElBQW5ELEVBQXlEaEMsUUFBUVIsS0FBUixHQUFnQlEsUUFBUVIsS0FBUixDQUFjd0IsUUFBZCxDQUF1QlEsR0FBdkIsQ0FBaEIsR0FBOEMsSUFBdkcsRUFBNkd4QixRQUFRcHFCLElBQVIsR0FBZW9xQixRQUFRcHFCLElBQVIsQ0FBYW9yQixRQUFiLENBQXNCUSxHQUF0QixFQUEyQm5oQixJQUEzQixDQUFnQyxHQUFoQyxDQUFmLEdBQXNELElBQW5LLEVBQXlLMmYsUUFBUU4sU0FBUixHQUFvQk0sUUFBUU4sU0FBUixDQUFrQnNCLFFBQWxCLENBQTJCUSxHQUEzQixDQUFwQixHQUFzRCxJQUEvTixDQUFQO0FBQ0gsS0FORDtBQU9BLFdBQU8sSUFBSTdCLFNBQUosQ0FBYyxLQUFLQyxRQUFMLENBQWNqcUIsR0FBZCxDQUFrQm9zQixlQUFsQixDQUFkLENBQVA7QUFDSCxDQVREO0FBVUFMLGlCQUFpQnhQLFNBQWpCLENBQTJCK08sU0FBM0IsR0FBdUMsU0FBU0EsU0FBVCxDQUFtQi9ULEVBQW5CLEVBQXVCO0FBQzFELFNBQUssSUFBSWpZLElBQUksQ0FBUixFQUFXbWtCLE9BQU8sS0FBS3dHLFFBQTVCLEVBQXNDM3FCLElBQUlta0IsS0FBSzlqQixNQUEvQyxFQUF1REwsS0FBSyxDQUE1RCxFQUErRDtBQUMzRCxZQUFJK3FCLFVBQVU1RyxLQUFLbmtCLENBQUwsQ0FBZDtBQUNBaVksV0FBRzhTLFFBQVE4QixPQUFYO0FBQ0EsWUFBSTlCLFFBQVFSLEtBQVosRUFBbUI7QUFDZnRTLGVBQUc4UyxRQUFRUixLQUFYO0FBQ0g7QUFDRCxZQUFJUSxRQUFRcHFCLElBQVosRUFBa0I7QUFDZHNYLGVBQUc4UyxRQUFRcHFCLElBQVg7QUFDSDtBQUNELFlBQUlvcUIsUUFBUU4sU0FBWixFQUF1QjtBQUNuQnhTLGVBQUc4UyxRQUFRTixTQUFYO0FBQ0g7QUFDSjtBQUNKLENBZEQ7QUFlQWdDLGlCQUFpQnhQLFNBQWpCLENBQTJCZ1AsYUFBM0IsR0FBMkMsU0FBU0EsYUFBVCxHQUF5QjtBQUNoRSxXQUFPLEtBQVA7QUFDSCxDQUZEO0FBR0FRLGlCQUFpQnhQLFNBQWpCLENBQTJCZ08sU0FBM0IsR0FBdUMsU0FBU0EsU0FBVCxHQUFxQjtBQUN4RCxRQUFJQyxhQUFhLENBQUMsUUFBRCxDQUFqQjtBQUNBLFNBQUssSUFBSWxyQixJQUFJLENBQVIsRUFBV21rQixPQUFPLEtBQUt3RyxRQUE1QixFQUFzQzNxQixJQUFJbWtCLEtBQUs5akIsTUFBL0MsRUFBdURMLEtBQUssQ0FBNUQsRUFBK0Q7QUFDM0QsWUFBSStxQixVQUFVNUcsS0FBS25rQixDQUFMLENBQWQ7QUFDQWtyQixtQkFBV2xxQixJQUFYLENBQWdCK3BCLFFBQVE4QixPQUFSLENBQWdCNUIsU0FBaEIsRUFBaEI7QUFDQSxZQUFJL1UsVUFBVSxFQUFkO0FBQ0EsWUFBSTZVLFFBQVFSLEtBQVosRUFBbUI7QUFDZnJVLG9CQUFRLFlBQVIsSUFBd0I2VSxRQUFRUixLQUFSLENBQWNVLFNBQWQsRUFBeEI7QUFDSDtBQUNELFlBQUlGLFFBQVFwcUIsSUFBWixFQUFrQjtBQUNkdVYsb0JBQVEsV0FBUixJQUF1QjZVLFFBQVFwcUIsSUFBUixDQUFhc3FCLFNBQWIsRUFBdkI7QUFDSDtBQUNELFlBQUlGLFFBQVFOLFNBQVosRUFBdUI7QUFDbkJ2VSxvQkFBUSxZQUFSLElBQXdCNlUsUUFBUU4sU0FBUixDQUFrQlEsU0FBbEIsRUFBeEI7QUFDSDtBQUNEQyxtQkFBV2xxQixJQUFYLENBQWdCa1YsT0FBaEI7QUFDSDtBQUNELFdBQU9nVixVQUFQO0FBQ0gsQ0FsQkQ7O0FBb0JBLElBQUk4QixrQkFBa0IsU0FBU0EsZUFBVCxDQUF5QmhTLEtBQXpCLEVBQWdDO0FBQ2xELFNBQUtoVyxJQUFMLEdBQVlpaUIsaUJBQVo7QUFDQSxTQUFLak0sS0FBTCxHQUFhQSxLQUFiO0FBQ0gsQ0FIRDtBQUlBZ1MsZ0JBQWdCbnFCLEtBQWhCLEdBQXdCLFNBQVNBLEtBQVQsQ0FBZStvQixJQUFmLEVBQXFCQyxPQUFyQixFQUE4QjtBQUNsRCxRQUFJRCxLQUFLdnJCLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYyx5QkFBZCxDQUFQO0FBQ0g7QUFDRCxRQUFJMkgsT0FBTzZmLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCbkYsVUFBMUIsQ0FBWDtBQUNBLFFBQUksQ0FBQ3phLElBQUwsRUFBVztBQUNQLGVBQU82ZixRQUFReG5CLEtBQVIsQ0FBYyx5QkFBZCxDQUFQO0FBQ0g7QUFDRCxXQUFPLElBQUkyb0IsZUFBSixDQUFvQmhoQixJQUFwQixDQUFQO0FBQ0gsQ0FURDtBQVVBZ2hCLGdCQUFnQi9QLFNBQWhCLENBQTBCOE8sUUFBMUIsR0FBcUMsU0FBU0EsUUFBVCxDQUFrQlEsR0FBbEIsRUFBdUI7QUFDeEQsUUFBSVUscUJBQXFCLEtBQUtqUyxLQUFMLENBQVcrUSxRQUFYLENBQW9CUSxHQUFwQixDQUF6QjtBQUNBLFFBQUlyZ0IsUUFBUWlmLGNBQWNQLFVBQWQsQ0FBeUJxQyxrQkFBekIsQ0FBWjtBQUNBLFFBQUkvZ0IsU0FBU3FnQixJQUFJVyxlQUFqQixFQUFrQztBQUM5QmhoQixjQUFNa2YsU0FBTixHQUFrQm1CLElBQUlXLGVBQUosQ0FBb0Juc0IsT0FBcEIsQ0FBNEJrc0Isa0JBQTVCLElBQWtELENBQUMsQ0FBckU7QUFDSDtBQUNELFdBQU8vZ0IsS0FBUDtBQUNILENBUEQ7QUFRQThnQixnQkFBZ0IvUCxTQUFoQixDQUEwQitPLFNBQTFCLEdBQXNDLFNBQVNBLFNBQVQsQ0FBbUIvVCxFQUFuQixFQUF1QjtBQUN6REEsT0FBRyxLQUFLK0MsS0FBUjtBQUNILENBRkQ7QUFHQWdTLGdCQUFnQi9QLFNBQWhCLENBQTBCZ1AsYUFBMUIsR0FBMEMsU0FBU0EsYUFBVCxHQUF5QjtBQUMvRCxXQUFPLEtBQVA7QUFDSCxDQUZEO0FBR0FlLGdCQUFnQi9QLFNBQWhCLENBQTBCZ08sU0FBMUIsR0FBc0MsU0FBU0EsU0FBVCxHQUFxQjtBQUN2RCxXQUFPLENBQ0gsT0FERyxFQUVILEtBQUtqUSxLQUFMLENBQVdpUSxTQUFYLEVBRkcsQ0FBUDtBQUlILENBTEQ7O0FBT0EsSUFBSWtDLFVBQVU7QUFDVixrQkFBY3pHLFdBREo7QUFFVixnQkFBWUMsU0FGRjtBQUdWLGlCQUFhSCxVQUhIO0FBSVYsaUJBQWFDO0FBSkgsQ0FBZDtBQU1BLElBQUkyRyxXQUFXLFNBQVNBLFFBQVQsQ0FBa0Jwb0IsSUFBbEIsRUFBd0I0bUIsSUFBeEIsRUFBOEI7QUFDekMsU0FBSzVtQixJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLNG1CLElBQUwsR0FBWUEsSUFBWjtBQUNILENBSEQ7QUFJQXdCLFNBQVN2cUIsS0FBVCxHQUFpQixTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDM0MsUUFBSUQsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbEIsRUFBcUI7QUFDakIsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYyxpQ0FBZCxDQUFQO0FBQ0g7QUFDRCxRQUFJMkgsT0FBTzRmLEtBQUssQ0FBTCxDQUFYO0FBQ0EsUUFBSSxDQUFDNWYsU0FBUyxZQUFULElBQXlCQSxTQUFTLFdBQW5DLEtBQW1ENGYsS0FBS3ZyQixNQUFMLEtBQWdCLENBQXZFLEVBQTBFO0FBQ3RFLGVBQU93ckIsUUFBUXhuQixLQUFSLENBQWMsd0JBQWQsQ0FBUDtBQUNIO0FBQ0QsUUFBSVcsT0FBT21vQixRQUFRbmhCLElBQVIsQ0FBWDtBQUNBLFFBQUlzZ0IsU0FBUyxFQUFiO0FBQ0EsU0FBSyxJQUFJdHNCLElBQUksQ0FBYixFQUFnQkEsSUFBSTRyQixLQUFLdnJCLE1BQXpCLEVBQWlDTCxHQUFqQyxFQUFzQztBQUNsQyxZQUFJZ2IsUUFBUTZRLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUs1ckIsQ0FBTCxDQUFkLEVBQXVCQSxDQUF2QixFQUEwQjZtQixTQUExQixDQUFaO0FBQ0EsWUFBSSxDQUFDN0wsS0FBTCxFQUFZO0FBQ1IsbUJBQU8sSUFBUDtBQUNIO0FBQ0RzUixlQUFPdHJCLElBQVAsQ0FBWWdhLEtBQVo7QUFDSDtBQUNELFdBQU8sSUFBSW9TLFFBQUosQ0FBYXBvQixJQUFiLEVBQW1Cc25CLE1BQW5CLENBQVA7QUFDSCxDQWxCRDtBQW1CQWMsU0FBU25RLFNBQVQsQ0FBbUI4TyxRQUFuQixHQUE4QixTQUFTQSxRQUFULENBQWtCUSxHQUFsQixFQUF1QjtBQUNqRCxRQUFJLEtBQUt2bkIsSUFBTCxDQUFVdWhCLElBQVYsS0FBbUIsU0FBdkIsRUFBa0M7QUFDOUIsZUFBTzhHLFFBQVEsS0FBS3pCLElBQUwsQ0FBVSxDQUFWLEVBQWFHLFFBQWIsQ0FBc0JRLEdBQXRCLENBQVIsQ0FBUDtBQUNILEtBRkQsTUFFTyxJQUFJLEtBQUt2bkIsSUFBTCxDQUFVdWhCLElBQVYsS0FBbUIsT0FBdkIsRUFBZ0M7QUFDbkMsWUFBSXZMLEtBQUo7QUFDQSxZQUFJM1csS0FBSjtBQUNBLGFBQUssSUFBSXJFLElBQUksQ0FBUixFQUFXbWtCLE9BQU8sS0FBS3lILElBQTVCLEVBQWtDNXJCLElBQUlta0IsS0FBSzlqQixNQUEzQyxFQUFtREwsS0FBSyxDQUF4RCxFQUEyRDtBQUN2RCxnQkFBSTRjLE1BQU11SCxLQUFLbmtCLENBQUwsQ0FBVjtBQUNBZ2Isb0JBQVE0QixJQUFJbVAsUUFBSixDQUFhUSxHQUFiLENBQVI7QUFDQWxvQixvQkFBUSxJQUFSO0FBQ0EsZ0JBQUkyVyxpQkFBaUJ2VixLQUFyQixFQUE0QjtBQUN4Qix1QkFBT3VWLEtBQVA7QUFDSCxhQUZELE1BRU8sSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ2xDLG9CQUFJc1MsSUFBSWYsSUFBSWdCLFVBQUosQ0FBZXZTLEtBQWYsQ0FBUjtBQUNBLG9CQUFJc1MsQ0FBSixFQUFPO0FBQ0gsMkJBQU9BLENBQVA7QUFDSDtBQUNKLGFBTE0sTUFLQSxJQUFJcHRCLE1BQU1DLE9BQU4sQ0FBYzZhLEtBQWQsQ0FBSixFQUEwQjtBQUM3QixvQkFBSUEsTUFBTTNhLE1BQU4sR0FBZSxDQUFmLElBQW9CMmEsTUFBTTNhLE1BQU4sR0FBZSxDQUF2QyxFQUEwQztBQUN0Q2dFLDRCQUFRLHdCQUF3QnpCLEtBQUtvVCxTQUFMLENBQWVnRixLQUFmLENBQXhCLEdBQWdELHFFQUF4RDtBQUNILGlCQUZELE1BRU87QUFDSDNXLDRCQUFRZ25CLGFBQWFyUSxNQUFNLENBQU4sQ0FBYixFQUF1QkEsTUFBTSxDQUFOLENBQXZCLEVBQWlDQSxNQUFNLENBQU4sQ0FBakMsRUFBMkNBLE1BQU0sQ0FBTixDQUEzQyxDQUFSO0FBQ0g7QUFDRCxvQkFBSSxDQUFDM1csS0FBTCxFQUFZO0FBQ1IsMkJBQU8sSUFBSW9CLEtBQUosQ0FBVXVWLE1BQU0sQ0FBTixJQUFXLEdBQXJCLEVBQTBCQSxNQUFNLENBQU4sSUFBVyxHQUFyQyxFQUEwQ0EsTUFBTSxDQUFOLElBQVcsR0FBckQsRUFBMERBLE1BQU0sQ0FBTixDQUExRCxDQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsY0FBTSxJQUFJa1IsWUFBSixDQUFpQjduQixTQUFTLHlDQUF5QyxPQUFPMlcsS0FBUCxLQUFpQixRQUFqQixHQUE0QkEsS0FBNUIsR0FBb0N2QixPQUFPN1csS0FBS29ULFNBQUwsQ0FBZWdGLEtBQWYsQ0FBUCxDQUE3RSxJQUE4RyxJQUF4SSxDQUFOO0FBQ0gsS0ExQk0sTUEwQkEsSUFBSSxLQUFLaFcsSUFBTCxDQUFVdWhCLElBQVYsS0FBbUIsUUFBdkIsRUFBaUM7QUFDcEMsWUFBSXJhLFFBQVEsSUFBWjtBQUNBLGFBQUssSUFBSTZYLE1BQU0sQ0FBVixFQUFheUosU0FBUyxLQUFLNUIsSUFBaEMsRUFBc0M3SCxNQUFNeUosT0FBT250QixNQUFuRCxFQUEyRDBqQixPQUFPLENBQWxFLEVBQXFFO0FBQ2pFLGdCQUFJMEosUUFBUUQsT0FBT3pKLEdBQVAsQ0FBWjtBQUNBN1gsb0JBQVF1aEIsTUFBTTFCLFFBQU4sQ0FBZVEsR0FBZixDQUFSO0FBQ0EsZ0JBQUlyZ0IsVUFBVSxJQUFkLEVBQW9CO0FBQ2hCLHVCQUFPLENBQVA7QUFDSDtBQUNELGdCQUFJd2hCLE1BQU1DLE9BQU96aEIsS0FBUCxDQUFWO0FBQ0EsZ0JBQUkwaEIsTUFBTUYsR0FBTixDQUFKLEVBQWdCO0FBQ1o7QUFDSDtBQUNELG1CQUFPQSxHQUFQO0FBQ0g7QUFDRCxjQUFNLElBQUl4QixZQUFKLENBQWlCLHVCQUF1QnRwQixLQUFLb1QsU0FBTCxDQUFlOUosS0FBZixDQUF2QixHQUErQyxhQUFoRSxDQUFOO0FBQ0gsS0FmTSxNQWVBLElBQUksS0FBS2xILElBQUwsQ0FBVXVoQixJQUFWLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ3ZDLGVBQU9tRSxVQUFVRSxVQUFWLENBQXFCYyxXQUFXLEtBQUtFLElBQUwsQ0FBVSxDQUFWLEVBQWFHLFFBQWIsQ0FBc0JRLEdBQXRCLENBQVgsQ0FBckIsQ0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJLEtBQUt2bkIsSUFBTCxDQUFVdWhCLElBQVYsS0FBbUIsZUFBdkIsRUFBd0M7QUFDM0MsZUFBTzRFLGNBQWNQLFVBQWQsQ0FBeUJjLFdBQVcsS0FBS0UsSUFBTCxDQUFVLENBQVYsRUFBYUcsUUFBYixDQUFzQlEsR0FBdEIsQ0FBWCxDQUF6QixDQUFQO0FBQ0gsS0FGTSxNQUVBO0FBQ0gsZUFBT2IsV0FBVyxLQUFLRSxJQUFMLENBQVUsQ0FBVixFQUFhRyxRQUFiLENBQXNCUSxHQUF0QixDQUFYLENBQVA7QUFDSDtBQUNKLENBbkREO0FBb0RBYSxTQUFTblEsU0FBVCxDQUFtQitPLFNBQW5CLEdBQStCLFNBQVNBLFNBQVQsQ0FBbUIvVCxFQUFuQixFQUF1QjtBQUNsRCxTQUFLMlQsSUFBTCxDQUFVckgsT0FBVixDQUFrQnRNLEVBQWxCO0FBQ0gsQ0FGRDtBQUdBbVYsU0FBU25RLFNBQVQsQ0FBbUJnUCxhQUFuQixHQUFtQyxTQUFTQSxhQUFULEdBQXlCO0FBQ3hELFdBQU8sS0FBS0wsSUFBTCxDQUFVWSxLQUFWLENBQWdCLFVBQVU1UCxHQUFWLEVBQWU7QUFDbEMsZUFBT0EsSUFBSXFQLGFBQUosRUFBUDtBQUNILEtBRk0sQ0FBUDtBQUdILENBSkQ7QUFLQW1CLFNBQVNuUSxTQUFULENBQW1CZ08sU0FBbkIsR0FBK0IsU0FBU0EsU0FBVCxHQUFxQjtBQUNoRCxRQUFJLEtBQUtqbUIsSUFBTCxDQUFVdWhCLElBQVYsS0FBbUIsV0FBdkIsRUFBb0M7QUFDaEMsZUFBTyxJQUFJa0csZ0JBQUosQ0FBcUIsQ0FBQztBQUNyQkkscUJBQVMsS0FBS2pCLElBQUwsQ0FBVSxDQUFWLENBRFk7QUFFckJyQixtQkFBTyxJQUZjO0FBR3JCNXBCLGtCQUFNLElBSGU7QUFJckI4cEIsdUJBQVc7QUFKVSxTQUFELENBQXJCLEVBS0NRLFNBTEQsRUFBUDtBQU1IO0FBQ0QsUUFBSSxLQUFLam1CLElBQUwsQ0FBVXVoQixJQUFWLEtBQW1CLGVBQXZCLEVBQXdDO0FBQ3BDLGVBQU8sSUFBSXlHLGVBQUosQ0FBb0IsS0FBS3BCLElBQUwsQ0FBVSxDQUFWLENBQXBCLEVBQWtDWCxTQUFsQyxFQUFQO0FBQ0g7QUFDRCxRQUFJQyxhQUFhLENBQUMsUUFBUSxLQUFLbG1CLElBQUwsQ0FBVXVoQixJQUFuQixDQUFqQjtBQUNBLFNBQUt5RixTQUFMLENBQWUsVUFBVTZCLEtBQVYsRUFBaUI7QUFDNUIzQyxtQkFBV2xxQixJQUFYLENBQWdCNnNCLE1BQU01QyxTQUFOLEVBQWhCO0FBQ0gsS0FGRDtBQUdBLFdBQU9DLFVBQVA7QUFDSCxDQWpCRDs7QUFtQkEsSUFBSTRDLGdCQUFnQixDQUNoQixTQURnQixFQUVoQixPQUZnQixFQUdoQixZQUhnQixFQUloQixTQUpnQixDQUFwQjtBQU1BLElBQUlDLG9CQUFvQixTQUFTQSxpQkFBVCxHQUE2QjtBQUNqRCxTQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNBLFNBQUtDLE9BQUwsR0FBZSxJQUFmO0FBQ0EsU0FBS0MsWUFBTCxHQUFvQixJQUFwQjtBQUNBLFNBQUtDLGdCQUFMLEdBQXdCLElBQXhCO0FBQ0EsU0FBS0MsZ0JBQUwsR0FBd0IsRUFBeEI7QUFDQSxTQUFLbEIsZUFBTCxHQUF1QixJQUF2QjtBQUNBLFNBQUttQixTQUFMLEdBQWlCLElBQWpCO0FBQ0gsQ0FSRDtBQVNBTixrQkFBa0I5USxTQUFsQixDQUE0QnRZLEVBQTVCLEdBQWlDLFNBQVNBLEVBQVQsR0FBYztBQUMzQyxXQUFPLEtBQUtzcEIsT0FBTCxJQUFnQixRQUFRLEtBQUtBLE9BQTdCLEdBQXVDLEtBQUtBLE9BQUwsQ0FBYXRwQixFQUFwRCxHQUF5RCxJQUFoRTtBQUNILENBRkQ7QUFHQW9wQixrQkFBa0I5USxTQUFsQixDQUE0QnFSLFlBQTVCLEdBQTJDLFNBQVNBLFlBQVQsR0FBd0I7QUFDL0QsV0FBTyxLQUFLTCxPQUFMLEdBQWUsT0FBTyxLQUFLQSxPQUFMLENBQWFqcEIsSUFBcEIsS0FBNkIsUUFBN0IsR0FBd0M4b0IsY0FBYyxLQUFLRyxPQUFMLENBQWFqcEIsSUFBM0IsQ0FBeEMsR0FBMkUsS0FBS2lwQixPQUFMLENBQWFqcEIsSUFBdkcsR0FBOEcsSUFBckg7QUFDSCxDQUZEO0FBR0Erb0Isa0JBQWtCOVEsU0FBbEIsQ0FBNEJzUixRQUE1QixHQUF1QyxTQUFTQSxRQUFULEdBQW9CO0FBQ3ZELFdBQU8sS0FBS04sT0FBTCxJQUFnQixjQUFjLEtBQUtBLE9BQW5DLEdBQTZDLEtBQUtBLE9BQUwsQ0FBYU0sUUFBMUQsR0FBcUUsSUFBNUU7QUFDSCxDQUZEO0FBR0FSLGtCQUFrQjlRLFNBQWxCLENBQTRCdVIsV0FBNUIsR0FBMEMsU0FBU0EsV0FBVCxHQUF1QjtBQUM3RCxXQUFPLEtBQUtILFNBQVo7QUFDSCxDQUZEO0FBR0FOLGtCQUFrQjlRLFNBQWxCLENBQTRCOUosVUFBNUIsR0FBeUMsU0FBU0EsVUFBVCxHQUFzQjtBQUMzRCxXQUFPLEtBQUs4YSxPQUFMLElBQWdCLEtBQUtBLE9BQUwsQ0FBYTlhLFVBQTdCLElBQTJDLEVBQWxEO0FBQ0gsQ0FGRDtBQUdBNGEsa0JBQWtCOVEsU0FBbEIsQ0FBNEJzUSxVQUE1QixHQUF5QyxTQUFTQSxVQUFULENBQW9CdlMsS0FBcEIsRUFBMkI7QUFDaEUsUUFBSXlULFNBQVMsS0FBS0wsZ0JBQUwsQ0FBc0JwVCxLQUF0QixDQUFiO0FBQ0EsUUFBSSxDQUFDeVQsTUFBTCxFQUFhO0FBQ1RBLGlCQUFTLEtBQUtMLGdCQUFMLENBQXNCcFQsS0FBdEIsSUFBK0J2VixNQUFNNUMsS0FBTixDQUFZbVksS0FBWixDQUF4QztBQUNIO0FBQ0QsV0FBT3lULE1BQVA7QUFDSCxDQU5EOztBQVFBLElBQUlDLHFCQUFxQixTQUFTQSxrQkFBVCxDQUE0QjFpQixJQUE1QixFQUFrQ2hILElBQWxDLEVBQXdDK21CLFFBQXhDLEVBQWtESCxJQUFsRCxFQUF3RDtBQUM3RSxTQUFLNWYsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS2hILElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUsycEIsU0FBTCxHQUFpQjVDLFFBQWpCO0FBQ0EsU0FBS0gsSUFBTCxHQUFZQSxJQUFaO0FBQ0gsQ0FMRDtBQU1BOEMsbUJBQW1CelIsU0FBbkIsQ0FBNkI4TyxRQUE3QixHQUF3QyxTQUFTQSxRQUFULENBQWtCUSxHQUFsQixFQUF1QjtBQUMzRCxXQUFPLEtBQUtvQyxTQUFMLENBQWVwQyxHQUFmLEVBQW9CLEtBQUtYLElBQXpCLENBQVA7QUFDSCxDQUZEO0FBR0E4QyxtQkFBbUJ6UixTQUFuQixDQUE2QitPLFNBQTdCLEdBQXlDLFNBQVNBLFNBQVQsQ0FBbUIvVCxFQUFuQixFQUF1QjtBQUM1RCxTQUFLMlQsSUFBTCxDQUFVckgsT0FBVixDQUFrQnRNLEVBQWxCO0FBQ0gsQ0FGRDtBQUdBeVcsbUJBQW1CelIsU0FBbkIsQ0FBNkJnUCxhQUE3QixHQUE2QyxTQUFTQSxhQUFULEdBQXlCO0FBQ2xFLFdBQU8sS0FBUDtBQUNILENBRkQ7QUFHQXlDLG1CQUFtQnpSLFNBQW5CLENBQTZCZ08sU0FBN0IsR0FBeUMsU0FBU0EsU0FBVCxHQUFxQjtBQUMxRCxXQUFPLENBQUMsS0FBS2pmLElBQU4sRUFBWXVJLE1BQVosQ0FBbUIsS0FBS3FYLElBQUwsQ0FBVWxyQixHQUFWLENBQWMsVUFBVWtjLEdBQVYsRUFBZTtBQUNuRCxlQUFPQSxJQUFJcU8sU0FBSixFQUFQO0FBQ0gsS0FGeUIsQ0FBbkIsQ0FBUDtBQUdILENBSkQ7QUFLQXlELG1CQUFtQjdyQixLQUFuQixHQUEyQixTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDckQsUUFBSStDLEtBQUo7QUFDQSxRQUFJaEcsS0FBS2dELEtBQUssQ0FBTCxDQUFUO0FBQ0EsUUFBSWlELGFBQWFILG1CQUFtQkksV0FBbkIsQ0FBK0JsRyxFQUEvQixDQUFqQjtBQUNBLFFBQUksQ0FBQ2lHLFVBQUwsRUFBaUI7QUFDYixlQUFPaEQsUUFBUXhuQixLQUFSLENBQWMseUJBQXlCdWtCLEVBQXpCLEdBQThCLDJEQUE1QyxFQUF5RyxDQUF6RyxDQUFQO0FBQ0g7QUFDRCxRQUFJNWpCLE9BQU85RSxNQUFNQyxPQUFOLENBQWMwdUIsVUFBZCxJQUE0QkEsV0FBVyxDQUFYLENBQTVCLEdBQTRDQSxXQUFXN3BCLElBQWxFO0FBQ0EsUUFBSStwQixxQkFBcUI3dUIsTUFBTUMsT0FBTixDQUFjMHVCLFVBQWQsSUFBNEIsQ0FBQyxDQUM5Q0EsV0FBVyxDQUFYLENBRDhDLEVBRTlDQSxXQUFXLENBQVgsQ0FGOEMsQ0FBRCxDQUE1QixHQUdoQkEsV0FBV0csU0FIcEI7QUFJQSxRQUFJQSxZQUFZRCxtQkFBbUJ4ZixNQUFuQixDQUEwQixVQUFVckosR0FBVixFQUFlO0FBQ3JELFlBQUkrb0IsWUFBWS9vQixJQUFJLENBQUosQ0FBaEI7QUFDQSxlQUFPLENBQUNoRyxNQUFNQyxPQUFOLENBQWM4dUIsU0FBZCxDQUFELElBQTZCQSxVQUFVNXVCLE1BQVYsS0FBcUJ1ckIsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBdkU7QUFDSCxLQUhlLENBQWhCO0FBSUEsUUFBSTZ1QixtQkFBbUIsSUFBdkI7QUFDQSxTQUFLLElBQUlDLE1BQU0sQ0FBVixFQUFhaEwsT0FBTzZLLFNBQXpCLEVBQW9DRyxNQUFNaEwsS0FBSzlqQixNQUEvQyxFQUF1RDh1QixPQUFPLENBQTlELEVBQWlFO0FBQzdELFlBQUlqcEIsTUFBTWllLEtBQUtnTCxHQUFMLENBQVY7QUFDQSxZQUFJcEcsU0FBUzdpQixJQUFJLENBQUosQ0FBYjtBQUNBLFlBQUk2bEIsV0FBVzdsQixJQUFJLENBQUosQ0FBZjtBQUNBZ3BCLDJCQUFtQixJQUFJRSxjQUFKLENBQW1CdkQsUUFBUXdELFFBQTNCLEVBQXFDeEQsUUFBUTVwQixJQUE3QyxFQUFtRCxJQUFuRCxFQUF5RDRwQixRQUFReUQsS0FBakUsQ0FBbkI7QUFDQSxZQUFJQyxhQUFhLEVBQWpCO0FBQ0EsWUFBSUMsaUJBQWlCLEtBQXJCO0FBQ0EsYUFBSyxJQUFJeHZCLElBQUksQ0FBYixFQUFnQkEsSUFBSTRyQixLQUFLdnJCLE1BQXpCLEVBQWlDTCxHQUFqQyxFQUFzQztBQUNsQyxnQkFBSTRjLE1BQU1nUCxLQUFLNXJCLENBQUwsQ0FBVjtBQUNBLGdCQUFJOHJCLGVBQWU1ckIsTUFBTUMsT0FBTixDQUFjNG9CLE1BQWQsSUFBd0JBLE9BQU8vb0IsSUFBSSxDQUFYLENBQXhCLEdBQXdDK29CLE9BQU8vakIsSUFBbEU7QUFDQSxnQkFBSXNuQixTQUFTNEMsaUJBQWlCcnNCLEtBQWpCLENBQXVCK1osR0FBdkIsRUFBNEIsSUFBSTJTLFdBQVdsdkIsTUFBM0MsRUFBbUR5ckIsWUFBbkQsQ0FBYjtBQUNBLGdCQUFJLENBQUNRLE1BQUwsRUFBYTtBQUNUa0QsaUNBQWlCLElBQWpCO0FBQ0E7QUFDSDtBQUNERCx1QkFBV3Z1QixJQUFYLENBQWdCc3JCLE1BQWhCO0FBQ0g7QUFDRCxZQUFJa0QsY0FBSixFQUFvQjtBQUNoQjtBQUNIO0FBQ0QsWUFBSXR2QixNQUFNQyxPQUFOLENBQWM0b0IsTUFBZCxDQUFKLEVBQTJCO0FBQ3ZCLGdCQUFJQSxPQUFPMW9CLE1BQVAsS0FBa0JrdkIsV0FBV2x2QixNQUFqQyxFQUF5QztBQUNyQzZ1QixpQ0FBaUI3cUIsS0FBakIsQ0FBdUIsY0FBYzBrQixPQUFPMW9CLE1BQXJCLEdBQThCLHdCQUE5QixHQUF5RGt2QixXQUFXbHZCLE1BQXBFLEdBQTZFLFdBQXBHO0FBQ0E7QUFDSDtBQUNKO0FBQ0QsYUFBSyxJQUFJMGpCLE1BQU0sQ0FBZixFQUFrQkEsTUFBTXdMLFdBQVdsdkIsTUFBbkMsRUFBMkMwakIsS0FBM0MsRUFBa0Q7QUFDOUMsZ0JBQUl1RCxXQUFXcG5CLE1BQU1DLE9BQU4sQ0FBYzRvQixNQUFkLElBQXdCQSxPQUFPaEYsR0FBUCxDQUF4QixHQUFzQ2dGLE9BQU8vakIsSUFBNUQ7QUFDQSxnQkFBSXlvQixRQUFROEIsV0FBV3hMLEdBQVgsQ0FBWjtBQUNBbUwsNkJBQWlCM2EsTUFBakIsQ0FBd0J3UCxNQUFNLENBQTlCLEVBQWlDc0QsWUFBakMsQ0FBOENDLFFBQTlDLEVBQXdEbUcsTUFBTXpvQixJQUE5RDtBQUNIO0FBQ0QsWUFBSWtxQixpQkFBaUI3VixNQUFqQixDQUF3QmhaLE1BQXhCLEtBQW1DLENBQXZDLEVBQTBDO0FBQ3RDLG1CQUFPLElBQUlxdUIsa0JBQUosQ0FBdUI5RixFQUF2QixFQUEyQjVqQixJQUEzQixFQUFpQyttQixRQUFqQyxFQUEyQ3dELFVBQTNDLENBQVA7QUFDSDtBQUNKO0FBQ0QsUUFBSVAsVUFBVTN1QixNQUFWLEtBQXFCLENBQXpCLEVBQTRCO0FBQ3hCLFNBQUN1dUIsUUFBUS9DLFFBQVF4UyxNQUFqQixFQUF5QnJZLElBQXpCLENBQThCdEIsS0FBOUIsQ0FBb0NrdkIsS0FBcEMsRUFBMkNNLGlCQUFpQjdWLE1BQTVEO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsWUFBSW9XLGFBQWFULFVBQVUzdUIsTUFBVixHQUFtQjJ1QixTQUFuQixHQUErQkQsa0JBQWhEO0FBQ0EsWUFBSVcsYUFBYUQsV0FBVy91QixHQUFYLENBQWUsVUFBVXdGLEdBQVYsRUFBZTtBQUMzQyxnQkFBSTZpQixTQUFTN2lCLElBQUksQ0FBSixDQUFiO0FBQ0EsbUJBQU95cEIsbUJBQW1CNUcsTUFBbkIsQ0FBUDtBQUNILFNBSGdCLEVBR2QzZCxJQUhjLENBR1QsS0FIUyxDQUFqQjtBQUlBLFlBQUl3a0IsY0FBYyxFQUFsQjtBQUNBLGFBQUssSUFBSUMsTUFBTSxDQUFmLEVBQWtCQSxNQUFNakUsS0FBS3ZyQixNQUE3QixFQUFxQ3d2QixLQUFyQyxFQUE0QztBQUN4QyxnQkFBSUMsV0FBV2pFLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUtpRSxHQUFMLENBQWQsRUFBeUIsSUFBSUQsWUFBWXZ2QixNQUF6QyxDQUFmO0FBQ0EsZ0JBQUksQ0FBQ3l2QixRQUFMLEVBQWU7QUFDWCx1QkFBTyxJQUFQO0FBQ0g7QUFDREYsd0JBQVk1dUIsSUFBWixDQUFpQjBFLFNBQVNvcUIsU0FBUzlxQixJQUFsQixDQUFqQjtBQUNIO0FBQ0Q2bUIsZ0JBQVF4bkIsS0FBUixDQUFjLGdDQUFnQ3FyQixVQUFoQyxHQUE2QyxlQUE3QyxHQUErREUsWUFBWXhrQixJQUFaLENBQWlCLElBQWpCLENBQS9ELEdBQXdGLFlBQXRHO0FBQ0g7QUFDRCxXQUFPLElBQVA7QUFDSCxDQXZFRDtBQXdFQXNqQixtQkFBbUJxQixRQUFuQixHQUE4QixTQUFTQSxRQUFULENBQWtCVixRQUFsQixFQUE0QlAsV0FBNUIsRUFBeUM7QUFDbkVKLHVCQUFtQkksV0FBbkIsR0FBaUNBLFdBQWpDO0FBQ0EsU0FBSyxJQUFJOWlCLElBQVQsSUFBaUI4aUIsV0FBakIsRUFBOEI7QUFDMUJPLGlCQUFTcmpCLElBQVQsSUFBaUIwaUIsa0JBQWpCO0FBQ0g7QUFDSixDQUxEO0FBTUEsU0FBU2lCLGtCQUFULENBQTRCVixTQUE1QixFQUF1QztBQUNuQyxRQUFJL3VCLE1BQU1DLE9BQU4sQ0FBYzh1QixTQUFkLENBQUosRUFBOEI7QUFDMUIsZUFBTyxNQUFNQSxVQUFVdnVCLEdBQVYsQ0FBY2dGLFFBQWQsRUFBd0IwRixJQUF4QixDQUE2QixJQUE3QixDQUFOLEdBQTJDLEdBQWxEO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsZUFBTyxNQUFNMUYsU0FBU3VwQixVQUFVanFCLElBQW5CLENBQU4sR0FBaUMsTUFBeEM7QUFDSDtBQUNKOztBQUVELElBQUlnckIscUJBQXFCLFNBQVNBLGtCQUFULENBQTRCdEcsYUFBNUIsRUFBMkNDLGtCQUEzQyxFQUErREMsTUFBL0QsRUFBdUU7QUFDNUYsU0FBSzVrQixJQUFMLEdBQVkraEIsWUFBWjtBQUNBLFNBQUs2QyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLRixhQUFMLEdBQXFCQSxhQUFyQjtBQUNBLFNBQUtDLGtCQUFMLEdBQTBCQSxrQkFBMUI7QUFDSCxDQUxEO0FBTUFxRyxtQkFBbUJudEIsS0FBbkIsR0FBMkIsU0FBU0EsS0FBVCxDQUFlK29CLElBQWYsRUFBcUJDLE9BQXJCLEVBQThCO0FBQ3JELFFBQUlELEtBQUt2ckIsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQixlQUFPd3JCLFFBQVF4bkIsS0FBUixDQUFjLHdCQUFkLENBQVA7QUFDSDtBQUNELFFBQUk2UixVQUFVMFYsS0FBSyxDQUFMLENBQWQ7QUFDQSxRQUFJLFFBQU8xVixPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQW5CLElBQStCaFcsTUFBTUMsT0FBTixDQUFjK1YsT0FBZCxDQUFuQyxFQUEyRDtBQUN2RCxlQUFPMlYsUUFBUXhuQixLQUFSLENBQWMsOENBQWQsQ0FBUDtBQUNIO0FBQ0QsUUFBSXFsQixnQkFBZ0JtQyxRQUFRaHBCLEtBQVIsQ0FBY3FULFFBQVEsZ0JBQVIsTUFBOEJsUyxTQUE5QixHQUEwQyxLQUExQyxHQUFrRGtTLFFBQVEsZ0JBQVIsQ0FBaEUsRUFBMkYsQ0FBM0YsRUFBOEZ3USxXQUE5RixDQUFwQjtBQUNBLFFBQUksQ0FBQ2dELGFBQUwsRUFBb0I7QUFDaEIsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJQyxxQkFBcUJrQyxRQUFRaHBCLEtBQVIsQ0FBY3FULFFBQVEscUJBQVIsTUFBbUNsUyxTQUFuQyxHQUErQyxLQUEvQyxHQUF1RGtTLFFBQVEscUJBQVIsQ0FBckUsRUFBcUcsQ0FBckcsRUFBd0d3USxXQUF4RyxDQUF6QjtBQUNBLFFBQUksQ0FBQ2lELGtCQUFMLEVBQXlCO0FBQ3JCLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSUMsU0FBUyxJQUFiO0FBQ0EsUUFBSTFULFFBQVEsUUFBUixDQUFKLEVBQXVCO0FBQ25CMFQsaUJBQVNpQyxRQUFRaHBCLEtBQVIsQ0FBY3FULFFBQVEsUUFBUixDQUFkLEVBQWlDLENBQWpDLEVBQW9DdVEsVUFBcEMsQ0FBVDtBQUNBLFlBQUksQ0FBQ21ELE1BQUwsRUFBYTtBQUNULG1CQUFPLElBQVA7QUFDSDtBQUNKO0FBQ0QsV0FBTyxJQUFJb0csa0JBQUosQ0FBdUJ0RyxhQUF2QixFQUFzQ0Msa0JBQXRDLEVBQTBEQyxNQUExRCxDQUFQO0FBQ0gsQ0F4QkQ7QUF5QkFvRyxtQkFBbUIvUyxTQUFuQixDQUE2QjhPLFFBQTdCLEdBQXdDLFNBQVNBLFFBQVQsQ0FBa0JRLEdBQWxCLEVBQXVCO0FBQzNELFdBQU8sSUFBSTlDLFFBQUosQ0FBYSxLQUFLQyxhQUFMLENBQW1CcUMsUUFBbkIsQ0FBNEJRLEdBQTVCLENBQWIsRUFBK0MsS0FBSzVDLGtCQUFMLENBQXdCb0MsUUFBeEIsQ0FBaUNRLEdBQWpDLENBQS9DLEVBQXNGLEtBQUszQyxNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZbUMsUUFBWixDQUFxQlEsR0FBckIsQ0FBZCxHQUEwQyxJQUFoSSxDQUFQO0FBQ0gsQ0FGRDtBQUdBeUQsbUJBQW1CL1MsU0FBbkIsQ0FBNkIrTyxTQUE3QixHQUF5QyxTQUFTQSxTQUFULENBQW1CL1QsRUFBbkIsRUFBdUI7QUFDNURBLE9BQUcsS0FBS3lSLGFBQVI7QUFDQXpSLE9BQUcsS0FBSzBSLGtCQUFSO0FBQ0EsUUFBSSxLQUFLQyxNQUFULEVBQWlCO0FBQ2IzUixXQUFHLEtBQUsyUixNQUFSO0FBQ0g7QUFDSixDQU5EO0FBT0FvRyxtQkFBbUIvUyxTQUFuQixDQUE2QmdQLGFBQTdCLEdBQTZDLFNBQVNBLGFBQVQsR0FBeUI7QUFDbEUsV0FBTyxLQUFQO0FBQ0gsQ0FGRDtBQUdBK0QsbUJBQW1CL1MsU0FBbkIsQ0FBNkJnTyxTQUE3QixHQUF5QyxTQUFTQSxTQUFULEdBQXFCO0FBQzFELFFBQUkvVSxVQUFVLEVBQWQ7QUFDQUEsWUFBUSxnQkFBUixJQUE0QixLQUFLd1QsYUFBTCxDQUFtQnVCLFNBQW5CLEVBQTVCO0FBQ0EvVSxZQUFRLHFCQUFSLElBQWlDLEtBQUt5VCxrQkFBTCxDQUF3QnNCLFNBQXhCLEVBQWpDO0FBQ0EsUUFBSSxLQUFLckIsTUFBVCxFQUFpQjtBQUNiMVQsZ0JBQVEsUUFBUixJQUFvQixLQUFLMFQsTUFBTCxDQUFZcUIsU0FBWixFQUFwQjtBQUNIO0FBQ0QsV0FBTyxDQUNILFVBREcsRUFFSC9VLE9BRkcsQ0FBUDtBQUlILENBWEQ7O0FBYUEsSUFBSStaLFNBQVMsSUFBYjtBQUNBLFNBQVNDLFVBQVQsQ0FBb0IvbEIsSUFBcEIsRUFBMEI4YSxLQUExQixFQUFpQztBQUM3QjlhLFNBQUssQ0FBTCxJQUFVb1AsS0FBS3hGLEdBQUwsQ0FBUzVKLEtBQUssQ0FBTCxDQUFULEVBQWtCOGEsTUFBTSxDQUFOLENBQWxCLENBQVY7QUFDQTlhLFNBQUssQ0FBTCxJQUFVb1AsS0FBS3hGLEdBQUwsQ0FBUzVKLEtBQUssQ0FBTCxDQUFULEVBQWtCOGEsTUFBTSxDQUFOLENBQWxCLENBQVY7QUFDQTlhLFNBQUssQ0FBTCxJQUFVb1AsS0FBS3ZGLEdBQUwsQ0FBUzdKLEtBQUssQ0FBTCxDQUFULEVBQWtCOGEsTUFBTSxDQUFOLENBQWxCLENBQVY7QUFDQTlhLFNBQUssQ0FBTCxJQUFVb1AsS0FBS3ZGLEdBQUwsQ0FBUzdKLEtBQUssQ0FBTCxDQUFULEVBQWtCOGEsTUFBTSxDQUFOLENBQWxCLENBQVY7QUFDSDtBQUNELFNBQVNrTCxnQkFBVCxDQUEwQkMsR0FBMUIsRUFBK0I7QUFDM0IsV0FBTyxDQUFDLE1BQU1BLEdBQVAsSUFBYyxHQUFyQjtBQUNIO0FBQ0QsU0FBU0MsZ0JBQVQsQ0FBMEJDLEdBQTFCLEVBQStCO0FBQzNCLFdBQU8sQ0FBQyxNQUFNLE1BQU0vVyxLQUFLZ1gsRUFBWCxHQUFnQmhYLEtBQUtpWCxHQUFMLENBQVNqWCxLQUFLNUYsR0FBTCxDQUFTNEYsS0FBS2dYLEVBQUwsR0FBVSxDQUFWLEdBQWNELE1BQU0vVyxLQUFLZ1gsRUFBWCxHQUFnQixHQUF2QyxDQUFULENBQXZCLElBQWdGLEdBQXZGO0FBQ0g7QUFDRCxTQUFTRSxZQUFULENBQXNCQyxLQUF0QixFQUE2QkMsS0FBN0IsRUFBb0M7QUFDaEMsUUFBSUQsTUFBTSxDQUFOLEtBQVlDLE1BQU0sQ0FBTixDQUFoQixFQUEwQjtBQUN0QixlQUFPLEtBQVA7QUFDSDtBQUNELFFBQUlELE1BQU0sQ0FBTixLQUFZQyxNQUFNLENBQU4sQ0FBaEIsRUFBMEI7QUFDdEIsZUFBTyxLQUFQO0FBQ0g7QUFDRCxRQUFJRCxNQUFNLENBQU4sS0FBWUMsTUFBTSxDQUFOLENBQWhCLEVBQTBCO0FBQ3RCLGVBQU8sS0FBUDtBQUNIO0FBQ0QsUUFBSUQsTUFBTSxDQUFOLEtBQVlDLE1BQU0sQ0FBTixDQUFoQixFQUEwQjtBQUN0QixlQUFPLEtBQVA7QUFDSDtBQUNELFdBQU8sSUFBUDtBQUNIO0FBQ0QsU0FBU0Msa0JBQVQsQ0FBNEI1TyxDQUE1QixFQUErQnFNLFNBQS9CLEVBQTBDO0FBQ3RDLFFBQUk1USxJQUFJMFMsaUJBQWlCbk8sRUFBRSxDQUFGLENBQWpCLENBQVI7QUFDQSxRQUFJNk8sSUFBSVIsaUJBQWlCck8sRUFBRSxDQUFGLENBQWpCLENBQVI7QUFDQSxRQUFJOE8sY0FBY3ZYLEtBQUt3WCxHQUFMLENBQVMsQ0FBVCxFQUFZMUMsVUFBVTJDLENBQXRCLENBQWxCO0FBQ0EsV0FBTyxDQUNIelgsS0FBS3JKLEtBQUwsQ0FBV3VOLElBQUlxVCxXQUFKLEdBQWtCYixNQUE3QixDQURHLEVBRUgxVyxLQUFLckosS0FBTCxDQUFXMmdCLElBQUlDLFdBQUosR0FBa0JiLE1BQTdCLENBRkcsQ0FBUDtBQUlIO0FBQ0QsU0FBU2dCLFVBQVQsQ0FBb0JqUCxDQUFwQixFQUF1QmtQLEVBQXZCLEVBQTJCQyxFQUEzQixFQUErQjtBQUMzQixRQUFJQyxLQUFLcFAsRUFBRSxDQUFGLElBQU9rUCxHQUFHLENBQUgsQ0FBaEI7QUFDQSxRQUFJRyxLQUFLclAsRUFBRSxDQUFGLElBQU9rUCxHQUFHLENBQUgsQ0FBaEI7QUFDQSxRQUFJSSxLQUFLdFAsRUFBRSxDQUFGLElBQU9tUCxHQUFHLENBQUgsQ0FBaEI7QUFDQSxRQUFJSSxLQUFLdlAsRUFBRSxDQUFGLElBQU9tUCxHQUFHLENBQUgsQ0FBaEI7QUFDQSxXQUFPQyxLQUFLRyxFQUFMLEdBQVVELEtBQUtELEVBQWYsS0FBc0IsQ0FBdEIsSUFBMkJELEtBQUtFLEVBQUwsSUFBVyxDQUF0QyxJQUEyQ0QsS0FBS0UsRUFBTCxJQUFXLENBQTdEO0FBQ0g7QUFDRCxTQUFTQyxZQUFULENBQXNCeFAsQ0FBdEIsRUFBeUJrUCxFQUF6QixFQUE2QkMsRUFBN0IsRUFBaUM7QUFDN0IsV0FBT0QsR0FBRyxDQUFILElBQVFsUCxFQUFFLENBQUYsQ0FBUixLQUFpQm1QLEdBQUcsQ0FBSCxJQUFRblAsRUFBRSxDQUFGLENBQXpCLElBQWlDQSxFQUFFLENBQUYsSUFBTyxDQUFDbVAsR0FBRyxDQUFILElBQVFELEdBQUcsQ0FBSCxDQUFULEtBQW1CbFAsRUFBRSxDQUFGLElBQU9rUCxHQUFHLENBQUgsQ0FBMUIsS0FBb0NDLEdBQUcsQ0FBSCxJQUFRRCxHQUFHLENBQUgsQ0FBNUMsSUFBcURBLEdBQUcsQ0FBSCxDQUFwRztBQUNIO0FBQ0QsU0FBU08sa0JBQVQsQ0FBNEJqaEIsS0FBNUIsRUFBbUNraEIsS0FBbkMsRUFBMEM7QUFDdEMsUUFBSUMsU0FBUyxLQUFiO0FBQ0EsU0FBSyxJQUFJM3hCLElBQUksQ0FBUixFQUFXd2QsTUFBTWtVLE1BQU1yeEIsTUFBNUIsRUFBb0NMLElBQUl3ZCxHQUF4QyxFQUE2Q3hkLEdBQTdDLEVBQWtEO0FBQzlDLFlBQUk0eEIsT0FBT0YsTUFBTTF4QixDQUFOLENBQVg7QUFDQSxhQUFLLElBQUlzYixJQUFJLENBQVIsRUFBV3VXLE9BQU9ELEtBQUt2eEIsTUFBNUIsRUFBb0NpYixJQUFJdVcsT0FBTyxDQUEvQyxFQUFrRHZXLEdBQWxELEVBQXVEO0FBQ25ELGdCQUFJMlYsV0FBV3pnQixLQUFYLEVBQWtCb2hCLEtBQUt0VyxDQUFMLENBQWxCLEVBQTJCc1csS0FBS3RXLElBQUksQ0FBVCxDQUEzQixDQUFKLEVBQTZDO0FBQ3pDLHVCQUFPLEtBQVA7QUFDSDtBQUNELGdCQUFJa1csYUFBYWhoQixLQUFiLEVBQW9Cb2hCLEtBQUt0VyxDQUFMLENBQXBCLEVBQTZCc1csS0FBS3RXLElBQUksQ0FBVCxDQUE3QixDQUFKLEVBQStDO0FBQzNDcVcseUJBQVMsQ0FBQ0EsTUFBVjtBQUNIO0FBQ0o7QUFDSjtBQUNELFdBQU9BLE1BQVA7QUFDSDtBQUNELFNBQVNHLG1CQUFULENBQTZCdGhCLEtBQTdCLEVBQW9DdWhCLFFBQXBDLEVBQThDO0FBQzFDLFNBQUssSUFBSS94QixJQUFJLENBQWIsRUFBZ0JBLElBQUkreEIsU0FBUzF4QixNQUE3QixFQUFxQ0wsR0FBckMsRUFBMEM7QUFDdEMsWUFBSXl4QixtQkFBbUJqaEIsS0FBbkIsRUFBMEJ1aEIsU0FBUy94QixDQUFULENBQTFCLENBQUosRUFBNEM7QUFDeEMsbUJBQU8sSUFBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPLEtBQVA7QUFDSDtBQUNELFNBQVNneUIsSUFBVCxDQUFjQyxFQUFkLEVBQWtCQyxFQUFsQixFQUFzQjtBQUNsQixXQUFPRCxHQUFHLENBQUgsSUFBUUMsR0FBRyxDQUFILENBQVIsR0FBZ0JELEdBQUcsQ0FBSCxJQUFRQyxHQUFHLENBQUgsQ0FBL0I7QUFDSDtBQUNELFNBQVNDLFFBQVQsQ0FBa0JqQixFQUFsQixFQUFzQkMsRUFBdEIsRUFBMEJpQixFQUExQixFQUE4QkMsRUFBOUIsRUFBa0M7QUFDOUIsUUFBSWpCLEtBQUtGLEdBQUcsQ0FBSCxJQUFRa0IsR0FBRyxDQUFILENBQWpCO0FBQ0EsUUFBSWYsS0FBS0gsR0FBRyxDQUFILElBQVFrQixHQUFHLENBQUgsQ0FBakI7QUFDQSxRQUFJZCxLQUFLSCxHQUFHLENBQUgsSUFBUWlCLEdBQUcsQ0FBSCxDQUFqQjtBQUNBLFFBQUliLEtBQUtKLEdBQUcsQ0FBSCxJQUFRaUIsR0FBRyxDQUFILENBQWpCO0FBQ0EsUUFBSUUsS0FBS0QsR0FBRyxDQUFILElBQVFELEdBQUcsQ0FBSCxDQUFqQjtBQUNBLFFBQUlHLEtBQUtGLEdBQUcsQ0FBSCxJQUFRRCxHQUFHLENBQUgsQ0FBakI7QUFDQSxRQUFJSSxPQUFPcEIsS0FBS21CLEVBQUwsR0FBVUQsS0FBS2pCLEVBQTFCO0FBQ0EsUUFBSW9CLE9BQU9uQixLQUFLaUIsRUFBTCxHQUFVRCxLQUFLZixFQUExQjtBQUNBLFFBQUlpQixPQUFPLENBQVAsSUFBWUMsT0FBTyxDQUFuQixJQUF3QkQsT0FBTyxDQUFQLElBQVlDLE9BQU8sQ0FBL0MsRUFBa0Q7QUFDOUMsZUFBTyxJQUFQO0FBQ0g7QUFDRCxXQUFPLEtBQVA7QUFDSDtBQUNELFNBQVNDLGlCQUFULENBQTJCem5CLENBQTNCLEVBQThCa2UsQ0FBOUIsRUFBaUNtRSxDQUFqQyxFQUFvQ3FGLENBQXBDLEVBQXVDO0FBQ25DLFFBQUlDLFVBQVUsQ0FDVnpKLEVBQUUsQ0FBRixJQUFPbGUsRUFBRSxDQUFGLENBREcsRUFFVmtlLEVBQUUsQ0FBRixJQUFPbGUsRUFBRSxDQUFGLENBRkcsQ0FBZDtBQUlBLFFBQUk0bkIsVUFBVSxDQUNWRixFQUFFLENBQUYsSUFBT3JGLEVBQUUsQ0FBRixDQURHLEVBRVZxRixFQUFFLENBQUYsSUFBT3JGLEVBQUUsQ0FBRixDQUZHLENBQWQ7QUFJQSxRQUFJMEUsS0FBS2EsT0FBTCxFQUFjRCxPQUFkLE1BQTJCLENBQS9CLEVBQWtDO0FBQzlCLGVBQU8sS0FBUDtBQUNIO0FBQ0QsUUFBSVQsU0FBU2xuQixDQUFULEVBQVlrZSxDQUFaLEVBQWVtRSxDQUFmLEVBQWtCcUYsQ0FBbEIsS0FBd0JSLFNBQVM3RSxDQUFULEVBQVlxRixDQUFaLEVBQWUxbkIsQ0FBZixFQUFrQmtlLENBQWxCLENBQTVCLEVBQWtEO0FBQzlDLGVBQU8sSUFBUDtBQUNIO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7QUFDRCxTQUFTMkosb0JBQVQsQ0FBOEI1QixFQUE5QixFQUFrQ0MsRUFBbEMsRUFBc0M0QixPQUF0QyxFQUErQztBQUMzQyxTQUFLLElBQUkveUIsSUFBSSxDQUFSLEVBQVdta0IsT0FBTzRPLE9BQXZCLEVBQWdDL3lCLElBQUlta0IsS0FBSzlqQixNQUF6QyxFQUFpREwsS0FBSyxDQUF0RCxFQUF5RDtBQUNyRCxZQUFJNHhCLE9BQU96TixLQUFLbmtCLENBQUwsQ0FBWDtBQUNBLGFBQUssSUFBSXNiLElBQUksQ0FBYixFQUFnQkEsSUFBSXNXLEtBQUt2eEIsTUFBTCxHQUFjLENBQWxDLEVBQXFDLEVBQUVpYixDQUF2QyxFQUEwQztBQUN0QyxnQkFBSW9YLGtCQUFrQnhCLEVBQWxCLEVBQXNCQyxFQUF0QixFQUEwQlMsS0FBS3RXLENBQUwsQ0FBMUIsRUFBbUNzVyxLQUFLdFcsSUFBSSxDQUFULENBQW5DLENBQUosRUFBcUQ7QUFDakQsdUJBQU8sSUFBUDtBQUNIO0FBQ0o7QUFDSjtBQUNELFdBQU8sS0FBUDtBQUNIO0FBQ0QsU0FBUzBYLHVCQUFULENBQWlDOWpCLElBQWpDLEVBQXVDNmpCLE9BQXZDLEVBQWdEO0FBQzVDLFNBQUssSUFBSS95QixJQUFJLENBQWIsRUFBZ0JBLElBQUlrUCxLQUFLN08sTUFBekIsRUFBaUMsRUFBRUwsQ0FBbkMsRUFBc0M7QUFDbEMsWUFBSSxDQUFDeXhCLG1CQUFtQnZpQixLQUFLbFAsQ0FBTCxDQUFuQixFQUE0Qit5QixPQUE1QixDQUFMLEVBQTJDO0FBQ3ZDLG1CQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0QsU0FBSyxJQUFJaFAsTUFBTSxDQUFmLEVBQWtCQSxNQUFNN1UsS0FBSzdPLE1BQUwsR0FBYyxDQUF0QyxFQUF5QyxFQUFFMGpCLEdBQTNDLEVBQWdEO0FBQzVDLFlBQUkrTyxxQkFBcUI1akIsS0FBSzZVLEdBQUwsQ0FBckIsRUFBZ0M3VSxLQUFLNlUsTUFBTSxDQUFYLENBQWhDLEVBQStDZ1AsT0FBL0MsQ0FBSixFQUE2RDtBQUN6RCxtQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNELFdBQU8sSUFBUDtBQUNIO0FBQ0QsU0FBU0Usd0JBQVQsQ0FBa0MvakIsSUFBbEMsRUFBd0M2aUIsUUFBeEMsRUFBa0Q7QUFDOUMsU0FBSyxJQUFJL3hCLElBQUksQ0FBYixFQUFnQkEsSUFBSSt4QixTQUFTMXhCLE1BQTdCLEVBQXFDTCxHQUFyQyxFQUEwQztBQUN0QyxZQUFJZ3pCLHdCQUF3QjlqQixJQUF4QixFQUE4QjZpQixTQUFTL3hCLENBQVQsQ0FBOUIsQ0FBSixFQUFnRDtBQUM1QyxtQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELFdBQU8sS0FBUDtBQUNIO0FBQ0QsU0FBU2t6QixjQUFULENBQXdCeGtCLFdBQXhCLEVBQXFDdkUsSUFBckMsRUFBMkNra0IsU0FBM0MsRUFBc0Q7QUFDbEQsUUFBSTBFLFVBQVUsRUFBZDtBQUNBLFNBQUssSUFBSS95QixJQUFJLENBQWIsRUFBZ0JBLElBQUkwTyxZQUFZck8sTUFBaEMsRUFBd0NMLEdBQXhDLEVBQTZDO0FBQ3pDLFlBQUk0eEIsT0FBTyxFQUFYO0FBQ0EsYUFBSyxJQUFJdFcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNU0sWUFBWTFPLENBQVosRUFBZUssTUFBbkMsRUFBMkNpYixHQUEzQyxFQUFnRDtBQUM1QyxnQkFBSTJKLFFBQVEyTCxtQkFBbUJsaUIsWUFBWTFPLENBQVosRUFBZXNiLENBQWYsQ0FBbkIsRUFBc0MrUyxTQUF0QyxDQUFaO0FBQ0E2Qix1QkFBVy9sQixJQUFYLEVBQWlCOGEsS0FBakI7QUFDQTJNLGlCQUFLNXdCLElBQUwsQ0FBVWlrQixLQUFWO0FBQ0g7QUFDRDhOLGdCQUFRL3hCLElBQVIsQ0FBYTR3QixJQUFiO0FBQ0g7QUFDRCxXQUFPbUIsT0FBUDtBQUNIO0FBQ0QsU0FBU0ksZUFBVCxDQUF5QnprQixXQUF6QixFQUFzQ3ZFLElBQXRDLEVBQTRDa2tCLFNBQTVDLEVBQXVEO0FBQ25ELFFBQUkwRCxXQUFXLEVBQWY7QUFDQSxTQUFLLElBQUkveEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJME8sWUFBWXJPLE1BQWhDLEVBQXdDTCxHQUF4QyxFQUE2QztBQUN6QyxZQUFJK3lCLFVBQVVHLGVBQWV4a0IsWUFBWTFPLENBQVosQ0FBZixFQUErQm1LLElBQS9CLEVBQXFDa2tCLFNBQXJDLENBQWQ7QUFDQTBELGlCQUFTL3dCLElBQVQsQ0FBYyt4QixPQUFkO0FBQ0g7QUFDRCxXQUFPaEIsUUFBUDtBQUNIO0FBQ0QsU0FBU3FCLFdBQVQsQ0FBcUJwUixDQUFyQixFQUF3QjdYLElBQXhCLEVBQThCa3BCLFFBQTlCLEVBQXdDQyxTQUF4QyxFQUFtRDtBQUMvQyxRQUFJdFIsRUFBRSxDQUFGLElBQU9xUixTQUFTLENBQVQsQ0FBUCxJQUFzQnJSLEVBQUUsQ0FBRixJQUFPcVIsU0FBUyxDQUFULENBQWpDLEVBQThDO0FBQzFDLFlBQUlFLGdCQUFnQkQsWUFBWSxHQUFoQztBQUNBLFlBQUl0USxRQUFRaEIsRUFBRSxDQUFGLElBQU9xUixTQUFTLENBQVQsQ0FBUCxHQUFxQkUsYUFBckIsR0FBcUMsQ0FBQ0QsU0FBdEMsR0FBa0RELFNBQVMsQ0FBVCxJQUFjclIsRUFBRSxDQUFGLENBQWQsR0FBcUJ1UixhQUFyQixHQUFxQ0QsU0FBckMsR0FBaUQsQ0FBL0c7QUFDQSxZQUFJdFEsVUFBVSxDQUFkLEVBQWlCO0FBQ2JBLG9CQUFRaEIsRUFBRSxDQUFGLElBQU9xUixTQUFTLENBQVQsQ0FBUCxHQUFxQkUsYUFBckIsR0FBcUMsQ0FBQ0QsU0FBdEMsR0FBa0RELFNBQVMsQ0FBVCxJQUFjclIsRUFBRSxDQUFGLENBQWQsR0FBcUJ1UixhQUFyQixHQUFxQ0QsU0FBckMsR0FBaUQsQ0FBM0c7QUFDSDtBQUNEdFIsVUFBRSxDQUFGLEtBQVFnQixLQUFSO0FBQ0g7QUFDRGtOLGVBQVcvbEIsSUFBWCxFQUFpQjZYLENBQWpCO0FBQ0g7QUFDRCxTQUFTd1IsU0FBVCxDQUFtQnJwQixJQUFuQixFQUF5QjtBQUNyQkEsU0FBSyxDQUFMLElBQVVBLEtBQUssQ0FBTCxJQUFVbU0sUUFBcEI7QUFDQW5NLFNBQUssQ0FBTCxJQUFVQSxLQUFLLENBQUwsSUFBVSxDQUFDbU0sUUFBckI7QUFDSDtBQUNELFNBQVNtZCxhQUFULENBQXVCbEYsUUFBdkIsRUFBaUNtRixTQUFqQyxFQUE0Q0wsUUFBNUMsRUFBc0RoRixTQUF0RCxFQUFpRTtBQUM3RCxRQUFJaUYsWUFBWS9aLEtBQUt3WCxHQUFMLENBQVMsQ0FBVCxFQUFZMUMsVUFBVTJDLENBQXRCLElBQTJCZixNQUEzQztBQUNBLFFBQUkwRCxTQUFTLENBQ1R0RixVQUFVNVEsQ0FBVixHQUFjd1MsTUFETCxFQUVUNUIsVUFBVXdDLENBQVYsR0FBY1osTUFGTCxDQUFiO0FBSUEsUUFBSTJELGFBQWEsRUFBakI7QUFDQSxTQUFLLElBQUk3UCxNQUFNLENBQVYsRUFBYXlKLFNBQVNlLFFBQTNCLEVBQXFDeEssTUFBTXlKLE9BQU9udEIsTUFBbEQsRUFBMEQwakIsT0FBTyxDQUFqRSxFQUFvRTtBQUNoRSxZQUFJOFAsU0FBU3JHLE9BQU96SixHQUFQLENBQWI7QUFDQSxhQUFLLElBQUkvakIsSUFBSSxDQUFSLEVBQVdta0IsT0FBTzBQLE1BQXZCLEVBQStCN3pCLElBQUlta0IsS0FBSzlqQixNQUF4QyxFQUFnREwsS0FBSyxDQUFyRCxFQUF3RDtBQUNwRCxnQkFBSXdRLFFBQVEyVCxLQUFLbmtCLENBQUwsQ0FBWjtBQUNBLGdCQUFJZ2lCLElBQUksQ0FDSnhSLE1BQU1pTixDQUFOLEdBQVVrVyxPQUFPLENBQVAsQ0FETixFQUVKbmpCLE1BQU1xZ0IsQ0FBTixHQUFVOEMsT0FBTyxDQUFQLENBRk4sQ0FBUjtBQUlBUCx3QkFBWXBSLENBQVosRUFBZTBSLFNBQWYsRUFBMEJMLFFBQTFCLEVBQW9DQyxTQUFwQztBQUNBTSx1QkFBVzV5QixJQUFYLENBQWdCZ2hCLENBQWhCO0FBQ0g7QUFDSjtBQUNELFdBQU80UixVQUFQO0FBQ0g7QUFDRCxTQUFTRSxZQUFULENBQXNCdkYsUUFBdEIsRUFBZ0N3RixRQUFoQyxFQUEwQ1YsUUFBMUMsRUFBb0RoRixTQUFwRCxFQUErRDtBQUMzRCxRQUFJaUYsWUFBWS9aLEtBQUt3WCxHQUFMLENBQVMsQ0FBVCxFQUFZMUMsVUFBVTJDLENBQXRCLElBQTJCZixNQUEzQztBQUNBLFFBQUkwRCxTQUFTLENBQ1R0RixVQUFVNVEsQ0FBVixHQUFjd1MsTUFETCxFQUVUNUIsVUFBVXdDLENBQVYsR0FBY1osTUFGTCxDQUFiO0FBSUEsUUFBSStELFlBQVksRUFBaEI7QUFDQSxTQUFLLElBQUlqUSxNQUFNLENBQVYsRUFBYXlKLFNBQVNlLFFBQTNCLEVBQXFDeEssTUFBTXlKLE9BQU9udEIsTUFBbEQsRUFBMEQwakIsT0FBTyxDQUFqRSxFQUFvRTtBQUNoRSxZQUFJN1UsT0FBT3NlLE9BQU96SixHQUFQLENBQVg7QUFDQSxZQUFJa1EsV0FBVyxFQUFmO0FBQ0EsYUFBSyxJQUFJajBCLElBQUksQ0FBUixFQUFXbWtCLE9BQU9qVixJQUF2QixFQUE2QmxQLElBQUlta0IsS0FBSzlqQixNQUF0QyxFQUE4Q0wsS0FBSyxDQUFuRCxFQUFzRDtBQUNsRCxnQkFBSXdRLFFBQVEyVCxLQUFLbmtCLENBQUwsQ0FBWjtBQUNBLGdCQUFJZ2lCLElBQUksQ0FDSnhSLE1BQU1pTixDQUFOLEdBQVVrVyxPQUFPLENBQVAsQ0FETixFQUVKbmpCLE1BQU1xZ0IsQ0FBTixHQUFVOEMsT0FBTyxDQUFQLENBRk4sQ0FBUjtBQUlBekQsdUJBQVc2RCxRQUFYLEVBQXFCL1IsQ0FBckI7QUFDQWlTLHFCQUFTanpCLElBQVQsQ0FBY2doQixDQUFkO0FBQ0g7QUFDRGdTLGtCQUFVaHpCLElBQVYsQ0FBZWl6QixRQUFmO0FBQ0g7QUFDRCxRQUFJRixTQUFTLENBQVQsSUFBY0EsU0FBUyxDQUFULENBQWQsSUFBNkJULFlBQVksQ0FBN0MsRUFBZ0Q7QUFDNUNFLGtCQUFVTyxRQUFWO0FBQ0EsYUFBSyxJQUFJNUUsTUFBTSxDQUFWLEVBQWErRSxTQUFTRixTQUEzQixFQUFzQzdFLE1BQU0rRSxPQUFPN3pCLE1BQW5ELEVBQTJEOHVCLE9BQU8sQ0FBbEUsRUFBcUU7QUFDakUsZ0JBQUlnRixTQUFTRCxPQUFPL0UsR0FBUCxDQUFiO0FBQ0EsaUJBQUssSUFBSVUsTUFBTSxDQUFWLEVBQWF1RSxTQUFTRCxNQUEzQixFQUFtQ3RFLE1BQU11RSxPQUFPL3pCLE1BQWhELEVBQXdEd3ZCLE9BQU8sQ0FBL0QsRUFBa0U7QUFDOUQsb0JBQUl3RSxNQUFNRCxPQUFPdkUsR0FBUCxDQUFWO0FBQ0F1RCw0QkFBWWlCLEdBQVosRUFBaUJOLFFBQWpCLEVBQTJCVixRQUEzQixFQUFxQ0MsU0FBckM7QUFDSDtBQUNKO0FBQ0o7QUFDRCxXQUFPVSxTQUFQO0FBQ0g7QUFDRCxTQUFTTSxvQkFBVCxDQUE4Qi9ILEdBQTlCLEVBQW1DZ0ksZUFBbkMsRUFBb0Q7QUFDaEQsUUFBSWIsWUFBWSxDQUNacGQsUUFEWSxFQUVaQSxRQUZZLEVBR1osQ0FBQ0EsUUFIVyxFQUlaLENBQUNBLFFBSlcsQ0FBaEI7QUFNQSxRQUFJK2MsV0FBVyxDQUNYL2MsUUFEVyxFQUVYQSxRQUZXLEVBR1gsQ0FBQ0EsUUFIVSxFQUlYLENBQUNBLFFBSlUsQ0FBZjtBQU1BLFFBQUkrWCxZQUFZOUIsSUFBSWlDLFdBQUosRUFBaEI7QUFDQSxRQUFJK0YsZ0JBQWdCdnZCLElBQWhCLEtBQXlCLFNBQTdCLEVBQXdDO0FBQ3BDLFlBQUl3dkIsY0FBY3RCLGVBQWVxQixnQkFBZ0I3bEIsV0FBL0IsRUFBNEMya0IsUUFBNUMsRUFBc0RoRixTQUF0RCxDQUFsQjtBQUNBLFlBQUl1RixhQUFhSCxjQUFjbEgsSUFBSWdDLFFBQUosRUFBZCxFQUE4Qm1GLFNBQTlCLEVBQXlDTCxRQUF6QyxFQUFtRGhGLFNBQW5ELENBQWpCO0FBQ0EsWUFBSSxDQUFDb0MsYUFBYWlELFNBQWIsRUFBd0JMLFFBQXhCLENBQUwsRUFBd0M7QUFDcEMsbUJBQU8sS0FBUDtBQUNIO0FBQ0QsYUFBSyxJQUFJcnpCLElBQUksQ0FBUixFQUFXbWtCLE9BQU95UCxVQUF2QixFQUFtQzV6QixJQUFJbWtCLEtBQUs5akIsTUFBNUMsRUFBb0RMLEtBQUssQ0FBekQsRUFBNEQ7QUFDeEQsZ0JBQUl3USxRQUFRMlQsS0FBS25rQixDQUFMLENBQVo7QUFDQSxnQkFBSSxDQUFDeXhCLG1CQUFtQmpoQixLQUFuQixFQUEwQmdrQixXQUExQixDQUFMLEVBQTZDO0FBQ3pDLHVCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDRCxRQUFJRCxnQkFBZ0J2dkIsSUFBaEIsS0FBeUIsY0FBN0IsRUFBNkM7QUFDekMsWUFBSXl2QixlQUFldEIsZ0JBQWdCb0IsZ0JBQWdCN2xCLFdBQWhDLEVBQTZDMmtCLFFBQTdDLEVBQXVEaEYsU0FBdkQsQ0FBbkI7QUFDQSxZQUFJcUcsZUFBZWpCLGNBQWNsSCxJQUFJZ0MsUUFBSixFQUFkLEVBQThCbUYsU0FBOUIsRUFBeUNMLFFBQXpDLEVBQW1EaEYsU0FBbkQsQ0FBbkI7QUFDQSxZQUFJLENBQUNvQyxhQUFhaUQsU0FBYixFQUF3QkwsUUFBeEIsQ0FBTCxFQUF3QztBQUNwQyxtQkFBTyxLQUFQO0FBQ0g7QUFDRCxhQUFLLElBQUl0UCxNQUFNLENBQVYsRUFBYXlKLFNBQVNrSCxZQUEzQixFQUF5QzNRLE1BQU15SixPQUFPbnRCLE1BQXRELEVBQThEMGpCLE9BQU8sQ0FBckUsRUFBd0U7QUFDcEUsZ0JBQUk0USxVQUFVbkgsT0FBT3pKLEdBQVAsQ0FBZDtBQUNBLGdCQUFJLENBQUMrTixvQkFBb0I2QyxPQUFwQixFQUE2QkYsWUFBN0IsQ0FBTCxFQUFpRDtBQUM3Qyx1QkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsV0FBTyxJQUFQO0FBQ0g7QUFDRCxTQUFTRyxtQkFBVCxDQUE2QnJJLEdBQTdCLEVBQWtDZ0ksZUFBbEMsRUFBbUQ7QUFDL0MsUUFBSVIsV0FBVyxDQUNYemQsUUFEVyxFQUVYQSxRQUZXLEVBR1gsQ0FBQ0EsUUFIVSxFQUlYLENBQUNBLFFBSlUsQ0FBZjtBQU1BLFFBQUkrYyxXQUFXLENBQ1gvYyxRQURXLEVBRVhBLFFBRlcsRUFHWCxDQUFDQSxRQUhVLEVBSVgsQ0FBQ0EsUUFKVSxDQUFmO0FBTUEsUUFBSStYLFlBQVk5QixJQUFJaUMsV0FBSixFQUFoQjtBQUNBLFFBQUkrRixnQkFBZ0J2dkIsSUFBaEIsS0FBeUIsU0FBN0IsRUFBd0M7QUFDcEMsWUFBSXd2QixjQUFjdEIsZUFBZXFCLGdCQUFnQjdsQixXQUEvQixFQUE0QzJrQixRQUE1QyxFQUFzRGhGLFNBQXRELENBQWxCO0FBQ0EsWUFBSTJGLFlBQVlGLGFBQWF2SCxJQUFJZ0MsUUFBSixFQUFiLEVBQTZCd0YsUUFBN0IsRUFBdUNWLFFBQXZDLEVBQWlEaEYsU0FBakQsQ0FBaEI7QUFDQSxZQUFJLENBQUNvQyxhQUFhc0QsUUFBYixFQUF1QlYsUUFBdkIsQ0FBTCxFQUF1QztBQUNuQyxtQkFBTyxLQUFQO0FBQ0g7QUFDRCxhQUFLLElBQUlyekIsSUFBSSxDQUFSLEVBQVdta0IsT0FBTzZQLFNBQXZCLEVBQWtDaDBCLElBQUlta0IsS0FBSzlqQixNQUEzQyxFQUFtREwsS0FBSyxDQUF4RCxFQUEyRDtBQUN2RCxnQkFBSWtQLE9BQU9pVixLQUFLbmtCLENBQUwsQ0FBWDtBQUNBLGdCQUFJLENBQUNnekIsd0JBQXdCOWpCLElBQXhCLEVBQThCc2xCLFdBQTlCLENBQUwsRUFBaUQ7QUFDN0MsdUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNELFFBQUlELGdCQUFnQnZ2QixJQUFoQixLQUF5QixjQUE3QixFQUE2QztBQUN6QyxZQUFJeXZCLGVBQWV0QixnQkFBZ0JvQixnQkFBZ0I3bEIsV0FBaEMsRUFBNkMya0IsUUFBN0MsRUFBdURoRixTQUF2RCxDQUFuQjtBQUNBLFlBQUl3RyxjQUFjZixhQUFhdkgsSUFBSWdDLFFBQUosRUFBYixFQUE2QndGLFFBQTdCLEVBQXVDVixRQUF2QyxFQUFpRGhGLFNBQWpELENBQWxCO0FBQ0EsWUFBSSxDQUFDb0MsYUFBYXNELFFBQWIsRUFBdUJWLFFBQXZCLENBQUwsRUFBdUM7QUFDbkMsbUJBQU8sS0FBUDtBQUNIO0FBQ0QsYUFBSyxJQUFJdFAsTUFBTSxDQUFWLEVBQWF5SixTQUFTcUgsV0FBM0IsRUFBd0M5USxNQUFNeUosT0FBT250QixNQUFyRCxFQUE2RDBqQixPQUFPLENBQXBFLEVBQXVFO0FBQ25FLGdCQUFJb1EsU0FBUzNHLE9BQU96SixHQUFQLENBQWI7QUFDQSxnQkFBSSxDQUFDa1AseUJBQXlCa0IsTUFBekIsRUFBaUNNLFlBQWpDLENBQUwsRUFBcUQ7QUFDakQsdUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNELFdBQU8sSUFBUDtBQUNIO0FBQ0QsSUFBSUssU0FBUyxTQUFTQSxNQUFULENBQWdCam5CLE9BQWhCLEVBQXlCa25CLFVBQXpCLEVBQXFDO0FBQzlDLFNBQUsvdkIsSUFBTCxHQUFZMGhCLFdBQVo7QUFDQSxTQUFLN1ksT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS2tuQixVQUFMLEdBQWtCQSxVQUFsQjtBQUNILENBSkQ7QUFLQUQsT0FBT2p5QixLQUFQLEdBQWUsU0FBU0EsS0FBVCxDQUFlK29CLElBQWYsRUFBcUJDLE9BQXJCLEVBQThCO0FBQ3pDLFFBQUlELEtBQUt2ckIsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQixlQUFPd3JCLFFBQVF4bkIsS0FBUixDQUFjLHFFQUFxRXVuQixLQUFLdnJCLE1BQUwsR0FBYyxDQUFuRixJQUF3RixXQUF0RyxDQUFQO0FBQ0g7QUFDRCxRQUFJaXJCLFFBQVFNLEtBQUssQ0FBTCxDQUFSLENBQUosRUFBc0I7QUFDbEIsWUFBSS9kLFVBQVUrZCxLQUFLLENBQUwsQ0FBZDtBQUNBLFlBQUkvZCxRQUFRN0ksSUFBUixLQUFpQixtQkFBckIsRUFBMEM7QUFDdEMsaUJBQUssSUFBSWhGLElBQUksQ0FBYixFQUFnQkEsSUFBSTZOLFFBQVFwRCxRQUFSLENBQWlCcEssTUFBckMsRUFBNkMsRUFBRUwsQ0FBL0MsRUFBa0Q7QUFDOUMsb0JBQUlnRixPQUFPNkksUUFBUXBELFFBQVIsQ0FBaUJ6SyxDQUFqQixFQUFvQnV1QixRQUFwQixDQUE2QnZwQixJQUF4QztBQUNBLG9CQUFJQSxTQUFTLFNBQVQsSUFBc0JBLFNBQVMsY0FBbkMsRUFBbUQ7QUFDL0MsMkJBQU8sSUFBSTh2QixNQUFKLENBQVdqbkIsT0FBWCxFQUFvQkEsUUFBUXBELFFBQVIsQ0FBaUJ6SyxDQUFqQixFQUFvQnV1QixRQUF4QyxDQUFQO0FBQ0g7QUFDSjtBQUNKLFNBUEQsTUFPTyxJQUFJMWdCLFFBQVE3SSxJQUFSLEtBQWlCLFNBQXJCLEVBQWdDO0FBQ25DLGdCQUFJcW5CLFNBQVN4ZSxRQUFRMGdCLFFBQVIsQ0FBaUJ2cEIsSUFBOUI7QUFDQSxnQkFBSXFuQixXQUFXLFNBQVgsSUFBd0JBLFdBQVcsY0FBdkMsRUFBdUQ7QUFDbkQsdUJBQU8sSUFBSXlJLE1BQUosQ0FBV2puQixPQUFYLEVBQW9CQSxRQUFRMGdCLFFBQTVCLENBQVA7QUFDSDtBQUNKLFNBTE0sTUFLQSxJQUFJMWdCLFFBQVE3SSxJQUFSLEtBQWlCLFNBQWpCLElBQThCNkksUUFBUTdJLElBQVIsS0FBaUIsY0FBbkQsRUFBbUU7QUFDdEUsbUJBQU8sSUFBSTh2QixNQUFKLENBQVdqbkIsT0FBWCxFQUFvQkEsT0FBcEIsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPZ2UsUUFBUXhuQixLQUFSLENBQWMsMEZBQWQsQ0FBUDtBQUNILENBdkJEO0FBd0JBeXdCLE9BQU83WCxTQUFQLENBQWlCOE8sUUFBakIsR0FBNEIsU0FBU0EsUUFBVCxDQUFrQlEsR0FBbEIsRUFBdUI7QUFDL0MsUUFBSUEsSUFBSWdDLFFBQUosTUFBa0IsSUFBbEIsSUFBMEJoQyxJQUFJaUMsV0FBSixNQUFxQixJQUFuRCxFQUF5RDtBQUNyRCxZQUFJakMsSUFBSStCLFlBQUosT0FBdUIsT0FBM0IsRUFBb0M7QUFDaEMsbUJBQU9nRyxxQkFBcUIvSCxHQUFyQixFQUEwQixLQUFLd0ksVUFBL0IsQ0FBUDtBQUNILFNBRkQsTUFFTyxJQUFJeEksSUFBSStCLFlBQUosT0FBdUIsWUFBM0IsRUFBeUM7QUFDNUMsbUJBQU9zRyxvQkFBb0JySSxHQUFwQixFQUF5QixLQUFLd0ksVUFBOUIsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPLEtBQVA7QUFDSCxDQVREO0FBVUFELE9BQU83WCxTQUFQLENBQWlCK08sU0FBakIsR0FBNkIsU0FBU0EsU0FBVCxHQUFxQixDQUNqRCxDQUREO0FBRUE4SSxPQUFPN1gsU0FBUCxDQUFpQmdQLGFBQWpCLEdBQWlDLFNBQVNBLGFBQVQsR0FBeUI7QUFDdEQsV0FBTyxJQUFQO0FBQ0gsQ0FGRDtBQUdBNkksT0FBTzdYLFNBQVAsQ0FBaUJnTyxTQUFqQixHQUE2QixTQUFTQSxTQUFULEdBQXFCO0FBQzlDLFdBQU8sQ0FDSCxRQURHLEVBRUgsS0FBS3BkLE9BRkYsQ0FBUDtBQUlILENBTEQ7O0FBT0EsU0FBU21uQixpQkFBVCxDQUEyQnB3QixDQUEzQixFQUE4QjtBQUMxQixRQUFJQSxhQUFhOHBCLGtCQUFqQixFQUFxQztBQUNqQyxZQUFJOXBCLEVBQUVvSCxJQUFGLEtBQVcsS0FBWCxJQUFvQnBILEVBQUVnbkIsSUFBRixDQUFPdnJCLE1BQVAsS0FBa0IsQ0FBMUMsRUFBNkM7QUFDekMsbUJBQU8sS0FBUDtBQUNILFNBRkQsTUFFTyxJQUFJdUUsRUFBRW9ILElBQUYsS0FBVyxlQUFmLEVBQWdDO0FBQ25DLG1CQUFPLEtBQVA7QUFDSCxTQUZNLE1BRUEsSUFBSXBILEVBQUVvSCxJQUFGLEtBQVcsS0FBWCxJQUFvQnBILEVBQUVnbkIsSUFBRixDQUFPdnJCLE1BQVAsS0FBa0IsQ0FBMUMsRUFBNkM7QUFDaEQsbUJBQU8sS0FBUDtBQUNILFNBRk0sTUFFQSxJQUFJdUUsRUFBRW9ILElBQUYsS0FBVyxZQUFYLElBQTJCcEgsRUFBRW9ILElBQUYsS0FBVyxlQUF0QyxJQUF5RHBILEVBQUVvSCxJQUFGLEtBQVcsSUFBeEUsRUFBOEU7QUFDakYsbUJBQU8sS0FBUDtBQUNILFNBRk0sTUFFQSxJQUFJLFdBQVdzUSxJQUFYLENBQWdCMVgsRUFBRW9ILElBQWxCLENBQUosRUFBNkI7QUFDaEMsbUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxRQUFJcEgsYUFBYWt3QixNQUFqQixFQUF5QjtBQUNyQixlQUFPLEtBQVA7QUFDSDtBQUNELFFBQUl0ZCxTQUFTLElBQWI7QUFDQTVTLE1BQUVvbkIsU0FBRixDQUFZLFVBQVVwUCxHQUFWLEVBQWU7QUFDdkIsWUFBSXBGLFVBQVUsQ0FBQ3dkLGtCQUFrQnBZLEdBQWxCLENBQWYsRUFBdUM7QUFDbkNwRixxQkFBUyxLQUFUO0FBQ0g7QUFDSixLQUpEO0FBS0EsV0FBT0EsTUFBUDtBQUNIO0FBQ0QsU0FBU3lkLGVBQVQsQ0FBeUJyd0IsQ0FBekIsRUFBNEI7QUFDeEIsUUFBSUEsYUFBYThwQixrQkFBakIsRUFBcUM7QUFDakMsWUFBSTlwQixFQUFFb0gsSUFBRixLQUFXLGVBQWYsRUFBZ0M7QUFDNUIsbUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxRQUFJd0wsU0FBUyxJQUFiO0FBQ0E1UyxNQUFFb25CLFNBQUYsQ0FBWSxVQUFVcFAsR0FBVixFQUFlO0FBQ3ZCLFlBQUlwRixVQUFVLENBQUN5ZCxnQkFBZ0JyWSxHQUFoQixDQUFmLEVBQXFDO0FBQ2pDcEYscUJBQVMsS0FBVDtBQUNIO0FBQ0osS0FKRDtBQUtBLFdBQU9BLE1BQVA7QUFDSDtBQUNELFNBQVMwZCx3QkFBVCxDQUFrQ3R3QixDQUFsQyxFQUFxQ3VPLFVBQXJDLEVBQWlEO0FBQzdDLFFBQUl2TyxhQUFhOHBCLGtCQUFiLElBQW1DdmIsV0FBV3BTLE9BQVgsQ0FBbUI2RCxFQUFFb0gsSUFBckIsS0FBOEIsQ0FBckUsRUFBd0U7QUFDcEUsZUFBTyxLQUFQO0FBQ0g7QUFDRCxRQUFJd0wsU0FBUyxJQUFiO0FBQ0E1UyxNQUFFb25CLFNBQUYsQ0FBWSxVQUFVcFAsR0FBVixFQUFlO0FBQ3ZCLFlBQUlwRixVQUFVLENBQUMwZCx5QkFBeUJ0WSxHQUF6QixFQUE4QnpKLFVBQTlCLENBQWYsRUFBMEQ7QUFDdERxRSxxQkFBUyxLQUFUO0FBQ0g7QUFDSixLQUpEO0FBS0EsV0FBT0EsTUFBUDtBQUNIOztBQUVELElBQUkyZCxNQUFNLFNBQVNBLEdBQVQsQ0FBYW5wQixJQUFiLEVBQW1Cb3BCLGVBQW5CLEVBQW9DO0FBQzFDLFNBQUtwd0IsSUFBTCxHQUFZb3dCLGdCQUFnQnB3QixJQUE1QjtBQUNBLFNBQUtnSCxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLb3BCLGVBQUwsR0FBdUJBLGVBQXZCO0FBQ0gsQ0FKRDtBQUtBRCxJQUFJdHlCLEtBQUosR0FBWSxTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDdEMsUUFBSUQsS0FBS3ZyQixNQUFMLEtBQWdCLENBQWhCLElBQXFCLE9BQU91ckIsS0FBSyxDQUFMLENBQVAsS0FBbUIsUUFBNUMsRUFBc0Q7QUFDbEQsZUFBT0MsUUFBUXhuQixLQUFSLENBQWMsa0VBQWQsQ0FBUDtBQUNIO0FBQ0QsUUFBSTJILE9BQU80ZixLQUFLLENBQUwsQ0FBWDtBQUNBLFFBQUksQ0FBQ0MsUUFBUXlELEtBQVIsQ0FBYzFkLEdBQWQsQ0FBa0I1RixJQUFsQixDQUFMLEVBQThCO0FBQzFCLGVBQU82ZixRQUFReG5CLEtBQVIsQ0FBYyx1QkFBdUIySCxJQUF2QixHQUE4QixnQkFBOUIsR0FBaURBLElBQWpELEdBQXdELG9FQUF0RSxFQUE0SSxDQUE1SSxDQUFQO0FBQ0g7QUFDRCxXQUFPLElBQUltcEIsR0FBSixDQUFRbnBCLElBQVIsRUFBYzZmLFFBQVF5RCxLQUFSLENBQWM3akIsR0FBZCxDQUFrQk8sSUFBbEIsQ0FBZCxDQUFQO0FBQ0gsQ0FURDtBQVVBbXBCLElBQUlsWSxTQUFKLENBQWM4TyxRQUFkLEdBQXlCLFNBQVNBLFFBQVQsQ0FBa0JRLEdBQWxCLEVBQXVCO0FBQzVDLFdBQU8sS0FBSzZJLGVBQUwsQ0FBcUJySixRQUFyQixDQUE4QlEsR0FBOUIsQ0FBUDtBQUNILENBRkQ7QUFHQTRJLElBQUlsWSxTQUFKLENBQWMrTyxTQUFkLEdBQTBCLFNBQVNBLFNBQVQsR0FBcUIsQ0FDOUMsQ0FERDtBQUVBbUosSUFBSWxZLFNBQUosQ0FBY2dQLGFBQWQsR0FBOEIsU0FBU0EsYUFBVCxHQUF5QjtBQUNuRCxXQUFPLEtBQVA7QUFDSCxDQUZEO0FBR0FrSixJQUFJbFksU0FBSixDQUFjZ08sU0FBZCxHQUEwQixTQUFTQSxTQUFULEdBQXFCO0FBQzNDLFdBQU8sQ0FDSCxLQURHLEVBRUgsS0FBS2pmLElBRkYsQ0FBUDtBQUlILENBTEQ7O0FBT0EsSUFBSW9qQixpQkFBaUIsU0FBU0EsY0FBVCxDQUF3QkMsUUFBeEIsRUFBa0NwdEIsSUFBbEMsRUFBd0M2cEIsWUFBeEMsRUFBc0R3RCxLQUF0RCxFQUE2RGpXLE1BQTdELEVBQXFFO0FBQ3RGLFFBQUlwWCxTQUFTLEtBQUssQ0FBbEIsRUFDSUEsT0FBTyxFQUFQO0FBQ0osUUFBSXF0QixVQUFVLEtBQUssQ0FBbkIsRUFDSUEsUUFBUSxJQUFJbkosS0FBSixFQUFSO0FBQ0osUUFBSTlNLFdBQVcsS0FBSyxDQUFwQixFQUNJQSxTQUFTLEVBQVQ7QUFDSixTQUFLZ1csUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxTQUFLcHRCLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtvSCxHQUFMLEdBQVdwSCxLQUFLdkIsR0FBTCxDQUFTLFVBQVVnaEIsSUFBVixFQUFnQjtBQUNoQyxlQUFPLE1BQU1BLElBQU4sR0FBYSxHQUFwQjtBQUNILEtBRlUsRUFFUnRXLElBRlEsQ0FFSCxFQUZHLENBQVg7QUFHQSxTQUFLa2tCLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUtqVyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLeVMsWUFBTCxHQUFvQkEsWUFBcEI7QUFDSCxDQWZEO0FBZ0JBc0QsZUFBZW5TLFNBQWYsQ0FBeUJwYSxLQUF6QixHQUFpQyxTQUFTQSxLQUFULENBQWV3eUIsSUFBZixFQUFxQnplLEtBQXJCLEVBQTRCa1YsWUFBNUIsRUFBMEN6RixRQUExQyxFQUFvRG5RLE9BQXBELEVBQTZEO0FBQzFGLFFBQUlBLFlBQVksS0FBSyxDQUFyQixFQUNJQSxVQUFVLEVBQVY7QUFDSixRQUFJVSxLQUFKLEVBQVc7QUFDUCxlQUFPLEtBQUtyQyxNQUFMLENBQVlxQyxLQUFaLEVBQW1Ca1YsWUFBbkIsRUFBaUN6RixRQUFqQyxFQUEyQ2lQLE1BQTNDLENBQWtERCxJQUFsRCxFQUF3RG5mLE9BQXhELENBQVA7QUFDSDtBQUNELFdBQU8sS0FBS29mLE1BQUwsQ0FBWUQsSUFBWixFQUFrQm5mLE9BQWxCLENBQVA7QUFDSCxDQVBEO0FBUUFrWixlQUFlblMsU0FBZixDQUF5QnFZLE1BQXpCLEdBQWtDLFNBQVNBLE1BQVQsQ0FBZ0JELElBQWhCLEVBQXNCbmYsT0FBdEIsRUFBK0I7QUFDN0QsUUFBSW1mLFNBQVMsSUFBVCxJQUFpQixPQUFPQSxJQUFQLEtBQWdCLFFBQWpDLElBQTZDLE9BQU9BLElBQVAsS0FBZ0IsU0FBN0QsSUFBMEUsT0FBT0EsSUFBUCxLQUFnQixRQUE5RixFQUF3RztBQUNwR0EsZUFBTyxDQUNILFNBREcsRUFFSEEsSUFGRyxDQUFQO0FBSUg7QUFDRCxhQUFTRSxRQUFULENBQWtCakosTUFBbEIsRUFBMEJ0bkIsSUFBMUIsRUFBZ0N3d0IsY0FBaEMsRUFBZ0Q7QUFDNUMsWUFBSUEsbUJBQW1CLFFBQXZCLEVBQWlDO0FBQzdCLG1CQUFPLElBQUlwSixTQUFKLENBQWNwbkIsSUFBZCxFQUFvQixDQUFDc25CLE1BQUQsQ0FBcEIsQ0FBUDtBQUNILFNBRkQsTUFFTyxJQUFJa0osbUJBQW1CLFFBQXZCLEVBQWlDO0FBQ3BDLG1CQUFPLElBQUlwSSxRQUFKLENBQWFwb0IsSUFBYixFQUFtQixDQUFDc25CLE1BQUQsQ0FBbkIsQ0FBUDtBQUNILFNBRk0sTUFFQTtBQUNILG1CQUFPQSxNQUFQO0FBQ0g7QUFDSjtBQUNELFFBQUlwc0IsTUFBTUMsT0FBTixDQUFjazFCLElBQWQsQ0FBSixFQUF5QjtBQUNyQixZQUFJQSxLQUFLaDFCLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsbUJBQU8sS0FBS2dFLEtBQUwsQ0FBVyxrR0FBWCxDQUFQO0FBQ0g7QUFDRCxZQUFJdWtCLEtBQUt5TSxLQUFLLENBQUwsQ0FBVDtBQUNBLFlBQUksT0FBT3pNLEVBQVAsS0FBYyxRQUFsQixFQUE0QjtBQUN4QixpQkFBS3ZrQixLQUFMLENBQVcseURBQXdEdWtCLEVBQXhELHlDQUF3REEsRUFBeEQsS0FBNkQsa0VBQXhFLEVBQTRJLENBQTVJO0FBQ0EsbUJBQU8sSUFBUDtBQUNIO0FBQ0QsWUFBSTZNLE9BQU8sS0FBS3BHLFFBQUwsQ0FBY3pHLEVBQWQsQ0FBWDtBQUNBLFlBQUk2TSxJQUFKLEVBQVU7QUFDTixnQkFBSW5KLFNBQVNtSixLQUFLNXlCLEtBQUwsQ0FBV3d5QixJQUFYLEVBQWlCLElBQWpCLENBQWI7QUFDQSxnQkFBSSxDQUFDL0ksTUFBTCxFQUFhO0FBQ1QsdUJBQU8sSUFBUDtBQUNIO0FBQ0QsZ0JBQUksS0FBS1IsWUFBVCxFQUF1QjtBQUNuQixvQkFBSXhFLFdBQVcsS0FBS3dFLFlBQXBCO0FBQ0Esb0JBQUk0SixTQUFTcEosT0FBT3RuQixJQUFwQjtBQUNBLG9CQUFJLENBQUNzaUIsU0FBU2YsSUFBVCxLQUFrQixRQUFsQixJQUE4QmUsU0FBU2YsSUFBVCxLQUFrQixRQUFoRCxJQUE0RGUsU0FBU2YsSUFBVCxLQUFrQixTQUE5RSxJQUEyRmUsU0FBU2YsSUFBVCxLQUFrQixRQUE3RyxJQUF5SGUsU0FBU2YsSUFBVCxLQUFrQixPQUE1SSxLQUF3Sm1QLE9BQU9uUCxJQUFQLEtBQWdCLE9BQTVLLEVBQXFMO0FBQ2pMK0YsNkJBQVNpSixTQUFTakosTUFBVCxFQUFpQmhGLFFBQWpCLEVBQTJCcFIsUUFBUXNmLGNBQVIsSUFBMEIsUUFBckQsQ0FBVDtBQUNILGlCQUZELE1BRU8sSUFBSSxDQUFDbE8sU0FBU2YsSUFBVCxLQUFrQixPQUFsQixJQUE2QmUsU0FBU2YsSUFBVCxLQUFrQixXQUEvQyxJQUE4RGUsU0FBU2YsSUFBVCxLQUFrQixlQUFqRixNQUFzR21QLE9BQU9uUCxJQUFQLEtBQWdCLE9BQWhCLElBQTJCbVAsT0FBT25QLElBQVAsS0FBZ0IsUUFBakosQ0FBSixFQUFnSztBQUNuSytGLDZCQUFTaUosU0FBU2pKLE1BQVQsRUFBaUJoRixRQUFqQixFQUEyQnBSLFFBQVFzZixjQUFSLElBQTBCLFFBQXJELENBQVQ7QUFDSCxpQkFGTSxNQUVBLElBQUksS0FBS25PLFlBQUwsQ0FBa0JDLFFBQWxCLEVBQTRCb08sTUFBNUIsQ0FBSixFQUF5QztBQUM1QywyQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELGdCQUFJLEVBQUVwSixrQkFBa0JYLE9BQXBCLEtBQWdDVyxPQUFPdG5CLElBQVAsQ0FBWXVoQixJQUFaLEtBQXFCLGVBQXJELElBQXdFb1AsV0FBV3JKLE1BQVgsQ0FBNUUsRUFBZ0c7QUFDNUYsb0JBQUlzSixLQUFLLElBQUk3SCxpQkFBSixFQUFUO0FBQ0Esb0JBQUk7QUFDQXpCLDZCQUFTLElBQUlYLE9BQUosQ0FBWVcsT0FBT3RuQixJQUFuQixFQUF5QnNuQixPQUFPUCxRQUFQLENBQWdCNkosRUFBaEIsQ0FBekIsQ0FBVDtBQUNILGlCQUZELENBRUUsT0FBT2h4QixDQUFQLEVBQVU7QUFDUix5QkFBS1AsS0FBTCxDQUFXTyxFQUFFbWhCLE9BQWI7QUFDQSwyQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELG1CQUFPdUcsTUFBUDtBQUNIO0FBQ0QsZUFBTyxLQUFLam9CLEtBQUwsQ0FBVyx5QkFBeUJ1a0IsRUFBekIsR0FBOEIsMkRBQXpDLEVBQXNHLENBQXRHLENBQVA7QUFDSCxLQXRDRCxNQXNDTyxJQUFJLE9BQU95TSxJQUFQLEtBQWdCLFdBQXBCLEVBQWlDO0FBQ3BDLGVBQU8sS0FBS2h4QixLQUFMLENBQVcsZ0RBQVgsQ0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJLFFBQU9neEIsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUFwQixFQUE4QjtBQUNqQyxlQUFPLEtBQUtoeEIsS0FBTCxDQUFXLHVEQUFYLENBQVA7QUFDSCxLQUZNLE1BRUE7QUFDSCxlQUFPLEtBQUtBLEtBQUwsQ0FBVywwQ0FBeUNneEIsSUFBekMseUNBQXlDQSxJQUF6QyxLQUFnRCxXQUEzRCxDQUFQO0FBQ0g7QUFDSixDQTdERDtBQThEQWpHLGVBQWVuUyxTQUFmLENBQXlCMUksTUFBekIsR0FBa0MsU0FBU0EsTUFBVCxDQUFnQnFDLEtBQWhCLEVBQXVCa1YsWUFBdkIsRUFBcUN6RixRQUFyQyxFQUErQztBQUM3RSxRQUFJcGtCLE9BQU8sT0FBTzJVLEtBQVAsS0FBaUIsUUFBakIsR0FBNEIsS0FBSzNVLElBQUwsQ0FBVXNTLE1BQVYsQ0FBaUJxQyxLQUFqQixDQUE1QixHQUFzRCxLQUFLM1UsSUFBdEU7QUFDQSxRQUFJcXRCLFFBQVFqSixXQUFXLEtBQUtpSixLQUFMLENBQVcvYSxNQUFYLENBQWtCOFIsUUFBbEIsQ0FBWCxHQUF5QyxLQUFLaUosS0FBMUQ7QUFDQSxXQUFPLElBQUlGLGNBQUosQ0FBbUIsS0FBS0MsUUFBeEIsRUFBa0NwdEIsSUFBbEMsRUFBd0M2cEIsZ0JBQWdCLElBQXhELEVBQThEd0QsS0FBOUQsRUFBcUUsS0FBS2pXLE1BQTFFLENBQVA7QUFDSCxDQUpEO0FBS0ErVixlQUFlblMsU0FBZixDQUF5QjVZLEtBQXpCLEdBQWlDLFNBQVNBLEtBQVQsQ0FBZXd4QixPQUFmLEVBQXdCO0FBQ3JELFFBQUk5ZSxPQUFPLEVBQVg7QUFBQSxRQUFleUcsTUFBTXFJLFVBQVV4bEIsTUFBVixHQUFtQixDQUF4QztBQUNBLFdBQU9tZCxRQUFRLENBQWY7QUFDSXpHLGFBQUt5RyxHQUFMLElBQVlxSSxVQUFVckksTUFBTSxDQUFoQixDQUFaO0FBREosS0FFQSxJQUFJblUsTUFBTSxLQUFLLEtBQUtBLEdBQVYsR0FBZ0IwTixLQUFLclcsR0FBTCxDQUFTLFVBQVVvYSxDQUFWLEVBQWE7QUFDNUMsZUFBTyxNQUFNQSxDQUFOLEdBQVUsR0FBakI7QUFDSCxLQUZ5QixFQUV2QjFQLElBRnVCLENBRWxCLEVBRmtCLENBQTFCO0FBR0EsU0FBS2lPLE1BQUwsQ0FBWXJZLElBQVosQ0FBaUIsSUFBSThrQixZQUFKLENBQWlCemMsR0FBakIsRUFBc0J3c0IsT0FBdEIsQ0FBakI7QUFDSCxDQVJEO0FBU0F6RyxlQUFlblMsU0FBZixDQUF5Qm9LLFlBQXpCLEdBQXdDLFNBQVN5TyxjQUFULENBQXdCeE8sUUFBeEIsRUFBa0M3TCxDQUFsQyxFQUFxQztBQUN6RSxRQUFJcFgsUUFBUWdqQixhQUFhQyxRQUFiLEVBQXVCN0wsQ0FBdkIsQ0FBWjtBQUNBLFFBQUlwWCxLQUFKLEVBQVc7QUFDUCxhQUFLQSxLQUFMLENBQVdBLEtBQVg7QUFDSDtBQUNELFdBQU9BLEtBQVA7QUFDSCxDQU5EO0FBT0EsU0FBU3N4QixVQUFULENBQW9CaG1CLFVBQXBCLEVBQWdDO0FBQzVCLFFBQUlBLHNCQUFzQndsQixHQUExQixFQUErQjtBQUMzQixlQUFPUSxXQUFXaG1CLFdBQVd5bEIsZUFBdEIsQ0FBUDtBQUNILEtBRkQsTUFFTyxJQUFJemxCLHNCQUFzQitlLGtCQUF0QixJQUE0Qy9lLFdBQVczRCxJQUFYLEtBQW9CLE9BQXBFLEVBQTZFO0FBQ2hGLGVBQU8sS0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJMkQsc0JBQXNCcWdCLGtCQUExQixFQUE4QztBQUNqRCxlQUFPLEtBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSXJnQixzQkFBc0JtbEIsTUFBMUIsRUFBa0M7QUFDckMsZUFBTyxLQUFQO0FBQ0g7QUFDRCxRQUFJaUIsbUJBQW1CcG1CLHNCQUFzQnlkLFFBQXRCLElBQWtDemQsc0JBQXNCeWMsU0FBL0U7QUFDQSxRQUFJNEosbUJBQW1CLElBQXZCO0FBQ0FybUIsZUFBV3FjLFNBQVgsQ0FBcUIsVUFBVTZCLEtBQVYsRUFBaUI7QUFDbEMsWUFBSWtJLGdCQUFKLEVBQXNCO0FBQ2xCQywrQkFBbUJBLG9CQUFvQkwsV0FBVzlILEtBQVgsQ0FBdkM7QUFDSCxTQUZELE1BRU87QUFDSG1JLCtCQUFtQkEsb0JBQW9CbkksaUJBQWlCbEMsT0FBeEQ7QUFDSDtBQUNKLEtBTkQ7QUFPQSxRQUFJLENBQUNxSyxnQkFBTCxFQUF1QjtBQUNuQixlQUFPLEtBQVA7QUFDSDtBQUNELFdBQU9oQixrQkFBa0JybEIsVUFBbEIsS0FBaUN1bEIseUJBQXlCdmxCLFVBQXpCLEVBQXFDLENBQ3pFLE1BRHlFLEVBRXpFLGlCQUZ5RSxFQUd6RSxlQUh5RSxFQUl6RSxhQUp5RSxFQUt6RSxxQkFMeUUsQ0FBckMsQ0FBeEM7QUFPSDs7QUFFRCxTQUFTc21CLHlCQUFULENBQW1DNzFCLEtBQW5DLEVBQTBDNGEsS0FBMUMsRUFBaUQ7QUFDN0MsUUFBSWtiLFlBQVk5MUIsTUFBTUMsTUFBTixHQUFlLENBQS9CO0FBQ0EsUUFBSTgxQixhQUFhLENBQWpCO0FBQ0EsUUFBSUMsYUFBYUYsU0FBakI7QUFDQSxRQUFJRyxlQUFlLENBQW5CO0FBQ0EsUUFBSW5hLFlBQUosRUFBa0JvYSxTQUFsQjtBQUNBLFdBQU9ILGNBQWNDLFVBQXJCLEVBQWlDO0FBQzdCQyx1QkFBZTljLEtBQUtwRixLQUFMLENBQVcsQ0FBQ2dpQixhQUFhQyxVQUFkLElBQTRCLENBQXZDLENBQWY7QUFDQWxhLHVCQUFlOWIsTUFBTWkyQixZQUFOLENBQWY7QUFDQUMsb0JBQVlsMkIsTUFBTWkyQixlQUFlLENBQXJCLENBQVo7QUFDQSxZQUFJbmEsZ0JBQWdCbEIsS0FBcEIsRUFBMkI7QUFDdkIsZ0JBQUlxYixpQkFBaUJILFNBQWpCLElBQThCbGIsUUFBUXNiLFNBQTFDLEVBQXFEO0FBQ2pELHVCQUFPRCxZQUFQO0FBQ0g7QUFDREYseUJBQWFFLGVBQWUsQ0FBNUI7QUFDSCxTQUxELE1BS08sSUFBSW5hLGVBQWVsQixLQUFuQixFQUEwQjtBQUM3Qm9iLHlCQUFhQyxlQUFlLENBQTVCO0FBQ0gsU0FGTSxNQUVBO0FBQ0gsa0JBQU0sSUFBSW5LLFlBQUosQ0FBaUIsd0JBQWpCLENBQU47QUFDSDtBQUNKO0FBQ0QsV0FBTyxDQUFQO0FBQ0g7O0FBRUQsSUFBSXFLLE9BQU8sU0FBU0EsSUFBVCxDQUFjdnhCLElBQWQsRUFBb0JnVyxLQUFwQixFQUEyQjVhLEtBQTNCLEVBQWtDO0FBQ3pDLFNBQUs0RSxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLZ1csS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS25CLE1BQUwsR0FBYyxFQUFkO0FBQ0EsU0FBSzJjLE9BQUwsR0FBZSxFQUFmO0FBQ0EsU0FBSyxJQUFJeDJCLElBQUksQ0FBUixFQUFXbWtCLE9BQU8vakIsS0FBdkIsRUFBOEJKLElBQUlta0IsS0FBSzlqQixNQUF2QyxFQUErQ0wsS0FBSyxDQUFwRCxFQUF1RDtBQUNuRCxZQUFJa0csTUFBTWllLEtBQUtua0IsQ0FBTCxDQUFWO0FBQ0EsWUFBSXkyQixRQUFRdndCLElBQUksQ0FBSixDQUFaO0FBQ0EsWUFBSXlKLGFBQWF6SixJQUFJLENBQUosQ0FBakI7QUFDQSxhQUFLMlQsTUFBTCxDQUFZN1ksSUFBWixDQUFpQnkxQixLQUFqQjtBQUNBLGFBQUtELE9BQUwsQ0FBYXgxQixJQUFiLENBQWtCMk8sVUFBbEI7QUFDSDtBQUNKLENBWkQ7QUFhQTRtQixLQUFLMXpCLEtBQUwsR0FBYSxTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDdkMsUUFBSUQsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBZCxHQUFrQixDQUF0QixFQUF5QjtBQUNyQixlQUFPd3JCLFFBQVF4bkIsS0FBUixDQUFjLG9EQUFvRHVuQixLQUFLdnJCLE1BQUwsR0FBYyxDQUFsRSxJQUF1RSxHQUFyRixDQUFQO0FBQ0g7QUFDRCxRQUFJLENBQUN1ckIsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBZixJQUFvQixDQUFwQixLQUEwQixDQUE5QixFQUFpQztBQUM3QixlQUFPd3JCLFFBQVF4bkIsS0FBUixDQUFjLHVDQUFkLENBQVA7QUFDSDtBQUNELFFBQUkyVyxRQUFRNlEsUUFBUWhwQixLQUFSLENBQWMrb0IsS0FBSyxDQUFMLENBQWQsRUFBdUIsQ0FBdkIsRUFBMEJwRixVQUExQixDQUFaO0FBQ0EsUUFBSSxDQUFDeEwsS0FBTCxFQUFZO0FBQ1IsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJNWEsUUFBUSxFQUFaO0FBQ0EsUUFBSXMyQixhQUFhLElBQWpCO0FBQ0EsUUFBSTdLLFFBQVFDLFlBQVIsSUFBd0JELFFBQVFDLFlBQVIsQ0FBcUJ2RixJQUFyQixLQUE4QixPQUExRCxFQUFtRTtBQUMvRG1RLHFCQUFhN0ssUUFBUUMsWUFBckI7QUFDSDtBQUNELFNBQUssSUFBSTlyQixJQUFJLENBQWIsRUFBZ0JBLElBQUk0ckIsS0FBS3ZyQixNQUF6QixFQUFpQ0wsS0FBSyxDQUF0QyxFQUF5QztBQUNyQyxZQUFJeTJCLFFBQVF6MkIsTUFBTSxDQUFOLEdBQVUsQ0FBQ3NXLFFBQVgsR0FBc0JzVixLQUFLNXJCLENBQUwsQ0FBbEM7QUFDQSxZQUFJa00sUUFBUTBmLEtBQUs1ckIsSUFBSSxDQUFULENBQVo7QUFDQSxZQUFJMjJCLFdBQVczMkIsQ0FBZjtBQUNBLFlBQUk0MkIsV0FBVzUyQixJQUFJLENBQW5CO0FBQ0EsWUFBSSxPQUFPeTJCLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0IsbUJBQU81SyxRQUFReG5CLEtBQVIsQ0FBYyx5SUFBZCxFQUF5SnN5QixRQUF6SixDQUFQO0FBQ0g7QUFDRCxZQUFJdjJCLE1BQU1DLE1BQU4sSUFBZ0JELE1BQU1BLE1BQU1DLE1BQU4sR0FBZSxDQUFyQixFQUF3QixDQUF4QixLQUE4Qm8yQixLQUFsRCxFQUF5RDtBQUNyRCxtQkFBTzVLLFFBQVF4bkIsS0FBUixDQUFjLDJHQUFkLEVBQTJIc3lCLFFBQTNILENBQVA7QUFDSDtBQUNELFlBQUlySyxTQUFTVCxRQUFRaHBCLEtBQVIsQ0FBY3FKLEtBQWQsRUFBcUIwcUIsUUFBckIsRUFBK0JGLFVBQS9CLENBQWI7QUFDQSxZQUFJLENBQUNwSyxNQUFMLEVBQWE7QUFDVCxtQkFBTyxJQUFQO0FBQ0g7QUFDRG9LLHFCQUFhQSxjQUFjcEssT0FBT3RuQixJQUFsQztBQUNBNUUsY0FBTVksSUFBTixDQUFXLENBQ1B5MUIsS0FETyxFQUVQbkssTUFGTyxDQUFYO0FBSUg7QUFDRCxXQUFPLElBQUlpSyxJQUFKLENBQVNHLFVBQVQsRUFBcUIxYixLQUFyQixFQUE0QjVhLEtBQTVCLENBQVA7QUFDSCxDQXRDRDtBQXVDQW0yQixLQUFLdFosU0FBTCxDQUFlOE8sUUFBZixHQUEwQixTQUFTQSxRQUFULENBQWtCUSxHQUFsQixFQUF1QjtBQUM3QyxRQUFJMVMsU0FBUyxLQUFLQSxNQUFsQjtBQUNBLFFBQUkyYyxVQUFVLEtBQUtBLE9BQW5CO0FBQ0EsUUFBSTNjLE9BQU94WixNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLGVBQU9tMkIsUUFBUSxDQUFSLEVBQVd6SyxRQUFYLENBQW9CUSxHQUFwQixDQUFQO0FBQ0g7QUFDRCxRQUFJcmdCLFFBQVEsS0FBSzhPLEtBQUwsQ0FBVytRLFFBQVgsQ0FBb0JRLEdBQXBCLENBQVo7QUFDQSxRQUFJcmdCLFNBQVMyTixPQUFPLENBQVAsQ0FBYixFQUF3QjtBQUNwQixlQUFPMmMsUUFBUSxDQUFSLEVBQVd6SyxRQUFYLENBQW9CUSxHQUFwQixDQUFQO0FBQ0g7QUFDRCxRQUFJc0ssWUFBWWhkLE9BQU94WixNQUF2QjtBQUNBLFFBQUk2TCxTQUFTMk4sT0FBT2dkLFlBQVksQ0FBbkIsQ0FBYixFQUFvQztBQUNoQyxlQUFPTCxRQUFRSyxZQUFZLENBQXBCLEVBQXVCOUssUUFBdkIsQ0FBZ0NRLEdBQWhDLENBQVA7QUFDSDtBQUNELFFBQUkzVixRQUFRcWYsMEJBQTBCcGMsTUFBMUIsRUFBa0MzTixLQUFsQyxDQUFaO0FBQ0EsV0FBT3NxQixRQUFRNWYsS0FBUixFQUFlbVYsUUFBZixDQUF3QlEsR0FBeEIsQ0FBUDtBQUNILENBaEJEO0FBaUJBZ0ssS0FBS3RaLFNBQUwsQ0FBZStPLFNBQWYsR0FBMkIsU0FBU0EsU0FBVCxDQUFtQi9ULEVBQW5CLEVBQXVCO0FBQzlDQSxPQUFHLEtBQUsrQyxLQUFSO0FBQ0EsU0FBSyxJQUFJaGIsSUFBSSxDQUFSLEVBQVdta0IsT0FBTyxLQUFLcVMsT0FBNUIsRUFBcUN4MkIsSUFBSW1rQixLQUFLOWpCLE1BQTlDLEVBQXNETCxLQUFLLENBQTNELEVBQThEO0FBQzFELFlBQUkyUCxhQUFhd1UsS0FBS25rQixDQUFMLENBQWpCO0FBQ0FpWSxXQUFHdEksVUFBSDtBQUNIO0FBQ0osQ0FORDtBQU9BNG1CLEtBQUt0WixTQUFMLENBQWVnUCxhQUFmLEdBQStCLFNBQVNBLGFBQVQsR0FBeUI7QUFDcEQsV0FBTyxLQUFLdUssT0FBTCxDQUFhaEssS0FBYixDQUFtQixVQUFVdFIsR0FBVixFQUFlO0FBQ3JDLGVBQU9BLElBQUkrUSxhQUFKLEVBQVA7QUFDSCxLQUZNLENBQVA7QUFHSCxDQUpEO0FBS0FzSyxLQUFLdFosU0FBTCxDQUFlZ08sU0FBZixHQUEyQixTQUFTQSxTQUFULEdBQXFCO0FBQzVDLFFBQUlDLGFBQWEsQ0FDYixNQURhLEVBRWIsS0FBS2xRLEtBQUwsQ0FBV2lRLFNBQVgsRUFGYSxDQUFqQjtBQUlBLFNBQUssSUFBSWpyQixJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBSzZaLE1BQUwsQ0FBWXhaLE1BQWhDLEVBQXdDTCxHQUF4QyxFQUE2QztBQUN6QyxZQUFJQSxJQUFJLENBQVIsRUFBVztBQUNQa3JCLHVCQUFXbHFCLElBQVgsQ0FBZ0IsS0FBSzZZLE1BQUwsQ0FBWTdaLENBQVosQ0FBaEI7QUFDSDtBQUNEa3JCLG1CQUFXbHFCLElBQVgsQ0FBZ0IsS0FBS3cxQixPQUFMLENBQWF4MkIsQ0FBYixFQUFnQmlyQixTQUFoQixFQUFoQjtBQUNIO0FBQ0QsV0FBT0MsVUFBUDtBQUNILENBWkQ7O0FBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkEsSUFBSTRMLGFBQWFDLFVBQWpCOztBQUVBLFNBQVNBLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCQyxHQUF6QixFQUE4QkMsR0FBOUIsRUFBbUNDLEdBQW5DLEVBQXdDO0FBQ3BDO0FBQ0EsU0FBS0MsRUFBTCxHQUFVLE1BQU1KLEdBQWhCO0FBQ0EsU0FBS0ssRUFBTCxHQUFVLE9BQU9ILE1BQU1GLEdBQWIsSUFBb0IsS0FBS0ksRUFBbkM7QUFDQSxTQUFLRSxFQUFMLEdBQVUsTUFBTSxLQUFLRixFQUFYLEdBQWdCLEtBQUtDLEVBQS9COztBQUVBLFNBQUtFLEVBQUwsR0FBVSxNQUFNTixHQUFoQjtBQUNBLFNBQUtPLEVBQUwsR0FBVSxPQUFPTCxNQUFNRixHQUFiLElBQW9CLEtBQUtNLEVBQW5DO0FBQ0EsU0FBS0UsRUFBTCxHQUFVLE1BQU0sS0FBS0YsRUFBWCxHQUFnQixLQUFLQyxFQUEvQjs7QUFFQSxTQUFLUixHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLQyxHQUFMLEdBQVdFLEdBQVg7QUFDQSxTQUFLRCxHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLQyxHQUFMLEdBQVdBLEdBQVg7QUFDSDs7QUFFREosV0FBVzlaLFNBQVgsQ0FBcUJ5YSxZQUFyQixHQUFvQyxVQUFTamMsQ0FBVCxFQUFZO0FBQzVDO0FBQ0EsV0FBTyxDQUFDLENBQUMsS0FBSzZiLEVBQUwsR0FBVTdiLENBQVYsR0FBYyxLQUFLNGIsRUFBcEIsSUFBMEI1YixDQUExQixHQUE4QixLQUFLMmIsRUFBcEMsSUFBMEMzYixDQUFqRDtBQUNILENBSEQ7O0FBS0FzYixXQUFXOVosU0FBWCxDQUFxQjBhLFlBQXJCLEdBQW9DLFVBQVNsYyxDQUFULEVBQVk7QUFDNUMsV0FBTyxDQUFDLENBQUMsS0FBS2djLEVBQUwsR0FBVWhjLENBQVYsR0FBYyxLQUFLK2IsRUFBcEIsSUFBMEIvYixDQUExQixHQUE4QixLQUFLOGIsRUFBcEMsSUFBMEM5YixDQUFqRDtBQUNILENBRkQ7O0FBSUFzYixXQUFXOVosU0FBWCxDQUFxQjJhLHNCQUFyQixHQUE4QyxVQUFTbmMsQ0FBVCxFQUFZO0FBQ3RELFdBQU8sQ0FBQyxNQUFNLEtBQUs2YixFQUFYLEdBQWdCN2IsQ0FBaEIsR0FBb0IsTUFBTSxLQUFLNGIsRUFBaEMsSUFBc0M1YixDQUF0QyxHQUEwQyxLQUFLMmIsRUFBdEQ7QUFDSCxDQUZEOztBQUlBTCxXQUFXOVosU0FBWCxDQUFxQjRhLFdBQXJCLEdBQW1DLFVBQVNwYSxDQUFULEVBQVlxYSxPQUFaLEVBQXFCO0FBQ3BELFFBQUksT0FBT0EsT0FBUCxLQUFtQixXQUF2QixFQUFvQztBQUFFQSxrQkFBVSxJQUFWO0FBQWlCOztBQUV2RCxRQUFJQyxFQUFKLEVBQVFDLEVBQVIsRUFBWUMsRUFBWixFQUFnQjNHLEVBQWhCLEVBQW9CdHhCLENBQXBCOztBQUVBO0FBQ0EsU0FBS2k0QixLQUFLeGEsQ0FBTCxFQUFRemQsSUFBSSxDQUFqQixFQUFvQkEsSUFBSSxDQUF4QixFQUEyQkEsR0FBM0IsRUFBZ0M7O0FBRTVCc3hCLGFBQUssS0FBS29HLFlBQUwsQ0FBa0JPLEVBQWxCLElBQXdCeGEsQ0FBN0I7QUFDQSxZQUFJbEUsS0FBS3RGLEdBQUwsQ0FBU3FkLEVBQVQsSUFBZXdHLE9BQW5CLEVBQTRCO0FBQUUsbUJBQU9HLEVBQVA7QUFBWTs7QUFFMUMsWUFBSUMsS0FBSyxLQUFLTixzQkFBTCxDQUE0QkssRUFBNUIsQ0FBVDtBQUNBLFlBQUkxZSxLQUFLdEYsR0FBTCxDQUFTaWtCLEVBQVQsSUFBZSxJQUFuQixFQUF5QjtBQUFFO0FBQVE7O0FBRW5DRCxhQUFLQSxLQUFLM0csS0FBSzRHLEVBQWY7QUFDSDs7QUFFRDtBQUNBSCxTQUFLLEdBQUw7QUFDQUMsU0FBSyxHQUFMO0FBQ0FDLFNBQUt4YSxDQUFMOztBQUVBLFFBQUl3YSxLQUFLRixFQUFULEVBQWE7QUFBRSxlQUFPQSxFQUFQO0FBQVk7QUFDM0IsUUFBSUUsS0FBS0QsRUFBVCxFQUFhO0FBQUUsZUFBT0EsRUFBUDtBQUFZOztBQUUzQixXQUFPRCxLQUFLQyxFQUFaLEVBQWdCOztBQUVaMUcsYUFBSyxLQUFLb0csWUFBTCxDQUFrQk8sRUFBbEIsQ0FBTDtBQUNBLFlBQUkxZSxLQUFLdEYsR0FBTCxDQUFTcWQsS0FBSzdULENBQWQsSUFBbUJxYSxPQUF2QixFQUFnQztBQUFFLG1CQUFPRyxFQUFQO0FBQVk7O0FBRTlDLFlBQUl4YSxJQUFJNlQsRUFBUixFQUFZO0FBQ1J5RyxpQkFBS0UsRUFBTDtBQUNILFNBRkQsTUFFTztBQUNIRCxpQkFBS0MsRUFBTDtBQUNIOztBQUVEQSxhQUFLLENBQUNELEtBQUtELEVBQU4sSUFBWSxHQUFaLEdBQWtCQSxFQUF2QjtBQUNIOztBQUVEO0FBQ0EsV0FBT0UsRUFBUDtBQUNILENBekNEOztBQTJDQWxCLFdBQVc5WixTQUFYLENBQXFCa2IsS0FBckIsR0FBNkIsVUFBUzFhLENBQVQsRUFBWXFhLE9BQVosRUFBcUI7QUFDOUMsV0FBTyxLQUFLSCxZQUFMLENBQWtCLEtBQUtFLFdBQUwsQ0FBaUJwYSxDQUFqQixFQUFvQnFhLE9BQXBCLENBQWxCLENBQVA7QUFDSCxDQUZEOztBQUlBLFNBQVNqbEIsTUFBVCxDQUFnQjVILENBQWhCLEVBQW1Ca2UsQ0FBbkIsRUFBc0IxTixDQUF0QixFQUF5QjtBQUNyQixXQUFPeFEsS0FBSyxJQUFJd1EsQ0FBVCxJQUFjME4sSUFBSTFOLENBQXpCO0FBQ0g7QUFDRCxTQUFTaFAsS0FBVCxDQUFlcVksSUFBZixFQUFxQkMsRUFBckIsRUFBeUJ0SixDQUF6QixFQUE0QjtBQUN4QixXQUFPLElBQUloVyxLQUFKLENBQVVvTixPQUFPaVMsS0FBS2hoQixDQUFaLEVBQWVpaEIsR0FBR2poQixDQUFsQixFQUFxQjJYLENBQXJCLENBQVYsRUFBbUM1SSxPQUFPaVMsS0FBS29FLENBQVosRUFBZW5FLEdBQUdtRSxDQUFsQixFQUFxQnpOLENBQXJCLENBQW5DLEVBQTRENUksT0FBT2lTLEtBQUtxRSxDQUFaLEVBQWVwRSxHQUFHb0UsQ0FBbEIsRUFBcUIxTixDQUFyQixDQUE1RCxFQUFxRjVJLE9BQU9pUyxLQUFLN1osQ0FBWixFQUFlOFosR0FBRzlaLENBQWxCLEVBQXFCd1EsQ0FBckIsQ0FBckYsQ0FBUDtBQUNIO0FBQ0QsU0FBUzJjLE9BQVQsQ0FBaUJ0VCxJQUFqQixFQUF1QkMsRUFBdkIsRUFBMkJ0SixDQUEzQixFQUE4QjtBQUMxQixXQUFPcUosS0FBS3BrQixHQUFMLENBQVMsVUFBVWl5QixDQUFWLEVBQWEzeUIsQ0FBYixFQUFnQjtBQUM1QixlQUFPNlMsT0FBTzhmLENBQVAsRUFBVTVOLEdBQUcva0IsQ0FBSCxDQUFWLEVBQWlCeWIsQ0FBakIsQ0FBUDtBQUNILEtBRk0sQ0FBUDtBQUdIOztBQUVELElBQUloSixjQUFjLGFBQWE0RSxPQUFPZ2hCLE1BQVAsQ0FBYztBQUMzQ3JTLGVBQVcsSUFEZ0M7QUFFM0NuVCxZQUFRQSxNQUZtQztBQUczQ3BHLFdBQU9BLEtBSG9DO0FBSTNDNEYsV0FBTytsQjtBQUpvQyxDQUFkLENBQS9COztBQU9BLElBQUlFLEtBQUssT0FBVDtBQUFBLElBQWtCQyxLQUFLLENBQXZCO0FBQUEsSUFBMEJDLEtBQUssT0FBL0I7QUFBQSxJQUF3Q1QsS0FBSyxJQUFJLEVBQWpEO0FBQUEsSUFBcURDLEtBQUssSUFBSSxFQUE5RDtBQUFBLElBQWtFQyxLQUFLLElBQUlELEVBQUosR0FBU0EsRUFBaEY7QUFBQSxJQUFvRlMsS0FBS1QsS0FBS0EsRUFBTCxHQUFVQSxFQUFuRztBQUFBLElBQXVHVSxVQUFVbmYsS0FBS2dYLEVBQUwsR0FBVSxHQUEzSDtBQUFBLElBQWdJb0ksVUFBVSxNQUFNcGYsS0FBS2dYLEVBQXJKO0FBQ0EsU0FBU3FJLE9BQVQsQ0FBaUJuZCxDQUFqQixFQUFvQjtBQUNoQixXQUFPQSxJQUFJZ2QsRUFBSixHQUFTbGYsS0FBS3dYLEdBQUwsQ0FBU3RWLENBQVQsRUFBWSxJQUFJLENBQWhCLENBQVQsR0FBOEJBLElBQUl3YyxFQUFKLEdBQVNGLEVBQTlDO0FBQ0g7QUFDRCxTQUFTYyxPQUFULENBQWlCcGQsQ0FBakIsRUFBb0I7QUFDaEIsV0FBT0EsSUFBSXVjLEVBQUosR0FBU3ZjLElBQUlBLENBQUosR0FBUUEsQ0FBakIsR0FBcUJ3YyxNQUFNeGMsSUFBSXNjLEVBQVYsQ0FBNUI7QUFDSDtBQUNELFNBQVNlLE9BQVQsQ0FBaUJyYixDQUFqQixFQUFvQjtBQUNoQixXQUFPLE9BQU9BLEtBQUssU0FBTCxHQUFpQixRQUFRQSxDQUF6QixHQUE2QixRQUFRbEUsS0FBS3dYLEdBQUwsQ0FBU3RULENBQVQsRUFBWSxJQUFJLEdBQWhCLENBQVIsR0FBK0IsS0FBbkUsQ0FBUDtBQUNIO0FBQ0QsU0FBU3NiLE9BQVQsQ0FBaUJ0YixDQUFqQixFQUFvQjtBQUNoQkEsU0FBSyxHQUFMO0FBQ0EsV0FBT0EsS0FBSyxPQUFMLEdBQWVBLElBQUksS0FBbkIsR0FBMkJsRSxLQUFLd1gsR0FBTCxDQUFTLENBQUN0VCxJQUFJLEtBQUwsSUFBYyxLQUF2QixFQUE4QixHQUE5QixDQUFsQztBQUNIO0FBQ0QsU0FBU3ViLFFBQVQsQ0FBa0JDLFFBQWxCLEVBQTRCO0FBQ3hCLFFBQUk5UCxJQUFJNFAsUUFBUUUsU0FBU24xQixDQUFqQixDQUFSO0FBQUEsUUFBNkJtSCxJQUFJOHRCLFFBQVFFLFNBQVMvUCxDQUFqQixDQUFqQztBQUFBLFFBQXNEbGpCLElBQUkreUIsUUFBUUUsU0FBUzlQLENBQWpCLENBQTFEO0FBQUEsUUFBK0UxTCxJQUFJbWIsUUFBUSxDQUFDLFlBQVl6UCxDQUFaLEdBQWdCLFlBQVlsZSxDQUE1QixHQUFnQyxZQUFZakYsQ0FBN0MsSUFBa0RzeUIsRUFBMUQsQ0FBbkY7QUFBQSxRQUFrSnpILElBQUkrSCxRQUFRLENBQUMsWUFBWXpQLENBQVosR0FBZ0IsWUFBWWxlLENBQTVCLEdBQWdDLFdBQVdqRixDQUE1QyxJQUFpRHV5QixFQUF6RCxDQUF0SjtBQUFBLFFBQW9OdkgsSUFBSTRILFFBQVEsQ0FBQyxZQUFZelAsQ0FBWixHQUFnQixXQUFXbGUsQ0FBM0IsR0FBK0IsWUFBWWpGLENBQTVDLElBQWlEd3lCLEVBQXpELENBQXhOO0FBQ0EsV0FBTztBQUNIeHlCLFdBQUcsTUFBTTZxQixDQUFOLEdBQVUsRUFEVjtBQUVINWxCLFdBQUcsT0FBT3dTLElBQUlvVCxDQUFYLENBRkE7QUFHSDFILFdBQUcsT0FBTzBILElBQUlHLENBQVgsQ0FIQTtBQUlIaEksZUFBT2lRLFNBQVNodUI7QUFKYixLQUFQO0FBTUg7QUFDRCxTQUFTaXVCLFFBQVQsQ0FBa0JDLFFBQWxCLEVBQTRCO0FBQ3hCLFFBQUl0SSxJQUFJLENBQUNzSSxTQUFTbnpCLENBQVQsR0FBYSxFQUFkLElBQW9CLEdBQTVCO0FBQUEsUUFBaUN5WCxJQUFJbVEsTUFBTXVMLFNBQVNsdUIsQ0FBZixJQUFvQjRsQixDQUFwQixHQUF3QkEsSUFBSXNJLFNBQVNsdUIsQ0FBVCxHQUFhLEdBQTlFO0FBQUEsUUFBbUYrbEIsSUFBSXBELE1BQU11TCxTQUFTaFEsQ0FBZixJQUFvQjBILENBQXBCLEdBQXdCQSxJQUFJc0ksU0FBU2hRLENBQVQsR0FBYSxHQUFoSTtBQUNBMEgsUUFBSTBILEtBQUtNLFFBQVFoSSxDQUFSLENBQVQ7QUFDQXBULFFBQUk2YSxLQUFLTyxRQUFRcGIsQ0FBUixDQUFUO0FBQ0F1VCxRQUFJd0gsS0FBS0ssUUFBUTdILENBQVIsQ0FBVDtBQUNBLFdBQU8sSUFBSXZyQixLQUFKLENBQVVxekIsUUFBUSxZQUFZcmIsQ0FBWixHQUFnQixZQUFZb1QsQ0FBNUIsR0FBZ0MsWUFBWUcsQ0FBcEQsQ0FBVixFQUFrRThILFFBQVEsQ0FBQyxRQUFELEdBQVlyYixDQUFaLEdBQWdCLFlBQVlvVCxDQUE1QixHQUFnQyxXQUFXRyxDQUFuRCxDQUFsRSxFQUF5SDhILFFBQVEsWUFBWXJiLENBQVosR0FBZ0IsWUFBWW9ULENBQTVCLEdBQWdDLFlBQVlHLENBQXBELENBQXpILEVBQWlMbUksU0FBU25RLEtBQTFMLENBQVA7QUFDSDtBQUNELFNBQVNvUSxjQUFULENBQXdCdFUsSUFBeEIsRUFBOEJDLEVBQTlCLEVBQWtDdEosQ0FBbEMsRUFBcUM7QUFDakMsV0FBTztBQUNIelYsV0FBRzZNLE9BQU9pUyxLQUFLOWUsQ0FBWixFQUFlK2UsR0FBRy9lLENBQWxCLEVBQXFCeVYsQ0FBckIsQ0FEQTtBQUVIeFEsV0FBRzRILE9BQU9pUyxLQUFLN1osQ0FBWixFQUFlOFosR0FBRzlaLENBQWxCLEVBQXFCd1EsQ0FBckIsQ0FGQTtBQUdIME4sV0FBR3RXLE9BQU9pUyxLQUFLcUUsQ0FBWixFQUFlcEUsR0FBR29FLENBQWxCLEVBQXFCMU4sQ0FBckIsQ0FIQTtBQUlIdU4sZUFBT25XLE9BQU9pUyxLQUFLa0UsS0FBWixFQUFtQmpFLEdBQUdpRSxLQUF0QixFQUE2QnZOLENBQTdCO0FBSkosS0FBUDtBQU1IO0FBQ0QsU0FBUzRkLFFBQVQsQ0FBa0JKLFFBQWxCLEVBQTRCO0FBQ3hCLFFBQUkveUIsTUFBTTh5QixTQUFTQyxRQUFULENBQVY7QUFDQSxRQUFJanpCLElBQUlFLElBQUlGLENBQVo7QUFDQSxRQUFJaUYsSUFBSS9FLElBQUkrRSxDQUFaO0FBQ0EsUUFBSWtlLElBQUlqakIsSUFBSWlqQixDQUFaO0FBQ0EsUUFBSWxILElBQUkxSSxLQUFLK2YsS0FBTCxDQUFXblEsQ0FBWCxFQUFjbGUsQ0FBZCxJQUFtQjB0QixPQUEzQjtBQUNBLFdBQU87QUFDSDFXLFdBQUdBLElBQUksQ0FBSixHQUFRQSxJQUFJLEdBQVosR0FBa0JBLENBRGxCO0FBRUhxTCxXQUFHL1QsS0FBS2xHLElBQUwsQ0FBVXBJLElBQUlBLENBQUosR0FBUWtlLElBQUlBLENBQXRCLENBRkE7QUFHSG5qQixXQUFHQSxDQUhBO0FBSUhnakIsZUFBT2lRLFNBQVNodUI7QUFKYixLQUFQO0FBTUg7QUFDRCxTQUFTc3VCLFFBQVQsQ0FBa0JDLFFBQWxCLEVBQTRCO0FBQ3hCLFFBQUl2WCxJQUFJdVgsU0FBU3ZYLENBQVQsR0FBYXlXLE9BQXJCO0FBQUEsUUFBOEJwTCxJQUFJa00sU0FBU2xNLENBQTNDO0FBQUEsUUFBOEN0bkIsSUFBSXd6QixTQUFTeHpCLENBQTNEO0FBQ0EsV0FBT2t6QixTQUFTO0FBQ1psekIsV0FBR0EsQ0FEUztBQUVaaUYsV0FBR3NPLEtBQUs3RixHQUFMLENBQVN1TyxDQUFULElBQWNxTCxDQUZMO0FBR1puRSxXQUFHNVAsS0FBSzlGLEdBQUwsQ0FBU3dPLENBQVQsSUFBY3FMLENBSEw7QUFJWnRFLGVBQU93USxTQUFTeFE7QUFKSixLQUFULENBQVA7QUFNSDtBQUNELFNBQVN5USxjQUFULENBQXdCeHVCLENBQXhCLEVBQTJCa2UsQ0FBM0IsRUFBOEIxTixDQUE5QixFQUFpQztBQUM3QixRQUFJa1gsSUFBSXhKLElBQUlsZSxDQUFaO0FBQ0EsV0FBT0EsSUFBSXdRLEtBQUtrWCxJQUFJLEdBQUosSUFBV0EsSUFBSSxDQUFDLEdBQWhCLEdBQXNCQSxJQUFJLE1BQU1wWixLQUFLckosS0FBTCxDQUFXeWlCLElBQUksR0FBZixDQUFoQyxHQUFzREEsQ0FBM0QsQ0FBWDtBQUNIO0FBQ0QsU0FBUytHLGNBQVQsQ0FBd0I1VSxJQUF4QixFQUE4QkMsRUFBOUIsRUFBa0N0SixDQUFsQyxFQUFxQztBQUNqQyxXQUFPO0FBQ0h3RyxXQUFHd1gsZUFBZTNVLEtBQUs3QyxDQUFwQixFQUF1QjhDLEdBQUc5QyxDQUExQixFQUE2QnhHLENBQTdCLENBREE7QUFFSDZSLFdBQUd6YSxPQUFPaVMsS0FBS3dJLENBQVosRUFBZXZJLEdBQUd1SSxDQUFsQixFQUFxQjdSLENBQXJCLENBRkE7QUFHSHpWLFdBQUc2TSxPQUFPaVMsS0FBSzllLENBQVosRUFBZStlLEdBQUcvZSxDQUFsQixFQUFxQnlWLENBQXJCLENBSEE7QUFJSHVOLGVBQU9uVyxPQUFPaVMsS0FBS2tFLEtBQVosRUFBbUJqRSxHQUFHaUUsS0FBdEIsRUFBNkJ2TixDQUE3QjtBQUpKLEtBQVA7QUFNSDtBQUNELElBQUk5RixNQUFNO0FBQ05na0IsYUFBU1gsUUFESDtBQUVOOVQsYUFBU2dVLFFBRkg7QUFHTnptQixpQkFBYTJtQjtBQUhQLENBQVY7QUFLQSxJQUFJeGpCLE1BQU07QUFDTitqQixhQUFTTixRQURIO0FBRU5uVSxhQUFTcVUsUUFGSDtBQUdOOW1CLGlCQUFhaW5CO0FBSFAsQ0FBVjs7QUFNQSxJQUFJRSxjQUFjLGFBQWF2aUIsT0FBT2doQixNQUFQLENBQWM7QUFDM0NyUyxlQUFXLElBRGdDO0FBRTNDclEsU0FBS0EsR0FGc0M7QUFHM0NDLFNBQUtBO0FBSHNDLENBQWQsQ0FBL0I7O0FBTUEsSUFBSWlrQixjQUFjLFNBQVNBLFdBQVQsQ0FBcUI3MEIsSUFBckIsRUFBMkI4MEIsUUFBM0IsRUFBcUNDLGFBQXJDLEVBQW9EL2UsS0FBcEQsRUFBMkQ1YSxLQUEzRCxFQUFrRTtBQUNoRixTQUFLNEUsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBSzgwQixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtDLGFBQUwsR0FBcUJBLGFBQXJCO0FBQ0EsU0FBSy9lLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUtuQixNQUFMLEdBQWMsRUFBZDtBQUNBLFNBQUsyYyxPQUFMLEdBQWUsRUFBZjtBQUNBLFNBQUssSUFBSXgyQixJQUFJLENBQVIsRUFBV21rQixPQUFPL2pCLEtBQXZCLEVBQThCSixJQUFJbWtCLEtBQUs5akIsTUFBdkMsRUFBK0NMLEtBQUssQ0FBcEQsRUFBdUQ7QUFDbkQsWUFBSWtHLE1BQU1pZSxLQUFLbmtCLENBQUwsQ0FBVjtBQUNBLFlBQUl5MkIsUUFBUXZ3QixJQUFJLENBQUosQ0FBWjtBQUNBLFlBQUl5SixhQUFhekosSUFBSSxDQUFKLENBQWpCO0FBQ0EsYUFBSzJULE1BQUwsQ0FBWTdZLElBQVosQ0FBaUJ5MUIsS0FBakI7QUFDQSxhQUFLRCxPQUFMLENBQWF4MUIsSUFBYixDQUFrQjJPLFVBQWxCO0FBQ0g7QUFDSixDQWREO0FBZUFrcUIsWUFBWUcsbUJBQVosR0FBa0MsU0FBU0EsbUJBQVQsQ0FBNkJELGFBQTdCLEVBQTRDL2UsS0FBNUMsRUFBbURpZixLQUFuRCxFQUEwREMsS0FBMUQsRUFBaUU7QUFDL0YsUUFBSXplLElBQUksQ0FBUjtBQUNBLFFBQUlzZSxjQUFjL3RCLElBQWQsS0FBdUIsYUFBM0IsRUFBMEM7QUFDdEN5UCxZQUFJMGUseUJBQXlCbmYsS0FBekIsRUFBZ0MrZSxjQUFjM2tCLElBQTlDLEVBQW9ENmtCLEtBQXBELEVBQTJEQyxLQUEzRCxDQUFKO0FBQ0gsS0FGRCxNQUVPLElBQUlILGNBQWMvdEIsSUFBZCxLQUF1QixRQUEzQixFQUFxQztBQUN4Q3lQLFlBQUkwZSx5QkFBeUJuZixLQUF6QixFQUFnQyxDQUFoQyxFQUFtQ2lmLEtBQW5DLEVBQTBDQyxLQUExQyxDQUFKO0FBQ0gsS0FGTSxNQUVBLElBQUlILGNBQWMvdEIsSUFBZCxLQUF1QixjQUEzQixFQUEyQztBQUM5QyxZQUFJc2hCLElBQUl5TSxjQUFjSyxhQUF0QjtBQUNBLFlBQUlDLEtBQUssSUFBSXZELFVBQUosQ0FBZXhKLEVBQUUsQ0FBRixDQUFmLEVBQXFCQSxFQUFFLENBQUYsQ0FBckIsRUFBMkJBLEVBQUUsQ0FBRixDQUEzQixFQUFpQ0EsRUFBRSxDQUFGLENBQWpDLENBQVQ7QUFDQTdSLFlBQUk0ZSxHQUFHbEMsS0FBSCxDQUFTZ0MseUJBQXlCbmYsS0FBekIsRUFBZ0MsQ0FBaEMsRUFBbUNpZixLQUFuQyxFQUEwQ0MsS0FBMUMsQ0FBVCxDQUFKO0FBQ0g7QUFDRCxXQUFPemUsQ0FBUDtBQUNILENBWkQ7QUFhQW9lLFlBQVloM0IsS0FBWixHQUFvQixTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDOUMsUUFBSWlPLFdBQVdsTyxLQUFLLENBQUwsQ0FBZjtBQUNBLFFBQUltTyxnQkFBZ0JuTyxLQUFLLENBQUwsQ0FBcEI7QUFDQSxRQUFJNVEsUUFBUTRRLEtBQUssQ0FBTCxDQUFaO0FBQ0EsUUFBSTlLLE9BQU84SyxLQUFLemdCLEtBQUwsQ0FBVyxDQUFYLENBQVg7QUFDQSxRQUFJLENBQUNqTCxNQUFNQyxPQUFOLENBQWM0NUIsYUFBZCxDQUFELElBQWlDQSxjQUFjMTVCLE1BQWQsS0FBeUIsQ0FBOUQsRUFBaUU7QUFDN0QsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYyw0Q0FBZCxFQUE0RCxDQUE1RCxDQUFQO0FBQ0g7QUFDRCxRQUFJMDFCLGNBQWMsQ0FBZCxNQUFxQixRQUF6QixFQUFtQztBQUMvQkEsd0JBQWdCLEVBQUUvdEIsTUFBTSxRQUFSLEVBQWhCO0FBQ0gsS0FGRCxNQUVPLElBQUkrdEIsY0FBYyxDQUFkLE1BQXFCLGFBQXpCLEVBQXdDO0FBQzNDLFlBQUkza0IsT0FBTzJrQixjQUFjLENBQWQsQ0FBWDtBQUNBLFlBQUksT0FBTzNrQixJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzFCLG1CQUFPeVcsUUFBUXhuQixLQUFSLENBQWMsb0RBQWQsRUFBb0UsQ0FBcEUsRUFBdUUsQ0FBdkUsQ0FBUDtBQUNIO0FBQ0QwMUIsd0JBQWdCO0FBQ1ovdEIsa0JBQU0sYUFETTtBQUVab0osa0JBQU1BO0FBRk0sU0FBaEI7QUFJSCxLQVRNLE1BU0EsSUFBSTJrQixjQUFjLENBQWQsTUFBcUIsY0FBekIsRUFBeUM7QUFDNUMsWUFBSUssZ0JBQWdCTCxjQUFjNXVCLEtBQWQsQ0FBb0IsQ0FBcEIsQ0FBcEI7QUFDQSxZQUFJaXZCLGNBQWMvNUIsTUFBZCxLQUF5QixDQUF6QixJQUE4Qis1QixjQUFjcjBCLElBQWQsQ0FBbUIsVUFBVTBWLENBQVYsRUFBYTtBQUMxRCxtQkFBTyxPQUFPQSxDQUFQLEtBQWEsUUFBYixJQUF5QkEsSUFBSSxDQUE3QixJQUFrQ0EsSUFBSSxDQUE3QztBQUNILFNBRjZCLENBQWxDLEVBRVE7QUFDSixtQkFBT29RLFFBQVF4bkIsS0FBUixDQUFjLHlGQUFkLEVBQXlHLENBQXpHLENBQVA7QUFDSDtBQUNEMDFCLHdCQUFnQjtBQUNaL3RCLGtCQUFNLGNBRE07QUFFWm91QiwyQkFBZUE7QUFGSCxTQUFoQjtBQUlILEtBWE0sTUFXQTtBQUNILGVBQU92TyxRQUFReG5CLEtBQVIsQ0FBYyxnQ0FBZ0NvVixPQUFPc2dCLGNBQWMsQ0FBZCxDQUFQLENBQTlDLEVBQXdFLENBQXhFLEVBQTJFLENBQTNFLENBQVA7QUFDSDtBQUNELFFBQUluTyxLQUFLdnJCLE1BQUwsR0FBYyxDQUFkLEdBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLGVBQU93ckIsUUFBUXhuQixLQUFSLENBQWMsb0RBQW9EdW5CLEtBQUt2ckIsTUFBTCxHQUFjLENBQWxFLElBQXVFLEdBQXJGLENBQVA7QUFDSDtBQUNELFFBQUksQ0FBQ3VyQixLQUFLdnJCLE1BQUwsR0FBYyxDQUFmLElBQW9CLENBQXBCLEtBQTBCLENBQTlCLEVBQWlDO0FBQzdCLGVBQU93ckIsUUFBUXhuQixLQUFSLENBQWMsdUNBQWQsQ0FBUDtBQUNIO0FBQ0QyVyxZQUFRNlEsUUFBUWhwQixLQUFSLENBQWNtWSxLQUFkLEVBQXFCLENBQXJCLEVBQXdCd0wsVUFBeEIsQ0FBUjtBQUNBLFFBQUksQ0FBQ3hMLEtBQUwsRUFBWTtBQUNSLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSTVhLFFBQVEsRUFBWjtBQUNBLFFBQUlzMkIsYUFBYSxJQUFqQjtBQUNBLFFBQUlvRCxhQUFhLGlCQUFiLElBQWtDQSxhQUFhLGlCQUFuRCxFQUFzRTtBQUNsRXBELHFCQUFhL1AsU0FBYjtBQUNILEtBRkQsTUFFTyxJQUFJa0YsUUFBUUMsWUFBUixJQUF3QkQsUUFBUUMsWUFBUixDQUFxQnZGLElBQXJCLEtBQThCLE9BQTFELEVBQW1FO0FBQ3RFbVEscUJBQWE3SyxRQUFRQyxZQUFyQjtBQUNIO0FBQ0QsU0FBSyxJQUFJOXJCLElBQUksQ0FBYixFQUFnQkEsSUFBSThnQixLQUFLemdCLE1BQXpCLEVBQWlDTCxLQUFLLENBQXRDLEVBQXlDO0FBQ3JDLFlBQUl5MkIsUUFBUTNWLEtBQUs5Z0IsQ0FBTCxDQUFaO0FBQ0EsWUFBSWtNLFFBQVE0VSxLQUFLOWdCLElBQUksQ0FBVCxDQUFaO0FBQ0EsWUFBSTIyQixXQUFXMzJCLElBQUksQ0FBbkI7QUFDQSxZQUFJNDJCLFdBQVc1MkIsSUFBSSxDQUFuQjtBQUNBLFlBQUksT0FBT3kyQixLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzNCLG1CQUFPNUssUUFBUXhuQixLQUFSLENBQWMsZ0pBQWQsRUFBZ0tzeUIsUUFBaEssQ0FBUDtBQUNIO0FBQ0QsWUFBSXYyQixNQUFNQyxNQUFOLElBQWdCRCxNQUFNQSxNQUFNQyxNQUFOLEdBQWUsQ0FBckIsRUFBd0IsQ0FBeEIsS0FBOEJvMkIsS0FBbEQsRUFBeUQ7QUFDckQsbUJBQU81SyxRQUFReG5CLEtBQVIsQ0FBYyxrSEFBZCxFQUFrSXN5QixRQUFsSSxDQUFQO0FBQ0g7QUFDRCxZQUFJckssU0FBU1QsUUFBUWhwQixLQUFSLENBQWNxSixLQUFkLEVBQXFCMHFCLFFBQXJCLEVBQStCRixVQUEvQixDQUFiO0FBQ0EsWUFBSSxDQUFDcEssTUFBTCxFQUFhO0FBQ1QsbUJBQU8sSUFBUDtBQUNIO0FBQ0RvSyxxQkFBYUEsY0FBY3BLLE9BQU90bkIsSUFBbEM7QUFDQTVFLGNBQU1ZLElBQU4sQ0FBVyxDQUNQeTFCLEtBRE8sRUFFUG5LLE1BRk8sQ0FBWDtBQUlIO0FBQ0QsUUFBSW9LLFdBQVduUSxJQUFYLEtBQW9CLFFBQXBCLElBQWdDbVEsV0FBV25RLElBQVgsS0FBb0IsT0FBcEQsSUFBK0QsRUFBRW1RLFdBQVduUSxJQUFYLEtBQW9CLE9BQXBCLElBQStCbVEsV0FBV3hQLFFBQVgsQ0FBb0JYLElBQXBCLEtBQTZCLFFBQTVELElBQXdFLE9BQU9tUSxXQUFXdlAsQ0FBbEIsS0FBd0IsUUFBbEcsQ0FBbkUsRUFBZ0w7QUFDNUssZUFBTzBFLFFBQVF4bkIsS0FBUixDQUFjLFVBQVVxQixTQUFTZ3hCLFVBQVQsQ0FBVixHQUFpQyx5QkFBL0MsQ0FBUDtBQUNIO0FBQ0QsV0FBTyxJQUFJbUQsV0FBSixDQUFnQm5ELFVBQWhCLEVBQTRCb0QsUUFBNUIsRUFBc0NDLGFBQXRDLEVBQXFEL2UsS0FBckQsRUFBNEQ1YSxLQUE1RCxDQUFQO0FBQ0gsQ0EzRUQ7QUE0RUF5NUIsWUFBWTVjLFNBQVosQ0FBc0I4TyxRQUF0QixHQUFpQyxTQUFTQSxRQUFULENBQWtCUSxHQUFsQixFQUF1QjtBQUNwRCxRQUFJMVMsU0FBUyxLQUFLQSxNQUFsQjtBQUNBLFFBQUkyYyxVQUFVLEtBQUtBLE9BQW5CO0FBQ0EsUUFBSTNjLE9BQU94WixNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLGVBQU9tMkIsUUFBUSxDQUFSLEVBQVd6SyxRQUFYLENBQW9CUSxHQUFwQixDQUFQO0FBQ0g7QUFDRCxRQUFJcmdCLFFBQVEsS0FBSzhPLEtBQUwsQ0FBVytRLFFBQVgsQ0FBb0JRLEdBQXBCLENBQVo7QUFDQSxRQUFJcmdCLFNBQVMyTixPQUFPLENBQVAsQ0FBYixFQUF3QjtBQUNwQixlQUFPMmMsUUFBUSxDQUFSLEVBQVd6SyxRQUFYLENBQW9CUSxHQUFwQixDQUFQO0FBQ0g7QUFDRCxRQUFJc0ssWUFBWWhkLE9BQU94WixNQUF2QjtBQUNBLFFBQUk2TCxTQUFTMk4sT0FBT2dkLFlBQVksQ0FBbkIsQ0FBYixFQUFvQztBQUNoQyxlQUFPTCxRQUFRSyxZQUFZLENBQXBCLEVBQXVCOUssUUFBdkIsQ0FBZ0NRLEdBQWhDLENBQVA7QUFDSDtBQUNELFFBQUkzVixRQUFRcWYsMEJBQTBCcGMsTUFBMUIsRUFBa0MzTixLQUFsQyxDQUFaO0FBQ0EsUUFBSSt0QixRQUFRcGdCLE9BQU9qRCxLQUFQLENBQVo7QUFDQSxRQUFJc2pCLFFBQVFyZ0IsT0FBT2pELFFBQVEsQ0FBZixDQUFaO0FBQ0EsUUFBSTZFLElBQUlvZSxZQUFZRyxtQkFBWixDQUFnQyxLQUFLRCxhQUFyQyxFQUFvRDd0QixLQUFwRCxFQUEyRCt0QixLQUEzRCxFQUFrRUMsS0FBbEUsQ0FBUjtBQUNBLFFBQUlJLGNBQWM5RCxRQUFRNWYsS0FBUixFQUFlbVYsUUFBZixDQUF3QlEsR0FBeEIsQ0FBbEI7QUFDQSxRQUFJZ08sY0FBYy9ELFFBQVE1ZixRQUFRLENBQWhCLEVBQW1CbVYsUUFBbkIsQ0FBNEJRLEdBQTVCLENBQWxCO0FBQ0EsUUFBSSxLQUFLdU4sUUFBTCxLQUFrQixhQUF0QixFQUFxQztBQUNqQyxlQUFPcm5CLFlBQVksS0FBS3pOLElBQUwsQ0FBVXVoQixJQUFWLENBQWVoSyxXQUFmLEVBQVosRUFBMEMrZCxXQUExQyxFQUF1REMsV0FBdkQsRUFBb0U5ZSxDQUFwRSxDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUksS0FBS3FlLFFBQUwsS0FBa0IsaUJBQXRCLEVBQXlDO0FBQzVDLGVBQU9sa0IsSUFBSXNQLE9BQUosQ0FBWXRQLElBQUluRCxXQUFKLENBQWdCbUQsSUFBSStqQixPQUFKLENBQVlXLFdBQVosQ0FBaEIsRUFBMEMxa0IsSUFBSStqQixPQUFKLENBQVlZLFdBQVosQ0FBMUMsRUFBb0U5ZSxDQUFwRSxDQUFaLENBQVA7QUFDSCxLQUZNLE1BRUE7QUFDSCxlQUFPOUYsSUFBSXVQLE9BQUosQ0FBWXZQLElBQUlsRCxXQUFKLENBQWdCa0QsSUFBSWdrQixPQUFKLENBQVlXLFdBQVosQ0FBaEIsRUFBMEMza0IsSUFBSWdrQixPQUFKLENBQVlZLFdBQVosQ0FBMUMsRUFBb0U5ZSxDQUFwRSxDQUFaLENBQVA7QUFDSDtBQUNKLENBM0JEO0FBNEJBb2UsWUFBWTVjLFNBQVosQ0FBc0IrTyxTQUF0QixHQUFrQyxTQUFTQSxTQUFULENBQW1CL1QsRUFBbkIsRUFBdUI7QUFDckRBLE9BQUcsS0FBSytDLEtBQVI7QUFDQSxTQUFLLElBQUloYixJQUFJLENBQVIsRUFBV21rQixPQUFPLEtBQUtxUyxPQUE1QixFQUFxQ3gyQixJQUFJbWtCLEtBQUs5akIsTUFBOUMsRUFBc0RMLEtBQUssQ0FBM0QsRUFBOEQ7QUFDMUQsWUFBSTJQLGFBQWF3VSxLQUFLbmtCLENBQUwsQ0FBakI7QUFDQWlZLFdBQUd0SSxVQUFIO0FBQ0g7QUFDSixDQU5EO0FBT0FrcUIsWUFBWTVjLFNBQVosQ0FBc0JnUCxhQUF0QixHQUFzQyxTQUFTQSxhQUFULEdBQXlCO0FBQzNELFdBQU8sS0FBS3VLLE9BQUwsQ0FBYWhLLEtBQWIsQ0FBbUIsVUFBVXRSLEdBQVYsRUFBZTtBQUNyQyxlQUFPQSxJQUFJK1EsYUFBSixFQUFQO0FBQ0gsS0FGTSxDQUFQO0FBR0gsQ0FKRDtBQUtBNE4sWUFBWTVjLFNBQVosQ0FBc0JnTyxTQUF0QixHQUFrQyxTQUFTQSxTQUFULEdBQXFCO0FBQ25ELFFBQUk4TyxhQUFKO0FBQ0EsUUFBSSxLQUFLQSxhQUFMLENBQW1CL3RCLElBQW5CLEtBQTRCLFFBQWhDLEVBQTBDO0FBQ3RDK3RCLHdCQUFnQixDQUFDLFFBQUQsQ0FBaEI7QUFDSCxLQUZELE1BRU8sSUFBSSxLQUFLQSxhQUFMLENBQW1CL3RCLElBQW5CLEtBQTRCLGFBQWhDLEVBQStDO0FBQ2xELFlBQUksS0FBSyt0QixhQUFMLENBQW1CM2tCLElBQW5CLEtBQTRCLENBQWhDLEVBQW1DO0FBQy9CMmtCLDRCQUFnQixDQUFDLFFBQUQsQ0FBaEI7QUFDSCxTQUZELE1BRU87QUFDSEEsNEJBQWdCLENBQ1osYUFEWSxFQUVaLEtBQUtBLGFBQUwsQ0FBbUIza0IsSUFGUCxDQUFoQjtBQUlIO0FBQ0osS0FUTSxNQVNBO0FBQ0gya0Isd0JBQWdCLENBQUMsY0FBRCxFQUFpQnhsQixNQUFqQixDQUF3QixLQUFLd2xCLGFBQUwsQ0FBbUJLLGFBQTNDLENBQWhCO0FBQ0g7QUFDRCxRQUFJbFAsYUFBYSxDQUNiLEtBQUs0TyxRQURRLEVBRWJDLGFBRmEsRUFHYixLQUFLL2UsS0FBTCxDQUFXaVEsU0FBWCxFQUhhLENBQWpCO0FBS0EsU0FBSyxJQUFJanJCLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLNlosTUFBTCxDQUFZeFosTUFBaEMsRUFBd0NMLEdBQXhDLEVBQTZDO0FBQ3pDa3JCLG1CQUFXbHFCLElBQVgsQ0FBZ0IsS0FBSzZZLE1BQUwsQ0FBWTdaLENBQVosQ0FBaEIsRUFBZ0MsS0FBS3cyQixPQUFMLENBQWF4MkIsQ0FBYixFQUFnQmlyQixTQUFoQixFQUFoQztBQUNIO0FBQ0QsV0FBT0MsVUFBUDtBQUNILENBekJEO0FBMEJBLFNBQVNpUCx3QkFBVCxDQUFrQ25mLEtBQWxDLEVBQXlDNUYsSUFBekMsRUFBK0NvbEIsVUFBL0MsRUFBMkRDLFVBQTNELEVBQXVFO0FBQ25FLFFBQUlDLGFBQWFELGFBQWFELFVBQTlCO0FBQ0EsUUFBSUcsV0FBVzNmLFFBQVF3ZixVQUF2QjtBQUNBLFFBQUlFLGVBQWUsQ0FBbkIsRUFBc0I7QUFDbEIsZUFBTyxDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUl0bEIsU0FBUyxDQUFiLEVBQWdCO0FBQ25CLGVBQU91bEIsV0FBV0QsVUFBbEI7QUFDSCxLQUZNLE1BRUE7QUFDSCxlQUFPLENBQUNuaEIsS0FBS3dYLEdBQUwsQ0FBUzNiLElBQVQsRUFBZXVsQixRQUFmLElBQTJCLENBQTVCLEtBQWtDcGhCLEtBQUt3WCxHQUFMLENBQVMzYixJQUFULEVBQWVzbEIsVUFBZixJQUE2QixDQUEvRCxDQUFQO0FBQ0g7QUFDSjs7QUFFRCxJQUFJRSxXQUFXLFNBQVNBLFFBQVQsQ0FBa0I1MUIsSUFBbEIsRUFBd0I0bUIsSUFBeEIsRUFBOEI7QUFDekMsU0FBSzVtQixJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLNG1CLElBQUwsR0FBWUEsSUFBWjtBQUNILENBSEQ7QUFJQWdQLFNBQVMvM0IsS0FBVCxHQUFpQixTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDM0MsUUFBSUQsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbEIsRUFBcUI7QUFDakIsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYyxvQ0FBZCxDQUFQO0FBQ0g7QUFDRCxRQUFJcXlCLGFBQWEsSUFBakI7QUFDQSxRQUFJNUssZUFBZUQsUUFBUUMsWUFBM0I7QUFDQSxRQUFJQSxnQkFBZ0JBLGFBQWF2RixJQUFiLEtBQXNCLE9BQTFDLEVBQW1EO0FBQy9DbVEscUJBQWE1SyxZQUFiO0FBQ0g7QUFDRCxRQUFJeUQsYUFBYSxFQUFqQjtBQUNBLFNBQUssSUFBSXZ2QixJQUFJLENBQVIsRUFBV21rQixPQUFPeUgsS0FBS3pnQixLQUFMLENBQVcsQ0FBWCxDQUF2QixFQUFzQ25MLElBQUlta0IsS0FBSzlqQixNQUEvQyxFQUF1REwsS0FBSyxDQUE1RCxFQUErRDtBQUMzRCxZQUFJNGMsTUFBTXVILEtBQUtua0IsQ0FBTCxDQUFWO0FBQ0EsWUFBSXNzQixTQUFTVCxRQUFRaHBCLEtBQVIsQ0FBYytaLEdBQWQsRUFBbUIsSUFBSTJTLFdBQVdsdkIsTUFBbEMsRUFBMENxMkIsVUFBMUMsRUFBc0QxeUIsU0FBdEQsRUFBaUUsRUFBRXd4QixnQkFBZ0IsTUFBbEIsRUFBakUsQ0FBYjtBQUNBLFlBQUksQ0FBQ2xKLE1BQUwsRUFBYTtBQUNULG1CQUFPLElBQVA7QUFDSDtBQUNEb0sscUJBQWFBLGNBQWNwSyxPQUFPdG5CLElBQWxDO0FBQ0F1cUIsbUJBQVd2dUIsSUFBWCxDQUFnQnNyQixNQUFoQjtBQUNIO0FBQ0QsUUFBSXVPLGtCQUFrQi9PLGdCQUFnQnlELFdBQVd4cEIsSUFBWCxDQUFnQixVQUFVNlcsR0FBVixFQUFlO0FBQ2pFLGVBQU95SyxhQUFheUUsWUFBYixFQUEyQmxQLElBQUk1WCxJQUEvQixDQUFQO0FBQ0gsS0FGcUMsQ0FBdEM7QUFHQSxXQUFPNjFCLGtCQUFrQixJQUFJRCxRQUFKLENBQWEvVCxTQUFiLEVBQXdCMEksVUFBeEIsQ0FBbEIsR0FBd0QsSUFBSXFMLFFBQUosQ0FBYWxFLFVBQWIsRUFBeUJuSCxVQUF6QixDQUEvRDtBQUNILENBdkJEO0FBd0JBcUwsU0FBUzNkLFNBQVQsQ0FBbUI4TyxRQUFuQixHQUE4QixTQUFTQSxRQUFULENBQWtCUSxHQUFsQixFQUF1QjtBQUNqRCxRQUFJL1UsU0FBUyxJQUFiO0FBQ0EsUUFBSXNqQixXQUFXLENBQWY7QUFDQSxRQUFJQyxrQkFBSjtBQUNBLFNBQUssSUFBSS82QixJQUFJLENBQVIsRUFBV21rQixPQUFPLEtBQUt5SCxJQUE1QixFQUFrQzVyQixJQUFJbWtCLEtBQUs5akIsTUFBM0MsRUFBbURMLEtBQUssQ0FBeEQsRUFBMkQ7QUFDdkQsWUFBSTRjLE1BQU11SCxLQUFLbmtCLENBQUwsQ0FBVjtBQUNBODZCO0FBQ0F0akIsaUJBQVNvRixJQUFJbVAsUUFBSixDQUFhUSxHQUFiLENBQVQ7QUFDQSxZQUFJL1UsVUFBVUEsa0JBQWtCMlQsYUFBNUIsSUFBNkMsQ0FBQzNULE9BQU80VCxTQUF6RCxFQUFvRTtBQUNoRSxnQkFBSSxDQUFDMlAsa0JBQUwsRUFBeUI7QUFDckJBLHFDQUFxQnZqQixPQUFPeEwsSUFBNUI7QUFDSDtBQUNEd0wscUJBQVMsSUFBVDtBQUNBLGdCQUFJc2pCLGFBQWEsS0FBS2xQLElBQUwsQ0FBVXZyQixNQUEzQixFQUFtQztBQUMvQm1YLHlCQUFTdWpCLGtCQUFUO0FBQ0g7QUFDSjtBQUNELFlBQUl2akIsV0FBVyxJQUFmLEVBQXFCO0FBQ2pCO0FBQ0g7QUFDSjtBQUNELFdBQU9BLE1BQVA7QUFDSCxDQXRCRDtBQXVCQW9qQixTQUFTM2QsU0FBVCxDQUFtQitPLFNBQW5CLEdBQStCLFNBQVNBLFNBQVQsQ0FBbUIvVCxFQUFuQixFQUF1QjtBQUNsRCxTQUFLMlQsSUFBTCxDQUFVckgsT0FBVixDQUFrQnRNLEVBQWxCO0FBQ0gsQ0FGRDtBQUdBMmlCLFNBQVMzZCxTQUFULENBQW1CZ1AsYUFBbkIsR0FBbUMsU0FBU0EsYUFBVCxHQUF5QjtBQUN4RCxXQUFPLEtBQUtMLElBQUwsQ0FBVVksS0FBVixDQUFnQixVQUFVNVAsR0FBVixFQUFlO0FBQ2xDLGVBQU9BLElBQUlxUCxhQUFKLEVBQVA7QUFDSCxLQUZNLENBQVA7QUFHSCxDQUpEO0FBS0EyTyxTQUFTM2QsU0FBVCxDQUFtQmdPLFNBQW5CLEdBQStCLFNBQVNBLFNBQVQsR0FBcUI7QUFDaEQsUUFBSUMsYUFBYSxDQUFDLFVBQUQsQ0FBakI7QUFDQSxTQUFLYyxTQUFMLENBQWUsVUFBVTZCLEtBQVYsRUFBaUI7QUFDNUIzQyxtQkFBV2xxQixJQUFYLENBQWdCNnNCLE1BQU01QyxTQUFOLEVBQWhCO0FBQ0gsS0FGRDtBQUdBLFdBQU9DLFVBQVA7QUFDSCxDQU5EOztBQVFBLElBQUk4UCxNQUFNLFNBQVNBLEdBQVQsQ0FBYTNVLFFBQWIsRUFBdUI3TyxNQUF2QixFQUErQjtBQUNyQyxTQUFLeFMsSUFBTCxHQUFZd1MsT0FBT3hTLElBQW5CO0FBQ0EsU0FBS3FoQixRQUFMLEdBQWdCLEdBQUc5UixNQUFILENBQVU4UixRQUFWLENBQWhCO0FBQ0EsU0FBSzdPLE1BQUwsR0FBY0EsTUFBZDtBQUNILENBSkQ7QUFLQXdqQixJQUFJL2QsU0FBSixDQUFjOE8sUUFBZCxHQUF5QixTQUFTQSxRQUFULENBQWtCUSxHQUFsQixFQUF1QjtBQUM1QyxXQUFPLEtBQUsvVSxNQUFMLENBQVl1VSxRQUFaLENBQXFCUSxHQUFyQixDQUFQO0FBQ0gsQ0FGRDtBQUdBeU8sSUFBSS9kLFNBQUosQ0FBYytPLFNBQWQsR0FBMEIsU0FBU0EsU0FBVCxDQUFtQi9ULEVBQW5CLEVBQXVCO0FBQzdDLFNBQUssSUFBSWpZLElBQUksQ0FBUixFQUFXbWtCLE9BQU8sS0FBS2tDLFFBQTVCLEVBQXNDcm1CLElBQUlta0IsS0FBSzlqQixNQUEvQyxFQUF1REwsS0FBSyxDQUE1RCxFQUErRDtBQUMzRCxZQUFJaTdCLFVBQVU5VyxLQUFLbmtCLENBQUwsQ0FBZDtBQUNBaVksV0FBR2dqQixRQUFRLENBQVIsQ0FBSDtBQUNIO0FBQ0RoakIsT0FBRyxLQUFLVCxNQUFSO0FBQ0gsQ0FORDtBQU9Bd2pCLElBQUluNEIsS0FBSixHQUFZLFNBQVNBLEtBQVQsQ0FBZStvQixJQUFmLEVBQXFCQyxPQUFyQixFQUE4QjtBQUN0QyxRQUFJRCxLQUFLdnJCLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNqQixlQUFPd3JCLFFBQVF4bkIsS0FBUixDQUFjLCtDQUErQ3VuQixLQUFLdnJCLE1BQUwsR0FBYyxDQUE3RCxJQUFrRSxXQUFoRixDQUFQO0FBQ0g7QUFDRCxRQUFJZ21CLFdBQVcsRUFBZjtBQUNBLFNBQUssSUFBSXJtQixJQUFJLENBQWIsRUFBZ0JBLElBQUk0ckIsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbEMsRUFBcUNMLEtBQUssQ0FBMUMsRUFBNkM7QUFDekMsWUFBSWdNLE9BQU80ZixLQUFLNXJCLENBQUwsQ0FBWDtBQUNBLFlBQUksT0FBT2dNLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUIsbUJBQU82ZixRQUFReG5CLEtBQVIsQ0FBYyx3Q0FBdUMySCxJQUF2Qyx5Q0FBdUNBLElBQXZDLEtBQThDLFdBQTVELEVBQXlFaE0sQ0FBekUsQ0FBUDtBQUNIO0FBQ0QsWUFBSSxnQkFBZ0JzYyxJQUFoQixDQUFxQnRRLElBQXJCLENBQUosRUFBZ0M7QUFDNUIsbUJBQU82ZixRQUFReG5CLEtBQVIsQ0FBYyxvRUFBZCxFQUFvRnJFLENBQXBGLENBQVA7QUFDSDtBQUNELFlBQUlrTSxRQUFRMmYsUUFBUWhwQixLQUFSLENBQWMrb0IsS0FBSzVyQixJQUFJLENBQVQsQ0FBZCxFQUEyQkEsSUFBSSxDQUEvQixDQUFaO0FBQ0EsWUFBSSxDQUFDa00sS0FBTCxFQUFZO0FBQ1IsbUJBQU8sSUFBUDtBQUNIO0FBQ0RtYSxpQkFBU3JsQixJQUFULENBQWMsQ0FDVmdMLElBRFUsRUFFVkUsS0FGVSxDQUFkO0FBSUg7QUFDRCxRQUFJc0wsU0FBU3FVLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUtBLEtBQUt2ckIsTUFBTCxHQUFjLENBQW5CLENBQWQsRUFBcUN1ckIsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbkQsRUFBc0R3ckIsUUFBUUMsWUFBOUQsRUFBNEV6RixRQUE1RSxDQUFiO0FBQ0EsUUFBSSxDQUFDN08sTUFBTCxFQUFhO0FBQ1QsZUFBTyxJQUFQO0FBQ0g7QUFDRCxXQUFPLElBQUl3akIsR0FBSixDQUFRM1UsUUFBUixFQUFrQjdPLE1BQWxCLENBQVA7QUFDSCxDQTNCRDtBQTRCQXdqQixJQUFJL2QsU0FBSixDQUFjZ1AsYUFBZCxHQUE4QixTQUFTQSxhQUFULEdBQXlCO0FBQ25ELFdBQU8sS0FBS3pVLE1BQUwsQ0FBWXlVLGFBQVosRUFBUDtBQUNILENBRkQ7QUFHQStPLElBQUkvZCxTQUFKLENBQWNnTyxTQUFkLEdBQTBCLFNBQVNBLFNBQVQsR0FBcUI7QUFDM0MsUUFBSUMsYUFBYSxDQUFDLEtBQUQsQ0FBakI7QUFDQSxTQUFLLElBQUlsckIsSUFBSSxDQUFSLEVBQVdta0IsT0FBTyxLQUFLa0MsUUFBNUIsRUFBc0NybUIsSUFBSW1rQixLQUFLOWpCLE1BQS9DLEVBQXVETCxLQUFLLENBQTVELEVBQStEO0FBQzNELFlBQUlrRyxNQUFNaWUsS0FBS25rQixDQUFMLENBQVY7QUFDQSxZQUFJZ00sT0FBTzlGLElBQUksQ0FBSixDQUFYO0FBQ0EsWUFBSW12QixPQUFPbnZCLElBQUksQ0FBSixDQUFYO0FBQ0FnbEIsbUJBQVdscUIsSUFBWCxDQUFnQmdMLElBQWhCLEVBQXNCcXBCLEtBQUtwSyxTQUFMLEVBQXRCO0FBQ0g7QUFDREMsZUFBV2xxQixJQUFYLENBQWdCLEtBQUt3VyxNQUFMLENBQVl5VCxTQUFaLEVBQWhCO0FBQ0EsV0FBT0MsVUFBUDtBQUNILENBVkQ7O0FBWUEsSUFBSWdRLEtBQUssU0FBU0EsRUFBVCxDQUFZbDJCLElBQVosRUFBa0I0UixLQUFsQixFQUF5Qm9FLEtBQXpCLEVBQWdDO0FBQ3JDLFNBQUtoVyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLNFIsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS29FLEtBQUwsR0FBYUEsS0FBYjtBQUNILENBSkQ7QUFLQWtnQixHQUFHcjRCLEtBQUgsR0FBVyxTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDckMsUUFBSUQsS0FBS3ZyQixNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CLGVBQU93ckIsUUFBUXhuQixLQUFSLENBQWMsc0NBQXNDdW5CLEtBQUt2ckIsTUFBTCxHQUFjLENBQXBELElBQXlELFdBQXZFLENBQVA7QUFDSDtBQUNELFFBQUl1VyxRQUFRaVYsUUFBUWhwQixLQUFSLENBQWMrb0IsS0FBSyxDQUFMLENBQWQsRUFBdUIsQ0FBdkIsRUFBMEJwRixVQUExQixDQUFaO0FBQ0EsUUFBSXhMLFFBQVE2USxRQUFRaHBCLEtBQVIsQ0FBYytvQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQnZaLE1BQU13WixRQUFRQyxZQUFSLElBQXdCakYsU0FBOUIsQ0FBMUIsQ0FBWjtBQUNBLFFBQUksQ0FBQ2pRLEtBQUQsSUFBVSxDQUFDb0UsS0FBZixFQUFzQjtBQUNsQixlQUFPLElBQVA7QUFDSDtBQUNELFFBQUlTLElBQUlULE1BQU1oVyxJQUFkO0FBQ0EsV0FBTyxJQUFJazJCLEVBQUosQ0FBT3pmLEVBQUV5TCxRQUFULEVBQW1CdFEsS0FBbkIsRUFBMEJvRSxLQUExQixDQUFQO0FBQ0gsQ0FYRDtBQVlBa2dCLEdBQUdqZSxTQUFILENBQWE4TyxRQUFiLEdBQXdCLFNBQVNBLFFBQVQsQ0FBa0JRLEdBQWxCLEVBQXVCO0FBQzNDLFFBQUkzVixRQUFRLEtBQUtBLEtBQUwsQ0FBV21WLFFBQVgsQ0FBb0JRLEdBQXBCLENBQVo7QUFDQSxRQUFJbGEsUUFBUSxLQUFLMkksS0FBTCxDQUFXK1EsUUFBWCxDQUFvQlEsR0FBcEIsQ0FBWjtBQUNBLFFBQUkzVixRQUFRLENBQVosRUFBZTtBQUNYLGNBQU0sSUFBSXNWLFlBQUosQ0FBaUIsZ0NBQWdDdFYsS0FBaEMsR0FBd0MsT0FBekQsQ0FBTjtBQUNIO0FBQ0QsUUFBSUEsU0FBU3ZFLE1BQU1oUyxNQUFuQixFQUEyQjtBQUN2QixjQUFNLElBQUk2ckIsWUFBSixDQUFpQixnQ0FBZ0N0VixLQUFoQyxHQUF3QyxLQUF4QyxJQUFpRHZFLE1BQU1oUyxNQUFOLEdBQWUsQ0FBaEUsSUFBcUUsR0FBdEYsQ0FBTjtBQUNIO0FBQ0QsUUFBSXVXLFVBQVUyQyxLQUFLcEYsS0FBTCxDQUFXeUMsS0FBWCxDQUFkLEVBQWlDO0FBQzdCLGNBQU0sSUFBSXNWLFlBQUosQ0FBaUIsK0NBQStDdFYsS0FBL0MsR0FBdUQsV0FBeEUsQ0FBTjtBQUNIO0FBQ0QsV0FBT3ZFLE1BQU11RSxLQUFOLENBQVA7QUFDSCxDQWJEO0FBY0Fza0IsR0FBR2plLFNBQUgsQ0FBYStPLFNBQWIsR0FBeUIsU0FBU0EsU0FBVCxDQUFtQi9ULEVBQW5CLEVBQXVCO0FBQzVDQSxPQUFHLEtBQUtyQixLQUFSO0FBQ0FxQixPQUFHLEtBQUsrQyxLQUFSO0FBQ0gsQ0FIRDtBQUlBa2dCLEdBQUdqZSxTQUFILENBQWFnUCxhQUFiLEdBQTZCLFNBQVNBLGFBQVQsR0FBeUI7QUFDbEQsV0FBTyxLQUFQO0FBQ0gsQ0FGRDtBQUdBaVAsR0FBR2plLFNBQUgsQ0FBYWdPLFNBQWIsR0FBeUIsU0FBU0EsU0FBVCxHQUFxQjtBQUMxQyxXQUFPLENBQ0gsSUFERyxFQUVILEtBQUtyVSxLQUFMLENBQVdxVSxTQUFYLEVBRkcsRUFHSCxLQUFLalEsS0FBTCxDQUFXaVEsU0FBWCxFQUhHLENBQVA7QUFLSCxDQU5EOztBQVFBLElBQUlrUSxLQUFLLFNBQVNBLEVBQVQsQ0FBWUMsTUFBWixFQUFvQkMsUUFBcEIsRUFBOEI7QUFDbkMsU0FBS3IyQixJQUFMLEdBQVkwaEIsV0FBWjtBQUNBLFNBQUswVSxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNILENBSkQ7QUFLQUYsR0FBR3Q0QixLQUFILEdBQVcsU0FBU0EsS0FBVCxDQUFlK29CLElBQWYsRUFBcUJDLE9BQXJCLEVBQThCO0FBQ3JDLFFBQUlELEtBQUt2ckIsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQixlQUFPd3JCLFFBQVF4bkIsS0FBUixDQUFjLHNDQUFzQ3VuQixLQUFLdnJCLE1BQUwsR0FBYyxDQUFwRCxJQUF5RCxXQUF2RSxDQUFQO0FBQ0g7QUFDRCxRQUFJKzZCLFNBQVN2UCxRQUFRaHBCLEtBQVIsQ0FBYytvQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQi9FLFNBQTFCLENBQWI7QUFDQSxRQUFJd1UsV0FBV3hQLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCL0UsU0FBMUIsQ0FBZjtBQUNBLFFBQUksQ0FBQ3VVLE1BQUQsSUFBVyxDQUFDQyxRQUFoQixFQUEwQjtBQUN0QixlQUFPLElBQVA7QUFDSDtBQUNELFFBQUksQ0FBQzdULFlBQVk0VCxPQUFPcDJCLElBQW5CLEVBQXlCLENBQ3RCMGhCLFdBRHNCLEVBRXRCRCxVQUZzQixFQUd0QkQsVUFIc0IsRUFJdEJGLFFBSnNCLEVBS3RCTyxTQUxzQixDQUF6QixDQUFMLEVBTVE7QUFDSixlQUFPZ0YsUUFBUXhuQixLQUFSLENBQWMsc0ZBQXNGcUIsU0FBUzAxQixPQUFPcDJCLElBQWhCLENBQXRGLEdBQThHLFVBQTVILENBQVA7QUFDSDtBQUNELFdBQU8sSUFBSW0yQixFQUFKLENBQU9DLE1BQVAsRUFBZUMsUUFBZixDQUFQO0FBQ0gsQ0FuQkQ7QUFvQkFGLEdBQUdsZSxTQUFILENBQWE4TyxRQUFiLEdBQXdCLFNBQVNBLFFBQVQsQ0FBa0JRLEdBQWxCLEVBQXVCO0FBQzNDLFFBQUk2TyxTQUFTLEtBQUtBLE1BQUwsQ0FBWXJQLFFBQVosQ0FBcUJRLEdBQXJCLENBQWI7QUFDQSxRQUFJOE8sV0FBVyxLQUFLQSxRQUFMLENBQWN0UCxRQUFkLENBQXVCUSxHQUF2QixDQUFmO0FBQ0EsUUFBSSxDQUFDOE8sUUFBTCxFQUFlO0FBQ1gsZUFBTyxLQUFQO0FBQ0g7QUFDRCxRQUFJLENBQUMxVCxrQkFBa0J5VCxNQUFsQixFQUEwQixDQUN2QixTQUR1QixFQUV2QixRQUZ1QixFQUd2QixRQUh1QixFQUl2QixNQUp1QixDQUExQixDQUFMLEVBS1E7QUFDSixjQUFNLElBQUlsUCxZQUFKLENBQWlCLHNGQUFzRnhtQixTQUFTK2xCLE9BQU8yUCxNQUFQLENBQVQsQ0FBdEYsR0FBaUgsV0FBbEksQ0FBTjtBQUNIO0FBQ0QsUUFBSSxDQUFDelQsa0JBQWtCMFQsUUFBbEIsRUFBNEIsQ0FDekIsUUFEeUIsRUFFekIsT0FGeUIsQ0FBNUIsQ0FBTCxFQUdRO0FBQ0osY0FBTSxJQUFJblAsWUFBSixDQUFpQix1RUFBdUV4bUIsU0FBUytsQixPQUFPNFAsUUFBUCxDQUFULENBQXZFLEdBQW9HLFdBQXJILENBQU47QUFDSDtBQUNELFdBQU9BLFNBQVN0NkIsT0FBVCxDQUFpQnE2QixNQUFqQixLQUE0QixDQUFuQztBQUNILENBckJEO0FBc0JBRCxHQUFHbGUsU0FBSCxDQUFhK08sU0FBYixHQUF5QixTQUFTQSxTQUFULENBQW1CL1QsRUFBbkIsRUFBdUI7QUFDNUNBLE9BQUcsS0FBS21qQixNQUFSO0FBQ0FuakIsT0FBRyxLQUFLb2pCLFFBQVI7QUFDSCxDQUhEO0FBSUFGLEdBQUdsZSxTQUFILENBQWFnUCxhQUFiLEdBQTZCLFNBQVNBLGFBQVQsR0FBeUI7QUFDbEQsV0FBTyxJQUFQO0FBQ0gsQ0FGRDtBQUdBa1AsR0FBR2xlLFNBQUgsQ0FBYWdPLFNBQWIsR0FBeUIsU0FBU0EsU0FBVCxHQUFxQjtBQUMxQyxXQUFPLENBQ0gsSUFERyxFQUVILEtBQUttUSxNQUFMLENBQVluUSxTQUFaLEVBRkcsRUFHSCxLQUFLb1EsUUFBTCxDQUFjcFEsU0FBZCxFQUhHLENBQVA7QUFLSCxDQU5EOztBQVFBLElBQUlxUSxVQUFVLFNBQVNBLE9BQVQsQ0FBaUJGLE1BQWpCLEVBQXlCQyxRQUF6QixFQUFtQ0UsU0FBbkMsRUFBOEM7QUFDeEQsU0FBS3YyQixJQUFMLEdBQVl3aEIsVUFBWjtBQUNBLFNBQUs0VSxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtFLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0gsQ0FMRDtBQU1BRCxRQUFRejRCLEtBQVIsR0FBZ0IsU0FBU0EsS0FBVCxDQUFlK29CLElBQWYsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzFDLFFBQUlELEtBQUt2ckIsTUFBTCxJQUFlLENBQWYsSUFBb0J1ckIsS0FBS3ZyQixNQUFMLElBQWUsQ0FBdkMsRUFBMEM7QUFDdEMsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYywyQ0FBMkN1bkIsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBekQsSUFBOEQsV0FBNUUsQ0FBUDtBQUNIO0FBQ0QsUUFBSSs2QixTQUFTdlAsUUFBUWhwQixLQUFSLENBQWMrb0IsS0FBSyxDQUFMLENBQWQsRUFBdUIsQ0FBdkIsRUFBMEIvRSxTQUExQixDQUFiO0FBQ0EsUUFBSXdVLFdBQVd4UCxRQUFRaHBCLEtBQVIsQ0FBYytvQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQi9FLFNBQTFCLENBQWY7QUFDQSxRQUFJLENBQUN1VSxNQUFELElBQVcsQ0FBQ0MsUUFBaEIsRUFBMEI7QUFDdEIsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJLENBQUM3VCxZQUFZNFQsT0FBT3AyQixJQUFuQixFQUF5QixDQUN0QjBoQixXQURzQixFQUV0QkQsVUFGc0IsRUFHdEJELFVBSHNCLEVBSXRCRixRQUpzQixFQUt0Qk8sU0FMc0IsQ0FBekIsQ0FBTCxFQU1RO0FBQ0osZUFBT2dGLFFBQVF4bkIsS0FBUixDQUFjLHNGQUFzRnFCLFNBQVMwMUIsT0FBT3AyQixJQUFoQixDQUF0RixHQUE4RyxVQUE1SCxDQUFQO0FBQ0g7QUFDRCxRQUFJNG1CLEtBQUt2ckIsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQixZQUFJazdCLFlBQVkxUCxRQUFRaHBCLEtBQVIsQ0FBYytvQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQnBGLFVBQTFCLENBQWhCO0FBQ0EsWUFBSSxDQUFDK1UsU0FBTCxFQUFnQjtBQUNaLG1CQUFPLElBQVA7QUFDSDtBQUNELGVBQU8sSUFBSUQsT0FBSixDQUFZRixNQUFaLEVBQW9CQyxRQUFwQixFQUE4QkUsU0FBOUIsQ0FBUDtBQUNILEtBTkQsTUFNTztBQUNILGVBQU8sSUFBSUQsT0FBSixDQUFZRixNQUFaLEVBQW9CQyxRQUFwQixDQUFQO0FBQ0g7QUFDSixDQTNCRDtBQTRCQUMsUUFBUXJlLFNBQVIsQ0FBa0I4TyxRQUFsQixHQUE2QixTQUFTQSxRQUFULENBQWtCUSxHQUFsQixFQUF1QjtBQUNoRCxRQUFJNk8sU0FBUyxLQUFLQSxNQUFMLENBQVlyUCxRQUFaLENBQXFCUSxHQUFyQixDQUFiO0FBQ0EsUUFBSThPLFdBQVcsS0FBS0EsUUFBTCxDQUFjdFAsUUFBZCxDQUF1QlEsR0FBdkIsQ0FBZjtBQUNBLFFBQUksQ0FBQzVFLGtCQUFrQnlULE1BQWxCLEVBQTBCLENBQ3ZCLFNBRHVCLEVBRXZCLFFBRnVCLEVBR3ZCLFFBSHVCLEVBSXZCLE1BSnVCLENBQTFCLENBQUwsRUFLUTtBQUNKLGNBQU0sSUFBSWxQLFlBQUosQ0FBaUIsc0ZBQXNGeG1CLFNBQVMrbEIsT0FBTzJQLE1BQVAsQ0FBVCxDQUF0RixHQUFpSCxXQUFsSSxDQUFOO0FBQ0g7QUFDRCxRQUFJLENBQUN6VCxrQkFBa0IwVCxRQUFsQixFQUE0QixDQUN6QixRQUR5QixFQUV6QixPQUZ5QixDQUE1QixDQUFMLEVBR1E7QUFDSixjQUFNLElBQUluUCxZQUFKLENBQWlCLHVFQUF1RXhtQixTQUFTK2xCLE9BQU80UCxRQUFQLENBQVQsQ0FBdkUsR0FBb0csV0FBckgsQ0FBTjtBQUNIO0FBQ0QsUUFBSSxLQUFLRSxTQUFULEVBQW9CO0FBQ2hCLFlBQUlBLFlBQVksS0FBS0EsU0FBTCxDQUFleFAsUUFBZixDQUF3QlEsR0FBeEIsQ0FBaEI7QUFDQSxlQUFPOE8sU0FBU3Q2QixPQUFULENBQWlCcTZCLE1BQWpCLEVBQXlCRyxTQUF6QixDQUFQO0FBQ0g7QUFDRCxXQUFPRixTQUFTdDZCLE9BQVQsQ0FBaUJxNkIsTUFBakIsQ0FBUDtBQUNILENBdEJEO0FBdUJBRSxRQUFRcmUsU0FBUixDQUFrQitPLFNBQWxCLEdBQThCLFNBQVNBLFNBQVQsQ0FBbUIvVCxFQUFuQixFQUF1QjtBQUNqREEsT0FBRyxLQUFLbWpCLE1BQVI7QUFDQW5qQixPQUFHLEtBQUtvakIsUUFBUjtBQUNBLFFBQUksS0FBS0UsU0FBVCxFQUFvQjtBQUNoQnRqQixXQUFHLEtBQUtzakIsU0FBUjtBQUNIO0FBQ0osQ0FORDtBQU9BRCxRQUFRcmUsU0FBUixDQUFrQmdQLGFBQWxCLEdBQWtDLFNBQVNBLGFBQVQsR0FBeUI7QUFDdkQsV0FBTyxLQUFQO0FBQ0gsQ0FGRDtBQUdBcVAsUUFBUXJlLFNBQVIsQ0FBa0JnTyxTQUFsQixHQUE4QixTQUFTQSxTQUFULEdBQXFCO0FBQy9DLFFBQUksS0FBS3NRLFNBQUwsSUFBa0IsSUFBbEIsSUFBMEIsS0FBS0EsU0FBTCxLQUFtQnYzQixTQUFqRCxFQUE0RDtBQUN4RCxZQUFJdTNCLFlBQVksS0FBS0EsU0FBTCxDQUFldFEsU0FBZixFQUFoQjtBQUNBLGVBQU8sQ0FDSCxVQURHLEVBRUgsS0FBS21RLE1BQUwsQ0FBWW5RLFNBQVosRUFGRyxFQUdILEtBQUtvUSxRQUFMLENBQWNwUSxTQUFkLEVBSEcsRUFJSHNRLFNBSkcsQ0FBUDtBQU1IO0FBQ0QsV0FBTyxDQUNILFVBREcsRUFFSCxLQUFLSCxNQUFMLENBQVluUSxTQUFaLEVBRkcsRUFHSCxLQUFLb1EsUUFBTCxDQUFjcFEsU0FBZCxFQUhHLENBQVA7QUFLSCxDQWZEOztBQWlCQSxJQUFJdVEsUUFBUSxTQUFTQSxLQUFULENBQWVDLFNBQWYsRUFBMEIvRSxVQUExQixFQUFzQzFiLEtBQXRDLEVBQTZDMGdCLEtBQTdDLEVBQW9EbEYsT0FBcEQsRUFBNkRtRixTQUE3RCxFQUF3RTtBQUNoRixTQUFLRixTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFNBQUt6MkIsSUFBTCxHQUFZMHhCLFVBQVo7QUFDQSxTQUFLMWIsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBSzBnQixLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLbEYsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS21GLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0gsQ0FQRDtBQVFBSCxNQUFNMzRCLEtBQU4sR0FBYyxTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDeEMsUUFBSUQsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbEIsRUFBcUI7QUFDakIsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYyxvREFBb0R1bkIsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbEUsSUFBdUUsR0FBckYsQ0FBUDtBQUNIO0FBQ0QsUUFBSXVyQixLQUFLdnJCLE1BQUwsR0FBYyxDQUFkLEtBQW9CLENBQXhCLEVBQTJCO0FBQ3ZCLGVBQU93ckIsUUFBUXhuQixLQUFSLENBQWMsdUNBQWQsQ0FBUDtBQUNIO0FBQ0QsUUFBSW8zQixTQUFKO0FBQ0EsUUFBSS9FLFVBQUo7QUFDQSxRQUFJN0ssUUFBUUMsWUFBUixJQUF3QkQsUUFBUUMsWUFBUixDQUFxQnZGLElBQXJCLEtBQThCLE9BQTFELEVBQW1FO0FBQy9EbVEscUJBQWE3SyxRQUFRQyxZQUFyQjtBQUNIO0FBQ0QsUUFBSTRQLFFBQVEsRUFBWjtBQUNBLFFBQUlsRixVQUFVLEVBQWQ7QUFDQSxTQUFLLElBQUl4MkIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNHJCLEtBQUt2ckIsTUFBTCxHQUFjLENBQWxDLEVBQXFDTCxLQUFLLENBQTFDLEVBQTZDO0FBQ3pDLFlBQUk2WixTQUFTK1IsS0FBSzVyQixDQUFMLENBQWI7QUFDQSxZQUFJa00sUUFBUTBmLEtBQUs1ckIsSUFBSSxDQUFULENBQVo7QUFDQSxZQUFJLENBQUNFLE1BQU1DLE9BQU4sQ0FBYzBaLE1BQWQsQ0FBTCxFQUE0QjtBQUN4QkEscUJBQVMsQ0FBQ0EsTUFBRCxDQUFUO0FBQ0g7QUFDRCxZQUFJK2hCLGVBQWUvUCxRQUFRdFgsTUFBUixDQUFldlUsQ0FBZixDQUFuQjtBQUNBLFlBQUk2WixPQUFPeFosTUFBUCxLQUFrQixDQUF0QixFQUF5QjtBQUNyQixtQkFBT3U3QixhQUFhdjNCLEtBQWIsQ0FBbUIscUNBQW5CLENBQVA7QUFDSDtBQUNELGFBQUssSUFBSTBmLE1BQU0sQ0FBVixFQUFhSSxPQUFPdEssTUFBekIsRUFBaUNrSyxNQUFNSSxLQUFLOWpCLE1BQTVDLEVBQW9EMGpCLE9BQU8sQ0FBM0QsRUFBOEQ7QUFDMUQsZ0JBQUkwUyxRQUFRdFMsS0FBS0osR0FBTCxDQUFaO0FBQ0EsZ0JBQUksT0FBTzBTLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsT0FBT0EsS0FBUCxLQUFpQixRQUFsRCxFQUE0RDtBQUN4RCx1QkFBT21GLGFBQWF2M0IsS0FBYixDQUFtQiwyQ0FBbkIsQ0FBUDtBQUNILGFBRkQsTUFFTyxJQUFJLE9BQU9veUIsS0FBUCxLQUFpQixRQUFqQixJQUE2QmxkLEtBQUt0RixHQUFMLENBQVN3aUIsS0FBVCxJQUFrQjlJLE9BQU9rTyxnQkFBMUQsRUFBNEU7QUFDL0UsdUJBQU9ELGFBQWF2M0IsS0FBYixDQUFtQixtREFBbURzcEIsT0FBT2tPLGdCQUExRCxHQUE2RSxHQUFoRyxDQUFQO0FBQ0gsYUFGTSxNQUVBLElBQUksT0FBT3BGLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJsZCxLQUFLcEYsS0FBTCxDQUFXc2lCLEtBQVgsTUFBc0JBLEtBQXZELEVBQThEO0FBQ2pFLHVCQUFPbUYsYUFBYXYzQixLQUFiLENBQW1CLCtDQUFuQixDQUFQO0FBQ0gsYUFGTSxNQUVBLElBQUksQ0FBQ28zQixTQUFMLEVBQWdCO0FBQ25CQSw0QkFBWWhRLE9BQU9nTCxLQUFQLENBQVo7QUFDSCxhQUZNLE1BRUEsSUFBSW1GLGFBQWF2VSxZQUFiLENBQTBCb1UsU0FBMUIsRUFBcUNoUSxPQUFPZ0wsS0FBUCxDQUFyQyxDQUFKLEVBQXlEO0FBQzVELHVCQUFPLElBQVA7QUFDSDtBQUNELGdCQUFJLE9BQU9pRixNQUFNamlCLE9BQU9nZCxLQUFQLENBQU4sQ0FBUCxLQUFnQyxXQUFwQyxFQUFpRDtBQUM3Qyx1QkFBT21GLGFBQWF2M0IsS0FBYixDQUFtQiwrQkFBbkIsQ0FBUDtBQUNIO0FBQ0RxM0Isa0JBQU1qaUIsT0FBT2dkLEtBQVAsQ0FBTixJQUF1QkQsUUFBUW4yQixNQUEvQjtBQUNIO0FBQ0QsWUFBSW1YLFNBQVNxVSxRQUFRaHBCLEtBQVIsQ0FBY3FKLEtBQWQsRUFBcUJsTSxDQUFyQixFQUF3QjAyQixVQUF4QixDQUFiO0FBQ0EsWUFBSSxDQUFDbGYsTUFBTCxFQUFhO0FBQ1QsbUJBQU8sSUFBUDtBQUNIO0FBQ0RrZixxQkFBYUEsY0FBY2xmLE9BQU94UyxJQUFsQztBQUNBd3hCLGdCQUFReDFCLElBQVIsQ0FBYXdXLE1BQWI7QUFDSDtBQUNELFFBQUl3RCxRQUFRNlEsUUFBUWhwQixLQUFSLENBQWMrb0IsS0FBSyxDQUFMLENBQWQsRUFBdUIsQ0FBdkIsRUFBMEIvRSxTQUExQixDQUFaO0FBQ0EsUUFBSSxDQUFDN0wsS0FBTCxFQUFZO0FBQ1IsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJMmdCLFlBQVk5UCxRQUFRaHBCLEtBQVIsQ0FBYytvQixLQUFLQSxLQUFLdnJCLE1BQUwsR0FBYyxDQUFuQixDQUFkLEVBQXFDdXJCLEtBQUt2ckIsTUFBTCxHQUFjLENBQW5ELEVBQXNEcTJCLFVBQXRELENBQWhCO0FBQ0EsUUFBSSxDQUFDaUYsU0FBTCxFQUFnQjtBQUNaLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSTNnQixNQUFNaFcsSUFBTixDQUFXdWhCLElBQVgsS0FBb0IsT0FBcEIsSUFBK0JzRixRQUFRdFgsTUFBUixDQUFlLENBQWYsRUFBa0I4UyxZQUFsQixDQUErQm9VLFNBQS9CLEVBQTBDemdCLE1BQU1oVyxJQUFoRCxDQUFuQyxFQUEwRjtBQUN0RixlQUFPLElBQVA7QUFDSDtBQUNELFdBQU8sSUFBSXcyQixLQUFKLENBQVVDLFNBQVYsRUFBcUIvRSxVQUFyQixFQUFpQzFiLEtBQWpDLEVBQXdDMGdCLEtBQXhDLEVBQStDbEYsT0FBL0MsRUFBd0RtRixTQUF4RCxDQUFQO0FBQ0gsQ0E3REQ7QUE4REFILE1BQU12ZSxTQUFOLENBQWdCOE8sUUFBaEIsR0FBMkIsU0FBU0EsUUFBVCxDQUFrQlEsR0FBbEIsRUFBdUI7QUFDOUMsUUFBSXZSLFFBQVEsS0FBS0EsS0FBTCxDQUFXK1EsUUFBWCxDQUFvQlEsR0FBcEIsQ0FBWjtBQUNBLFFBQUl2UyxTQUFTeVIsT0FBT3pRLEtBQVAsTUFBa0IsS0FBS3lnQixTQUF2QixJQUFvQyxLQUFLakYsT0FBTCxDQUFhLEtBQUtrRixLQUFMLENBQVcxZ0IsS0FBWCxDQUFiLENBQXBDLElBQXVFLEtBQUsyZ0IsU0FBekY7QUFDQSxXQUFPM2hCLE9BQU8rUixRQUFQLENBQWdCUSxHQUFoQixDQUFQO0FBQ0gsQ0FKRDtBQUtBaVAsTUFBTXZlLFNBQU4sQ0FBZ0IrTyxTQUFoQixHQUE0QixTQUFTQSxTQUFULENBQW1CL1QsRUFBbkIsRUFBdUI7QUFDL0NBLE9BQUcsS0FBSytDLEtBQVI7QUFDQSxTQUFLd2IsT0FBTCxDQUFhalMsT0FBYixDQUFxQnRNLEVBQXJCO0FBQ0FBLE9BQUcsS0FBSzBqQixTQUFSO0FBQ0gsQ0FKRDtBQUtBSCxNQUFNdmUsU0FBTixDQUFnQmdQLGFBQWhCLEdBQWdDLFNBQVNBLGFBQVQsR0FBeUI7QUFDckQsV0FBTyxLQUFLdUssT0FBTCxDQUFhaEssS0FBYixDQUFtQixVQUFVdFIsR0FBVixFQUFlO0FBQ3JDLGVBQU9BLElBQUkrUSxhQUFKLEVBQVA7QUFDSCxLQUZNLEtBRUQsS0FBSzBQLFNBQUwsQ0FBZTFQLGFBQWYsRUFGTjtBQUdILENBSkQ7QUFLQXVQLE1BQU12ZSxTQUFOLENBQWdCZ08sU0FBaEIsR0FBNEIsU0FBU0EsU0FBVCxHQUFxQjtBQUM3QyxRQUFJNlEsU0FBUyxJQUFiO0FBQ0EsUUFBSTVRLGFBQWEsQ0FDYixPQURhLEVBRWIsS0FBS2xRLEtBQUwsQ0FBV2lRLFNBQVgsRUFGYSxDQUFqQjtBQUlBLFFBQUk4USxlQUFlMWtCLE9BQU9OLElBQVAsQ0FBWSxLQUFLMmtCLEtBQWpCLEVBQXdCTSxJQUF4QixFQUFuQjtBQUNBLFFBQUlDLGtCQUFrQixFQUF0QjtBQUNBLFFBQUlDLGVBQWUsRUFBbkI7QUFDQSxTQUFLLElBQUlsOEIsSUFBSSxDQUFSLEVBQVdta0IsT0FBTzRYLFlBQXZCLEVBQXFDLzdCLElBQUlta0IsS0FBSzlqQixNQUE5QyxFQUFzREwsS0FBSyxDQUEzRCxFQUE4RDtBQUMxRCxZQUFJeTJCLFFBQVF0UyxLQUFLbmtCLENBQUwsQ0FBWjtBQUNBLFlBQUltOEIsY0FBY0QsYUFBYSxLQUFLUixLQUFMLENBQVdqRixLQUFYLENBQWIsQ0FBbEI7QUFDQSxZQUFJMEYsZ0JBQWdCbjRCLFNBQXBCLEVBQStCO0FBQzNCazRCLHlCQUFhLEtBQUtSLEtBQUwsQ0FBV2pGLEtBQVgsQ0FBYixJQUFrQ3dGLGdCQUFnQjU3QixNQUFsRDtBQUNBNDdCLDRCQUFnQmo3QixJQUFoQixDQUFxQixDQUNqQixLQUFLMDZCLEtBQUwsQ0FBV2pGLEtBQVgsQ0FEaUIsRUFFakIsQ0FBQ0EsS0FBRCxDQUZpQixDQUFyQjtBQUlILFNBTkQsTUFNTztBQUNId0YsNEJBQWdCRSxXQUFoQixFQUE2QixDQUE3QixFQUFnQ243QixJQUFoQyxDQUFxQ3kxQixLQUFyQztBQUNIO0FBQ0o7QUFDRCxRQUFJMkYsY0FBYyxTQUFkQSxXQUFjLENBQVUzRixLQUFWLEVBQWlCO0FBQy9CLGVBQU9xRixPQUFPTCxTQUFQLENBQWlCbFYsSUFBakIsS0FBMEIsUUFBMUIsR0FBcUNvSCxPQUFPOEksS0FBUCxDQUFyQyxHQUFxREEsS0FBNUQ7QUFDSCxLQUZEO0FBR0EsU0FBSyxJQUFJMVMsTUFBTSxDQUFWLEVBQWF5SixTQUFTeU8sZUFBM0IsRUFBNENsWSxNQUFNeUosT0FBT250QixNQUF6RCxFQUFpRTBqQixPQUFPLENBQXhFLEVBQTJFO0FBQ3ZFLFlBQUk3ZCxNQUFNc25CLE9BQU96SixHQUFQLENBQVY7QUFDQSxZQUFJb1ksY0FBY2oyQixJQUFJLENBQUosQ0FBbEI7QUFDQSxZQUFJMlQsU0FBUzNULElBQUksQ0FBSixDQUFiO0FBQ0EsWUFBSTJULE9BQU94WixNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCNnFCLHVCQUFXbHFCLElBQVgsQ0FBZ0JvN0IsWUFBWXZpQixPQUFPLENBQVAsQ0FBWixDQUFoQjtBQUNILFNBRkQsTUFFTztBQUNIcVIsdUJBQVdscUIsSUFBWCxDQUFnQjZZLE9BQU9uWixHQUFQLENBQVcwN0IsV0FBWCxDQUFoQjtBQUNIO0FBQ0RsUixtQkFBV2xxQixJQUFYLENBQWdCLEtBQUt3MUIsT0FBTCxDQUFhNkYsYUFBYixFQUE0QnBSLFNBQTVCLEVBQWhCO0FBQ0g7QUFDREMsZUFBV2xxQixJQUFYLENBQWdCLEtBQUsyNkIsU0FBTCxDQUFlMVEsU0FBZixFQUFoQjtBQUNBLFdBQU9DLFVBQVA7QUFDSCxDQXRDRDs7QUF3Q0EsSUFBSW9SLE9BQU8sU0FBU0EsSUFBVCxDQUFjdDNCLElBQWQsRUFBb0J1M0IsUUFBcEIsRUFBOEJaLFNBQTlCLEVBQXlDO0FBQ2hELFNBQUszMkIsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS3UzQixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtaLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0gsQ0FKRDtBQUtBVyxLQUFLejVCLEtBQUwsR0FBYSxTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDdkMsUUFBSUQsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbEIsRUFBcUI7QUFDakIsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYyxvREFBb0R1bkIsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbEUsSUFBdUUsR0FBckYsQ0FBUDtBQUNIO0FBQ0QsUUFBSXVyQixLQUFLdnJCLE1BQUwsR0FBYyxDQUFkLEtBQW9CLENBQXhCLEVBQTJCO0FBQ3ZCLGVBQU93ckIsUUFBUXhuQixLQUFSLENBQWMsc0NBQWQsQ0FBUDtBQUNIO0FBQ0QsUUFBSXF5QixVQUFKO0FBQ0EsUUFBSTdLLFFBQVFDLFlBQVIsSUFBd0JELFFBQVFDLFlBQVIsQ0FBcUJ2RixJQUFyQixLQUE4QixPQUExRCxFQUFtRTtBQUMvRG1RLHFCQUFhN0ssUUFBUUMsWUFBckI7QUFDSDtBQUNELFFBQUl5USxXQUFXLEVBQWY7QUFDQSxTQUFLLElBQUl2OEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNHJCLEtBQUt2ckIsTUFBTCxHQUFjLENBQWxDLEVBQXFDTCxLQUFLLENBQTFDLEVBQTZDO0FBQ3pDLFlBQUlzYyxPQUFPdVAsUUFBUWhwQixLQUFSLENBQWMrb0IsS0FBSzVyQixDQUFMLENBQWQsRUFBdUJBLENBQXZCLEVBQTBCMG1CLFdBQTFCLENBQVg7QUFDQSxZQUFJLENBQUNwSyxJQUFMLEVBQVc7QUFDUCxtQkFBTyxJQUFQO0FBQ0g7QUFDRCxZQUFJOUUsU0FBU3FVLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUs1ckIsSUFBSSxDQUFULENBQWQsRUFBMkJBLElBQUksQ0FBL0IsRUFBa0MwMkIsVUFBbEMsQ0FBYjtBQUNBLFlBQUksQ0FBQ2xmLE1BQUwsRUFBYTtBQUNULG1CQUFPLElBQVA7QUFDSDtBQUNEK2tCLGlCQUFTdjdCLElBQVQsQ0FBYyxDQUNWc2IsSUFEVSxFQUVWOUUsTUFGVSxDQUFkO0FBSUFrZixxQkFBYUEsY0FBY2xmLE9BQU94UyxJQUFsQztBQUNIO0FBQ0QsUUFBSTIyQixZQUFZOVAsUUFBUWhwQixLQUFSLENBQWMrb0IsS0FBS0EsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBbkIsQ0FBZCxFQUFxQ3VyQixLQUFLdnJCLE1BQUwsR0FBYyxDQUFuRCxFQUFzRHEyQixVQUF0RCxDQUFoQjtBQUNBLFFBQUksQ0FBQ2lGLFNBQUwsRUFBZ0I7QUFDWixlQUFPLElBQVA7QUFDSDtBQUNELFdBQU8sSUFBSVcsSUFBSixDQUFTNUYsVUFBVCxFQUFxQjZGLFFBQXJCLEVBQStCWixTQUEvQixDQUFQO0FBQ0gsQ0FoQ0Q7QUFpQ0FXLEtBQUtyZixTQUFMLENBQWU4TyxRQUFmLEdBQTBCLFNBQVNBLFFBQVQsQ0FBa0JRLEdBQWxCLEVBQXVCO0FBQzdDLFNBQUssSUFBSXZzQixJQUFJLENBQVIsRUFBV21rQixPQUFPLEtBQUtvWSxRQUE1QixFQUFzQ3Y4QixJQUFJbWtCLEtBQUs5akIsTUFBL0MsRUFBdURMLEtBQUssQ0FBNUQsRUFBK0Q7QUFDM0QsWUFBSWtHLE1BQU1pZSxLQUFLbmtCLENBQUwsQ0FBVjtBQUNBLFlBQUlzYyxPQUFPcFcsSUFBSSxDQUFKLENBQVg7QUFDQSxZQUFJeUosYUFBYXpKLElBQUksQ0FBSixDQUFqQjtBQUNBLFlBQUlvVyxLQUFLeVAsUUFBTCxDQUFjUSxHQUFkLENBQUosRUFBd0I7QUFDcEIsbUJBQU81YyxXQUFXb2MsUUFBWCxDQUFvQlEsR0FBcEIsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPLEtBQUtvUCxTQUFMLENBQWU1UCxRQUFmLENBQXdCUSxHQUF4QixDQUFQO0FBQ0gsQ0FWRDtBQVdBK1AsS0FBS3JmLFNBQUwsQ0FBZStPLFNBQWYsR0FBMkIsU0FBU0EsU0FBVCxDQUFtQi9ULEVBQW5CLEVBQXVCO0FBQzlDLFNBQUssSUFBSWpZLElBQUksQ0FBUixFQUFXbWtCLE9BQU8sS0FBS29ZLFFBQTVCLEVBQXNDdjhCLElBQUlta0IsS0FBSzlqQixNQUEvQyxFQUF1REwsS0FBSyxDQUE1RCxFQUErRDtBQUMzRCxZQUFJa0csTUFBTWllLEtBQUtua0IsQ0FBTCxDQUFWO0FBQ0EsWUFBSXNjLE9BQU9wVyxJQUFJLENBQUosQ0FBWDtBQUNBLFlBQUl5SixhQUFhekosSUFBSSxDQUFKLENBQWpCO0FBQ0ErUixXQUFHcUUsSUFBSDtBQUNBckUsV0FBR3RJLFVBQUg7QUFDSDtBQUNEc0ksT0FBRyxLQUFLMGpCLFNBQVI7QUFDSCxDQVREO0FBVUFXLEtBQUtyZixTQUFMLENBQWVnUCxhQUFmLEdBQStCLFNBQVNBLGFBQVQsR0FBeUI7QUFDcEQsV0FBTyxLQUFLc1EsUUFBTCxDQUFjL1AsS0FBZCxDQUFvQixVQUFVdG1CLEdBQVYsRUFBZTtBQUN0QyxZQUFJczJCLElBQUl0MkIsSUFBSSxDQUFKLENBQVI7QUFDQSxZQUFJZ1YsTUFBTWhWLElBQUksQ0FBSixDQUFWO0FBQ0EsZUFBT2dWLElBQUkrUSxhQUFKLEVBQVA7QUFDSCxLQUpNLEtBSUQsS0FBSzBQLFNBQUwsQ0FBZTFQLGFBQWYsRUFKTjtBQUtILENBTkQ7QUFPQXFRLEtBQUtyZixTQUFMLENBQWVnTyxTQUFmLEdBQTJCLFNBQVNBLFNBQVQsR0FBcUI7QUFDNUMsUUFBSUMsYUFBYSxDQUFDLE1BQUQsQ0FBakI7QUFDQSxTQUFLYyxTQUFMLENBQWUsVUFBVTZCLEtBQVYsRUFBaUI7QUFDNUIzQyxtQkFBV2xxQixJQUFYLENBQWdCNnNCLE1BQU01QyxTQUFOLEVBQWhCO0FBQ0gsS0FGRDtBQUdBLFdBQU9DLFVBQVA7QUFDSCxDQU5EOztBQVFBLElBQUl1UixRQUFRLFNBQVNBLEtBQVQsQ0FBZXozQixJQUFmLEVBQXFCZ1csS0FBckIsRUFBNEIwaEIsVUFBNUIsRUFBd0NDLFFBQXhDLEVBQWtEO0FBQzFELFNBQUszM0IsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS2dXLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUswaEIsVUFBTCxHQUFrQkEsVUFBbEI7QUFDQSxTQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNILENBTEQ7QUFNQUYsTUFBTTU1QixLQUFOLEdBQWMsU0FBU0EsS0FBVCxDQUFlK29CLElBQWYsRUFBcUJDLE9BQXJCLEVBQThCO0FBQ3hDLFFBQUlELEtBQUt2ckIsTUFBTCxJQUFlLENBQWYsSUFBb0J1ckIsS0FBS3ZyQixNQUFMLElBQWUsQ0FBdkMsRUFBMEM7QUFDdEMsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYywyQ0FBMkN1bkIsS0FBS3ZyQixNQUFMLEdBQWMsQ0FBekQsSUFBOEQsV0FBNUUsQ0FBUDtBQUNIO0FBQ0QsUUFBSTJhLFFBQVE2USxRQUFRaHBCLEtBQVIsQ0FBYytvQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQi9FLFNBQTFCLENBQVo7QUFDQSxRQUFJNlYsYUFBYTdRLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCcEYsVUFBMUIsQ0FBakI7QUFDQSxRQUFJLENBQUN4TCxLQUFELElBQVUsQ0FBQzBoQixVQUFmLEVBQTJCO0FBQ3ZCLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSSxDQUFDbFYsWUFBWXhNLE1BQU1oVyxJQUFsQixFQUF3QixDQUNyQnFOLE1BQU13VSxTQUFOLENBRHFCLEVBRXJCSixVQUZxQixFQUdyQkksU0FIcUIsQ0FBeEIsQ0FBTCxFQUlRO0FBQ0osZUFBT2dGLFFBQVF4bkIsS0FBUixDQUFjLHNFQUFzRXFCLFNBQVNzVixNQUFNaFcsSUFBZixDQUF0RSxHQUE2RixVQUEzRyxDQUFQO0FBQ0g7QUFDRCxRQUFJNG1CLEtBQUt2ckIsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQixZQUFJczhCLFdBQVc5USxRQUFRaHBCLEtBQVIsQ0FBYytvQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQnBGLFVBQTFCLENBQWY7QUFDQSxZQUFJLENBQUNtVyxRQUFMLEVBQWU7QUFDWCxtQkFBTyxJQUFQO0FBQ0g7QUFDRCxlQUFPLElBQUlGLEtBQUosQ0FBVXpoQixNQUFNaFcsSUFBaEIsRUFBc0JnVyxLQUF0QixFQUE2QjBoQixVQUE3QixFQUF5Q0MsUUFBekMsQ0FBUDtBQUNILEtBTkQsTUFNTztBQUNILGVBQU8sSUFBSUYsS0FBSixDQUFVemhCLE1BQU1oVyxJQUFoQixFQUFzQmdXLEtBQXRCLEVBQTZCMGhCLFVBQTdCLENBQVA7QUFDSDtBQUNKLENBekJEO0FBMEJBRCxNQUFNeGYsU0FBTixDQUFnQjhPLFFBQWhCLEdBQTJCLFNBQVNBLFFBQVQsQ0FBa0JRLEdBQWxCLEVBQXVCO0FBQzlDLFFBQUl2UixRQUFRLEtBQUtBLEtBQUwsQ0FBVytRLFFBQVgsQ0FBb0JRLEdBQXBCLENBQVo7QUFDQSxRQUFJbVEsYUFBYSxLQUFLQSxVQUFMLENBQWdCM1EsUUFBaEIsQ0FBeUJRLEdBQXpCLENBQWpCO0FBQ0EsUUFBSSxDQUFDNUUsa0JBQWtCM00sS0FBbEIsRUFBeUIsQ0FDdEIsUUFEc0IsRUFFdEIsT0FGc0IsQ0FBekIsQ0FBTCxFQUdRO0FBQ0osY0FBTSxJQUFJa1IsWUFBSixDQUFpQixzRUFBc0V4bUIsU0FBUytsQixPQUFPelEsS0FBUCxDQUFULENBQXRFLEdBQWdHLFdBQWpILENBQU47QUFDSDtBQUNELFFBQUksS0FBSzJoQixRQUFULEVBQW1CO0FBQ2YsWUFBSUEsV0FBVyxLQUFLQSxRQUFMLENBQWM1USxRQUFkLENBQXVCUSxHQUF2QixDQUFmO0FBQ0EsZUFBT3ZSLE1BQU03UCxLQUFOLENBQVl1eEIsVUFBWixFQUF3QkMsUUFBeEIsQ0FBUDtBQUNIO0FBQ0QsV0FBTzNoQixNQUFNN1AsS0FBTixDQUFZdXhCLFVBQVosQ0FBUDtBQUNILENBZEQ7QUFlQUQsTUFBTXhmLFNBQU4sQ0FBZ0IrTyxTQUFoQixHQUE0QixTQUFTQSxTQUFULENBQW1CL1QsRUFBbkIsRUFBdUI7QUFDL0NBLE9BQUcsS0FBSytDLEtBQVI7QUFDQS9DLE9BQUcsS0FBS3lrQixVQUFSO0FBQ0EsUUFBSSxLQUFLQyxRQUFULEVBQW1CO0FBQ2Yxa0IsV0FBRyxLQUFLMGtCLFFBQVI7QUFDSDtBQUNKLENBTkQ7QUFPQUYsTUFBTXhmLFNBQU4sQ0FBZ0JnUCxhQUFoQixHQUFnQyxTQUFTQSxhQUFULEdBQXlCO0FBQ3JELFdBQU8sS0FBUDtBQUNILENBRkQ7QUFHQXdRLE1BQU14ZixTQUFOLENBQWdCZ08sU0FBaEIsR0FBNEIsU0FBU0EsU0FBVCxHQUFxQjtBQUM3QyxRQUFJLEtBQUswUixRQUFMLElBQWlCLElBQWpCLElBQXlCLEtBQUtBLFFBQUwsS0FBa0IzNEIsU0FBL0MsRUFBMEQ7QUFDdEQsWUFBSTI0QixXQUFXLEtBQUtBLFFBQUwsQ0FBYzFSLFNBQWQsRUFBZjtBQUNBLGVBQU8sQ0FDSCxPQURHLEVBRUgsS0FBS2pRLEtBQUwsQ0FBV2lRLFNBQVgsRUFGRyxFQUdILEtBQUt5UixVQUFMLENBQWdCelIsU0FBaEIsRUFIRyxFQUlIMFIsUUFKRyxDQUFQO0FBTUg7QUFDRCxXQUFPLENBQ0gsT0FERyxFQUVILEtBQUszaEIsS0FBTCxDQUFXaVEsU0FBWCxFQUZHLEVBR0gsS0FBS3lSLFVBQUwsQ0FBZ0J6UixTQUFoQixFQUhHLENBQVA7QUFLSCxDQWZEOztBQWlCQSxTQUFTMlIsZ0JBQVQsQ0FBMEJoVSxFQUExQixFQUE4QjVqQixJQUE5QixFQUFvQztBQUNoQyxRQUFJNGpCLE9BQU8sSUFBUCxJQUFlQSxPQUFPLElBQTFCLEVBQWdDO0FBQzVCLGVBQU81akIsS0FBS3VoQixJQUFMLEtBQWMsU0FBZCxJQUEyQnZoQixLQUFLdWhCLElBQUwsS0FBYyxRQUF6QyxJQUFxRHZoQixLQUFLdWhCLElBQUwsS0FBYyxRQUFuRSxJQUErRXZoQixLQUFLdWhCLElBQUwsS0FBYyxNQUE3RixJQUF1R3ZoQixLQUFLdWhCLElBQUwsS0FBYyxPQUE1SDtBQUNILEtBRkQsTUFFTztBQUNILGVBQU92aEIsS0FBS3VoQixJQUFMLEtBQWMsUUFBZCxJQUEwQnZoQixLQUFLdWhCLElBQUwsS0FBYyxRQUF4QyxJQUFvRHZoQixLQUFLdWhCLElBQUwsS0FBYyxPQUF6RTtBQUNIO0FBQ0o7QUFDRCxTQUFTbEosRUFBVCxDQUFZa1AsR0FBWixFQUFpQnRoQixDQUFqQixFQUFvQmtlLENBQXBCLEVBQXVCO0FBQ25CLFdBQU9sZSxNQUFNa2UsQ0FBYjtBQUNIO0FBQ0QsU0FBUzBULEdBQVQsQ0FBYXRRLEdBQWIsRUFBa0J0aEIsQ0FBbEIsRUFBcUJrZSxDQUFyQixFQUF3QjtBQUNwQixXQUFPbGUsTUFBTWtlLENBQWI7QUFDSDtBQUNELFNBQVMyVCxFQUFULENBQVl2USxHQUFaLEVBQWlCdGhCLENBQWpCLEVBQW9Ca2UsQ0FBcEIsRUFBdUI7QUFDbkIsV0FBT2xlLElBQUlrZSxDQUFYO0FBQ0g7QUFDRCxTQUFTNFQsRUFBVCxDQUFZeFEsR0FBWixFQUFpQnRoQixDQUFqQixFQUFvQmtlLENBQXBCLEVBQXVCO0FBQ25CLFdBQU9sZSxJQUFJa2UsQ0FBWDtBQUNIO0FBQ0QsU0FBUzZULElBQVQsQ0FBY3pRLEdBQWQsRUFBbUJ0aEIsQ0FBbkIsRUFBc0JrZSxDQUF0QixFQUF5QjtBQUNyQixXQUFPbGUsS0FBS2tlLENBQVo7QUFDSDtBQUNELFNBQVM4VCxJQUFULENBQWMxUSxHQUFkLEVBQW1CdGhCLENBQW5CLEVBQXNCa2UsQ0FBdEIsRUFBeUI7QUFDckIsV0FBT2xlLEtBQUtrZSxDQUFaO0FBQ0g7QUFDRCxTQUFTK1QsU0FBVCxDQUFtQjNRLEdBQW5CLEVBQXdCdGhCLENBQXhCLEVBQTJCa2UsQ0FBM0IsRUFBOEJtRSxDQUE5QixFQUFpQztBQUM3QixXQUFPQSxFQUFFdEQsT0FBRixDQUFVL2UsQ0FBVixFQUFha2UsQ0FBYixNQUFvQixDQUEzQjtBQUNIO0FBQ0QsU0FBU2dVLFVBQVQsQ0FBb0I1USxHQUFwQixFQUF5QnRoQixDQUF6QixFQUE0QmtlLENBQTVCLEVBQStCbUUsQ0FBL0IsRUFBa0M7QUFDOUIsV0FBTyxDQUFDNFAsVUFBVTNRLEdBQVYsRUFBZXRoQixDQUFmLEVBQWtCa2UsQ0FBbEIsRUFBcUJtRSxDQUFyQixDQUFSO0FBQ0g7QUFDRCxTQUFTOFAsU0FBVCxDQUFtQjdRLEdBQW5CLEVBQXdCdGhCLENBQXhCLEVBQTJCa2UsQ0FBM0IsRUFBOEJtRSxDQUE5QixFQUFpQztBQUM3QixXQUFPQSxFQUFFdEQsT0FBRixDQUFVL2UsQ0FBVixFQUFha2UsQ0FBYixJQUFrQixDQUF6QjtBQUNIO0FBQ0QsU0FBU2tVLFNBQVQsQ0FBbUI5USxHQUFuQixFQUF3QnRoQixDQUF4QixFQUEyQmtlLENBQTNCLEVBQThCbUUsQ0FBOUIsRUFBaUM7QUFDN0IsV0FBT0EsRUFBRXRELE9BQUYsQ0FBVS9lLENBQVYsRUFBYWtlLENBQWIsSUFBa0IsQ0FBekI7QUFDSDtBQUNELFNBQVNtVSxXQUFULENBQXFCL1EsR0FBckIsRUFBMEJ0aEIsQ0FBMUIsRUFBNkJrZSxDQUE3QixFQUFnQ21FLENBQWhDLEVBQW1DO0FBQy9CLFdBQU9BLEVBQUV0RCxPQUFGLENBQVUvZSxDQUFWLEVBQWFrZSxDQUFiLEtBQW1CLENBQTFCO0FBQ0g7QUFDRCxTQUFTb1UsV0FBVCxDQUFxQmhSLEdBQXJCLEVBQTBCdGhCLENBQTFCLEVBQTZCa2UsQ0FBN0IsRUFBZ0NtRSxDQUFoQyxFQUFtQztBQUMvQixXQUFPQSxFQUFFdEQsT0FBRixDQUFVL2UsQ0FBVixFQUFha2UsQ0FBYixLQUFtQixDQUExQjtBQUNIO0FBQ0QsU0FBU3FVLGNBQVQsQ0FBd0I1VSxFQUF4QixFQUE0QjZVLFlBQTVCLEVBQTBDQyxtQkFBMUMsRUFBK0Q7QUFDM0QsUUFBSUMsb0JBQW9CL1UsT0FBTyxJQUFQLElBQWVBLE9BQU8sSUFBOUM7QUFDQSxXQUFPLFlBQVk7QUFDZixpQkFBU2dWLFVBQVQsQ0FBb0IzVCxHQUFwQixFQUF5QkMsR0FBekIsRUFBOEJsWCxRQUE5QixFQUF3QztBQUNwQyxpQkFBS2hPLElBQUwsR0FBWTBoQixXQUFaO0FBQ0EsaUJBQUt1RCxHQUFMLEdBQVdBLEdBQVg7QUFDQSxpQkFBS0MsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsaUJBQUtsWCxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLGlCQUFLNnFCLGtCQUFMLEdBQTBCNVQsSUFBSWpsQixJQUFKLENBQVN1aEIsSUFBVCxLQUFrQixPQUFsQixJQUE2QjJELElBQUlsbEIsSUFBSixDQUFTdWhCLElBQVQsS0FBa0IsT0FBekU7QUFDSDtBQUNEcVgsbUJBQVcvNkIsS0FBWCxHQUFtQixTQUFTQSxLQUFULENBQWUrb0IsSUFBZixFQUFxQkMsT0FBckIsRUFBOEI7QUFDN0MsZ0JBQUlELEtBQUt2ckIsTUFBTCxLQUFnQixDQUFoQixJQUFxQnVyQixLQUFLdnJCLE1BQUwsS0FBZ0IsQ0FBekMsRUFBNEM7QUFDeEMsdUJBQU93ckIsUUFBUXhuQixLQUFSLENBQWMsa0NBQWQsQ0FBUDtBQUNIO0FBQ0QsZ0JBQUl1a0IsS0FBS2dELEtBQUssQ0FBTCxDQUFUO0FBQ0EsZ0JBQUkzQixNQUFNNEIsUUFBUWhwQixLQUFSLENBQWMrb0IsS0FBSyxDQUFMLENBQWQsRUFBdUIsQ0FBdkIsRUFBMEIvRSxTQUExQixDQUFWO0FBQ0EsZ0JBQUksQ0FBQ29ELEdBQUwsRUFBVTtBQUNOLHVCQUFPLElBQVA7QUFDSDtBQUNELGdCQUFJLENBQUMyUyxpQkFBaUJoVSxFQUFqQixFQUFxQnFCLElBQUlqbEIsSUFBekIsQ0FBTCxFQUFxQztBQUNqQyx1QkFBTzZtQixRQUFRdFgsTUFBUixDQUFlLENBQWYsRUFBa0JsUSxLQUFsQixDQUF3QixNQUFNdWtCLEVBQU4sR0FBVyw2Q0FBWCxHQUEyRGxqQixTQUFTdWtCLElBQUlqbEIsSUFBYixDQUEzRCxHQUFnRixLQUF4RyxDQUFQO0FBQ0g7QUFDRCxnQkFBSWtsQixNQUFNMkIsUUFBUWhwQixLQUFSLENBQWMrb0IsS0FBSyxDQUFMLENBQWQsRUFBdUIsQ0FBdkIsRUFBMEIvRSxTQUExQixDQUFWO0FBQ0EsZ0JBQUksQ0FBQ3FELEdBQUwsRUFBVTtBQUNOLHVCQUFPLElBQVA7QUFDSDtBQUNELGdCQUFJLENBQUMwUyxpQkFBaUJoVSxFQUFqQixFQUFxQnNCLElBQUlsbEIsSUFBekIsQ0FBTCxFQUFxQztBQUNqQyx1QkFBTzZtQixRQUFRdFgsTUFBUixDQUFlLENBQWYsRUFBa0JsUSxLQUFsQixDQUF3QixNQUFNdWtCLEVBQU4sR0FBVyw2Q0FBWCxHQUEyRGxqQixTQUFTd2tCLElBQUlsbEIsSUFBYixDQUEzRCxHQUFnRixLQUF4RyxDQUFQO0FBQ0g7QUFDRCxnQkFBSWlsQixJQUFJamxCLElBQUosQ0FBU3VoQixJQUFULEtBQWtCMkQsSUFBSWxsQixJQUFKLENBQVN1aEIsSUFBM0IsSUFBbUMwRCxJQUFJamxCLElBQUosQ0FBU3VoQixJQUFULEtBQWtCLE9BQXJELElBQWdFMkQsSUFBSWxsQixJQUFKLENBQVN1aEIsSUFBVCxLQUFrQixPQUF0RixFQUErRjtBQUMzRix1QkFBT3NGLFFBQVF4bkIsS0FBUixDQUFjLDRCQUE0QnFCLFNBQVN1a0IsSUFBSWpsQixJQUFiLENBQTVCLEdBQWlELFdBQWpELEdBQStEVSxTQUFTd2tCLElBQUlsbEIsSUFBYixDQUEvRCxHQUFvRixLQUFsRyxDQUFQO0FBQ0g7QUFDRCxnQkFBSTI0QixpQkFBSixFQUF1QjtBQUNuQixvQkFBSTFULElBQUlqbEIsSUFBSixDQUFTdWhCLElBQVQsS0FBa0IsT0FBbEIsSUFBNkIyRCxJQUFJbGxCLElBQUosQ0FBU3VoQixJQUFULEtBQWtCLE9BQW5ELEVBQTREO0FBQ3hEMEQsMEJBQU0sSUFBSW1DLFNBQUosQ0FBY2xDLElBQUlsbEIsSUFBbEIsRUFBd0IsQ0FBQ2lsQixHQUFELENBQXhCLENBQU47QUFDSCxpQkFGRCxNQUVPLElBQUlBLElBQUlqbEIsSUFBSixDQUFTdWhCLElBQVQsS0FBa0IsT0FBbEIsSUFBNkIyRCxJQUFJbGxCLElBQUosQ0FBU3VoQixJQUFULEtBQWtCLE9BQW5ELEVBQTREO0FBQy9EMkQsMEJBQU0sSUFBSWtDLFNBQUosQ0FBY25DLElBQUlqbEIsSUFBbEIsRUFBd0IsQ0FBQ2tsQixHQUFELENBQXhCLENBQU47QUFDSDtBQUNKO0FBQ0QsZ0JBQUlsWCxXQUFXLElBQWY7QUFDQSxnQkFBSTRZLEtBQUt2ckIsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQixvQkFBSTRwQixJQUFJamxCLElBQUosQ0FBU3VoQixJQUFULEtBQWtCLFFBQWxCLElBQThCMkQsSUFBSWxsQixJQUFKLENBQVN1aEIsSUFBVCxLQUFrQixRQUFoRCxJQUE0RDBELElBQUlqbEIsSUFBSixDQUFTdWhCLElBQVQsS0FBa0IsT0FBOUUsSUFBeUYyRCxJQUFJbGxCLElBQUosQ0FBU3VoQixJQUFULEtBQWtCLE9BQS9HLEVBQXdIO0FBQ3BILDJCQUFPc0YsUUFBUXhuQixLQUFSLENBQWMsa0RBQWQsQ0FBUDtBQUNIO0FBQ0QyTywyQkFBVzZZLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCN0UsWUFBMUIsQ0FBWDtBQUNBLG9CQUFJLENBQUMvVCxRQUFMLEVBQWU7QUFDWCwyQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELG1CQUFPLElBQUk0cUIsVUFBSixDQUFlM1QsR0FBZixFQUFvQkMsR0FBcEIsRUFBeUJsWCxRQUF6QixDQUFQO0FBQ0gsU0F4Q0Q7QUF5Q0E0cUIsbUJBQVczZ0IsU0FBWCxDQUFxQjhPLFFBQXJCLEdBQWdDLFNBQVNBLFFBQVQsQ0FBa0JRLEdBQWxCLEVBQXVCO0FBQ25ELGdCQUFJdEMsTUFBTSxLQUFLQSxHQUFMLENBQVM4QixRQUFULENBQWtCUSxHQUFsQixDQUFWO0FBQ0EsZ0JBQUlyQyxNQUFNLEtBQUtBLEdBQUwsQ0FBUzZCLFFBQVQsQ0FBa0JRLEdBQWxCLENBQVY7QUFDQSxnQkFBSW9SLHFCQUFxQixLQUFLRSxrQkFBOUIsRUFBa0Q7QUFDOUMsb0JBQUlmLEtBQUtyUixPQUFPeEIsR0FBUCxDQUFUO0FBQ0Esb0JBQUk2VCxLQUFLclMsT0FBT3ZCLEdBQVAsQ0FBVDtBQUNBLG9CQUFJNFMsR0FBR3ZXLElBQUgsS0FBWXVYLEdBQUd2WCxJQUFmLElBQXVCLEVBQUV1VyxHQUFHdlcsSUFBSCxLQUFZLFFBQVosSUFBd0J1VyxHQUFHdlcsSUFBSCxLQUFZLFFBQXRDLENBQTNCLEVBQTRFO0FBQ3hFLDBCQUFNLElBQUkyRixZQUFKLENBQWlCLDZCQUE2QnRELEVBQTdCLEdBQWtDLDJEQUFsQyxHQUFnR2tVLEdBQUd2VyxJQUFuRyxHQUEwRyxJQUExRyxHQUFpSHVYLEdBQUd2WCxJQUFwSCxHQUEySCxZQUE1SSxDQUFOO0FBQ0g7QUFDSjtBQUNELGdCQUFJLEtBQUt2VCxRQUFMLElBQWlCLENBQUMycUIsaUJBQWxCLElBQXVDLEtBQUtFLGtCQUFoRCxFQUFvRTtBQUNoRSxvQkFBSUUsT0FBT3RTLE9BQU94QixHQUFQLENBQVg7QUFDQSxvQkFBSStULE9BQU92UyxPQUFPdkIsR0FBUCxDQUFYO0FBQ0Esb0JBQUk2VCxLQUFLeFgsSUFBTCxLQUFjLFFBQWQsSUFBMEJ5WCxLQUFLelgsSUFBTCxLQUFjLFFBQTVDLEVBQXNEO0FBQ2xELDJCQUFPa1gsYUFBYWxSLEdBQWIsRUFBa0J0QyxHQUFsQixFQUF1QkMsR0FBdkIsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxtQkFBTyxLQUFLbFgsUUFBTCxHQUFnQjBxQixvQkFBb0JuUixHQUFwQixFQUF5QnRDLEdBQXpCLEVBQThCQyxHQUE5QixFQUFtQyxLQUFLbFgsUUFBTCxDQUFjK1ksUUFBZCxDQUF1QlEsR0FBdkIsQ0FBbkMsQ0FBaEIsR0FBa0ZrUixhQUFhbFIsR0FBYixFQUFrQnRDLEdBQWxCLEVBQXVCQyxHQUF2QixDQUF6RjtBQUNILFNBbEJEO0FBbUJBMFQsbUJBQVczZ0IsU0FBWCxDQUFxQitPLFNBQXJCLEdBQWlDLFNBQVNBLFNBQVQsQ0FBbUIvVCxFQUFuQixFQUF1QjtBQUNwREEsZUFBRyxLQUFLZ1MsR0FBUjtBQUNBaFMsZUFBRyxLQUFLaVMsR0FBUjtBQUNBLGdCQUFJLEtBQUtsWCxRQUFULEVBQW1CO0FBQ2ZpRixtQkFBRyxLQUFLakYsUUFBUjtBQUNIO0FBQ0osU0FORDtBQU9BNHFCLG1CQUFXM2dCLFNBQVgsQ0FBcUJnUCxhQUFyQixHQUFxQyxTQUFTQSxhQUFULEdBQXlCO0FBQzFELG1CQUFPLElBQVA7QUFDSCxTQUZEO0FBR0EyUixtQkFBVzNnQixTQUFYLENBQXFCZ08sU0FBckIsR0FBaUMsU0FBU0EsU0FBVCxHQUFxQjtBQUNsRCxnQkFBSUMsYUFBYSxDQUFDdEMsRUFBRCxDQUFqQjtBQUNBLGlCQUFLb0QsU0FBTCxDQUFlLFVBQVU2QixLQUFWLEVBQWlCO0FBQzVCM0MsMkJBQVdscUIsSUFBWCxDQUFnQjZzQixNQUFNNUMsU0FBTixFQUFoQjtBQUNILGFBRkQ7QUFHQSxtQkFBT0MsVUFBUDtBQUNILFNBTkQ7QUFPQSxlQUFPMFMsVUFBUDtBQUNILEtBdEZNLEVBQVA7QUF1Rkg7QUFDRCxJQUFJSyxTQUFTVCxlQUFlLElBQWYsRUFBcUJuZ0IsRUFBckIsRUFBeUI2ZixTQUF6QixDQUFiO0FBQ0EsSUFBSWdCLFlBQVlWLGVBQWUsSUFBZixFQUFxQlgsR0FBckIsRUFBMEJNLFVBQTFCLENBQWhCO0FBQ0EsSUFBSWdCLFdBQVdYLGVBQWUsR0FBZixFQUFvQlYsRUFBcEIsRUFBd0JNLFNBQXhCLENBQWY7QUFDQSxJQUFJZ0IsY0FBY1osZUFBZSxHQUFmLEVBQW9CVCxFQUFwQixFQUF3Qk0sU0FBeEIsQ0FBbEI7QUFDQSxJQUFJZ0Isa0JBQWtCYixlQUFlLElBQWYsRUFBcUJSLElBQXJCLEVBQTJCTSxXQUEzQixDQUF0QjtBQUNBLElBQUlnQixxQkFBcUJkLGVBQWUsSUFBZixFQUFxQlAsSUFBckIsRUFBMkJNLFdBQTNCLENBQXpCOztBQUVBLElBQUlnQixlQUFlLFNBQVNBLFlBQVQsQ0FBc0IxckIsTUFBdEIsRUFBOEIrVyxNQUE5QixFQUFzQzRVLFFBQXRDLEVBQWdEQyxpQkFBaEQsRUFBbUVDLGlCQUFuRSxFQUFzRjtBQUNyRyxTQUFLMTVCLElBQUwsR0FBWXloQixVQUFaO0FBQ0EsU0FBSzVULE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUsrVyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLNFUsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxTQUFLQyxpQkFBTCxHQUF5QkEsaUJBQXpCO0FBQ0EsU0FBS0MsaUJBQUwsR0FBeUJBLGlCQUF6QjtBQUNILENBUEQ7QUFRQUgsYUFBYTE3QixLQUFiLEdBQXFCLFNBQVNBLEtBQVQsQ0FBZStvQixJQUFmLEVBQXFCQyxPQUFyQixFQUE4QjtBQUMvQyxRQUFJRCxLQUFLdnJCLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsZUFBT3dyQixRQUFReG5CLEtBQVIsQ0FBYyx5QkFBZCxDQUFQO0FBQ0g7QUFDRCxRQUFJd08sU0FBU2daLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCcEYsVUFBMUIsQ0FBYjtBQUNBLFFBQUksQ0FBQzNULE1BQUwsRUFBYTtBQUNULGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSXFELFVBQVUwVixLQUFLLENBQUwsQ0FBZDtBQUNBLFFBQUksUUFBTzFWLE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0JoVyxNQUFNQyxPQUFOLENBQWMrVixPQUFkLENBQW5DLEVBQTJEO0FBQ3ZELGVBQU8yVixRQUFReG5CLEtBQVIsQ0FBYyxrREFBZCxDQUFQO0FBQ0g7QUFDRCxRQUFJdWxCLFNBQVMsSUFBYjtBQUNBLFFBQUkxVCxRQUFRLFFBQVIsQ0FBSixFQUF1QjtBQUNuQjBULGlCQUFTaUMsUUFBUWhwQixLQUFSLENBQWNxVCxRQUFRLFFBQVIsQ0FBZCxFQUFpQyxDQUFqQyxFQUFvQ3VRLFVBQXBDLENBQVQ7QUFDQSxZQUFJLENBQUNtRCxNQUFMLEVBQWE7QUFDVCxtQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELFFBQUk0VSxXQUFXLElBQWY7QUFDQSxRQUFJdG9CLFFBQVEsVUFBUixDQUFKLEVBQXlCO0FBQ3JCc29CLG1CQUFXM1MsUUFBUWhwQixLQUFSLENBQWNxVCxRQUFRLFVBQVIsQ0FBZCxFQUFtQyxDQUFuQyxFQUFzQ3VRLFVBQXRDLENBQVg7QUFDQSxZQUFJLENBQUMrWCxRQUFMLEVBQWU7QUFDWCxtQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELFFBQUlDLG9CQUFvQixJQUF4QjtBQUNBLFFBQUl2b0IsUUFBUSxxQkFBUixDQUFKLEVBQW9DO0FBQ2hDdW9CLDRCQUFvQjVTLFFBQVFocEIsS0FBUixDQUFjcVQsUUFBUSxxQkFBUixDQUFkLEVBQThDLENBQTlDLEVBQWlEc1EsVUFBakQsQ0FBcEI7QUFDQSxZQUFJLENBQUNpWSxpQkFBTCxFQUF3QjtBQUNwQixtQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELFFBQUlDLG9CQUFvQixJQUF4QjtBQUNBLFFBQUl4b0IsUUFBUSxxQkFBUixDQUFKLEVBQW9DO0FBQ2hDd29CLDRCQUFvQjdTLFFBQVFocEIsS0FBUixDQUFjcVQsUUFBUSxxQkFBUixDQUFkLEVBQThDLENBQTlDLEVBQWlEc1EsVUFBakQsQ0FBcEI7QUFDQSxZQUFJLENBQUNrWSxpQkFBTCxFQUF3QjtBQUNwQixtQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELFdBQU8sSUFBSUgsWUFBSixDQUFpQjFyQixNQUFqQixFQUF5QitXLE1BQXpCLEVBQWlDNFUsUUFBakMsRUFBMkNDLGlCQUEzQyxFQUE4REMsaUJBQTlELENBQVA7QUFDSCxDQXpDRDtBQTBDQUgsYUFBYXRoQixTQUFiLENBQXVCOE8sUUFBdkIsR0FBa0MsU0FBU0EsUUFBVCxDQUFrQlEsR0FBbEIsRUFBdUI7QUFDckQsV0FBTyxJQUFJekMsS0FBS3lVLFlBQVQsQ0FBc0IsS0FBSzNVLE1BQUwsR0FBYyxLQUFLQSxNQUFMLENBQVltQyxRQUFaLENBQXFCUSxHQUFyQixDQUFkLEdBQTBDLEVBQWhFLEVBQW9FO0FBQ3ZFam9CLGVBQU8sS0FBS2s2QixRQUFMLEdBQWdCLFVBQWhCLEdBQTZCLFNBRG1DO0FBRXZFQSxrQkFBVSxLQUFLQSxRQUFMLEdBQWdCLEtBQUtBLFFBQUwsQ0FBY3pTLFFBQWQsQ0FBdUJRLEdBQXZCLENBQWhCLEdBQThDdm9CLFNBRmU7QUFHdkUyNkIsK0JBQXVCLEtBQUtGLGlCQUFMLEdBQXlCLEtBQUtBLGlCQUFMLENBQXVCMVMsUUFBdkIsQ0FBZ0NRLEdBQWhDLENBQXpCLEdBQWdFdm9CLFNBSGhCO0FBSXZFNDZCLCtCQUF1QixLQUFLRixpQkFBTCxHQUF5QixLQUFLQSxpQkFBTCxDQUF1QjNTLFFBQXZCLENBQWdDUSxHQUFoQyxDQUF6QixHQUFnRXZvQjtBQUpoQixLQUFwRSxFQUtKOEUsTUFMSSxDQUtHLEtBQUsrSixNQUFMLENBQVlrWixRQUFaLENBQXFCUSxHQUFyQixDQUxILENBQVA7QUFNSCxDQVBEO0FBUUFnUyxhQUFhdGhCLFNBQWIsQ0FBdUIrTyxTQUF2QixHQUFtQyxTQUFTQSxTQUFULENBQW1CL1QsRUFBbkIsRUFBdUI7QUFDdERBLE9BQUcsS0FBS3BGLE1BQVI7QUFDQSxRQUFJLEtBQUsrVyxNQUFULEVBQWlCO0FBQ2IzUixXQUFHLEtBQUsyUixNQUFSO0FBQ0g7QUFDRCxRQUFJLEtBQUs0VSxRQUFULEVBQW1CO0FBQ2Z2bUIsV0FBRyxLQUFLdW1CLFFBQVI7QUFDSDtBQUNELFFBQUksS0FBS0MsaUJBQVQsRUFBNEI7QUFDeEJ4bUIsV0FBRyxLQUFLd21CLGlCQUFSO0FBQ0g7QUFDRCxRQUFJLEtBQUtDLGlCQUFULEVBQTRCO0FBQ3hCem1CLFdBQUcsS0FBS3ltQixpQkFBUjtBQUNIO0FBQ0osQ0FkRDtBQWVBSCxhQUFhdGhCLFNBQWIsQ0FBdUJnUCxhQUF2QixHQUF1QyxTQUFTQSxhQUFULEdBQXlCO0FBQzVELFdBQU8sS0FBUDtBQUNILENBRkQ7QUFHQXNTLGFBQWF0aEIsU0FBYixDQUF1QmdPLFNBQXZCLEdBQW1DLFNBQVNBLFNBQVQsR0FBcUI7QUFDcEQsUUFBSS9VLFVBQVUsRUFBZDtBQUNBLFFBQUksS0FBSzBULE1BQVQsRUFBaUI7QUFDYjFULGdCQUFRLFFBQVIsSUFBb0IsS0FBSzBULE1BQUwsQ0FBWXFCLFNBQVosRUFBcEI7QUFDSDtBQUNELFFBQUksS0FBS3VULFFBQVQsRUFBbUI7QUFDZnRvQixnQkFBUSxVQUFSLElBQXNCLEtBQUtzb0IsUUFBTCxDQUFjdlQsU0FBZCxFQUF0QjtBQUNIO0FBQ0QsUUFBSSxLQUFLd1QsaUJBQVQsRUFBNEI7QUFDeEJ2b0IsZ0JBQVEscUJBQVIsSUFBaUMsS0FBS3VvQixpQkFBTCxDQUF1QnhULFNBQXZCLEVBQWpDO0FBQ0g7QUFDRCxRQUFJLEtBQUt5VCxpQkFBVCxFQUE0QjtBQUN4QnhvQixnQkFBUSxxQkFBUixJQUFpQyxLQUFLd29CLGlCQUFMLENBQXVCelQsU0FBdkIsRUFBakM7QUFDSDtBQUNELFdBQU8sQ0FDSCxlQURHLEVBRUgsS0FBS3BZLE1BQUwsQ0FBWW9ZLFNBQVosRUFGRyxFQUdIL1UsT0FIRyxDQUFQO0FBS0gsQ0FuQkQ7O0FBcUJBLElBQUkyb0IsU0FBUyxTQUFTQSxNQUFULENBQWdCN2pCLEtBQWhCLEVBQXVCO0FBQ2hDLFNBQUtoVyxJQUFMLEdBQVl3aEIsVUFBWjtBQUNBLFNBQUt4TCxLQUFMLEdBQWFBLEtBQWI7QUFDSCxDQUhEO0FBSUE2akIsT0FBT2g4QixLQUFQLEdBQWUsU0FBU0EsS0FBVCxDQUFlK29CLElBQWYsRUFBcUJDLE9BQXJCLEVBQThCO0FBQ3pDLFFBQUlELEtBQUt2ckIsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQixlQUFPd3JCLFFBQVF4bkIsS0FBUixDQUFjLHFDQUFxQ3VuQixLQUFLdnJCLE1BQUwsR0FBYyxDQUFuRCxJQUF3RCxXQUF0RSxDQUFQO0FBQ0g7QUFDRCxRQUFJMmEsUUFBUTZRLFFBQVFocEIsS0FBUixDQUFjK29CLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLENBQVo7QUFDQSxRQUFJLENBQUM1USxLQUFMLEVBQVk7QUFDUixlQUFPLElBQVA7QUFDSDtBQUNELFFBQUlBLE1BQU1oVyxJQUFOLENBQVd1aEIsSUFBWCxLQUFvQixPQUFwQixJQUErQnZMLE1BQU1oVyxJQUFOLENBQVd1aEIsSUFBWCxLQUFvQixRQUFuRCxJQUErRHZMLE1BQU1oVyxJQUFOLENBQVd1aEIsSUFBWCxLQUFvQixPQUF2RixFQUFnRztBQUM1RixlQUFPc0YsUUFBUXhuQixLQUFSLENBQWMsMERBQTBEcUIsU0FBU3NWLE1BQU1oVyxJQUFmLENBQTFELEdBQWlGLFdBQS9GLENBQVA7QUFDSDtBQUNELFdBQU8sSUFBSTY1QixNQUFKLENBQVc3akIsS0FBWCxDQUFQO0FBQ0gsQ0FaRDtBQWFBNmpCLE9BQU81aEIsU0FBUCxDQUFpQjhPLFFBQWpCLEdBQTRCLFNBQVNBLFFBQVQsQ0FBa0JRLEdBQWxCLEVBQXVCO0FBQy9DLFFBQUl2UixRQUFRLEtBQUtBLEtBQUwsQ0FBVytRLFFBQVgsQ0FBb0JRLEdBQXBCLENBQVo7QUFDQSxRQUFJLE9BQU92UixLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzNCLGVBQU9BLE1BQU0zYSxNQUFiO0FBQ0gsS0FGRCxNQUVPLElBQUlILE1BQU1DLE9BQU4sQ0FBYzZhLEtBQWQsQ0FBSixFQUEwQjtBQUM3QixlQUFPQSxNQUFNM2EsTUFBYjtBQUNILEtBRk0sTUFFQTtBQUNILGNBQU0sSUFBSTZyQixZQUFKLENBQWlCLDZEQUE2RHhtQixTQUFTK2xCLE9BQU96USxLQUFQLENBQVQsQ0FBN0QsR0FBdUYsV0FBeEcsQ0FBTjtBQUNIO0FBQ0osQ0FURDtBQVVBNmpCLE9BQU81aEIsU0FBUCxDQUFpQitPLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBbUIvVCxFQUFuQixFQUF1QjtBQUNoREEsT0FBRyxLQUFLK0MsS0FBUjtBQUNILENBRkQ7QUFHQTZqQixPQUFPNWhCLFNBQVAsQ0FBaUJnUCxhQUFqQixHQUFpQyxTQUFTQSxhQUFULEdBQXlCO0FBQ3RELFdBQU8sS0FBUDtBQUNILENBRkQ7QUFHQTRTLE9BQU81aEIsU0FBUCxDQUFpQmdPLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsR0FBcUI7QUFDOUMsUUFBSUMsYUFBYSxDQUFDLFFBQUQsQ0FBakI7QUFDQSxTQUFLYyxTQUFMLENBQWUsVUFBVTZCLEtBQVYsRUFBaUI7QUFDNUIzQyxtQkFBV2xxQixJQUFYLENBQWdCNnNCLE1BQU01QyxTQUFOLEVBQWhCO0FBQ0gsS0FGRDtBQUdBLFdBQU9DLFVBQVA7QUFDSCxDQU5EOztBQVFBLElBQUk0VCxjQUFjO0FBQ2QsVUFBTWIsTUFEUTtBQUVkLFVBQU1DLFNBRlE7QUFHZCxTQUFLRSxXQUhTO0FBSWQsU0FBS0QsUUFKUztBQUtkLFVBQU1HLGtCQUxRO0FBTWQsVUFBTUQsZUFOUTtBQU9kLGFBQVNqUyxTQVBLO0FBUWQsVUFBTThPLEVBUlE7QUFTZCxlQUFXOU8sU0FURztBQVVkLFlBQVFrUSxJQVZNO0FBV2QsZ0JBQVkxQixRQVhFO0FBWWQsZ0JBQVk1SyxrQkFaRTtBQWFkLGNBQVV2RCxnQkFiSTtBQWNkLGFBQVNPLGVBZEs7QUFlZCxVQUFNbU8sRUFmUTtBQWdCZCxnQkFBWUcsT0FoQkU7QUFpQmQsbUJBQWV6QixXQWpCRDtBQWtCZCx1QkFBbUJBLFdBbEJMO0FBbUJkLHVCQUFtQkEsV0FuQkw7QUFvQmQsY0FBVWdGLE1BcEJJO0FBcUJkLFdBQU83RCxHQXJCTztBQXNCZCxlQUFXclAsT0F0Qkc7QUF1QmQsYUFBUzZQLEtBdkJLO0FBd0JkLGNBQVVwUCxTQXhCSTtBQXlCZCxxQkFBaUJtUyxZQXpCSDtBQTBCZCxjQUFVblMsU0ExQkk7QUEyQmQsYUFBU3FRLEtBM0JLO0FBNEJkLFlBQVFsRyxJQTVCTTtBQTZCZCxjQUFVbkssU0E3Qkk7QUE4QmQsa0JBQWNnQixRQTlCQTtBQStCZCxnQkFBWUEsUUEvQkU7QUFnQ2QsaUJBQWFBLFFBaENDO0FBaUNkLGlCQUFhQSxRQWpDQztBQWtDZCxXQUFPK0gsR0FsQ087QUFtQ2QsY0FBVUw7QUFuQ0ksQ0FBbEI7QUFxQ0EsU0FBUzVoQixJQUFULENBQWNxWixHQUFkLEVBQW1Ccm1CLEdBQW5CLEVBQXdCO0FBQ3BCLFFBQUlwQyxJQUFJb0MsSUFBSSxDQUFKLENBQVI7QUFDQSxRQUFJZ2pCLElBQUloakIsSUFBSSxDQUFKLENBQVI7QUFDQSxRQUFJaWpCLElBQUlqakIsSUFBSSxDQUFKLENBQVI7QUFDQSxRQUFJK0UsSUFBSS9FLElBQUksQ0FBSixDQUFSO0FBQ0FwQyxRQUFJQSxFQUFFaW9CLFFBQUYsQ0FBV1EsR0FBWCxDQUFKO0FBQ0FyRCxRQUFJQSxFQUFFNkMsUUFBRixDQUFXUSxHQUFYLENBQUo7QUFDQXBELFFBQUlBLEVBQUU0QyxRQUFGLENBQVdRLEdBQVgsQ0FBSjtBQUNBLFFBQUl2RCxRQUFRL2QsSUFBSUEsRUFBRThnQixRQUFGLENBQVdRLEdBQVgsQ0FBSixHQUFzQixDQUFsQztBQUNBLFFBQUlsb0IsUUFBUWduQixhQUFhdm5CLENBQWIsRUFBZ0JvbEIsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCSCxLQUF0QixDQUFaO0FBQ0EsUUFBSTNrQixLQUFKLEVBQVc7QUFDUCxjQUFNLElBQUk2bkIsWUFBSixDQUFpQjduQixLQUFqQixDQUFOO0FBQ0g7QUFDRCxXQUFPLElBQUlvQixLQUFKLENBQVUzQixJQUFJLEdBQUosR0FBVWtsQixLQUFwQixFQUEyQkUsSUFBSSxHQUFKLEdBQVVGLEtBQXJDLEVBQTRDRyxJQUFJLEdBQUosR0FBVUgsS0FBdEQsRUFBNkRBLEtBQTdELENBQVA7QUFDSDtBQUNELFNBQVNwWCxHQUFULENBQWF2SSxHQUFiLEVBQWtCbU4sR0FBbEIsRUFBdUI7QUFDbkIsV0FBT25OLE9BQU9tTixHQUFkO0FBQ0g7QUFDRCxTQUFTL0ssR0FBVCxDQUFhcEMsR0FBYixFQUFrQm1OLEdBQWxCLEVBQXVCO0FBQ25CLFFBQUlxSCxJQUFJckgsSUFBSW5OLEdBQUosQ0FBUjtBQUNBLFdBQU8sT0FBT3dVLENBQVAsS0FBYSxXQUFiLEdBQTJCLElBQTNCLEdBQWtDQSxDQUF6QztBQUNIO0FBQ0QsU0FBU2toQixZQUFULENBQXNCbGhCLENBQXRCLEVBQXlCNVMsQ0FBekIsRUFBNEJqTCxDQUE1QixFQUErQnNiLENBQS9CLEVBQWtDO0FBQzlCLFdBQU90YixLQUFLc2IsQ0FBWixFQUFlO0FBQ1gsWUFBSVUsSUFBSWhjLElBQUlzYixDQUFKLElBQVMsQ0FBakI7QUFDQSxZQUFJclEsRUFBRStRLENBQUYsTUFBUzZCLENBQWIsRUFBZ0I7QUFDWixtQkFBTyxJQUFQO0FBQ0g7QUFDRCxZQUFJNVMsRUFBRStRLENBQUYsSUFBTzZCLENBQVgsRUFBYztBQUNWdkMsZ0JBQUlVLElBQUksQ0FBUjtBQUNILFNBRkQsTUFFTztBQUNIaGMsZ0JBQUlnYyxJQUFJLENBQVI7QUFDSDtBQUNKO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7QUFDRCxTQUFTZ2pCLE9BQVQsQ0FBaUJoNkIsSUFBakIsRUFBdUI7QUFDbkIsV0FBTyxFQUFFQSxNQUFNQSxJQUFSLEVBQVA7QUFDSDtBQUNEMHBCLG1CQUFtQnFCLFFBQW5CLENBQTRCK08sV0FBNUIsRUFBeUM7QUFDckMsYUFBUyxDQUNMaFksU0FESyxFQUVMLENBQUNMLFVBQUQsQ0FGSyxFQUdMLFVBQVU4RixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJMlgsSUFBSTNYLElBQUksQ0FBSixDQUFSO0FBQ0EsY0FBTSxJQUFJZ21CLFlBQUosQ0FBaUJyTyxFQUFFa08sUUFBRixDQUFXUSxHQUFYLENBQWpCLENBQU47QUFDSCxLQU5JLENBRDRCO0FBU3JDLGNBQVUsQ0FDTjlGLFVBRE0sRUFFTixDQUFDSSxTQUFELENBRk0sRUFHTixVQUFVMEYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSTJYLElBQUkzWCxJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU9SLFNBQVMrbEIsT0FBTzVOLEVBQUVrTyxRQUFGLENBQVdRLEdBQVgsQ0FBUCxDQUFULENBQVA7QUFDSCxLQU5LLENBVDJCO0FBaUJyQyxlQUFXLENBQ1BsYSxNQUFNbVUsVUFBTixFQUFrQixDQUFsQixDQURPLEVBRVAsQ0FBQ0csU0FBRCxDQUZPLEVBR1AsVUFBVTRGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUkyWCxJQUFJM1gsSUFBSSxDQUFKLENBQVI7QUFDQSxlQUFPMlgsRUFBRWtPLFFBQUYsQ0FBV1EsR0FBWCxFQUFnQm5ELE9BQWhCLEVBQVA7QUFDSCxLQU5NLENBakIwQjtBQXlCckMsV0FBTyxDQUNIekMsU0FERyxFQUVILENBQ0lILFVBREosRUFFSUEsVUFGSixFQUdJQSxVQUhKLENBRkcsRUFPSHRULElBUEcsQ0F6QjhCO0FBa0NyQyxZQUFRLENBQ0p5VCxTQURJLEVBRUosQ0FDSUgsVUFESixFQUVJQSxVQUZKLEVBR0lBLFVBSEosRUFJSUEsVUFKSixDQUZJLEVBUUp0VCxJQVJJLENBbEM2QjtBQTRDckMsV0FBTztBQUNIbE8sY0FBTTBoQixXQURIO0FBRUhzSSxtQkFBVyxDQUNQLENBQ0ksQ0FBQ3ZJLFVBQUQsQ0FESixFQUVJLFVBQVU4RixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixnQkFBSW1ELE1BQU1uRCxJQUFJLENBQUosQ0FBVjtBQUNBLG1CQUFPMEwsSUFBSXZJLElBQUkwaUIsUUFBSixDQUFhUSxHQUFiLENBQUosRUFBdUJBLElBQUlwWixVQUFKLEVBQXZCLENBQVA7QUFDSCxTQUxMLENBRE8sRUFRUCxDQUNJLENBQ0lzVCxVQURKLEVBRUlHLFVBRkosQ0FESixFQUtJLFVBQVUyRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixnQkFBSW1ELE1BQU1uRCxJQUFJLENBQUosQ0FBVjtBQUNBLGdCQUFJc1EsTUFBTXRRLElBQUksQ0FBSixDQUFWO0FBQ0EsbUJBQU8wTCxJQUFJdkksSUFBSTBpQixRQUFKLENBQWFRLEdBQWIsQ0FBSixFQUF1Qi9WLElBQUl1VixRQUFKLENBQWFRLEdBQWIsQ0FBdkIsQ0FBUDtBQUNILFNBVEwsQ0FSTztBQUZSLEtBNUM4QjtBQW1FckMsV0FBTztBQUNIdm5CLGNBQU02aEIsU0FESDtBQUVIbUksbUJBQVcsQ0FDUCxDQUNJLENBQUN2SSxVQUFELENBREosRUFFSSxVQUFVOEYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsZ0JBQUltRCxNQUFNbkQsSUFBSSxDQUFKLENBQVY7QUFDQSxtQkFBT3VGLElBQUlwQyxJQUFJMGlCLFFBQUosQ0FBYVEsR0FBYixDQUFKLEVBQXVCQSxJQUFJcFosVUFBSixFQUF2QixDQUFQO0FBQ0gsU0FMTCxDQURPLEVBUVAsQ0FDSSxDQUNJc1QsVUFESixFQUVJRyxVQUZKLENBREosRUFLSSxVQUFVMkYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsZ0JBQUltRCxNQUFNbkQsSUFBSSxDQUFKLENBQVY7QUFDQSxnQkFBSXNRLE1BQU10USxJQUFJLENBQUosQ0FBVjtBQUNBLG1CQUFPdUYsSUFBSXBDLElBQUkwaUIsUUFBSixDQUFhUSxHQUFiLENBQUosRUFBdUIvVixJQUFJdVYsUUFBSixDQUFhUSxHQUFiLENBQXZCLENBQVA7QUFDSCxTQVRMLENBUk87QUFGUixLQW5FOEI7QUEwRnJDLHFCQUFpQixDQUNiMUYsU0FEYSxFQUViLENBQUNKLFVBQUQsQ0FGYSxFQUdiLFVBQVU4RixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJbUQsTUFBTW5ELElBQUksQ0FBSixDQUFWO0FBQ0EsZUFBT3VGLElBQUlwQyxJQUFJMGlCLFFBQUosQ0FBYVEsR0FBYixDQUFKLEVBQXVCQSxJQUFJMkIsWUFBSixJQUFvQixFQUEzQyxDQUFQO0FBQ0gsS0FOWSxDQTFGb0I7QUFrR3JDLGtCQUFjLENBQ1Z0SCxVQURVLEVBRVYsRUFGVSxFQUdWLFVBQVUyRixHQUFWLEVBQWU7QUFDWCxlQUFPQSxJQUFJcFosVUFBSixFQUFQO0FBQ0gsS0FMUyxDQWxHdUI7QUF5R3JDLHFCQUFpQixDQUNic1QsVUFEYSxFQUViLEVBRmEsRUFHYixVQUFVOEYsR0FBVixFQUFlO0FBQ1gsZUFBT0EsSUFBSStCLFlBQUosRUFBUDtBQUNILEtBTFksQ0F6R29CO0FBZ0hyQyxVQUFNLENBQ0Z6SCxTQURFLEVBRUYsRUFGRSxFQUdGLFVBQVUwRixHQUFWLEVBQWU7QUFDWCxlQUFPQSxJQUFJNW5CLEVBQUosRUFBUDtBQUNILEtBTEMsQ0FoSCtCO0FBdUhyQyxZQUFRLENBQ0o2aEIsVUFESSxFQUVKLEVBRkksRUFHSixVQUFVK0YsR0FBVixFQUFlO0FBQ1gsZUFBT0EsSUFBSXlCLE9BQUosQ0FBWTNvQixJQUFuQjtBQUNILEtBTEcsQ0F2SDZCO0FBOEhyQyx1QkFBbUIsQ0FDZm1oQixVQURlLEVBRWYsRUFGZSxFQUdmLFVBQVUrRixHQUFWLEVBQWU7QUFDWCxlQUFPQSxJQUFJeUIsT0FBSixDQUFZaVIsY0FBWixJQUE4QixDQUFyQztBQUNILEtBTGMsQ0E5SGtCO0FBcUlyQyxxQkFBaUIsQ0FDYnpZLFVBRGEsRUFFYixFQUZhLEVBR2IsVUFBVStGLEdBQVYsRUFBZTtBQUNYLGVBQU9BLElBQUl5QixPQUFKLENBQVlrUixZQUFaLElBQTRCLENBQW5DO0FBQ0gsS0FMWSxDQXJJb0I7QUE0SXJDLG1CQUFlLENBQ1hyWSxTQURXLEVBRVgsRUFGVyxFQUdYLFVBQVUwRixHQUFWLEVBQWU7QUFDWCxlQUFPQSxJQUFJeUIsT0FBSixDQUFZNWEsV0FBWixLQUE0QnBQLFNBQTVCLEdBQXdDLElBQXhDLEdBQStDdW9CLElBQUl5QixPQUFKLENBQVk1YSxXQUFsRTtBQUNILEtBTFUsQ0E1SXNCO0FBbUpyQyxTQUFLLENBQ0RvVCxVQURDLEVBRUR3WSxRQUFReFksVUFBUixDQUZDLEVBR0QsVUFBVStGLEdBQVYsRUFBZVgsSUFBZixFQUFxQjtBQUNqQixZQUFJcFUsU0FBUyxDQUFiO0FBQ0EsYUFBSyxJQUFJeFgsSUFBSSxDQUFSLEVBQVdta0IsT0FBT3lILElBQXZCLEVBQTZCNXJCLElBQUlta0IsS0FBSzlqQixNQUF0QyxFQUE4Q0wsS0FBSyxDQUFuRCxFQUFzRDtBQUNsRCxnQkFBSTRjLE1BQU11SCxLQUFLbmtCLENBQUwsQ0FBVjtBQUNBd1gsc0JBQVVvRixJQUFJbVAsUUFBSixDQUFhUSxHQUFiLENBQVY7QUFDSDtBQUNELGVBQU8vVSxNQUFQO0FBQ0gsS0FWQSxDQW5KZ0M7QUErSnJDLFNBQUssQ0FDRGdQLFVBREMsRUFFRHdZLFFBQVF4WSxVQUFSLENBRkMsRUFHRCxVQUFVK0YsR0FBVixFQUFlWCxJQUFmLEVBQXFCO0FBQ2pCLFlBQUlwVSxTQUFTLENBQWI7QUFDQSxhQUFLLElBQUl4WCxJQUFJLENBQVIsRUFBV21rQixPQUFPeUgsSUFBdkIsRUFBNkI1ckIsSUFBSW1rQixLQUFLOWpCLE1BQXRDLEVBQThDTCxLQUFLLENBQW5ELEVBQXNEO0FBQ2xELGdCQUFJNGMsTUFBTXVILEtBQUtua0IsQ0FBTCxDQUFWO0FBQ0F3WCxzQkFBVW9GLElBQUltUCxRQUFKLENBQWFRLEdBQWIsQ0FBVjtBQUNIO0FBQ0QsZUFBTy9VLE1BQVA7QUFDSCxLQVZBLENBL0pnQztBQTJLckMsU0FBSztBQUNEeFMsY0FBTXdoQixVQURMO0FBRUR3SSxtQkFBVyxDQUNQLENBQ0ksQ0FDSXhJLFVBREosRUFFSUEsVUFGSixDQURKLEVBS0ksVUFBVStGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLGdCQUFJK0UsSUFBSS9FLElBQUksQ0FBSixDQUFSO0FBQ0EsZ0JBQUlpakIsSUFBSWpqQixJQUFJLENBQUosQ0FBUjtBQUNBLG1CQUFPK0UsRUFBRThnQixRQUFGLENBQVdRLEdBQVgsSUFBa0JwRCxFQUFFNEMsUUFBRixDQUFXUSxHQUFYLENBQXpCO0FBQ0gsU0FUTCxDQURPLEVBWVAsQ0FDSSxDQUFDL0YsVUFBRCxDQURKLEVBRUksVUFBVStGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLGdCQUFJK0UsSUFBSS9FLElBQUksQ0FBSixDQUFSO0FBQ0EsbUJBQU8sQ0FBQytFLEVBQUU4Z0IsUUFBRixDQUFXUSxHQUFYLENBQVI7QUFDSCxTQUxMLENBWk87QUFGVixLQTNLZ0M7QUFrTXJDLFNBQUssQ0FDRC9GLFVBREMsRUFFRCxDQUNJQSxVQURKLEVBRUlBLFVBRkosQ0FGQyxFQU1ELFVBQVUrRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJK0UsSUFBSS9FLElBQUksQ0FBSixDQUFSO0FBQ0EsWUFBSWlqQixJQUFJampCLElBQUksQ0FBSixDQUFSO0FBQ0EsZUFBTytFLEVBQUU4Z0IsUUFBRixDQUFXUSxHQUFYLElBQWtCcEQsRUFBRTRDLFFBQUYsQ0FBV1EsR0FBWCxDQUF6QjtBQUNILEtBVkEsQ0FsTWdDO0FBOE1yQyxTQUFLLENBQ0QvRixVQURDLEVBRUQsQ0FDSUEsVUFESixFQUVJQSxVQUZKLENBRkMsRUFNRCxVQUFVK0YsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSStFLElBQUkvRSxJQUFJLENBQUosQ0FBUjtBQUNBLFlBQUlpakIsSUFBSWpqQixJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU8rRSxFQUFFOGdCLFFBQUYsQ0FBV1EsR0FBWCxJQUFrQnBELEVBQUU0QyxRQUFGLENBQVdRLEdBQVgsQ0FBekI7QUFDSCxLQVZBLENBOU1nQztBQTBOckMsV0FBTyxDQUNIL0YsVUFERyxFQUVILEVBRkcsRUFHSCxZQUFZO0FBQ1IsZUFBT2pOLEtBQUs0bEIsR0FBWjtBQUNILEtBTEUsQ0ExTjhCO0FBaU9yQyxVQUFNLENBQ0YzWSxVQURFLEVBRUYsRUFGRSxFQUdGLFlBQVk7QUFDUixlQUFPak4sS0FBS2dYLEVBQVo7QUFDSCxLQUxDLENBak8rQjtBQXdPckMsU0FBSyxDQUNEL0osVUFEQyxFQUVELEVBRkMsRUFHRCxZQUFZO0FBQ1IsZUFBT2pOLEtBQUs2bEIsQ0FBWjtBQUNILEtBTEEsQ0F4T2dDO0FBK09yQyxTQUFLLENBQ0Q1WSxVQURDLEVBRUQsQ0FDSUEsVUFESixFQUVJQSxVQUZKLENBRkMsRUFNRCxVQUFVK0YsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSWlqQixJQUFJampCLElBQUksQ0FBSixDQUFSO0FBQ0EsWUFBSXRCLElBQUlzQixJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU9xVCxLQUFLd1gsR0FBTCxDQUFTNUgsRUFBRTRDLFFBQUYsQ0FBV1EsR0FBWCxDQUFULEVBQTBCM25CLEVBQUVtbkIsUUFBRixDQUFXUSxHQUFYLENBQTFCLENBQVA7QUFDSCxLQVZBLENBL09nQztBQTJQckMsWUFBUSxDQUNKL0YsVUFESSxFQUVKLENBQUNBLFVBQUQsQ0FGSSxFQUdKLFVBQVUrRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJdVgsSUFBSXZYLElBQUksQ0FBSixDQUFSO0FBQ0EsZUFBT3FULEtBQUtsRyxJQUFMLENBQVVvSyxFQUFFc08sUUFBRixDQUFXUSxHQUFYLENBQVYsQ0FBUDtBQUNILEtBTkcsQ0EzUDZCO0FBbVFyQyxhQUFTLENBQ0wvRixVQURLLEVBRUwsQ0FBQ0EsVUFBRCxDQUZLLEVBR0wsVUFBVStGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUlpVixJQUFJalYsSUFBSSxDQUFKLENBQVI7QUFDQSxlQUFPcVQsS0FBS2lYLEdBQUwsQ0FBU3JWLEVBQUU0USxRQUFGLENBQVdRLEdBQVgsQ0FBVCxJQUE0QmhULEtBQUs4bEIsSUFBeEM7QUFDSCxLQU5JLENBblE0QjtBQTJRckMsVUFBTSxDQUNGN1ksVUFERSxFQUVGLENBQUNBLFVBQUQsQ0FGRSxFQUdGLFVBQVUrRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJaVYsSUFBSWpWLElBQUksQ0FBSixDQUFSO0FBQ0EsZUFBT3FULEtBQUtpWCxHQUFMLENBQVNyVixFQUFFNFEsUUFBRixDQUFXUSxHQUFYLENBQVQsQ0FBUDtBQUNILEtBTkMsQ0EzUStCO0FBbVJyQyxZQUFRLENBQ0ovRixVQURJLEVBRUosQ0FBQ0EsVUFBRCxDQUZJLEVBR0osVUFBVStGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUlpVixJQUFJalYsSUFBSSxDQUFKLENBQVI7QUFDQSxlQUFPcVQsS0FBS2lYLEdBQUwsQ0FBU3JWLEVBQUU0USxRQUFGLENBQVdRLEdBQVgsQ0FBVCxJQUE0QmhULEtBQUs0bEIsR0FBeEM7QUFDSCxLQU5HLENBblI2QjtBQTJSckMsV0FBTyxDQUNIM1ksVUFERyxFQUVILENBQUNBLFVBQUQsQ0FGRyxFQUdILFVBQVUrRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJaVYsSUFBSWpWLElBQUksQ0FBSixDQUFSO0FBQ0EsZUFBT3FULEtBQUs5RixHQUFMLENBQVMwSCxFQUFFNFEsUUFBRixDQUFXUSxHQUFYLENBQVQsQ0FBUDtBQUNILEtBTkUsQ0EzUjhCO0FBbVNyQyxXQUFPLENBQ0gvRixVQURHLEVBRUgsQ0FBQ0EsVUFBRCxDQUZHLEVBR0gsVUFBVStGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUlpVixJQUFJalYsSUFBSSxDQUFKLENBQVI7QUFDQSxlQUFPcVQsS0FBSzdGLEdBQUwsQ0FBU3lILEVBQUU0USxRQUFGLENBQVdRLEdBQVgsQ0FBVCxDQUFQO0FBQ0gsS0FORSxDQW5TOEI7QUEyU3JDLFdBQU8sQ0FDSC9GLFVBREcsRUFFSCxDQUFDQSxVQUFELENBRkcsRUFHSCxVQUFVK0YsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSWlWLElBQUlqVixJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU9xVCxLQUFLNUYsR0FBTCxDQUFTd0gsRUFBRTRRLFFBQUYsQ0FBV1EsR0FBWCxDQUFULENBQVA7QUFDSCxLQU5FLENBM1M4QjtBQW1UckMsWUFBUSxDQUNKL0YsVUFESSxFQUVKLENBQUNBLFVBQUQsQ0FGSSxFQUdKLFVBQVUrRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJaVYsSUFBSWpWLElBQUksQ0FBSixDQUFSO0FBQ0EsZUFBT3FULEtBQUszRixJQUFMLENBQVV1SCxFQUFFNFEsUUFBRixDQUFXUSxHQUFYLENBQVYsQ0FBUDtBQUNILEtBTkcsQ0FuVDZCO0FBMlRyQyxZQUFRLENBQ0ovRixVQURJLEVBRUosQ0FBQ0EsVUFBRCxDQUZJLEVBR0osVUFBVStGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUlpVixJQUFJalYsSUFBSSxDQUFKLENBQVI7QUFDQSxlQUFPcVQsS0FBSzFGLElBQUwsQ0FBVXNILEVBQUU0USxRQUFGLENBQVdRLEdBQVgsQ0FBVixDQUFQO0FBQ0gsS0FORyxDQTNUNkI7QUFtVXJDLFlBQVEsQ0FDSi9GLFVBREksRUFFSixDQUFDQSxVQUFELENBRkksRUFHSixVQUFVK0YsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSWlWLElBQUlqVixJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU9xVCxLQUFLekYsSUFBTCxDQUFVcUgsRUFBRTRRLFFBQUYsQ0FBV1EsR0FBWCxDQUFWLENBQVA7QUFDSCxLQU5HLENBblU2QjtBQTJVckMsV0FBTyxDQUNIL0YsVUFERyxFQUVId1ksUUFBUXhZLFVBQVIsQ0FGRyxFQUdILFVBQVUrRixHQUFWLEVBQWVYLElBQWYsRUFBcUI7QUFDakIsZUFBT3JTLEtBQUt4RixHQUFMLENBQVNyVSxLQUFULENBQWU2WixJQUFmLEVBQXFCcVMsS0FBS2xyQixHQUFMLENBQVMsVUFBVWtjLEdBQVYsRUFBZTtBQUNoRCxtQkFBT0EsSUFBSW1QLFFBQUosQ0FBYVEsR0FBYixDQUFQO0FBQ0gsU0FGMkIsQ0FBckIsQ0FBUDtBQUdILEtBUEUsQ0EzVThCO0FBb1ZyQyxXQUFPLENBQ0gvRixVQURHLEVBRUh3WSxRQUFReFksVUFBUixDQUZHLEVBR0gsVUFBVStGLEdBQVYsRUFBZVgsSUFBZixFQUFxQjtBQUNqQixlQUFPclMsS0FBS3ZGLEdBQUwsQ0FBU3RVLEtBQVQsQ0FBZTZaLElBQWYsRUFBcUJxUyxLQUFLbHJCLEdBQUwsQ0FBUyxVQUFVa2MsR0FBVixFQUFlO0FBQ2hELG1CQUFPQSxJQUFJbVAsUUFBSixDQUFhUSxHQUFiLENBQVA7QUFDSCxTQUYyQixDQUFyQixDQUFQO0FBR0gsS0FQRSxDQXBWOEI7QUE2VnJDLFdBQU8sQ0FDSC9GLFVBREcsRUFFSCxDQUFDQSxVQUFELENBRkcsRUFHSCxVQUFVK0YsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSWlWLElBQUlqVixJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU9xVCxLQUFLdEYsR0FBTCxDQUFTa0gsRUFBRTRRLFFBQUYsQ0FBV1EsR0FBWCxDQUFULENBQVA7QUFDSCxLQU5FLENBN1Y4QjtBQXFXckMsYUFBUyxDQUNML0YsVUFESyxFQUVMLENBQUNBLFVBQUQsQ0FGSyxFQUdMLFVBQVUrRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJaVYsSUFBSWpWLElBQUksQ0FBSixDQUFSO0FBQ0EsWUFBSTJYLElBQUkxQyxFQUFFNFEsUUFBRixDQUFXUSxHQUFYLENBQVI7QUFDQSxlQUFPMU8sSUFBSSxDQUFKLEdBQVEsQ0FBQ3RFLEtBQUtySixLQUFMLENBQVcsQ0FBQzJOLENBQVosQ0FBVCxHQUEwQnRFLEtBQUtySixLQUFMLENBQVcyTixDQUFYLENBQWpDO0FBQ0gsS0FQSSxDQXJXNEI7QUE4V3JDLGFBQVMsQ0FDTDJJLFVBREssRUFFTCxDQUFDQSxVQUFELENBRkssRUFHTCxVQUFVK0YsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSWlWLElBQUlqVixJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU9xVCxLQUFLcEYsS0FBTCxDQUFXZ0gsRUFBRTRRLFFBQUYsQ0FBV1EsR0FBWCxDQUFYLENBQVA7QUFDSCxLQU5JLENBOVc0QjtBQXNYckMsWUFBUSxDQUNKL0YsVUFESSxFQUVKLENBQUNBLFVBQUQsQ0FGSSxFQUdKLFVBQVUrRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJaVYsSUFBSWpWLElBQUksQ0FBSixDQUFSO0FBQ0EsZUFBT3FULEtBQUtyRixJQUFMLENBQVVpSCxFQUFFNFEsUUFBRixDQUFXUSxHQUFYLENBQVYsQ0FBUDtBQUNILEtBTkcsQ0F0WDZCO0FBOFhyQyxpQkFBYSxDQUNUN0YsV0FEUyxFQUVULENBQ0lELFVBREosRUFFSUksU0FGSixDQUZTLEVBTVQsVUFBVTBGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUk0VSxJQUFJNVUsSUFBSSxDQUFKLENBQVI7QUFDQSxZQUFJMlgsSUFBSTNYLElBQUksQ0FBSixDQUFSO0FBQ0EsZUFBT3FtQixJQUFJcFosVUFBSixHQUFpQjJILEVBQUU1TyxLQUFuQixNQUE4QjJSLEVBQUUzUixLQUF2QztBQUNILEtBVlEsQ0E5WHdCO0FBMFlyQyxvQkFBZ0IsQ0FDWndhLFdBRFksRUFFWixDQUFDRyxTQUFELENBRlksRUFHWixVQUFVMEYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSTJYLElBQUkzWCxJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU9xbUIsSUFBSTVuQixFQUFKLE9BQWFrWixFQUFFM1IsS0FBdEI7QUFDSCxLQU5XLENBMVlxQjtBQWtackMsc0JBQWtCLENBQ2R3YSxXQURjLEVBRWQsQ0FBQ0QsVUFBRCxDQUZjLEVBR2QsVUFBVThGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUkyWCxJQUFJM1gsSUFBSSxDQUFKLENBQVI7QUFDQSxlQUFPcW1CLElBQUkrQixZQUFKLE9BQXVCelEsRUFBRTNSLEtBQWhDO0FBQ0gsS0FOYSxDQWxabUI7QUEwWnJDLGdCQUFZLENBQ1J3YSxXQURRLEVBRVIsQ0FDSUQsVUFESixFQUVJSSxTQUZKLENBRlEsRUFNUixVQUFVMEYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSTRVLElBQUk1VSxJQUFJLENBQUosQ0FBUjtBQUNBLFlBQUkyWCxJQUFJM1gsSUFBSSxDQUFKLENBQVI7QUFDQSxZQUFJK0UsSUFBSXNoQixJQUFJcFosVUFBSixHQUFpQjJILEVBQUU1TyxLQUFuQixDQUFSO0FBQ0EsWUFBSWlkLElBQUl0TCxFQUFFM1IsS0FBVjtBQUNBLGVBQU8sUUFBT2pCLENBQVAseUNBQU9BLENBQVAsZUFBb0JrZSxDQUFwQix5Q0FBb0JBLENBQXBCLE1BQXlCbGUsSUFBSWtlLENBQXBDO0FBQ0gsS0FaTyxDQTFaeUI7QUF3YXJDLG1CQUFlLENBQ1h6QyxXQURXLEVBRVgsQ0FBQ0csU0FBRCxDQUZXLEVBR1gsVUFBVTBGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUkyWCxJQUFJM1gsSUFBSSxDQUFKLENBQVI7QUFDQSxZQUFJK0UsSUFBSXNoQixJQUFJNW5CLEVBQUosRUFBUjtBQUNBLFlBQUl3a0IsSUFBSXRMLEVBQUUzUixLQUFWO0FBQ0EsZUFBTyxRQUFPakIsQ0FBUCx5Q0FBT0EsQ0FBUCxlQUFvQmtlLENBQXBCLHlDQUFvQkEsQ0FBcEIsTUFBeUJsZSxJQUFJa2UsQ0FBcEM7QUFDSCxLQVJVLENBeGFzQjtBQWtickMsZ0JBQVksQ0FDUnpDLFdBRFEsRUFFUixDQUNJRCxVQURKLEVBRUlJLFNBRkosQ0FGUSxFQU1SLFVBQVUwRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJNFUsSUFBSTVVLElBQUksQ0FBSixDQUFSO0FBQ0EsWUFBSTJYLElBQUkzWCxJQUFJLENBQUosQ0FBUjtBQUNBLFlBQUkrRSxJQUFJc2hCLElBQUlwWixVQUFKLEdBQWlCMkgsRUFBRTVPLEtBQW5CLENBQVI7QUFDQSxZQUFJaWQsSUFBSXRMLEVBQUUzUixLQUFWO0FBQ0EsZUFBTyxRQUFPakIsQ0FBUCx5Q0FBT0EsQ0FBUCxlQUFvQmtlLENBQXBCLHlDQUFvQkEsQ0FBcEIsTUFBeUJsZSxJQUFJa2UsQ0FBcEM7QUFDSCxLQVpPLENBbGJ5QjtBQWdjckMsbUJBQWUsQ0FDWHpDLFdBRFcsRUFFWCxDQUFDRyxTQUFELENBRlcsRUFHWCxVQUFVMEYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSTJYLElBQUkzWCxJQUFJLENBQUosQ0FBUjtBQUNBLFlBQUkrRSxJQUFJc2hCLElBQUk1bkIsRUFBSixFQUFSO0FBQ0EsWUFBSXdrQixJQUFJdEwsRUFBRTNSLEtBQVY7QUFDQSxlQUFPLFFBQU9qQixDQUFQLHlDQUFPQSxDQUFQLGVBQW9Ca2UsQ0FBcEIseUNBQW9CQSxDQUFwQixNQUF5QmxlLElBQUlrZSxDQUFwQztBQUNILEtBUlUsQ0FoY3NCO0FBMGNyQyxpQkFBYSxDQUNUekMsV0FEUyxFQUVULENBQ0lELFVBREosRUFFSUksU0FGSixDQUZTLEVBTVQsVUFBVTBGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUk0VSxJQUFJNVUsSUFBSSxDQUFKLENBQVI7QUFDQSxZQUFJMlgsSUFBSTNYLElBQUksQ0FBSixDQUFSO0FBQ0EsWUFBSStFLElBQUlzaEIsSUFBSXBaLFVBQUosR0FBaUIySCxFQUFFNU8sS0FBbkIsQ0FBUjtBQUNBLFlBQUlpZCxJQUFJdEwsRUFBRTNSLEtBQVY7QUFDQSxlQUFPLFFBQU9qQixDQUFQLHlDQUFPQSxDQUFQLGVBQW9Ca2UsQ0FBcEIseUNBQW9CQSxDQUFwQixNQUF5QmxlLEtBQUtrZSxDQUFyQztBQUNILEtBWlEsQ0ExY3dCO0FBd2RyQyxvQkFBZ0IsQ0FDWnpDLFdBRFksRUFFWixDQUFDRyxTQUFELENBRlksRUFHWixVQUFVMEYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSTJYLElBQUkzWCxJQUFJLENBQUosQ0FBUjtBQUNBLFlBQUkrRSxJQUFJc2hCLElBQUk1bkIsRUFBSixFQUFSO0FBQ0EsWUFBSXdrQixJQUFJdEwsRUFBRTNSLEtBQVY7QUFDQSxlQUFPLFFBQU9qQixDQUFQLHlDQUFPQSxDQUFQLGVBQW9Ca2UsQ0FBcEIseUNBQW9CQSxDQUFwQixNQUF5QmxlLEtBQUtrZSxDQUFyQztBQUNILEtBUlcsQ0F4ZHFCO0FBa2VyQyxpQkFBYSxDQUNUekMsV0FEUyxFQUVULENBQ0lELFVBREosRUFFSUksU0FGSixDQUZTLEVBTVQsVUFBVTBGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUk0VSxJQUFJNVUsSUFBSSxDQUFKLENBQVI7QUFDQSxZQUFJMlgsSUFBSTNYLElBQUksQ0FBSixDQUFSO0FBQ0EsWUFBSStFLElBQUlzaEIsSUFBSXBaLFVBQUosR0FBaUIySCxFQUFFNU8sS0FBbkIsQ0FBUjtBQUNBLFlBQUlpZCxJQUFJdEwsRUFBRTNSLEtBQVY7QUFDQSxlQUFPLFFBQU9qQixDQUFQLHlDQUFPQSxDQUFQLGVBQW9Ca2UsQ0FBcEIseUNBQW9CQSxDQUFwQixNQUF5QmxlLEtBQUtrZSxDQUFyQztBQUNILEtBWlEsQ0FsZXdCO0FBZ2ZyQyxvQkFBZ0IsQ0FDWnpDLFdBRFksRUFFWixDQUFDRyxTQUFELENBRlksRUFHWixVQUFVMEYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSTJYLElBQUkzWCxJQUFJLENBQUosQ0FBUjtBQUNBLFlBQUkrRSxJQUFJc2hCLElBQUk1bkIsRUFBSixFQUFSO0FBQ0EsWUFBSXdrQixJQUFJdEwsRUFBRTNSLEtBQVY7QUFDQSxlQUFPLFFBQU9qQixDQUFQLHlDQUFPQSxDQUFQLGVBQW9Ca2UsQ0FBcEIseUNBQW9CQSxDQUFwQixNQUF5QmxlLEtBQUtrZSxDQUFyQztBQUNILEtBUlcsQ0FoZnFCO0FBMGZyQyxrQkFBYyxDQUNWekMsV0FEVSxFQUVWLENBQUNHLFNBQUQsQ0FGVSxFQUdWLFVBQVUwRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJNFUsSUFBSTVVLElBQUksQ0FBSixDQUFSO0FBQ0EsZUFBTzRVLEVBQUU1TyxLQUFGLElBQVdxZ0IsSUFBSXBaLFVBQUosRUFBbEI7QUFDSCxLQU5TLENBMWZ1QjtBQWtnQnJDLHFCQUFpQixDQUNidVQsV0FEYSxFQUViLEVBRmEsRUFHYixVQUFVNkYsR0FBVixFQUFlO0FBQ1gsZUFBT0EsSUFBSTVuQixFQUFKLE9BQWEsSUFBYixJQUFxQjRuQixJQUFJNW5CLEVBQUosT0FBYVgsU0FBekM7QUFDSCxLQUxZLENBbGdCb0I7QUF5Z0JyQyxzQkFBa0IsQ0FDZDBpQixXQURjLEVBRWQsQ0FBQ3JVLE1BQU1vVSxVQUFOLENBQUQsQ0FGYyxFQUdkLFVBQVU4RixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJMlgsSUFBSTNYLElBQUksQ0FBSixDQUFSO0FBQ0EsZUFBTzJYLEVBQUUzUixLQUFGLENBQVFuTCxPQUFSLENBQWdCd3JCLElBQUkrQixZQUFKLEVBQWhCLEtBQXVDLENBQTlDO0FBQ0gsS0FOYSxDQXpnQm1CO0FBaWhCckMsb0JBQWdCLENBQ1o1SCxXQURZLEVBRVosQ0FBQ3JVLE1BQU13VSxTQUFOLENBQUQsQ0FGWSxFQUdaLFVBQVUwRixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJMlgsSUFBSTNYLElBQUksQ0FBSixDQUFSO0FBQ0EsZUFBTzJYLEVBQUUzUixLQUFGLENBQVFuTCxPQUFSLENBQWdCd3JCLElBQUk1bkIsRUFBSixFQUFoQixLQUE2QixDQUFwQztBQUNILEtBTlcsQ0FqaEJxQjtBQXloQnJDLHVCQUFtQixDQUNmK2hCLFdBRGUsRUFFZixDQUNJRCxVQURKLEVBRUlwVSxNQUFNd1UsU0FBTixDQUZKLENBRmUsRUFNZixVQUFVMEYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSTRVLElBQUk1VSxJQUFJLENBQUosQ0FBUjtBQUNBLFlBQUkyWCxJQUFJM1gsSUFBSSxDQUFKLENBQVI7QUFDQSxlQUFPMlgsRUFBRTNSLEtBQUYsQ0FBUW5MLE9BQVIsQ0FBZ0J3ckIsSUFBSXBaLFVBQUosR0FBaUIySCxFQUFFNU8sS0FBbkIsQ0FBaEIsS0FBOEMsQ0FBckQ7QUFDSCxLQVZjLENBemhCa0I7QUFxaUJyQyx1QkFBbUIsQ0FDZndhLFdBRGUsRUFFZixDQUNJRCxVQURKLEVBRUlwVSxNQUFNd1UsU0FBTixDQUZKLENBRmUsRUFNZixVQUFVMEYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSTRVLElBQUk1VSxJQUFJLENBQUosQ0FBUjtBQUNBLFlBQUkyWCxJQUFJM1gsSUFBSSxDQUFKLENBQVI7QUFDQSxlQUFPNjRCLGFBQWF4UyxJQUFJcFosVUFBSixHQUFpQjJILEVBQUU1TyxLQUFuQixDQUFiLEVBQXdDMlIsRUFBRTNSLEtBQTFDLEVBQWlELENBQWpELEVBQW9EMlIsRUFBRTNSLEtBQUYsQ0FBUTdMLE1BQVIsR0FBaUIsQ0FBckUsQ0FBUDtBQUNILEtBVmMsQ0FyaUJrQjtBQWlqQnJDLFdBQU87QUFDSDJFLGNBQU0waEIsV0FESDtBQUVIc0ksbUJBQVcsQ0FDUCxDQUNJLENBQ0l0SSxXQURKLEVBRUlBLFdBRkosQ0FESixFQUtJLFVBQVU2RixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixnQkFBSStFLElBQUkvRSxJQUFJLENBQUosQ0FBUjtBQUNBLGdCQUFJaWpCLElBQUlqakIsSUFBSSxDQUFKLENBQVI7QUFDQSxtQkFBTytFLEVBQUU4Z0IsUUFBRixDQUFXUSxHQUFYLEtBQW1CcEQsRUFBRTRDLFFBQUYsQ0FBV1EsR0FBWCxDQUExQjtBQUNILFNBVEwsQ0FETyxFQVlQLENBQ0l5UyxRQUFRdFksV0FBUixDQURKLEVBRUksVUFBVTZGLEdBQVYsRUFBZVgsSUFBZixFQUFxQjtBQUNqQixpQkFBSyxJQUFJNXJCLElBQUksQ0FBUixFQUFXbWtCLE9BQU95SCxJQUF2QixFQUE2QjVyQixJQUFJbWtCLEtBQUs5akIsTUFBdEMsRUFBOENMLEtBQUssQ0FBbkQsRUFBc0Q7QUFDbEQsb0JBQUk0YyxNQUFNdUgsS0FBS25rQixDQUFMLENBQVY7QUFDQSxvQkFBSSxDQUFDNGMsSUFBSW1QLFFBQUosQ0FBYVEsR0FBYixDQUFMLEVBQXdCO0FBQ3BCLDJCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0QsbUJBQU8sSUFBUDtBQUNILFNBVkwsQ0FaTztBQUZSLEtBampCOEI7QUE2a0JyQyxXQUFPO0FBQ0h2bkIsY0FBTTBoQixXQURIO0FBRUhzSSxtQkFBVyxDQUNQLENBQ0ksQ0FDSXRJLFdBREosRUFFSUEsV0FGSixDQURKLEVBS0ksVUFBVTZGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLGdCQUFJK0UsSUFBSS9FLElBQUksQ0FBSixDQUFSO0FBQ0EsZ0JBQUlpakIsSUFBSWpqQixJQUFJLENBQUosQ0FBUjtBQUNBLG1CQUFPK0UsRUFBRThnQixRQUFGLENBQVdRLEdBQVgsS0FBbUJwRCxFQUFFNEMsUUFBRixDQUFXUSxHQUFYLENBQTFCO0FBQ0gsU0FUTCxDQURPLEVBWVAsQ0FDSXlTLFFBQVF0WSxXQUFSLENBREosRUFFSSxVQUFVNkYsR0FBVixFQUFlWCxJQUFmLEVBQXFCO0FBQ2pCLGlCQUFLLElBQUk1ckIsSUFBSSxDQUFSLEVBQVdta0IsT0FBT3lILElBQXZCLEVBQTZCNXJCLElBQUlta0IsS0FBSzlqQixNQUF0QyxFQUE4Q0wsS0FBSyxDQUFuRCxFQUFzRDtBQUNsRCxvQkFBSTRjLE1BQU11SCxLQUFLbmtCLENBQUwsQ0FBVjtBQUNBLG9CQUFJNGMsSUFBSW1QLFFBQUosQ0FBYVEsR0FBYixDQUFKLEVBQXVCO0FBQ25CLDJCQUFPLElBQVA7QUFDSDtBQUNKO0FBQ0QsbUJBQU8sS0FBUDtBQUNILFNBVkwsQ0FaTztBQUZSLEtBN2tCOEI7QUF5bUJyQyxTQUFLLENBQ0Q3RixXQURDLEVBRUQsQ0FBQ0EsV0FBRCxDQUZDLEVBR0QsVUFBVTZGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUlpakIsSUFBSWpqQixJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU8sQ0FBQ2lqQixFQUFFNEMsUUFBRixDQUFXUSxHQUFYLENBQVI7QUFDSCxLQU5BLENBem1CZ0M7QUFpbkJyQywyQkFBdUIsQ0FDbkI3RixXQURtQixFQUVuQixDQUFDRCxVQUFELENBRm1CLEVBR25CLFVBQVU4RixHQUFWLEVBQWVybUIsR0FBZixFQUFvQjtBQUNoQixZQUFJb2MsSUFBSXBjLElBQUksQ0FBSixDQUFSO0FBQ0EsWUFBSW81QixvQkFBb0IvUyxJQUFJeUIsT0FBSixJQUFlekIsSUFBSXlCLE9BQUosQ0FBWXNSLGlCQUFuRDtBQUNBLFlBQUlBLGlCQUFKLEVBQXVCO0FBQ25CLG1CQUFPQSxrQkFBa0JoZCxFQUFFeUosUUFBRixDQUFXUSxHQUFYLENBQWxCLENBQVA7QUFDSDtBQUNELGVBQU8sSUFBUDtBQUNILEtBVmtCLENBam5CYztBQTZuQnJDLGNBQVUsQ0FDTjlGLFVBRE0sRUFFTixDQUFDQSxVQUFELENBRk0sRUFHTixVQUFVOEYsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSW9jLElBQUlwYyxJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU9vYyxFQUFFeUosUUFBRixDQUFXUSxHQUFYLEVBQWdCZ1QsV0FBaEIsRUFBUDtBQUNILEtBTkssQ0E3bkIyQjtBQXFvQnJDLGdCQUFZLENBQ1I5WSxVQURRLEVBRVIsQ0FBQ0EsVUFBRCxDQUZRLEVBR1IsVUFBVThGLEdBQVYsRUFBZXJtQixHQUFmLEVBQW9CO0FBQ2hCLFlBQUlvYyxJQUFJcGMsSUFBSSxDQUFKLENBQVI7QUFDQSxlQUFPb2MsRUFBRXlKLFFBQUYsQ0FBV1EsR0FBWCxFQUFnQmhRLFdBQWhCLEVBQVA7QUFDSCxLQU5PLENBcm9CeUI7QUE2b0JyQyxjQUFVLENBQ05rSyxVQURNLEVBRU51WSxRQUFRblksU0FBUixDQUZNLEVBR04sVUFBVTBGLEdBQVYsRUFBZVgsSUFBZixFQUFxQjtBQUNqQixlQUFPQSxLQUFLbHJCLEdBQUwsQ0FBUyxVQUFVa2MsR0FBVixFQUFlO0FBQzNCLG1CQUFPOE8sV0FBVzlPLElBQUltUCxRQUFKLENBQWFRLEdBQWIsQ0FBWCxDQUFQO0FBQ0gsU0FGTSxFQUVKbmhCLElBRkksQ0FFQyxFQUZELENBQVA7QUFHSCxLQVBLLENBN29CMkI7QUFzcEJyQyx1QkFBbUIsQ0FDZnFiLFVBRGUsRUFFZixDQUFDTSxZQUFELENBRmUsRUFHZixVQUFVd0YsR0FBVixFQUFlcm1CLEdBQWYsRUFBb0I7QUFDaEIsWUFBSThNLFdBQVc5TSxJQUFJLENBQUosQ0FBZjtBQUNBLGVBQU84TSxTQUFTK1ksUUFBVCxDQUFrQlEsR0FBbEIsRUFBdUJwQyxjQUF2QixFQUFQO0FBQ0gsS0FOYztBQXRwQmtCLENBQXpDOztBQWdxQkEsU0FBU3FWLE9BQVQsQ0FBaUJ0ekIsS0FBakIsRUFBd0I7QUFDcEIsV0FBTztBQUNIc0wsZ0JBQVEsU0FETDtBQUVIdEwsZUFBT0E7QUFGSixLQUFQO0FBSUg7QUFDRCxTQUFTN0gsS0FBVCxDQUFlNkgsS0FBZixFQUFzQjtBQUNsQixXQUFPO0FBQ0hzTCxnQkFBUSxPQURMO0FBRUh0TCxlQUFPQTtBQUZKLEtBQVA7QUFJSDs7QUFFRCxTQUFTdXpCLDBCQUFULENBQW9DQyxJQUFwQyxFQUEwQztBQUN0QyxXQUFPQSxLQUFLLGVBQUwsTUFBMEIsYUFBMUIsSUFBMkNBLEtBQUssZUFBTCxNQUEwQix5QkFBNUU7QUFDSDtBQUNELFNBQVNDLHNCQUFULENBQWdDRCxJQUFoQyxFQUFzQztBQUNsQyxXQUFPLENBQUMsQ0FBQ0EsS0FBSy92QixVQUFQLElBQXFCK3ZCLEtBQUsvdkIsVUFBTCxDQUFnQkUsVUFBaEIsQ0FBMkI5TyxPQUEzQixDQUFtQyxNQUFuQyxJQUE2QyxDQUFDLENBQTFFO0FBQ0g7QUFDRCxTQUFTNitCLHFCQUFULENBQStCRixJQUEvQixFQUFxQztBQUNqQyxXQUFPLENBQUMsQ0FBQ0EsS0FBSy92QixVQUFQLElBQXFCK3ZCLEtBQUsvdkIsVUFBTCxDQUFnQkMsWUFBNUM7QUFDSDs7QUFFRCxTQUFTaXdCLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCO0FBQ2xCLFFBQUlBLGVBQWVuUyxNQUFuQixFQUEyQjtBQUN2QixlQUFPLFFBQVA7QUFDSCxLQUZELE1BRU8sSUFBSW1TLGVBQWVybUIsTUFBbkIsRUFBMkI7QUFDOUIsZUFBTyxRQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUlxbUIsZUFBZXpTLE9BQW5CLEVBQTRCO0FBQy9CLGVBQU8sU0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJbnRCLE1BQU1DLE9BQU4sQ0FBYzIvQixHQUFkLENBQUosRUFBd0I7QUFDM0IsZUFBTyxPQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUlBLFFBQVEsSUFBWixFQUFrQjtBQUNyQixlQUFPLE1BQVA7QUFDSCxLQUZNLE1BRUE7QUFDSCxzQkFBY0EsR0FBZCx5Q0FBY0EsR0FBZDtBQUNIO0FBQ0o7O0FBRUQsU0FBU0MsWUFBVCxDQUFzQjd6QixLQUF0QixFQUE2QjtBQUN6QixXQUFPLFFBQU9BLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFBakIsSUFBNkJBLFVBQVUsSUFBdkMsSUFBK0MsQ0FBQ2hNLE1BQU1DLE9BQU4sQ0FBYytMLEtBQWQsQ0FBdkQ7QUFDSDtBQUNELFNBQVM4ekIsZ0JBQVQsQ0FBMEJ2aUIsQ0FBMUIsRUFBNkI7QUFDekIsV0FBT0EsQ0FBUDtBQUNIO0FBQ0QsU0FBU3dpQixjQUFULENBQXdCcHdCLFVBQXhCLEVBQW9DcXdCLFlBQXBDLEVBQWtEO0FBQzlDLFFBQUlDLFVBQVVELGFBQWFsN0IsSUFBYixLQUFzQixPQUFwQztBQUNBLFFBQUlvN0IsMEJBQTBCdndCLFdBQVd6UCxLQUFYLElBQW9CLFFBQU95UCxXQUFXelAsS0FBWCxDQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFQLE1BQWtDLFFBQXBGO0FBQ0EsUUFBSWlnQyxtQkFBbUJELDJCQUEyQnZ3QixXQUFXd0YsUUFBWCxLQUF3QnJSLFNBQTFFO0FBQ0EsUUFBSXM4QixnQkFBZ0JGLDJCQUEyQixDQUFDQyxnQkFBaEQ7QUFDQSxRQUFJcjdCLE9BQU82SyxXQUFXN0ssSUFBWCxLQUFvQjQ2QixzQkFBc0JNLFlBQXRCLElBQXNDLGFBQXRDLEdBQXNELFVBQTFFLENBQVg7QUFDQSxRQUFJQyxPQUFKLEVBQWE7QUFDVHR3QixxQkFBYThWLE9BQU8sRUFBUCxFQUFXOVYsVUFBWCxDQUFiO0FBQ0EsWUFBSUEsV0FBV3pQLEtBQWYsRUFBc0I7QUFDbEJ5UCx1QkFBV3pQLEtBQVgsR0FBbUJ5UCxXQUFXelAsS0FBWCxDQUFpQk0sR0FBakIsQ0FBcUIsVUFBVXlrQixJQUFWLEVBQWdCO0FBQ3BELHVCQUFPLENBQ0hBLEtBQUssQ0FBTCxDQURHLEVBRUgxZixNQUFNNUMsS0FBTixDQUFZc2lCLEtBQUssQ0FBTCxDQUFaLENBRkcsQ0FBUDtBQUlILGFBTGtCLENBQW5CO0FBTUg7QUFDRCxZQUFJdFYsV0FBVzB3QixPQUFmLEVBQXdCO0FBQ3BCMXdCLHVCQUFXMHdCLE9BQVgsR0FBcUI5NkIsTUFBTTVDLEtBQU4sQ0FBWWdOLFdBQVcwd0IsT0FBdkIsQ0FBckI7QUFDSCxTQUZELE1BRU87QUFDSDF3Qix1QkFBVzB3QixPQUFYLEdBQXFCOTZCLE1BQU01QyxLQUFOLENBQVlxOUIsYUFBYUssT0FBekIsQ0FBckI7QUFDSDtBQUNKO0FBQ0QsUUFBSTF3QixXQUFXNkYsVUFBWCxJQUF5QjdGLFdBQVc2RixVQUFYLEtBQTBCLEtBQW5ELElBQTRELENBQUNra0IsWUFBWS9wQixXQUFXNkYsVUFBdkIsQ0FBakUsRUFBcUc7QUFDakcsY0FBTSxJQUFJM1MsS0FBSixDQUFVLDBCQUEwQjhNLFdBQVc2RixVQUEvQyxDQUFOO0FBQ0g7QUFDRCxRQUFJOHFCLFFBQUo7QUFDQSxRQUFJQyxXQUFKO0FBQ0EsUUFBSUMsa0JBQUo7QUFDQSxRQUFJMTdCLFNBQVMsYUFBYixFQUE0QjtBQUN4Qnc3QixtQkFBV0csMkJBQVg7QUFDSCxLQUZELE1BRU8sSUFBSTM3QixTQUFTLFVBQWIsRUFBeUI7QUFDNUJ3N0IsbUJBQVdJLHdCQUFYO0FBQ0gsS0FGTSxNQUVBLElBQUk1N0IsU0FBUyxhQUFiLEVBQTRCO0FBQy9CdzdCLG1CQUFXSywyQkFBWDtBQUNBSixzQkFBY3BwQixPQUFPNE8sTUFBUCxDQUFjLElBQWQsQ0FBZDtBQUNBLGFBQUssSUFBSWptQixJQUFJLENBQVIsRUFBV21rQixPQUFPdFUsV0FBV3pQLEtBQWxDLEVBQXlDSixJQUFJbWtCLEtBQUs5akIsTUFBbEQsRUFBMERMLEtBQUssQ0FBL0QsRUFBa0U7QUFDOUQsZ0JBQUltbEIsT0FBT2hCLEtBQUtua0IsQ0FBTCxDQUFYO0FBQ0F5Z0Msd0JBQVl0YixLQUFLLENBQUwsQ0FBWixJQUF1QkEsS0FBSyxDQUFMLENBQXZCO0FBQ0g7QUFDRHViLHFDQUE0Qjd3QixXQUFXelAsS0FBWCxDQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUE1QjtBQUNILEtBUk0sTUFRQSxJQUFJNEUsU0FBUyxVQUFiLEVBQXlCO0FBQzVCdzdCLG1CQUFXTSx3QkFBWDtBQUNILEtBRk0sTUFFQTtBQUNILGNBQU0sSUFBSS85QixLQUFKLENBQVUsNEJBQTRCaUMsSUFBNUIsR0FBbUMsR0FBN0MsQ0FBTjtBQUNIO0FBQ0QsUUFBSW83Qix1QkFBSixFQUE2QjtBQUN6QixZQUFJVyxtQkFBbUIsRUFBdkI7QUFDQSxZQUFJQyxZQUFZLEVBQWhCO0FBQ0EsYUFBSyxJQUFJMWUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJelMsV0FBV3pQLEtBQVgsQ0FBaUJDLE1BQXJDLEVBQTZDaWlCLEdBQTdDLEVBQWtEO0FBQzlDLGdCQUFJMmUsU0FBU3B4QixXQUFXelAsS0FBWCxDQUFpQmtpQixDQUFqQixDQUFiO0FBQ0EsZ0JBQUlqZCxPQUFPNDdCLE9BQU8sQ0FBUCxFQUFVNTdCLElBQXJCO0FBQ0EsZ0JBQUkwN0IsaUJBQWlCMTdCLElBQWpCLE1BQTJCckIsU0FBL0IsRUFBMEM7QUFDdEMrOEIsaUNBQWlCMTdCLElBQWpCLElBQXlCO0FBQ3JCQSwwQkFBTUEsSUFEZTtBQUVyQkwsMEJBQU02SyxXQUFXN0ssSUFGSTtBQUdyQnFRLDhCQUFVeEYsV0FBV3dGLFFBSEE7QUFJckJrckIsNkJBQVMxd0IsV0FBVzB3QixPQUpDO0FBS3JCbmdDLDJCQUFPO0FBTGMsaUJBQXpCO0FBT0E0Z0MsMEJBQVVoZ0MsSUFBVixDQUFlcUUsSUFBZjtBQUNIO0FBQ0QwN0IsNkJBQWlCMTdCLElBQWpCLEVBQXVCakYsS0FBdkIsQ0FBNkJZLElBQTdCLENBQWtDLENBQzlCaWdDLE9BQU8sQ0FBUCxFQUFVLzBCLEtBRG9CLEVBRTlCKzBCLE9BQU8sQ0FBUCxDQUY4QixDQUFsQztBQUlIO0FBQ0QsWUFBSUMsdUJBQXVCLEVBQTNCO0FBQ0EsYUFBSyxJQUFJbmQsTUFBTSxDQUFWLEVBQWF5SixTQUFTd1QsU0FBM0IsRUFBc0NqZCxNQUFNeUosT0FBT250QixNQUFuRCxFQUEyRDBqQixPQUFPLENBQWxFLEVBQXFFO0FBQ2pFLGdCQUFJaU4sSUFBSXhELE9BQU96SixHQUFQLENBQVI7QUFDQW1kLGlDQUFxQmxnQyxJQUFyQixDQUEwQixDQUN0QisvQixpQkFBaUIvUCxDQUFqQixFQUFvQjNyQixJQURFLEVBRXRCNDZCLGVBQWVjLGlCQUFpQi9QLENBQWpCLENBQWYsRUFBb0NrUCxZQUFwQyxDQUZzQixDQUExQjtBQUlIO0FBQ0QsWUFBSWlCLG9CQUFvQixFQUFFbjFCLE1BQU0sUUFBUixFQUF4QjtBQUNBLGVBQU87QUFDSHVhLGtCQUFNLFdBREg7QUFFSDRhLCtCQUFtQkEsaUJBRmhCO0FBR0huSCxpQ0FBcUJILFlBQVlHLG1CQUFaLENBQWdDb0gsSUFBaEMsQ0FBcUNwOUIsU0FBckMsRUFBZ0RtOUIsaUJBQWhELENBSGxCO0FBSUhILHVCQUFXRSxxQkFBcUJ4Z0MsR0FBckIsQ0FBeUIsVUFBVTRoQixDQUFWLEVBQWE7QUFDN0MsdUJBQU9BLEVBQUUsQ0FBRixDQUFQO0FBQ0gsYUFGVSxDQUpSO0FBT0h5SixzQkFBVSxTQUFTQSxRQUFULENBQWtCN2xCLEdBQWxCLEVBQXVCaU4sVUFBdkIsRUFBbUM7QUFDekMsb0JBQUk5TixPQUFPYSxJQUFJYixJQUFmO0FBQ0EsdUJBQU9zN0IsNEJBQTRCO0FBQy9CdmdDLDJCQUFPOGdDLG9CQUR3QjtBQUUvQjlyQiwwQkFBTXZGLFdBQVd1RjtBQUZjLGlCQUE1QixFQUdKOHFCLFlBSEksRUFHVTc2QixJQUhWLEVBR2dCMG1CLFFBSGhCLENBR3lCMW1CLElBSHpCLEVBRytCOE4sVUFIL0IsQ0FBUDtBQUlIO0FBYkUsU0FBUDtBQWVILEtBN0NELE1BNkNPLElBQUltdEIsYUFBSixFQUFtQjtBQUN0QixZQUFJZSxzQkFBc0JyOEIsU0FBUyxhQUFULEdBQXlCO0FBQy9DZ0gsa0JBQU0sYUFEeUM7QUFFL0NvSixrQkFBTXZGLFdBQVd1RixJQUFYLEtBQW9CcFIsU0FBcEIsR0FBZ0M2TCxXQUFXdUYsSUFBM0MsR0FBa0Q7QUFGVCxTQUF6QixHQUd0QixJQUhKO0FBSUEsZUFBTztBQUNIbVIsa0JBQU0sUUFESDtBQUVINGEsK0JBQW1CRSxtQkFGaEI7QUFHSHJILGlDQUFxQkgsWUFBWUcsbUJBQVosQ0FBZ0NvSCxJQUFoQyxDQUFxQ3A5QixTQUFyQyxFQUFnRHE5QixtQkFBaEQsQ0FIbEI7QUFJSEwsdUJBQVdueEIsV0FBV3pQLEtBQVgsQ0FBaUJNLEdBQWpCLENBQXFCLFVBQVU0aEIsQ0FBVixFQUFhO0FBQ3pDLHVCQUFPQSxFQUFFLENBQUYsQ0FBUDtBQUNILGFBRlUsQ0FKUjtBQU9IeUosc0JBQVUsa0JBQVU3bEIsR0FBVixFQUFlO0FBQ3JCLG9CQUFJYixPQUFPYSxJQUFJYixJQUFmO0FBQ0EsdUJBQU9tN0IsU0FBUzN3QixVQUFULEVBQXFCcXdCLFlBQXJCLEVBQW1DNzZCLElBQW5DLEVBQXlDbzdCLFdBQXpDLEVBQXNEQyxrQkFBdEQsQ0FBUDtBQUNIO0FBVkUsU0FBUDtBQVlILEtBakJNLE1BaUJBO0FBQ0gsZUFBTztBQUNIbmEsa0JBQU0sUUFESDtBQUVId0Ysc0JBQVUsU0FBU0EsUUFBVCxDQUFrQnlRLENBQWxCLEVBQXFCdk8sT0FBckIsRUFBOEI7QUFDcEMsb0JBQUkvaEIsUUFBUStoQixXQUFXQSxRQUFROWEsVUFBbkIsR0FBZ0M4YSxRQUFROWEsVUFBUixDQUFtQnRELFdBQVd3RixRQUE5QixDQUFoQyxHQUEwRXJSLFNBQXRGO0FBQ0Esb0JBQUlrSSxVQUFVbEksU0FBZCxFQUF5QjtBQUNyQiwyQkFBT3VPLFNBQVMxQyxXQUFXMHdCLE9BQXBCLEVBQTZCTCxhQUFhSyxPQUExQyxDQUFQO0FBQ0g7QUFDRCx1QkFBT0MsU0FBUzN3QixVQUFULEVBQXFCcXdCLFlBQXJCLEVBQW1DaDBCLEtBQW5DLEVBQTBDdTBCLFdBQTFDLEVBQXVEQyxrQkFBdkQsQ0FBUDtBQUNIO0FBUkUsU0FBUDtBQVVIO0FBQ0o7QUFDRCxTQUFTbnVCLFFBQVQsQ0FBa0J0SCxDQUFsQixFQUFxQmtlLENBQXJCLEVBQXdCbUUsQ0FBeEIsRUFBMkI7QUFDdkIsUUFBSXJpQixNQUFNakgsU0FBVixFQUFxQjtBQUNqQixlQUFPaUgsQ0FBUDtBQUNIO0FBQ0QsUUFBSWtlLE1BQU1ubEIsU0FBVixFQUFxQjtBQUNqQixlQUFPbWxCLENBQVA7QUFDSDtBQUNELFFBQUltRSxNQUFNdHBCLFNBQVYsRUFBcUI7QUFDakIsZUFBT3NwQixDQUFQO0FBQ0g7QUFDSjtBQUNELFNBQVN1VCwyQkFBVCxDQUFxQ2h4QixVQUFyQyxFQUFpRHF3QixZQUFqRCxFQUErRGxsQixLQUEvRCxFQUFzRXlsQixXQUF0RSxFQUFtRmEsT0FBbkYsRUFBNEY7QUFDeEYsUUFBSUMsWUFBWSxRQUFPdm1CLEtBQVAseUNBQU9BLEtBQVAsT0FBaUJzbUIsT0FBakIsR0FBMkJiLFlBQVl6bEIsS0FBWixDQUEzQixHQUFnRGhYLFNBQWhFO0FBQ0EsV0FBT3VPLFNBQVNndkIsU0FBVCxFQUFvQjF4QixXQUFXMHdCLE9BQS9CLEVBQXdDTCxhQUFhSyxPQUFyRCxDQUFQO0FBQ0g7QUFDRCxTQUFTSyx3QkFBVCxDQUFrQy93QixVQUFsQyxFQUE4Q3F3QixZQUE5QyxFQUE0RGxsQixLQUE1RCxFQUFtRTtBQUMvRCxRQUFJNmtCLFFBQVE3a0IsS0FBUixNQUFtQixRQUF2QixFQUFpQztBQUM3QixlQUFPekksU0FBUzFDLFdBQVcwd0IsT0FBcEIsRUFBNkJMLGFBQWFLLE9BQTFDLENBQVA7QUFDSDtBQUNELFFBQUlwbEIsSUFBSXRMLFdBQVd6UCxLQUFYLENBQWlCQyxNQUF6QjtBQUNBLFFBQUk4YSxNQUFNLENBQVYsRUFBYTtBQUNULGVBQU90TCxXQUFXelAsS0FBWCxDQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFQO0FBQ0g7QUFDRCxRQUFJNGEsU0FBU25MLFdBQVd6UCxLQUFYLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLENBQWIsRUFBcUM7QUFDakMsZUFBT3lQLFdBQVd6UCxLQUFYLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLENBQVA7QUFDSDtBQUNELFFBQUk0YSxTQUFTbkwsV0FBV3pQLEtBQVgsQ0FBaUIrYSxJQUFJLENBQXJCLEVBQXdCLENBQXhCLENBQWIsRUFBeUM7QUFDckMsZUFBT3RMLFdBQVd6UCxLQUFYLENBQWlCK2EsSUFBSSxDQUFyQixFQUF3QixDQUF4QixDQUFQO0FBQ0g7QUFDRCxRQUFJdkUsUUFBUXFmLDBCQUEwQnBtQixXQUFXelAsS0FBWCxDQUFpQk0sR0FBakIsQ0FBcUIsVUFBVXlrQixJQUFWLEVBQWdCO0FBQ3ZFLGVBQU9BLEtBQUssQ0FBTCxDQUFQO0FBQ0gsS0FGcUMsQ0FBMUIsRUFFUm5LLEtBRlEsQ0FBWjtBQUdBLFdBQU9uTCxXQUFXelAsS0FBWCxDQUFpQndXLEtBQWpCLEVBQXdCLENBQXhCLENBQVA7QUFDSDtBQUNELFNBQVMrcEIsMkJBQVQsQ0FBcUM5d0IsVUFBckMsRUFBaURxd0IsWUFBakQsRUFBK0RsbEIsS0FBL0QsRUFBc0U7QUFDbEUsUUFBSTVGLE9BQU92RixXQUFXdUYsSUFBWCxLQUFvQnBSLFNBQXBCLEdBQWdDNkwsV0FBV3VGLElBQTNDLEdBQWtELENBQTdEO0FBQ0EsUUFBSXlxQixRQUFRN2tCLEtBQVIsTUFBbUIsUUFBdkIsRUFBaUM7QUFDN0IsZUFBT3pJLFNBQVMxQyxXQUFXMHdCLE9BQXBCLEVBQTZCTCxhQUFhSyxPQUExQyxDQUFQO0FBQ0g7QUFDRCxRQUFJcGxCLElBQUl0TCxXQUFXelAsS0FBWCxDQUFpQkMsTUFBekI7QUFDQSxRQUFJOGEsTUFBTSxDQUFWLEVBQWE7QUFDVCxlQUFPdEwsV0FBV3pQLEtBQVgsQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsQ0FBUDtBQUNIO0FBQ0QsUUFBSTRhLFNBQVNuTCxXQUFXelAsS0FBWCxDQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFiLEVBQXFDO0FBQ2pDLGVBQU95UCxXQUFXelAsS0FBWCxDQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFQO0FBQ0g7QUFDRCxRQUFJNGEsU0FBU25MLFdBQVd6UCxLQUFYLENBQWlCK2EsSUFBSSxDQUFyQixFQUF3QixDQUF4QixDQUFiLEVBQXlDO0FBQ3JDLGVBQU90TCxXQUFXelAsS0FBWCxDQUFpQithLElBQUksQ0FBckIsRUFBd0IsQ0FBeEIsQ0FBUDtBQUNIO0FBQ0QsUUFBSXZFLFFBQVFxZiwwQkFBMEJwbUIsV0FBV3pQLEtBQVgsQ0FBaUJNLEdBQWpCLENBQXFCLFVBQVV5a0IsSUFBVixFQUFnQjtBQUN2RSxlQUFPQSxLQUFLLENBQUwsQ0FBUDtBQUNILEtBRnFDLENBQTFCLEVBRVJuSyxLQUZRLENBQVo7QUFHQSxRQUFJUyxJQUFJdWUsb0JBQW9CaGYsS0FBcEIsRUFBMkI1RixJQUEzQixFQUFpQ3ZGLFdBQVd6UCxLQUFYLENBQWlCd1csS0FBakIsRUFBd0IsQ0FBeEIsQ0FBakMsRUFBNkQvRyxXQUFXelAsS0FBWCxDQUFpQndXLFFBQVEsQ0FBekIsRUFBNEIsQ0FBNUIsQ0FBN0QsQ0FBUjtBQUNBLFFBQUkwakIsY0FBY3pxQixXQUFXelAsS0FBWCxDQUFpQndXLEtBQWpCLEVBQXdCLENBQXhCLENBQWxCO0FBQ0EsUUFBSTJqQixjQUFjMXFCLFdBQVd6UCxLQUFYLENBQWlCd1csUUFBUSxDQUF6QixFQUE0QixDQUE1QixDQUFsQjtBQUNBLFFBQUk0cUIsU0FBUy91QixZQUFZeXRCLGFBQWFsN0IsSUFBekIsS0FBa0NnN0IsZ0JBQS9DO0FBQ0EsUUFBSW53QixXQUFXNkYsVUFBWCxJQUF5QjdGLFdBQVc2RixVQUFYLEtBQTBCLEtBQXZELEVBQThEO0FBQzFELFlBQUkrckIsYUFBYTdILFlBQVkvcEIsV0FBVzZGLFVBQXZCLENBQWpCO0FBQ0E4ckIsaUJBQVMsZ0JBQVV2MkIsQ0FBVixFQUFha2UsQ0FBYixFQUFnQjtBQUNyQixtQkFBT3NZLFdBQVd2YyxPQUFYLENBQW1CdWMsV0FBV2h2QixXQUFYLENBQXVCZ3ZCLFdBQVc5SCxPQUFYLENBQW1CMXVCLENBQW5CLENBQXZCLEVBQThDdzJCLFdBQVc5SCxPQUFYLENBQW1CeFEsQ0FBbkIsQ0FBOUMsRUFBcUUxTixDQUFyRSxDQUFuQixDQUFQO0FBQ0gsU0FGRDtBQUdIO0FBQ0QsUUFBSSxPQUFPNmUsWUFBWXZPLFFBQW5CLEtBQWdDLFVBQXBDLEVBQWdEO0FBQzVDLGVBQU87QUFDSEEsc0JBQVUsU0FBU0EsUUFBVCxHQUFvQjtBQUMxQixvQkFBSUgsT0FBTyxFQUFYO0FBQUEsb0JBQWVwTyxNQUFNcUksVUFBVXhsQixNQUEvQjtBQUNBLHVCQUFPbWQsS0FBUDtBQUNJb08seUJBQUtwTyxHQUFMLElBQVlxSSxVQUFVckksR0FBVixDQUFaO0FBREosaUJBRUEsSUFBSWtrQixpQkFBaUJwSCxZQUFZdk8sUUFBWixDQUFxQnJzQixLQUFyQixDQUEyQnNFLFNBQTNCLEVBQXNDNG5CLElBQXRDLENBQXJCO0FBQ0Esb0JBQUkrVixpQkFBaUJwSCxZQUFZeE8sUUFBWixDQUFxQnJzQixLQUFyQixDQUEyQnNFLFNBQTNCLEVBQXNDNG5CLElBQXRDLENBQXJCO0FBQ0Esb0JBQUk4VixtQkFBbUIxOUIsU0FBbkIsSUFBZ0MyOUIsbUJBQW1CMzlCLFNBQXZELEVBQWtFO0FBQzlELDJCQUFPQSxTQUFQO0FBQ0g7QUFDRCx1QkFBT3c5QixPQUFPRSxjQUFQLEVBQXVCQyxjQUF2QixFQUF1Q2xtQixDQUF2QyxDQUFQO0FBQ0g7QUFYRSxTQUFQO0FBYUg7QUFDRCxXQUFPK2xCLE9BQU9sSCxXQUFQLEVBQW9CQyxXQUFwQixFQUFpQzllLENBQWpDLENBQVA7QUFDSDtBQUNELFNBQVNxbEIsd0JBQVQsQ0FBa0NqeEIsVUFBbEMsRUFBOENxd0IsWUFBOUMsRUFBNERsbEIsS0FBNUQsRUFBbUU7QUFDL0QsUUFBSWtsQixhQUFhbDdCLElBQWIsS0FBc0IsT0FBMUIsRUFBbUM7QUFDL0JnVyxnQkFBUXZWLE1BQU01QyxLQUFOLENBQVltWSxLQUFaLENBQVI7QUFDSCxLQUZELE1BRU8sSUFBSWtsQixhQUFhbDdCLElBQWIsS0FBc0IsV0FBMUIsRUFBdUM7QUFDMUNnVyxnQkFBUTBQLFVBQVVFLFVBQVYsQ0FBcUI1UCxNQUFNdFYsUUFBTixFQUFyQixDQUFSO0FBQ0gsS0FGTSxNQUVBLElBQUl3NkIsYUFBYWw3QixJQUFiLEtBQXNCLGVBQTFCLEVBQTJDO0FBQzlDZ1csZ0JBQVFtUSxjQUFjUCxVQUFkLENBQXlCNVAsTUFBTXRWLFFBQU4sRUFBekIsQ0FBUjtBQUNILEtBRk0sTUFFQSxJQUFJbTZCLFFBQVE3a0IsS0FBUixNQUFtQmtsQixhQUFhbDdCLElBQWhDLEtBQXlDazdCLGFBQWFsN0IsSUFBYixLQUFzQixNQUF0QixJQUFnQyxDQUFDazdCLGFBQWFyMEIsTUFBYixDQUFvQm1QLEtBQXBCLENBQTFFLENBQUosRUFBMkc7QUFDOUdBLGdCQUFRaFgsU0FBUjtBQUNIO0FBQ0QsV0FBT3VPLFNBQVN5SSxLQUFULEVBQWdCbkwsV0FBVzB3QixPQUEzQixFQUFvQ0wsYUFBYUssT0FBakQsQ0FBUDtBQUNIO0FBQ0QsU0FBU3ZHLG1CQUFULENBQTZCaGYsS0FBN0IsRUFBb0M1RixJQUFwQyxFQUEwQ29sQixVQUExQyxFQUFzREMsVUFBdEQsRUFBa0U7QUFDOUQsUUFBSUMsYUFBYUQsYUFBYUQsVUFBOUI7QUFDQSxRQUFJRyxXQUFXM2YsUUFBUXdmLFVBQXZCO0FBQ0EsUUFBSUUsZUFBZSxDQUFuQixFQUFzQjtBQUNsQixlQUFPLENBQVA7QUFDSCxLQUZELE1BRU8sSUFBSXRsQixTQUFTLENBQWIsRUFBZ0I7QUFDbkIsZUFBT3VsQixXQUFXRCxVQUFsQjtBQUNILEtBRk0sTUFFQTtBQUNILGVBQU8sQ0FBQ25oQixLQUFLd1gsR0FBTCxDQUFTM2IsSUFBVCxFQUFldWxCLFFBQWYsSUFBMkIsQ0FBNUIsS0FBa0NwaEIsS0FBS3dYLEdBQUwsQ0FBUzNiLElBQVQsRUFBZXNsQixVQUFmLElBQTZCLENBQS9ELENBQVA7QUFDSDtBQUNKOztBQUVELElBQUlrSCxrQkFBa0IsU0FBU0EsZUFBVCxDQUF5Qmp5QixVQUF6QixFQUFxQ3V3QixZQUFyQyxFQUFtRDtBQUNyRSxTQUFLdndCLFVBQUwsR0FBa0JBLFVBQWxCO0FBQ0EsU0FBS2t5QixlQUFMLEdBQXVCLEVBQXZCO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixJQUFJL1QsaUJBQUosRUFBbEI7QUFDQSxTQUFLZ1UsYUFBTCxHQUFxQjdCLGVBQWU4QixnQkFBZ0I5QixZQUFoQixDQUFmLEdBQStDLElBQXBFO0FBQ0EsU0FBSytCLFdBQUwsR0FBbUIvQixnQkFBZ0JBLGFBQWFsN0IsSUFBYixLQUFzQixNQUF0QyxHQUErQ2s3QixhQUFhcjBCLE1BQTVELEdBQXFFLElBQXhGO0FBQ0gsQ0FORDtBQU9BKzFCLGdCQUFnQjNrQixTQUFoQixDQUEwQmlsQiw0QkFBMUIsR0FBeUQsU0FBU0EsNEJBQVQsQ0FBc0NsVSxPQUF0QyxFQUErQ0MsT0FBL0MsRUFBd0RDLFlBQXhELEVBQXNFRyxTQUF0RSxFQUFpRm5CLGVBQWpGLEVBQWtHaUIsZ0JBQWxHLEVBQW9IO0FBQ3pLLFNBQUsyVCxVQUFMLENBQWdCOVQsT0FBaEIsR0FBMEJBLE9BQTFCO0FBQ0EsU0FBSzhULFVBQUwsQ0FBZ0I3VCxPQUFoQixHQUEwQkEsT0FBMUI7QUFDQSxTQUFLNlQsVUFBTCxDQUFnQjVULFlBQWhCLEdBQStCQSxZQUEvQjtBQUNBLFNBQUs0VCxVQUFMLENBQWdCelQsU0FBaEIsR0FBNEJBLFNBQTVCO0FBQ0EsU0FBS3lULFVBQUwsQ0FBZ0I1VSxlQUFoQixHQUFrQ0EsbUJBQW1CLElBQXJEO0FBQ0EsU0FBSzRVLFVBQUwsQ0FBZ0IzVCxnQkFBaEIsR0FBbUNBLGdCQUFuQztBQUNBLFdBQU8sS0FBS3hlLFVBQUwsQ0FBZ0JvYyxRQUFoQixDQUF5QixLQUFLK1YsVUFBOUIsQ0FBUDtBQUNILENBUkQ7QUFTQUYsZ0JBQWdCM2tCLFNBQWhCLENBQTBCOE8sUUFBMUIsR0FBcUMsU0FBU0EsUUFBVCxDQUFrQmlDLE9BQWxCLEVBQTJCQyxPQUEzQixFQUFvQ0MsWUFBcEMsRUFBa0RHLFNBQWxELEVBQTZEbkIsZUFBN0QsRUFBOEVpQixnQkFBOUUsRUFBZ0c7QUFDakksU0FBSzJULFVBQUwsQ0FBZ0I5VCxPQUFoQixHQUEwQkEsT0FBMUI7QUFDQSxTQUFLOFQsVUFBTCxDQUFnQjdULE9BQWhCLEdBQTBCQSxXQUFXLElBQXJDO0FBQ0EsU0FBSzZULFVBQUwsQ0FBZ0I1VCxZQUFoQixHQUErQkEsZ0JBQWdCLElBQS9DO0FBQ0EsU0FBSzRULFVBQUwsQ0FBZ0J6VCxTQUFoQixHQUE0QkEsU0FBNUI7QUFDQSxTQUFLeVQsVUFBTCxDQUFnQjVVLGVBQWhCLEdBQWtDQSxtQkFBbUIsSUFBckQ7QUFDQSxTQUFLNFUsVUFBTCxDQUFnQjNULGdCQUFoQixHQUFtQ0Esb0JBQW9CLElBQXZEO0FBQ0EsUUFBSTtBQUNBLFlBQUkyUixNQUFNLEtBQUtud0IsVUFBTCxDQUFnQm9jLFFBQWhCLENBQXlCLEtBQUsrVixVQUE5QixDQUFWO0FBQ0EsWUFBSWhDLFFBQVEsSUFBUixJQUFnQkEsUUFBUTk3QixTQUF4QixJQUFxQyxPQUFPODdCLEdBQVAsS0FBZSxRQUFmLElBQTJCQSxRQUFRQSxHQUE1RSxFQUFpRjtBQUM3RSxtQkFBTyxLQUFLaUMsYUFBWjtBQUNIO0FBQ0QsWUFBSSxLQUFLRSxXQUFMLElBQW9CLEVBQUVuQyxPQUFPLEtBQUttQyxXQUFkLENBQXhCLEVBQW9EO0FBQ2hELGtCQUFNLElBQUkvVixZQUFKLENBQWlCLGlDQUFpQzdVLE9BQU9OLElBQVAsQ0FBWSxLQUFLa3JCLFdBQWpCLEVBQThCdmhDLEdBQTlCLENBQWtDLFVBQVVtZCxDQUFWLEVBQWE7QUFDbkcsdUJBQU9qYixLQUFLb1QsU0FBTCxDQUFlNkgsQ0FBZixDQUFQO0FBQ0gsYUFGdUQsRUFFckR6UyxJQUZxRCxDQUVoRCxJQUZnRCxDQUFqQyxHQUVQLGNBRk8sR0FFVXhJLEtBQUtvVCxTQUFMLENBQWU4cEIsR0FBZixDQUZWLEdBRWdDLFdBRmpELENBQU47QUFHSDtBQUNELGVBQU9BLEdBQVA7QUFDSCxLQVhELENBV0UsT0FBT2w3QixDQUFQLEVBQVU7QUFDUixZQUFJLENBQUMsS0FBS2k5QixlQUFMLENBQXFCajlCLEVBQUVtaEIsT0FBdkIsQ0FBTCxFQUFzQztBQUNsQyxpQkFBSzhiLGVBQUwsQ0FBcUJqOUIsRUFBRW1oQixPQUF2QixJQUFrQyxJQUFsQztBQUNBLGdCQUFJLE9BQU8zaEIsT0FBUCxLQUFtQixXQUF2QixFQUFvQztBQUNoQ0Esd0JBQVErOUIsSUFBUixDQUFhdjlCLEVBQUVtaEIsT0FBZjtBQUNIO0FBQ0o7QUFDRCxlQUFPLEtBQUtnYyxhQUFaO0FBQ0g7QUFDSixDQTNCRDtBQTRCQSxTQUFTSyxZQUFULENBQXNCenlCLFVBQXRCLEVBQWtDO0FBQzlCLFdBQU96UCxNQUFNQyxPQUFOLENBQWN3UCxVQUFkLEtBQTZCQSxXQUFXdFAsTUFBWCxHQUFvQixDQUFqRCxJQUFzRCxPQUFPc1AsV0FBVyxDQUFYLENBQVAsS0FBeUIsUUFBL0UsSUFBMkZBLFdBQVcsQ0FBWCxLQUFpQm12QixXQUFuSDtBQUNIO0FBQ0QsU0FBU3VELGdCQUFULENBQTBCMXlCLFVBQTFCLEVBQXNDdXdCLFlBQXRDLEVBQW9EO0FBQ2hELFFBQUlvQyxTQUFTLElBQUlsVCxjQUFKLENBQW1CMFAsV0FBbkIsRUFBZ0MsRUFBaEMsRUFBb0NvQixlQUFlcUMsZ0JBQWdCckMsWUFBaEIsQ0FBZixHQUErQ2w4QixTQUFuRixDQUFiO0FBQ0EsUUFBSXNvQixTQUFTZ1csT0FBT3ovQixLQUFQLENBQWE4TSxVQUFiLEVBQXlCM0wsU0FBekIsRUFBb0NBLFNBQXBDLEVBQStDQSxTQUEvQyxFQUEwRGs4QixnQkFBZ0JBLGFBQWFsN0IsSUFBYixLQUFzQixRQUF0QyxHQUFpRCxFQUFFd3dCLGdCQUFnQixRQUFsQixFQUFqRCxHQUFnRnh4QixTQUExSSxDQUFiO0FBQ0EsUUFBSSxDQUFDc29CLE1BQUwsRUFBYTtBQUNULGVBQU9qb0IsTUFBTWkrQixPQUFPanBCLE1BQWIsQ0FBUDtBQUNIO0FBQ0QsV0FBT21tQixRQUFRLElBQUlvQyxlQUFKLENBQW9CdFYsTUFBcEIsRUFBNEI0VCxZQUE1QixDQUFSLENBQVA7QUFDSDtBQUNELElBQUlzQyx5QkFBeUIsU0FBU0Esc0JBQVQsQ0FBZ0NqYyxJQUFoQyxFQUFzQzVXLFVBQXRDLEVBQWtEO0FBQzNFLFNBQUs0VyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLa2MsZ0JBQUwsR0FBd0I5eUIsVUFBeEI7QUFDQSxTQUFLK3lCLGdCQUFMLEdBQXdCbmMsU0FBUyxVQUFULElBQXVCLENBQUMwTyxnQkFBZ0J0bEIsV0FBV0EsVUFBM0IsQ0FBaEQ7QUFDSCxDQUpEO0FBS0E2eUIsdUJBQXVCdmxCLFNBQXZCLENBQWlDaWxCLDRCQUFqQyxHQUFnRSxTQUFTQSw0QkFBVCxDQUFzQ2xVLE9BQXRDLEVBQStDQyxPQUEvQyxFQUF3REMsWUFBeEQsRUFBc0VHLFNBQXRFLEVBQWlGbkIsZUFBakYsRUFBa0dpQixnQkFBbEcsRUFBb0g7QUFDaEwsV0FBTyxLQUFLc1UsZ0JBQUwsQ0FBc0JQLDRCQUF0QixDQUFtRGxVLE9BQW5ELEVBQTREQyxPQUE1RCxFQUFxRUMsWUFBckUsRUFBbUZHLFNBQW5GLEVBQThGbkIsZUFBOUYsRUFBK0dpQixnQkFBL0csQ0FBUDtBQUNILENBRkQ7QUFHQXFVLHVCQUF1QnZsQixTQUF2QixDQUFpQzhPLFFBQWpDLEdBQTRDLFNBQVNBLFFBQVQsQ0FBa0JpQyxPQUFsQixFQUEyQkMsT0FBM0IsRUFBb0NDLFlBQXBDLEVBQWtERyxTQUFsRCxFQUE2RG5CLGVBQTdELEVBQThFaUIsZ0JBQTlFLEVBQWdHO0FBQ3hJLFdBQU8sS0FBS3NVLGdCQUFMLENBQXNCMVcsUUFBdEIsQ0FBK0JpQyxPQUEvQixFQUF3Q0MsT0FBeEMsRUFBaURDLFlBQWpELEVBQStERyxTQUEvRCxFQUEwRW5CLGVBQTFFLEVBQTJGaUIsZ0JBQTNGLENBQVA7QUFDSCxDQUZEO0FBR0EsSUFBSXdVLDBCQUEwQixTQUFTQSx1QkFBVCxDQUFpQ3BjLElBQWpDLEVBQXVDNVcsVUFBdkMsRUFBbURxeEIsU0FBbkQsRUFBOERHLGlCQUE5RCxFQUFpRjtBQUMzRyxTQUFLNWEsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS3lhLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0EsU0FBS3lCLGdCQUFMLEdBQXdCOXlCLFVBQXhCO0FBQ0EsU0FBSyt5QixnQkFBTCxHQUF3Qm5jLFNBQVMsUUFBVCxJQUFxQixDQUFDME8sZ0JBQWdCdGxCLFdBQVdBLFVBQTNCLENBQTlDO0FBQ0EsU0FBS3d4QixpQkFBTCxHQUF5QkEsaUJBQXpCO0FBQ0gsQ0FORDtBQU9Bd0Isd0JBQXdCMWxCLFNBQXhCLENBQWtDaWxCLDRCQUFsQyxHQUFpRSxTQUFTQSw0QkFBVCxDQUFzQ2xVLE9BQXRDLEVBQStDQyxPQUEvQyxFQUF3REMsWUFBeEQsRUFBc0VHLFNBQXRFLEVBQWlGbkIsZUFBakYsRUFBa0dpQixnQkFBbEcsRUFBb0g7QUFDakwsV0FBTyxLQUFLc1UsZ0JBQUwsQ0FBc0JQLDRCQUF0QixDQUFtRGxVLE9BQW5ELEVBQTREQyxPQUE1RCxFQUFxRUMsWUFBckUsRUFBbUZHLFNBQW5GLEVBQThGbkIsZUFBOUYsRUFBK0dpQixnQkFBL0csQ0FBUDtBQUNILENBRkQ7QUFHQXdVLHdCQUF3QjFsQixTQUF4QixDQUFrQzhPLFFBQWxDLEdBQTZDLFNBQVNBLFFBQVQsQ0FBa0JpQyxPQUFsQixFQUEyQkMsT0FBM0IsRUFBb0NDLFlBQXBDLEVBQWtERyxTQUFsRCxFQUE2RG5CLGVBQTdELEVBQThFaUIsZ0JBQTlFLEVBQWdHO0FBQ3pJLFdBQU8sS0FBS3NVLGdCQUFMLENBQXNCMVcsUUFBdEIsQ0FBK0JpQyxPQUEvQixFQUF3Q0MsT0FBeEMsRUFBaURDLFlBQWpELEVBQStERyxTQUEvRCxFQUEwRW5CLGVBQTFFLEVBQTJGaUIsZ0JBQTNGLENBQVA7QUFDSCxDQUZEO0FBR0F3VSx3QkFBd0IxbEIsU0FBeEIsQ0FBa0MrYyxtQkFBbEMsR0FBd0QsU0FBU0EsbUJBQVQsQ0FBNkJoZixLQUE3QixFQUFvQ2lmLEtBQXBDLEVBQTJDQyxLQUEzQyxFQUFrRDtBQUN0RyxRQUFJLEtBQUtpSCxpQkFBVCxFQUE0QjtBQUN4QixlQUFPdEgsWUFBWUcsbUJBQVosQ0FBZ0MsS0FBS21ILGlCQUFyQyxFQUF3RG5tQixLQUF4RCxFQUErRGlmLEtBQS9ELEVBQXNFQyxLQUF0RSxDQUFQO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsZUFBTyxDQUFQO0FBQ0g7QUFDSixDQU5EO0FBT0EsU0FBUzBJLHdCQUFULENBQWtDanpCLFVBQWxDLEVBQThDdXdCLFlBQTlDLEVBQTREO0FBQ3hEdndCLGlCQUFhMHlCLGlCQUFpQjF5QixVQUFqQixFQUE2QnV3QixZQUE3QixDQUFiO0FBQ0EsUUFBSXZ3QixXQUFXNkgsTUFBWCxLQUFzQixPQUExQixFQUFtQztBQUMvQixlQUFPN0gsVUFBUDtBQUNIO0FBQ0QsUUFBSTJjLFNBQVMzYyxXQUFXekQsS0FBWCxDQUFpQnlELFVBQTlCO0FBQ0EsUUFBSWt6QixzQkFBc0I3TixrQkFBa0IxSSxNQUFsQixDQUExQjtBQUNBLFFBQUksQ0FBQ3VXLG1CQUFELElBQXdCLENBQUNwRCwyQkFBMkJTLFlBQTNCLENBQTdCLEVBQXVFO0FBQ25FLGVBQU83N0IsTUFBTSxDQUFDLElBQUl5aEIsWUFBSixDQUFpQixFQUFqQixFQUFxQixnQ0FBckIsQ0FBRCxDQUFOLENBQVA7QUFDSDtBQUNELFFBQUlnZCxpQkFBaUI1Tix5QkFBeUI1SSxNQUF6QixFQUFpQyxDQUFDLE1BQUQsQ0FBakMsQ0FBckI7QUFDQSxRQUFJLENBQUN3VyxjQUFELElBQW1CLENBQUNuRCx1QkFBdUJPLFlBQXZCLENBQXhCLEVBQThEO0FBQzFELGVBQU83N0IsTUFBTSxDQUFDLElBQUl5aEIsWUFBSixDQUFpQixFQUFqQixFQUFxQixnQ0FBckIsQ0FBRCxDQUFOLENBQVA7QUFDSDtBQUNELFFBQUlpZCxZQUFZQyxjQUFjMVcsTUFBZCxDQUFoQjtBQUNBLFFBQUksQ0FBQ3lXLFNBQUQsSUFBYyxDQUFDRCxjQUFuQixFQUFtQztBQUMvQixlQUFPeitCLE1BQU0sQ0FBQyxJQUFJeWhCLFlBQUosQ0FBaUIsRUFBakIsRUFBcUIsZ0dBQXJCLENBQUQsQ0FBTixDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUlpZCxxQkFBcUJqZCxZQUF6QixFQUF1QztBQUMxQyxlQUFPemhCLE1BQU0sQ0FBQzArQixTQUFELENBQU4sQ0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJQSxxQkFBcUJsSixXQUFyQixJQUFvQyxDQUFDK0Ysc0JBQXNCTSxZQUF0QixDQUF6QyxFQUE4RTtBQUNqRixlQUFPNzdCLE1BQU0sQ0FBQyxJQUFJeWhCLFlBQUosQ0FBaUIsRUFBakIsRUFBcUIsNkRBQXJCLENBQUQsQ0FBTixDQUFQO0FBQ0g7QUFDRCxRQUFJLENBQUNpZCxTQUFMLEVBQWdCO0FBQ1osZUFBT3ZELFFBQVFxRCxzQkFBc0IsSUFBSUwsc0JBQUosQ0FBMkIsVUFBM0IsRUFBdUM3eUIsV0FBV3pELEtBQWxELENBQXRCLEdBQWlGLElBQUlzMkIsc0JBQUosQ0FBMkIsUUFBM0IsRUFBcUM3eUIsV0FBV3pELEtBQWhELENBQXpGLENBQVA7QUFDSDtBQUNELFFBQUlpMUIsb0JBQW9CNEIscUJBQXFCbEosV0FBckIsR0FBbUNrSixVQUFVaEosYUFBN0MsR0FBNkQvMUIsU0FBckY7QUFDQSxXQUFPdzdCLFFBQVFxRCxzQkFBc0IsSUFBSUYsdUJBQUosQ0FBNEIsUUFBNUIsRUFBc0NoekIsV0FBV3pELEtBQWpELEVBQXdENjJCLFVBQVVscEIsTUFBbEUsRUFBMEVzbkIsaUJBQTFFLENBQXRCLEdBQXFILElBQUl3Qix1QkFBSixDQUE0QixXQUE1QixFQUF5Q2h6QixXQUFXekQsS0FBcEQsRUFBMkQ2MkIsVUFBVWxwQixNQUFyRSxFQUE2RXNuQixpQkFBN0UsQ0FBN0gsQ0FBUDtBQUNIO0FBQ0QsSUFBSThCLHdCQUF3QixTQUFTQSxxQkFBVCxDQUErQnB6QixVQUEvQixFQUEyQ3F6QixhQUEzQyxFQUEwRDtBQUNsRixTQUFLQyxXQUFMLEdBQW1CdHpCLFVBQW5CO0FBQ0EsU0FBS3V6QixjQUFMLEdBQXNCRixhQUF0QjtBQUNBdmQsV0FBTyxJQUFQLEVBQWFzYSxlQUFlLEtBQUtrRCxXQUFwQixFQUFpQyxLQUFLQyxjQUF0QyxDQUFiO0FBQ0gsQ0FKRDtBQUtBSCxzQkFBc0JJLFdBQXRCLEdBQW9DLFNBQVNBLFdBQVQsQ0FBcUJuWSxVQUFyQixFQUFpQztBQUNqRSxXQUFPLElBQUkrWCxxQkFBSixDQUEwQi9YLFdBQVdpWSxXQUFyQyxFQUFrRGpZLFdBQVdrWSxjQUE3RCxDQUFQO0FBQ0gsQ0FGRDtBQUdBSCxzQkFBc0JoWSxTQUF0QixHQUFrQyxTQUFTQSxTQUFULENBQW1CalEsS0FBbkIsRUFBMEI7QUFDeEQsV0FBTztBQUNIbW9CLHFCQUFhbm9CLE1BQU1tb0IsV0FEaEI7QUFFSEMsd0JBQWdCcG9CLE1BQU1vb0I7QUFGbkIsS0FBUDtBQUlILENBTEQ7QUFNQSxTQUFTRSwyQkFBVCxDQUFxQ3AzQixLQUFyQyxFQUE0Q2czQixhQUE1QyxFQUEyRDtBQUN2RCxRQUFJbkQsYUFBYTd6QixLQUFiLENBQUosRUFBeUI7QUFDckIsZUFBTyxJQUFJKzJCLHFCQUFKLENBQTBCLzJCLEtBQTFCLEVBQWlDZzNCLGFBQWpDLENBQVA7QUFDSCxLQUZELE1BRU8sSUFBSWQsYUFBYWwyQixLQUFiLENBQUosRUFBeUI7QUFDNUIsWUFBSXlELGFBQWFpekIseUJBQXlCMTJCLEtBQXpCLEVBQWdDZzNCLGFBQWhDLENBQWpCO0FBQ0EsWUFBSXZ6QixXQUFXNkgsTUFBWCxLQUFzQixPQUExQixFQUFtQztBQUMvQixrQkFBTSxJQUFJelUsS0FBSixDQUFVNE0sV0FBV3pELEtBQVgsQ0FBaUJ4TCxHQUFqQixDQUFxQixVQUFVeUQsR0FBVixFQUFlO0FBQ2hELHVCQUFPQSxJQUFJa0YsR0FBSixHQUFVLElBQVYsR0FBaUJsRixJQUFJNGhCLE9BQTVCO0FBQ0gsYUFGZSxFQUViM2EsSUFGYSxDQUVSLElBRlEsQ0FBVixDQUFOO0FBR0g7QUFDRCxlQUFPdUUsV0FBV3pELEtBQWxCO0FBQ0gsS0FSTSxNQVFBO0FBQ0gsWUFBSTJKLFdBQVczSixLQUFmO0FBQ0EsWUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQWpCLElBQTZCZzNCLGNBQWNsK0IsSUFBZCxLQUF1QixPQUF4RCxFQUFpRTtBQUM3RDZRLHVCQUFXcFEsTUFBTTVDLEtBQU4sQ0FBWXFKLEtBQVosQ0FBWDtBQUNIO0FBQ0QsZUFBTztBQUNIcWEsa0JBQU0sVUFESDtBQUVId0Ysc0JBQVUsb0JBQVk7QUFDbEIsdUJBQU9sVyxRQUFQO0FBQ0g7QUFKRSxTQUFQO0FBTUg7QUFDSjtBQUNELFNBQVNtdEIsYUFBVCxDQUF1QnJ6QixVQUF2QixFQUFtQztBQUMvQixRQUFJNkgsU0FBUyxJQUFiO0FBQ0EsUUFBSTdILHNCQUFzQnFyQixHQUExQixFQUErQjtBQUMzQnhqQixpQkFBU3dyQixjQUFjcnpCLFdBQVc2SCxNQUF6QixDQUFUO0FBQ0gsS0FGRCxNQUVPLElBQUk3SCxzQkFBc0JpckIsUUFBMUIsRUFBb0M7QUFDdkMsYUFBSyxJQUFJNTZCLElBQUksQ0FBUixFQUFXbWtCLE9BQU94VSxXQUFXaWMsSUFBbEMsRUFBd0M1ckIsSUFBSW1rQixLQUFLOWpCLE1BQWpELEVBQXlETCxLQUFLLENBQTlELEVBQWlFO0FBQzdELGdCQUFJNGMsTUFBTXVILEtBQUtua0IsQ0FBTCxDQUFWO0FBQ0F3WCxxQkFBU3dyQixjQUFjcG1CLEdBQWQsQ0FBVDtBQUNBLGdCQUFJcEYsTUFBSixFQUFZO0FBQ1I7QUFDSDtBQUNKO0FBQ0osS0FSTSxNQVFBLElBQUksQ0FBQzdILHNCQUFzQjRtQixJQUF0QixJQUE4QjVtQixzQkFBc0JrcUIsV0FBckQsS0FBcUVscUIsV0FBV3FMLEtBQVgsWUFBNEIwVCxrQkFBakcsSUFBdUgvZSxXQUFXcUwsS0FBWCxDQUFpQmhQLElBQWpCLEtBQTBCLE1BQXJKLEVBQTZKO0FBQ2hLd0wsaUJBQVM3SCxVQUFUO0FBQ0g7QUFDRCxRQUFJNkgsa0JBQWtCc08sWUFBdEIsRUFBb0M7QUFDaEMsZUFBT3RPLE1BQVA7QUFDSDtBQUNEN0gsZUFBV3FjLFNBQVgsQ0FBcUIsVUFBVTZCLEtBQVYsRUFBaUI7QUFDbEMsWUFBSTBWLGNBQWNQLGNBQWNuVixLQUFkLENBQWxCO0FBQ0EsWUFBSTBWLHVCQUF1QnpkLFlBQTNCLEVBQXlDO0FBQ3JDdE8scUJBQVMrckIsV0FBVDtBQUNILFNBRkQsTUFFTyxJQUFJLENBQUMvckIsTUFBRCxJQUFXK3JCLFdBQWYsRUFBNEI7QUFDL0IvckIscUJBQVMsSUFBSXNPLFlBQUosQ0FBaUIsRUFBakIsRUFBcUIsZ0dBQXJCLENBQVQ7QUFDSCxTQUZNLE1BRUEsSUFBSXRPLFVBQVUrckIsV0FBVixJQUF5Qi9yQixXQUFXK3JCLFdBQXhDLEVBQXFEO0FBQ3hEL3JCLHFCQUFTLElBQUlzTyxZQUFKLENBQWlCLEVBQWpCLEVBQXFCLHlGQUFyQixDQUFUO0FBQ0g7QUFDSixLQVREO0FBVUEsV0FBT3RPLE1BQVA7QUFDSDtBQUNELFNBQVMrcUIsZUFBVCxDQUF5QjdDLElBQXpCLEVBQStCO0FBQzNCLFFBQUl2VCxRQUFRO0FBQ1IxZixlQUFPa2EsU0FEQztBQUVSL1QsZ0JBQVE2VCxVQUZBO0FBR1I1VCxnQkFBUTJULFVBSEE7QUFJUmdkLGNBQU0vYyxVQUpFO0FBS1IzVCxpQkFBUzRULFdBTEQ7QUFNUitjLG1CQUFXemMsYUFOSDtBQU9SMGMsdUJBQWV6YztBQVBQLEtBQVo7QUFTQSxRQUFJeVksS0FBSzE2QixJQUFMLEtBQWMsT0FBbEIsRUFBMkI7QUFDdkIsZUFBT3FOLE1BQU04WixNQUFNdVQsS0FBS3h6QixLQUFYLEtBQXFCMmEsU0FBM0IsRUFBc0M2WSxLQUFLci9CLE1BQTNDLENBQVA7QUFDSDtBQUNELFdBQU84ckIsTUFBTXVULEtBQUsxNkIsSUFBWCxDQUFQO0FBQ0g7QUFDRCxTQUFTZzlCLGVBQVQsQ0FBeUJ0QyxJQUF6QixFQUErQjtBQUMzQixRQUFJQSxLQUFLMTZCLElBQUwsS0FBYyxPQUFkLElBQXlCKzZCLGFBQWFMLEtBQUthLE9BQWxCLENBQTdCLEVBQXlEO0FBQ3JELGVBQU8sSUFBSTk2QixLQUFKLENBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBUDtBQUNILEtBRkQsTUFFTyxJQUFJaTZCLEtBQUsxNkIsSUFBTCxLQUFjLE9BQWxCLEVBQTJCO0FBQzlCLGVBQU9TLE1BQU01QyxLQUFOLENBQVk2OEIsS0FBS2EsT0FBakIsS0FBNkIsSUFBcEM7QUFDSCxLQUZNLE1BRUEsSUFBSWIsS0FBS2EsT0FBTCxLQUFpQnY4QixTQUFyQixFQUFnQztBQUNuQyxlQUFPLElBQVA7QUFDSCxLQUZNLE1BRUE7QUFDSCxlQUFPMDdCLEtBQUthLE9BQVo7QUFDSDtBQUNKOztBQUVELFNBQVNvRCxjQUFULENBQXdCejNCLEtBQXhCLEVBQStCO0FBQzNCLFdBQU8sUUFBT0EsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUFqQixHQUE0QixDQUMvQixTQUQrQixFQUUvQkEsS0FGK0IsQ0FBNUIsR0FHSEEsS0FISjtBQUlIO0FBQ0QsU0FBUzAzQixlQUFULENBQXlCL3pCLFVBQXpCLEVBQXFDcXdCLFlBQXJDLEVBQW1EO0FBQy9DLFFBQUk5L0IsUUFBUXlQLFdBQVd6UCxLQUF2QjtBQUNBLFFBQUksQ0FBQ0EsS0FBTCxFQUFZO0FBQ1IsZUFBT3lqQyx3QkFBd0JoMEIsVUFBeEIsRUFBb0Nxd0IsWUFBcEMsQ0FBUDtBQUNIO0FBQ0QsUUFBSUUsMEJBQTBCaGdDLFNBQVMsUUFBT0EsTUFBTSxDQUFOLEVBQVMsQ0FBVCxDQUFQLE1BQXVCLFFBQTlEO0FBQ0EsUUFBSWlnQyxtQkFBbUJELDJCQUEyQnZ3QixXQUFXd0YsUUFBWCxLQUF3QnJSLFNBQTFFO0FBQ0EsUUFBSXM4QixnQkFBZ0JGLDJCQUEyQixDQUFDQyxnQkFBaEQ7QUFDQWpnQyxZQUFRQSxNQUFNTSxHQUFOLENBQVUsVUFBVXlrQixJQUFWLEVBQWdCO0FBQzlCLFlBQUksQ0FBQ2tiLGdCQUFELElBQXFCSCxhQUFhcHZCLE1BQWxDLElBQTRDLE9BQU9xVSxLQUFLLENBQUwsQ0FBUCxLQUFtQixRQUFuRSxFQUE2RTtBQUN6RSxtQkFBTyxDQUNIQSxLQUFLLENBQUwsQ0FERyxFQUVIMmUsbUJBQW1CM2UsS0FBSyxDQUFMLENBQW5CLENBRkcsQ0FBUDtBQUlIO0FBQ0QsZUFBTyxDQUNIQSxLQUFLLENBQUwsQ0FERyxFQUVId2UsZUFBZXhlLEtBQUssQ0FBTCxDQUFmLENBRkcsQ0FBUDtBQUlILEtBWE8sQ0FBUjtBQVlBLFFBQUlpYix1QkFBSixFQUE2QjtBQUN6QixlQUFPMkQsK0JBQStCbDBCLFVBQS9CLEVBQTJDcXdCLFlBQTNDLEVBQXlEOS9CLEtBQXpELENBQVA7QUFDSCxLQUZELE1BRU8sSUFBSWtnQyxhQUFKLEVBQW1CO0FBQ3RCLGVBQU8wRCxvQkFBb0JuMEIsVUFBcEIsRUFBZ0Nxd0IsWUFBaEMsRUFBOEM5L0IsS0FBOUMsQ0FBUDtBQUNILEtBRk0sTUFFQTtBQUNILGVBQU82akMsd0JBQXdCcDBCLFVBQXhCLEVBQW9DcXdCLFlBQXBDLEVBQWtEOS9CLEtBQWxELENBQVA7QUFDSDtBQUNKO0FBQ0QsU0FBU3lqQyx1QkFBVCxDQUFpQ2gwQixVQUFqQyxFQUE2Q3F3QixZQUE3QyxFQUEyRDtBQUN2RCxRQUFJejBCLE1BQU0sQ0FDTixLQURNLEVBRU5vRSxXQUFXd0YsUUFGTCxDQUFWO0FBSUEsUUFBSXhGLFdBQVcwd0IsT0FBWCxLQUF1QnY4QixTQUEzQixFQUFzQztBQUNsQyxlQUFPazhCLGFBQWFsN0IsSUFBYixLQUFzQixRQUF0QixHQUFpQyxDQUNwQyxRQURvQyxFQUVwQ3lHLEdBRm9DLENBQWpDLEdBR0hBLEdBSEo7QUFJSCxLQUxELE1BS08sSUFBSXkwQixhQUFhbDdCLElBQWIsS0FBc0IsTUFBMUIsRUFBa0M7QUFDckMsZUFBTyxDQUNILE9BREcsRUFFSHlHLEdBRkcsRUFHSDRMLE9BQU9OLElBQVAsQ0FBWW1wQixhQUFhcjBCLE1BQXpCLENBSEcsRUFJSEosR0FKRyxFQUtIb0UsV0FBVzB3QixPQUxSLENBQVA7QUFPSCxLQVJNLE1BUUE7QUFDSCxZQUFJNXdCLGFBQWEsQ0FDYnV3QixhQUFhbDdCLElBQWIsS0FBc0IsT0FBdEIsR0FBZ0MsVUFBaEMsR0FBNkNrN0IsYUFBYWw3QixJQUQ3QyxFQUVieUcsR0FGYSxFQUdiazRCLGVBQWU5ekIsV0FBVzB3QixPQUExQixDQUhhLENBQWpCO0FBS0EsWUFBSUwsYUFBYWw3QixJQUFiLEtBQXNCLE9BQTFCLEVBQW1DO0FBQy9CMkssdUJBQVdpTSxNQUFYLENBQWtCLENBQWxCLEVBQXFCLENBQXJCLEVBQXdCc2tCLGFBQWFoMEIsS0FBckMsRUFBNENnMEIsYUFBYTcvQixNQUFiLElBQXVCLElBQW5FO0FBQ0g7QUFDRCxlQUFPc1AsVUFBUDtBQUNIO0FBQ0o7QUFDRCxTQUFTdTBCLHNCQUFULENBQWdDcjBCLFVBQWhDLEVBQTRDO0FBQ3hDLFlBQVFBLFdBQVc2RixVQUFuQjtBQUNBLGFBQUssS0FBTDtBQUNJLG1CQUFPLGlCQUFQO0FBQ0osYUFBSyxLQUFMO0FBQ0ksbUJBQU8saUJBQVA7QUFDSjtBQUNJLG1CQUFPLGFBQVA7QUFOSjtBQVFIO0FBQ0QsU0FBU3F1Qiw4QkFBVCxDQUF3Q2wwQixVQUF4QyxFQUFvRHF3QixZQUFwRCxFQUFrRTkvQixLQUFsRSxFQUF5RTtBQUNyRSxRQUFJK2pDLDRCQUE0QixFQUFoQztBQUNBLFFBQUlqRCx1QkFBdUIsRUFBM0I7QUFDQSxRQUFJRixZQUFZLEVBQWhCO0FBQ0EsU0FBSyxJQUFJMWUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbGlCLE1BQU1DLE1BQTFCLEVBQWtDaWlCLEdBQWxDLEVBQXVDO0FBQ25DLFlBQUk2QyxPQUFPL2tCLE1BQU1raUIsQ0FBTixDQUFYO0FBQ0EsWUFBSWpkLE9BQU84ZixLQUFLLENBQUwsRUFBUTlmLElBQW5CO0FBQ0EsWUFBSTgrQiwwQkFBMEI5K0IsSUFBMUIsTUFBb0NyQixTQUF4QyxFQUFtRDtBQUMvQ21nQyxzQ0FBMEI5K0IsSUFBMUIsSUFBa0M7QUFDOUJBLHNCQUFNQSxJQUR3QjtBQUU5Qkwsc0JBQU02SyxXQUFXN0ssSUFGYTtBQUc5QnFRLDBCQUFVeEYsV0FBV3dGLFFBSFM7QUFJOUJrckIseUJBQVMxd0IsV0FBVzB3QjtBQUpVLGFBQWxDO0FBTUFXLGlDQUFxQjc3QixJQUFyQixJQUE2QixFQUE3QjtBQUNBMjdCLHNCQUFVaGdDLElBQVYsQ0FBZXFFLElBQWY7QUFDSDtBQUNENjdCLDZCQUFxQjc3QixJQUFyQixFQUEyQnJFLElBQTNCLENBQWdDLENBQzVCbWtCLEtBQUssQ0FBTCxFQUFRalosS0FEb0IsRUFFNUJpWixLQUFLLENBQUwsQ0FGNEIsQ0FBaEM7QUFJSDtBQUNELFFBQUlpZixlQUFlQyxnQkFBZ0IsRUFBaEIsRUFBb0JuRSxZQUFwQixDQUFuQjtBQUNBLFFBQUlrRSxpQkFBaUIsYUFBckIsRUFBb0M7QUFDaEMsWUFBSXowQixhQUFhLENBQ2J1MEIsdUJBQXVCcjBCLFVBQXZCLENBRGEsRUFFYixDQUFDLFFBQUQsQ0FGYSxFQUdiLENBQUMsTUFBRCxDQUhhLENBQWpCO0FBS0EsYUFBSyxJQUFJN1AsSUFBSSxDQUFSLEVBQVdta0IsT0FBTzZjLFNBQXZCLEVBQWtDaGhDLElBQUlta0IsS0FBSzlqQixNQUEzQyxFQUFtREwsS0FBSyxDQUF4RCxFQUEyRDtBQUN2RCxnQkFBSWd4QixJQUFJN00sS0FBS25rQixDQUFMLENBQVI7QUFDQSxnQkFBSWdhLFNBQVNpcUIsd0JBQXdCRSwwQkFBMEJuVCxDQUExQixDQUF4QixFQUFzRGtQLFlBQXRELEVBQW9FZ0IscUJBQXFCbFEsQ0FBckIsQ0FBcEUsQ0FBYjtBQUNBc1QsMkJBQWUzMEIsVUFBZixFQUEyQnFoQixDQUEzQixFQUE4QmhYLE1BQTlCLEVBQXNDLEtBQXRDO0FBQ0g7QUFDRCxlQUFPckssVUFBUDtBQUNILEtBWkQsTUFZTztBQUNILFlBQUk0MEIsZUFBZSxDQUNmLE1BRGUsRUFFZixDQUFDLE1BQUQsQ0FGZSxDQUFuQjtBQUlBLGFBQUssSUFBSXhnQixNQUFNLENBQVYsRUFBYXlKLFNBQVN3VCxTQUEzQixFQUFzQ2pkLE1BQU15SixPQUFPbnRCLE1BQW5ELEVBQTJEMGpCLE9BQU8sQ0FBbEUsRUFBcUU7QUFDakUsZ0JBQUl5Z0IsTUFBTWhYLE9BQU96SixHQUFQLENBQVY7QUFDQSxnQkFBSTBnQixXQUFXUix3QkFBd0JFLDBCQUEwQkssR0FBMUIsQ0FBeEIsRUFBd0R0RSxZQUF4RCxFQUFzRWdCLHFCQUFxQnNELEdBQXJCLENBQXRFLENBQWY7QUFDQUYsMkJBQWVDLFlBQWYsRUFBNkJDLEdBQTdCLEVBQWtDQyxRQUFsQyxFQUE0QyxJQUE1QztBQUNIO0FBQ0RDLGlDQUF5QkgsWUFBekI7QUFDQSxlQUFPQSxZQUFQO0FBQ0g7QUFDSjtBQUNELFNBQVNJLFVBQVQsQ0FBb0IxNUIsQ0FBcEIsRUFBdUJrZSxDQUF2QixFQUEwQjtBQUN0QixRQUFJbGUsTUFBTWpILFNBQVYsRUFBcUI7QUFDakIsZUFBT2lILENBQVA7QUFDSDtBQUNELFFBQUlrZSxNQUFNbmxCLFNBQVYsRUFBcUI7QUFDakIsZUFBT21sQixDQUFQO0FBQ0g7QUFDSjtBQUNELFNBQVM4YSx1QkFBVCxDQUFpQ3AwQixVQUFqQyxFQUE2Q3F3QixZQUE3QyxFQUEyRDkvQixLQUEzRCxFQUFrRTtBQUM5RCxRQUFJNEUsT0FBT3EvQixnQkFBZ0J4MEIsVUFBaEIsRUFBNEJxd0IsWUFBNUIsQ0FBWDtBQUNBLFFBQUl6MEIsTUFBTSxDQUNOLEtBRE0sRUFFTm9FLFdBQVd3RixRQUZMLENBQVY7QUFJQSxRQUFJclEsU0FBUyxhQUFULElBQTBCLE9BQU81RSxNQUFNLENBQU4sRUFBUyxDQUFULENBQVAsS0FBdUIsU0FBckQsRUFBZ0U7QUFDNUQsWUFBSXVQLGFBQWEsQ0FBQyxNQUFELENBQWpCO0FBQ0EsYUFBSyxJQUFJM1AsSUFBSSxDQUFSLEVBQVdta0IsT0FBTy9qQixLQUF2QixFQUE4QkosSUFBSW1rQixLQUFLOWpCLE1BQXZDLEVBQStDTCxLQUFLLENBQXBELEVBQXVEO0FBQ25ELGdCQUFJbWxCLE9BQU9oQixLQUFLbmtCLENBQUwsQ0FBWDtBQUNBMlAsdUJBQVczTyxJQUFYLENBQWdCLENBQ1osSUFEWSxFQUVaeUssR0FGWSxFQUdaMFosS0FBSyxDQUFMLENBSFksQ0FBaEIsRUFJR0EsS0FBSyxDQUFMLENBSkg7QUFLSDtBQUNEeFYsbUJBQVczTyxJQUFYLENBQWdCMmlDLGVBQWVnQixXQUFXOTBCLFdBQVcwd0IsT0FBdEIsRUFBK0JMLGFBQWFLLE9BQTVDLENBQWYsQ0FBaEI7QUFDQSxlQUFPNXdCLFVBQVA7QUFDSCxLQVpELE1BWU8sSUFBSTNLLFNBQVMsYUFBYixFQUE0QjtBQUMvQixZQUFJdS9CLGVBQWUsQ0FDZixPQURlLEVBRWY5NEIsR0FGZSxDQUFuQjtBQUlBLGFBQUssSUFBSXNZLE1BQU0sQ0FBVixFQUFheUosU0FBU3B0QixLQUEzQixFQUFrQzJqQixNQUFNeUosT0FBT250QixNQUEvQyxFQUF1RDBqQixPQUFPLENBQTlELEVBQWlFO0FBQzdELGdCQUFJa2QsU0FBU3pULE9BQU96SixHQUFQLENBQWI7QUFDQXVnQiwyQkFBZUMsWUFBZixFQUE2QnRELE9BQU8sQ0FBUCxDQUE3QixFQUF3Q0EsT0FBTyxDQUFQLENBQXhDLEVBQW1ELEtBQW5EO0FBQ0g7QUFDRHNELHFCQUFhdmpDLElBQWIsQ0FBa0IyaUMsZUFBZWdCLFdBQVc5MEIsV0FBVzB3QixPQUF0QixFQUErQkwsYUFBYUssT0FBNUMsQ0FBZixDQUFsQjtBQUNBLGVBQU9nRSxZQUFQO0FBQ0gsS0FYTSxNQVdBLElBQUl2L0IsU0FBUyxVQUFiLEVBQXlCO0FBQzVCLFlBQUk0L0IsZUFBZSxDQUNmLE1BRGUsRUFFZixDQUNJLFFBREosRUFFSW41QixHQUZKLENBRmUsQ0FBbkI7QUFPQSxhQUFLLElBQUlva0IsTUFBTSxDQUFWLEVBQWF1RSxTQUFTaDBCLEtBQTNCLEVBQWtDeXZCLE1BQU11RSxPQUFPL3pCLE1BQS9DLEVBQXVEd3ZCLE9BQU8sQ0FBOUQsRUFBaUU7QUFDN0QsZ0JBQUlnVixTQUFTelEsT0FBT3ZFLEdBQVAsQ0FBYjtBQUNBeVUsMkJBQWVNLFlBQWYsRUFBNkJDLE9BQU8sQ0FBUCxDQUE3QixFQUF3Q0EsT0FBTyxDQUFQLENBQXhDLEVBQW1ELElBQW5EO0FBQ0g7QUFDREgsaUNBQXlCRSxZQUF6QjtBQUNBLGVBQU8vMEIsV0FBVzB3QixPQUFYLEtBQXVCdjhCLFNBQXZCLEdBQW1DNGdDLFlBQW5DLEdBQWtELENBQ3JELE1BRHFELEVBRXJELENBQ0ksSUFESixFQUVJLENBQ0ksUUFESixFQUVJbjVCLEdBRkosQ0FGSixFQU1JLFFBTkosQ0FGcUQsRUFVckRtNUIsWUFWcUQsRUFXckRqQixlQUFlOXpCLFdBQVcwd0IsT0FBMUIsQ0FYcUQsQ0FBekQ7QUFhSCxLQTFCTSxNQTBCQSxJQUFJdjdCLFNBQVMsYUFBYixFQUE0QjtBQUMvQixZQUFJb1EsT0FBT3ZGLFdBQVd1RixJQUFYLEtBQW9CcFIsU0FBcEIsR0FBZ0M2TCxXQUFXdUYsSUFBM0MsR0FBa0QsQ0FBN0Q7QUFDQSxZQUFJMHZCLGVBQWUsQ0FDZlosdUJBQXVCcjBCLFVBQXZCLENBRGUsRUFFZnVGLFNBQVMsQ0FBVCxHQUFhLENBQUMsUUFBRCxDQUFiLEdBQTBCLENBQ3RCLGFBRHNCLEVBRXRCQSxJQUZzQixDQUZYLEVBTWYsQ0FDSSxRQURKLEVBRUkzSixHQUZKLENBTmUsQ0FBbkI7QUFXQSxhQUFLLElBQUkwakIsTUFBTSxDQUFWLEVBQWErRSxTQUFTOXpCLEtBQTNCLEVBQWtDK3VCLE1BQU0rRSxPQUFPN3pCLE1BQS9DLEVBQXVEOHVCLE9BQU8sQ0FBOUQsRUFBaUU7QUFDN0QsZ0JBQUk0VixTQUFTN1EsT0FBTy9FLEdBQVAsQ0FBYjtBQUNBbVYsMkJBQWVRLFlBQWYsRUFBNkJDLE9BQU8sQ0FBUCxDQUE3QixFQUF3Q0EsT0FBTyxDQUFQLENBQXhDLEVBQW1ELEtBQW5EO0FBQ0g7QUFDRCxlQUFPbDFCLFdBQVcwd0IsT0FBWCxLQUF1QnY4QixTQUF2QixHQUFtQzhnQyxZQUFuQyxHQUFrRCxDQUNyRCxNQURxRCxFQUVyRCxDQUNJLElBREosRUFFSSxDQUNJLFFBREosRUFFSXI1QixHQUZKLENBRkosRUFNSSxRQU5KLENBRnFELEVBVXJEcTVCLFlBVnFELEVBV3JEbkIsZUFBZTl6QixXQUFXMHdCLE9BQTFCLENBWHFELENBQXpEO0FBYUgsS0E5Qk0sTUE4QkE7QUFDSCxjQUFNLElBQUl4OUIsS0FBSixDQUFVLG9DQUFvQ2lDLElBQTlDLENBQU47QUFDSDtBQUNKO0FBQ0QsU0FBU2cvQixtQkFBVCxDQUE2Qm4wQixVQUE3QixFQUF5Q3F3QixZQUF6QyxFQUF1RDkvQixLQUF2RCxFQUE4RDRhLEtBQTlELEVBQXFFO0FBQ2pFLFFBQUlBLFVBQVUsS0FBSyxDQUFuQixFQUNJQSxRQUFRLENBQUMsTUFBRCxDQUFSO0FBQ0osUUFBSWhXLE9BQU9xL0IsZ0JBQWdCeDBCLFVBQWhCLEVBQTRCcXdCLFlBQTVCLENBQVg7QUFDQSxRQUFJdndCLFVBQUo7QUFDQSxRQUFJcTFCLFNBQVMsS0FBYjtBQUNBLFFBQUloZ0MsU0FBUyxVQUFiLEVBQXlCO0FBQ3JCMksscUJBQWEsQ0FDVCxNQURTLEVBRVRxTCxLQUZTLENBQWI7QUFJQWdxQixpQkFBUyxJQUFUO0FBQ0gsS0FORCxNQU1PLElBQUloZ0MsU0FBUyxhQUFiLEVBQTRCO0FBQy9CLFlBQUlvUSxPQUFPdkYsV0FBV3VGLElBQVgsS0FBb0JwUixTQUFwQixHQUFnQzZMLFdBQVd1RixJQUEzQyxHQUFrRCxDQUE3RDtBQUNBekYscUJBQWEsQ0FDVHUwQix1QkFBdUJyMEIsVUFBdkIsQ0FEUyxFQUVUdUYsU0FBUyxDQUFULEdBQWEsQ0FBQyxRQUFELENBQWIsR0FBMEIsQ0FDdEIsYUFEc0IsRUFFdEJBLElBRnNCLENBRmpCLEVBTVQ0RixLQU5TLENBQWI7QUFRSCxLQVZNLE1BVUE7QUFDSCxjQUFNLElBQUlqWSxLQUFKLENBQVUsaUNBQWlDaUMsSUFBakMsR0FBd0MsR0FBbEQsQ0FBTjtBQUNIO0FBQ0QsU0FBSyxJQUFJaEYsSUFBSSxDQUFSLEVBQVdta0IsT0FBTy9qQixLQUF2QixFQUE4QkosSUFBSW1rQixLQUFLOWpCLE1BQXZDLEVBQStDTCxLQUFLLENBQXBELEVBQXVEO0FBQ25ELFlBQUltbEIsT0FBT2hCLEtBQUtua0IsQ0FBTCxDQUFYO0FBQ0Fza0MsdUJBQWUzMEIsVUFBZixFQUEyQndWLEtBQUssQ0FBTCxDQUEzQixFQUFvQ0EsS0FBSyxDQUFMLENBQXBDLEVBQTZDNmYsTUFBN0M7QUFDSDtBQUNETiw2QkFBeUIvMEIsVUFBekI7QUFDQSxXQUFPQSxVQUFQO0FBQ0g7QUFDRCxTQUFTKzBCLHdCQUFULENBQWtDLzBCLFVBQWxDLEVBQThDO0FBQzFDLFFBQUlBLFdBQVcsQ0FBWCxNQUFrQixNQUFsQixJQUE0QkEsV0FBV3RQLE1BQVgsS0FBc0IsQ0FBdEQsRUFBeUQ7QUFDckRzUCxtQkFBVzNPLElBQVgsQ0FBZ0IsQ0FBaEI7QUFDQTJPLG1CQUFXM08sSUFBWCxDQUFnQjJPLFdBQVcsQ0FBWCxDQUFoQjtBQUNIO0FBQ0o7QUFDRCxTQUFTMjBCLGNBQVQsQ0FBd0JXLEtBQXhCLEVBQStCanFCLEtBQS9CLEVBQXNDaEIsTUFBdEMsRUFBOENnckIsTUFBOUMsRUFBc0Q7QUFDbEQsUUFBSUMsTUFBTTVrQyxNQUFOLEdBQWUsQ0FBZixJQUFvQjJhLFVBQVVpcUIsTUFBTUEsTUFBTTVrQyxNQUFOLEdBQWUsQ0FBckIsQ0FBbEMsRUFBMkQ7QUFDdkQ7QUFDSDtBQUNELFFBQUksRUFBRTJrQyxVQUFVQyxNQUFNNWtDLE1BQU4sS0FBaUIsQ0FBN0IsQ0FBSixFQUFxQztBQUNqQzRrQyxjQUFNamtDLElBQU4sQ0FBV2dhLEtBQVg7QUFDSDtBQUNEaXFCLFVBQU1qa0MsSUFBTixDQUFXZ1osTUFBWDtBQUNIO0FBQ0QsU0FBU3FxQixlQUFULENBQXlCeDBCLFVBQXpCLEVBQXFDcXdCLFlBQXJDLEVBQW1EO0FBQy9DLFFBQUlyd0IsV0FBVzdLLElBQWYsRUFBcUI7QUFDakIsZUFBTzZLLFdBQVc3SyxJQUFsQjtBQUNILEtBRkQsTUFFTztBQUNILGVBQU9rN0IsYUFBYXZ3QixVQUFiLENBQXdCQyxZQUF4QixHQUF1QyxhQUF2QyxHQUF1RCxVQUE5RDtBQUNIO0FBQ0o7QUFDRCxTQUFTazBCLGtCQUFULENBQTRCeGhCLENBQTVCLEVBQStCO0FBQzNCLFFBQUk5SyxTQUFTLENBQUMsUUFBRCxDQUFiO0FBQ0EsUUFBSTB0QixLQUFLLGFBQVQ7QUFDQSxRQUFJQyxNQUFNLENBQVY7QUFDQSxTQUFLLElBQUk5aUMsUUFBUTZpQyxHQUFHamtCLElBQUgsQ0FBUXFCLENBQVIsQ0FBakIsRUFBNkJqZ0IsVUFBVSxJQUF2QyxFQUE2Q0EsUUFBUTZpQyxHQUFHamtCLElBQUgsQ0FBUXFCLENBQVIsQ0FBckQsRUFBaUU7QUFDN0QsWUFBSWxRLFVBQVVrUSxFQUFFblgsS0FBRixDQUFRZzZCLEdBQVIsRUFBYUQsR0FBR2hQLFNBQUgsR0FBZTd6QixNQUFNLENBQU4sRUFBU2hDLE1BQXJDLENBQWQ7QUFDQThrQyxjQUFNRCxHQUFHaFAsU0FBVDtBQUNBLFlBQUk5akIsUUFBUS9SLE1BQVIsR0FBaUIsQ0FBckIsRUFBd0I7QUFDcEJtWCxtQkFBT3hXLElBQVAsQ0FBWW9SLE9BQVo7QUFDSDtBQUNEb0YsZUFBT3hXLElBQVAsQ0FBWSxDQUNSLEtBRFEsRUFFUnFCLE1BQU0sQ0FBTixDQUZRLENBQVo7QUFJSDtBQUNELFFBQUltVixPQUFPblgsTUFBUCxLQUFrQixDQUF0QixFQUF5QjtBQUNyQixlQUFPaWlCLENBQVA7QUFDSDtBQUNELFFBQUk2aUIsTUFBTTdpQixFQUFFamlCLE1BQVosRUFBb0I7QUFDaEJtWCxlQUFPeFcsSUFBUCxDQUFZc2hCLEVBQUVuWCxLQUFGLENBQVFnNkIsR0FBUixDQUFaO0FBQ0gsS0FGRCxNQUVPLElBQUkzdEIsT0FBT25YLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDNUIsZUFBTyxDQUNILFdBREcsRUFFSG1YLE9BQU8sQ0FBUCxDQUZHLENBQVA7QUFJSDtBQUNELFdBQU9BLE1BQVA7QUFDSDs7QUFFRCxTQUFTNHRCLGtCQUFULENBQTRCNzFCLE1BQTVCLEVBQW9DO0FBQ2hDLFFBQUlBLFdBQVcsSUFBWCxJQUFtQkEsV0FBVyxLQUFsQyxFQUF5QztBQUNyQyxlQUFPLElBQVA7QUFDSDtBQUNELFFBQUksQ0FBQ3JQLE1BQU1DLE9BQU4sQ0FBY29QLE1BQWQsQ0FBRCxJQUEwQkEsT0FBT2xQLE1BQVAsS0FBa0IsQ0FBaEQsRUFBbUQ7QUFDL0MsZUFBTyxLQUFQO0FBQ0g7QUFDRCxZQUFRa1AsT0FBTyxDQUFQLENBQVI7QUFDQSxhQUFLLEtBQUw7QUFDSSxtQkFBT0EsT0FBT2xQLE1BQVAsSUFBaUIsQ0FBakIsSUFBc0JrUCxPQUFPLENBQVAsTUFBYyxLQUFwQyxJQUE2Q0EsT0FBTyxDQUFQLE1BQWMsT0FBbEU7QUFDSixhQUFLLElBQUw7QUFDSSxtQkFBT0EsT0FBT2xQLE1BQVAsSUFBaUIsQ0FBakIsS0FBdUIsT0FBT2tQLE9BQU8sQ0FBUCxDQUFQLEtBQXFCLFFBQXJCLElBQWlDclAsTUFBTUMsT0FBTixDQUFjb1AsT0FBTyxDQUFQLENBQWQsQ0FBeEQsQ0FBUDtBQUNKLGFBQUssS0FBTDtBQUNBLGFBQUssTUFBTDtBQUNBLGFBQUssTUFBTDtBQUNJLG1CQUFPLEtBQVA7QUFDSixhQUFLLElBQUw7QUFDQSxhQUFLLElBQUw7QUFDQSxhQUFLLEdBQUw7QUFDQSxhQUFLLElBQUw7QUFDQSxhQUFLLEdBQUw7QUFDQSxhQUFLLElBQUw7QUFDSSxtQkFBT0EsT0FBT2xQLE1BQVAsS0FBa0IsQ0FBbEIsSUFBd0JILE1BQU1DLE9BQU4sQ0FBY29QLE9BQU8sQ0FBUCxDQUFkLEtBQTRCclAsTUFBTUMsT0FBTixDQUFjb1AsT0FBTyxDQUFQLENBQWQsQ0FBM0Q7QUFDSixhQUFLLEtBQUw7QUFDQSxhQUFLLEtBQUw7QUFDSSxpQkFBSyxJQUFJdlAsSUFBSSxDQUFSLEVBQVdta0IsT0FBTzVVLE9BQU9wRSxLQUFQLENBQWEsQ0FBYixDQUF2QixFQUF3Q25MLElBQUlta0IsS0FBSzlqQixNQUFqRCxFQUF5REwsS0FBSyxDQUE5RCxFQUFpRTtBQUM3RCxvQkFBSWdvQixJQUFJN0QsS0FBS25rQixDQUFMLENBQVI7QUFDQSxvQkFBSSxDQUFDb2xDLG1CQUFtQnBkLENBQW5CLENBQUQsSUFBMEIsT0FBT0EsQ0FBUCxLQUFhLFNBQTNDLEVBQXNEO0FBQ2xELDJCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0QsbUJBQU8sSUFBUDtBQUNKO0FBQ0ksbUJBQU8sSUFBUDtBQTFCSjtBQTRCSDtBQUNELElBQUlxZCxhQUFhO0FBQ2IsWUFBUSxTQURLO0FBRWIsZUFBVyxLQUZFO0FBR2Isa0JBQWMsS0FIRDtBQUliLHFCQUFpQixhQUpKO0FBS2Isa0JBQWM7QUFDVix3QkFBZ0IsS0FETjtBQUVWLHNCQUFjLENBQ1YsTUFEVSxFQUVWLFNBRlU7QUFGSjtBQUxELENBQWpCO0FBYUEsU0FBU0MsWUFBVCxDQUFzQi8xQixNQUF0QixFQUE4QjtBQUMxQixRQUFJQSxXQUFXLElBQVgsSUFBbUJBLFdBQVd2TCxTQUFsQyxFQUE2QztBQUN6QyxlQUFPO0FBQ0h1TCxvQkFBUSxrQkFBWTtBQUNoQix1QkFBTyxJQUFQO0FBQ0gsYUFIRTtBQUlIZzJCLDBCQUFjO0FBSlgsU0FBUDtBQU1IO0FBQ0QsUUFBSSxDQUFDSCxtQkFBbUI3MUIsTUFBbkIsQ0FBTCxFQUFpQztBQUM3QkEsaUJBQVNpMkIsY0FBY2oyQixNQUFkLENBQVQ7QUFDSDtBQUNELFFBQUlrMkIsV0FBV3BELGlCQUFpQjl5QixNQUFqQixFQUF5QjgxQixVQUF6QixDQUFmO0FBQ0EsUUFBSUksU0FBU2p1QixNQUFULEtBQW9CLE9BQXhCLEVBQWlDO0FBQzdCLGNBQU0sSUFBSXpVLEtBQUosQ0FBVTBpQyxTQUFTdjVCLEtBQVQsQ0FBZXhMLEdBQWYsQ0FBbUIsVUFBVXlELEdBQVYsRUFBZTtBQUM5QyxtQkFBT0EsSUFBSWtGLEdBQUosR0FBVSxJQUFWLEdBQWlCbEYsSUFBSTRoQixPQUE1QjtBQUNILFNBRmUsRUFFYjNhLElBRmEsQ0FFUixJQUZRLENBQVYsQ0FBTjtBQUdILEtBSkQsTUFJTztBQUNILFlBQUltNkIsZUFBZXJsQyxNQUFNQyxPQUFOLENBQWNvUCxNQUFkLEtBQXlCQSxPQUFPbFAsTUFBUCxLQUFrQixDQUEzQyxJQUFnRGtQLE9BQU8sQ0FBUCxNQUFjLFFBQWpGO0FBQ0EsZUFBTztBQUNIQSxvQkFBUSxnQkFBVW0yQixnQkFBVixFQUE0QnpYLE9BQTVCLEVBQXFDSSxTQUFyQyxFQUFnRDtBQUNwRCx1QkFBT29YLFNBQVN2NUIsS0FBVCxDQUFlNmYsUUFBZixDQUF3QjJaLGdCQUF4QixFQUEwQ3pYLE9BQTFDLEVBQW1ELEVBQW5ELEVBQXVESSxTQUF2RCxDQUFQO0FBQ0gsYUFIRTtBQUlIa1gsMEJBQWNBO0FBSlgsU0FBUDtBQU1IO0FBQ0o7QUFDRCxTQUFTdmIsT0FBVCxDQUFpQi9lLENBQWpCLEVBQW9Ca2UsQ0FBcEIsRUFBdUI7QUFDbkIsV0FBT2xlLElBQUlrZSxDQUFKLEdBQVEsQ0FBQyxDQUFULEdBQWFsZSxJQUFJa2UsQ0FBSixHQUFRLENBQVIsR0FBWSxDQUFoQztBQUNIO0FBQ0QsU0FBU3FjLGFBQVQsQ0FBdUJqMkIsTUFBdkIsRUFBK0I7QUFDM0IsUUFBSSxDQUFDQSxNQUFMLEVBQWE7QUFDVCxlQUFPLElBQVA7QUFDSDtBQUNELFFBQUlxWixLQUFLclosT0FBTyxDQUFQLENBQVQ7QUFDQSxRQUFJQSxPQUFPbFAsTUFBUCxJQUFpQixDQUFyQixFQUF3QjtBQUNwQixlQUFPdW9CLE9BQU8sS0FBZDtBQUNIO0FBQ0QsUUFBSStjLFlBQVkvYyxPQUFPLElBQVAsR0FBY2dkLG9CQUFvQnIyQixPQUFPLENBQVAsQ0FBcEIsRUFBK0JBLE9BQU8sQ0FBUCxDQUEvQixFQUEwQyxJQUExQyxDQUFkLEdBQWdFcVosT0FBTyxJQUFQLEdBQWNpZCxnQkFBZ0JELG9CQUFvQnIyQixPQUFPLENBQVAsQ0FBcEIsRUFBK0JBLE9BQU8sQ0FBUCxDQUEvQixFQUEwQyxJQUExQyxDQUFoQixDQUFkLEdBQWlGcVosT0FBTyxHQUFQLElBQWNBLE9BQU8sR0FBckIsSUFBNEJBLE9BQU8sSUFBbkMsSUFBMkNBLE9BQU8sSUFBbEQsR0FBeURnZCxvQkFBb0JyMkIsT0FBTyxDQUFQLENBQXBCLEVBQStCQSxPQUFPLENBQVAsQ0FBL0IsRUFBMENxWixFQUExQyxDQUF6RCxHQUF5R0EsT0FBTyxLQUFQLEdBQWVrZCxxQkFBcUJ2MkIsT0FBT3BFLEtBQVAsQ0FBYSxDQUFiLENBQXJCLENBQWYsR0FBdUR5ZCxPQUFPLEtBQVAsR0FBZSxDQUFDLEtBQUQsRUFBUXJVLE1BQVIsQ0FBZWhGLE9BQU9wRSxLQUFQLENBQWEsQ0FBYixFQUFnQnpLLEdBQWhCLENBQW9COGtDLGFBQXBCLENBQWYsQ0FBZixHQUFvRTVjLE9BQU8sTUFBUCxHQUFnQixDQUFDLEtBQUQsRUFBUXJVLE1BQVIsQ0FBZWhGLE9BQU9wRSxLQUFQLENBQWEsQ0FBYixFQUFnQnpLLEdBQWhCLENBQW9COGtDLGFBQXBCLEVBQW1DOWtDLEdBQW5DLENBQXVDbWxDLGVBQXZDLENBQWYsQ0FBaEIsR0FBMEZqZCxPQUFPLElBQVAsR0FBY21kLFlBQVl4MkIsT0FBTyxDQUFQLENBQVosRUFBdUJBLE9BQU9wRSxLQUFQLENBQWEsQ0FBYixDQUF2QixDQUFkLEdBQXdEeWQsT0FBTyxLQUFQLEdBQWVpZCxnQkFBZ0JFLFlBQVl4MkIsT0FBTyxDQUFQLENBQVosRUFBdUJBLE9BQU9wRSxLQUFQLENBQWEsQ0FBYixDQUF2QixDQUFoQixDQUFmLEdBQTBFeWQsT0FBTyxLQUFQLEdBQWVvZCxhQUFhejJCLE9BQU8sQ0FBUCxDQUFiLENBQWYsR0FBeUNxWixPQUFPLE1BQVAsR0FBZ0JpZCxnQkFBZ0JHLGFBQWF6MkIsT0FBTyxDQUFQLENBQWIsQ0FBaEIsQ0FBaEIsR0FBMkQsSUFBcnNCO0FBQ0EsV0FBT28yQixTQUFQO0FBQ0g7QUFDRCxTQUFTQyxtQkFBVCxDQUE2QnZ3QixRQUE3QixFQUF1Q25KLEtBQXZDLEVBQThDMGMsRUFBOUMsRUFBa0Q7QUFDOUMsWUFBUXZULFFBQVI7QUFDQSxhQUFLLE9BQUw7QUFDSSxtQkFBTyxDQUNILGlCQUFpQnVULEVBRGQsRUFFSDFjLEtBRkcsQ0FBUDtBQUlKLGFBQUssS0FBTDtBQUNJLG1CQUFPLENBQ0gsZUFBZTBjLEVBRFosRUFFSDFjLEtBRkcsQ0FBUDtBQUlKO0FBQ0ksbUJBQU8sQ0FDSCxZQUFZMGMsRUFEVCxFQUVIdlQsUUFGRyxFQUdIbkosS0FIRyxDQUFQO0FBWko7QUFrQkg7QUFDRCxTQUFTNDVCLG9CQUFULENBQThCRyxPQUE5QixFQUF1QztBQUNuQyxXQUFPLENBQUMsS0FBRCxFQUFRMXhCLE1BQVIsQ0FBZTB4QixRQUFRdmxDLEdBQVIsQ0FBWThrQyxhQUFaLENBQWYsQ0FBUDtBQUNIO0FBQ0QsU0FBU08sV0FBVCxDQUFxQjF3QixRQUFyQixFQUErQnhKLE1BQS9CLEVBQXVDO0FBQ25DLFFBQUlBLE9BQU94TCxNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLGVBQU8sS0FBUDtBQUNIO0FBQ0QsWUFBUWdWLFFBQVI7QUFDQSxhQUFLLE9BQUw7QUFDSSxtQkFBTyxDQUNILGdCQURHLEVBRUgsQ0FDSSxTQURKLEVBRUl4SixNQUZKLENBRkcsQ0FBUDtBQU9KLGFBQUssS0FBTDtBQUNJLG1CQUFPLENBQ0gsY0FERyxFQUVILENBQ0ksU0FESixFQUVJQSxNQUZKLENBRkcsQ0FBUDtBQU9KO0FBQ0ksZ0JBQUlBLE9BQU94TCxNQUFQLEdBQWdCLEdBQWhCLElBQXVCLENBQUN3TCxPQUFPOUYsSUFBUCxDQUFZLFVBQVU4WCxDQUFWLEVBQWE7QUFDN0MsdUJBQU8sUUFBT0EsQ0FBUCx5Q0FBT0EsQ0FBUCxlQUFvQmhTLE9BQU8sQ0FBUCxDQUFwQixDQUFQO0FBQ0gsYUFGdUIsQ0FBNUIsRUFFUTtBQUNKLHVCQUFPLENBQ0gsaUJBREcsRUFFSHdKLFFBRkcsRUFHSCxDQUNJLFNBREosRUFFSXhKLE9BQU9td0IsSUFBUCxDQUFZaFMsT0FBWixDQUZKLENBSEcsQ0FBUDtBQVFILGFBWEQsTUFXTztBQUNILHVCQUFPLENBQ0gsaUJBREcsRUFFSDNVLFFBRkcsRUFHSCxDQUNJLFNBREosRUFFSXhKLE1BRkosQ0FIRyxDQUFQO0FBUUg7QUF0Q0w7QUF3Q0g7QUFDRCxTQUFTbTZCLFlBQVQsQ0FBc0Izd0IsUUFBdEIsRUFBZ0M7QUFDNUIsWUFBUUEsUUFBUjtBQUNBLGFBQUssT0FBTDtBQUNJLG1CQUFPLElBQVA7QUFDSixhQUFLLEtBQUw7QUFDSSxtQkFBTyxDQUFDLGVBQUQsQ0FBUDtBQUNKO0FBQ0ksbUJBQU8sQ0FDSCxZQURHLEVBRUhBLFFBRkcsQ0FBUDtBQU5KO0FBV0g7QUFDRCxTQUFTd3dCLGVBQVQsQ0FBeUJ0MkIsTUFBekIsRUFBaUM7QUFDN0IsV0FBTyxDQUNILEdBREcsRUFFSEEsTUFGRyxDQUFQO0FBSUg7O0FBRUQsU0FBUzIyQixlQUFULENBQXlCMzJCLE1BQXpCLEVBQWlDO0FBQzdCLFdBQU80MkIsZUFBZTUyQixNQUFmLEVBQXVCLEVBQXZCLENBQVA7QUFDSDtBQUNELFNBQVM0MkIsY0FBVCxDQUF3QjUyQixNQUF4QixFQUFnQzYyQixhQUFoQyxFQUErQztBQUMzQyxRQUFJeFgsS0FBSjtBQUNBLFFBQUl3VyxtQkFBbUI3MUIsTUFBbkIsQ0FBSixFQUFnQztBQUM1QixlQUFPQSxNQUFQO0FBQ0g7QUFDRCxRQUFJLENBQUNBLE1BQUwsRUFBYTtBQUNULGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSXFaLEtBQUtyWixPQUFPLENBQVAsQ0FBVDtBQUNBLFFBQUlBLE9BQU9sUCxNQUFQLElBQWlCLENBQXJCLEVBQXdCO0FBQ3BCLGVBQU91b0IsT0FBTyxLQUFkO0FBQ0g7QUFDRCxRQUFJK2MsU0FBSjtBQUNBLFFBQUkvYyxPQUFPLElBQVAsSUFBZUEsT0FBTyxJQUF0QixJQUE4QkEsT0FBTyxHQUFyQyxJQUE0Q0EsT0FBTyxHQUFuRCxJQUEwREEsT0FBTyxJQUFqRSxJQUF5RUEsT0FBTyxJQUFwRixFQUEwRjtBQUN0RixZQUFJMWlCLE1BQU1xSixNQUFWO0FBQ0EsWUFBSThGLFdBQVduUCxJQUFJLENBQUosQ0FBZjtBQUNBLFlBQUlnRyxRQUFRaEcsSUFBSSxDQUFKLENBQVo7QUFDQXkvQixvQkFBWVUsc0JBQXNCaHhCLFFBQXRCLEVBQWdDbkosS0FBaEMsRUFBdUMwYyxFQUF2QyxFQUEyQ3dkLGFBQTNDLENBQVo7QUFDSCxLQUxELE1BS08sSUFBSXhkLE9BQU8sS0FBWCxFQUFrQjtBQUNyQixZQUFJMGQsV0FBVy8yQixPQUFPcEUsS0FBUCxDQUFhLENBQWIsRUFBZ0J6SyxHQUFoQixDQUFvQixVQUFVc25CLENBQVYsRUFBYTtBQUM1QyxnQkFBSW1FLFFBQVEsRUFBWjtBQUNBLGdCQUFJMEIsUUFBUXNZLGVBQWVuZSxDQUFmLEVBQWtCbUUsS0FBbEIsQ0FBWjtBQUNBLGdCQUFJb2EsYUFBYUMsa0JBQWtCcmEsS0FBbEIsQ0FBakI7QUFDQSxtQkFBT29hLGVBQWUsSUFBZixHQUFzQjFZLEtBQXRCLEdBQThCLENBQ2pDLE1BRGlDLEVBRWpDMFksVUFGaUMsRUFHakMxWSxLQUhpQyxFQUlqQyxLQUppQyxDQUFyQztBQU1ILFNBVmMsQ0FBZjtBQVdBLGVBQU8sQ0FBQyxLQUFELEVBQVF0WixNQUFSLENBQWUreEIsUUFBZixDQUFQO0FBQ0gsS0FiTSxNQWFBLElBQUkxZCxPQUFPLEtBQVgsRUFBa0I7QUFDckIsWUFBSTZkLGFBQWFsM0IsT0FBT3BFLEtBQVAsQ0FBYSxDQUFiLEVBQWdCekssR0FBaEIsQ0FBb0IsVUFBVXNuQixDQUFWLEVBQWE7QUFDOUMsbUJBQU9tZSxlQUFlbmUsQ0FBZixFQUFrQm9lLGFBQWxCLENBQVA7QUFDSCxTQUZnQixDQUFqQjtBQUdBLGVBQU9LLFdBQVdwbUMsTUFBWCxHQUFvQixDQUFwQixHQUF3QixDQUFDLEtBQUQsRUFBUWtVLE1BQVIsQ0FBZWt5QixVQUFmLENBQXhCLEdBQXFELENBQUM3WCxRQUFRLEVBQVQsRUFBYXJhLE1BQWIsQ0FBb0I3VSxLQUFwQixDQUEwQmt2QixLQUExQixFQUFpQzZYLFVBQWpDLENBQTVEO0FBQ0gsS0FMTSxNQUtBLElBQUk3ZCxPQUFPLE1BQVgsRUFBbUI7QUFDdEIsZUFBTyxDQUNILEdBREcsRUFFSHVkLGVBQWUsQ0FBQyxLQUFELEVBQVE1eEIsTUFBUixDQUFlaEYsT0FBT3BFLEtBQVAsQ0FBYSxDQUFiLENBQWYsQ0FBZixFQUFnRCxFQUFoRCxDQUZHLENBQVA7QUFJSCxLQUxNLE1BS0EsSUFBSXlkLE9BQU8sSUFBWCxFQUFpQjtBQUNwQitjLG9CQUFZZSxjQUFjbjNCLE9BQU8sQ0FBUCxDQUFkLEVBQXlCQSxPQUFPcEUsS0FBUCxDQUFhLENBQWIsQ0FBekIsQ0FBWjtBQUNILEtBRk0sTUFFQSxJQUFJeWQsT0FBTyxLQUFYLEVBQWtCO0FBQ3JCK2Msb0JBQVllLGNBQWNuM0IsT0FBTyxDQUFQLENBQWQsRUFBeUJBLE9BQU9wRSxLQUFQLENBQWEsQ0FBYixDQUF6QixFQUEwQyxJQUExQyxDQUFaO0FBQ0gsS0FGTSxNQUVBLElBQUl5ZCxPQUFPLEtBQVgsRUFBa0I7QUFDckIrYyxvQkFBWWdCLGVBQWVwM0IsT0FBTyxDQUFQLENBQWYsQ0FBWjtBQUNILEtBRk0sTUFFQSxJQUFJcVosT0FBTyxNQUFYLEVBQW1CO0FBQ3RCK2Msb0JBQVksQ0FDUixHQURRLEVBRVJnQixlQUFlcDNCLE9BQU8sQ0FBUCxDQUFmLENBRlEsQ0FBWjtBQUlILEtBTE0sTUFLQTtBQUNIbzJCLG9CQUFZLElBQVo7QUFDSDtBQUNELFdBQU9BLFNBQVA7QUFDSDtBQUNELFNBQVNhLGlCQUFULENBQTJCSixhQUEzQixFQUEwQztBQUN0QyxRQUFJUSxhQUFhLEVBQWpCO0FBQ0EsU0FBSyxJQUFJdnhCLFFBQVQsSUFBcUIrd0IsYUFBckIsRUFBb0M7QUFDaEMsWUFBSTM2QixNQUFNNEosYUFBYSxLQUFiLEdBQXFCLENBQUMsSUFBRCxDQUFyQixHQUE4QixDQUNwQyxLQURvQyxFQUVwQ0EsUUFGb0MsQ0FBeEM7QUFJQXV4QixtQkFBVzVsQyxJQUFYLENBQWdCLENBQ1osSUFEWSxFQUVaLENBQ0ksUUFESixFQUVJeUssR0FGSixDQUZZLEVBTVoyNkIsY0FBYy93QixRQUFkLENBTlksQ0FBaEI7QUFRSDtBQUNELFFBQUl1eEIsV0FBV3ZtQyxNQUFYLEtBQXNCLENBQTFCLEVBQTZCO0FBQ3pCLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSXVtQyxXQUFXdm1DLE1BQVgsS0FBc0IsQ0FBMUIsRUFBNkI7QUFDekIsZUFBT3VtQyxXQUFXLENBQVgsQ0FBUDtBQUNIO0FBQ0QsV0FBTyxDQUFDLEtBQUQsRUFBUXJ5QixNQUFSLENBQWVxeUIsVUFBZixDQUFQO0FBQ0g7QUFDRCxTQUFTUCxxQkFBVCxDQUErQmh4QixRQUEvQixFQUF5Q25KLEtBQXpDLEVBQWdEMGMsRUFBaEQsRUFBb0R3ZCxhQUFwRCxFQUFtRTtBQUMvRCxRQUFJMzZCLEdBQUo7QUFDQSxRQUFJNEosYUFBYSxPQUFqQixFQUEwQjtBQUN0QixlQUFPLENBQ0h1VCxFQURHLEVBRUgsQ0FBQyxlQUFELENBRkcsRUFHSDFjLEtBSEcsQ0FBUDtBQUtILEtBTkQsTUFNTyxJQUFJbUosYUFBYSxLQUFqQixFQUF3QjtBQUMzQjVKLGNBQU0sQ0FBQyxJQUFELENBQU47QUFDSCxLQUZNLE1BRUE7QUFDSEEsY0FBTSxDQUNGLEtBREUsRUFFRjRKLFFBRkUsQ0FBTjtBQUlIO0FBQ0QsUUFBSSt3QixpQkFBaUJsNkIsVUFBVSxJQUEvQixFQUFxQztBQUNqQyxZQUFJbEgsY0FBY2tILEtBQWQseUNBQWNBLEtBQWQsQ0FBSjtBQUNBazZCLHNCQUFjL3dCLFFBQWQsSUFBMEJyUSxJQUExQjtBQUNIO0FBQ0QsUUFBSTRqQixPQUFPLElBQVAsSUFBZXZULGFBQWEsS0FBNUIsSUFBcUNuSixVQUFVLElBQW5ELEVBQXlEO0FBQ3JELGVBQU8sQ0FDSCxLQURHLEVBRUgsQ0FDSSxLQURKLEVBRUltSixRQUZKLENBRkcsRUFNSCxDQUNJLElBREosRUFFSTVKLEdBRkosRUFHSSxJQUhKLENBTkcsQ0FBUDtBQVlILEtBYkQsTUFhTyxJQUFJbWQsT0FBTyxJQUFQLElBQWV2VCxhQUFhLEtBQTVCLElBQXFDbkosVUFBVSxJQUFuRCxFQUF5RDtBQUM1RCxlQUFPLENBQ0gsS0FERyxFQUVILENBQ0ksR0FESixFQUVJLENBQ0ksS0FESixFQUVJbUosUUFGSixDQUZKLENBRkcsRUFTSCxDQUNJLElBREosRUFFSTVKLEdBRkosRUFHSSxJQUhKLENBVEcsQ0FBUDtBQWVIO0FBQ0QsV0FBTyxDQUNIbWQsRUFERyxFQUVIbmQsR0FGRyxFQUdIUyxLQUhHLENBQVA7QUFLSDtBQUNELFNBQVN3NkIsYUFBVCxDQUF1QnJ4QixRQUF2QixFQUFpQ3hKLE1BQWpDLEVBQXlDZzdCLE1BQXpDLEVBQWlEO0FBQzdDLFFBQUlBLFdBQVcsS0FBSyxDQUFwQixFQUNJQSxTQUFTLEtBQVQ7QUFDSixRQUFJaDdCLE9BQU94TCxNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLGVBQU93bUMsTUFBUDtBQUNIO0FBQ0QsUUFBSXA3QixHQUFKO0FBQ0EsUUFBSTRKLGFBQWEsT0FBakIsRUFBMEI7QUFDdEI1SixjQUFNLENBQUMsZUFBRCxDQUFOO0FBQ0gsS0FGRCxNQUVPLElBQUk0SixhQUFhLEtBQWpCLEVBQXdCO0FBQzNCNUosY0FBTSxDQUFDLElBQUQsQ0FBTjtBQUNILEtBRk0sTUFFQTtBQUNIQSxjQUFNLENBQ0YsS0FERSxFQUVGNEosUUFGRSxDQUFOO0FBSUg7QUFDRCxRQUFJeXhCLGVBQWUsSUFBbkI7QUFDQSxRQUFJOWhDLGVBQWM2RyxPQUFPLENBQVAsQ0FBZCxDQUFKO0FBQ0EsU0FBSyxJQUFJN0wsSUFBSSxDQUFSLEVBQVdta0IsT0FBT3RZLE1BQXZCLEVBQStCN0wsSUFBSW1rQixLQUFLOWpCLE1BQXhDLEVBQWdETCxLQUFLLENBQXJELEVBQXdEO0FBQ3BELFlBQUlrTSxRQUFRaVksS0FBS25rQixDQUFMLENBQVo7QUFDQSxZQUFJLFFBQU9rTSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCbEgsSUFBckIsRUFBMkI7QUFDdkI4aEMsMkJBQWUsS0FBZjtBQUNBO0FBQ0g7QUFDSjtBQUNELFFBQUlBLGlCQUFpQjloQyxTQUFTLFFBQVQsSUFBcUJBLFNBQVMsUUFBL0MsQ0FBSixFQUE4RDtBQUMxRCxZQUFJK2hDLGVBQWVsN0IsT0FBT213QixJQUFQLEdBQWN6c0IsTUFBZCxDQUFxQixVQUFVc08sQ0FBVixFQUFhN2QsQ0FBYixFQUFnQjtBQUNwRCxtQkFBT0EsTUFBTSxDQUFOLElBQVc2TCxPQUFPN0wsSUFBSSxDQUFYLE1BQWtCNmQsQ0FBcEM7QUFDSCxTQUZrQixDQUFuQjtBQUdBLGVBQU8sQ0FDSCxPQURHLEVBRUhwUyxHQUZHLEVBR0hzN0IsWUFIRyxFQUlILENBQUNGLE1BSkUsRUFLSEEsTUFMRyxDQUFQO0FBT0g7QUFDRCxXQUFPLENBQUNBLFNBQVMsS0FBVCxHQUFpQixLQUFsQixFQUF5QnR5QixNQUF6QixDQUFnQzFJLE9BQU9uTCxHQUFQLENBQVcsVUFBVW1kLENBQVYsRUFBYTtBQUMzRCxlQUFPLENBQ0hncEIsU0FBUyxJQUFULEdBQWdCLElBRGIsRUFFSHA3QixHQUZHLEVBR0hvUyxDQUhHLENBQVA7QUFLSCxLQU5zQyxDQUFoQyxDQUFQO0FBT0g7QUFDRCxTQUFTOG9CLGNBQVQsQ0FBd0J0eEIsUUFBeEIsRUFBa0M7QUFDOUIsUUFBSUEsYUFBYSxPQUFqQixFQUEwQjtBQUN0QixlQUFPLElBQVA7QUFDSCxLQUZELE1BRU8sSUFBSUEsYUFBYSxLQUFqQixFQUF3QjtBQUMzQixlQUFPLENBQ0gsSUFERyxFQUVILENBQUMsSUFBRCxDQUZHLEVBR0gsSUFIRyxDQUFQO0FBS0gsS0FOTSxNQU1BO0FBQ0gsZUFBTyxDQUNILEtBREcsRUFFSEEsUUFGRyxDQUFQO0FBSUg7QUFDSjs7QUFFRCxTQUFTMnhCLG9CQUFULENBQStCMWlDLEtBQS9CLEVBQXNDO0FBQ2xDLFFBQUlxaEMsWUFBWSxFQUFoQjtBQUNBemhCLGNBQVU1ZixLQUFWLEVBQWlCLFVBQVUxQyxLQUFWLEVBQWlCO0FBQzlCLFlBQUlBLE1BQU0yTixNQUFWLEVBQWtCO0FBQ2QzTixrQkFBTTJOLE1BQU4sR0FBZTIyQixnQkFBZ0J0a0MsTUFBTTJOLE1BQXRCLENBQWY7QUFDSDtBQUNKLEtBSkQ7QUFLQTZVLGlCQUFhOWYsS0FBYixFQUFvQjtBQUNoQmMsZUFBTyxJQURTO0FBRWhCdkQsZ0JBQVE7QUFGUSxLQUFwQixFQUdHLFVBQVVxRSxHQUFWLEVBQWU7QUFDZCxZQUFJakUsT0FBT2lFLElBQUlqRSxJQUFmO0FBQ0EsWUFBSWlLLFFBQVFoRyxJQUFJZ0csS0FBaEI7QUFDQSxZQUFJcUwsWUFBWXJSLElBQUlxUixTQUFwQjtBQUNBLFlBQUl6TSxNQUFNNUUsSUFBSTRFLEdBQWQ7QUFDQSxZQUFJczNCLGFBQWFsMkIsS0FBYixDQUFKLEVBQXlCO0FBQ3JCO0FBQ0g7QUFDRCxZQUFJLFFBQU9BLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFBakIsSUFBNkIsQ0FBQ2hNLE1BQU1DLE9BQU4sQ0FBYytMLEtBQWQsQ0FBbEMsRUFBd0Q7QUFDcERwQixnQkFBSTg0QixnQkFBZ0IxM0IsS0FBaEIsRUFBdUJxTCxTQUF2QixDQUFKO0FBQ0FvdUIsc0JBQVUza0MsSUFBVixDQUFlaUIsS0FBS21KLElBQUwsQ0FBVSxHQUFWLENBQWY7QUFDSCxTQUhELE1BR08sSUFBSW1NLFVBQVV6RyxNQUFWLElBQW9CLE9BQU81RSxLQUFQLEtBQWlCLFFBQXpDLEVBQW1EO0FBQ3REcEIsZ0JBQUlnNUIsbUJBQW1CNTNCLEtBQW5CLENBQUo7QUFDSDtBQUNKLEtBakJEO0FBa0JBLFdBQU81SCxLQUFQO0FBQ0g7O0FBRUQsU0FBUzJpQyxPQUFULENBQWtCM2lDLEtBQWxCLEVBQXlCO0FBQ3JCLFFBQUk0aUMsV0FBVyxLQUFmO0FBQ0EsUUFBSTVpQyxNQUFNeEIsT0FBTixLQUFrQixDQUF0QixFQUF5QjtBQUNyQndCLGdCQUFRMGdCLFlBQVkxZ0IsS0FBWixDQUFSO0FBQ0E0aUMsbUJBQVcsSUFBWDtBQUNIO0FBQ0QsUUFBSTVpQyxNQUFNeEIsT0FBTixLQUFrQixDQUF0QixFQUF5QjtBQUNyQm9rQyxtQkFBV0YscUJBQXFCMWlDLEtBQXJCLENBQVg7QUFDQTRpQyxtQkFBVyxJQUFYO0FBQ0g7QUFDRCxRQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNYLGNBQU0sSUFBSW5rQyxLQUFKLENBQVUscUJBQVYsRUFBaUN1QixNQUFNeEIsT0FBdkMsQ0FBTjtBQUNIO0FBQ0QsV0FBT3dCLEtBQVA7QUFDSDs7QUFFRCxTQUFTNmlDLFNBQVQsQ0FBb0I3aUMsS0FBcEIsRUFBMkI7QUFDdkIsUUFBSThpQyxXQUFXLEVBQWY7QUFDQSxRQUFJQyxZQUFZLEVBQWhCO0FBQ0EsUUFBSUMseUJBQXlCLEVBQTdCO0FBQ0EsU0FBSyxJQUFJM2lDLEVBQVQsSUFBZUwsTUFBTXlELE9BQXJCLEVBQThCO0FBQzFCLFlBQUl4RixTQUFTK0IsTUFBTXlELE9BQU4sQ0FBY3BELEVBQWQsQ0FBYjtBQUNBLFlBQUlwQyxPQUFPeUMsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUMxQjtBQUNIO0FBQ0QsWUFBSTNDLFFBQVEsbUJBQW1CNGUsSUFBbkIsQ0FBd0IxZSxPQUFPUCxHQUEvQixDQUFaO0FBQ0EsWUFBSSxDQUFDSyxLQUFMLEVBQVk7QUFDUjtBQUNIO0FBQ0Qra0MsaUJBQVNwbUMsSUFBVCxDQUFjMkQsRUFBZDtBQUNBMGlDLGtCQUFVcm1DLElBQVYsQ0FBZXFCLE1BQU0sQ0FBTixDQUFmO0FBQ0g7QUFDRCxRQUFJK2tDLFNBQVMvbUMsTUFBVCxHQUFrQixDQUF0QixFQUF5QjtBQUNyQixlQUFPaUUsS0FBUDtBQUNIO0FBQ0Q4aUMsYUFBUzdpQixPQUFULENBQWlCLFVBQVU1ZixFQUFWLEVBQWM7QUFDM0IsZUFBT0wsTUFBTXlELE9BQU4sQ0FBY3BELEVBQWQsQ0FBUDtBQUNILEtBRkQ7QUFHQSxRQUFJNGlDLGNBQWNGLFVBQVVqOEIsSUFBVixDQUFlLEdBQWYsQ0FBbEI7QUFDQTlHLFVBQU15RCxPQUFOLENBQWN3L0IsV0FBZCxJQUE2QjtBQUN6QixnQkFBUSxRQURpQjtBQUV6QixlQUFPLGNBQWNBO0FBRkksS0FBN0I7QUFJQWpqQyxVQUFNSSxNQUFOLENBQWE2ZixPQUFiLENBQXFCLFVBQVUzaUIsS0FBVixFQUFpQjtBQUNsQyxZQUFJd2xDLFNBQVNybUMsT0FBVCxDQUFpQmEsTUFBTVcsTUFBdkIsS0FBa0MsQ0FBdEMsRUFBeUM7QUFDckNYLGtCQUFNVyxNQUFOLEdBQWVnbEMsV0FBZjtBQUNBLGdCQUFJLGtCQUFrQjNsQyxLQUF0QixFQUE2QjtBQUN6QixvQkFBSTBsQyx1QkFBdUJ2bUMsT0FBdkIsQ0FBK0JhLE1BQU0sY0FBTixDQUEvQixLQUF5RCxDQUE3RCxFQUFnRTtBQUM1RCwwQkFBTSxJQUFJbUIsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSCxpQkFGRCxNQUVPO0FBQ0h1a0MsMkNBQXVCdG1DLElBQXZCLENBQTRCWSxNQUFNLGNBQU4sQ0FBNUI7QUFDSDtBQUNKO0FBQ0o7QUFDSixLQVhEO0FBWUEsV0FBTzBDLEtBQVA7QUFDSDs7QUFFRCxJQUFJa2pDLGdCQUFnQixDQUNoQixNQURnQixFQUVoQixRQUZnQixFQUdoQixjQUhnQixFQUloQixTQUpnQixFQUtoQixTQUxnQixFQU1oQixRQU5nQixFQU9oQixRQVBnQixDQUFwQjs7QUFVQSxTQUFTQyxLQUFULENBQWU3bEMsS0FBZixFQUFzQndrQixNQUF0QixFQUE4QjtBQUMxQixRQUFJNU8sU0FBUyxFQUFiO0FBQ0EsU0FBSyxJQUFJc0QsQ0FBVCxJQUFjbFosS0FBZCxFQUFxQjtBQUNqQixZQUFJa1osTUFBTSxLQUFWLEVBQWlCO0FBQ2J0RCxtQkFBT3NELENBQVAsSUFBWWxaLE1BQU1rWixDQUFOLENBQVo7QUFDSDtBQUNKO0FBQ0Qwc0Isa0JBQWNqakIsT0FBZCxDQUFzQixVQUFVekosQ0FBVixFQUFhO0FBQy9CLFlBQUlBLEtBQUtzTCxNQUFULEVBQWlCO0FBQ2I1TyxtQkFBT3NELENBQVAsSUFBWXNMLE9BQU90TCxDQUFQLENBQVo7QUFDSDtBQUNKLEtBSkQ7QUFLQSxXQUFPdEQsTUFBUDtBQUNIO0FBQ0QsU0FBU2t3QixXQUFULENBQXFCaGpDLE1BQXJCLEVBQTZCO0FBQ3pCQSxhQUFTQSxPQUFPeUcsS0FBUCxFQUFUO0FBQ0EsUUFBSXpLLE1BQU0yVyxPQUFPNE8sTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBLFNBQUssSUFBSWptQixJQUFJLENBQWIsRUFBZ0JBLElBQUkwRSxPQUFPckUsTUFBM0IsRUFBbUNMLEdBQW5DLEVBQXdDO0FBQ3BDVSxZQUFJZ0UsT0FBTzFFLENBQVAsRUFBVTJFLEVBQWQsSUFBb0JELE9BQU8xRSxDQUFQLENBQXBCO0FBQ0g7QUFDRCxTQUFLLElBQUkrakIsTUFBTSxDQUFmLEVBQWtCQSxNQUFNcmYsT0FBT3JFLE1BQS9CLEVBQXVDMGpCLEtBQXZDLEVBQThDO0FBQzFDLFlBQUksU0FBU3JmLE9BQU9xZixHQUFQLENBQWIsRUFBMEI7QUFDdEJyZixtQkFBT3FmLEdBQVAsSUFBYzBqQixNQUFNL2lDLE9BQU9xZixHQUFQLENBQU4sRUFBbUJyakIsSUFBSWdFLE9BQU9xZixHQUFQLEVBQVk3ZCxHQUFoQixDQUFuQixDQUFkO0FBQ0g7QUFDSjtBQUNELFdBQU94QixNQUFQO0FBQ0g7O0FBRUQsU0FBU2lqQyxTQUFULENBQW1CMThCLENBQW5CLEVBQXNCa2UsQ0FBdEIsRUFBeUI7QUFDckIsUUFBSWpwQixNQUFNQyxPQUFOLENBQWM4SyxDQUFkLENBQUosRUFBc0I7QUFDbEIsWUFBSSxDQUFDL0ssTUFBTUMsT0FBTixDQUFjZ3BCLENBQWQsQ0FBRCxJQUFxQmxlLEVBQUU1SyxNQUFGLEtBQWE4b0IsRUFBRTlvQixNQUF4QyxFQUFnRDtBQUM1QyxtQkFBTyxLQUFQO0FBQ0g7QUFDRCxhQUFLLElBQUlMLElBQUksQ0FBYixFQUFnQkEsSUFBSWlMLEVBQUU1SyxNQUF0QixFQUE4QkwsR0FBOUIsRUFBbUM7QUFDL0IsZ0JBQUksQ0FBQzJuQyxVQUFVMThCLEVBQUVqTCxDQUFGLENBQVYsRUFBZ0JtcEIsRUFBRW5wQixDQUFGLENBQWhCLENBQUwsRUFBNEI7QUFDeEIsdUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxlQUFPLElBQVA7QUFDSDtBQUNELFFBQUksUUFBT2lMLENBQVAseUNBQU9BLENBQVAsT0FBYSxRQUFiLElBQXlCQSxNQUFNLElBQS9CLElBQXVDa2UsTUFBTSxJQUFqRCxFQUF1RDtBQUNuRCxZQUFJLEVBQUUsUUFBT0EsQ0FBUCx5Q0FBT0EsQ0FBUCxPQUFhLFFBQWYsQ0FBSixFQUE4QjtBQUMxQixtQkFBTyxLQUFQO0FBQ0g7QUFDRCxZQUFJcFMsT0FBT00sT0FBT04sSUFBUCxDQUFZOUwsQ0FBWixDQUFYO0FBQ0EsWUFBSThMLEtBQUsxVyxNQUFMLEtBQWdCZ1gsT0FBT04sSUFBUCxDQUFZb1MsQ0FBWixFQUFlOW9CLE1BQW5DLEVBQTJDO0FBQ3ZDLG1CQUFPLEtBQVA7QUFDSDtBQUNELGFBQUssSUFBSWdKLEdBQVQsSUFBZ0I0QixDQUFoQixFQUFtQjtBQUNmLGdCQUFJLENBQUMwOEIsVUFBVTE4QixFQUFFNUIsR0FBRixDQUFWLEVBQWtCOGYsRUFBRTlmLEdBQUYsQ0FBbEIsQ0FBTCxFQUFnQztBQUM1Qix1QkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNIO0FBQ0QsV0FBTzRCLE1BQU1rZSxDQUFiO0FBQ0g7O0FBRUQsSUFBSXllLGFBQWE7QUFDYnJqQyxjQUFVLFVBREc7QUFFYmlELGNBQVUsVUFGRztBQUdicWdDLGlCQUFhLGFBSEE7QUFJYkMsc0JBQWtCLGtCQUpMO0FBS2JDLHVCQUFtQixtQkFMTjtBQU1iQyxlQUFXLFdBTkU7QUFPYkMsZUFBVyxXQVBFO0FBUWJDLGtCQUFjLGNBUkQ7QUFTYkMsMEJBQXNCLHNCQVRUO0FBVWJDLHVCQUFtQixtQkFWTjtBQVdiQyxzQkFBa0Isa0JBWEw7QUFZYjNoQyxlQUFXLFdBWkU7QUFhYkUsYUFBUyxTQWJJO0FBY2IwaEMsZ0JBQVksWUFkQztBQWViQyxjQUFVLFVBZkc7QUFnQmJDLGVBQVcsV0FoQkU7QUFpQmJDLGVBQVcsV0FqQkU7QUFrQmJDLG1CQUFlLGVBbEJGO0FBbUJiQyxjQUFVO0FBbkJHLENBQWpCO0FBcUJBLFNBQVNWLFNBQVQsQ0FBbUI5aEMsUUFBbkIsRUFBNkJ5aUMsS0FBN0IsRUFBb0NDLFFBQXBDLEVBQThDO0FBQzFDQSxhQUFTN25DLElBQVQsQ0FBYztBQUNWOG5DLGlCQUFTbEIsV0FBV0ssU0FEVjtBQUVWcmMsY0FBTSxDQUNGemxCLFFBREUsRUFFRnlpQyxNQUFNemlDLFFBQU4sQ0FGRTtBQUZJLEtBQWQ7QUFPSDtBQUNELFNBQVMraEMsWUFBVCxDQUFzQi9oQyxRQUF0QixFQUFnQzBpQyxRQUFoQyxFQUEwQ0UsY0FBMUMsRUFBMEQ7QUFDdERGLGFBQVM3bkMsSUFBVCxDQUFjO0FBQ1Y4bkMsaUJBQVNsQixXQUFXTSxZQURWO0FBRVZ0YyxjQUFNLENBQUN6bEIsUUFBRDtBQUZJLEtBQWQ7QUFJQTRpQyxtQkFBZTVpQyxRQUFmLElBQTJCLElBQTNCO0FBQ0g7QUFDRCxTQUFTNmlDLFlBQVQsQ0FBc0I3aUMsUUFBdEIsRUFBZ0N5aUMsS0FBaEMsRUFBdUNDLFFBQXZDLEVBQWlERSxjQUFqRCxFQUFpRTtBQUM3RGIsaUJBQWEvaEMsUUFBYixFQUF1QjBpQyxRQUF2QixFQUFpQ0UsY0FBakM7QUFDQWQsY0FBVTloQyxRQUFWLEVBQW9CeWlDLEtBQXBCLEVBQTJCQyxRQUEzQjtBQUNIO0FBQ0QsU0FBU0ksZ0JBQVQsQ0FBMEJDLE1BQTFCLEVBQWtDTixLQUFsQyxFQUF5Q3ppQyxRQUF6QyxFQUFtRDtBQUMvQyxRQUFJNlcsSUFBSjtBQUNBLFNBQUtBLElBQUwsSUFBYWtzQixPQUFPL2lDLFFBQVAsQ0FBYixFQUErQjtBQUMzQixZQUFJLENBQUMraUMsT0FBTy9pQyxRQUFQLEVBQWlCc1csY0FBakIsQ0FBZ0NPLElBQWhDLENBQUwsRUFBNEM7QUFDeEM7QUFDSDtBQUNELFlBQUlBLFNBQVMsTUFBVCxJQUFtQixDQUFDMnFCLFVBQVV1QixPQUFPL2lDLFFBQVAsRUFBaUI2VyxJQUFqQixDQUFWLEVBQWtDNHJCLE1BQU16aUMsUUFBTixFQUFnQjZXLElBQWhCLENBQWxDLENBQXhCLEVBQWtGO0FBQzlFLG1CQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0QsU0FBS0EsSUFBTCxJQUFhNHJCLE1BQU16aUMsUUFBTixDQUFiLEVBQThCO0FBQzFCLFlBQUksQ0FBQ3lpQyxNQUFNemlDLFFBQU4sRUFBZ0JzVyxjQUFoQixDQUErQk8sSUFBL0IsQ0FBTCxFQUEyQztBQUN2QztBQUNIO0FBQ0QsWUFBSUEsU0FBUyxNQUFULElBQW1CLENBQUMycUIsVUFBVXVCLE9BQU8vaUMsUUFBUCxFQUFpQjZXLElBQWpCLENBQVYsRUFBa0M0ckIsTUFBTXppQyxRQUFOLEVBQWdCNlcsSUFBaEIsQ0FBbEMsQ0FBeEIsRUFBa0Y7QUFDOUUsbUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSDtBQUNELFNBQVNtc0IsV0FBVCxDQUFxQkQsTUFBckIsRUFBNkJOLEtBQTdCLEVBQW9DQyxRQUFwQyxFQUE4Q0UsY0FBOUMsRUFBOEQ7QUFDMURHLGFBQVNBLFVBQVUsRUFBbkI7QUFDQU4sWUFBUUEsU0FBUyxFQUFqQjtBQUNBLFFBQUl6aUMsUUFBSjtBQUNBLFNBQUtBLFFBQUwsSUFBaUIraUMsTUFBakIsRUFBeUI7QUFDckIsWUFBSSxDQUFDQSxPQUFPenNCLGNBQVAsQ0FBc0J0VyxRQUF0QixDQUFMLEVBQXNDO0FBQ2xDO0FBQ0g7QUFDRCxZQUFJLENBQUN5aUMsTUFBTW5zQixjQUFOLENBQXFCdFcsUUFBckIsQ0FBTCxFQUFxQztBQUNqQytoQyx5QkFBYS9oQyxRQUFiLEVBQXVCMGlDLFFBQXZCLEVBQWlDRSxjQUFqQztBQUNIO0FBQ0o7QUFDRCxTQUFLNWlDLFFBQUwsSUFBaUJ5aUMsS0FBakIsRUFBd0I7QUFDcEIsWUFBSSxDQUFDQSxNQUFNbnNCLGNBQU4sQ0FBcUJ0VyxRQUFyQixDQUFMLEVBQXFDO0FBQ2pDO0FBQ0g7QUFDRCxZQUFJLENBQUMraUMsT0FBT3pzQixjQUFQLENBQXNCdFcsUUFBdEIsQ0FBTCxFQUFzQztBQUNsQzhoQyxzQkFBVTloQyxRQUFWLEVBQW9CeWlDLEtBQXBCLEVBQTJCQyxRQUEzQjtBQUNILFNBRkQsTUFFTyxJQUFJLENBQUNsQixVQUFVdUIsT0FBTy9pQyxRQUFQLENBQVYsRUFBNEJ5aUMsTUFBTXppQyxRQUFOLENBQTVCLENBQUwsRUFBbUQ7QUFDdEQsZ0JBQUkraUMsT0FBTy9pQyxRQUFQLEVBQWlCbkIsSUFBakIsS0FBMEIsU0FBMUIsSUFBdUM0akMsTUFBTXppQyxRQUFOLEVBQWdCbkIsSUFBaEIsS0FBeUIsU0FBaEUsSUFBNkVpa0MsaUJBQWlCQyxNQUFqQixFQUF5Qk4sS0FBekIsRUFBZ0N6aUMsUUFBaEMsQ0FBakYsRUFBNEg7QUFDeEgwaUMseUJBQVM3bkMsSUFBVCxDQUFjO0FBQ1Y4bkMsNkJBQVNsQixXQUFXTyxvQkFEVjtBQUVWdmMsMEJBQU0sQ0FDRnpsQixRQURFLEVBRUZ5aUMsTUFBTXppQyxRQUFOLEVBQWdCcUUsSUFGZDtBQUZJLGlCQUFkO0FBT0gsYUFSRCxNQVFPO0FBQ0h3K0IsNkJBQWE3aUMsUUFBYixFQUF1QnlpQyxLQUF2QixFQUE4QkMsUUFBOUIsRUFBd0NFLGNBQXhDO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDRCxTQUFTSyx3QkFBVCxDQUFrQ0YsTUFBbEMsRUFBMENOLEtBQTFDLEVBQWlEQyxRQUFqRCxFQUEyRHY5QixPQUEzRCxFQUFvRSs5QixLQUFwRSxFQUEyRVAsT0FBM0UsRUFBb0Y7QUFDaEZJLGFBQVNBLFVBQVUsRUFBbkI7QUFDQU4sWUFBUUEsU0FBUyxFQUFqQjtBQUNBLFFBQUk1ckIsSUFBSjtBQUNBLFNBQUtBLElBQUwsSUFBYWtzQixNQUFiLEVBQXFCO0FBQ2pCLFlBQUksQ0FBQ0EsT0FBT3pzQixjQUFQLENBQXNCTyxJQUF0QixDQUFMLEVBQWtDO0FBQzlCO0FBQ0g7QUFDRCxZQUFJLENBQUMycUIsVUFBVXVCLE9BQU9sc0IsSUFBUCxDQUFWLEVBQXdCNHJCLE1BQU01ckIsSUFBTixDQUF4QixDQUFMLEVBQTJDO0FBQ3ZDNnJCLHFCQUFTN25DLElBQVQsQ0FBYztBQUNWOG5DLHlCQUFTQSxPQURDO0FBRVZsZCxzQkFBTSxDQUNGdGdCLE9BREUsRUFFRjBSLElBRkUsRUFHRjRyQixNQUFNNXJCLElBQU4sQ0FIRSxFQUlGcXNCLEtBSkU7QUFGSSxhQUFkO0FBU0g7QUFDSjtBQUNELFNBQUtyc0IsSUFBTCxJQUFhNHJCLEtBQWIsRUFBb0I7QUFDaEIsWUFBSSxDQUFDQSxNQUFNbnNCLGNBQU4sQ0FBcUJPLElBQXJCLENBQUQsSUFBK0Jrc0IsT0FBT3pzQixjQUFQLENBQXNCTyxJQUF0QixDQUFuQyxFQUFnRTtBQUM1RDtBQUNIO0FBQ0QsWUFBSSxDQUFDMnFCLFVBQVV1QixPQUFPbHNCLElBQVAsQ0FBVixFQUF3QjRyQixNQUFNNXJCLElBQU4sQ0FBeEIsQ0FBTCxFQUEyQztBQUN2QzZyQixxQkFBUzduQyxJQUFULENBQWM7QUFDVjhuQyx5QkFBU0EsT0FEQztBQUVWbGQsc0JBQU0sQ0FDRnRnQixPQURFLEVBRUYwUixJQUZFLEVBR0Y0ckIsTUFBTTVyQixJQUFOLENBSEUsRUFJRnFzQixLQUpFO0FBRkksYUFBZDtBQVNIO0FBQ0o7QUFDSjtBQUNELFNBQVNDLE9BQVQsQ0FBaUIxbkMsS0FBakIsRUFBd0I7QUFDcEIsV0FBT0EsTUFBTStDLEVBQWI7QUFDSDtBQUNELFNBQVM0a0MsU0FBVCxDQUFtQnAzQixLQUFuQixFQUEwQnZRLEtBQTFCLEVBQWlDO0FBQzdCdVEsVUFBTXZRLE1BQU0rQyxFQUFaLElBQWtCL0MsS0FBbEI7QUFDQSxXQUFPdVEsS0FBUDtBQUNIO0FBQ0QsU0FBU3EzQixVQUFULENBQW9CTixNQUFwQixFQUE0Qk4sS0FBNUIsRUFBbUNDLFFBQW5DLEVBQTZDO0FBQ3pDSyxhQUFTQSxVQUFVLEVBQW5CO0FBQ0FOLFlBQVFBLFNBQVMsRUFBakI7QUFDQSxRQUFJYSxjQUFjUCxPQUFPeG9DLEdBQVAsQ0FBVzRvQyxPQUFYLENBQWxCO0FBQ0EsUUFBSUksYUFBYWQsTUFBTWxvQyxHQUFOLENBQVU0b0MsT0FBVixDQUFqQjtBQUNBLFFBQUlLLGNBQWNULE9BQU9VLE1BQVAsQ0FBY0wsU0FBZCxFQUF5QixFQUF6QixDQUFsQjtBQUNBLFFBQUlNLGFBQWFqQixNQUFNZ0IsTUFBTixDQUFhTCxTQUFiLEVBQXdCLEVBQXhCLENBQWpCO0FBQ0EsUUFBSU8sVUFBVUwsWUFBWXQrQixLQUFaLEVBQWQ7QUFDQSxRQUFJNCtCLFFBQVExeUIsT0FBTzRPLE1BQVAsQ0FBYyxJQUFkLENBQVo7QUFDQSxRQUFJam1CLENBQUosRUFBTzJ5QixDQUFQLEVBQVVybkIsT0FBVixFQUFtQjArQixXQUFuQixFQUFnQ0MsVUFBaEMsRUFBNENDLG1CQUE1QyxFQUFpRWx0QixJQUFqRTtBQUNBLFNBQUtoZCxJQUFJLENBQUosRUFBTzJ5QixJQUFJLENBQWhCLEVBQW1CM3lCLElBQUl5cEMsWUFBWXBwQyxNQUFuQyxFQUEyQ0wsR0FBM0MsRUFBZ0Q7QUFDNUNzTCxrQkFBVW0rQixZQUFZenBDLENBQVosQ0FBVjtBQUNBLFlBQUksQ0FBQzZwQyxXQUFXcHRCLGNBQVgsQ0FBMEJuUixPQUExQixDQUFMLEVBQXlDO0FBQ3JDdTlCLHFCQUFTN25DLElBQVQsQ0FBYztBQUNWOG5DLHlCQUFTbEIsV0FBV0MsV0FEVjtBQUVWamMsc0JBQU0sQ0FBQ3RnQixPQUFEO0FBRkksYUFBZDtBQUlBdytCLG9CQUFRbHVCLE1BQVIsQ0FBZWt1QixRQUFRL29DLE9BQVIsQ0FBZ0J1SyxPQUFoQixFQUF5QnFuQixDQUF6QixDQUFmLEVBQTRDLENBQTVDO0FBQ0gsU0FORCxNQU1PO0FBQ0hBO0FBQ0g7QUFDSjtBQUNELFNBQUszeUIsSUFBSSxDQUFKLEVBQU8yeUIsSUFBSSxDQUFoQixFQUFtQjN5QixJQUFJMHBDLFdBQVdycEMsTUFBbEMsRUFBMENMLEdBQTFDLEVBQStDO0FBQzNDc0wsa0JBQVVvK0IsV0FBV0EsV0FBV3JwQyxNQUFYLEdBQW9CLENBQXBCLEdBQXdCTCxDQUFuQyxDQUFWO0FBQ0EsWUFBSThwQyxRQUFRQSxRQUFRenBDLE1BQVIsR0FBaUIsQ0FBakIsR0FBcUJMLENBQTdCLE1BQW9Dc0wsT0FBeEMsRUFBaUQ7QUFDN0M7QUFDSDtBQUNELFlBQUlxK0IsWUFBWWx0QixjQUFaLENBQTJCblIsT0FBM0IsQ0FBSixFQUF5QztBQUNyQ3U5QixxQkFBUzduQyxJQUFULENBQWM7QUFDVjhuQyx5QkFBU2xCLFdBQVdDLFdBRFY7QUFFVmpjLHNCQUFNLENBQUN0Z0IsT0FBRDtBQUZJLGFBQWQ7QUFJQXcrQixvQkFBUWx1QixNQUFSLENBQWVrdUIsUUFBUW51QixXQUFSLENBQW9CclEsT0FBcEIsRUFBNkJ3K0IsUUFBUXpwQyxNQUFSLEdBQWlCc3lCLENBQTlDLENBQWYsRUFBaUUsQ0FBakU7QUFDSCxTQU5ELE1BTU87QUFDSEE7QUFDSDtBQUNEdVgsOEJBQXNCSixRQUFRQSxRQUFRenBDLE1BQVIsR0FBaUJMLENBQXpCLENBQXRCO0FBQ0E2b0MsaUJBQVM3bkMsSUFBVCxDQUFjO0FBQ1Y4bkMscUJBQVNsQixXQUFXcGdDLFFBRFY7QUFFVm9rQixrQkFBTSxDQUNGaWUsV0FBV3YrQixPQUFYLENBREUsRUFFRjQrQixtQkFGRTtBQUZJLFNBQWQ7QUFPQUosZ0JBQVFsdUIsTUFBUixDQUFla3VCLFFBQVF6cEMsTUFBUixHQUFpQkwsQ0FBaEMsRUFBbUMsQ0FBbkMsRUFBc0NzTCxPQUF0QztBQUNBeStCLGNBQU16K0IsT0FBTixJQUFpQixJQUFqQjtBQUNIO0FBQ0QsU0FBS3RMLElBQUksQ0FBVCxFQUFZQSxJQUFJMHBDLFdBQVdycEMsTUFBM0IsRUFBbUNMLEdBQW5DLEVBQXdDO0FBQ3BDc0wsa0JBQVVvK0IsV0FBVzFwQyxDQUFYLENBQVY7QUFDQWdxQyxzQkFBY0wsWUFBWXIrQixPQUFaLENBQWQ7QUFDQTIrQixxQkFBYUosV0FBV3YrQixPQUFYLENBQWI7QUFDQSxZQUFJeStCLE1BQU16K0IsT0FBTixLQUFrQnE4QixVQUFVcUMsV0FBVixFQUF1QkMsVUFBdkIsQ0FBdEIsRUFBMEQ7QUFDdEQ7QUFDSDtBQUNELFlBQUksQ0FBQ3RDLFVBQVVxQyxZQUFZem5DLE1BQXRCLEVBQThCMG5DLFdBQVcxbkMsTUFBekMsQ0FBRCxJQUFxRCxDQUFDb2xDLFVBQVVxQyxZQUFZLGNBQVosQ0FBVixFQUF1Q0MsV0FBVyxjQUFYLENBQXZDLENBQXRELElBQTRILENBQUN0QyxVQUFVcUMsWUFBWWhsQyxJQUF0QixFQUE0QmlsQyxXQUFXamxDLElBQXZDLENBQWpJLEVBQStLO0FBQzNLNmpDLHFCQUFTN25DLElBQVQsQ0FBYztBQUNWOG5DLHlCQUFTbEIsV0FBV0MsV0FEVjtBQUVWamMsc0JBQU0sQ0FBQ3RnQixPQUFEO0FBRkksYUFBZDtBQUlBNCtCLGtDQUFzQkosUUFBUUEsUUFBUW51QixXQUFSLENBQW9CclEsT0FBcEIsSUFBK0IsQ0FBdkMsQ0FBdEI7QUFDQXU5QixxQkFBUzduQyxJQUFULENBQWM7QUFDVjhuQyx5QkFBU2xCLFdBQVdwZ0MsUUFEVjtBQUVWb2tCLHNCQUFNLENBQ0ZxZSxVQURFLEVBRUZDLG1CQUZFO0FBRkksYUFBZDtBQU9BO0FBQ0g7QUFDRGQsaUNBQXlCWSxZQUFZbm9DLE1BQXJDLEVBQTZDb29DLFdBQVdwb0MsTUFBeEQsRUFBZ0VnbkMsUUFBaEUsRUFBMEV2OUIsT0FBMUUsRUFBbUYsSUFBbkYsRUFBeUZzOEIsV0FBV0csaUJBQXBHO0FBQ0FxQixpQ0FBeUJZLFlBQVk1a0MsS0FBckMsRUFBNEM2a0MsV0FBVzdrQyxLQUF2RCxFQUE4RHlqQyxRQUE5RCxFQUF3RXY5QixPQUF4RSxFQUFpRixJQUFqRixFQUF1RnM4QixXQUFXRSxnQkFBbEc7QUFDQSxZQUFJLENBQUNILFVBQVVxQyxZQUFZejZCLE1BQXRCLEVBQThCMDZCLFdBQVcxNkIsTUFBekMsQ0FBTCxFQUF1RDtBQUNuRHM1QixxQkFBUzduQyxJQUFULENBQWM7QUFDVjhuQyx5QkFBU2xCLFdBQVdJLFNBRFY7QUFFVnBjLHNCQUFNLENBQ0Z0Z0IsT0FERSxFQUVGMitCLFdBQVcxNkIsTUFGVDtBQUZJLGFBQWQ7QUFPSDtBQUNELFlBQUksQ0FBQ280QixVQUFVcUMsWUFBWTFoQyxPQUF0QixFQUErQjJoQyxXQUFXM2hDLE9BQTFDLENBQUQsSUFBdUQsQ0FBQ3EvQixVQUFVcUMsWUFBWTVoQyxPQUF0QixFQUErQjZoQyxXQUFXN2hDLE9BQTFDLENBQTVELEVBQWdIO0FBQzVHeWdDLHFCQUFTN25DLElBQVQsQ0FBYztBQUNWOG5DLHlCQUFTbEIsV0FBV1EsaUJBRFY7QUFFVnhjLHNCQUFNLENBQ0Z0Z0IsT0FERSxFQUVGMitCLFdBQVczaEMsT0FGVCxFQUdGMmhDLFdBQVc3aEMsT0FIVDtBQUZJLGFBQWQ7QUFRSDtBQUNELGFBQUs0VSxJQUFMLElBQWFndEIsV0FBYixFQUEwQjtBQUN0QixnQkFBSSxDQUFDQSxZQUFZdnRCLGNBQVosQ0FBMkJPLElBQTNCLENBQUwsRUFBdUM7QUFDbkM7QUFDSDtBQUNELGdCQUFJQSxTQUFTLFFBQVQsSUFBcUJBLFNBQVMsT0FBOUIsSUFBeUNBLFNBQVMsUUFBbEQsSUFBOERBLFNBQVMsVUFBdkUsSUFBcUZBLFNBQVMsU0FBOUYsSUFBMkdBLFNBQVMsU0FBeEgsRUFBbUk7QUFDL0g7QUFDSDtBQUNELGdCQUFJQSxLQUFLamMsT0FBTCxDQUFhLFFBQWIsTUFBMkIsQ0FBL0IsRUFBa0M7QUFDOUJxb0MseUNBQXlCWSxZQUFZaHRCLElBQVosQ0FBekIsRUFBNENpdEIsV0FBV2p0QixJQUFYLENBQTVDLEVBQThENnJCLFFBQTlELEVBQXdFdjlCLE9BQXhFLEVBQWlGMFIsS0FBSzdSLEtBQUwsQ0FBVyxDQUFYLENBQWpGLEVBQWdHeThCLFdBQVdFLGdCQUEzRztBQUNILGFBRkQsTUFFTyxJQUFJLENBQUNILFVBQVVxQyxZQUFZaHRCLElBQVosQ0FBVixFQUE2Qml0QixXQUFXanRCLElBQVgsQ0FBN0IsQ0FBTCxFQUFxRDtBQUN4RDZyQix5QkFBUzduQyxJQUFULENBQWM7QUFDVjhuQyw2QkFBU2xCLFdBQVdTLGdCQURWO0FBRVZ6YywwQkFBTSxDQUNGdGdCLE9BREUsRUFFRjBSLElBRkUsRUFHRml0QixXQUFXanRCLElBQVgsQ0FIRTtBQUZJLGlCQUFkO0FBUUg7QUFDSjtBQUNELGFBQUtBLElBQUwsSUFBYWl0QixVQUFiLEVBQXlCO0FBQ3JCLGdCQUFJLENBQUNBLFdBQVd4dEIsY0FBWCxDQUEwQk8sSUFBMUIsQ0FBRCxJQUFvQ2d0QixZQUFZdnRCLGNBQVosQ0FBMkJPLElBQTNCLENBQXhDLEVBQTBFO0FBQ3RFO0FBQ0g7QUFDRCxnQkFBSUEsU0FBUyxRQUFULElBQXFCQSxTQUFTLE9BQTlCLElBQXlDQSxTQUFTLFFBQWxELElBQThEQSxTQUFTLFVBQXZFLElBQXFGQSxTQUFTLFNBQTlGLElBQTJHQSxTQUFTLFNBQXhILEVBQW1JO0FBQy9IO0FBQ0g7QUFDRCxnQkFBSUEsS0FBS2pjLE9BQUwsQ0FBYSxRQUFiLE1BQTJCLENBQS9CLEVBQWtDO0FBQzlCcW9DLHlDQUF5QlksWUFBWWh0QixJQUFaLENBQXpCLEVBQTRDaXRCLFdBQVdqdEIsSUFBWCxDQUE1QyxFQUE4RDZyQixRQUE5RCxFQUF3RXY5QixPQUF4RSxFQUFpRjBSLEtBQUs3UixLQUFMLENBQVcsQ0FBWCxDQUFqRixFQUFnR3k4QixXQUFXRSxnQkFBM0c7QUFDSCxhQUZELE1BRU8sSUFBSSxDQUFDSCxVQUFVcUMsWUFBWWh0QixJQUFaLENBQVYsRUFBNkJpdEIsV0FBV2p0QixJQUFYLENBQTdCLENBQUwsRUFBcUQ7QUFDeEQ2ckIseUJBQVM3bkMsSUFBVCxDQUFjO0FBQ1Y4bkMsNkJBQVNsQixXQUFXUyxnQkFEVjtBQUVWemMsMEJBQU0sQ0FDRnRnQixPQURFLEVBRUYwUixJQUZFLEVBR0ZpdEIsV0FBV2p0QixJQUFYLENBSEU7QUFGSSxpQkFBZDtBQVFIO0FBQ0o7QUFDSjtBQUNKO0FBQ0QsU0FBU210QixVQUFULENBQW9CakIsTUFBcEIsRUFBNEJOLEtBQTVCLEVBQW1DO0FBQy9CLFFBQUksQ0FBQ00sTUFBTCxFQUFhO0FBQ1QsZUFBTyxDQUFDO0FBQ0FKLHFCQUFTbEIsV0FBV3JqQyxRQURwQjtBQUVBcW5CLGtCQUFNLENBQUNnZCxLQUFEO0FBRk4sU0FBRCxDQUFQO0FBSUg7QUFDRCxRQUFJQyxXQUFXLEVBQWY7QUFDQSxRQUFJO0FBQ0EsWUFBSSxDQUFDbEIsVUFBVXVCLE9BQU9wbUMsT0FBakIsRUFBMEI4bEMsTUFBTTlsQyxPQUFoQyxDQUFMLEVBQStDO0FBQzNDLG1CQUFPLENBQUM7QUFDQWdtQyx5QkFBU2xCLFdBQVdyakMsUUFEcEI7QUFFQXFuQixzQkFBTSxDQUFDZ2QsS0FBRDtBQUZOLGFBQUQsQ0FBUDtBQUlIO0FBQ0QsWUFBSSxDQUFDakIsVUFBVXVCLE9BQU92aUMsTUFBakIsRUFBeUJpaUMsTUFBTWppQyxNQUEvQixDQUFMLEVBQTZDO0FBQ3pDa2lDLHFCQUFTN25DLElBQVQsQ0FBYztBQUNWOG5DLHlCQUFTbEIsV0FBV2xoQyxTQURWO0FBRVZrbEIsc0JBQU0sQ0FBQ2dkLE1BQU1qaUMsTUFBUDtBQUZJLGFBQWQ7QUFJSDtBQUNELFlBQUksQ0FBQ2doQyxVQUFVdUIsT0FBTzdqQyxJQUFqQixFQUF1QnVqQyxNQUFNdmpDLElBQTdCLENBQUwsRUFBeUM7QUFDckN3akMscUJBQVM3bkMsSUFBVCxDQUFjO0FBQ1Y4bkMseUJBQVNsQixXQUFXaGhDLE9BRFY7QUFFVmdsQixzQkFBTSxDQUFDZ2QsTUFBTXZqQyxJQUFQO0FBRkksYUFBZDtBQUlIO0FBQ0QsWUFBSSxDQUFDc2lDLFVBQVV1QixPQUFPLzhCLE9BQWpCLEVBQTBCeThCLE1BQU16OEIsT0FBaEMsQ0FBTCxFQUErQztBQUMzQzA4QixxQkFBUzduQyxJQUFULENBQWM7QUFDVjhuQyx5QkFBU2xCLFdBQVdVLFVBRFY7QUFFVjFjLHNCQUFNLENBQUNnZCxNQUFNejhCLE9BQVA7QUFGSSxhQUFkO0FBSUg7QUFDRCxZQUFJLENBQUN3N0IsVUFBVXVCLE9BQU81OEIsS0FBakIsRUFBd0JzOEIsTUFBTXQ4QixLQUE5QixDQUFMLEVBQTJDO0FBQ3ZDdThCLHFCQUFTN25DLElBQVQsQ0FBYztBQUNWOG5DLHlCQUFTbEIsV0FBV1csUUFEVjtBQUVWM2Msc0JBQU0sQ0FBQ2dkLE1BQU10OEIsS0FBUDtBQUZJLGFBQWQ7QUFJSDtBQUNELFlBQUksQ0FBQ3E3QixVQUFVdUIsT0FBTy9sQyxNQUFqQixFQUF5QnlsQyxNQUFNemxDLE1BQS9CLENBQUwsRUFBNkM7QUFDekMwbEMscUJBQVM3bkMsSUFBVCxDQUFjO0FBQ1Y4bkMseUJBQVNsQixXQUFXWSxTQURWO0FBRVY1YyxzQkFBTSxDQUFDZ2QsTUFBTXpsQyxNQUFQO0FBRkksYUFBZDtBQUlIO0FBQ0QsWUFBSSxDQUFDd2tDLFVBQVV1QixPQUFPdjhCLE1BQWpCLEVBQXlCaThCLE1BQU1qOEIsTUFBL0IsQ0FBTCxFQUE2QztBQUN6Q2s4QixxQkFBUzduQyxJQUFULENBQWM7QUFDVjhuQyx5QkFBU2xCLFdBQVdhLFNBRFY7QUFFVjdjLHNCQUFNLENBQUNnZCxNQUFNajhCLE1BQVA7QUFGSSxhQUFkO0FBSUg7QUFDRCxZQUFJLENBQUNnN0IsVUFBVXVCLE9BQU90OEIsVUFBakIsRUFBNkJnOEIsTUFBTWg4QixVQUFuQyxDQUFMLEVBQXFEO0FBQ2pEaThCLHFCQUFTN25DLElBQVQsQ0FBYztBQUNWOG5DLHlCQUFTbEIsV0FBV2MsYUFEVjtBQUVWOWMsc0JBQU0sQ0FBQ2dkLE1BQU1oOEIsVUFBUDtBQUZJLGFBQWQ7QUFJSDtBQUNELFlBQUksQ0FBQys2QixVQUFVdUIsT0FBTzM4QixLQUFqQixFQUF3QnE4QixNQUFNcjhCLEtBQTlCLENBQUwsRUFBMkM7QUFDdkNzOEIscUJBQVM3bkMsSUFBVCxDQUFjO0FBQ1Y4bkMseUJBQVNsQixXQUFXZSxRQURWO0FBRVYvYyxzQkFBTSxDQUFDZ2QsTUFBTXI4QixLQUFQO0FBRkksYUFBZDtBQUlIO0FBQ0QsWUFBSXc4QixpQkFBaUIsRUFBckI7QUFDQSxZQUFJcUIsNEJBQTRCLEVBQWhDO0FBQ0FqQixvQkFBWUQsT0FBT25oQyxPQUFuQixFQUE0QjZnQyxNQUFNN2dDLE9BQWxDLEVBQTJDcWlDLHlCQUEzQyxFQUFzRXJCLGNBQXRFO0FBQ0EsWUFBSXNCLGVBQWUsRUFBbkI7QUFDQSxZQUFJbkIsT0FBT3hrQyxNQUFYLEVBQW1CO0FBQ2Z3a0MsbUJBQU94a0MsTUFBUCxDQUFjNmYsT0FBZCxDQUFzQixVQUFVM2lCLEtBQVYsRUFBaUI7QUFDbkMsb0JBQUltbkMsZUFBZW5uQyxNQUFNVyxNQUFyQixDQUFKLEVBQWtDO0FBQzlCc21DLDZCQUFTN25DLElBQVQsQ0FBYztBQUNWOG5DLGlDQUFTbEIsV0FBV0MsV0FEVjtBQUVWamMsOEJBQU0sQ0FBQ2hxQixNQUFNK0MsRUFBUDtBQUZJLHFCQUFkO0FBSUgsaUJBTEQsTUFLTztBQUNIMGxDLGlDQUFhcnBDLElBQWIsQ0FBa0JZLEtBQWxCO0FBQ0g7QUFDSixhQVREO0FBVUg7QUFDRGluQyxtQkFBV0EsU0FBU3QwQixNQUFULENBQWdCNjFCLHlCQUFoQixDQUFYO0FBQ0FaLG1CQUFXYSxZQUFYLEVBQXlCekIsTUFBTWxrQyxNQUEvQixFQUF1Q21rQyxRQUF2QztBQUNILEtBekVELENBeUVFLE9BQU9qa0MsQ0FBUCxFQUFVO0FBQ1JSLGdCQUFRKzlCLElBQVIsQ0FBYSwrQkFBYixFQUE4Q3Y5QixDQUE5QztBQUNBaWtDLG1CQUFXLENBQUM7QUFDSkMscUJBQVNsQixXQUFXcmpDLFFBRGhCO0FBRUpxbkIsa0JBQU0sQ0FBQ2dkLEtBQUQ7QUFGRixTQUFELENBQVg7QUFJSDtBQUNELFdBQU9DLFFBQVA7QUFDSDs7QUFFRCxJQUFJeUIsa0JBQWtCLFNBQVNBLGVBQVQsQ0FBeUJqaEMsR0FBekIsRUFBOEI2QyxLQUE5QixFQUFxQzZaLE9BQXJDLEVBQThDd2tCLFVBQTlDLEVBQTBEO0FBQzVFLFNBQUt4a0IsT0FBTCxHQUFlLENBQUMxYyxNQUFNQSxNQUFNLElBQVosR0FBbUIsRUFBcEIsSUFBMEIwYyxPQUF6QztBQUNBLFFBQUl3a0IsVUFBSixFQUFnQjtBQUNaLGFBQUtBLFVBQUwsR0FBa0JBLFVBQWxCO0FBQ0g7QUFDRCxRQUFJcitCLFVBQVUsSUFBVixJQUFrQkEsVUFBVWxJLFNBQTVCLElBQXlDa0ksTUFBTXMrQixRQUFuRCxFQUE2RDtBQUN6RCxhQUFLdDdCLElBQUwsR0FBWWhELE1BQU1zK0IsUUFBbEI7QUFDSDtBQUNKLENBUkQ7O0FBVUEsSUFBSUMsaUJBQWlCLFNBQVMza0IsWUFBVCxDQUFzQnpoQixLQUF0QixFQUE2QjtBQUM5QyxTQUFLQSxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLMGhCLE9BQUwsR0FBZTFoQixNQUFNMGhCLE9BQXJCO0FBQ0EsUUFBSTFqQixRQUFRZ0MsTUFBTTBoQixPQUFOLENBQWMxakIsS0FBZCxDQUFvQixZQUFwQixDQUFaO0FBQ0EsU0FBSzZNLElBQUwsR0FBWTdNLFFBQVErbEIsU0FBUy9sQixNQUFNLENBQU4sQ0FBVCxFQUFtQixFQUFuQixDQUFSLEdBQWlDLENBQTdDO0FBQ0gsQ0FMRDs7QUFPQSxTQUFTcW9DLGlCQUFULENBQTJCeDBCLE9BQTNCLEVBQW9DO0FBQ2hDLFFBQUk3TSxNQUFNNk0sUUFBUTdNLEdBQWxCO0FBQ0EsUUFBSXNiLFlBQVl6TyxRQUFRaEssS0FBeEI7QUFDQSxRQUFJeVksU0FBSixFQUFlO0FBQ1gsZUFBTyxDQUFDLElBQUkybEIsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QnNiLFNBQXpCLEVBQW9DLHlDQUFwQyxDQUFELENBQVA7QUFDSCxLQUZELE1BRU87QUFDSCxlQUFPLEVBQVA7QUFDSDtBQUNKOztBQUVELFNBQVNnbUIsUUFBVCxDQUFrQnorQixLQUFsQixFQUF5QjtBQUNyQixRQUFJQSxpQkFBaUJ5aEIsTUFBakIsSUFBMkJ6aEIsaUJBQWlCdU4sTUFBNUMsSUFBc0R2TixpQkFBaUJtaEIsT0FBM0UsRUFBb0Y7QUFDaEYsZUFBT25oQixNQUFNMCtCLE9BQU4sRUFBUDtBQUNILEtBRkQsTUFFTztBQUNILGVBQU8xK0IsS0FBUDtBQUNIO0FBQ0o7QUFDRCxTQUFTMitCLFlBQVQsQ0FBc0IzK0IsS0FBdEIsRUFBNkI7QUFDekIsUUFBSWhNLE1BQU1DLE9BQU4sQ0FBYytMLEtBQWQsQ0FBSixFQUEwQjtBQUN0QixlQUFPQSxNQUFNeEwsR0FBTixDQUFVbXFDLFlBQVYsQ0FBUDtBQUNILEtBRkQsTUFFTyxJQUFJMytCLGlCQUFpQm1MLE1BQWpCLElBQTJCLEVBQUVuTCxpQkFBaUJ5aEIsTUFBakIsSUFBMkJ6aEIsaUJBQWlCdU4sTUFBNUMsSUFBc0R2TixpQkFBaUJtaEIsT0FBekUsQ0FBL0IsRUFBa0g7QUFDckgsWUFBSXlkLGlCQUFpQixFQUFyQjtBQUNBLGFBQUssSUFBSXpoQyxHQUFULElBQWdCNkMsS0FBaEIsRUFBdUI7QUFDbkI0K0IsMkJBQWV6aEMsR0FBZixJQUFzQndoQyxhQUFhMytCLE1BQU03QyxHQUFOLENBQWIsQ0FBdEI7QUFDSDtBQUNELGVBQU95aEMsY0FBUDtBQUNIO0FBQ0QsV0FBT0gsU0FBU3orQixLQUFULENBQVA7QUFDSDs7QUFFRCxTQUFTNitCLGNBQVQsQ0FBd0I3MEIsT0FBeEIsRUFBaUM7QUFDN0IsUUFBSTdNLE1BQU02TSxRQUFRN00sR0FBbEI7QUFDQSxRQUFJMEosU0FBU21ELFFBQVFoSyxLQUFyQjtBQUNBLFFBQUk4K0IsZUFBZTkwQixRQUFRKzBCLFNBQVIsSUFBcUIsRUFBeEM7QUFDQSxRQUFJQyxvQkFBb0JoMUIsUUFBUWkxQix1QkFBUixJQUFtQyxFQUEzRDtBQUNBLFFBQUk3bUMsUUFBUTRSLFFBQVE1UixLQUFwQjtBQUNBLFFBQUk4bUMsWUFBWWwxQixRQUFRazFCLFNBQXhCO0FBQ0EsUUFBSS94QixTQUFTLEVBQWI7QUFDQSxRQUFJclUsT0FBTzY2QixRQUFROXNCLE1BQVIsQ0FBWDtBQUNBLFFBQUkvTixTQUFTLFFBQWIsRUFBdUI7QUFDbkIsZUFBTyxDQUFDLElBQUlzbEMsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QjBKLE1BQXpCLEVBQWlDLHNCQUFzQi9OLElBQXRCLEdBQTZCLFFBQTlELENBQUQsQ0FBUDtBQUNIO0FBQ0QsU0FBSyxJQUFJcW1DLFNBQVQsSUFBc0J0NEIsTUFBdEIsRUFBOEI7QUFDMUIsWUFBSXU0QixpQkFBaUJELFVBQVV6cUMsS0FBVixDQUFnQixHQUFoQixFQUFxQixDQUFyQixDQUFyQjtBQUNBLFlBQUkycUMsY0FBY1AsYUFBYU0sY0FBYixLQUFnQ04sYUFBYSxHQUFiLENBQWxEO0FBQ0EsWUFBSVEsa0JBQWtCLEtBQUssQ0FBM0I7QUFDQSxZQUFJTixrQkFBa0JJLGNBQWxCLENBQUosRUFBdUM7QUFDbkNFLDhCQUFrQk4sa0JBQWtCSSxjQUFsQixDQUFsQjtBQUNILFNBRkQsTUFFTyxJQUFJTixhQUFhTSxjQUFiLENBQUosRUFBa0M7QUFDckNFLDhCQUFrQkMsUUFBbEI7QUFDSCxTQUZNLE1BRUEsSUFBSVAsa0JBQWtCLEdBQWxCLENBQUosRUFBNEI7QUFDL0JNLDhCQUFrQk4sa0JBQWtCLEdBQWxCLENBQWxCO0FBQ0gsU0FGTSxNQUVBLElBQUlGLGFBQWEsR0FBYixDQUFKLEVBQXVCO0FBQzFCUSw4QkFBa0JDLFFBQWxCO0FBQ0gsU0FGTSxNQUVBO0FBQ0hweUIsbUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCMEosT0FBT3M0QixTQUFQLENBQXpCLEVBQTRDLHVCQUF1QkEsU0FBdkIsR0FBbUMsR0FBL0UsQ0FBWjtBQUNBO0FBQ0g7QUFDRGh5QixpQkFBU0EsT0FBTzlFLE1BQVAsQ0FBY2kzQixnQkFBZ0I7QUFDbkNuaUMsaUJBQUssQ0FBQ0EsTUFBTUEsTUFBTSxHQUFaLEdBQWtCQSxHQUFuQixJQUEwQmdpQyxTQURJO0FBRW5Dbi9CLG1CQUFPNkcsT0FBT3M0QixTQUFQLENBRjRCO0FBR25DSix1QkFBV00sV0FId0I7QUFJbkNqbkMsbUJBQU9BLEtBSjRCO0FBS25DOG1DLHVCQUFXQSxTQUx3QjtBQU1uQ3I0QixvQkFBUUEsTUFOMkI7QUFPbkNzNEIsdUJBQVdBO0FBUHdCLFNBQWhCLEVBUXBCdDRCLE1BUm9CLENBQWQsQ0FBVDtBQVNIO0FBQ0QsU0FBSyxJQUFJMjRCLGdCQUFULElBQTZCVixZQUE3QixFQUEyQztBQUN2QyxZQUFJRSxrQkFBa0JRLGdCQUFsQixDQUFKLEVBQXlDO0FBQ3JDO0FBQ0g7QUFDRCxZQUFJVixhQUFhVSxnQkFBYixFQUErQjkvQixRQUEvQixJQUEyQ28vQixhQUFhVSxnQkFBYixFQUErQixTQUEvQixNQUE4QzFuQyxTQUF6RixJQUFzRytPLE9BQU8yNEIsZ0JBQVAsTUFBNkIxbkMsU0FBdkksRUFBa0o7QUFDOUlxVixtQkFBT3JZLElBQVAsQ0FBWSxJQUFJc3BDLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUIwSixNQUF6QixFQUFpQyxnQ0FBZ0MyNEIsZ0JBQWhDLEdBQW1ELEdBQXBGLENBQVo7QUFDSDtBQUNKO0FBQ0QsV0FBT3J5QixNQUFQO0FBQ0g7O0FBRUQsU0FBU3N5QixhQUFULENBQXVCejFCLE9BQXZCLEVBQWdDO0FBQzVCLFFBQUk3RCxRQUFRNkQsUUFBUWhLLEtBQXBCO0FBQ0EsUUFBSTAvQixZQUFZMTFCLFFBQVErMEIsU0FBeEI7QUFDQSxRQUFJM21DLFFBQVE0UixRQUFRNVIsS0FBcEI7QUFDQSxRQUFJOG1DLFlBQVlsMUIsUUFBUWsxQixTQUF4QjtBQUNBLFFBQUkvaEMsTUFBTTZNLFFBQVE3TSxHQUFsQjtBQUNBLFFBQUl3aUMsdUJBQXVCMzFCLFFBQVE0MUIscUJBQVIsSUFBaUNMLFFBQTVEO0FBQ0EsUUFBSTVMLFFBQVF4dEIsS0FBUixNQUFtQixPQUF2QixFQUFnQztBQUM1QixlQUFPLENBQUMsSUFBSWk0QixlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCZ0osS0FBekIsRUFBZ0MscUJBQXFCd3RCLFFBQVF4dEIsS0FBUixDQUFyQixHQUFzQyxRQUF0RSxDQUFELENBQVA7QUFDSDtBQUNELFFBQUl1NUIsVUFBVXZyQyxNQUFWLElBQW9CZ1MsTUFBTWhTLE1BQU4sS0FBaUJ1ckMsVUFBVXZyQyxNQUFuRCxFQUEyRDtBQUN2RCxlQUFPLENBQUMsSUFBSWlxQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCZ0osS0FBekIsRUFBZ0Msa0JBQWtCdTVCLFVBQVV2ckMsTUFBNUIsR0FBcUMsb0JBQXJDLEdBQTREZ1MsTUFBTWhTLE1BQWxFLEdBQTJFLFFBQTNHLENBQUQsQ0FBUDtBQUNIO0FBQ0QsUUFBSXVyQyxVQUFVLFlBQVYsS0FBMkJ2NUIsTUFBTWhTLE1BQU4sR0FBZXVyQyxVQUFVLFlBQVYsQ0FBOUMsRUFBdUU7QUFDbkUsZUFBTyxDQUFDLElBQUl0QixlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCZ0osS0FBekIsRUFBZ0MsMkJBQTJCdTVCLFVBQVUsWUFBVixDQUEzQixHQUFxRCxvQkFBckQsR0FBNEV2NUIsTUFBTWhTLE1BQWxGLEdBQTJGLFFBQTNILENBQUQsQ0FBUDtBQUNIO0FBQ0QsUUFBSTByQyxtQkFBbUI7QUFDbkIsZ0JBQVFILFVBQVUxL0IsS0FEQztBQUVuQixrQkFBVTAvQixVQUFVLy9CO0FBRkQsS0FBdkI7QUFJQSxRQUFJdS9CLFVBQVUxL0IsUUFBVixHQUFxQixDQUF6QixFQUE0QjtBQUN4QnFnQyx5QkFBaUJDLFFBQWpCLEdBQTRCSixVQUFVSSxRQUF0QztBQUNIO0FBQ0QsUUFBSW5NLFFBQVErTCxVQUFVMS9CLEtBQWxCLE1BQTZCLFFBQWpDLEVBQTJDO0FBQ3ZDNi9CLDJCQUFtQkgsVUFBVTEvQixLQUE3QjtBQUNIO0FBQ0QsUUFBSW1OLFNBQVMsRUFBYjtBQUNBLFNBQUssSUFBSXJaLElBQUksQ0FBYixFQUFnQkEsSUFBSXFTLE1BQU1oUyxNQUExQixFQUFrQ0wsR0FBbEMsRUFBdUM7QUFDbkNxWixpQkFBU0EsT0FBTzlFLE1BQVAsQ0FBY3MzQixxQkFBcUI7QUFDeEN4NUIsbUJBQU9BLEtBRGlDO0FBRXhDNDVCLHdCQUFZanNDLENBRjRCO0FBR3hDa00sbUJBQU9tRyxNQUFNclMsQ0FBTixDQUhpQztBQUl4Q2lyQyx1QkFBV2MsZ0JBSjZCO0FBS3hDem5DLG1CQUFPQSxLQUxpQztBQU14QzhtQyx1QkFBV0EsU0FONkI7QUFPeEMvaEMsaUJBQUtBLE1BQU0sR0FBTixHQUFZckosQ0FBWixHQUFnQjtBQVBtQixTQUFyQixDQUFkLENBQVQ7QUFTSDtBQUNELFdBQU9xWixNQUFQO0FBQ0g7O0FBRUQsU0FBUzZ5QixjQUFULENBQXdCaDJCLE9BQXhCLEVBQWlDO0FBQzdCLFFBQUk3TSxNQUFNNk0sUUFBUTdNLEdBQWxCO0FBQ0EsUUFBSTZDLFFBQVFnSyxRQUFRaEssS0FBcEI7QUFDQSxRQUFJKytCLFlBQVkvMEIsUUFBUSswQixTQUF4QjtBQUNBLFFBQUlqbUMsT0FBTzY2QixRQUFRM3pCLEtBQVIsQ0FBWDtBQUNBLFFBQUlsSCxTQUFTLFFBQVQsSUFBcUJrSCxVQUFVQSxLQUFuQyxFQUEwQztBQUN0Q2xILGVBQU8sS0FBUDtBQUNIO0FBQ0QsUUFBSUEsU0FBUyxRQUFiLEVBQXVCO0FBQ25CLGVBQU8sQ0FBQyxJQUFJc2xDLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUI2QyxLQUF6QixFQUFnQyxzQkFBc0JsSCxJQUF0QixHQUE2QixRQUE3RCxDQUFELENBQVA7QUFDSDtBQUNELFFBQUksYUFBYWltQyxTQUFiLElBQTBCLytCLFFBQVErK0IsVUFBVWo5QixPQUFoRCxFQUF5RDtBQUNyRCxlQUFPLENBQUMsSUFBSXM4QixlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0NBLFFBQVEsa0NBQVIsR0FBNkMrK0IsVUFBVWo5QixPQUF2RixDQUFELENBQVA7QUFDSDtBQUNELFFBQUksYUFBYWk5QixTQUFiLElBQTBCLytCLFFBQVErK0IsVUFBVWw5QixPQUFoRCxFQUF5RDtBQUNyRCxlQUFPLENBQUMsSUFBSXU4QixlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0NBLFFBQVEscUNBQVIsR0FBZ0QrK0IsVUFBVWw5QixPQUExRixDQUFELENBQVA7QUFDSDtBQUNELFdBQU8sRUFBUDtBQUNIOztBQUVELFNBQVNvK0IsZ0JBQVQsQ0FBMEJqMkIsT0FBMUIsRUFBbUM7QUFDL0IsUUFBSWsyQixvQkFBb0JsMkIsUUFBUSswQixTQUFoQztBQUNBLFFBQUk3RyxlQUFldUcsU0FBU3owQixRQUFRaEssS0FBUixDQUFjbEgsSUFBdkIsQ0FBbkI7QUFDQSxRQUFJcW5DLFdBQUo7QUFDQSxRQUFJQyxtQkFBbUIsRUFBdkI7QUFDQSxRQUFJQyx1QkFBSjtBQUNBLFFBQUlDLHNCQUFKO0FBQ0EsUUFBSUMsaUJBQWlCckksaUJBQWlCLGFBQWpCLElBQWtDbHVCLFFBQVFoSyxLQUFSLENBQWNtSixRQUFkLEtBQTJCclIsU0FBbEY7QUFDQSxRQUFJMG9DLHFCQUFxQixDQUFDRCxjQUExQjtBQUNBLFFBQUlFLDRCQUE0QjlNLFFBQVEzcEIsUUFBUWhLLEtBQVIsQ0FBYzlMLEtBQXRCLE1BQWlDLE9BQWpDLElBQTRDeS9CLFFBQVEzcEIsUUFBUWhLLEtBQVIsQ0FBYzlMLEtBQWQsQ0FBb0IsQ0FBcEIsQ0FBUixNQUFvQyxPQUFoRixJQUEyRnkvQixRQUFRM3BCLFFBQVFoSyxLQUFSLENBQWM5TCxLQUFkLENBQW9CLENBQXBCLEVBQXVCLENBQXZCLENBQVIsTUFBdUMsUUFBbEs7QUFDQSxRQUFJaVosU0FBUzB4QixlQUFlO0FBQ3hCMWhDLGFBQUs2TSxRQUFRN00sR0FEVztBQUV4QjZDLGVBQU9nSyxRQUFRaEssS0FGUztBQUd4QisrQixtQkFBVy8wQixRQUFRazFCLFNBQVIsQ0FBa0JZLFFBSEw7QUFJeEIxbkMsZUFBTzRSLFFBQVE1UixLQUpTO0FBS3hCOG1DLG1CQUFXbDFCLFFBQVFrMUIsU0FMSztBQU14QkQsaUNBQXlCO0FBQ3JCL3FDLG1CQUFPd3NDLHFCQURjO0FBRXJCck0scUJBQVNzTTtBQUZZO0FBTkQsS0FBZixDQUFiO0FBV0EsUUFBSXpJLGlCQUFpQixVQUFqQixJQUErQnFJLGNBQW5DLEVBQW1EO0FBQy9DcHpCLGVBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CcDBCLFFBQVE3TSxHQUE1QixFQUFpQzZNLFFBQVFoSyxLQUF6QyxFQUFnRCxzQ0FBaEQsQ0FBWjtBQUNIO0FBQ0QsUUFBSWs0QixpQkFBaUIsVUFBakIsSUFBK0IsQ0FBQ2x1QixRQUFRaEssS0FBUixDQUFjOUwsS0FBbEQsRUFBeUQ7QUFDckRpWixlQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQnAwQixRQUFRN00sR0FBNUIsRUFBaUM2TSxRQUFRaEssS0FBekMsRUFBZ0QsbUNBQWhELENBQVo7QUFDSDtBQUNELFFBQUlrNEIsaUJBQWlCLGFBQWpCLElBQWtDbHVCLFFBQVErMEIsU0FBUixDQUFrQnQ3QixVQUFwRCxJQUFrRSxDQUFDaXdCLHNCQUFzQjFwQixRQUFRKzBCLFNBQTlCLENBQXZFLEVBQWlIO0FBQzdHNXhCLGVBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CcDBCLFFBQVE3TSxHQUE1QixFQUFpQzZNLFFBQVFoSyxLQUF6QyxFQUFnRCxxQ0FBaEQsQ0FBWjtBQUNIO0FBQ0QsUUFBSWdLLFFBQVFrMUIsU0FBUixDQUFrQjEvQixRQUFsQixJQUE4QixDQUFsQyxFQUFxQztBQUNqQyxZQUFJZ2hDLHNCQUFzQixDQUFDak4sMkJBQTJCdnBCLFFBQVErMEIsU0FBbkMsQ0FBM0IsRUFBMEU7QUFDdEU1eEIsbUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CcDBCLFFBQVE3TSxHQUE1QixFQUFpQzZNLFFBQVFoSyxLQUF6QyxFQUFnRCxrQ0FBaEQsQ0FBWjtBQUNILFNBRkQsTUFFTyxJQUFJdWdDLGtCQUFrQixDQUFDOU0sdUJBQXVCenBCLFFBQVErMEIsU0FBL0IsQ0FBdkIsRUFBa0U7QUFDckU1eEIsbUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CcDBCLFFBQVE3TSxHQUE1QixFQUFpQzZNLFFBQVFoSyxLQUF6QyxFQUFnRCw4QkFBaEQsQ0FBWjtBQUNIO0FBQ0o7QUFDRCxRQUFJLENBQUNrNEIsaUJBQWlCLGFBQWpCLElBQWtDdUkseUJBQW5DLEtBQWlFejJCLFFBQVFoSyxLQUFSLENBQWNtSixRQUFkLEtBQTJCclIsU0FBaEcsRUFBMkc7QUFDdkdxVixlQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQnAwQixRQUFRN00sR0FBNUIsRUFBaUM2TSxRQUFRaEssS0FBekMsRUFBZ0QsaUNBQWhELENBQVo7QUFDSDtBQUNELFdBQU9tTixNQUFQO0FBQ0EsYUFBU3V6QixxQkFBVCxDQUErQjEyQixPQUEvQixFQUF3QztBQUNwQyxZQUFJa3VCLGlCQUFpQixVQUFyQixFQUFpQztBQUM3QixtQkFBTyxDQUFDLElBQUlrRyxlQUFKLENBQW9CcDBCLFFBQVE3TSxHQUE1QixFQUFpQzZNLFFBQVFoSyxLQUF6QyxFQUFnRCxtREFBaEQsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxZQUFJbU4sU0FBUyxFQUFiO0FBQ0EsWUFBSW5OLFFBQVFnSyxRQUFRaEssS0FBcEI7QUFDQW1OLGlCQUFTQSxPQUFPOUUsTUFBUCxDQUFjbzNCLGNBQWM7QUFDakN0aUMsaUJBQUs2TSxRQUFRN00sR0FEb0I7QUFFakM2QyxtQkFBT0EsS0FGMEI7QUFHakMrK0IsdUJBQVcvMEIsUUFBUSswQixTQUhjO0FBSWpDM21DLG1CQUFPNFIsUUFBUTVSLEtBSmtCO0FBS2pDOG1DLHVCQUFXbDFCLFFBQVFrMUIsU0FMYztBQU1qQ1UsbUNBQXVCZ0I7QUFOVSxTQUFkLENBQWQsQ0FBVDtBQVFBLFlBQUlqTixRQUFRM3pCLEtBQVIsTUFBbUIsT0FBbkIsSUFBOEJBLE1BQU03TCxNQUFOLEtBQWlCLENBQW5ELEVBQXNEO0FBQ2xEZ1osbUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CcDBCLFFBQVE3TSxHQUE1QixFQUFpQzZDLEtBQWpDLEVBQXdDLG1DQUF4QyxDQUFaO0FBQ0g7QUFDRCxlQUFPbU4sTUFBUDtBQUNIO0FBQ0QsYUFBU3l6QixvQkFBVCxDQUE4QjUyQixPQUE5QixFQUF1QztBQUNuQyxZQUFJbUQsU0FBUyxFQUFiO0FBQ0EsWUFBSW5OLFFBQVFnSyxRQUFRaEssS0FBcEI7QUFDQSxZQUFJN0MsTUFBTTZNLFFBQVE3TSxHQUFsQjtBQUNBLFlBQUl3MkIsUUFBUTN6QixLQUFSLE1BQW1CLE9BQXZCLEVBQWdDO0FBQzVCLG1CQUFPLENBQUMsSUFBSW8rQixlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0MscUJBQXFCMnpCLFFBQVEzekIsS0FBUixDQUFyQixHQUFzQyxRQUF0RSxDQUFELENBQVA7QUFDSDtBQUNELFlBQUlBLE1BQU03TCxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3BCLG1CQUFPLENBQUMsSUFBSWlxQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0MscUNBQXFDQSxNQUFNN0wsTUFBM0MsR0FBb0QsUUFBcEYsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxZQUFJc3NDLHlCQUFKLEVBQStCO0FBQzNCLGdCQUFJOU0sUUFBUTN6QixNQUFNLENBQU4sQ0FBUixNQUFzQixRQUExQixFQUFvQztBQUNoQyx1QkFBTyxDQUFDLElBQUlvK0IsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QjZDLEtBQXpCLEVBQWdDLHNCQUFzQjJ6QixRQUFRM3pCLE1BQU0sQ0FBTixDQUFSLENBQXRCLEdBQTBDLFFBQTFFLENBQUQsQ0FBUDtBQUNIO0FBQ0QsZ0JBQUlBLE1BQU0sQ0FBTixFQUFTN0csSUFBVCxLQUFrQnJCLFNBQXRCLEVBQWlDO0FBQzdCLHVCQUFPLENBQUMsSUFBSXNtQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0MsZ0NBQWhDLENBQUQsQ0FBUDtBQUNIO0FBQ0QsZ0JBQUlBLE1BQU0sQ0FBTixFQUFTQSxLQUFULEtBQW1CbEksU0FBdkIsRUFBa0M7QUFDOUIsdUJBQU8sQ0FBQyxJQUFJc21DLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUI2QyxLQUF6QixFQUFnQyxpQ0FBaEMsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxnQkFBSXNnQywwQkFBMEJBLHlCQUF5QjdCLFNBQVN6K0IsTUFBTSxDQUFOLEVBQVM3RyxJQUFsQixDQUF2RCxFQUFnRjtBQUM1RSx1QkFBTyxDQUFDLElBQUlpbEMsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QjZDLE1BQU0sQ0FBTixFQUFTN0csSUFBbEMsRUFBd0MsaURBQXhDLENBQUQsQ0FBUDtBQUNIO0FBQ0QsZ0JBQUlzbEMsU0FBU3orQixNQUFNLENBQU4sRUFBUzdHLElBQWxCLE1BQTRCbW5DLHNCQUFoQyxFQUF3RDtBQUNwREEseUNBQXlCN0IsU0FBU3orQixNQUFNLENBQU4sRUFBUzdHLElBQWxCLENBQXpCO0FBQ0FrbkMsMENBQTBCdm9DLFNBQTFCO0FBQ0Fzb0MsbUNBQW1CLEVBQW5CO0FBQ0g7QUFDRGp6QixxQkFBU0EsT0FBTzlFLE1BQVAsQ0FBY3cyQixlQUFlO0FBQ2xDMWhDLHFCQUFLQSxNQUFNLEtBRHVCO0FBRWxDNkMsdUJBQU9BLE1BQU0sQ0FBTixDQUYyQjtBQUdsQysrQiwyQkFBVyxFQUFFNWxDLE1BQU0sRUFBUixFQUh1QjtBQUlsQ2YsdUJBQU80UixRQUFRNVIsS0FKbUI7QUFLbEM4bUMsMkJBQVdsMUIsUUFBUWsxQixTQUxlO0FBTWxDRCx5Q0FBeUI7QUFDckI5bEMsMEJBQU02bUMsY0FEZTtBQUVyQmhnQywyQkFBTzZnQztBQUZjO0FBTlMsYUFBZixDQUFkLENBQVQ7QUFXSCxTQTdCRCxNQTZCTztBQUNIMXpCLHFCQUFTQSxPQUFPOUUsTUFBUCxDQUFjdzRCLHdCQUF3QjtBQUMzQzFqQyxxQkFBS0EsTUFBTSxLQURnQztBQUUzQzZDLHVCQUFPQSxNQUFNLENBQU4sQ0FGb0M7QUFHM0MrK0IsMkJBQVcsRUFIZ0M7QUFJM0MzbUMsdUJBQU80UixRQUFRNVIsS0FKNEI7QUFLM0M4bUMsMkJBQVdsMUIsUUFBUWsxQjtBQUx3QixhQUF4QixFQU1wQmwvQixLQU5vQixDQUFkLENBQVQ7QUFPSDtBQUNELFlBQUlrMkIsYUFBYXlJLGFBQWEzK0IsTUFBTSxDQUFOLENBQWIsQ0FBYixDQUFKLEVBQTBDO0FBQ3RDLG1CQUFPbU4sT0FBTzlFLE1BQVAsQ0FBYyxDQUFDLElBQUkrMUIsZUFBSixDQUFvQmpoQyxNQUFNLEtBQTFCLEVBQWlDNkMsTUFBTSxDQUFOLENBQWpDLEVBQTJDLGdEQUEzQyxDQUFELENBQWQsQ0FBUDtBQUNIO0FBQ0QsZUFBT21OLE9BQU85RSxNQUFQLENBQWNrM0IsU0FBUztBQUMxQnBpQyxpQkFBS0EsTUFBTSxLQURlO0FBRTFCNkMsbUJBQU9BLE1BQU0sQ0FBTixDQUZtQjtBQUcxQisrQix1QkFBV21CLGlCQUhlO0FBSTFCOW5DLG1CQUFPNFIsUUFBUTVSLEtBSlc7QUFLMUI4bUMsdUJBQVdsMUIsUUFBUWsxQjtBQUxPLFNBQVQsQ0FBZCxDQUFQO0FBT0g7QUFDRCxhQUFTMkIsdUJBQVQsQ0FBaUM3MkIsT0FBakMsRUFBMENpUCxJQUExQyxFQUFnRDtBQUM1QyxZQUFJbmdCLE9BQU82NkIsUUFBUTNwQixRQUFRaEssS0FBaEIsQ0FBWDtBQUNBLFlBQUlBLFFBQVF5K0IsU0FBU3owQixRQUFRaEssS0FBakIsQ0FBWjtBQUNBLFlBQUk4Z0MsY0FBYzkyQixRQUFRaEssS0FBUixLQUFrQixJQUFsQixHQUF5QmdLLFFBQVFoSyxLQUFqQyxHQUF5Q2laLElBQTNEO0FBQ0EsWUFBSSxDQUFDa25CLFdBQUwsRUFBa0I7QUFDZEEsMEJBQWNybkMsSUFBZDtBQUNILFNBRkQsTUFFTyxJQUFJQSxTQUFTcW5DLFdBQWIsRUFBMEI7QUFDN0IsbUJBQU8sQ0FBQyxJQUFJL0IsZUFBSixDQUFvQnAwQixRQUFRN00sR0FBNUIsRUFBaUMyakMsV0FBakMsRUFBOENob0MsT0FBTyx5REFBUCxHQUFtRXFuQyxXQUFqSCxDQUFELENBQVA7QUFDSDtBQUNELFlBQUlybkMsU0FBUyxRQUFULElBQXFCQSxTQUFTLFFBQTlCLElBQTBDQSxTQUFTLFNBQXZELEVBQWtFO0FBQzlELG1CQUFPLENBQUMsSUFBSXNsQyxlQUFKLENBQW9CcDBCLFFBQVE3TSxHQUE1QixFQUFpQzJqQyxXQUFqQyxFQUE4Qyx3REFBOUMsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxZQUFJaG9DLFNBQVMsUUFBVCxJQUFxQm8vQixpQkFBaUIsYUFBMUMsRUFBeUQ7QUFDckQsZ0JBQUlyZSxVQUFVLHNCQUFzQi9nQixJQUF0QixHQUE2QixRQUEzQztBQUNBLGdCQUFJeTZCLDJCQUEyQjJNLGlCQUEzQixLQUFpRGhJLGlCQUFpQnBnQyxTQUF0RSxFQUFpRjtBQUM3RStoQiwyQkFBVyxtRkFBWDtBQUNIO0FBQ0QsbUJBQU8sQ0FBQyxJQUFJdWtCLGVBQUosQ0FBb0JwMEIsUUFBUTdNLEdBQTVCLEVBQWlDMmpDLFdBQWpDLEVBQThDam5CLE9BQTlDLENBQUQsQ0FBUDtBQUNIO0FBQ0QsWUFBSXFlLGlCQUFpQixhQUFqQixJQUFrQ3AvQixTQUFTLFFBQTNDLEtBQXdELENBQUNnWixTQUFTOVIsS0FBVCxDQUFELElBQW9CcU4sS0FBS3BGLEtBQUwsQ0FBV2pJLEtBQVgsTUFBc0JBLEtBQWxHLENBQUosRUFBOEc7QUFDMUcsbUJBQU8sQ0FBQyxJQUFJbytCLGVBQUosQ0FBb0JwMEIsUUFBUTdNLEdBQTVCLEVBQWlDMmpDLFdBQWpDLEVBQThDLDZCQUE2QjlnQyxLQUEzRSxDQUFELENBQVA7QUFDSDtBQUNELFlBQUlrNEIsaUJBQWlCLGFBQWpCLElBQWtDcC9CLFNBQVMsUUFBM0MsSUFBdUR1bkMsNEJBQTRCdm9DLFNBQW5GLElBQWdHa0ksUUFBUXFnQyx1QkFBNUcsRUFBcUk7QUFDakksbUJBQU8sQ0FBQyxJQUFJakMsZUFBSixDQUFvQnAwQixRQUFRN00sR0FBNUIsRUFBaUMyakMsV0FBakMsRUFBOEMsbURBQTlDLENBQUQsQ0FBUDtBQUNILFNBRkQsTUFFTztBQUNIVCxzQ0FBMEJyZ0MsS0FBMUI7QUFDSDtBQUNELFlBQUlrNEIsaUJBQWlCLGFBQWpCLElBQWtDbDRCLFNBQVNvZ0MsZ0JBQS9DLEVBQWlFO0FBQzdELG1CQUFPLENBQUMsSUFBSWhDLGVBQUosQ0FBb0JwMEIsUUFBUTdNLEdBQTVCLEVBQWlDMmpDLFdBQWpDLEVBQThDLG1DQUE5QyxDQUFELENBQVA7QUFDSCxTQUZELE1BRU87QUFDSFYsNkJBQWlCcGdDLEtBQWpCLElBQTBCLElBQTFCO0FBQ0g7QUFDRCxlQUFPLEVBQVA7QUFDSDtBQUNELGFBQVMyZ0MsdUJBQVQsQ0FBaUMzMkIsT0FBakMsRUFBMEM7QUFDdEMsZUFBT3UxQixTQUFTO0FBQ1pwaUMsaUJBQUs2TSxRQUFRN00sR0FERDtBQUVaNkMsbUJBQU9nSyxRQUFRaEssS0FGSDtBQUdaKytCLHVCQUFXbUIsaUJBSEM7QUFJWjluQyxtQkFBTzRSLFFBQVE1UixLQUpIO0FBS1o4bUMsdUJBQVdsMUIsUUFBUWsxQjtBQUxQLFNBQVQsQ0FBUDtBQU9IO0FBQ0o7O0FBRUQsU0FBUzZCLGtCQUFULENBQTRCLzJCLE9BQTVCLEVBQXFDO0FBQ2pDLFFBQUl2RyxhQUFhLENBQUN1RyxRQUFRZzNCLGlCQUFSLEtBQThCLFVBQTlCLEdBQTJDdEssd0JBQTNDLEdBQXNFUCxnQkFBdkUsRUFBeUZ3SSxhQUFhMzBCLFFBQVFoSyxLQUFyQixDQUF6RixFQUFzSGdLLFFBQVErMEIsU0FBOUgsQ0FBakI7QUFDQSxRQUFJdDdCLFdBQVc2SCxNQUFYLEtBQXNCLE9BQTFCLEVBQW1DO0FBQy9CLGVBQU83SCxXQUFXekQsS0FBWCxDQUFpQnhMLEdBQWpCLENBQXFCLFVBQVUyRCxLQUFWLEVBQWlCO0FBQ3pDLG1CQUFPLElBQUlpbUMsZUFBSixDQUFvQixLQUFLcDBCLFFBQVE3TSxHQUFiLEdBQW1CaEYsTUFBTWdGLEdBQTdDLEVBQWtENk0sUUFBUWhLLEtBQTFELEVBQWlFN0gsTUFBTTBoQixPQUF2RSxDQUFQO0FBQ0gsU0FGTSxDQUFQO0FBR0g7QUFDRCxRQUFJb25CLGdCQUFnQng5QixXQUFXekQsS0FBWCxDQUFpQnlELFVBQWpCLElBQStCQSxXQUFXekQsS0FBWCxDQUFpQnUyQixnQkFBakIsQ0FBa0M5eUIsVUFBckY7QUFDQSxRQUFJdUcsUUFBUWczQixpQkFBUixLQUE4QixVQUE5QixJQUE0Q2gzQixRQUFRazNCLFdBQVIsS0FBd0IsV0FBcEUsSUFBbUYsQ0FBQ0QsY0FBY2xoQixhQUFkLEVBQXhGLEVBQXVIO0FBQ25ILGVBQU8sQ0FBQyxJQUFJcWUsZUFBSixDQUFvQnAwQixRQUFRN00sR0FBNUIsRUFBaUM2TSxRQUFRaEssS0FBekMsRUFBZ0Qsa0NBQWtDZ0ssUUFBUWszQixXQUExQyxHQUF3RCx1RUFBeEcsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxRQUFJbDNCLFFBQVFnM0IsaUJBQVIsS0FBOEIsVUFBOUIsSUFBNENoM0IsUUFBUW9PLFlBQVIsS0FBeUIsUUFBckUsSUFBaUYsQ0FBQzJRLGdCQUFnQmtZLGFBQWhCLENBQXRGLEVBQXNIO0FBQ2xILGVBQU8sQ0FBQyxJQUFJN0MsZUFBSixDQUFvQnAwQixRQUFRN00sR0FBNUIsRUFBaUM2TSxRQUFRaEssS0FBekMsRUFBZ0QsNEVBQWhELENBQUQsQ0FBUDtBQUNIO0FBQ0QsUUFBSWdLLFFBQVFnM0IsaUJBQVIsS0FBOEIsUUFBOUIsSUFBMEMsQ0FBQ2pZLGdCQUFnQmtZLGFBQWhCLENBQS9DLEVBQStFO0FBQzNFLGVBQU8sQ0FBQyxJQUFJN0MsZUFBSixDQUFvQnAwQixRQUFRN00sR0FBNUIsRUFBaUM2TSxRQUFRaEssS0FBekMsRUFBZ0Qsa0VBQWhELENBQUQsQ0FBUDtBQUNIO0FBQ0QsUUFBSWdLLFFBQVFnM0IsaUJBQVIsSUFBNkJoM0IsUUFBUWczQixpQkFBUixDQUEwQm5zQyxPQUExQixDQUFrQyxTQUFsQyxNQUFpRCxDQUFsRixFQUFxRjtBQUNqRixZQUFJLENBQUNtMEIseUJBQXlCaVksYUFBekIsRUFBd0MsQ0FDckMsTUFEcUMsRUFFckMsZUFGcUMsQ0FBeEMsQ0FBTCxFQUdRO0FBQ0osbUJBQU8sQ0FBQyxJQUFJN0MsZUFBSixDQUFvQnAwQixRQUFRN00sR0FBNUIsRUFBaUM2TSxRQUFRaEssS0FBekMsRUFBZ0QsbUZBQWhELENBQUQsQ0FBUDtBQUNIO0FBQ0QsWUFBSWdLLFFBQVFnM0IsaUJBQVIsS0FBOEIsaUJBQTlCLElBQW1ELENBQUNsWSxrQkFBa0JtWSxhQUFsQixDQUF4RCxFQUEwRjtBQUN0RixtQkFBTyxDQUFDLElBQUk3QyxlQUFKLENBQW9CcDBCLFFBQVE3TSxHQUE1QixFQUFpQzZNLFFBQVFoSyxLQUF6QyxFQUFnRCxnR0FBaEQsQ0FBRCxDQUFQO0FBQ0g7QUFDSjtBQUNELFdBQU8sRUFBUDtBQUNIOztBQUVELFNBQVNtaEMsZUFBVCxDQUF5Qm4zQixPQUF6QixFQUFrQztBQUM5QixRQUFJaEssUUFBUWdLLFFBQVFoSyxLQUFwQjtBQUNBLFFBQUk3QyxNQUFNNk0sUUFBUTdNLEdBQWxCO0FBQ0EsUUFBSXJFLE9BQU82NkIsUUFBUTN6QixLQUFSLENBQVg7QUFDQSxRQUFJbEgsU0FBUyxTQUFiLEVBQXdCO0FBQ3BCLGVBQU8sQ0FBQyxJQUFJc2xDLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUI2QyxLQUF6QixFQUFnQyx1QkFBdUJsSCxJQUF2QixHQUE4QixRQUE5RCxDQUFELENBQVA7QUFDSDtBQUNELFdBQU8sRUFBUDtBQUNIOztBQUVELFNBQVNzb0MsYUFBVCxDQUF1QnAzQixPQUF2QixFQUFnQztBQUM1QixRQUFJN00sTUFBTTZNLFFBQVE3TSxHQUFsQjtBQUNBLFFBQUk2QyxRQUFRZ0ssUUFBUWhLLEtBQXBCO0FBQ0EsUUFBSWxILE9BQU82NkIsUUFBUTN6QixLQUFSLENBQVg7QUFDQSxRQUFJbEgsU0FBUyxRQUFiLEVBQXVCO0FBQ25CLGVBQU8sQ0FBQyxJQUFJc2xDLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUI2QyxLQUF6QixFQUFnQyxxQkFBcUJsSCxJQUFyQixHQUE0QixRQUE1RCxDQUFELENBQVA7QUFDSDtBQUNELFFBQUlpa0IsaUJBQWlCL2MsS0FBakIsTUFBNEIsSUFBaEMsRUFBc0M7QUFDbEMsZUFBTyxDQUFDLElBQUlvK0IsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QjZDLEtBQXpCLEVBQWdDLHNCQUFzQkEsS0FBdEIsR0FBOEIsU0FBOUQsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxXQUFPLEVBQVA7QUFDSDs7QUFFRCxTQUFTcWhDLFlBQVQsQ0FBc0JyM0IsT0FBdEIsRUFBK0I7QUFDM0IsUUFBSTdNLE1BQU02TSxRQUFRN00sR0FBbEI7QUFDQSxRQUFJNkMsUUFBUWdLLFFBQVFoSyxLQUFwQjtBQUNBLFFBQUkrK0IsWUFBWS8wQixRQUFRKzBCLFNBQXhCO0FBQ0EsUUFBSTV4QixTQUFTLEVBQWI7QUFDQSxRQUFJblosTUFBTUMsT0FBTixDQUFjOHFDLFVBQVVwL0IsTUFBeEIsQ0FBSixFQUFxQztBQUNqQyxZQUFJby9CLFVBQVVwL0IsTUFBVixDQUFpQjlLLE9BQWpCLENBQXlCNHBDLFNBQVN6K0IsS0FBVCxDQUF6QixNQUE4QyxDQUFDLENBQW5ELEVBQXNEO0FBQ2xEbU4sbUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0Msc0JBQXNCKytCLFVBQVVwL0IsTUFBVixDQUFpQlQsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBdEIsR0FBb0QsS0FBcEQsR0FBNER4SSxLQUFLb1QsU0FBTCxDQUFlOUosS0FBZixDQUE1RCxHQUFvRixRQUFwSCxDQUFaO0FBQ0g7QUFDSixLQUpELE1BSU87QUFDSCxZQUFJbUwsT0FBT04sSUFBUCxDQUFZazBCLFVBQVVwL0IsTUFBdEIsRUFBOEI5SyxPQUE5QixDQUFzQzRwQyxTQUFTeitCLEtBQVQsQ0FBdEMsTUFBMkQsQ0FBQyxDQUFoRSxFQUFtRTtBQUMvRG1OLG1CQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QjZDLEtBQXpCLEVBQWdDLHNCQUFzQm1MLE9BQU9OLElBQVAsQ0FBWWswQixVQUFVcC9CLE1BQXRCLEVBQThCVCxJQUE5QixDQUFtQyxJQUFuQyxDQUF0QixHQUFpRSxLQUFqRSxHQUF5RXhJLEtBQUtvVCxTQUFMLENBQWU5SixLQUFmLENBQXpFLEdBQWlHLFFBQWpJLENBQVo7QUFDSDtBQUNKO0FBQ0QsV0FBT21OLE1BQVA7QUFDSDs7QUFFRCxTQUFTbTBCLGNBQVQsQ0FBd0J0M0IsT0FBeEIsRUFBaUM7QUFDN0IsUUFBSWt2QixtQkFBbUJ5RixhQUFhMzBCLFFBQVFoSyxLQUFyQixDQUFuQixDQUFKLEVBQXFEO0FBQ2pELGVBQU8rZ0MsbUJBQW1CdG5CLE9BQU8sRUFBUCxFQUFXelAsT0FBWCxFQUFvQjtBQUMxQ2czQiwrQkFBbUIsUUFEdUI7QUFFMUNqQyx1QkFBVyxFQUFFLytCLE9BQU8sU0FBVDtBQUYrQixTQUFwQixDQUFuQixDQUFQO0FBSUgsS0FMRCxNQUtPO0FBQ0gsZUFBT3VoQyw0QkFBNEJ2M0IsT0FBNUIsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxTQUFTdTNCLDJCQUFULENBQXFDdjNCLE9BQXJDLEVBQThDO0FBQzFDLFFBQUloSyxRQUFRZ0ssUUFBUWhLLEtBQXBCO0FBQ0EsUUFBSTdDLE1BQU02TSxRQUFRN00sR0FBbEI7QUFDQSxRQUFJdzJCLFFBQVEzekIsS0FBUixNQUFtQixPQUF2QixFQUFnQztBQUM1QixlQUFPLENBQUMsSUFBSW8rQixlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0MscUJBQXFCMnpCLFFBQVEzekIsS0FBUixDQUFyQixHQUFzQyxRQUF0RSxDQUFELENBQVA7QUFDSDtBQUNELFFBQUlrL0IsWUFBWWwxQixRQUFRazFCLFNBQXhCO0FBQ0EsUUFBSXBtQyxJQUFKO0FBQ0EsUUFBSXFVLFNBQVMsRUFBYjtBQUNBLFFBQUluTixNQUFNN0wsTUFBTixHQUFlLENBQW5CLEVBQXNCO0FBQ2xCLGVBQU8sQ0FBQyxJQUFJaXFDLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUI2QyxLQUF6QixFQUFnQywyQ0FBaEMsQ0FBRCxDQUFQO0FBQ0g7QUFDRG1OLGFBQVNBLE9BQU85RSxNQUFQLENBQWNnNUIsYUFBYTtBQUNoQ2xrQyxhQUFLQSxNQUFNLEtBRHFCO0FBRWhDNkMsZUFBT0EsTUFBTSxDQUFOLENBRnlCO0FBR2hDKytCLG1CQUFXRyxVQUFVMzVCLGVBSFc7QUFJaENuTixlQUFPNFIsUUFBUTVSLEtBSmlCO0FBS2hDOG1DLG1CQUFXbDFCLFFBQVFrMUI7QUFMYSxLQUFiLENBQWQsQ0FBVDtBQU9BLFlBQVFULFNBQVN6K0IsTUFBTSxDQUFOLENBQVQsQ0FBUjtBQUNBLGFBQUssR0FBTDtBQUNBLGFBQUssSUFBTDtBQUNBLGFBQUssR0FBTDtBQUNBLGFBQUssSUFBTDtBQUNJLGdCQUFJQSxNQUFNN0wsTUFBTixJQUFnQixDQUFoQixJQUFxQnNxQyxTQUFTeitCLE1BQU0sQ0FBTixDQUFULE1BQXVCLE9BQWhELEVBQXlEO0FBQ3JEbU4sdUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0MsMENBQTBDQSxNQUFNLENBQU4sQ0FBMUMsR0FBcUQsR0FBckYsQ0FBWjtBQUNIO0FBQ0wsYUFBSyxJQUFMO0FBQ0EsYUFBSyxJQUFMO0FBQ0ksZ0JBQUlBLE1BQU03TCxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3BCZ1osdUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0MsZ0NBQWdDQSxNQUFNLENBQU4sQ0FBaEMsR0FBMkMsd0JBQTNFLENBQVo7QUFDSDtBQUNMLGFBQUssSUFBTDtBQUNBLGFBQUssS0FBTDtBQUNJLGdCQUFJQSxNQUFNN0wsTUFBTixJQUFnQixDQUFwQixFQUF1QjtBQUNuQjJFLHVCQUFPNjZCLFFBQVEzekIsTUFBTSxDQUFOLENBQVIsQ0FBUDtBQUNBLG9CQUFJbEgsU0FBUyxRQUFiLEVBQXVCO0FBQ25CcVUsMkJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLE1BQU0sS0FBMUIsRUFBaUM2QyxNQUFNLENBQU4sQ0FBakMsRUFBMkMsc0JBQXNCbEgsSUFBdEIsR0FBNkIsUUFBeEUsQ0FBWjtBQUNIO0FBQ0o7QUFDRCxpQkFBSyxJQUFJaEYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJa00sTUFBTTdMLE1BQTFCLEVBQWtDTCxHQUFsQyxFQUF1QztBQUNuQ2dGLHVCQUFPNjZCLFFBQVEzekIsTUFBTWxNLENBQU4sQ0FBUixDQUFQO0FBQ0Esb0JBQUkycUMsU0FBU3orQixNQUFNLENBQU4sQ0FBVCxNQUF1QixPQUEzQixFQUFvQztBQUNoQ21OLDZCQUFTQSxPQUFPOUUsTUFBUCxDQUFjZzVCLGFBQWE7QUFDaENsa0MsNkJBQUtBLE1BQU0sR0FBTixHQUFZckosQ0FBWixHQUFnQixHQURXO0FBRWhDa00sK0JBQU9BLE1BQU1sTSxDQUFOLENBRnlCO0FBR2hDaXJDLG1DQUFXRyxVQUFVdjVCLGFBSFc7QUFJaEN2TiwrQkFBTzRSLFFBQVE1UixLQUppQjtBQUtoQzhtQyxtQ0FBV2wxQixRQUFRazFCO0FBTGEscUJBQWIsQ0FBZCxDQUFUO0FBT0gsaUJBUkQsTUFRTyxJQUFJcG1DLFNBQVMsUUFBVCxJQUFxQkEsU0FBUyxRQUE5QixJQUEwQ0EsU0FBUyxTQUF2RCxFQUFrRTtBQUNyRXFVLDJCQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQmpoQyxNQUFNLEdBQU4sR0FBWXJKLENBQVosR0FBZ0IsR0FBcEMsRUFBeUNrTSxNQUFNbE0sQ0FBTixDQUF6QyxFQUFtRCwwQ0FBMENnRixJQUExQyxHQUFpRCxRQUFwRyxDQUFaO0FBQ0g7QUFDSjtBQUNEO0FBQ0osYUFBSyxLQUFMO0FBQ0EsYUFBSyxLQUFMO0FBQ0EsYUFBSyxNQUFMO0FBQ0ksaUJBQUssSUFBSStlLE1BQU0sQ0FBZixFQUFrQkEsTUFBTTdYLE1BQU03TCxNQUE5QixFQUFzQzBqQixLQUF0QyxFQUE2QztBQUN6QzFLLHlCQUFTQSxPQUFPOUUsTUFBUCxDQUFjazVCLDRCQUE0QjtBQUMvQ3BrQyx5QkFBS0EsTUFBTSxHQUFOLEdBQVkwYSxHQUFaLEdBQWtCLEdBRHdCO0FBRS9DN1gsMkJBQU9BLE1BQU02WCxHQUFOLENBRndDO0FBRy9DemYsMkJBQU80UixRQUFRNVIsS0FIZ0M7QUFJL0M4bUMsK0JBQVdsMUIsUUFBUWsxQjtBQUo0QixpQkFBNUIsQ0FBZCxDQUFUO0FBTUg7QUFDRDtBQUNKLGFBQUssS0FBTDtBQUNBLGFBQUssTUFBTDtBQUNJcG1DLG1CQUFPNjZCLFFBQVEzekIsTUFBTSxDQUFOLENBQVIsQ0FBUDtBQUNBLGdCQUFJQSxNQUFNN0wsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUNwQmdaLHVCQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QjZDLEtBQXpCLEVBQWdDLHVCQUF1QkEsTUFBTSxDQUFOLENBQXZCLEdBQWtDLGlDQUFsRSxDQUFaO0FBQ0gsYUFGRCxNQUVPLElBQUlsSCxTQUFTLFFBQWIsRUFBdUI7QUFDMUJxVSx1QkFBT3JZLElBQVAsQ0FBWSxJQUFJc3BDLGVBQUosQ0FBb0JqaEMsTUFBTSxLQUExQixFQUFpQzZDLE1BQU0sQ0FBTixDQUFqQyxFQUEyQyxzQkFBc0JsSCxJQUF0QixHQUE2QixRQUF4RSxDQUFaO0FBQ0g7QUFDRDtBQXhESjtBQTBEQSxXQUFPcVUsTUFBUDtBQUNIOztBQUVELFNBQVNxMEIsZ0JBQVQsQ0FBMEJ4M0IsT0FBMUIsRUFBbUNvTyxZQUFuQyxFQUFpRDtBQUM3QyxRQUFJamIsTUFBTTZNLFFBQVE3TSxHQUFsQjtBQUNBLFFBQUkvRSxRQUFRNFIsUUFBUTVSLEtBQXBCO0FBQ0EsUUFBSThtQyxZQUFZbDFCLFFBQVFrMUIsU0FBeEI7QUFDQSxRQUFJbC9CLFFBQVFnSyxRQUFRaEssS0FBcEI7QUFDQSxRQUFJa2hDLGNBQWNsM0IsUUFBUW0xQixTQUExQjtBQUNBLFFBQUlzQyxZQUFZdkMsVUFBVTltQixlQUFlLEdBQWYsR0FBcUJwTyxRQUFRMDNCLFNBQXZDLENBQWhCO0FBQ0EsUUFBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQ1osZUFBTyxFQUFQO0FBQ0g7QUFDRCxRQUFJRSxrQkFBa0JULFlBQVkvcUMsS0FBWixDQUFrQixtQkFBbEIsQ0FBdEI7QUFDQSxRQUFJaWlCLGlCQUFpQixPQUFqQixJQUE0QnVwQixlQUE1QixJQUErQ0YsVUFBVUUsZ0JBQWdCLENBQWhCLENBQVYsQ0FBL0MsSUFBZ0ZGLFVBQVVFLGdCQUFnQixDQUFoQixDQUFWLEVBQThCamhDLFVBQWxILEVBQThIO0FBQzFILGVBQU82K0IsU0FBUztBQUNacGlDLGlCQUFLQSxHQURPO0FBRVo2QyxtQkFBT0EsS0FGSztBQUdaKytCLHVCQUFXRyxVQUFVeCtCLFVBSFQ7QUFJWnRJLG1CQUFPQSxLQUpLO0FBS1o4bUMsdUJBQVdBO0FBTEMsU0FBVCxDQUFQO0FBT0g7QUFDRCxRQUFJSCxZQUFZLzBCLFFBQVErMEIsU0FBUixJQUFxQjBDLFVBQVVQLFdBQVYsQ0FBckM7QUFDQSxRQUFJLENBQUNuQyxTQUFMLEVBQWdCO0FBQ1osZUFBTyxDQUFDLElBQUlYLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUI2QyxLQUF6QixFQUFnQyx1QkFBdUJraEMsV0FBdkIsR0FBcUMsR0FBckUsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxRQUFJVSxVQUFKO0FBQ0EsUUFBSWpPLFFBQVEzekIsS0FBUixNQUFtQixRQUFuQixJQUErQnV6QiwyQkFBMkJ3TCxTQUEzQixDQUEvQixJQUF3RSxDQUFDQSxVQUFVbjZCLE1BQW5GLEtBQThGZzlCLGFBQWEsY0FBYzdzQixJQUFkLENBQW1CL1UsS0FBbkIsQ0FBM0csQ0FBSixFQUEySTtBQUN2SSxlQUFPLENBQUMsSUFBSW8rQixlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0MsTUFBTWtoQyxXQUFOLEdBQW9CLDJDQUFwQixHQUFrRSxnRkFBbEUsR0FBcUp4cUMsS0FBS29ULFNBQUwsQ0FBZTgzQixXQUFXLENBQVgsQ0FBZixDQUFySixHQUFxTCxNQUFyTixDQUFELENBQVA7QUFDSDtBQUNELFFBQUl6MEIsU0FBUyxFQUFiO0FBQ0EsUUFBSW5ELFFBQVEwM0IsU0FBUixLQUFzQixRQUExQixFQUFvQztBQUNoQyxZQUFJUixnQkFBZ0IsWUFBaEIsSUFBZ0M5b0MsS0FBaEMsSUFBeUMsQ0FBQ0EsTUFBTXFJLE1BQXBELEVBQTREO0FBQ3hEME0sbUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0Msd0RBQWhDLENBQVo7QUFDSDtBQUNELFlBQUlraEMsZ0JBQWdCLFdBQWhCLElBQStCck4sYUFBYThLLGFBQWEzK0IsS0FBYixDQUFiLENBQS9CLElBQW9FeStCLFNBQVN6K0IsTUFBTWxILElBQWYsTUFBeUIsVUFBakcsRUFBNkc7QUFDekdxVSxtQkFBT3JZLElBQVAsQ0FBWSxJQUFJc3BDLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUI2QyxLQUF6QixFQUFnQyxpREFBaEMsQ0FBWjtBQUNIO0FBQ0o7QUFDRCxXQUFPbU4sT0FBTzlFLE1BQVAsQ0FBY2szQixTQUFTO0FBQzFCcGlDLGFBQUs2TSxRQUFRN00sR0FEYTtBQUUxQjZDLGVBQU9BLEtBRm1CO0FBRzFCKytCLG1CQUFXQSxTQUhlO0FBSTFCM21DLGVBQU9BLEtBSm1CO0FBSzFCOG1DLG1CQUFXQSxTQUxlO0FBTTFCOEIsMkJBQW1CLFVBTk87QUFPMUI1b0Isc0JBQWNBLFlBUFk7QUFRMUI4b0IscUJBQWFBO0FBUmEsS0FBVCxDQUFkLENBQVA7QUFVSDs7QUFFRCxTQUFTVyxxQkFBVCxDQUErQjczQixPQUEvQixFQUF3QztBQUNwQyxXQUFPdzNCLGlCQUFpQngzQixPQUFqQixFQUEwQixPQUExQixDQUFQO0FBQ0g7O0FBRUQsU0FBUzgzQixzQkFBVCxDQUFnQzkzQixPQUFoQyxFQUF5QztBQUNyQyxXQUFPdzNCLGlCQUFpQngzQixPQUFqQixFQUEwQixRQUExQixDQUFQO0FBQ0g7O0FBRUQsU0FBUyszQixhQUFULENBQXVCLzNCLE9BQXZCLEVBQWdDO0FBQzVCLFFBQUltRCxTQUFTLEVBQWI7QUFDQSxRQUFJelgsUUFBUXNVLFFBQVFoSyxLQUFwQjtBQUNBLFFBQUk3QyxNQUFNNk0sUUFBUTdNLEdBQWxCO0FBQ0EsUUFBSS9FLFFBQVE0UixRQUFRNVIsS0FBcEI7QUFDQSxRQUFJOG1DLFlBQVlsMUIsUUFBUWsxQixTQUF4QjtBQUNBLFFBQUksQ0FBQ3hwQyxNQUFNb0QsSUFBUCxJQUFlLENBQUNwRCxNQUFNc0UsR0FBMUIsRUFBK0I7QUFDM0JtVCxlQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QnpILEtBQXpCLEVBQWdDLG9DQUFoQyxDQUFaO0FBQ0g7QUFDRCxRQUFJb0QsT0FBTzJsQyxTQUFTL29DLE1BQU1vRCxJQUFmLENBQVg7QUFDQSxRQUFJa0IsTUFBTXlrQyxTQUFTL29DLE1BQU1zRSxHQUFmLENBQVY7QUFDQSxRQUFJdEUsTUFBTStDLEVBQVYsRUFBYztBQUNWLFlBQUkyRyxVQUFVcS9CLFNBQVMvb0MsTUFBTStDLEVBQWYsQ0FBZDtBQUNBLGFBQUssSUFBSTNFLElBQUksQ0FBYixFQUFnQkEsSUFBSWtXLFFBQVErMUIsVUFBNUIsRUFBd0Nqc0MsR0FBeEMsRUFBNkM7QUFDekMsZ0JBQUlrdUMsYUFBYTVwQyxNQUFNSSxNQUFOLENBQWExRSxDQUFiLENBQWpCO0FBQ0EsZ0JBQUkycUMsU0FBU3VELFdBQVd2cEMsRUFBcEIsTUFBNEIyRyxPQUFoQyxFQUF5QztBQUNyQytOLHVCQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QnpILE1BQU0rQyxFQUEvQixFQUFtQyx5QkFBeUIvQyxNQUFNK0MsRUFBL0IsR0FBb0MsNkJBQXBDLEdBQW9FdXBDLFdBQVd2cEMsRUFBWCxDQUFjNmxDLFFBQXJILENBQVo7QUFDSDtBQUNKO0FBQ0o7QUFDRCxRQUFJLFNBQVM1b0MsS0FBYixFQUFvQjtBQUNoQixTQUNJLE1BREosRUFFSSxRQUZKLEVBR0ksY0FISixFQUlJLFFBSkosRUFLSSxRQUxKLEVBTUUyaUIsT0FORixDQU1VLFVBQVV2QyxDQUFWLEVBQWE7QUFDbkIsZ0JBQUlBLEtBQUtwZ0IsS0FBVCxFQUFnQjtBQUNaeVgsdUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCekgsTUFBTW9nQixDQUFOLENBQXpCLEVBQW1DLE1BQU1BLENBQU4sR0FBVSxnQ0FBN0MsQ0FBWjtBQUNIO0FBQ0osU0FWRDtBQVdBLFlBQUlvRSxNQUFKO0FBQ0E5aEIsY0FBTUksTUFBTixDQUFhNmYsT0FBYixDQUFxQixVQUFVM2lCLEtBQVYsRUFBaUI7QUFDbEMsZ0JBQUkrb0MsU0FBUy9vQyxNQUFNK0MsRUFBZixNQUF1QnVCLEdBQTNCLEVBQWdDO0FBQzVCa2dCLHlCQUFTeGtCLEtBQVQ7QUFDSDtBQUNKLFNBSkQ7QUFLQSxZQUFJLENBQUN3a0IsTUFBTCxFQUFhO0FBQ1QvTSxtQkFBT3JZLElBQVAsQ0FBWSxJQUFJc3BDLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUJ6SCxNQUFNc0UsR0FBL0IsRUFBb0MsZ0JBQWdCQSxHQUFoQixHQUFzQixhQUExRCxDQUFaO0FBQ0gsU0FGRCxNQUVPLElBQUlrZ0IsT0FBT2xnQixHQUFYLEVBQWdCO0FBQ25CbVQsbUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCekgsTUFBTXNFLEdBQS9CLEVBQW9DLHdDQUFwQyxDQUFaO0FBQ0gsU0FGTSxNQUVBO0FBQ0hsQixtQkFBTzJsQyxTQUFTdmtCLE9BQU9waEIsSUFBaEIsQ0FBUDtBQUNIO0FBQ0osS0F6QkQsTUF5Qk8sSUFBSUEsU0FBUyxZQUFiLEVBQTJCO0FBQzlCLFlBQUksQ0FBQ3BELE1BQU1XLE1BQVgsRUFBbUI7QUFDZjhXLG1CQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QnpILEtBQXpCLEVBQWdDLG9DQUFoQyxDQUFaO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsZ0JBQUlXLFNBQVMrQixNQUFNeUQsT0FBTixJQUFpQnpELE1BQU15RCxPQUFOLENBQWNuRyxNQUFNVyxNQUFwQixDQUE5QjtBQUNBLGdCQUFJNHJDLGFBQWE1ckMsVUFBVW9vQyxTQUFTcG9DLE9BQU95QyxJQUFoQixDQUEzQjtBQUNBLGdCQUFJLENBQUN6QyxNQUFMLEVBQWE7QUFDVDhXLHVCQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QnpILE1BQU1XLE1BQS9CLEVBQXVDLGFBQWFYLE1BQU1XLE1BQW5CLEdBQTRCLGFBQW5FLENBQVo7QUFDSCxhQUZELE1BRU8sSUFBSTRyQyxlQUFlLFFBQWYsSUFBMkJucEMsU0FBUyxRQUF4QyxFQUFrRDtBQUNyRHFVLHVCQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QnpILE1BQU1XLE1BQS9CLEVBQXVDLFlBQVlYLE1BQU0rQyxFQUFsQixHQUF1Qiw0QkFBOUQsQ0FBWjtBQUNILGFBRk0sTUFFQSxJQUFJd3BDLGVBQWUsUUFBZixJQUEyQm5wQyxTQUFTLFFBQXhDLEVBQWtEO0FBQ3JEcVUsdUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCekgsTUFBTVcsTUFBL0IsRUFBdUMsWUFBWVgsTUFBTStDLEVBQWxCLEdBQXVCLDRCQUE5RCxDQUFaO0FBQ0gsYUFGTSxNQUVBLElBQUl3cEMsZUFBZSxRQUFmLElBQTJCLENBQUN2c0MsTUFBTSxjQUFOLENBQWhDLEVBQXVEO0FBQzFEeVgsdUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCekgsS0FBekIsRUFBZ0MsWUFBWUEsTUFBTStDLEVBQWxCLEdBQXVCLGlDQUF2RCxDQUFaO0FBQ0gsYUFGTSxNQUVBLElBQUl3cEMsZUFBZSxZQUFmLElBQStCbnBDLFNBQVMsV0FBNUMsRUFBeUQ7QUFDNURxVSx1QkFBT3JZLElBQVAsQ0FBWSxJQUFJc3BDLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUJ6SCxNQUFNVyxNQUEvQixFQUF1QyxtRUFBdkMsQ0FBWjtBQUNILGFBRk0sTUFFQSxJQUFJeUMsU0FBUyxNQUFULElBQW1CcEQsTUFBTXdELEtBQXpCLElBQWtDeEQsTUFBTXdELEtBQU4sQ0FBWSxlQUFaLENBQWxDLEtBQW1FK29DLGVBQWUsU0FBZixJQUE0QixDQUFDNXJDLE9BQU8rTCxXQUF2RyxDQUFKLEVBQXlIO0FBQzVIK0ssdUJBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCekgsS0FBekIsRUFBZ0MsWUFBWUEsTUFBTStDLEVBQWxCLEdBQXVCLDBGQUF2RCxDQUFaO0FBQ0g7QUFDSjtBQUNKO0FBQ0QwVSxhQUFTQSxPQUFPOUUsTUFBUCxDQUFjdzJCLGVBQWU7QUFDbEMxaEMsYUFBS0EsR0FENkI7QUFFbEM2QyxlQUFPdEssS0FGMkI7QUFHbENxcEMsbUJBQVdHLFVBQVV4cEMsS0FIYTtBQUlsQzBDLGVBQU80UixRQUFRNVIsS0FKbUI7QUFLbEM4bUMsbUJBQVdsMUIsUUFBUWsxQixTQUxlO0FBTWxDRCxpQ0FBeUI7QUFDckIsaUJBQUssU0FBUzNPLENBQVQsR0FBYTtBQUNkLHVCQUFPLEVBQVA7QUFDSCxhQUhvQjtBQUlyQngzQixrQkFBTSxTQUFTQSxJQUFULEdBQWdCO0FBQ2xCLHVCQUFPeW1DLFNBQVM7QUFDWnBpQyx5QkFBS0EsTUFBTSxPQURDO0FBRVo2QywyQkFBT3RLLE1BQU1vRCxJQUZEO0FBR1ppbUMsK0JBQVdHLFVBQVV4cEMsS0FBVixDQUFnQm9ELElBSGY7QUFJWlYsMkJBQU80UixRQUFRNVIsS0FKSDtBQUtaOG1DLCtCQUFXbDFCLFFBQVFrMUIsU0FMUDtBQU1acjRCLDRCQUFRblIsS0FOSTtBQU9aeXBDLCtCQUFXO0FBUEMsaUJBQVQsQ0FBUDtBQVNILGFBZG9CO0FBZXJCOTdCLG9CQUFRaStCLGNBZmE7QUFnQnJCM3JDLG9CQUFRLFNBQVNBLE1BQVQsQ0FBZ0JxVSxPQUFoQixFQUF5QjtBQUM3Qix1QkFBTzYwQixlQUFlO0FBQ2xCbnBDLDJCQUFPQSxLQURXO0FBRWxCeUgseUJBQUs2TSxRQUFRN00sR0FGSztBQUdsQjZDLDJCQUFPZ0ssUUFBUWhLLEtBSEc7QUFJbEI1SCwyQkFBTzRSLFFBQVE1UixLQUpHO0FBS2xCOG1DLCtCQUFXbDFCLFFBQVFrMUIsU0FMRDtBQU1sQkQsNkNBQXlCO0FBQ3JCLDZCQUFLLFNBQVMzTyxDQUFULENBQVd0bUIsT0FBWCxFQUFvQjtBQUNyQixtQ0FBTzgzQix1QkFBdUJyb0IsT0FBTyxFQUFFaW9CLFdBQVc1b0MsSUFBYixFQUFQLEVBQTRCa1IsT0FBNUIsQ0FBdkIsQ0FBUDtBQUNIO0FBSG9CO0FBTlAsaUJBQWYsQ0FBUDtBQVlILGFBN0JvQjtBQThCckI5USxtQkFBTyxTQUFTQSxLQUFULENBQWU4USxPQUFmLEVBQXdCO0FBQzNCLHVCQUFPNjBCLGVBQWU7QUFDbEJucEMsMkJBQU9BLEtBRFc7QUFFbEJ5SCx5QkFBSzZNLFFBQVE3TSxHQUZLO0FBR2xCNkMsMkJBQU9nSyxRQUFRaEssS0FIRztBQUlsQjVILDJCQUFPNFIsUUFBUTVSLEtBSkc7QUFLbEI4bUMsK0JBQVdsMUIsUUFBUWsxQixTQUxEO0FBTWxCRCw2Q0FBeUI7QUFDckIsNkJBQUssU0FBUzNPLENBQVQsQ0FBV3RtQixPQUFYLEVBQW9CO0FBQ3JCLG1DQUFPNjNCLHNCQUFzQnBvQixPQUFPLEVBQUVpb0IsV0FBVzVvQyxJQUFiLEVBQVAsRUFBNEJrUixPQUE1QixDQUF0QixDQUFQO0FBQ0g7QUFIb0I7QUFOUCxpQkFBZixDQUFQO0FBWUg7QUEzQ29CO0FBTlMsS0FBZixDQUFkLENBQVQ7QUFvREEsV0FBT21ELE1BQVA7QUFDSDs7QUFFRCxTQUFTKzBCLGNBQVQsQ0FBd0JsNEIsT0FBeEIsRUFBaUM7QUFDN0IsUUFBSWhLLFFBQVFnSyxRQUFRaEssS0FBcEI7QUFDQSxRQUFJN0MsTUFBTTZNLFFBQVE3TSxHQUFsQjtBQUNBLFFBQUlyRSxPQUFPNjZCLFFBQVEzekIsS0FBUixDQUFYO0FBQ0EsUUFBSWxILFNBQVMsUUFBYixFQUF1QjtBQUNuQixlQUFPLENBQUMsSUFBSXNsQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0Msc0JBQXNCbEgsSUFBdEIsR0FBNkIsUUFBN0QsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxXQUFPLEVBQVA7QUFDSDs7QUFFRCxJQUFJbW1DLDBCQUEwQixFQUFFOTlCLFdBQVdnaEMsaUJBQWIsRUFBOUI7QUFDQSxTQUFTQyxjQUFULENBQXdCcDRCLE9BQXhCLEVBQWlDO0FBQzdCLFFBQUloSyxRQUFRZ0ssUUFBUWhLLEtBQXBCO0FBQ0EsUUFBSTdDLE1BQU02TSxRQUFRN00sR0FBbEI7QUFDQSxRQUFJK2hDLFlBQVlsMUIsUUFBUWsxQixTQUF4QjtBQUNBLFFBQUk5bUMsUUFBUTRSLFFBQVE1UixLQUFwQjtBQUNBLFFBQUksQ0FBQzRILE1BQU1sSCxJQUFYLEVBQWlCO0FBQ2IsZUFBTyxDQUFDLElBQUlzbEMsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QjZDLEtBQXpCLEVBQWdDLG9CQUFoQyxDQUFELENBQVA7QUFDSDtBQUNELFFBQUlsSCxPQUFPMmxDLFNBQVN6K0IsTUFBTWxILElBQWYsQ0FBWDtBQUNBLFFBQUlxVSxNQUFKO0FBQ0EsWUFBUXJVLElBQVI7QUFDQSxhQUFLLFFBQUw7QUFDQSxhQUFLLFFBQUw7QUFDQSxhQUFLLFlBQUw7QUFDSXFVLHFCQUFTMHhCLGVBQWU7QUFDcEIxaEMscUJBQUtBLEdBRGU7QUFFcEI2Qyx1QkFBT0EsS0FGYTtBQUdwQisrQiwyQkFBV0csVUFBVSxZQUFZcG1DLEtBQUtuRSxPQUFMLENBQWEsR0FBYixFQUFrQixHQUFsQixDQUF0QixDQUhTO0FBSXBCeUQsdUJBQU80UixRQUFRNVIsS0FKSztBQUtwQjhtQywyQkFBV0EsU0FMUztBQU1wQkQseUNBQXlCQTtBQU5MLGFBQWYsQ0FBVDtBQVFBLG1CQUFPOXhCLE1BQVA7QUFDSixhQUFLLFNBQUw7QUFDSUEscUJBQVMweEIsZUFBZTtBQUNwQjFoQyxxQkFBS0EsR0FEZTtBQUVwQjZDLHVCQUFPQSxLQUZhO0FBR3BCKytCLDJCQUFXRyxVQUFVeDlCLGNBSEQ7QUFJcEJ0Six1QkFBT0EsS0FKYTtBQUtwQjhtQywyQkFBV0EsU0FMUztBQU1wQkQseUNBQXlCQTtBQU5MLGFBQWYsQ0FBVDtBQVFBLGdCQUFJai9CLE1BQU1nQyxPQUFWLEVBQW1CO0FBQ2YscUJBQUssSUFBSThPLElBQVQsSUFBaUI5USxNQUFNbUMsaUJBQXZCLEVBQTBDO0FBQ3RDLHdCQUFJbkksTUFBTWdHLE1BQU1tQyxpQkFBTixDQUF3QjJPLElBQXhCLENBQVY7QUFDQSx3QkFBSThjLFdBQVc1ekIsSUFBSSxDQUFKLENBQWY7QUFDQSx3QkFBSXFvQyxVQUFVcm9DLElBQUksQ0FBSixDQUFkO0FBQ0Esd0JBQUlzb0MsYUFBYSxPQUFPMVUsUUFBUCxLQUFvQixRQUFwQixHQUErQixDQUM1Q0EsUUFENEMsRUFFNUMsQ0FBQyxhQUFELENBRjRDLEVBRzVDLENBQ0ksS0FESixFQUVJOWMsSUFGSixDQUg0QyxDQUEvQixHQU9iOGMsUUFQSjtBQVFBemdCLDJCQUFPclksSUFBUCxDQUFZdEIsS0FBWixDQUFrQjJaLE1BQWxCLEVBQTBCNHpCLG1CQUFtQjtBQUN6QzVqQyw2QkFBS0EsTUFBTSxHQUFOLEdBQVkyVCxJQUFaLEdBQW1CLE1BRGlCO0FBRXpDOVEsK0JBQU9xaUMsT0FGa0M7QUFHekNyQiwyQ0FBbUI7QUFIc0IscUJBQW5CLENBQTFCO0FBS0E3ekIsMkJBQU9yWSxJQUFQLENBQVl0QixLQUFaLENBQWtCMlosTUFBbEIsRUFBMEI0ekIsbUJBQW1CO0FBQ3pDNWpDLDZCQUFLQSxNQUFNLEdBQU4sR0FBWTJULElBQVosR0FBbUIsU0FEaUI7QUFFekM5USwrQkFBT3NpQyxVQUZrQztBQUd6Q3RCLDJDQUFtQjtBQUhzQixxQkFBbkIsQ0FBMUI7QUFLSDtBQUNKO0FBQ0QsbUJBQU83ekIsTUFBUDtBQUNKLGFBQUssT0FBTDtBQUNJLG1CQUFPMHhCLGVBQWU7QUFDbEIxaEMscUJBQUtBLEdBRGE7QUFFbEI2Qyx1QkFBT0EsS0FGVztBQUdsQisrQiwyQkFBV0csVUFBVTU4QixZQUhIO0FBSWxCbEssdUJBQU9BLEtBSlc7QUFLbEI4bUMsMkJBQVdBO0FBTE8sYUFBZixDQUFQO0FBT0osYUFBSyxPQUFMO0FBQ0ksbUJBQU9MLGVBQWU7QUFDbEIxaEMscUJBQUtBLEdBRGE7QUFFbEI2Qyx1QkFBT0EsS0FGVztBQUdsQisrQiwyQkFBV0csVUFBVXo4QixZQUhIO0FBSWxCckssdUJBQU9BLEtBSlc7QUFLbEI4bUMsMkJBQVdBO0FBTE8sYUFBZixDQUFQO0FBT0osYUFBSyxRQUFMO0FBQ0ksbUJBQU8sQ0FBQyxJQUFJZCxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCLElBQXpCLEVBQStCLDJGQUEvQixFQUE0SCxlQUE1SCxDQUFELENBQVA7QUFDSjtBQUNJLG1CQUFPa2tDLGFBQWE7QUFDaEJsa0MscUJBQUtBLE1BQU0sT0FESztBQUVoQjZDLHVCQUFPQSxNQUFNbEgsSUFGRztBQUdoQmltQywyQkFBVztBQUNQcC9CLDRCQUFRLENBQ0osUUFESSxFQUVKLFFBRkksRUFHSixZQUhJLEVBSUosU0FKSSxFQUtKLE9BTEksRUFNSixPQU5JO0FBREQsaUJBSEs7QUFhaEJ2SCx1QkFBT0EsS0FiUztBQWNoQjhtQywyQkFBV0E7QUFkSyxhQUFiLENBQVA7QUFuRUo7QUFvRkg7QUFDRCxTQUFTaUQsaUJBQVQsQ0FBMkJub0MsR0FBM0IsRUFBZ0M7QUFDNUIsUUFBSW1ELE1BQU1uRCxJQUFJbUQsR0FBZDtBQUNBLFFBQUk2QyxRQUFRaEcsSUFBSWdHLEtBQWhCO0FBQ0EsUUFBSTJ6QixRQUFRM3pCLEtBQVIsTUFBbUIsUUFBdkIsRUFBaUM7QUFDN0IsZUFBT2tpQyxlQUFlO0FBQ2xCL2tDLGlCQUFLQSxHQURhO0FBRWxCNkMsbUJBQU9BO0FBRlcsU0FBZixDQUFQO0FBSUgsS0FMRCxNQUtPO0FBQ0gsWUFBSW1OLFNBQVMsRUFBYjtBQUNBLGFBQUssSUFBSTJELElBQVQsSUFBaUI5USxLQUFqQixFQUF3QjtBQUNwQm1OLG1CQUFPclksSUFBUCxDQUFZdEIsS0FBWixDQUFrQjJaLE1BQWxCLEVBQTBCKzBCLGVBQWU7QUFDckMva0MscUJBQUtBLE1BQU0sR0FBTixHQUFZMlQsSUFEb0I7QUFFckM5USx1QkFBT0EsTUFBTThRLElBQU47QUFGOEIsYUFBZixDQUExQjtBQUlIO0FBQ0QsZUFBTzNELE1BQVA7QUFDSDtBQUNKOztBQUVELFNBQVNvMUIsYUFBVCxDQUF1QnY0QixPQUF2QixFQUFnQztBQUM1QixRQUFJM0osUUFBUTJKLFFBQVFoSyxLQUFwQjtBQUNBLFFBQUlrL0IsWUFBWWwxQixRQUFRazFCLFNBQXhCO0FBQ0EsUUFBSXNELFlBQVl0RCxVQUFVNytCLEtBQTFCO0FBQ0EsUUFBSWpJLFFBQVE0UixRQUFRNVIsS0FBcEI7QUFDQSxRQUFJK1UsU0FBUyxFQUFiO0FBQ0EsUUFBSXMxQixXQUFXOU8sUUFBUXR6QixLQUFSLENBQWY7QUFDQSxRQUFJQSxVQUFVdkksU0FBZCxFQUF5QjtBQUNyQixlQUFPcVYsTUFBUDtBQUNILEtBRkQsTUFFTyxJQUFJczFCLGFBQWEsUUFBakIsRUFBMkI7QUFDOUJ0MUIsaUJBQVNBLE9BQU85RSxNQUFQLENBQWMsQ0FBQyxJQUFJKzFCLGVBQUosQ0FBb0IsT0FBcEIsRUFBNkIvOUIsS0FBN0IsRUFBb0Msc0JBQXNCb2lDLFFBQXRCLEdBQWlDLFFBQXJFLENBQUQsQ0FBZCxDQUFUO0FBQ0EsZUFBT3QxQixNQUFQO0FBQ0g7QUFDRCxTQUFLLElBQUloUSxHQUFULElBQWdCa0QsS0FBaEIsRUFBdUI7QUFDbkIsWUFBSXNoQyxrQkFBa0J4a0MsSUFBSWhILEtBQUosQ0FBVSxtQkFBVixDQUF0QjtBQUNBLFlBQUl3ckMsbUJBQW1CYSxVQUFVYixnQkFBZ0IsQ0FBaEIsQ0FBVixDQUFuQixJQUFvRGEsVUFBVWIsZ0JBQWdCLENBQWhCLENBQVYsRUFBOEJqaEMsVUFBdEYsRUFBa0c7QUFDOUZ5TSxxQkFBU0EsT0FBTzlFLE1BQVAsQ0FBY2szQixTQUFTO0FBQzVCcGlDLHFCQUFLQSxHQUR1QjtBQUU1QjZDLHVCQUFPSyxNQUFNbEQsR0FBTixDQUZxQjtBQUc1QjRoQywyQkFBV0csVUFBVXgrQixVQUhPO0FBSTVCdEksdUJBQU9BLEtBSnFCO0FBSzVCOG1DLDJCQUFXQTtBQUxpQixhQUFULENBQWQsQ0FBVDtBQU9ILFNBUkQsTUFRTyxJQUFJc0QsVUFBVXJsQyxHQUFWLENBQUosRUFBb0I7QUFDdkJnUSxxQkFBU0EsT0FBTzlFLE1BQVAsQ0FBY2szQixTQUFTO0FBQzVCcGlDLHFCQUFLQSxHQUR1QjtBQUU1QjZDLHVCQUFPSyxNQUFNbEQsR0FBTixDQUZxQjtBQUc1QjRoQywyQkFBV3lELFVBQVVybEMsR0FBVixDQUhpQjtBQUk1Qi9FLHVCQUFPQSxLQUpxQjtBQUs1QjhtQywyQkFBV0E7QUFMaUIsYUFBVCxDQUFkLENBQVQ7QUFPSCxTQVJNLE1BUUE7QUFDSC94QixxQkFBU0EsT0FBTzlFLE1BQVAsQ0FBYyxDQUFDLElBQUkrMUIsZUFBSixDQUFvQmpoQyxHQUFwQixFQUF5QmtELE1BQU1sRCxHQUFOLENBQXpCLEVBQXFDLHVCQUF1QkEsR0FBdkIsR0FBNkIsR0FBbEUsQ0FBRCxDQUFkLENBQVQ7QUFDSDtBQUNKO0FBQ0QsV0FBT2dRLE1BQVA7QUFDSDs7QUFFRCxTQUFTdTFCLGlCQUFULENBQTJCMTRCLE9BQTNCLEVBQW9DO0FBQ2hDLFFBQUlrNEIsZUFBZWw0QixPQUFmLEVBQXdCN1YsTUFBeEIsS0FBbUMsQ0FBdkMsRUFBMEM7QUFDdEMsZUFBTyxFQUFQO0FBQ0g7QUFDRCxXQUFPNHNDLG1CQUFtQi8yQixPQUFuQixDQUFQO0FBQ0g7O0FBRUQsU0FBUzI0QixhQUFULENBQXVCMzRCLE9BQXZCLEVBQWdDO0FBQzVCLFFBQUlrNEIsZUFBZWw0QixPQUFmLEVBQXdCN1YsTUFBeEIsS0FBbUMsQ0FBdkMsRUFBMEM7QUFDdEMsZUFBTyxFQUFQO0FBQ0g7QUFDRCxXQUFPNHNDLG1CQUFtQi8yQixPQUFuQixDQUFQO0FBQ0g7O0FBRUQsSUFBSTQ0QixhQUFhO0FBQ2IsU0FBSyxTQUFTdFMsQ0FBVCxHQUFhO0FBQ2QsZUFBTyxFQUFQO0FBQ0gsS0FIWTtBQUliLGFBQVNtUCxhQUpJO0FBS2IsZUFBVzBCLGVBTEU7QUFNYixjQUFVbkIsY0FORztBQU9iLGFBQVNvQixhQVBJO0FBUWIsaUJBQWE1QyxpQkFSQTtBQVNiLFlBQVE2QyxZQVRLO0FBVWIsY0FBVUMsY0FWRztBQVdiLGdCQUFZckIsZ0JBWEM7QUFZYixhQUFTOEIsYUFaSTtBQWFiLGNBQVVsRCxjQWJHO0FBY2IsY0FBVXVELGNBZEc7QUFlYixhQUFTRyxhQWZJO0FBZ0JiLGNBQVVMLGNBaEJHO0FBaUJiLGlCQUFhUSxpQkFqQkE7QUFrQmIscUJBQWlCQztBQWxCSixDQUFqQjtBQW9CQSxTQUFTcEQsUUFBVCxDQUFrQnYxQixPQUFsQixFQUEyQjtBQUN2QixRQUFJaEssUUFBUWdLLFFBQVFoSyxLQUFwQjtBQUNBLFFBQUkrK0IsWUFBWS8wQixRQUFRKzBCLFNBQXhCO0FBQ0EsUUFBSUcsWUFBWWwxQixRQUFRazFCLFNBQXhCO0FBQ0EsUUFBSUgsVUFBVXQ3QixVQUFWLElBQXdCb3dCLGFBQWE0SyxTQUFTeitCLEtBQVQsQ0FBYixDQUE1QixFQUEyRDtBQUN2RCxlQUFPaWdDLGlCQUFpQmoyQixPQUFqQixDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUkrMEIsVUFBVXQ3QixVQUFWLElBQXdCeXlCLGFBQWF5SSxhQUFhMytCLEtBQWIsQ0FBYixDQUE1QixFQUErRDtBQUNsRSxlQUFPK2dDLG1CQUFtQi8yQixPQUFuQixDQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUkrMEIsVUFBVWptQyxJQUFWLElBQWtCOHBDLFdBQVc3RCxVQUFVam1DLElBQXJCLENBQXRCLEVBQWtEO0FBQ3JELGVBQU84cEMsV0FBVzdELFVBQVVqbUMsSUFBckIsRUFBMkJrUixPQUEzQixDQUFQO0FBQ0gsS0FGTSxNQUVBO0FBQ0gsWUFBSTY0QixRQUFRaEUsZUFBZXBsQixPQUFPLEVBQVAsRUFBV3pQLE9BQVgsRUFBb0IsRUFBRSswQixXQUFXQSxVQUFVam1DLElBQVYsR0FBaUJvbUMsVUFBVUgsVUFBVWptQyxJQUFwQixDQUFqQixHQUE2Q2ltQyxTQUExRCxFQUFwQixDQUFmLENBQVo7QUFDQSxlQUFPOEQsS0FBUDtBQUNIO0FBQ0o7O0FBRUQsU0FBU0MsaUJBQVQsQ0FBNEI5NEIsT0FBNUIsRUFBcUM7QUFDakMsUUFBSWhLLFFBQVFnSyxRQUFRaEssS0FBcEI7QUFDQSxRQUFJN0MsTUFBTTZNLFFBQVE3TSxHQUFsQjtBQUNBLFFBQUlnUSxTQUFTKzBCLGVBQWVsNEIsT0FBZixDQUFiO0FBQ0EsUUFBSW1ELE9BQU9oWixNQUFYLEVBQW1CO0FBQ2YsZUFBT2daLE1BQVA7QUFDSDtBQUNELFFBQUluTixNQUFNbkwsT0FBTixDQUFjLGFBQWQsTUFBaUMsQ0FBQyxDQUF0QyxFQUF5QztBQUNyQ3NZLGVBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CamhDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0MsaURBQWhDLENBQVo7QUFDSDtBQUNELFFBQUlBLE1BQU1uTCxPQUFOLENBQWMsU0FBZCxNQUE2QixDQUFDLENBQWxDLEVBQXFDO0FBQ2pDc1ksZUFBT3JZLElBQVAsQ0FBWSxJQUFJc3BDLGVBQUosQ0FBb0JqaEMsR0FBcEIsRUFBeUI2QyxLQUF6QixFQUFnQyw2Q0FBaEMsQ0FBWjtBQUNIO0FBQ0QsV0FBT21OLE1BQVA7QUFDSDs7QUFFRCxTQUFTNDFCLGdCQUFULENBQTBCM3FDLEtBQTFCLEVBQWlDOG1DLFNBQWpDLEVBQTRDO0FBQ3hDLFFBQUlBLGNBQWMsS0FBSyxDQUF2QixFQUNJQSxZQUFZajJCLEVBQVo7QUFDSixRQUFJa0UsU0FBUyxFQUFiO0FBQ0FBLGFBQVNBLE9BQU85RSxNQUFQLENBQWNrM0IsU0FBUztBQUM1QnBpQyxhQUFLLEVBRHVCO0FBRTVCNkMsZUFBTzVILEtBRnFCO0FBRzVCMm1DLG1CQUFXRyxVQUFVei9CLEtBSE87QUFJNUJ5L0IsbUJBQVdBLFNBSmlCO0FBSzVCOW1DLGVBQU9BLEtBTHFCO0FBTTVCNm1DLGlDQUF5QjtBQUNyQngrQixvQkFBUXFpQyxpQkFEYTtBQUVyQixpQkFBSyxTQUFTeFMsQ0FBVCxHQUFhO0FBQ2QsdUJBQU8sRUFBUDtBQUNIO0FBSm9CO0FBTkcsS0FBVCxDQUFkLENBQVQ7QUFhQSxRQUFJbDRCLE1BQU1xZ0IsU0FBVixFQUFxQjtBQUNqQnRMLGlCQUFTQSxPQUFPOUUsTUFBUCxDQUFjbTJCLGtCQUFrQjtBQUNyQ3JoQyxpQkFBSyxXQURnQztBQUVyQzZDLG1CQUFPNUgsTUFBTXFnQixTQUZ3QjtBQUdyQ3JnQixtQkFBT0EsS0FIOEI7QUFJckM4bUMsdUJBQVdBO0FBSjBCLFNBQWxCLENBQWQsQ0FBVDtBQU1IO0FBQ0QsV0FBTzhELFdBQVc3MUIsTUFBWCxDQUFQO0FBQ0g7QUFDRDQxQixpQkFBaUIxc0MsTUFBakIsR0FBMEI0c0MsZ0JBQWdCYixjQUFoQixDQUExQjtBQUNBVyxpQkFBaUIxaUMsS0FBakIsR0FBeUI0aUMsZ0JBQWdCVixhQUFoQixDQUF6QjtBQUNBUSxpQkFBaUJydEMsS0FBakIsR0FBeUJ1dEMsZ0JBQWdCbEIsYUFBaEIsQ0FBekI7QUFDQWdCLGlCQUFpQjEvQixNQUFqQixHQUEwQjQvQixnQkFBZ0IzQixjQUFoQixDQUExQjtBQUNBeUIsaUJBQWlCRyxhQUFqQixHQUFpQ0QsZ0JBQWdCcEIscUJBQWhCLENBQWpDO0FBQ0FrQixpQkFBaUJJLGNBQWpCLEdBQWtDRixnQkFBZ0JuQixzQkFBaEIsQ0FBbEM7QUFDQSxTQUFTa0IsVUFBVCxDQUFvQjcxQixNQUFwQixFQUE0QjtBQUN4QixXQUFPLEdBQUc5RSxNQUFILENBQVU4RSxNQUFWLEVBQWtCMmlCLElBQWxCLENBQXVCLFVBQVUvd0IsQ0FBVixFQUFha2UsQ0FBYixFQUFnQjtBQUMxQyxlQUFPbGUsRUFBRWlFLElBQUYsR0FBU2lhLEVBQUVqYSxJQUFsQjtBQUNILEtBRk0sQ0FBUDtBQUdIO0FBQ0QsU0FBU2lnQyxlQUFULENBQXlCOXFCLEtBQXpCLEVBQWdDO0FBQzVCLFdBQU8sWUFBWTtBQUNmLFlBQUl1SCxPQUFPLEVBQVg7QUFBQSxZQUFlcE8sTUFBTXFJLFVBQVV4bEIsTUFBL0I7QUFDQSxlQUFPbWQsS0FBUDtBQUNJb08saUJBQUtwTyxHQUFMLElBQVlxSSxVQUFVckksR0FBVixDQUFaO0FBREosU0FFQSxPQUFPMHhCLFdBQVc3cUIsTUFBTTNrQixLQUFOLENBQVksSUFBWixFQUFrQmtzQixJQUFsQixDQUFYLENBQVA7QUFDSCxLQUxEO0FBTUg7O0FBRUQsSUFBSTBqQixXQUFXdDNCLHFCQUFxQixVQUFVRSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjtBQUMvRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3RUEsUUFBSW1xQixTQUFVLFlBQVU7QUFDeEIsWUFBSWlOLElBQUUsV0FBU3owQixDQUFULEVBQVcrQyxDQUFYLEVBQWEweEIsRUFBYixFQUFldnBDLENBQWYsRUFBaUI7QUFBQyxpQkFBSXVwQyxLQUFFQSxNQUFHLEVBQUwsRUFBUXZwQyxJQUFFOFUsRUFBRXphLE1BQWhCLEVBQXVCMkYsR0FBdkIsRUFBMkJ1cEMsR0FBRXowQixFQUFFOVUsQ0FBRixDQUFGLElBQVE2WCxDQUFuQyxFQUFxQyxDQUFHLFFBQU8weEIsRUFBUDtBQUFTLFNBQXpFO0FBQUEsWUFBMEVDLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUE5RTtBQUFBLFlBQXFGQyxNQUFJLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBekY7QUFBQSxZQUFnR0MsTUFBSSxDQUFDLENBQUQsRUFBRyxDQUFILENBQXBHO0FBQUEsWUFBMEdDLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUE5RztBQUFBLFlBQXFIQyxNQUFJLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBekg7QUFBQSxZQUFnSUMsTUFBSSxDQUFDLENBQUQsRUFBRyxFQUFILENBQXBJO0FBQUEsWUFBMklDLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUEvSTtBQUFBLFlBQXNKQyxNQUFJLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLEVBQVUsRUFBVixDQUExSjtBQUFBLFlBQXdLQyxNQUFJLENBQUMsRUFBRCxFQUFJLEVBQUosQ0FBNUs7QUFBQSxZQUFvTEMsTUFBSSxDQUFDLEVBQUQsRUFBSSxFQUFKLENBQXhMO0FBQ0EsWUFBSTNOLFNBQVMsRUFBQzROLE9BQU8sU0FBU0EsS0FBVCxHQUFpQixDQUFHLENBQTVCO0FBQ2JDLGdCQUFJLEVBRFM7QUFFYkMsc0JBQVUsRUFBQyxTQUFRLENBQVQsRUFBVyxjQUFhLENBQXhCLEVBQTBCLFVBQVMsQ0FBbkMsRUFBcUMsY0FBYSxDQUFsRCxFQUFvRCxVQUFTLENBQTdELEVBQStELG1CQUFrQixDQUFqRixFQUFtRixRQUFPLENBQTFGLEVBQTRGLHNCQUFxQixDQUFqSCxFQUFtSCxRQUFPLEVBQTFILEVBQTZILFNBQVEsRUFBckksRUFBd0ksWUFBVyxFQUFuSixFQUFzSixhQUFZLEVBQWxLLEVBQXFLLE9BQU0sRUFBM0ssRUFBOEssY0FBYSxFQUEzTCxFQUE4TCxhQUFZLEVBQTFNLEVBQTZNLEtBQUksRUFBak4sRUFBb04sS0FBSSxFQUF4TixFQUEyTixrQkFBaUIsRUFBNU8sRUFBK08sY0FBYSxFQUE1UCxFQUErUCxLQUFJLEVBQW5RLEVBQXNRLEtBQUksRUFBMVEsRUFBNlEsS0FBSSxFQUFqUixFQUFvUixLQUFJLEVBQXhSLEVBQTJSLG1CQUFrQixFQUE3UyxFQUFnVCxXQUFVLENBQTFULEVBQTRULFFBQU8sQ0FBblUsRUFGRztBQUdiQyx3QkFBWSxFQUFDLEdBQUUsT0FBSCxFQUFXLEdBQUUsUUFBYixFQUFzQixHQUFFLFFBQXhCLEVBQWlDLEdBQUUsTUFBbkMsRUFBMEMsSUFBRyxNQUE3QyxFQUFvRCxJQUFHLE9BQXZELEVBQStELElBQUcsS0FBbEUsRUFBd0UsSUFBRyxHQUEzRSxFQUErRSxJQUFHLEdBQWxGLEVBQXNGLElBQUcsR0FBekYsRUFBNkYsSUFBRyxHQUFoRyxFQUFvRyxJQUFHLEdBQXZHLEVBQTJHLElBQUcsR0FBOUcsRUFIQztBQUliQywwQkFBYyxDQUFDLENBQUQsRUFBRyxDQUFDLENBQUQsRUFBRyxDQUFILENBQUgsRUFBUyxDQUFDLENBQUQsRUFBRyxDQUFILENBQVQsRUFBZSxDQUFDLENBQUQsRUFBRyxDQUFILENBQWYsRUFBcUIsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFyQixFQUEyQixDQUFDLENBQUQsRUFBRyxDQUFILENBQTNCLEVBQWlDLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBakMsRUFBd0MsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUF4QyxFQUErQyxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQS9DLEVBQXNELENBQUMsRUFBRCxFQUFJLENBQUosQ0FBdEQsRUFBNkQsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUE3RCxFQUFvRSxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQXBFLEVBQTJFLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBM0UsRUFBa0YsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUFsRixFQUF5RixDQUFDLEVBQUQsRUFBSSxDQUFKLENBQXpGLEVBQWdHLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBaEcsRUFBdUcsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUF2RyxFQUE4RyxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQTlHLEVBQXFILENBQUMsRUFBRCxFQUFJLENBQUosQ0FBckgsRUFBNEgsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUE1SCxFQUFtSSxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQW5JLEVBQTBJLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBMUksQ0FKRDtBQUtiQywyQkFBZSxTQUFTQyxTQUFULENBQW1CQyxNQUFuQixFQUEyQkMsTUFBM0IsRUFBbUNDLFFBQW5DLEVBQTZDUixFQUE3QyxFQUFpRFMsT0FBakQsQ0FBeUQsZUFBekQsRUFBMEVDLEVBQTFFLENBQTZFLFlBQTdFLEVBQTJGQyxFQUEzRixDQUE4RixZQUE5RixFQUE0RztBQUMzSDs7QUFFQSxvQkFBSUMsS0FBS0YsR0FBR3h3QyxNQUFILEdBQVksQ0FBckI7QUFDQSx3QkFBUXV3QyxPQUFSO0FBQ0EseUJBQUssQ0FBTDtBQUNDO0FBQ1MsNkJBQUtJLENBQUwsR0FBUyxJQUFJdjNCLE1BQUosQ0FBV2czQixPQUFPNXZDLE9BQVAsQ0FBZSxXQUFmLEVBQTRCLE1BQUksR0FBaEMsRUFDUkEsT0FEUSxDQUNBLE1BREEsRUFDTyxJQURQLEVBRVJBLE9BRlEsQ0FFQSxNQUZBLEVBRU8sSUFGUCxFQUdSQSxPQUhRLENBR0EsTUFIQSxFQUdPLElBSFAsRUFJUkEsT0FKUSxDQUlBLE1BSkEsRUFJTyxJQUpQLEVBS1JBLE9BTFEsQ0FLQSxNQUxBLEVBS08sSUFMUCxFQU1SQSxPQU5RLENBTUEsTUFOQSxFQU1PLElBTlAsQ0FBWCxDQUFUO0FBT0EsNkJBQUttd0MsQ0FBTCxDQUFPeEcsUUFBUCxHQUFtQixLQUFLc0csRUFBTCxDQUFRRyxVQUEzQjs7QUFFVjtBQUNBLHlCQUFLLENBQUw7O0FBRVksNkJBQUtELENBQUwsR0FBUyxJQUFJcmpCLE1BQUosQ0FBVzhpQixNQUFYLENBQVQ7QUFDQSw2QkFBS08sQ0FBTCxDQUFPeEcsUUFBUCxHQUFtQixLQUFLc0csRUFBTCxDQUFRRyxVQUEzQjs7QUFFWjtBQUNBLHlCQUFLLENBQUw7O0FBRVksNkJBQUtELENBQUwsR0FBUyxJQUFUOztBQUVaO0FBQ0EseUJBQUssQ0FBTDs7QUFFWSw2QkFBS0EsQ0FBTCxHQUFTLElBQUkzakIsT0FBSixDQUFZLElBQVosQ0FBVDtBQUNBLDZCQUFLMmpCLENBQUwsQ0FBT3hHLFFBQVAsR0FBa0IsS0FBS3NHLEVBQUwsQ0FBUUcsVUFBMUI7O0FBRVo7QUFDQSx5QkFBSyxDQUFMOztBQUVZLDZCQUFLRCxDQUFMLEdBQVMsSUFBSTNqQixPQUFKLENBQVksS0FBWixDQUFUO0FBQ0EsNkJBQUsyakIsQ0FBTCxDQUFPeEcsUUFBUCxHQUFrQixLQUFLc0csRUFBTCxDQUFRRyxVQUExQjs7QUFFWjtBQUNBLHlCQUFLLENBQUw7QUFDQSwrQkFBTyxLQUFLRCxDQUFMLEdBQVNILEdBQUdFLEtBQUcsQ0FBTixDQUFoQjtBQUNBLHlCQUFLLEVBQUw7QUFDQSw2QkFBS0MsQ0FBTCxHQUFTLEVBQVQsQ0FBYTM1QixPQUFPNjVCLGNBQVAsQ0FBc0IsS0FBS0YsQ0FBM0IsRUFBOEIsVUFBOUIsRUFBMEM7QUFDM0M5a0MsbUNBQU8sS0FBSzRrQyxFQUFMLENBQVFHLFVBRDRCO0FBRTNDRSx3Q0FBWTtBQUYrQix5QkFBMUM7QUFJYjtBQUNBLHlCQUFLLEVBQUwsQ0FBUyxLQUFLLEVBQUw7QUFDVCw2QkFBS0gsQ0FBTCxHQUFTSCxHQUFHRSxLQUFHLENBQU4sQ0FBVCxDQUFtQjE1QixPQUFPNjVCLGNBQVAsQ0FBc0IsS0FBS0YsQ0FBM0IsRUFBOEIsVUFBOUIsRUFBMEM7QUFDakQ5a0MsbUNBQU8sS0FBSzRrQyxFQUFMLENBQVFHLFVBRGtDO0FBRWpERSx3Q0FBWTtBQUZxQyx5QkFBMUM7QUFJbkI7QUFDQSx5QkFBSyxFQUFMO0FBQ0EsNkJBQUtILENBQUwsR0FBUyxDQUFDSCxHQUFHRSxLQUFHLENBQU4sQ0FBRCxFQUFXRixHQUFHRSxFQUFILENBQVgsQ0FBVDtBQUNBO0FBQ0EseUJBQUssRUFBTDtBQUNBLDZCQUFLQyxDQUFMLEdBQVMsRUFBVCxDQUFhLEtBQUtBLENBQUwsQ0FBT0gsR0FBR0UsRUFBSCxFQUFPLENBQVAsQ0FBUCxJQUFvQkYsR0FBR0UsRUFBSCxFQUFPLENBQVAsQ0FBcEI7QUFDYjtBQUNBLHlCQUFLLEVBQUw7QUFDQSw2QkFBS0MsQ0FBTCxHQUFTSCxHQUFHRSxLQUFHLENBQU4sQ0FBVCxDQUFtQkYsR0FBR0UsS0FBRyxDQUFOLEVBQVNGLEdBQUdFLEVBQUgsRUFBTyxDQUFQLENBQVQsSUFBc0JGLEdBQUdFLEVBQUgsRUFBTyxDQUFQLENBQXRCO0FBQ25CO0FBQ0EseUJBQUssRUFBTDtBQUNBLDZCQUFLQyxDQUFMLEdBQVMsRUFBVCxDQUFhMzVCLE9BQU82NUIsY0FBUCxDQUFzQixLQUFLRixDQUEzQixFQUE4QixVQUE5QixFQUEwQztBQUMzQzlrQyxtQ0FBTyxLQUFLNGtDLEVBQUwsQ0FBUUcsVUFENEI7QUFFM0NFLHdDQUFZO0FBRitCLHlCQUExQztBQUliO0FBQ0EseUJBQUssRUFBTDtBQUNBLDZCQUFLSCxDQUFMLEdBQVMsQ0FBQ0gsR0FBR0UsRUFBSCxDQUFELENBQVQ7QUFDQTtBQUNBLHlCQUFLLEVBQUw7QUFDQSw2QkFBS0MsQ0FBTCxHQUFTSCxHQUFHRSxLQUFHLENBQU4sQ0FBVCxDQUFtQkYsR0FBR0UsS0FBRyxDQUFOLEVBQVMvdkMsSUFBVCxDQUFjNnZDLEdBQUdFLEVBQUgsQ0FBZDtBQUNuQjtBQXRFQTtBQXdFQyxhQWpGWTtBQWtGYkssbUJBQU8sQ0FBQyxFQUFDLEdBQUUsQ0FBSCxFQUFLLEdBQUU1QixHQUFQLEVBQVcsR0FBRSxDQUFiLEVBQWUsR0FBRUMsR0FBakIsRUFBcUIsR0FBRSxDQUF2QixFQUF5QixHQUFFQyxHQUEzQixFQUErQixHQUFFLENBQWpDLEVBQW1DLElBQUdDLEdBQXRDLEVBQTBDLElBQUdDLEdBQTdDLEVBQWlELElBQUcsQ0FBcEQsRUFBc0QsSUFBRyxDQUF6RCxFQUEyRCxJQUFHLENBQTlELEVBQWdFLElBQUcsQ0FBbkUsRUFBcUUsSUFBR0MsR0FBeEUsRUFBNEUsSUFBR0MsR0FBL0UsRUFBRCxFQUFxRixFQUFDLEdBQUUsQ0FBQyxDQUFELENBQUgsRUFBckYsRUFBNkYsRUFBQyxJQUFHLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBSixFQUE3RixFQUF5R1AsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBTixDQUF6RyxFQUFzSFIsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBTixDQUF0SCxFQUFtSVIsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBTixDQUFuSSxFQUFnSlIsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBTixDQUFoSixFQUE4SlIsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBTixDQUE5SixFQUE0S1IsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBTixDQUE1SyxFQUEwTFIsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBTixDQUExTCxFQUF1TVIsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBTixDQUF2TSxFQUFvTlIsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBTixDQUFwTixFQUFpT1IsRUFBRSxDQUFDLEVBQUQsRUFBSSxFQUFKLEVBQU8sRUFBUCxFQUFVLEVBQVYsRUFBYSxFQUFiLENBQUYsRUFBbUIsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFuQixDQUFqTyxFQUEyUEEsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBTixDQUEzUCxFQUF3USxFQUFDLEdBQUUsRUFBSCxFQUFNLEdBQUVQLEdBQVIsRUFBWSxJQUFHLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBZixFQUFzQixJQUFHLEVBQXpCLEVBQTRCLElBQUcsRUFBL0IsRUFBeFEsRUFBMlMsRUFBQyxHQUFFLENBQUgsRUFBSyxHQUFFQSxHQUFQLEVBQVcsR0FBRSxDQUFiLEVBQWUsR0FBRUMsR0FBakIsRUFBcUIsR0FBRSxDQUF2QixFQUF5QixHQUFFQyxHQUEzQixFQUErQixHQUFFLENBQWpDLEVBQW1DLElBQUdDLEdBQXRDLEVBQTBDLElBQUdDLEdBQTdDLEVBQWlELElBQUcsRUFBcEQsRUFBdUQsSUFBRyxDQUExRCxFQUE0RCxJQUFHLENBQS9ELEVBQWlFLElBQUdDLEdBQXBFLEVBQXdFLElBQUdDLEdBQTNFLEVBQStFLElBQUcsQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFsRixFQUF5RixJQUFHLEVBQTVGLEVBQTNTLEVBQTJZLEVBQUMsR0FBRSxDQUFDLENBQUQsRUFBRyxDQUFILENBQUgsRUFBM1ksRUFBcVpQLEVBQUVRLEdBQUYsRUFBTSxDQUFDLENBQUQsRUFBRyxFQUFILENBQU4sQ0FBclosRUFBbWEsRUFBQyxJQUFHLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBSixFQUFXLElBQUcsQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFkLEVBQW5hLEVBQXliUixFQUFFUyxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFOLENBQXpiLEVBQXVjLEVBQUMsSUFBRyxDQUFDLENBQUQsRUFBRyxFQUFILENBQUosRUFBdmMsRUFBbWRULEVBQUVRLEdBQUYsRUFBTSxDQUFDLENBQUQsRUFBRyxFQUFILENBQU4sQ0FBbmQsRUFBaWUsRUFBQyxJQUFHLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBSixFQUFXLElBQUcsQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFkLEVBQWplLEVBQXVmUixFQUFFVSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFOLENBQXZmLEVBQXFnQlYsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBTixDQUFyZ0IsRUFBbWhCLEVBQUMsR0FBRSxFQUFILEVBQU0sR0FBRVAsR0FBUixFQUFZLElBQUcsRUFBZixFQUFuaEIsRUFBc2lCLEVBQUMsR0FBRSxDQUFILEVBQUssR0FBRUEsR0FBUCxFQUFXLEdBQUUsQ0FBYixFQUFlLEdBQUVDLEdBQWpCLEVBQXFCLEdBQUUsQ0FBdkIsRUFBeUIsR0FBRUMsR0FBM0IsRUFBK0IsR0FBRSxDQUFqQyxFQUFtQyxJQUFHQyxHQUF0QyxFQUEwQyxJQUFHQyxHQUE3QyxFQUFpRCxJQUFHLEVBQXBELEVBQXVELElBQUcsQ0FBMUQsRUFBNEQsSUFBRyxDQUEvRCxFQUFpRSxJQUFHQyxHQUFwRSxFQUF3RSxJQUFHQyxHQUEzRSxFQUF0aUIsRUFBc25CUCxFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFOLENBQXRuQixFQUFvb0IsRUFBQyxHQUFFLENBQUgsRUFBSyxHQUFFUCxHQUFQLEVBQVcsR0FBRSxDQUFiLEVBQWUsR0FBRUMsR0FBakIsRUFBcUIsR0FBRSxDQUF2QixFQUF5QixHQUFFQyxHQUEzQixFQUErQixHQUFFLENBQWpDLEVBQW1DLElBQUdDLEdBQXRDLEVBQTBDLElBQUdDLEdBQTdDLEVBQWlELElBQUcsRUFBcEQsRUFBdUQsSUFBRyxDQUExRCxFQUE0RCxJQUFHLENBQS9ELEVBQWlFLElBQUdDLEdBQXBFLEVBQXdFLElBQUdDLEdBQTNFLEVBQXBvQixFQUFvdEJQLEVBQUVTLEdBQUYsRUFBTSxDQUFDLENBQUQsRUFBRyxFQUFILENBQU4sQ0FBcHRCLEVBQWt1QlQsRUFBRVMsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBTixDQUFsdUIsRUFBZ3ZCVCxFQUFFVSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFOLENBQWh2QixDQWxGTTtBQW1GYm9CLDRCQUFnQixFQUFDLElBQUcsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFKLEVBbkZIO0FBb0ZiQyx3QkFBWSxTQUFTQSxVQUFULENBQW9CcHBCLEdBQXBCLEVBQXlCN0ksSUFBekIsRUFBK0I7QUFDdkMsb0JBQUlBLEtBQUtreUIsV0FBVCxFQUFzQjtBQUNsQix5QkFBS3JCLEtBQUwsQ0FBV2hvQixHQUFYO0FBQ0gsaUJBRkQsTUFFTztBQUNILDBCQUFNLElBQUlubEIsS0FBSixDQUFVbWxCLEdBQVYsQ0FBTjtBQUNIO0FBQ0osYUExRlk7QUEyRmJybEIsbUJBQU8sU0FBU0EsS0FBVCxDQUFlbVksS0FBZixFQUFzQjtBQUN6QixvQkFBSWxELE9BQU8sSUFBWDtBQUFBLG9CQUFpQjA1QixRQUFRLENBQUMsQ0FBRCxDQUF6QjtBQUFBLG9CQUE4QkMsU0FBUyxDQUFDLElBQUQsQ0FBdkM7QUFBQSxvQkFBK0NDLFNBQVMsRUFBeEQ7QUFBQSxvQkFBNEROLFFBQVEsS0FBS0EsS0FBekU7QUFBQSxvQkFBZ0ZYLFNBQVMsRUFBekY7QUFBQSxvQkFBNkZFLFdBQVcsQ0FBeEc7QUFBQSxvQkFBMkdELFNBQVMsQ0FBcEg7QUFBQSxvQkFBdUhpQixTQUFTLENBQWhJO0FBQUEsb0JBQW1JQyxNQUFNLENBQXpJO0FBQ0Esb0JBQUlobUIsT0FBTzhsQixPQUFPdm1DLEtBQVAsQ0FBYStSLElBQWIsQ0FBa0IySSxTQUFsQixFQUE2QixDQUE3QixDQUFYO0FBQ0Esb0JBQUlnc0IsUUFBUXg2QixPQUFPNE8sTUFBUCxDQUFjLEtBQUs0ckIsS0FBbkIsQ0FBWjtBQUNBLG9CQUFJQyxjQUFjLEVBQUUzQixJQUFJLEVBQU4sRUFBbEI7QUFDQSxxQkFBSyxJQUFJcjFCLENBQVQsSUFBYyxLQUFLcTFCLEVBQW5CLEVBQXVCO0FBQ25CLHdCQUFJOTRCLE9BQU80RixTQUFQLENBQWlCUixjQUFqQixDQUFnQ1MsSUFBaEMsQ0FBcUMsS0FBS2l6QixFQUExQyxFQUE4Q3IxQixDQUE5QyxDQUFKLEVBQXNEO0FBQ2xEZzNCLG9DQUFZM0IsRUFBWixDQUFlcjFCLENBQWYsSUFBb0IsS0FBS3ExQixFQUFMLENBQVFyMUIsQ0FBUixDQUFwQjtBQUNIO0FBQ0o7QUFDRCsyQixzQkFBTUUsUUFBTixDQUFlLzJCLEtBQWYsRUFBc0I4MkIsWUFBWTNCLEVBQWxDO0FBQ0EyQiw0QkFBWTNCLEVBQVosQ0FBZTBCLEtBQWYsR0FBdUJBLEtBQXZCO0FBQ0FDLDRCQUFZM0IsRUFBWixDQUFlN04sTUFBZixHQUF3QixJQUF4QjtBQUNBLG9CQUFJLE9BQU91UCxNQUFNRyxNQUFiLElBQXVCLFdBQTNCLEVBQXdDO0FBQ3BDSCwwQkFBTUcsTUFBTixHQUFlLEVBQWY7QUFDSDtBQUNELG9CQUFJQyxRQUFRSixNQUFNRyxNQUFsQjtBQUNBTix1QkFBTzF3QyxJQUFQLENBQVlpeEMsS0FBWjtBQUNBLG9CQUFJQyxTQUFTTCxNQUFNMzdCLE9BQU4sSUFBaUIyN0IsTUFBTTM3QixPQUFOLENBQWNnOEIsTUFBNUM7QUFDQSxvQkFBSSxPQUFPSixZQUFZM0IsRUFBWixDQUFlbUIsVUFBdEIsS0FBcUMsVUFBekMsRUFBcUQ7QUFDakQseUJBQUtBLFVBQUwsR0FBa0JRLFlBQVkzQixFQUFaLENBQWVtQixVQUFqQztBQUNILGlCQUZELE1BRU87QUFDSCx5QkFBS0EsVUFBTCxHQUFrQmo2QixPQUFPODZCLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEJiLFVBQTlDO0FBQ0g7O0FBRUcseUJBQVNjLEdBQVQsR0FBZTtBQUNYLHdCQUFJQyxLQUFKO0FBQ0FBLDRCQUFRUixNQUFNTyxHQUFOLE1BQWVSLEdBQXZCO0FBQ0Esd0JBQUksT0FBT1MsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUMzQkEsZ0NBQVF2NkIsS0FBS3M0QixRQUFMLENBQWNpQyxLQUFkLEtBQXdCQSxLQUFoQztBQUNIO0FBQ0QsMkJBQU9BLEtBQVA7QUFDSDtBQUNMLG9CQUFJbGpDLE1BQUo7QUFBQSxvQkFBWW1qQyxLQUFaO0FBQUEsb0JBQW1CQyxNQUFuQjtBQUFBLG9CQUEyQnp1QyxDQUEzQjtBQUFBLG9CQUE4QjB1QyxRQUFRLEVBQXRDO0FBQUEsb0JBQTBDeHdCLENBQTFDO0FBQUEsb0JBQTZDeEUsR0FBN0M7QUFBQSxvQkFBa0RpMUIsUUFBbEQ7QUFBQSxvQkFBNERuckIsUUFBNUQ7QUFDQSx1QkFBTyxJQUFQLEVBQWE7QUFDVGdyQiw0QkFBUWQsTUFBTUEsTUFBTW54QyxNQUFOLEdBQWUsQ0FBckIsQ0FBUjtBQUNBLHdCQUFJLEtBQUtneEMsY0FBTCxDQUFvQmlCLEtBQXBCLENBQUosRUFBZ0M7QUFDNUJDLGlDQUFTLEtBQUtsQixjQUFMLENBQW9CaUIsS0FBcEIsQ0FBVDtBQUNILHFCQUZELE1BRU87QUFDSCw0QkFBSW5qQyxXQUFXLElBQVgsSUFBbUIsT0FBT0EsTUFBUCxJQUFpQixXQUF4QyxFQUFxRDtBQUNqREEscUNBQVNpakMsS0FBVDtBQUNIO0FBQ0RHLGlDQUFTbkIsTUFBTWtCLEtBQU4sS0FBZ0JsQixNQUFNa0IsS0FBTixFQUFhbmpDLE1BQWIsQ0FBekI7QUFDSDtBQUNXLHdCQUFJLE9BQU9vakMsTUFBUCxLQUFrQixXQUFsQixJQUFpQyxDQUFDQSxPQUFPbHlDLE1BQXpDLElBQW1ELENBQUNreUMsT0FBTyxDQUFQLENBQXhELEVBQW1FO0FBQ3ZFLDRCQUFJRyxTQUFTLEVBQWI7QUFDQXByQixtQ0FBVyxFQUFYO0FBQ0EsNkJBQUt0RixDQUFMLElBQVVvdkIsTUFBTWtCLEtBQU4sQ0FBVixFQUF3QjtBQUNwQixnQ0FBSSxLQUFLakMsVUFBTCxDQUFnQnJ1QixDQUFoQixLQUFzQkEsSUFBSTJ2QixNQUE5QixFQUFzQztBQUNsQ3JxQix5Q0FBU3RtQixJQUFULENBQWMsT0FBTyxLQUFLcXZDLFVBQUwsQ0FBZ0JydUIsQ0FBaEIsQ0FBUCxHQUE0QixJQUExQztBQUNIO0FBQ0o7QUFDRCw0QkFBSTZ2QixNQUFNYyxZQUFWLEVBQXdCO0FBQ3BCRCxxQ0FBUywwQkFBMEIvQixXQUFXLENBQXJDLElBQTBDLEtBQTFDLEdBQWtEa0IsTUFBTWMsWUFBTixFQUFsRCxHQUF5RSxjQUF6RSxHQUEwRnJyQixTQUFTbGMsSUFBVCxDQUFjLElBQWQsQ0FBMUYsR0FBZ0gsVUFBaEgsSUFBOEgsS0FBS2lsQyxVQUFMLENBQWdCbGhDLE1BQWhCLEtBQTJCQSxNQUF6SixJQUFtSyxJQUE1SztBQUNILHlCQUZELE1BRU87QUFDSHVqQyxxQ0FBUywwQkFBMEIvQixXQUFXLENBQXJDLElBQTBDLGVBQTFDLElBQTZEeGhDLFVBQVV5aUMsR0FBVixHQUFnQixjQUFoQixHQUFpQyxRQUFRLEtBQUt2QixVQUFMLENBQWdCbGhDLE1BQWhCLEtBQTJCQSxNQUFuQyxJQUE2QyxJQUEzSSxDQUFUO0FBQ0g7QUFDRCw2QkFBS21pQyxVQUFMLENBQWdCb0IsTUFBaEIsRUFBd0I7QUFDcEJwb0Isa0NBQU11bkIsTUFBTXh2QyxLQURRO0FBRXBCZ3dDLG1DQUFPLEtBQUtoQyxVQUFMLENBQWdCbGhDLE1BQWhCLEtBQTJCQSxNQUZkO0FBR3BCRCxrQ0FBTTJpQyxNQUFNbEIsUUFIUTtBQUlwQmlDLGlDQUFLWCxLQUplO0FBS3BCM3FCLHNDQUFVQTtBQUxVLHlCQUF4QjtBQU9IO0FBQ0wsd0JBQUlpckIsT0FBTyxDQUFQLGFBQXFCcnlDLEtBQXJCLElBQThCcXlDLE9BQU9seUMsTUFBUCxHQUFnQixDQUFsRCxFQUFxRDtBQUNqRCw4QkFBTSxJQUFJMEMsS0FBSixDQUFVLHNEQUFzRHV2QyxLQUF0RCxHQUE4RCxXQUE5RCxHQUE0RW5qQyxNQUF0RixDQUFOO0FBQ0g7QUFDRCw0QkFBUW9qQyxPQUFPLENBQVAsQ0FBUjtBQUNBLDZCQUFLLENBQUw7QUFDSWYsa0NBQU14d0MsSUFBTixDQUFXbU8sTUFBWDtBQUNBc2lDLG1DQUFPendDLElBQVAsQ0FBWTZ3QyxNQUFNcEIsTUFBbEI7QUFDQWlCLG1DQUFPMXdDLElBQVAsQ0FBWTZ3QyxNQUFNRyxNQUFsQjtBQUNBUixrQ0FBTXh3QyxJQUFOLENBQVd1eEMsT0FBTyxDQUFQLENBQVg7QUFDQXBqQyxxQ0FBUyxJQUFUO0FBQ0E7QUFDSXVoQyx5Q0FBU21CLE1BQU1uQixNQUFmO0FBQ0FELHlDQUFTb0IsTUFBTXBCLE1BQWY7QUFDQUUsMkNBQVdrQixNQUFNbEIsUUFBakI7QUFDQXNCLHdDQUFRSixNQUFNRyxNQUFkO0FBQ0g7QUFDRDtBQUNKLDZCQUFLLENBQUw7QUFDSXgwQixrQ0FBTSxLQUFLOHlCLFlBQUwsQ0FBa0JpQyxPQUFPLENBQVAsQ0FBbEIsRUFBNkIsQ0FBN0IsQ0FBTjtBQUNBQyxrQ0FBTXhCLENBQU4sR0FBVVMsT0FBT0EsT0FBT3B4QyxNQUFQLEdBQWdCbWQsR0FBdkIsQ0FBVjtBQUNBZzFCLGtDQUFNMUIsRUFBTixHQUFXO0FBQ1BHLDRDQUFZUyxPQUFPQSxPQUFPcnhDLE1BQVAsSUFBaUJtZCxPQUFPLENBQXhCLENBQVAsRUFBbUN5ekIsVUFEeEM7QUFFUDRCLDJDQUFXbkIsT0FBT0EsT0FBT3J4QyxNQUFQLEdBQWdCLENBQXZCLEVBQTBCd3lDLFNBRjlCO0FBR1BDLDhDQUFjcEIsT0FBT0EsT0FBT3J4QyxNQUFQLElBQWlCbWQsT0FBTyxDQUF4QixDQUFQLEVBQW1DczFCLFlBSDFDO0FBSVBDLDZDQUFhckIsT0FBT0EsT0FBT3J4QyxNQUFQLEdBQWdCLENBQXZCLEVBQTBCMHlDO0FBSmhDLDZCQUFYO0FBTUEsZ0NBQUliLE1BQUosRUFBWTtBQUNSTSxzQ0FBTTFCLEVBQU4sQ0FBU2tDLEtBQVQsR0FBaUIsQ0FDYnRCLE9BQU9BLE9BQU9yeEMsTUFBUCxJQUFpQm1kLE9BQU8sQ0FBeEIsQ0FBUCxFQUFtQ3cxQixLQUFuQyxDQUF5QyxDQUF6QyxDQURhLEVBRWJ0QixPQUFPQSxPQUFPcnhDLE1BQVAsR0FBZ0IsQ0FBdkIsRUFBMEIyeUMsS0FBMUIsQ0FBZ0MsQ0FBaEMsQ0FGYSxDQUFqQjtBQUlIO0FBQ0RsdkMsZ0NBQUksS0FBS3lzQyxhQUFMLENBQW1CN3dDLEtBQW5CLENBQXlCOHlDLEtBQXpCLEVBQWdDLENBQ2hDL0IsTUFEZ0MsRUFFaENDLE1BRmdDLEVBR2hDQyxRQUhnQyxFQUloQ21CLFlBQVkzQixFQUpvQixFQUtoQ29DLE9BQU8sQ0FBUCxDQUxnQyxFQU1oQ2QsTUFOZ0MsRUFPaENDLE1BUGdDLEVBUWxDbjlCLE1BUmtDLENBUTNCcVgsSUFSMkIsQ0FBaEMsQ0FBSjtBQVNBLGdDQUFJLE9BQU85bkIsQ0FBUCxLQUFhLFdBQWpCLEVBQThCO0FBQzFCLHVDQUFPQSxDQUFQO0FBQ0g7QUFDRCxnQ0FBSTBaLEdBQUosRUFBUztBQUNMZzBCLHdDQUFRQSxNQUFNcm1DLEtBQU4sQ0FBWSxDQUFaLEVBQWUsQ0FBQyxDQUFELEdBQUtxUyxHQUFMLEdBQVcsQ0FBMUIsQ0FBUjtBQUNBaTBCLHlDQUFTQSxPQUFPdG1DLEtBQVAsQ0FBYSxDQUFiLEVBQWdCLENBQUMsQ0FBRCxHQUFLcVMsR0FBckIsQ0FBVDtBQUNBazBCLHlDQUFTQSxPQUFPdm1DLEtBQVAsQ0FBYSxDQUFiLEVBQWdCLENBQUMsQ0FBRCxHQUFLcVMsR0FBckIsQ0FBVDtBQUNIO0FBQ0RnMEIsa0NBQU14d0MsSUFBTixDQUFXLEtBQUtzdkMsWUFBTCxDQUFrQmlDLE9BQU8sQ0FBUCxDQUFsQixFQUE2QixDQUE3QixDQUFYO0FBQ0FkLG1DQUFPendDLElBQVAsQ0FBWXd4QyxNQUFNeEIsQ0FBbEI7QUFDQVUsbUNBQU8xd0MsSUFBUCxDQUFZd3hDLE1BQU0xQixFQUFsQjtBQUNBMkIsdUNBQVdyQixNQUFNSSxNQUFNQSxNQUFNbnhDLE1BQU4sR0FBZSxDQUFyQixDQUFOLEVBQStCbXhDLE1BQU1BLE1BQU1ueEMsTUFBTixHQUFlLENBQXJCLENBQS9CLENBQVg7QUFDQW14QyxrQ0FBTXh3QyxJQUFOLENBQVd5eEMsUUFBWDtBQUNBO0FBQ0osNkJBQUssQ0FBTDtBQUNJLG1DQUFPLElBQVA7QUFyREo7QUF1REg7QUFDRCx1QkFBTyxJQUFQO0FBQ0gsYUF4TlksRUFBYjtBQXlOQTtBQUNBLFlBQUlaLFFBQVMsWUFBVTtBQUN2QixnQkFBSUEsUUFBUzs7QUFFYkQscUJBQUksQ0FGUzs7QUFJYk4sNEJBQVcsU0FBU0EsVUFBVCxDQUFvQnBwQixHQUFwQixFQUF5QjdJLElBQXpCLEVBQStCO0FBQ2xDLHdCQUFJLEtBQUs4d0IsRUFBTCxDQUFRN04sTUFBWixFQUFvQjtBQUNoQiw2QkFBSzZOLEVBQUwsQ0FBUTdOLE1BQVIsQ0FBZWdQLFVBQWYsQ0FBMEJwcEIsR0FBMUIsRUFBK0I3SSxJQUEvQjtBQUNILHFCQUZELE1BRU87QUFDSCw4QkFBTSxJQUFJdGMsS0FBSixDQUFVbWxCLEdBQVYsQ0FBTjtBQUNIO0FBQ0osaUJBVlE7O0FBWWI7QUFDQTZwQiwwQkFBUyxrQkFBVS8yQixLQUFWLEVBQWlCbTFCLEVBQWpCLEVBQXFCO0FBQ3RCLHlCQUFLQSxFQUFMLEdBQVVBLE1BQU0sS0FBS0EsRUFBWCxJQUFpQixFQUEzQjtBQUNBLHlCQUFLOEMsTUFBTCxHQUFjajRCLEtBQWQ7QUFDQSx5QkFBS2s0QixLQUFMLEdBQWEsS0FBS0MsVUFBTCxHQUFrQixLQUFLQyxJQUFMLEdBQVksS0FBM0M7QUFDQSx5QkFBS3pDLFFBQUwsR0FBZ0IsS0FBS0QsTUFBTCxHQUFjLENBQTlCO0FBQ0EseUJBQUtELE1BQUwsR0FBYyxLQUFLNEMsT0FBTCxHQUFlLEtBQUtoeEMsS0FBTCxHQUFhLEVBQTFDO0FBQ0EseUJBQUtpeEMsY0FBTCxHQUFzQixDQUFDLFNBQUQsQ0FBdEI7QUFDQSx5QkFBS3RCLE1BQUwsR0FBYztBQUNWZixvQ0FBWSxDQURGO0FBRVY2QixzQ0FBYyxDQUZKO0FBR1ZELG1DQUFXLENBSEQ7QUFJVkUscUNBQWE7QUFKSCxxQkFBZDtBQU1BLHdCQUFJLEtBQUs3OEIsT0FBTCxDQUFhZzhCLE1BQWpCLEVBQXlCO0FBQ3JCLDZCQUFLRixNQUFMLENBQVlnQixLQUFaLEdBQW9CLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBcEI7QUFDSDtBQUNELHlCQUFLTyxNQUFMLEdBQWMsQ0FBZDtBQUNBLDJCQUFPLElBQVA7QUFDSCxpQkEvQlE7O0FBaUNiO0FBQ0F2NEIsdUJBQU0saUJBQVk7QUFDVix3QkFBSXc0QixLQUFLLEtBQUtQLE1BQUwsQ0FBWSxDQUFaLENBQVQ7QUFDQSx5QkFBS3hDLE1BQUwsSUFBZStDLEVBQWY7QUFDQSx5QkFBSzlDLE1BQUw7QUFDQSx5QkFBSzZDLE1BQUw7QUFDQSx5QkFBS2x4QyxLQUFMLElBQWNteEMsRUFBZDtBQUNBLHlCQUFLSCxPQUFMLElBQWdCRyxFQUFoQjtBQUNBLHdCQUFJQyxRQUFRRCxHQUFHbnhDLEtBQUgsQ0FBUyxpQkFBVCxDQUFaO0FBQ0Esd0JBQUlveEMsS0FBSixFQUFXO0FBQ1AsNkJBQUs5QyxRQUFMO0FBQ0EsNkJBQUtxQixNQUFMLENBQVlhLFNBQVo7QUFDSCxxQkFIRCxNQUdPO0FBQ0gsNkJBQUtiLE1BQUwsQ0FBWWUsV0FBWjtBQUNIO0FBQ0Qsd0JBQUksS0FBSzc4QixPQUFMLENBQWFnOEIsTUFBakIsRUFBeUI7QUFDckIsNkJBQUtGLE1BQUwsQ0FBWWdCLEtBQVosQ0FBa0IsQ0FBbEI7QUFDSDs7QUFFRCx5QkFBS0MsTUFBTCxHQUFjLEtBQUtBLE1BQUwsQ0FBWTluQyxLQUFaLENBQWtCLENBQWxCLENBQWQ7QUFDQSwyQkFBT3FvQyxFQUFQO0FBQ0gsaUJBdERROztBQXdEYjtBQUNBRSx1QkFBTSxlQUFVRixFQUFWLEVBQWM7QUFDWix3QkFBSWgyQixNQUFNZzJCLEdBQUduekMsTUFBYjtBQUNBLHdCQUFJb3pDLFFBQVFELEdBQUc1eUMsS0FBSCxDQUFTLGVBQVQsQ0FBWjs7QUFFQSx5QkFBS3F5QyxNQUFMLEdBQWNPLEtBQUssS0FBS1AsTUFBeEI7QUFDQSx5QkFBS3hDLE1BQUwsR0FBYyxLQUFLQSxNQUFMLENBQVlwbEMsTUFBWixDQUFtQixDQUFuQixFQUFzQixLQUFLb2xDLE1BQUwsQ0FBWXB3QyxNQUFaLEdBQXFCbWQsR0FBM0MsQ0FBZDtBQUNBO0FBQ0EseUJBQUsrMUIsTUFBTCxJQUFlLzFCLEdBQWY7QUFDQSx3QkFBSW0yQixXQUFXLEtBQUt0eEMsS0FBTCxDQUFXekIsS0FBWCxDQUFpQixlQUFqQixDQUFmO0FBQ0EseUJBQUt5QixLQUFMLEdBQWEsS0FBS0EsS0FBTCxDQUFXZ0osTUFBWCxDQUFrQixDQUFsQixFQUFxQixLQUFLaEosS0FBTCxDQUFXaEMsTUFBWCxHQUFvQixDQUF6QyxDQUFiO0FBQ0EseUJBQUtnekMsT0FBTCxHQUFlLEtBQUtBLE9BQUwsQ0FBYWhvQyxNQUFiLENBQW9CLENBQXBCLEVBQXVCLEtBQUtnb0MsT0FBTCxDQUFhaHpDLE1BQWIsR0FBc0IsQ0FBN0MsQ0FBZjs7QUFFQSx3QkFBSW96QyxNQUFNcHpDLE1BQU4sR0FBZSxDQUFuQixFQUFzQjtBQUNsQiw2QkFBS3N3QyxRQUFMLElBQWlCOEMsTUFBTXB6QyxNQUFOLEdBQWUsQ0FBaEM7QUFDSDtBQUNELHdCQUFJeUQsSUFBSSxLQUFLa3VDLE1BQUwsQ0FBWWdCLEtBQXBCOztBQUVBLHlCQUFLaEIsTUFBTCxHQUFjO0FBQ1ZmLG9DQUFZLEtBQUtlLE1BQUwsQ0FBWWYsVUFEZDtBQUVWNEIsbUNBQVcsS0FBS2xDLFFBQUwsR0FBZ0IsQ0FGakI7QUFHVm1DLHNDQUFjLEtBQUtkLE1BQUwsQ0FBWWMsWUFIaEI7QUFJVkMscUNBQWFVLFFBQ1QsQ0FBQ0EsTUFBTXB6QyxNQUFOLEtBQWlCc3pDLFNBQVN0ekMsTUFBMUIsR0FBbUMsS0FBSzJ4QyxNQUFMLENBQVljLFlBQS9DLEdBQThELENBQS9ELElBQ0dhLFNBQVNBLFNBQVN0ekMsTUFBVCxHQUFrQm96QyxNQUFNcHpDLE1BQWpDLEVBQXlDQSxNQUQ1QyxHQUNxRG96QyxNQUFNLENBQU4sRUFBU3B6QyxNQUZyRCxHQUdYLEtBQUsyeEMsTUFBTCxDQUFZYyxZQUFaLEdBQTJCdDFCO0FBUG5CLHFCQUFkOztBQVVBLHdCQUFJLEtBQUt0SCxPQUFMLENBQWFnOEIsTUFBakIsRUFBeUI7QUFDckIsNkJBQUtGLE1BQUwsQ0FBWWdCLEtBQVosR0FBb0IsQ0FBQ2x2QyxFQUFFLENBQUYsQ0FBRCxFQUFPQSxFQUFFLENBQUYsSUFBTyxLQUFLNHNDLE1BQVosR0FBcUJsekIsR0FBNUIsQ0FBcEI7QUFDSDtBQUNELHlCQUFLa3pCLE1BQUwsR0FBYyxLQUFLRCxNQUFMLENBQVlwd0MsTUFBMUI7QUFDQSwyQkFBTyxJQUFQO0FBQ0gsaUJBekZROztBQTJGYjtBQUNBdXpDLHNCQUFLLGdCQUFZO0FBQ1QseUJBQUtWLEtBQUwsR0FBYSxJQUFiO0FBQ0EsMkJBQU8sSUFBUDtBQUNILGlCQS9GUTs7QUFpR2I7QUFDQXZ3Qyx3QkFBTyxrQkFBWTtBQUNYLHdCQUFJLEtBQUt1VCxPQUFMLENBQWEyOUIsZUFBakIsRUFBa0M7QUFDOUIsNkJBQUtWLFVBQUwsR0FBa0IsSUFBbEI7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsK0JBQU8sS0FBSzdCLFVBQUwsQ0FBZ0IsNEJBQTRCLEtBQUtYLFFBQUwsR0FBZ0IsQ0FBNUMsSUFBaUQsa0lBQWpELEdBQXNMLEtBQUtnQyxZQUFMLEVBQXRNLEVBQTJOO0FBQzlOcm9CLGtDQUFNLEVBRHdOO0FBRTlOK25CLG1DQUFPLElBRnVOO0FBRzlObmpDLGtDQUFNLEtBQUt5aEM7QUFIbU4seUJBQTNOLENBQVA7QUFNSDtBQUNELDJCQUFPLElBQVA7QUFDSCxpQkE5R1E7O0FBZ0hiO0FBQ0FtRCxzQkFBSyxjQUFVMzRCLENBQVYsRUFBYTtBQUNWLHlCQUFLdTRCLEtBQUwsQ0FBVyxLQUFLcnhDLEtBQUwsQ0FBVzhJLEtBQVgsQ0FBaUJnUSxDQUFqQixDQUFYO0FBQ0gsaUJBbkhROztBQXFIYjtBQUNBNDRCLDJCQUFVLHFCQUFZO0FBQ2Qsd0JBQUlDLE9BQU8sS0FBS1gsT0FBTCxDQUFhaG9DLE1BQWIsQ0FBb0IsQ0FBcEIsRUFBdUIsS0FBS2dvQyxPQUFMLENBQWFoekMsTUFBYixHQUFzQixLQUFLZ0MsS0FBTCxDQUFXaEMsTUFBeEQsQ0FBWDtBQUNBLDJCQUFPLENBQUMyekMsS0FBSzN6QyxNQUFMLEdBQWMsRUFBZCxHQUFtQixLQUFuQixHQUF5QixFQUExQixJQUFnQzJ6QyxLQUFLM29DLE1BQUwsQ0FBWSxDQUFDLEVBQWIsRUFBaUJ4SyxPQUFqQixDQUF5QixLQUF6QixFQUFnQyxFQUFoQyxDQUF2QztBQUNILGlCQXpIUTs7QUEySGI7QUFDQW96QywrQkFBYyx5QkFBWTtBQUNsQix3QkFBSUMsT0FBTyxLQUFLN3hDLEtBQWhCO0FBQ0Esd0JBQUk2eEMsS0FBSzd6QyxNQUFMLEdBQWMsRUFBbEIsRUFBc0I7QUFDbEI2ekMsZ0NBQVEsS0FBS2pCLE1BQUwsQ0FBWTVuQyxNQUFaLENBQW1CLENBQW5CLEVBQXNCLEtBQUc2b0MsS0FBSzd6QyxNQUE5QixDQUFSO0FBQ0g7QUFDRCwyQkFBTyxDQUFDNnpDLEtBQUs3b0MsTUFBTCxDQUFZLENBQVosRUFBYyxFQUFkLEtBQXFCNm9DLEtBQUs3ekMsTUFBTCxHQUFjLEVBQWQsR0FBbUIsS0FBbkIsR0FBMkIsRUFBaEQsQ0FBRCxFQUFzRFEsT0FBdEQsQ0FBOEQsS0FBOUQsRUFBcUUsRUFBckUsQ0FBUDtBQUNILGlCQWxJUTs7QUFvSWI7QUFDQTh4Qyw4QkFBYSx3QkFBWTtBQUNqQix3QkFBSXdCLE1BQU0sS0FBS0osU0FBTCxFQUFWO0FBQ0Esd0JBQUl6bUIsSUFBSSxJQUFJcHRCLEtBQUosQ0FBVWkwQyxJQUFJOXpDLE1BQUosR0FBYSxDQUF2QixFQUEwQitLLElBQTFCLENBQStCLEdBQS9CLENBQVI7QUFDQSwyQkFBTytvQyxNQUFNLEtBQUtGLGFBQUwsRUFBTixHQUE2QixJQUE3QixHQUFvQzNtQixDQUFwQyxHQUF3QyxHQUEvQztBQUNILGlCQXpJUTs7QUEySWI7QUFDQThtQiw0QkFBVyxvQkFBVS94QyxLQUFWLEVBQWlCZ3lDLFlBQWpCLEVBQStCO0FBQ2xDLHdCQUFJaEMsS0FBSixFQUNJb0IsS0FESixFQUVJYSxNQUZKOztBQUlBLHdCQUFJLEtBQUtwK0IsT0FBTCxDQUFhMjlCLGVBQWpCLEVBQWtDO0FBQzlCO0FBQ0FTLGlDQUFTO0FBQ0wzRCxzQ0FBVSxLQUFLQSxRQURWO0FBRUxxQixvQ0FBUTtBQUNKZiw0Q0FBWSxLQUFLZSxNQUFMLENBQVlmLFVBRHBCO0FBRUo0QiwyQ0FBVyxLQUFLQSxTQUZaO0FBR0pDLDhDQUFjLEtBQUtkLE1BQUwsQ0FBWWMsWUFIdEI7QUFJSkMsNkNBQWEsS0FBS2YsTUFBTCxDQUFZZTtBQUpyQiw2QkFGSDtBQVFMdEMsb0NBQVEsS0FBS0EsTUFSUjtBQVNMcHVDLG1DQUFPLEtBQUtBLEtBVFA7QUFVTGt5QyxxQ0FBUyxLQUFLQSxPQVZUO0FBV0xsQixxQ0FBUyxLQUFLQSxPQVhUO0FBWUwzQyxvQ0FBUSxLQUFLQSxNQVpSO0FBYUw2QyxvQ0FBUSxLQUFLQSxNQWJSO0FBY0xMLG1DQUFPLEtBQUtBLEtBZFA7QUFlTEQsb0NBQVEsS0FBS0EsTUFmUjtBQWdCTDlDLGdDQUFJLEtBQUtBLEVBaEJKO0FBaUJMbUQsNENBQWdCLEtBQUtBLGNBQUwsQ0FBb0Jub0MsS0FBcEIsQ0FBMEIsQ0FBMUIsQ0FqQlg7QUFrQkxpb0Msa0NBQU0sS0FBS0E7QUFsQk4seUJBQVQ7QUFvQkEsNEJBQUksS0FBS2w5QixPQUFMLENBQWFnOEIsTUFBakIsRUFBeUI7QUFDckJvQyxtQ0FBT3RDLE1BQVAsQ0FBY2dCLEtBQWQsR0FBc0IsS0FBS2hCLE1BQUwsQ0FBWWdCLEtBQVosQ0FBa0I3bkMsS0FBbEIsQ0FBd0IsQ0FBeEIsQ0FBdEI7QUFDSDtBQUNKOztBQUVEc29DLDRCQUFRcHhDLE1BQU0sQ0FBTixFQUFTQSxLQUFULENBQWUsaUJBQWYsQ0FBUjtBQUNBLHdCQUFJb3hDLEtBQUosRUFBVztBQUNQLDZCQUFLOUMsUUFBTCxJQUFpQjhDLE1BQU1wekMsTUFBdkI7QUFDSDtBQUNELHlCQUFLMnhDLE1BQUwsR0FBYztBQUNWZixvQ0FBWSxLQUFLZSxNQUFMLENBQVlhLFNBRGQ7QUFFVkEsbUNBQVcsS0FBS2xDLFFBQUwsR0FBZ0IsQ0FGakI7QUFHVm1DLHNDQUFjLEtBQUtkLE1BQUwsQ0FBWWUsV0FIaEI7QUFJVkEscUNBQWFVLFFBQ0FBLE1BQU1BLE1BQU1wekMsTUFBTixHQUFlLENBQXJCLEVBQXdCQSxNQUF4QixHQUFpQ296QyxNQUFNQSxNQUFNcHpDLE1BQU4sR0FBZSxDQUFyQixFQUF3QmdDLEtBQXhCLENBQThCLFFBQTlCLEVBQXdDLENBQXhDLEVBQTJDaEMsTUFENUUsR0FFQSxLQUFLMnhDLE1BQUwsQ0FBWWUsV0FBWixHQUEwQjF3QyxNQUFNLENBQU4sRUFBU2hDO0FBTnRDLHFCQUFkO0FBUUEseUJBQUtvd0MsTUFBTCxJQUFlcHVDLE1BQU0sQ0FBTixDQUFmO0FBQ0EseUJBQUtBLEtBQUwsSUFBY0EsTUFBTSxDQUFOLENBQWQ7QUFDQSx5QkFBS2t5QyxPQUFMLEdBQWVseUMsS0FBZjtBQUNBLHlCQUFLcXVDLE1BQUwsR0FBYyxLQUFLRCxNQUFMLENBQVlwd0MsTUFBMUI7QUFDQSx3QkFBSSxLQUFLNlYsT0FBTCxDQUFhZzhCLE1BQWpCLEVBQXlCO0FBQ3JCLDZCQUFLRixNQUFMLENBQVlnQixLQUFaLEdBQW9CLENBQUMsS0FBS08sTUFBTixFQUFjLEtBQUtBLE1BQUwsSUFBZSxLQUFLN0MsTUFBbEMsQ0FBcEI7QUFDSDtBQUNELHlCQUFLd0MsS0FBTCxHQUFhLEtBQWI7QUFDQSx5QkFBS0MsVUFBTCxHQUFrQixLQUFsQjtBQUNBLHlCQUFLRixNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZOW5DLEtBQVosQ0FBa0I5SSxNQUFNLENBQU4sRUFBU2hDLE1BQTNCLENBQWQ7QUFDQSx5QkFBS2d6QyxPQUFMLElBQWdCaHhDLE1BQU0sQ0FBTixDQUFoQjtBQUNBZ3dDLDRCQUFRLEtBQUs5QixhQUFMLENBQW1CcnpCLElBQW5CLENBQXdCLElBQXhCLEVBQThCLEtBQUtpekIsRUFBbkMsRUFBdUMsSUFBdkMsRUFBNkNrRSxZQUE3QyxFQUEyRCxLQUFLZixjQUFMLENBQW9CLEtBQUtBLGNBQUwsQ0FBb0JqekMsTUFBcEIsR0FBNkIsQ0FBakQsQ0FBM0QsQ0FBUjtBQUNBLHdCQUFJLEtBQUsreUMsSUFBTCxJQUFhLEtBQUtILE1BQXRCLEVBQThCO0FBQzFCLDZCQUFLRyxJQUFMLEdBQVksS0FBWjtBQUNIO0FBQ0Qsd0JBQUlmLEtBQUosRUFBVztBQUNQLCtCQUFPQSxLQUFQO0FBQ0gscUJBRkQsTUFFTyxJQUFJLEtBQUtjLFVBQVQsRUFBcUI7QUFDeEI7QUFDQSw2QkFBSyxJQUFJcjRCLENBQVQsSUFBY3c1QixNQUFkLEVBQXNCO0FBQ2xCLGlDQUFLeDVCLENBQUwsSUFBVXc1QixPQUFPeDVCLENBQVAsQ0FBVjtBQUNIO0FBQ0QsK0JBQU8sS0FBUCxDQUx3QixDQUtWO0FBQ2pCO0FBQ0QsMkJBQU8sS0FBUDtBQUNILGlCQWpOUTs7QUFtTmI7QUFDQW81QixzQkFBSyxnQkFBWTtBQUNULHdCQUFJLEtBQUtkLElBQVQsRUFBZTtBQUNYLCtCQUFPLEtBQUt4QixHQUFaO0FBQ0g7QUFDRCx3QkFBSSxDQUFDLEtBQUtxQixNQUFWLEVBQWtCO0FBQ2QsNkJBQUtHLElBQUwsR0FBWSxJQUFaO0FBQ0g7O0FBRUQsd0JBQUlmLEtBQUosRUFDSWh3QyxLQURKLEVBRUlteUMsU0FGSixFQUdJNTlCLEtBSEo7QUFJQSx3QkFBSSxDQUFDLEtBQUtzOEIsS0FBVixFQUFpQjtBQUNiLDZCQUFLekMsTUFBTCxHQUFjLEVBQWQ7QUFDQSw2QkFBS3B1QyxLQUFMLEdBQWEsRUFBYjtBQUNIO0FBQ0Qsd0JBQUlveUMsUUFBUSxLQUFLQyxhQUFMLEVBQVo7QUFDQSx5QkFBSyxJQUFJMTBDLElBQUksQ0FBYixFQUFnQkEsSUFBSXkwQyxNQUFNcDBDLE1BQTFCLEVBQWtDTCxHQUFsQyxFQUF1QztBQUNuQ3cwQyxvQ0FBWSxLQUFLdkIsTUFBTCxDQUFZNXdDLEtBQVosQ0FBa0IsS0FBS295QyxLQUFMLENBQVdBLE1BQU16MEMsQ0FBTixDQUFYLENBQWxCLENBQVo7QUFDQSw0QkFBSXcwQyxjQUFjLENBQUNueUMsS0FBRCxJQUFVbXlDLFVBQVUsQ0FBVixFQUFhbjBDLE1BQWIsR0FBc0JnQyxNQUFNLENBQU4sRUFBU2hDLE1BQXZELENBQUosRUFBb0U7QUFDaEVnQyxvQ0FBUW15QyxTQUFSO0FBQ0E1OUIsb0NBQVE1VyxDQUFSO0FBQ0EsZ0NBQUksS0FBS2tXLE9BQUwsQ0FBYTI5QixlQUFqQixFQUFrQztBQUM5QnhCLHdDQUFRLEtBQUsrQixVQUFMLENBQWdCSSxTQUFoQixFQUEyQkMsTUFBTXowQyxDQUFOLENBQTNCLENBQVI7QUFDQSxvQ0FBSXF5QyxVQUFVLEtBQWQsRUFBcUI7QUFDakIsMkNBQU9BLEtBQVA7QUFDSCxpQ0FGRCxNQUVPLElBQUksS0FBS2MsVUFBVCxFQUFxQjtBQUN4Qjl3Qyw0Q0FBUSxLQUFSO0FBQ0EsNkNBRndCLENBRWQ7QUFDYixpQ0FITSxNQUdBO0FBQ0g7QUFDQSwyQ0FBTyxLQUFQO0FBQ0g7QUFDSiw2QkFYRCxNQVdPLElBQUksQ0FBQyxLQUFLNlQsT0FBTCxDQUFheStCLElBQWxCLEVBQXdCO0FBQzNCO0FBQ0g7QUFDSjtBQUNKO0FBQ0Qsd0JBQUl0eUMsS0FBSixFQUFXO0FBQ1Bnd0MsZ0NBQVEsS0FBSytCLFVBQUwsQ0FBZ0IveEMsS0FBaEIsRUFBdUJveUMsTUFBTTc5QixLQUFOLENBQXZCLENBQVI7QUFDQSw0QkFBSXk3QixVQUFVLEtBQWQsRUFBcUI7QUFDakIsbUNBQU9BLEtBQVA7QUFDSDtBQUNEO0FBQ0EsK0JBQU8sS0FBUDtBQUNIO0FBQ0Qsd0JBQUksS0FBS1ksTUFBTCxLQUFnQixFQUFwQixFQUF3QjtBQUNwQiwrQkFBTyxLQUFLckIsR0FBWjtBQUNILHFCQUZELE1BRU87QUFDSCwrQkFBTyxLQUFLTixVQUFMLENBQWdCLDRCQUE0QixLQUFLWCxRQUFMLEdBQWdCLENBQTVDLElBQWlELHdCQUFqRCxHQUE0RSxLQUFLZ0MsWUFBTCxFQUE1RixFQUFpSDtBQUNwSHJvQixrQ0FBTSxFQUQ4RztBQUVwSCtuQixtQ0FBTyxJQUY2RztBQUdwSG5qQyxrQ0FBTSxLQUFLeWhDO0FBSHlHLHlCQUFqSCxDQUFQO0FBS0g7QUFDSixpQkEzUVE7O0FBNlFiO0FBQ0F5QixxQkFBSSxTQUFTQSxHQUFULEdBQWU7QUFDWCx3QkFBSXR1QyxJQUFJLEtBQUtvd0MsSUFBTCxFQUFSO0FBQ0Esd0JBQUlwd0MsQ0FBSixFQUFPO0FBQ0gsK0JBQU9BLENBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsK0JBQU8sS0FBS3N1QyxHQUFMLEVBQVA7QUFDSDtBQUNKLGlCQXJSUTs7QUF1UmI7QUFDQXdDLHVCQUFNLFNBQVNBLEtBQVQsQ0FBZUMsU0FBZixFQUEwQjtBQUN4Qix5QkFBS3ZCLGNBQUwsQ0FBb0J0eUMsSUFBcEIsQ0FBeUI2ekMsU0FBekI7QUFDSCxpQkExUlE7O0FBNFJiO0FBQ0FDLDBCQUFTLFNBQVNBLFFBQVQsR0FBb0I7QUFDckIsd0JBQUkzNUIsSUFBSSxLQUFLbTRCLGNBQUwsQ0FBb0JqekMsTUFBcEIsR0FBNkIsQ0FBckM7QUFDQSx3QkFBSThhLElBQUksQ0FBUixFQUFXO0FBQ1AsK0JBQU8sS0FBS200QixjQUFMLENBQW9CL3ZCLEdBQXBCLEVBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsK0JBQU8sS0FBSyt2QixjQUFMLENBQW9CLENBQXBCLENBQVA7QUFDSDtBQUNKLGlCQXBTUTs7QUFzU2I7QUFDQW9CLCtCQUFjLFNBQVNBLGFBQVQsR0FBeUI7QUFDL0Isd0JBQUksS0FBS3BCLGNBQUwsQ0FBb0JqekMsTUFBcEIsSUFBOEIsS0FBS2l6QyxjQUFMLENBQW9CLEtBQUtBLGNBQUwsQ0FBb0JqekMsTUFBcEIsR0FBNkIsQ0FBakQsQ0FBbEMsRUFBdUY7QUFDbkYsK0JBQU8sS0FBS3VtQyxVQUFMLENBQWdCLEtBQUswTSxjQUFMLENBQW9CLEtBQUtBLGNBQUwsQ0FBb0JqekMsTUFBcEIsR0FBNkIsQ0FBakQsQ0FBaEIsRUFBcUVvMEMsS0FBNUU7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsK0JBQU8sS0FBSzdOLFVBQUwsQ0FBZ0IsU0FBaEIsRUFBMkI2TixLQUFsQztBQUNIO0FBQ0osaUJBN1NROztBQStTYjtBQUNBTSwwQkFBUyxTQUFTQSxRQUFULENBQWtCNTVCLENBQWxCLEVBQXFCO0FBQ3RCQSx3QkFBSSxLQUFLbTRCLGNBQUwsQ0FBb0JqekMsTUFBcEIsR0FBNkIsQ0FBN0IsR0FBaUNrWixLQUFLdEYsR0FBTCxDQUFTa0gsS0FBSyxDQUFkLENBQXJDO0FBQ0Esd0JBQUlBLEtBQUssQ0FBVCxFQUFZO0FBQ1IsK0JBQU8sS0FBS200QixjQUFMLENBQW9CbjRCLENBQXBCLENBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsK0JBQU8sU0FBUDtBQUNIO0FBQ0osaUJBdlRROztBQXlUYjtBQUNBNjVCLDJCQUFVLFNBQVNBLFNBQVQsQ0FBbUJILFNBQW5CLEVBQThCO0FBQ2hDLHlCQUFLRCxLQUFMLENBQVdDLFNBQVg7QUFDSCxpQkE1VFE7O0FBOFRiO0FBQ0FJLGdDQUFlLFNBQVNBLGNBQVQsR0FBMEI7QUFDakMsMkJBQU8sS0FBSzNCLGNBQUwsQ0FBb0JqekMsTUFBM0I7QUFDSCxpQkFqVVE7QUFrVWI2Vix5QkFBUyxFQWxVSTtBQW1VYnE2QiwrQkFBZSxTQUFTQyxTQUFULENBQW1CTCxFQUFuQixFQUFzQitFLEdBQXRCLEVBQTBCQyx5QkFBMUIsRUFBb0RDLFFBQXBELEVBQThEO0FBQzdFLDRCQUFPRCx5QkFBUDtBQUNBLDZCQUFLLENBQUw7QUFBTztBQUNQO0FBQ0EsNkJBQUssQ0FBTDtBQUFPLG1DQUFPLENBQVA7QUFDUCw2QkFBSyxDQUFMO0FBQU9ELGdDQUFJekUsTUFBSixHQUFheUUsSUFBSXpFLE1BQUosQ0FBV3BsQyxNQUFYLENBQWtCLENBQWxCLEVBQW9CNnBDLElBQUl4RSxNQUFKLEdBQVcsQ0FBL0IsQ0FBYixDQUFnRCxPQUFPLENBQVA7QUFDdkQsNkJBQUssQ0FBTDtBQUFPLG1DQUFPLEVBQVA7QUFDUCw2QkFBSyxDQUFMO0FBQU8sbUNBQU8sRUFBUDtBQUNQLDZCQUFLLENBQUw7QUFBTyxtQ0FBTyxFQUFQO0FBQ1AsNkJBQUssQ0FBTDtBQUFPLG1DQUFPLEVBQVA7QUFDUCw2QkFBSyxDQUFMO0FBQU8sbUNBQU8sRUFBUDtBQUNQLDZCQUFLLENBQUw7QUFBTyxtQ0FBTyxFQUFQO0FBQ1AsNkJBQUssQ0FBTDtBQUFPLG1DQUFPLEVBQVA7QUFDUCw2QkFBSyxFQUFMO0FBQVEsbUNBQU8sRUFBUDtBQUNSLDZCQUFLLEVBQUw7QUFBUSxtQ0FBTyxDQUFQO0FBQ1IsNkJBQUssRUFBTDtBQUFRLG1DQUFPLEVBQVA7QUFDUiw2QkFBSyxFQUFMO0FBQVEsbUNBQU8sU0FBUDtBQWZSO0FBaUJDLGlCQXJWWTtBQXNWYitELHVCQUFPLENBQUMsVUFBRCxFQUFZLDZEQUFaLEVBQTBFLG9FQUExRSxFQUErSSxTQUEvSSxFQUF5SixTQUF6SixFQUFtSyxTQUFuSyxFQUE2SyxTQUE3SyxFQUF1TCxRQUF2TCxFQUFnTSxRQUFoTSxFQUF5TSxhQUF6TSxFQUF1TixjQUF2TixFQUFzTyxhQUF0TyxFQUFvUCxRQUFwUCxFQUE2UCxRQUE3UCxDQXRWTTtBQXVWYjdOLDRCQUFZLEVBQUMsV0FBVSxFQUFDLFNBQVEsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLENBQUwsRUFBTyxDQUFQLEVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiLEVBQWUsQ0FBZixFQUFpQixDQUFqQixFQUFtQixDQUFuQixFQUFxQixFQUFyQixFQUF3QixFQUF4QixFQUEyQixFQUEzQixFQUE4QixFQUE5QixDQUFULEVBQTJDLGFBQVksSUFBdkQsRUFBWDtBQXZWQyxhQUFiO0FBeVZBLG1CQUFPaUwsS0FBUDtBQUNDLFNBM1ZXLEVBQVo7QUE0VkF2UCxlQUFPdVAsS0FBUCxHQUFlQSxLQUFmO0FBQ0EsaUJBQVN3RCxNQUFULEdBQW1CO0FBQ2pCLGlCQUFLbEYsRUFBTCxHQUFVLEVBQVY7QUFDRDtBQUNEa0YsZUFBT3A0QixTQUFQLEdBQW1CcWxCLE1BQW5CLENBQTBCQSxPQUFPK1MsTUFBUCxHQUFnQkEsTUFBaEI7QUFDMUIsZUFBTyxJQUFJQSxNQUFKLEVBQVA7QUFDQyxLQTlqQlksRUFBYjs7QUFpa0JBLFFBQUksT0FBT3Q5QixlQUFQLEtBQTJCLFdBQTNCLElBQTBDLGFBQWEsV0FBM0QsRUFBd0U7QUFDeEVJLGdCQUFRbXFCLE1BQVIsR0FBaUJBLE1BQWpCO0FBQ0FucUIsZ0JBQVFrOUIsTUFBUixHQUFpQi9TLE9BQU8rUyxNQUF4QjtBQUNBbDlCLGdCQUFRdFYsS0FBUixHQUFnQixZQUFZO0FBQUUsbUJBQU95L0IsT0FBT3ovQixLQUFQLENBQWFuRCxLQUFiLENBQW1CNGlDLE1BQW5CLEVBQTJCemMsU0FBM0IsQ0FBUDtBQUErQyxTQUE3RTtBQUNDO0FBQ0EsQ0FocEJjLENBQWY7QUFpcEJBLElBQUl5dkIsYUFBYWhHLFNBQVNoTixNQUExQjtBQUNBLElBQUlpVCxhQUFhakcsU0FBUytGLE1BQTFCO0FBQ0EsSUFBSUcsYUFBYWxHLFNBQVN6c0MsS0FBMUI7O0FBRUEsU0FBUzR5QyxTQUFULENBQW1CbnhDLEtBQW5CLEVBQTBCO0FBQ3RCLFFBQUlBLGlCQUFpQm1WLE1BQWpCLElBQTJCLE9BQU9uVixLQUFQLEtBQWlCLFFBQTVDLElBQXdEQSxpQkFBaUJveEMsTUFBN0UsRUFBcUY7QUFDakYsWUFBSTtBQUNBLG1CQUFPcEcsU0FBU3pzQyxLQUFULENBQWV5QixNQUFNb0IsUUFBTixFQUFmLENBQVA7QUFDSCxTQUZELENBRUUsT0FBT2QsQ0FBUCxFQUFVO0FBQ1Isa0JBQU0sSUFBSTZsQyxjQUFKLENBQW1CN2xDLENBQW5CLENBQU47QUFDSDtBQUNKO0FBQ0QsV0FBT04sS0FBUDtBQUNIOztBQUVELFNBQVNxeEMsYUFBVCxDQUF1QnJ4QyxLQUF2QixFQUE4QjhtQyxTQUE5QixFQUF5QztBQUNyQyxRQUFJQSxjQUFjLEtBQUssQ0FBdkIsRUFDSUEsWUFBWWoyQixFQUFaO0FBQ0osUUFBSW1OLElBQUloZSxLQUFSO0FBQ0EsUUFBSTtBQUNBZ2UsWUFBSW16QixVQUFVbnpCLENBQVYsQ0FBSjtBQUNILEtBRkQsQ0FFRSxPQUFPMWQsQ0FBUCxFQUFVO0FBQ1IsZUFBTyxDQUFDQSxDQUFELENBQVA7QUFDSDtBQUNELFdBQU9xcUMsaUJBQWlCM3NCLENBQWpCLEVBQW9COG9CLFNBQXBCLENBQVA7QUFDSDs7QUFFRCxJQUFJd0sseUJBQXlCLENBQTdCO0FBQ0EsSUFBSUMsdUJBQXVCLEVBQTNCO0FBQ0EsU0FBU0MsT0FBVCxDQUFpQjVwQyxLQUFqQixFQUF3QjZwQyxLQUF4QixFQUErQjtBQUMzQixRQUFJLENBQUM3cEMsS0FBRCxJQUFVMnpCLFFBQVEzekIsS0FBUixNQUFtQixRQUFqQyxFQUEyQztBQUN2QyxlQUFPLElBQVA7QUFDSDtBQUNELFdBQU8sQ0FBQyxDQUFDQSxNQUFNN0osS0FBTixDQUFZMHpDLEtBQVosQ0FBVDtBQUNIO0FBQ0QsU0FBU0MsY0FBVCxDQUF3Qnp6QyxNQUF4QixFQUFnQztBQUM1QixRQUFJQSxPQUFPUCxHQUFYLEVBQWdCO0FBQ1osZUFBT08sT0FBT1AsR0FBUCxDQUFXcEIsS0FBWCxDQUFpQixHQUFqQixFQUFzQlAsTUFBN0I7QUFDSCxLQUZELE1BRU87QUFDSCxlQUFPLENBQVA7QUFDSDtBQUNKO0FBQ0QsU0FBUzQxQyxtQkFBVCxDQUE2QnovQixHQUE3QixFQUFrQ08sSUFBbEMsRUFBd0M5VSxJQUF4QyxFQUE4QztBQUMxQyxRQUFJaTBDLFVBQVUsSUFBSUMsR0FBSixDQUFRcC9CLElBQVIsQ0FBZDtBQUNBLFFBQUlzQyxTQUFTLEVBQWI7QUFDQWhDLFdBQU9OLElBQVAsQ0FBWVAsR0FBWixFQUFpQitOLE9BQWpCLENBQXlCLFVBQVV6SixDQUFWLEVBQWE7QUFDbEMsWUFBSSxDQUFDbzdCLFFBQVF0a0MsR0FBUixDQUFZa0osQ0FBWixDQUFMLEVBQXFCO0FBQ2pCLGdCQUFJa0MsT0FBTy9hLE9BQU9BLE9BQU8sR0FBUCxHQUFhNlksQ0FBcEIsR0FBd0IsSUFBbkM7QUFDQXpCLG1CQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQnR0QixJQUFwQixFQUEwQnhHLElBQUlzRSxDQUFKLENBQTFCLEVBQWtDLDJCQUEyQkEsQ0FBM0IsR0FBK0IsR0FBakUsQ0FBWjtBQUNIO0FBQ0osS0FMRDtBQU1BLFdBQU96QixNQUFQO0FBQ0g7QUFDRCxTQUFTKzhCLGVBQVQsQ0FBeUI3ekMsTUFBekIsRUFBaUN2QyxDQUFqQyxFQUFvQztBQUNoQyxRQUFJcVosU0FBUyxFQUFiO0FBQ0EsUUFBSWc5QixhQUFhLENBQ2IsTUFEYSxFQUViLEtBRmEsRUFHYixVQUhhLENBQWpCO0FBS0FoOUIsV0FBT3JZLElBQVAsQ0FBWXRCLEtBQVosQ0FBa0IyWixNQUFsQixFQUEwQjQ4QixvQkFBb0IxekMsTUFBcEIsRUFBNEI4ekMsVUFBNUIsRUFBd0MsUUFBeEMsQ0FBMUI7QUFDQSxRQUFJQyxtQkFBbUIsc0JBQXZCO0FBQ0EsUUFBSSxDQUFDUixRQUFRdnpDLE9BQU9QLEdBQWYsRUFBb0JzMEMsZ0JBQXBCLENBQUwsRUFBNEM7QUFDeENqOUIsZUFBT3JZLElBQVAsQ0FBWSxJQUFJc3BDLGVBQUosQ0FBb0IsYUFBYXRxQyxDQUFiLEdBQWlCLEdBQXJDLEVBQTBDdUMsT0FBT1AsR0FBakQsRUFBc0QsK0NBQXRELENBQVo7QUFDSDtBQUNELFdBQU9xWCxNQUFQO0FBQ0g7QUFDRCxTQUFTazlCLGdCQUFULENBQTBCeHVDLE9BQTFCLEVBQW1DO0FBQy9CLFFBQUlzUixTQUFTLEVBQWI7QUFDQSxRQUFJbTlCLFFBQVEsQ0FBWjtBQUNBbi9CLFdBQU9OLElBQVAsQ0FBWWhQLE9BQVosRUFBcUJ3YyxPQUFyQixDQUE2QixVQUFVakMsQ0FBVixFQUFhdGlCLENBQWIsRUFBZ0I7QUFDekMsWUFBSXkyQyxlQUFlTCxnQkFBZ0JydUMsUUFBUXVhLENBQVIsQ0FBaEIsRUFBNEJ0aUIsQ0FBNUIsQ0FBbkI7QUFDQSxZQUFJLENBQUN5MkMsYUFBYXAyQyxNQUFsQixFQUEwQjtBQUN0Qm0yQyxvQkFBUUEsUUFBUVIsZUFBZWp1QyxRQUFRdWEsQ0FBUixDQUFmLENBQWhCO0FBQ0g7QUFDRGpKLGVBQU9yWSxJQUFQLENBQVl0QixLQUFaLENBQWtCMlosTUFBbEIsRUFBMEJvOUIsWUFBMUI7QUFDSCxLQU5EO0FBT0EsUUFBSUQsUUFBUVgsb0JBQVosRUFBa0M7QUFDOUJ4OEIsZUFBT3JZLElBQVAsQ0FBWSxJQUFJc3BDLGVBQUosQ0FBb0IsU0FBcEIsRUFBK0IsSUFBL0IsRUFBcUMseUJBQXlCdUwsb0JBQXpCLEdBQWdELG1CQUFyRixDQUFaO0FBQ0g7QUFDRCxXQUFPeDhCLE1BQVA7QUFDSDtBQUNELFNBQVNxOUIsYUFBVCxDQUF1QnB5QyxLQUF2QixFQUE4QnF5QyxRQUE5QixFQUF3QztBQUNwQyxRQUFJdDlCLFNBQVMsRUFBYjtBQUNBLFFBQUl1OUIseUJBQXlCLENBQ3pCLE9BRHlCLEVBRXpCLElBRnlCLEVBR3pCLGNBSHlCLEVBSXpCLE9BSnlCLEVBS3pCLFNBTHlCLEVBTXpCLFVBTnlCLEVBT3pCLFlBUHlCLENBQTdCO0FBU0EsUUFBSUMsbUJBQW1CWixvQkFBb0IzeEMsS0FBcEIsRUFBMkJxeUMsU0FBU3BpQyxNQUFULENBQWdCcWlDLHNCQUFoQixDQUEzQixDQUF2QjtBQUNBdjlCLFdBQU9yWSxJQUFQLENBQVl0QixLQUFaLENBQWtCMlosTUFBbEIsRUFBMEJ3OUIsZ0JBQTFCO0FBQ0EsUUFBSXZ5QyxNQUFNeEIsT0FBTixHQUFnQjh5QyxzQkFBaEIsSUFBMEN0eEMsTUFBTXhCLE9BQU4sR0FBZ0I4eUMsc0JBQTlELEVBQXNGO0FBQ2xGdjhCLGVBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CLFNBQXBCLEVBQStCaG1DLE1BQU14QixPQUFyQyxFQUE4QywyQkFBMkI4eUMsc0JBQXpFLENBQVo7QUFDSDtBQUNELFFBQUlrQixrQkFBa0IsdURBQXRCO0FBQ0EsUUFBSSxDQUFDaEIsUUFBUXh4QyxNQUFNcUksTUFBZCxFQUFzQm1xQyxlQUF0QixDQUFMLEVBQTZDO0FBQ3pDejlCLGVBQU9yWSxJQUFQLENBQVksSUFBSXNwQyxlQUFKLENBQW9CLFFBQXBCLEVBQThCaG1DLE1BQU1xSSxNQUFwQyxFQUE0QywrQ0FBNUMsQ0FBWjtBQUNIO0FBQ0QsUUFBSW9xQyxtQkFBbUIsbURBQXZCO0FBQ0EsUUFBSSxDQUFDakIsUUFBUXh4QyxNQUFNbkIsTUFBZCxFQUFzQjR6QyxnQkFBdEIsQ0FBTCxFQUE4QztBQUMxQzE5QixlQUFPclksSUFBUCxDQUFZLElBQUlzcEMsZUFBSixDQUFvQixRQUFwQixFQUE4QmhtQyxNQUFNbkIsTUFBcEMsRUFBNEMsZ0RBQTVDLENBQVo7QUFDSDtBQUNELFFBQUk2ekMsb0JBQW9CLG9CQUF4QjtBQUNBLFFBQUksQ0FBQ2xCLFFBQVF4eEMsTUFBTXNCLFVBQWQsRUFBMEJveEMsaUJBQTFCLENBQUwsRUFBbUQ7QUFDL0MzOUIsZUFBT3JZLElBQVAsQ0FBWSxJQUFJc3BDLGVBQUosQ0FBb0IsWUFBcEIsRUFBa0NobUMsTUFBTXNCLFVBQXhDLEVBQW9ELDRDQUFwRCxDQUFaO0FBQ0g7QUFDRCxXQUFPeVQsTUFBUDtBQUNIO0FBQ0QsU0FBUzQ5QiwwQkFBVCxDQUFvQzN5QyxLQUFwQyxFQUEyQztBQUN2QyxRQUFJZ2UsSUFBSWhlLEtBQVI7QUFDQSxRQUFJO0FBQ0FnZSxZQUFJbXpCLFVBQVVuekIsQ0FBVixDQUFKO0FBQ0gsS0FGRCxDQUVFLE9BQU8xZCxDQUFQLEVBQVU7QUFDUixlQUFPLENBQUNBLENBQUQsQ0FBUDtBQUNIO0FBQ0QsUUFBSXlVLFNBQVM0MUIsaUJBQWlCM3NCLENBQWpCLEVBQW9Cbk4sRUFBcEIsRUFBd0JaLE1BQXhCLENBQStCbWlDLGNBQWNwMEIsQ0FBZCxFQUFpQmpMLE9BQU9OLElBQVAsQ0FBWTVCLEdBQUd4SixLQUFmLENBQWpCLENBQS9CLENBQWI7QUFDQSxRQUFJMlcsRUFBRXZhLE9BQU4sRUFBZTtBQUNYc1IsaUJBQVNBLE9BQU85RSxNQUFQLENBQWNnaUMsaUJBQWlCajBCLEVBQUV2YSxPQUFuQixDQUFkLENBQVQ7QUFDSDtBQUNELFdBQU9zUixNQUFQO0FBQ0g7O0FBRUQsSUFBSWtyQixlQUFlO0FBQ2YzQyxxQkFBaUJBLGVBREY7QUFFZlEsa0JBQWNBLFlBRkM7QUFHZmdELHdCQUFvQkEsa0JBSEw7QUFJZi9DLHNCQUFrQkEsZ0JBSkg7QUFLZk8sOEJBQTBCQSx3QkFMWDtBQU1mVSxpQ0FBNkJBLDJCQU5kO0FBT2ZkLDRCQUF3QkEsc0JBUFQ7QUFRZkcsNkJBQXlCQSx1QkFSVjtBQVNmTSwyQkFBdUJBO0FBVFIsQ0FBbkI7QUFXQSxJQUFJaVUsZ0JBQWdCO0FBQ2hCdFQscUJBQWlCQSxlQUREO0FBRWhCM0Qsb0JBQWdCQSxjQUZBO0FBR2hCcmIsZ0JBQVltYjtBQUhJLENBQXBCO0FBS0EsSUFBSW9YLFFBQVE7QUFDUm56QixnQkFBWUEsVUFESjtBQUVSRSxlQUFXQSxTQUZIO0FBR1JFLGtCQUFjQTtBQUhOLENBQVo7QUFLQXV4QixjQUFjcnBCLE1BQWQsR0FBdUJxcEIsYUFBdkI7QUFDQUEsY0FBY3lCLE1BQWQsR0FBdUJ6QixhQUF2Qjs7UUFFU2x3QyxLLEdBQUFBLEs7UUFBeUJxZ0IsWSxHQUFsQjJrQixjO1FBQWdDSCxlLEdBQUFBLGU7UUFBaUJuRCxTLEdBQUFBLFM7UUFBOEIzQixhLEdBQW5CVSxlO1FBQWtDd0IsVyxHQUFBQSxXO1FBQTJCMlAsSSxHQUFkbE4sVTtRQUFvQ3g2QixVLEdBQWhCNDBCLFk7UUFBNEMrUyxhLEdBQWhCaFMsWTtRQUErQng4QixNLEdBQUFBLE07UUFBeUJrakMsUSxHQUFqQmtMLGE7UUFBaUNFLE0sR0FBTmppQyxFO1FBQWM4eEIsTyxHQUFBQSxPO1FBQVM5eEIsRSxHQUFBQSxFO1FBQXFCczJCLFEsR0FBakJrSyxhO1FBQTJCc0IsMEIsR0FBQUEsMEI7UUFBNEJFLEssR0FBQUEsSztBQUMvVCxvQzs7Ozs7Ozs7Ozs7OztBQ2prZEE7O0FBRUFoL0IsUUFBUW8vQixVQUFSLEdBQXFCQSxVQUFyQjtBQUNBcC9CLFFBQVFxL0IsV0FBUixHQUFzQkEsV0FBdEI7QUFDQXIvQixRQUFRcy9CLGFBQVIsR0FBd0JBLGFBQXhCOztBQUVBLElBQUlDLFNBQVMsRUFBYjtBQUNBLElBQUlDLFlBQVksRUFBaEI7QUFDQSxJQUFJQyxNQUFNLE9BQU9DLFVBQVAsS0FBc0IsV0FBdEIsR0FBb0NBLFVBQXBDLEdBQWlEMzNDLEtBQTNEOztBQUVBLElBQUk0M0MsT0FBTyxrRUFBWDtBQUNBLEtBQUssSUFBSTkzQyxJQUFJLENBQVIsRUFBV3dkLE1BQU1zNkIsS0FBS3ozQyxNQUEzQixFQUFtQ0wsSUFBSXdkLEdBQXZDLEVBQTRDLEVBQUV4ZCxDQUE5QyxFQUFpRDtBQUMvQzAzQyxTQUFPMTNDLENBQVAsSUFBWTgzQyxLQUFLOTNDLENBQUwsQ0FBWjtBQUNBMjNDLFlBQVVHLEtBQUszOUIsVUFBTCxDQUFnQm5hLENBQWhCLENBQVYsSUFBZ0NBLENBQWhDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBMjNDLFVBQVUsSUFBSXg5QixVQUFKLENBQWUsQ0FBZixDQUFWLElBQStCLEVBQS9CO0FBQ0F3OUIsVUFBVSxJQUFJeDlCLFVBQUosQ0FBZSxDQUFmLENBQVYsSUFBK0IsRUFBL0I7O0FBRUEsU0FBUzQ5QixPQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUNyQixNQUFJeDZCLE1BQU13NkIsSUFBSTMzQyxNQUFkOztBQUVBLE1BQUltZCxNQUFNLENBQU4sR0FBVSxDQUFkLEVBQWlCO0FBQ2YsVUFBTSxJQUFJemEsS0FBSixDQUFVLGdEQUFWLENBQU47QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSWsxQyxXQUFXRCxJQUFJajNDLE9BQUosQ0FBWSxHQUFaLENBQWY7QUFDQSxNQUFJazNDLGFBQWEsQ0FBQyxDQUFsQixFQUFxQkEsV0FBV3o2QixHQUFYOztBQUVyQixNQUFJMDZCLGtCQUFrQkQsYUFBYXo2QixHQUFiLEdBQ2xCLENBRGtCLEdBRWxCLElBQUt5NkIsV0FBVyxDQUZwQjs7QUFJQSxTQUFPLENBQUNBLFFBQUQsRUFBV0MsZUFBWCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFTWCxVQUFULENBQXFCUyxHQUFyQixFQUEwQjtBQUN4QixNQUFJRyxPQUFPSixRQUFRQyxHQUFSLENBQVg7QUFDQSxNQUFJQyxXQUFXRSxLQUFLLENBQUwsQ0FBZjtBQUNBLE1BQUlELGtCQUFrQkMsS0FBSyxDQUFMLENBQXRCO0FBQ0EsU0FBUSxDQUFDRixXQUFXQyxlQUFaLElBQStCLENBQS9CLEdBQW1DLENBQXBDLEdBQXlDQSxlQUFoRDtBQUNEOztBQUVELFNBQVNFLFdBQVQsQ0FBc0JKLEdBQXRCLEVBQTJCQyxRQUEzQixFQUFxQ0MsZUFBckMsRUFBc0Q7QUFDcEQsU0FBUSxDQUFDRCxXQUFXQyxlQUFaLElBQStCLENBQS9CLEdBQW1DLENBQXBDLEdBQXlDQSxlQUFoRDtBQUNEOztBQUVELFNBQVNWLFdBQVQsQ0FBc0JRLEdBQXRCLEVBQTJCO0FBQ3pCLE1BQUlLLEdBQUo7QUFDQSxNQUFJRixPQUFPSixRQUFRQyxHQUFSLENBQVg7QUFDQSxNQUFJQyxXQUFXRSxLQUFLLENBQUwsQ0FBZjtBQUNBLE1BQUlELGtCQUFrQkMsS0FBSyxDQUFMLENBQXRCOztBQUVBLE1BQUlHLE1BQU0sSUFBSVYsR0FBSixDQUFRUSxZQUFZSixHQUFaLEVBQWlCQyxRQUFqQixFQUEyQkMsZUFBM0IsQ0FBUixDQUFWOztBQUVBLE1BQUlLLFVBQVUsQ0FBZDs7QUFFQTtBQUNBLE1BQUkvNkIsTUFBTTA2QixrQkFBa0IsQ0FBbEIsR0FDTkQsV0FBVyxDQURMLEdBRU5BLFFBRko7O0FBSUEsTUFBSWo0QyxDQUFKO0FBQ0EsT0FBS0EsSUFBSSxDQUFULEVBQVlBLElBQUl3ZCxHQUFoQixFQUFxQnhkLEtBQUssQ0FBMUIsRUFBNkI7QUFDM0JxNEMsVUFDR1YsVUFBVUssSUFBSTc5QixVQUFKLENBQWVuYSxDQUFmLENBQVYsS0FBZ0MsRUFBakMsR0FDQzIzQyxVQUFVSyxJQUFJNzlCLFVBQUosQ0FBZW5hLElBQUksQ0FBbkIsQ0FBVixLQUFvQyxFQURyQyxHQUVDMjNDLFVBQVVLLElBQUk3OUIsVUFBSixDQUFlbmEsSUFBSSxDQUFuQixDQUFWLEtBQW9DLENBRnJDLEdBR0EyM0MsVUFBVUssSUFBSTc5QixVQUFKLENBQWVuYSxJQUFJLENBQW5CLENBQVYsQ0FKRjtBQUtBczRDLFFBQUlDLFNBQUosSUFBa0JGLE9BQU8sRUFBUixHQUFjLElBQS9CO0FBQ0FDLFFBQUlDLFNBQUosSUFBa0JGLE9BQU8sQ0FBUixHQUFhLElBQTlCO0FBQ0FDLFFBQUlDLFNBQUosSUFBaUJGLE1BQU0sSUFBdkI7QUFDRDs7QUFFRCxNQUFJSCxvQkFBb0IsQ0FBeEIsRUFBMkI7QUFDekJHLFVBQ0dWLFVBQVVLLElBQUk3OUIsVUFBSixDQUFlbmEsQ0FBZixDQUFWLEtBQWdDLENBQWpDLEdBQ0MyM0MsVUFBVUssSUFBSTc5QixVQUFKLENBQWVuYSxJQUFJLENBQW5CLENBQVYsS0FBb0MsQ0FGdkM7QUFHQXM0QyxRQUFJQyxTQUFKLElBQWlCRixNQUFNLElBQXZCO0FBQ0Q7O0FBRUQsTUFBSUgsb0JBQW9CLENBQXhCLEVBQTJCO0FBQ3pCRyxVQUNHVixVQUFVSyxJQUFJNzlCLFVBQUosQ0FBZW5hLENBQWYsQ0FBVixLQUFnQyxFQUFqQyxHQUNDMjNDLFVBQVVLLElBQUk3OUIsVUFBSixDQUFlbmEsSUFBSSxDQUFuQixDQUFWLEtBQW9DLENBRHJDLEdBRUMyM0MsVUFBVUssSUFBSTc5QixVQUFKLENBQWVuYSxJQUFJLENBQW5CLENBQVYsS0FBb0MsQ0FIdkM7QUFJQXM0QyxRQUFJQyxTQUFKLElBQWtCRixPQUFPLENBQVIsR0FBYSxJQUE5QjtBQUNBQyxRQUFJQyxTQUFKLElBQWlCRixNQUFNLElBQXZCO0FBQ0Q7O0FBRUQsU0FBT0MsR0FBUDtBQUNEOztBQUVELFNBQVNFLGVBQVQsQ0FBMEI5cUIsR0FBMUIsRUFBK0I7QUFDN0IsU0FBT2dxQixPQUFPaHFCLE9BQU8sRUFBUCxHQUFZLElBQW5CLElBQ0xncUIsT0FBT2hxQixPQUFPLEVBQVAsR0FBWSxJQUFuQixDQURLLEdBRUxncUIsT0FBT2hxQixPQUFPLENBQVAsR0FBVyxJQUFsQixDQUZLLEdBR0xncUIsT0FBT2hxQixNQUFNLElBQWIsQ0FIRjtBQUlEOztBQUVELFNBQVMrcUIsV0FBVCxDQUFzQkMsS0FBdEIsRUFBNkJ4aEMsS0FBN0IsRUFBb0NQLEdBQXBDLEVBQXlDO0FBQ3ZDLE1BQUkwaEMsR0FBSjtBQUNBLE1BQUlyK0IsU0FBUyxFQUFiO0FBQ0EsT0FBSyxJQUFJaGEsSUFBSWtYLEtBQWIsRUFBb0JsWCxJQUFJMlcsR0FBeEIsRUFBNkIzVyxLQUFLLENBQWxDLEVBQXFDO0FBQ25DcTRDLFVBQ0UsQ0FBRUssTUFBTTE0QyxDQUFOLEtBQVksRUFBYixHQUFtQixRQUFwQixLQUNFMDRDLE1BQU0xNEMsSUFBSSxDQUFWLEtBQWdCLENBQWpCLEdBQXNCLE1BRHZCLEtBRUMwNEMsTUFBTTE0QyxJQUFJLENBQVYsSUFBZSxJQUZoQixDQURGO0FBSUFnYSxXQUFPaFosSUFBUCxDQUFZdzNDLGdCQUFnQkgsR0FBaEIsQ0FBWjtBQUNEO0FBQ0QsU0FBT3IrQixPQUFPNU8sSUFBUCxDQUFZLEVBQVosQ0FBUDtBQUNEOztBQUVELFNBQVNxc0MsYUFBVCxDQUF3QmlCLEtBQXhCLEVBQStCO0FBQzdCLE1BQUlMLEdBQUo7QUFDQSxNQUFJNzZCLE1BQU1rN0IsTUFBTXI0QyxNQUFoQjtBQUNBLE1BQUlzNEMsYUFBYW43QixNQUFNLENBQXZCLENBSDZCLENBR0o7QUFDekIsTUFBSXBiLFFBQVEsRUFBWjtBQUNBLE1BQUl3MkMsaUJBQWlCLEtBQXJCLENBTDZCLENBS0Y7O0FBRTNCO0FBQ0EsT0FBSyxJQUFJNTRDLElBQUksQ0FBUixFQUFXNnhCLE9BQU9yVSxNQUFNbTdCLFVBQTdCLEVBQXlDMzRDLElBQUk2eEIsSUFBN0MsRUFBbUQ3eEIsS0FBSzQ0QyxjQUF4RCxFQUF3RTtBQUN0RXgyQyxVQUFNcEIsSUFBTixDQUFXeTNDLFlBQ1RDLEtBRFMsRUFDRjE0QyxDQURFLEVBQ0VBLElBQUk0NEMsY0FBTCxHQUF1Qi9tQixJQUF2QixHQUE4QkEsSUFBOUIsR0FBc0M3eEIsSUFBSTQ0QyxjQUQzQyxDQUFYO0FBR0Q7O0FBRUQ7QUFDQSxNQUFJRCxlQUFlLENBQW5CLEVBQXNCO0FBQ3BCTixVQUFNSyxNQUFNbDdCLE1BQU0sQ0FBWixDQUFOO0FBQ0FwYixVQUFNcEIsSUFBTixDQUNFMDJDLE9BQU9XLE9BQU8sQ0FBZCxJQUNBWCxPQUFRVyxPQUFPLENBQVIsR0FBYSxJQUFwQixDQURBLEdBRUEsSUFIRjtBQUtELEdBUEQsTUFPTyxJQUFJTSxlQUFlLENBQW5CLEVBQXNCO0FBQzNCTixVQUFNLENBQUNLLE1BQU1sN0IsTUFBTSxDQUFaLEtBQWtCLENBQW5CLElBQXdCazdCLE1BQU1sN0IsTUFBTSxDQUFaLENBQTlCO0FBQ0FwYixVQUFNcEIsSUFBTixDQUNFMDJDLE9BQU9XLE9BQU8sRUFBZCxJQUNBWCxPQUFRVyxPQUFPLENBQVIsR0FBYSxJQUFwQixDQURBLEdBRUFYLE9BQVFXLE9BQU8sQ0FBUixHQUFhLElBQXBCLENBRkEsR0FHQSxHQUpGO0FBTUQ7O0FBRUQsU0FBT2oyQyxNQUFNZ0osSUFBTixDQUFXLEVBQVgsQ0FBUDtBQUNELEM7Ozs7Ozs7Ozs7OztBQ3ZKRDs7Ozs7O0FBTUE7O0FBRUE7O0FBRUEsSUFBSXl0QyxTQUFTQyxtQkFBT0EsQ0FBQyxvREFBUixDQUFiO0FBQ0EsSUFBSUMsVUFBVUQsbUJBQU9BLENBQUMsZ0RBQVIsQ0FBZDtBQUNBLElBQUkzNEMsVUFBVTI0QyxtQkFBT0EsQ0FBQyxnREFBUixDQUFkOztBQUVBM2dDLFFBQVF1OUIsTUFBUixHQUFpQkEsTUFBakI7QUFDQXY5QixRQUFRNmdDLFVBQVIsR0FBcUJBLFVBQXJCO0FBQ0E3Z0MsUUFBUThnQyxpQkFBUixHQUE0QixFQUE1Qjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBdkQsT0FBT3dELG1CQUFQLEdBQTZCcmhDLE9BQU9xaEMsbUJBQVAsS0FBK0JsMUMsU0FBL0IsR0FDekI2VCxPQUFPcWhDLG1CQURrQixHQUV6QkMsbUJBRko7O0FBSUE7OztBQUdBaGhDLFFBQVFpaEMsVUFBUixHQUFxQkEsWUFBckI7O0FBRUEsU0FBU0QsaUJBQVQsR0FBOEI7QUFDNUIsTUFBSTtBQUNGLFFBQUliLE1BQU0sSUFBSVQsVUFBSixDQUFlLENBQWYsQ0FBVjtBQUNBUyxRQUFJdHlCLFNBQUosR0FBZ0IsRUFBQ0EsV0FBVzZ4QixXQUFXNTZCLFNBQXZCLEVBQWtDbzhCLEtBQUssZUFBWTtBQUFFLGVBQU8sRUFBUDtBQUFXLE9BQWhFLEVBQWhCO0FBQ0EsV0FBT2YsSUFBSWUsR0FBSixPQUFjLEVBQWQsSUFBb0I7QUFDdkIsV0FBT2YsSUFBSWdCLFFBQVgsS0FBd0IsVUFEckIsSUFDbUM7QUFDdENoQixRQUFJZ0IsUUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIvQixVQUFuQixLQUFrQyxDQUZ0QyxDQUhFLENBS3NDO0FBQ3pDLEdBTkQsQ0FNRSxPQUFPM3lDLENBQVAsRUFBVTtBQUNWLFdBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3cwQyxVQUFULEdBQXVCO0FBQ3JCLFNBQU8xRCxPQUFPd0QsbUJBQVAsR0FDSCxVQURHLEdBRUgsVUFGSjtBQUdEOztBQUVELFNBQVNLLFlBQVQsQ0FBdUJDLElBQXZCLEVBQTZCbjVDLE1BQTdCLEVBQXFDO0FBQ25DLE1BQUkrNEMsZUFBZS80QyxNQUFuQixFQUEyQjtBQUN6QixVQUFNLElBQUlzWixVQUFKLENBQWUsNEJBQWYsQ0FBTjtBQUNEO0FBQ0QsTUFBSSs3QixPQUFPd0QsbUJBQVgsRUFBZ0M7QUFDOUI7QUFDQU0sV0FBTyxJQUFJM0IsVUFBSixDQUFleDNDLE1BQWYsQ0FBUDtBQUNBbTVDLFNBQUt4ekIsU0FBTCxHQUFpQjB2QixPQUFPejRCLFNBQXhCO0FBQ0QsR0FKRCxNQUlPO0FBQ0w7QUFDQSxRQUFJdThCLFNBQVMsSUFBYixFQUFtQjtBQUNqQkEsYUFBTyxJQUFJOUQsTUFBSixDQUFXcjFDLE1BQVgsQ0FBUDtBQUNEO0FBQ0RtNUMsU0FBS241QyxNQUFMLEdBQWNBLE1BQWQ7QUFDRDs7QUFFRCxTQUFPbTVDLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBLFNBQVM5RCxNQUFULENBQWlCOTRCLEdBQWpCLEVBQXNCNjhCLGdCQUF0QixFQUF3Q3A1QyxNQUF4QyxFQUFnRDtBQUM5QyxNQUFJLENBQUNxMUMsT0FBT3dELG1CQUFSLElBQStCLEVBQUUsZ0JBQWdCeEQsTUFBbEIsQ0FBbkMsRUFBOEQ7QUFDNUQsV0FBTyxJQUFJQSxNQUFKLENBQVc5NEIsR0FBWCxFQUFnQjY4QixnQkFBaEIsRUFBa0NwNUMsTUFBbEMsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsTUFBSSxPQUFPdWMsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCLFFBQUksT0FBTzY4QixnQkFBUCxLQUE0QixRQUFoQyxFQUEwQztBQUN4QyxZQUFNLElBQUkxMkMsS0FBSixDQUNKLG1FQURJLENBQU47QUFHRDtBQUNELFdBQU8yMkMsWUFBWSxJQUFaLEVBQWtCOThCLEdBQWxCLENBQVA7QUFDRDtBQUNELFNBQU9rSSxLQUFLLElBQUwsRUFBV2xJLEdBQVgsRUFBZ0I2OEIsZ0JBQWhCLEVBQWtDcDVDLE1BQWxDLENBQVA7QUFDRDs7QUFFRHExQyxPQUFPaUUsUUFBUCxHQUFrQixJQUFsQixDLENBQXVCOztBQUV2QjtBQUNBakUsT0FBT2tFLFFBQVAsR0FBa0IsVUFBVXRCLEdBQVYsRUFBZTtBQUMvQkEsTUFBSXR5QixTQUFKLEdBQWdCMHZCLE9BQU96NEIsU0FBdkI7QUFDQSxTQUFPcTdCLEdBQVA7QUFDRCxDQUhEOztBQUtBLFNBQVN4ekIsSUFBVCxDQUFlMDBCLElBQWYsRUFBcUJ0dEMsS0FBckIsRUFBNEJ1dEMsZ0JBQTVCLEVBQThDcDVDLE1BQTlDLEVBQXNEO0FBQ3BELE1BQUksT0FBTzZMLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsVUFBTSxJQUFJdVUsU0FBSixDQUFjLHVDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJLE9BQU9vNUIsV0FBUCxLQUF1QixXQUF2QixJQUFzQzN0QyxpQkFBaUIydEMsV0FBM0QsRUFBd0U7QUFDdEUsV0FBT0MsZ0JBQWdCTixJQUFoQixFQUFzQnR0QyxLQUF0QixFQUE2QnV0QyxnQkFBN0IsRUFBK0NwNUMsTUFBL0MsQ0FBUDtBQUNEOztBQUVELE1BQUksT0FBTzZMLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsV0FBTzBlLFdBQVc0dUIsSUFBWCxFQUFpQnR0QyxLQUFqQixFQUF3QnV0QyxnQkFBeEIsQ0FBUDtBQUNEOztBQUVELFNBQU9NLFdBQVdQLElBQVgsRUFBaUJ0dEMsS0FBakIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBd3BDLE9BQU81d0IsSUFBUCxHQUFjLFVBQVU1WSxLQUFWLEVBQWlCdXRDLGdCQUFqQixFQUFtQ3A1QyxNQUFuQyxFQUEyQztBQUN2RCxTQUFPeWtCLEtBQUssSUFBTCxFQUFXNVksS0FBWCxFQUFrQnV0QyxnQkFBbEIsRUFBb0NwNUMsTUFBcEMsQ0FBUDtBQUNELENBRkQ7O0FBSUEsSUFBSXExQyxPQUFPd0QsbUJBQVgsRUFBZ0M7QUFDOUJ4RCxTQUFPejRCLFNBQVAsQ0FBaUIrSSxTQUFqQixHQUE2QjZ4QixXQUFXNTZCLFNBQXhDO0FBQ0F5NEIsU0FBTzF2QixTQUFQLEdBQW1CNnhCLFVBQW5CO0FBQ0EsTUFBSSxPQUFPbUMsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBT0MsT0FBeEMsSUFDQXZFLE9BQU9zRSxPQUFPQyxPQUFkLE1BQTJCdkUsTUFEL0IsRUFDdUM7QUFDckM7QUFDQXIrQixXQUFPNjVCLGNBQVAsQ0FBc0J3RSxNQUF0QixFQUE4QnNFLE9BQU9DLE9BQXJDLEVBQThDO0FBQzVDL3RDLGFBQU8sSUFEcUM7QUFFNUNndUMsb0JBQWM7QUFGOEIsS0FBOUM7QUFJRDtBQUNGOztBQUVELFNBQVNDLFVBQVQsQ0FBcUJsekMsSUFBckIsRUFBMkI7QUFDekIsTUFBSSxPQUFPQSxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCLFVBQU0sSUFBSXdaLFNBQUosQ0FBYyxrQ0FBZCxDQUFOO0FBQ0QsR0FGRCxNQUVPLElBQUl4WixPQUFPLENBQVgsRUFBYztBQUNuQixVQUFNLElBQUkwUyxVQUFKLENBQWUsc0NBQWYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3lnQyxLQUFULENBQWdCWixJQUFoQixFQUFzQnZ5QyxJQUF0QixFQUE0QjRILElBQTVCLEVBQWtDcEIsUUFBbEMsRUFBNEM7QUFDMUMwc0MsYUFBV2x6QyxJQUFYO0FBQ0EsTUFBSUEsUUFBUSxDQUFaLEVBQWU7QUFDYixXQUFPc3lDLGFBQWFDLElBQWIsRUFBbUJ2eUMsSUFBbkIsQ0FBUDtBQUNEO0FBQ0QsTUFBSTRILFNBQVM3SyxTQUFiLEVBQXdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFdBQU8sT0FBT3lKLFFBQVAsS0FBb0IsUUFBcEIsR0FDSDhyQyxhQUFhQyxJQUFiLEVBQW1CdnlDLElBQW5CLEVBQXlCNEgsSUFBekIsQ0FBOEJBLElBQTlCLEVBQW9DcEIsUUFBcEMsQ0FERyxHQUVIOHJDLGFBQWFDLElBQWIsRUFBbUJ2eUMsSUFBbkIsRUFBeUI0SCxJQUF6QixDQUE4QkEsSUFBOUIsQ0FGSjtBQUdEO0FBQ0QsU0FBTzBxQyxhQUFhQyxJQUFiLEVBQW1CdnlDLElBQW5CLENBQVA7QUFDRDs7QUFFRDs7OztBQUlBeXVDLE9BQU8wRSxLQUFQLEdBQWUsVUFBVW56QyxJQUFWLEVBQWdCNEgsSUFBaEIsRUFBc0JwQixRQUF0QixFQUFnQztBQUM3QyxTQUFPMnNDLE1BQU0sSUFBTixFQUFZbnpDLElBQVosRUFBa0I0SCxJQUFsQixFQUF3QnBCLFFBQXhCLENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVNpc0MsV0FBVCxDQUFzQkYsSUFBdEIsRUFBNEJ2eUMsSUFBNUIsRUFBa0M7QUFDaENrekMsYUFBV2x6QyxJQUFYO0FBQ0F1eUMsU0FBT0QsYUFBYUMsSUFBYixFQUFtQnZ5QyxPQUFPLENBQVAsR0FBVyxDQUFYLEdBQWVvekMsUUFBUXB6QyxJQUFSLElBQWdCLENBQWxELENBQVA7QUFDQSxNQUFJLENBQUN5dUMsT0FBT3dELG1CQUFaLEVBQWlDO0FBQy9CLFNBQUssSUFBSWw1QyxJQUFJLENBQWIsRUFBZ0JBLElBQUlpSCxJQUFwQixFQUEwQixFQUFFakgsQ0FBNUIsRUFBK0I7QUFDN0J3NUMsV0FBS3g1QyxDQUFMLElBQVUsQ0FBVjtBQUNEO0FBQ0Y7QUFDRCxTQUFPdzVDLElBQVA7QUFDRDs7QUFFRDs7O0FBR0E5RCxPQUFPZ0UsV0FBUCxHQUFxQixVQUFVenlDLElBQVYsRUFBZ0I7QUFDbkMsU0FBT3l5QyxZQUFZLElBQVosRUFBa0J6eUMsSUFBbEIsQ0FBUDtBQUNELENBRkQ7QUFHQTs7O0FBR0F5dUMsT0FBTzRFLGVBQVAsR0FBeUIsVUFBVXJ6QyxJQUFWLEVBQWdCO0FBQ3ZDLFNBQU95eUMsWUFBWSxJQUFaLEVBQWtCenlDLElBQWxCLENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVMyakIsVUFBVCxDQUFxQjR1QixJQUFyQixFQUEyQjVtQyxNQUEzQixFQUFtQ25GLFFBQW5DLEVBQTZDO0FBQzNDLE1BQUksT0FBT0EsUUFBUCxLQUFvQixRQUFwQixJQUFnQ0EsYUFBYSxFQUFqRCxFQUFxRDtBQUNuREEsZUFBVyxNQUFYO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDaW9DLE9BQU82RSxVQUFQLENBQWtCOXNDLFFBQWxCLENBQUwsRUFBa0M7QUFDaEMsVUFBTSxJQUFJZ1QsU0FBSixDQUFjLDRDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJcGdCLFNBQVNrM0MsV0FBVzNrQyxNQUFYLEVBQW1CbkYsUUFBbkIsSUFBK0IsQ0FBNUM7QUFDQStyQyxTQUFPRCxhQUFhQyxJQUFiLEVBQW1CbjVDLE1BQW5CLENBQVA7O0FBRUEsTUFBSXExQixTQUFTOGpCLEtBQUtnQixLQUFMLENBQVc1bkMsTUFBWCxFQUFtQm5GLFFBQW5CLENBQWI7O0FBRUEsTUFBSWlvQixXQUFXcjFCLE1BQWYsRUFBdUI7QUFDckI7QUFDQTtBQUNBO0FBQ0FtNUMsV0FBT0EsS0FBS3J1QyxLQUFMLENBQVcsQ0FBWCxFQUFjdXFCLE1BQWQsQ0FBUDtBQUNEOztBQUVELFNBQU84akIsSUFBUDtBQUNEOztBQUVELFNBQVNpQixhQUFULENBQXdCakIsSUFBeEIsRUFBOEJubkMsS0FBOUIsRUFBcUM7QUFDbkMsTUFBSWhTLFNBQVNnUyxNQUFNaFMsTUFBTixHQUFlLENBQWYsR0FBbUIsQ0FBbkIsR0FBdUJnNkMsUUFBUWhvQyxNQUFNaFMsTUFBZCxJQUF3QixDQUE1RDtBQUNBbTVDLFNBQU9ELGFBQWFDLElBQWIsRUFBbUJuNUMsTUFBbkIsQ0FBUDtBQUNBLE9BQUssSUFBSUwsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSyxNQUFwQixFQUE0QkwsS0FBSyxDQUFqQyxFQUFvQztBQUNsQ3c1QyxTQUFLeDVDLENBQUwsSUFBVXFTLE1BQU1yUyxDQUFOLElBQVcsR0FBckI7QUFDRDtBQUNELFNBQU93NUMsSUFBUDtBQUNEOztBQUVELFNBQVNNLGVBQVQsQ0FBMEJOLElBQTFCLEVBQWdDbm5DLEtBQWhDLEVBQXVDcW9DLFVBQXZDLEVBQW1EcjZDLE1BQW5ELEVBQTJEO0FBQ3pEZ1MsUUFBTWtsQyxVQUFOLENBRHlELENBQ3hDOztBQUVqQixNQUFJbUQsYUFBYSxDQUFiLElBQWtCcm9DLE1BQU1rbEMsVUFBTixHQUFtQm1ELFVBQXpDLEVBQXFEO0FBQ25ELFVBQU0sSUFBSS9nQyxVQUFKLENBQWUsNkJBQWYsQ0FBTjtBQUNEOztBQUVELE1BQUl0SCxNQUFNa2xDLFVBQU4sR0FBbUJtRCxjQUFjcjZDLFVBQVUsQ0FBeEIsQ0FBdkIsRUFBbUQ7QUFDakQsVUFBTSxJQUFJc1osVUFBSixDQUFlLDZCQUFmLENBQU47QUFDRDs7QUFFRCxNQUFJK2dDLGVBQWUxMkMsU0FBZixJQUE0QjNELFdBQVcyRCxTQUEzQyxFQUFzRDtBQUNwRHFPLFlBQVEsSUFBSXdsQyxVQUFKLENBQWV4bEMsS0FBZixDQUFSO0FBQ0QsR0FGRCxNQUVPLElBQUloUyxXQUFXMkQsU0FBZixFQUEwQjtBQUMvQnFPLFlBQVEsSUFBSXdsQyxVQUFKLENBQWV4bEMsS0FBZixFQUFzQnFvQyxVQUF0QixDQUFSO0FBQ0QsR0FGTSxNQUVBO0FBQ0xyb0MsWUFBUSxJQUFJd2xDLFVBQUosQ0FBZXhsQyxLQUFmLEVBQXNCcW9DLFVBQXRCLEVBQWtDcjZDLE1BQWxDLENBQVI7QUFDRDs7QUFFRCxNQUFJcTFDLE9BQU93RCxtQkFBWCxFQUFnQztBQUM5QjtBQUNBTSxXQUFPbm5DLEtBQVA7QUFDQW1uQyxTQUFLeHpCLFNBQUwsR0FBaUIwdkIsT0FBT3o0QixTQUF4QjtBQUNELEdBSkQsTUFJTztBQUNMO0FBQ0F1OEIsV0FBT2lCLGNBQWNqQixJQUFkLEVBQW9Cbm5DLEtBQXBCLENBQVA7QUFDRDtBQUNELFNBQU9tbkMsSUFBUDtBQUNEOztBQUVELFNBQVNPLFVBQVQsQ0FBcUJQLElBQXJCLEVBQTJCaGpDLEdBQTNCLEVBQWdDO0FBQzlCLE1BQUlrL0IsT0FBT2lGLFFBQVAsQ0FBZ0Jua0MsR0FBaEIsQ0FBSixFQUEwQjtBQUN4QixRQUFJZ0gsTUFBTTY4QixRQUFRN2pDLElBQUluVyxNQUFaLElBQXNCLENBQWhDO0FBQ0FtNUMsV0FBT0QsYUFBYUMsSUFBYixFQUFtQmg4QixHQUFuQixDQUFQOztBQUVBLFFBQUlnOEIsS0FBS241QyxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGFBQU9tNUMsSUFBUDtBQUNEOztBQUVEaGpDLFFBQUlva0MsSUFBSixDQUFTcEIsSUFBVCxFQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUJoOEIsR0FBckI7QUFDQSxXQUFPZzhCLElBQVA7QUFDRDs7QUFFRCxNQUFJaGpDLEdBQUosRUFBUztBQUNQLFFBQUssT0FBT3FqQyxXQUFQLEtBQXVCLFdBQXZCLElBQ0RyakMsSUFBSTFJLE1BQUosWUFBc0IrckMsV0FEdEIsSUFDc0MsWUFBWXJqQyxHQUR0RCxFQUMyRDtBQUN6RCxVQUFJLE9BQU9BLElBQUluVyxNQUFYLEtBQXNCLFFBQXRCLElBQWtDdzZDLE1BQU1ya0MsSUFBSW5XLE1BQVYsQ0FBdEMsRUFBeUQ7QUFDdkQsZUFBT2s1QyxhQUFhQyxJQUFiLEVBQW1CLENBQW5CLENBQVA7QUFDRDtBQUNELGFBQU9pQixjQUFjakIsSUFBZCxFQUFvQmhqQyxHQUFwQixDQUFQO0FBQ0Q7O0FBRUQsUUFBSUEsSUFBSXhSLElBQUosS0FBYSxRQUFiLElBQXlCN0UsUUFBUXFXLElBQUloTSxJQUFaLENBQTdCLEVBQWdEO0FBQzlDLGFBQU9pd0MsY0FBY2pCLElBQWQsRUFBb0JoakMsSUFBSWhNLElBQXhCLENBQVA7QUFDRDtBQUNGOztBQUVELFFBQU0sSUFBSWlXLFNBQUosQ0FBYyxvRkFBZCxDQUFOO0FBQ0Q7O0FBRUQsU0FBUzQ1QixPQUFULENBQWtCaDZDLE1BQWxCLEVBQTBCO0FBQ3hCO0FBQ0E7QUFDQSxNQUFJQSxVQUFVKzRDLFlBQWQsRUFBNEI7QUFDMUIsVUFBTSxJQUFJei9CLFVBQUosQ0FBZSxvREFDQSxVQURBLEdBQ2F5L0IsYUFBYTF6QyxRQUFiLENBQXNCLEVBQXRCLENBRGIsR0FDeUMsUUFEeEQsQ0FBTjtBQUVEO0FBQ0QsU0FBT3JGLFNBQVMsQ0FBaEI7QUFDRDs7QUFFRCxTQUFTMjRDLFVBQVQsQ0FBcUIzNEMsTUFBckIsRUFBNkI7QUFDM0IsTUFBSSxDQUFDQSxNQUFELElBQVdBLE1BQWYsRUFBdUI7QUFBRTtBQUN2QkEsYUFBUyxDQUFUO0FBQ0Q7QUFDRCxTQUFPcTFDLE9BQU8wRSxLQUFQLENBQWEsQ0FBQy81QyxNQUFkLENBQVA7QUFDRDs7QUFFRHExQyxPQUFPaUYsUUFBUCxHQUFrQixTQUFTQSxRQUFULENBQW1CeHhCLENBQW5CLEVBQXNCO0FBQ3RDLFNBQU8sQ0FBQyxFQUFFQSxLQUFLLElBQUwsSUFBYUEsRUFBRTJ4QixTQUFqQixDQUFSO0FBQ0QsQ0FGRDs7QUFJQXBGLE9BQU8xckIsT0FBUCxHQUFpQixTQUFTQSxPQUFULENBQWtCL2UsQ0FBbEIsRUFBcUJrZSxDQUFyQixFQUF3QjtBQUN2QyxNQUFJLENBQUN1c0IsT0FBT2lGLFFBQVAsQ0FBZ0IxdkMsQ0FBaEIsQ0FBRCxJQUF1QixDQUFDeXFDLE9BQU9pRixRQUFQLENBQWdCeHhCLENBQWhCLENBQTVCLEVBQWdEO0FBQzlDLFVBQU0sSUFBSTFJLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ0Q7O0FBRUQsTUFBSXhWLE1BQU1rZSxDQUFWLEVBQWEsT0FBTyxDQUFQOztBQUViLE1BQUkxTCxJQUFJeFMsRUFBRTVLLE1BQVY7QUFDQSxNQUFJd3dCLElBQUkxSCxFQUFFOW9CLE1BQVY7O0FBRUEsT0FBSyxJQUFJTCxJQUFJLENBQVIsRUFBV3dkLE1BQU1qRSxLQUFLeEYsR0FBTCxDQUFTMEosQ0FBVCxFQUFZb1QsQ0FBWixDQUF0QixFQUFzQzd3QixJQUFJd2QsR0FBMUMsRUFBK0MsRUFBRXhkLENBQWpELEVBQW9EO0FBQ2xELFFBQUlpTCxFQUFFakwsQ0FBRixNQUFTbXBCLEVBQUVucEIsQ0FBRixDQUFiLEVBQW1CO0FBQ2pCeWQsVUFBSXhTLEVBQUVqTCxDQUFGLENBQUo7QUFDQTZ3QixVQUFJMUgsRUFBRW5wQixDQUFGLENBQUo7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSXlkLElBQUlvVCxDQUFSLEVBQVcsT0FBTyxDQUFDLENBQVI7QUFDWCxNQUFJQSxJQUFJcFQsQ0FBUixFQUFXLE9BQU8sQ0FBUDtBQUNYLFNBQU8sQ0FBUDtBQUNELENBckJEOztBQXVCQWk0QixPQUFPNkUsVUFBUCxHQUFvQixTQUFTQSxVQUFULENBQXFCOXNDLFFBQXJCLEVBQStCO0FBQ2pELFVBQVFnTSxPQUFPaE0sUUFBUCxFQUFpQjhPLFdBQWpCLEVBQVI7QUFDRSxTQUFLLEtBQUw7QUFDQSxTQUFLLE1BQUw7QUFDQSxTQUFLLE9BQUw7QUFDQSxTQUFLLE9BQUw7QUFDQSxTQUFLLFFBQUw7QUFDQSxTQUFLLFFBQUw7QUFDQSxTQUFLLFFBQUw7QUFDQSxTQUFLLE1BQUw7QUFDQSxTQUFLLE9BQUw7QUFDQSxTQUFLLFNBQUw7QUFDQSxTQUFLLFVBQUw7QUFDRSxhQUFPLElBQVA7QUFDRjtBQUNFLGFBQU8sS0FBUDtBQWRKO0FBZ0JELENBakJEOztBQW1CQW01QixPQUFPbmhDLE1BQVAsR0FBZ0IsU0FBU0EsTUFBVCxDQUFpQjRQLElBQWpCLEVBQXVCOWpCLE1BQXZCLEVBQStCO0FBQzdDLE1BQUksQ0FBQ0YsUUFBUWdrQixJQUFSLENBQUwsRUFBb0I7QUFDbEIsVUFBTSxJQUFJMUQsU0FBSixDQUFjLDZDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJMEQsS0FBSzlqQixNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLFdBQU9xMUMsT0FBTzBFLEtBQVAsQ0FBYSxDQUFiLENBQVA7QUFDRDs7QUFFRCxNQUFJcDZDLENBQUo7QUFDQSxNQUFJSyxXQUFXMkQsU0FBZixFQUEwQjtBQUN4QjNELGFBQVMsQ0FBVDtBQUNBLFNBQUtMLElBQUksQ0FBVCxFQUFZQSxJQUFJbWtCLEtBQUs5akIsTUFBckIsRUFBNkIsRUFBRUwsQ0FBL0IsRUFBa0M7QUFDaENLLGdCQUFVOGpCLEtBQUtua0IsQ0FBTCxFQUFRSyxNQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSXlOLFNBQVM0bkMsT0FBT2dFLFdBQVAsQ0FBbUJyNUMsTUFBbkIsQ0FBYjtBQUNBLE1BQUk4a0MsTUFBTSxDQUFWO0FBQ0EsT0FBS25sQyxJQUFJLENBQVQsRUFBWUEsSUFBSW1rQixLQUFLOWpCLE1BQXJCLEVBQTZCLEVBQUVMLENBQS9CLEVBQWtDO0FBQ2hDLFFBQUkrNkMsTUFBTTUyQixLQUFLbmtCLENBQUwsQ0FBVjtBQUNBLFFBQUksQ0FBQzAxQyxPQUFPaUYsUUFBUCxDQUFnQkksR0FBaEIsQ0FBTCxFQUEyQjtBQUN6QixZQUFNLElBQUl0NkIsU0FBSixDQUFjLDZDQUFkLENBQU47QUFDRDtBQUNEczZCLFFBQUlILElBQUosQ0FBUzlzQyxNQUFULEVBQWlCcTNCLEdBQWpCO0FBQ0FBLFdBQU80VixJQUFJMTZDLE1BQVg7QUFDRDtBQUNELFNBQU95TixNQUFQO0FBQ0QsQ0E1QkQ7O0FBOEJBLFNBQVN5cEMsVUFBVCxDQUFxQjNrQyxNQUFyQixFQUE2Qm5GLFFBQTdCLEVBQXVDO0FBQ3JDLE1BQUlpb0MsT0FBT2lGLFFBQVAsQ0FBZ0IvbkMsTUFBaEIsQ0FBSixFQUE2QjtBQUMzQixXQUFPQSxPQUFPdlMsTUFBZDtBQUNEO0FBQ0QsTUFBSSxPQUFPdzVDLFdBQVAsS0FBdUIsV0FBdkIsSUFBc0MsT0FBT0EsWUFBWW1CLE1BQW5CLEtBQThCLFVBQXBFLEtBQ0NuQixZQUFZbUIsTUFBWixDQUFtQnBvQyxNQUFuQixLQUE4QkEsa0JBQWtCaW5DLFdBRGpELENBQUosRUFDbUU7QUFDakUsV0FBT2puQyxPQUFPMmtDLFVBQWQ7QUFDRDtBQUNELE1BQUksT0FBTzNrQyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCQSxhQUFTLEtBQUtBLE1BQWQ7QUFDRDs7QUFFRCxNQUFJNEssTUFBTTVLLE9BQU92UyxNQUFqQjtBQUNBLE1BQUltZCxRQUFRLENBQVosRUFBZSxPQUFPLENBQVA7O0FBRWY7QUFDQSxNQUFJeTlCLGNBQWMsS0FBbEI7QUFDQSxXQUFTO0FBQ1AsWUFBUXh0QyxRQUFSO0FBQ0UsV0FBSyxPQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBTytQLEdBQVA7QUFDRixXQUFLLE1BQUw7QUFDQSxXQUFLLE9BQUw7QUFDQSxXQUFLeFosU0FBTDtBQUNFLGVBQU9rM0MsWUFBWXRvQyxNQUFaLEVBQW9CdlMsTUFBM0I7QUFDRixXQUFLLE1BQUw7QUFDQSxXQUFLLE9BQUw7QUFDQSxXQUFLLFNBQUw7QUFDQSxXQUFLLFVBQUw7QUFDRSxlQUFPbWQsTUFBTSxDQUFiO0FBQ0YsV0FBSyxLQUFMO0FBQ0UsZUFBT0EsUUFBUSxDQUFmO0FBQ0YsV0FBSyxRQUFMO0FBQ0UsZUFBTzI5QixjQUFjdm9DLE1BQWQsRUFBc0J2UyxNQUE3QjtBQUNGO0FBQ0UsWUFBSTQ2QyxXQUFKLEVBQWlCLE9BQU9DLFlBQVl0b0MsTUFBWixFQUFvQnZTLE1BQTNCLENBRG5CLENBQ3FEO0FBQ25Eb04sbUJBQVcsQ0FBQyxLQUFLQSxRQUFOLEVBQWdCOE8sV0FBaEIsRUFBWDtBQUNBMCtCLHNCQUFjLElBQWQ7QUFyQko7QUF1QkQ7QUFDRjtBQUNEdkYsT0FBTzZCLFVBQVAsR0FBb0JBLFVBQXBCOztBQUVBLFNBQVM2RCxZQUFULENBQXVCM3RDLFFBQXZCLEVBQWlDeUosS0FBakMsRUFBd0NQLEdBQXhDLEVBQTZDO0FBQzNDLE1BQUlza0MsY0FBYyxLQUFsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSS9qQyxVQUFVbFQsU0FBVixJQUF1QmtULFFBQVEsQ0FBbkMsRUFBc0M7QUFDcENBLFlBQVEsQ0FBUjtBQUNEO0FBQ0Q7QUFDQTtBQUNBLE1BQUlBLFFBQVEsS0FBSzdXLE1BQWpCLEVBQXlCO0FBQ3ZCLFdBQU8sRUFBUDtBQUNEOztBQUVELE1BQUlzVyxRQUFRM1MsU0FBUixJQUFxQjJTLE1BQU0sS0FBS3RXLE1BQXBDLEVBQTRDO0FBQzFDc1csVUFBTSxLQUFLdFcsTUFBWDtBQUNEOztBQUVELE1BQUlzVyxPQUFPLENBQVgsRUFBYztBQUNaLFdBQU8sRUFBUDtBQUNEOztBQUVEO0FBQ0FBLFdBQVMsQ0FBVDtBQUNBTyxhQUFXLENBQVg7O0FBRUEsTUFBSVAsT0FBT08sS0FBWCxFQUFrQjtBQUNoQixXQUFPLEVBQVA7QUFDRDs7QUFFRCxNQUFJLENBQUN6SixRQUFMLEVBQWVBLFdBQVcsTUFBWDs7QUFFZixTQUFPLElBQVAsRUFBYTtBQUNYLFlBQVFBLFFBQVI7QUFDRSxXQUFLLEtBQUw7QUFDRSxlQUFPNHRDLFNBQVMsSUFBVCxFQUFlbmtDLEtBQWYsRUFBc0JQLEdBQXRCLENBQVA7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0UsZUFBTzJrQyxVQUFVLElBQVYsRUFBZ0Jwa0MsS0FBaEIsRUFBdUJQLEdBQXZCLENBQVA7O0FBRUYsV0FBSyxPQUFMO0FBQ0UsZUFBTzRrQyxXQUFXLElBQVgsRUFBaUJya0MsS0FBakIsRUFBd0JQLEdBQXhCLENBQVA7O0FBRUYsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBTzZrQyxZQUFZLElBQVosRUFBa0J0a0MsS0FBbEIsRUFBeUJQLEdBQXpCLENBQVA7O0FBRUYsV0FBSyxRQUFMO0FBQ0UsZUFBTzhrQyxZQUFZLElBQVosRUFBa0J2a0MsS0FBbEIsRUFBeUJQLEdBQXpCLENBQVA7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0UsZUFBTytrQyxhQUFhLElBQWIsRUFBbUJ4a0MsS0FBbkIsRUFBMEJQLEdBQTFCLENBQVA7O0FBRUY7QUFDRSxZQUFJc2tDLFdBQUosRUFBaUIsTUFBTSxJQUFJeDZCLFNBQUosQ0FBYyx1QkFBdUJoVCxRQUFyQyxDQUFOO0FBQ2pCQSxtQkFBVyxDQUFDQSxXQUFXLEVBQVosRUFBZ0I4TyxXQUFoQixFQUFYO0FBQ0EwK0Isc0JBQWMsSUFBZDtBQTNCSjtBQTZCRDtBQUNGOztBQUVEO0FBQ0E7QUFDQXZGLE9BQU96NEIsU0FBUCxDQUFpQjY5QixTQUFqQixHQUE2QixJQUE3Qjs7QUFFQSxTQUFTYSxJQUFULENBQWV4eUIsQ0FBZixFQUFrQmhPLENBQWxCLEVBQXFCYSxDQUFyQixFQUF3QjtBQUN0QixNQUFJaGMsSUFBSW1wQixFQUFFaE8sQ0FBRixDQUFSO0FBQ0FnTyxJQUFFaE8sQ0FBRixJQUFPZ08sRUFBRW5OLENBQUYsQ0FBUDtBQUNBbU4sSUFBRW5OLENBQUYsSUFBT2hjLENBQVA7QUFDRDs7QUFFRDAxQyxPQUFPejRCLFNBQVAsQ0FBaUIyK0IsTUFBakIsR0FBMEIsU0FBU0EsTUFBVCxHQUFtQjtBQUMzQyxNQUFJcCtCLE1BQU0sS0FBS25kLE1BQWY7QUFDQSxNQUFJbWQsTUFBTSxDQUFOLEtBQVksQ0FBaEIsRUFBbUI7QUFDakIsVUFBTSxJQUFJN0QsVUFBSixDQUFlLDJDQUFmLENBQU47QUFDRDtBQUNELE9BQUssSUFBSTNaLElBQUksQ0FBYixFQUFnQkEsSUFBSXdkLEdBQXBCLEVBQXlCeGQsS0FBSyxDQUE5QixFQUFpQztBQUMvQjI3QyxTQUFLLElBQUwsRUFBVzM3QyxDQUFYLEVBQWNBLElBQUksQ0FBbEI7QUFDRDtBQUNELFNBQU8sSUFBUDtBQUNELENBVEQ7O0FBV0EwMUMsT0FBT3o0QixTQUFQLENBQWlCNCtCLE1BQWpCLEdBQTBCLFNBQVNBLE1BQVQsR0FBbUI7QUFDM0MsTUFBSXIrQixNQUFNLEtBQUtuZCxNQUFmO0FBQ0EsTUFBSW1kLE1BQU0sQ0FBTixLQUFZLENBQWhCLEVBQW1CO0FBQ2pCLFVBQU0sSUFBSTdELFVBQUosQ0FBZSwyQ0FBZixDQUFOO0FBQ0Q7QUFDRCxPQUFLLElBQUkzWixJQUFJLENBQWIsRUFBZ0JBLElBQUl3ZCxHQUFwQixFQUF5QnhkLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0IyN0MsU0FBSyxJQUFMLEVBQVczN0MsQ0FBWCxFQUFjQSxJQUFJLENBQWxCO0FBQ0EyN0MsU0FBSyxJQUFMLEVBQVczN0MsSUFBSSxDQUFmLEVBQWtCQSxJQUFJLENBQXRCO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVZEOztBQVlBMDFDLE9BQU96NEIsU0FBUCxDQUFpQjYrQixNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLE1BQUl0K0IsTUFBTSxLQUFLbmQsTUFBZjtBQUNBLE1BQUltZCxNQUFNLENBQU4sS0FBWSxDQUFoQixFQUFtQjtBQUNqQixVQUFNLElBQUk3RCxVQUFKLENBQWUsMkNBQWYsQ0FBTjtBQUNEO0FBQ0QsT0FBSyxJQUFJM1osSUFBSSxDQUFiLEVBQWdCQSxJQUFJd2QsR0FBcEIsRUFBeUJ4ZCxLQUFLLENBQTlCLEVBQWlDO0FBQy9CMjdDLFNBQUssSUFBTCxFQUFXMzdDLENBQVgsRUFBY0EsSUFBSSxDQUFsQjtBQUNBMjdDLFNBQUssSUFBTCxFQUFXMzdDLElBQUksQ0FBZixFQUFrQkEsSUFBSSxDQUF0QjtBQUNBMjdDLFNBQUssSUFBTCxFQUFXMzdDLElBQUksQ0FBZixFQUFrQkEsSUFBSSxDQUF0QjtBQUNBMjdDLFNBQUssSUFBTCxFQUFXMzdDLElBQUksQ0FBZixFQUFrQkEsSUFBSSxDQUF0QjtBQUNEO0FBQ0QsU0FBTyxJQUFQO0FBQ0QsQ0FaRDs7QUFjQTAxQyxPQUFPejRCLFNBQVAsQ0FBaUJ2WCxRQUFqQixHQUE0QixTQUFTQSxRQUFULEdBQXFCO0FBQy9DLE1BQUlyRixTQUFTLEtBQUtBLE1BQUwsR0FBYyxDQUEzQjtBQUNBLE1BQUlBLFdBQVcsQ0FBZixFQUFrQixPQUFPLEVBQVA7QUFDbEIsTUFBSXdsQixVQUFVeGxCLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEIsT0FBT2k3QyxVQUFVLElBQVYsRUFBZ0IsQ0FBaEIsRUFBbUJqN0MsTUFBbkIsQ0FBUDtBQUM1QixTQUFPKzZDLGFBQWExN0MsS0FBYixDQUFtQixJQUFuQixFQUF5Qm1tQixTQUF6QixDQUFQO0FBQ0QsQ0FMRDs7QUFPQTZ2QixPQUFPejRCLFNBQVAsQ0FBaUI4K0IsTUFBakIsR0FBMEIsU0FBU0EsTUFBVCxDQUFpQjV5QixDQUFqQixFQUFvQjtBQUM1QyxNQUFJLENBQUN1c0IsT0FBT2lGLFFBQVAsQ0FBZ0J4eEIsQ0FBaEIsQ0FBTCxFQUF5QixNQUFNLElBQUkxSSxTQUFKLENBQWMsMkJBQWQsQ0FBTjtBQUN6QixNQUFJLFNBQVMwSSxDQUFiLEVBQWdCLE9BQU8sSUFBUDtBQUNoQixTQUFPdXNCLE9BQU8xckIsT0FBUCxDQUFlLElBQWYsRUFBcUJiLENBQXJCLE1BQTRCLENBQW5DO0FBQ0QsQ0FKRDs7QUFNQXVzQixPQUFPejRCLFNBQVAsQ0FBaUIrK0IsT0FBakIsR0FBMkIsU0FBU0EsT0FBVCxHQUFvQjtBQUM3QyxNQUFJOXpCLE1BQU0sRUFBVjtBQUNBLE1BQUlsVSxNQUFNbUUsUUFBUThnQyxpQkFBbEI7QUFDQSxNQUFJLEtBQUs1NEMsTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ25CNm5CLFVBQU0sS0FBS3hpQixRQUFMLENBQWMsS0FBZCxFQUFxQixDQUFyQixFQUF3QnNPLEdBQXhCLEVBQTZCM1IsS0FBN0IsQ0FBbUMsT0FBbkMsRUFBNEMrSSxJQUE1QyxDQUFpRCxHQUFqRCxDQUFOO0FBQ0EsUUFBSSxLQUFLL0ssTUFBTCxHQUFjMlQsR0FBbEIsRUFBdUJrVSxPQUFPLE9BQVA7QUFDeEI7QUFDRCxTQUFPLGFBQWFBLEdBQWIsR0FBbUIsR0FBMUI7QUFDRCxDQVJEOztBQVVBd3RCLE9BQU96NEIsU0FBUCxDQUFpQitNLE9BQWpCLEdBQTJCLFNBQVNBLE9BQVQsQ0FBa0JoZixNQUFsQixFQUEwQmtNLEtBQTFCLEVBQWlDUCxHQUFqQyxFQUFzQ3NsQyxTQUF0QyxFQUFpREMsT0FBakQsRUFBMEQ7QUFDbkYsTUFBSSxDQUFDeEcsT0FBT2lGLFFBQVAsQ0FBZ0IzdkMsTUFBaEIsQ0FBTCxFQUE4QjtBQUM1QixVQUFNLElBQUl5VixTQUFKLENBQWMsMkJBQWQsQ0FBTjtBQUNEOztBQUVELE1BQUl2SixVQUFVbFQsU0FBZCxFQUF5QjtBQUN2QmtULFlBQVEsQ0FBUjtBQUNEO0FBQ0QsTUFBSVAsUUFBUTNTLFNBQVosRUFBdUI7QUFDckIyUyxVQUFNM0wsU0FBU0EsT0FBTzNLLE1BQWhCLEdBQXlCLENBQS9CO0FBQ0Q7QUFDRCxNQUFJNDdDLGNBQWNqNEMsU0FBbEIsRUFBNkI7QUFDM0JpNEMsZ0JBQVksQ0FBWjtBQUNEO0FBQ0QsTUFBSUMsWUFBWWw0QyxTQUFoQixFQUEyQjtBQUN6Qms0QyxjQUFVLEtBQUs3N0MsTUFBZjtBQUNEOztBQUVELE1BQUk2VyxRQUFRLENBQVIsSUFBYVAsTUFBTTNMLE9BQU8zSyxNQUExQixJQUFvQzQ3QyxZQUFZLENBQWhELElBQXFEQyxVQUFVLEtBQUs3N0MsTUFBeEUsRUFBZ0Y7QUFDOUUsVUFBTSxJQUFJc1osVUFBSixDQUFlLG9CQUFmLENBQU47QUFDRDs7QUFFRCxNQUFJc2lDLGFBQWFDLE9BQWIsSUFBd0JobEMsU0FBU1AsR0FBckMsRUFBMEM7QUFDeEMsV0FBTyxDQUFQO0FBQ0Q7QUFDRCxNQUFJc2xDLGFBQWFDLE9BQWpCLEVBQTBCO0FBQ3hCLFdBQU8sQ0FBQyxDQUFSO0FBQ0Q7QUFDRCxNQUFJaGxDLFNBQVNQLEdBQWIsRUFBa0I7QUFDaEIsV0FBTyxDQUFQO0FBQ0Q7O0FBRURPLGFBQVcsQ0FBWDtBQUNBUCxXQUFTLENBQVQ7QUFDQXNsQyxpQkFBZSxDQUFmO0FBQ0FDLGVBQWEsQ0FBYjs7QUFFQSxNQUFJLFNBQVNseEMsTUFBYixFQUFxQixPQUFPLENBQVA7O0FBRXJCLE1BQUl5UyxJQUFJeStCLFVBQVVELFNBQWxCO0FBQ0EsTUFBSXByQixJQUFJbGEsTUFBTU8sS0FBZDtBQUNBLE1BQUlzRyxNQUFNakUsS0FBS3hGLEdBQUwsQ0FBUzBKLENBQVQsRUFBWW9ULENBQVosQ0FBVjs7QUFFQSxNQUFJc3JCLFdBQVcsS0FBS2h4QyxLQUFMLENBQVc4d0MsU0FBWCxFQUFzQkMsT0FBdEIsQ0FBZjtBQUNBLE1BQUlFLGFBQWFweEMsT0FBT0csS0FBUCxDQUFhK0wsS0FBYixFQUFvQlAsR0FBcEIsQ0FBakI7O0FBRUEsT0FBSyxJQUFJM1csSUFBSSxDQUFiLEVBQWdCQSxJQUFJd2QsR0FBcEIsRUFBeUIsRUFBRXhkLENBQTNCLEVBQThCO0FBQzVCLFFBQUltOEMsU0FBU244QyxDQUFULE1BQWdCbzhDLFdBQVdwOEMsQ0FBWCxDQUFwQixFQUFtQztBQUNqQ3lkLFVBQUkwK0IsU0FBU244QyxDQUFULENBQUo7QUFDQTZ3QixVQUFJdXJCLFdBQVdwOEMsQ0FBWCxDQUFKO0FBQ0E7QUFDRDtBQUNGOztBQUVELE1BQUl5ZCxJQUFJb1QsQ0FBUixFQUFXLE9BQU8sQ0FBQyxDQUFSO0FBQ1gsTUFBSUEsSUFBSXBULENBQVIsRUFBVyxPQUFPLENBQVA7QUFDWCxTQUFPLENBQVA7QUFDRCxDQXpERDs7QUEyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzQrQixvQkFBVCxDQUErQnZ1QyxNQUEvQixFQUF1Q2d5QixHQUF2QyxFQUE0QzRhLFVBQTVDLEVBQXdEanRDLFFBQXhELEVBQWtFNnVDLEdBQWxFLEVBQXVFO0FBQ3JFO0FBQ0EsTUFBSXh1QyxPQUFPek4sTUFBUCxLQUFrQixDQUF0QixFQUF5QixPQUFPLENBQUMsQ0FBUjs7QUFFekI7QUFDQSxNQUFJLE9BQU9xNkMsVUFBUCxLQUFzQixRQUExQixFQUFvQztBQUNsQ2p0QyxlQUFXaXRDLFVBQVg7QUFDQUEsaUJBQWEsQ0FBYjtBQUNELEdBSEQsTUFHTyxJQUFJQSxhQUFhLFVBQWpCLEVBQTZCO0FBQ2xDQSxpQkFBYSxVQUFiO0FBQ0QsR0FGTSxNQUVBLElBQUlBLGFBQWEsQ0FBQyxVQUFsQixFQUE4QjtBQUNuQ0EsaUJBQWEsQ0FBQyxVQUFkO0FBQ0Q7QUFDREEsZUFBYSxDQUFDQSxVQUFkLENBYnFFLENBYTNDO0FBQzFCLE1BQUk5c0IsTUFBTThzQixVQUFOLENBQUosRUFBdUI7QUFDckI7QUFDQUEsaUJBQWE0QixNQUFNLENBQU4sR0FBV3h1QyxPQUFPek4sTUFBUCxHQUFnQixDQUF4QztBQUNEOztBQUVEO0FBQ0EsTUFBSXE2QyxhQUFhLENBQWpCLEVBQW9CQSxhQUFhNXNDLE9BQU96TixNQUFQLEdBQWdCcTZDLFVBQTdCO0FBQ3BCLE1BQUlBLGNBQWM1c0MsT0FBT3pOLE1BQXpCLEVBQWlDO0FBQy9CLFFBQUlpOEMsR0FBSixFQUFTLE9BQU8sQ0FBQyxDQUFSLENBQVQsS0FDSzVCLGFBQWE1c0MsT0FBT3pOLE1BQVAsR0FBZ0IsQ0FBN0I7QUFDTixHQUhELE1BR08sSUFBSXE2QyxhQUFhLENBQWpCLEVBQW9CO0FBQ3pCLFFBQUk0QixHQUFKLEVBQVM1QixhQUFhLENBQWIsQ0FBVCxLQUNLLE9BQU8sQ0FBQyxDQUFSO0FBQ047O0FBRUQ7QUFDQSxNQUFJLE9BQU81YSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0JBLFVBQU00VixPQUFPNXdCLElBQVAsQ0FBWWdiLEdBQVosRUFBaUJyeUIsUUFBakIsQ0FBTjtBQUNEOztBQUVEO0FBQ0EsTUFBSWlvQyxPQUFPaUYsUUFBUCxDQUFnQjdhLEdBQWhCLENBQUosRUFBMEI7QUFDeEI7QUFDQSxRQUFJQSxJQUFJei9CLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixhQUFPLENBQUMsQ0FBUjtBQUNEO0FBQ0QsV0FBT2s4QyxhQUFhenVDLE1BQWIsRUFBcUJneUIsR0FBckIsRUFBMEI0YSxVQUExQixFQUFzQ2p0QyxRQUF0QyxFQUFnRDZ1QyxHQUFoRCxDQUFQO0FBQ0QsR0FORCxNQU1PLElBQUksT0FBT3hjLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNsQ0EsVUFBTUEsTUFBTSxJQUFaLENBRGtDLENBQ2pCO0FBQ2pCLFFBQUk0VixPQUFPd0QsbUJBQVAsSUFDQSxPQUFPckIsV0FBVzU2QixTQUFYLENBQXFCbGMsT0FBNUIsS0FBd0MsVUFENUMsRUFDd0Q7QUFDdEQsVUFBSXU3QyxHQUFKLEVBQVM7QUFDUCxlQUFPekUsV0FBVzU2QixTQUFYLENBQXFCbGMsT0FBckIsQ0FBNkJtYyxJQUE3QixDQUFrQ3BQLE1BQWxDLEVBQTBDZ3lCLEdBQTFDLEVBQStDNGEsVUFBL0MsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU83QyxXQUFXNTZCLFNBQVgsQ0FBcUJ0QixXQUFyQixDQUFpQ3VCLElBQWpDLENBQXNDcFAsTUFBdEMsRUFBOENneUIsR0FBOUMsRUFBbUQ0YSxVQUFuRCxDQUFQO0FBQ0Q7QUFDRjtBQUNELFdBQU82QixhQUFhenVDLE1BQWIsRUFBcUIsQ0FBRWd5QixHQUFGLENBQXJCLEVBQThCNGEsVUFBOUIsRUFBMENqdEMsUUFBMUMsRUFBb0Q2dUMsR0FBcEQsQ0FBUDtBQUNEOztBQUVELFFBQU0sSUFBSTc3QixTQUFKLENBQWMsc0NBQWQsQ0FBTjtBQUNEOztBQUVELFNBQVM4N0IsWUFBVCxDQUF1QmpFLEdBQXZCLEVBQTRCeFksR0FBNUIsRUFBaUM0YSxVQUFqQyxFQUE2Q2p0QyxRQUE3QyxFQUF1RDZ1QyxHQUF2RCxFQUE0RDtBQUMxRCxNQUFJRSxZQUFZLENBQWhCO0FBQ0EsTUFBSUMsWUFBWW5FLElBQUlqNEMsTUFBcEI7QUFDQSxNQUFJcThDLFlBQVk1YyxJQUFJei9CLE1BQXBCOztBQUVBLE1BQUlvTixhQUFhekosU0FBakIsRUFBNEI7QUFDMUJ5SixlQUFXZ00sT0FBT2hNLFFBQVAsRUFBaUI4TyxXQUFqQixFQUFYO0FBQ0EsUUFBSTlPLGFBQWEsTUFBYixJQUF1QkEsYUFBYSxPQUFwQyxJQUNBQSxhQUFhLFNBRGIsSUFDMEJBLGFBQWEsVUFEM0MsRUFDdUQ7QUFDckQsVUFBSTZxQyxJQUFJajRDLE1BQUosR0FBYSxDQUFiLElBQWtCeS9CLElBQUl6L0IsTUFBSixHQUFhLENBQW5DLEVBQXNDO0FBQ3BDLGVBQU8sQ0FBQyxDQUFSO0FBQ0Q7QUFDRG04QyxrQkFBWSxDQUFaO0FBQ0FDLG1CQUFhLENBQWI7QUFDQUMsbUJBQWEsQ0FBYjtBQUNBaEMsb0JBQWMsQ0FBZDtBQUNEO0FBQ0Y7O0FBRUQsV0FBU2lDLElBQVQsQ0FBZTVCLEdBQWYsRUFBb0IvNkMsQ0FBcEIsRUFBdUI7QUFDckIsUUFBSXc4QyxjQUFjLENBQWxCLEVBQXFCO0FBQ25CLGFBQU96QixJQUFJLzZDLENBQUosQ0FBUDtBQUNELEtBRkQsTUFFTztBQUNMLGFBQU8rNkMsSUFBSTZCLFlBQUosQ0FBaUI1OEMsSUFBSXc4QyxTQUFyQixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJeDhDLENBQUo7QUFDQSxNQUFJczhDLEdBQUosRUFBUztBQUNQLFFBQUlPLGFBQWEsQ0FBQyxDQUFsQjtBQUNBLFNBQUs3OEMsSUFBSTA2QyxVQUFULEVBQXFCMTZDLElBQUl5OEMsU0FBekIsRUFBb0N6OEMsR0FBcEMsRUFBeUM7QUFDdkMsVUFBSTI4QyxLQUFLckUsR0FBTCxFQUFVdDRDLENBQVYsTUFBaUIyOEMsS0FBSzdjLEdBQUwsRUFBVStjLGVBQWUsQ0FBQyxDQUFoQixHQUFvQixDQUFwQixHQUF3Qjc4QyxJQUFJNjhDLFVBQXRDLENBQXJCLEVBQXdFO0FBQ3RFLFlBQUlBLGVBQWUsQ0FBQyxDQUFwQixFQUF1QkEsYUFBYTc4QyxDQUFiO0FBQ3ZCLFlBQUlBLElBQUk2OEMsVUFBSixHQUFpQixDQUFqQixLQUF1QkgsU0FBM0IsRUFBc0MsT0FBT0csYUFBYUwsU0FBcEI7QUFDdkMsT0FIRCxNQUdPO0FBQ0wsWUFBSUssZUFBZSxDQUFDLENBQXBCLEVBQXVCNzhDLEtBQUtBLElBQUk2OEMsVUFBVDtBQUN2QkEscUJBQWEsQ0FBQyxDQUFkO0FBQ0Q7QUFDRjtBQUNGLEdBWEQsTUFXTztBQUNMLFFBQUluQyxhQUFhZ0MsU0FBYixHQUF5QkQsU0FBN0IsRUFBd0MvQixhQUFhK0IsWUFBWUMsU0FBekI7QUFDeEMsU0FBSzE4QyxJQUFJMDZDLFVBQVQsRUFBcUIxNkMsS0FBSyxDQUExQixFQUE2QkEsR0FBN0IsRUFBa0M7QUFDaEMsVUFBSTg4QyxRQUFRLElBQVo7QUFDQSxXQUFLLElBQUl4aEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJb2hDLFNBQXBCLEVBQStCcGhDLEdBQS9CLEVBQW9DO0FBQ2xDLFlBQUlxaEMsS0FBS3JFLEdBQUwsRUFBVXQ0QyxJQUFJc2IsQ0FBZCxNQUFxQnFoQyxLQUFLN2MsR0FBTCxFQUFVeGtCLENBQVYsQ0FBekIsRUFBdUM7QUFDckN3aEMsa0JBQVEsS0FBUjtBQUNBO0FBQ0Q7QUFDRjtBQUNELFVBQUlBLEtBQUosRUFBVyxPQUFPOThDLENBQVA7QUFDWjtBQUNGOztBQUVELFNBQU8sQ0FBQyxDQUFSO0FBQ0Q7O0FBRUQwMUMsT0FBT3o0QixTQUFQLENBQWlCOC9CLFFBQWpCLEdBQTRCLFNBQVNBLFFBQVQsQ0FBbUJqZCxHQUFuQixFQUF3QjRhLFVBQXhCLEVBQW9DanRDLFFBQXBDLEVBQThDO0FBQ3hFLFNBQU8sS0FBSzFNLE9BQUwsQ0FBYSsrQixHQUFiLEVBQWtCNGEsVUFBbEIsRUFBOEJqdEMsUUFBOUIsTUFBNEMsQ0FBQyxDQUFwRDtBQUNELENBRkQ7O0FBSUFpb0MsT0FBT3o0QixTQUFQLENBQWlCbGMsT0FBakIsR0FBMkIsU0FBU0EsT0FBVCxDQUFrQisrQixHQUFsQixFQUF1QjRhLFVBQXZCLEVBQW1DanRDLFFBQW5DLEVBQTZDO0FBQ3RFLFNBQU80dUMscUJBQXFCLElBQXJCLEVBQTJCdmMsR0FBM0IsRUFBZ0M0YSxVQUFoQyxFQUE0Q2p0QyxRQUE1QyxFQUFzRCxJQUF0RCxDQUFQO0FBQ0QsQ0FGRDs7QUFJQWlvQyxPQUFPejRCLFNBQVAsQ0FBaUJ0QixXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCbWtCLEdBQXRCLEVBQTJCNGEsVUFBM0IsRUFBdUNqdEMsUUFBdkMsRUFBaUQ7QUFDOUUsU0FBTzR1QyxxQkFBcUIsSUFBckIsRUFBMkJ2YyxHQUEzQixFQUFnQzRhLFVBQWhDLEVBQTRDanRDLFFBQTVDLEVBQXNELEtBQXRELENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVN1dkMsUUFBVCxDQUFtQmpDLEdBQW5CLEVBQXdCbm9DLE1BQXhCLEVBQWdDMmdDLE1BQWhDLEVBQXdDbHpDLE1BQXhDLEVBQWdEO0FBQzlDa3pDLFdBQVM1bEIsT0FBTzRsQixNQUFQLEtBQWtCLENBQTNCO0FBQ0EsTUFBSTBKLFlBQVlsQyxJQUFJMTZDLE1BQUosR0FBYWt6QyxNQUE3QjtBQUNBLE1BQUksQ0FBQ2x6QyxNQUFMLEVBQWE7QUFDWEEsYUFBUzQ4QyxTQUFUO0FBQ0QsR0FGRCxNQUVPO0FBQ0w1OEMsYUFBU3N0QixPQUFPdHRCLE1BQVAsQ0FBVDtBQUNBLFFBQUlBLFNBQVM0OEMsU0FBYixFQUF3QjtBQUN0QjU4QyxlQUFTNDhDLFNBQVQ7QUFDRDtBQUNGOztBQUVEO0FBQ0EsTUFBSUMsU0FBU3RxQyxPQUFPdlMsTUFBcEI7QUFDQSxNQUFJNjhDLFNBQVMsQ0FBVCxLQUFlLENBQW5CLEVBQXNCLE1BQU0sSUFBSXo4QixTQUFKLENBQWMsb0JBQWQsQ0FBTjs7QUFFdEIsTUFBSXBnQixTQUFTNjhDLFNBQVMsQ0FBdEIsRUFBeUI7QUFDdkI3OEMsYUFBUzY4QyxTQUFTLENBQWxCO0FBQ0Q7QUFDRCxPQUFLLElBQUlsOUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSyxNQUFwQixFQUE0QixFQUFFTCxDQUE5QixFQUFpQztBQUMvQixRQUFJc3NCLFNBQVNsRSxTQUFTeFYsT0FBT3ZILE1BQVAsQ0FBY3JMLElBQUksQ0FBbEIsRUFBcUIsQ0FBckIsQ0FBVCxFQUFrQyxFQUFsQyxDQUFiO0FBQ0EsUUFBSTR0QixNQUFNdEIsTUFBTixDQUFKLEVBQW1CLE9BQU90c0IsQ0FBUDtBQUNuQis2QyxRQUFJeEgsU0FBU3Z6QyxDQUFiLElBQWtCc3NCLE1BQWxCO0FBQ0Q7QUFDRCxTQUFPdHNCLENBQVA7QUFDRDs7QUFFRCxTQUFTbTlDLFNBQVQsQ0FBb0JwQyxHQUFwQixFQUF5Qm5vQyxNQUF6QixFQUFpQzJnQyxNQUFqQyxFQUF5Q2x6QyxNQUF6QyxFQUFpRDtBQUMvQyxTQUFPKzhDLFdBQVdsQyxZQUFZdG9DLE1BQVosRUFBb0Jtb0MsSUFBSTE2QyxNQUFKLEdBQWFrekMsTUFBakMsQ0FBWCxFQUFxRHdILEdBQXJELEVBQTBEeEgsTUFBMUQsRUFBa0VsekMsTUFBbEUsQ0FBUDtBQUNEOztBQUVELFNBQVNnOUMsVUFBVCxDQUFxQnRDLEdBQXJCLEVBQTBCbm9DLE1BQTFCLEVBQWtDMmdDLE1BQWxDLEVBQTBDbHpDLE1BQTFDLEVBQWtEO0FBQ2hELFNBQU8rOEMsV0FBV0UsYUFBYTFxQyxNQUFiLENBQVgsRUFBaUNtb0MsR0FBakMsRUFBc0N4SCxNQUF0QyxFQUE4Q2x6QyxNQUE5QyxDQUFQO0FBQ0Q7O0FBRUQsU0FBU2s5QyxXQUFULENBQXNCeEMsR0FBdEIsRUFBMkJub0MsTUFBM0IsRUFBbUMyZ0MsTUFBbkMsRUFBMkNsekMsTUFBM0MsRUFBbUQ7QUFDakQsU0FBT2c5QyxXQUFXdEMsR0FBWCxFQUFnQm5vQyxNQUFoQixFQUF3QjJnQyxNQUF4QixFQUFnQ2x6QyxNQUFoQyxDQUFQO0FBQ0Q7O0FBRUQsU0FBU205QyxXQUFULENBQXNCekMsR0FBdEIsRUFBMkJub0MsTUFBM0IsRUFBbUMyZ0MsTUFBbkMsRUFBMkNsekMsTUFBM0MsRUFBbUQ7QUFDakQsU0FBTys4QyxXQUFXakMsY0FBY3ZvQyxNQUFkLENBQVgsRUFBa0Ntb0MsR0FBbEMsRUFBdUN4SCxNQUF2QyxFQUErQ2x6QyxNQUEvQyxDQUFQO0FBQ0Q7O0FBRUQsU0FBU285QyxTQUFULENBQW9CMUMsR0FBcEIsRUFBeUJub0MsTUFBekIsRUFBaUMyZ0MsTUFBakMsRUFBeUNsekMsTUFBekMsRUFBaUQ7QUFDL0MsU0FBTys4QyxXQUFXTSxlQUFlOXFDLE1BQWYsRUFBdUJtb0MsSUFBSTE2QyxNQUFKLEdBQWFrekMsTUFBcEMsQ0FBWCxFQUF3RHdILEdBQXhELEVBQTZEeEgsTUFBN0QsRUFBcUVsekMsTUFBckUsQ0FBUDtBQUNEOztBQUVEcTFDLE9BQU96NEIsU0FBUCxDQUFpQnU5QixLQUFqQixHQUF5QixTQUFTQSxLQUFULENBQWdCNW5DLE1BQWhCLEVBQXdCMmdDLE1BQXhCLEVBQWdDbHpDLE1BQWhDLEVBQXdDb04sUUFBeEMsRUFBa0Q7QUFDekU7QUFDQSxNQUFJOGxDLFdBQVd2dkMsU0FBZixFQUEwQjtBQUN4QnlKLGVBQVcsTUFBWDtBQUNBcE4sYUFBUyxLQUFLQSxNQUFkO0FBQ0FrekMsYUFBUyxDQUFUO0FBQ0Y7QUFDQyxHQUxELE1BS08sSUFBSWx6QyxXQUFXMkQsU0FBWCxJQUF3QixPQUFPdXZDLE1BQVAsS0FBa0IsUUFBOUMsRUFBd0Q7QUFDN0Q5bEMsZUFBVzhsQyxNQUFYO0FBQ0FsekMsYUFBUyxLQUFLQSxNQUFkO0FBQ0FrekMsYUFBUyxDQUFUO0FBQ0Y7QUFDQyxHQUxNLE1BS0EsSUFBSXYxQixTQUFTdTFCLE1BQVQsQ0FBSixFQUFzQjtBQUMzQkEsYUFBU0EsU0FBUyxDQUFsQjtBQUNBLFFBQUl2MUIsU0FBUzNkLE1BQVQsQ0FBSixFQUFzQjtBQUNwQkEsZUFBU0EsU0FBUyxDQUFsQjtBQUNBLFVBQUlvTixhQUFhekosU0FBakIsRUFBNEJ5SixXQUFXLE1BQVg7QUFDN0IsS0FIRCxNQUdPO0FBQ0xBLGlCQUFXcE4sTUFBWDtBQUNBQSxlQUFTMkQsU0FBVDtBQUNEO0FBQ0g7QUFDQyxHQVZNLE1BVUE7QUFDTCxVQUFNLElBQUlqQixLQUFKLENBQ0oseUVBREksQ0FBTjtBQUdEOztBQUVELE1BQUlrNkMsWUFBWSxLQUFLNThDLE1BQUwsR0FBY2t6QyxNQUE5QjtBQUNBLE1BQUlsekMsV0FBVzJELFNBQVgsSUFBd0IzRCxTQUFTNDhDLFNBQXJDLEVBQWdENThDLFNBQVM0OEMsU0FBVDs7QUFFaEQsTUFBS3JxQyxPQUFPdlMsTUFBUCxHQUFnQixDQUFoQixLQUFzQkEsU0FBUyxDQUFULElBQWNrekMsU0FBUyxDQUE3QyxDQUFELElBQXFEQSxTQUFTLEtBQUtsekMsTUFBdkUsRUFBK0U7QUFDN0UsVUFBTSxJQUFJc1osVUFBSixDQUFlLHdDQUFmLENBQU47QUFDRDs7QUFFRCxNQUFJLENBQUNsTSxRQUFMLEVBQWVBLFdBQVcsTUFBWDs7QUFFZixNQUFJd3RDLGNBQWMsS0FBbEI7QUFDQSxXQUFTO0FBQ1AsWUFBUXh0QyxRQUFSO0FBQ0UsV0FBSyxLQUFMO0FBQ0UsZUFBT3V2QyxTQUFTLElBQVQsRUFBZXBxQyxNQUFmLEVBQXVCMmdDLE1BQXZCLEVBQStCbHpDLE1BQS9CLENBQVA7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0UsZUFBTzg4QyxVQUFVLElBQVYsRUFBZ0J2cUMsTUFBaEIsRUFBd0IyZ0MsTUFBeEIsRUFBZ0NsekMsTUFBaEMsQ0FBUDs7QUFFRixXQUFLLE9BQUw7QUFDRSxlQUFPZzlDLFdBQVcsSUFBWCxFQUFpQnpxQyxNQUFqQixFQUF5QjJnQyxNQUF6QixFQUFpQ2x6QyxNQUFqQyxDQUFQOztBQUVGLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNFLGVBQU9rOUMsWUFBWSxJQUFaLEVBQWtCM3FDLE1BQWxCLEVBQTBCMmdDLE1BQTFCLEVBQWtDbHpDLE1BQWxDLENBQVA7O0FBRUYsV0FBSyxRQUFMO0FBQ0U7QUFDQSxlQUFPbTlDLFlBQVksSUFBWixFQUFrQjVxQyxNQUFsQixFQUEwQjJnQyxNQUExQixFQUFrQ2x6QyxNQUFsQyxDQUFQOztBQUVGLFdBQUssTUFBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssVUFBTDtBQUNFLGVBQU9vOUMsVUFBVSxJQUFWLEVBQWdCN3FDLE1BQWhCLEVBQXdCMmdDLE1BQXhCLEVBQWdDbHpDLE1BQWhDLENBQVA7O0FBRUY7QUFDRSxZQUFJNDZDLFdBQUosRUFBaUIsTUFBTSxJQUFJeDZCLFNBQUosQ0FBYyx1QkFBdUJoVCxRQUFyQyxDQUFOO0FBQ2pCQSxtQkFBVyxDQUFDLEtBQUtBLFFBQU4sRUFBZ0I4TyxXQUFoQixFQUFYO0FBQ0EwK0Isc0JBQWMsSUFBZDtBQTVCSjtBQThCRDtBQUNGLENBdEVEOztBQXdFQXZGLE9BQU96NEIsU0FBUCxDQUFpQjlGLE1BQWpCLEdBQTBCLFNBQVNBLE1BQVQsR0FBbUI7QUFDM0MsU0FBTztBQUNMblMsVUFBTSxRQUREO0FBRUx3RixVQUFNdEssTUFBTStjLFNBQU4sQ0FBZ0I5UixLQUFoQixDQUFzQitSLElBQXRCLENBQTJCLEtBQUt5Z0MsSUFBTCxJQUFhLElBQXhDLEVBQThDLENBQTlDO0FBRkQsR0FBUDtBQUlELENBTEQ7O0FBT0EsU0FBU2xDLFdBQVQsQ0FBc0JWLEdBQXRCLEVBQTJCN2pDLEtBQTNCLEVBQWtDUCxHQUFsQyxFQUF1QztBQUNyQyxNQUFJTyxVQUFVLENBQVYsSUFBZVAsUUFBUW9rQyxJQUFJMTZDLE1BQS9CLEVBQXVDO0FBQ3JDLFdBQU93NEMsT0FBT3BCLGFBQVAsQ0FBcUJzRCxHQUFyQixDQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT2xDLE9BQU9wQixhQUFQLENBQXFCc0QsSUFBSTV2QyxLQUFKLENBQVUrTCxLQUFWLEVBQWlCUCxHQUFqQixDQUFyQixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTMmtDLFNBQVQsQ0FBb0JQLEdBQXBCLEVBQXlCN2pDLEtBQXpCLEVBQWdDUCxHQUFoQyxFQUFxQztBQUNuQ0EsUUFBTTRDLEtBQUt4RixHQUFMLENBQVNnbkMsSUFBSTE2QyxNQUFiLEVBQXFCc1csR0FBckIsQ0FBTjtBQUNBLE1BQUlpbkMsTUFBTSxFQUFWOztBQUVBLE1BQUk1OUMsSUFBSWtYLEtBQVI7QUFDQSxTQUFPbFgsSUFBSTJXLEdBQVgsRUFBZ0I7QUFDZCxRQUFJa25DLFlBQVk5QyxJQUFJLzZDLENBQUosQ0FBaEI7QUFDQSxRQUFJc2EsWUFBWSxJQUFoQjtBQUNBLFFBQUl3akMsbUJBQW9CRCxZQUFZLElBQWIsR0FBcUIsQ0FBckIsR0FDbEJBLFlBQVksSUFBYixHQUFxQixDQUFyQixHQUNDQSxZQUFZLElBQWIsR0FBcUIsQ0FBckIsR0FDQSxDQUhKOztBQUtBLFFBQUk3OUMsSUFBSTg5QyxnQkFBSixJQUF3Qm5uQyxHQUE1QixFQUFpQztBQUMvQixVQUFJb25DLFVBQUosRUFBZ0JDLFNBQWhCLEVBQTJCQyxVQUEzQixFQUF1Q0MsYUFBdkM7O0FBRUEsY0FBUUosZ0JBQVI7QUFDRSxhQUFLLENBQUw7QUFDRSxjQUFJRCxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCdmpDLHdCQUFZdWpDLFNBQVo7QUFDRDtBQUNEO0FBQ0YsYUFBSyxDQUFMO0FBQ0VFLHVCQUFhaEQsSUFBSS82QyxJQUFJLENBQVIsQ0FBYjtBQUNBLGNBQUksQ0FBQys5QyxhQUFhLElBQWQsTUFBd0IsSUFBNUIsRUFBa0M7QUFDaENHLDRCQUFnQixDQUFDTCxZQUFZLElBQWIsS0FBc0IsR0FBdEIsR0FBNkJFLGFBQWEsSUFBMUQ7QUFDQSxnQkFBSUcsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3hCNWpDLDBCQUFZNGpDLGFBQVo7QUFDRDtBQUNGO0FBQ0Q7QUFDRixhQUFLLENBQUw7QUFDRUgsdUJBQWFoRCxJQUFJLzZDLElBQUksQ0FBUixDQUFiO0FBQ0FnK0Msc0JBQVlqRCxJQUFJLzZDLElBQUksQ0FBUixDQUFaO0FBQ0EsY0FBSSxDQUFDKzlDLGFBQWEsSUFBZCxNQUF3QixJQUF4QixJQUFnQyxDQUFDQyxZQUFZLElBQWIsTUFBdUIsSUFBM0QsRUFBaUU7QUFDL0RFLDRCQUFnQixDQUFDTCxZQUFZLEdBQWIsS0FBcUIsR0FBckIsR0FBMkIsQ0FBQ0UsYUFBYSxJQUFkLEtBQXVCLEdBQWxELEdBQXlEQyxZQUFZLElBQXJGO0FBQ0EsZ0JBQUlFLGdCQUFnQixLQUFoQixLQUEwQkEsZ0JBQWdCLE1BQWhCLElBQTBCQSxnQkFBZ0IsTUFBcEUsQ0FBSixFQUFpRjtBQUMvRTVqQywwQkFBWTRqQyxhQUFaO0FBQ0Q7QUFDRjtBQUNEO0FBQ0YsYUFBSyxDQUFMO0FBQ0VILHVCQUFhaEQsSUFBSS82QyxJQUFJLENBQVIsQ0FBYjtBQUNBZytDLHNCQUFZakQsSUFBSS82QyxJQUFJLENBQVIsQ0FBWjtBQUNBaStDLHVCQUFhbEQsSUFBSS82QyxJQUFJLENBQVIsQ0FBYjtBQUNBLGNBQUksQ0FBQys5QyxhQUFhLElBQWQsTUFBd0IsSUFBeEIsSUFBZ0MsQ0FBQ0MsWUFBWSxJQUFiLE1BQXVCLElBQXZELElBQStELENBQUNDLGFBQWEsSUFBZCxNQUF3QixJQUEzRixFQUFpRztBQUMvRkMsNEJBQWdCLENBQUNMLFlBQVksR0FBYixLQUFxQixJQUFyQixHQUE0QixDQUFDRSxhQUFhLElBQWQsS0FBdUIsR0FBbkQsR0FBeUQsQ0FBQ0MsWUFBWSxJQUFiLEtBQXNCLEdBQS9FLEdBQXNGQyxhQUFhLElBQW5IO0FBQ0EsZ0JBQUlDLGdCQUFnQixNQUFoQixJQUEwQkEsZ0JBQWdCLFFBQTlDLEVBQXdEO0FBQ3RENWpDLDBCQUFZNGpDLGFBQVo7QUFDRDtBQUNGO0FBbENMO0FBb0NEOztBQUVELFFBQUk1akMsY0FBYyxJQUFsQixFQUF3QjtBQUN0QjtBQUNBO0FBQ0FBLGtCQUFZLE1BQVo7QUFDQXdqQyx5QkFBbUIsQ0FBbkI7QUFDRCxLQUxELE1BS08sSUFBSXhqQyxZQUFZLE1BQWhCLEVBQXdCO0FBQzdCO0FBQ0FBLG1CQUFhLE9BQWI7QUFDQXNqQyxVQUFJNThDLElBQUosQ0FBU3NaLGNBQWMsRUFBZCxHQUFtQixLQUFuQixHQUEyQixNQUFwQztBQUNBQSxrQkFBWSxTQUFTQSxZQUFZLEtBQWpDO0FBQ0Q7O0FBRURzakMsUUFBSTU4QyxJQUFKLENBQVNzWixTQUFUO0FBQ0F0YSxTQUFLODlDLGdCQUFMO0FBQ0Q7O0FBRUQsU0FBT0ssc0JBQXNCUCxHQUF0QixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSVEsdUJBQXVCLE1BQTNCOztBQUVBLFNBQVNELHFCQUFULENBQWdDRSxVQUFoQyxFQUE0QztBQUMxQyxNQUFJN2dDLE1BQU02Z0MsV0FBV2grQyxNQUFyQjtBQUNBLE1BQUltZCxPQUFPNGdDLG9CQUFYLEVBQWlDO0FBQy9CLFdBQU8za0MsT0FBT0MsWUFBUCxDQUFvQmhhLEtBQXBCLENBQTBCK1osTUFBMUIsRUFBa0M0a0MsVUFBbEMsQ0FBUCxDQUQrQixDQUNzQjtBQUN0RDs7QUFFRDtBQUNBLE1BQUlULE1BQU0sRUFBVjtBQUNBLE1BQUk1OUMsSUFBSSxDQUFSO0FBQ0EsU0FBT0EsSUFBSXdkLEdBQVgsRUFBZ0I7QUFDZG9nQyxXQUFPbmtDLE9BQU9DLFlBQVAsQ0FBb0JoYSxLQUFwQixDQUNMK1osTUFESyxFQUVMNGtDLFdBQVdsekMsS0FBWCxDQUFpQm5MLENBQWpCLEVBQW9CQSxLQUFLbytDLG9CQUF6QixDQUZLLENBQVA7QUFJRDtBQUNELFNBQU9SLEdBQVA7QUFDRDs7QUFFRCxTQUFTckMsVUFBVCxDQUFxQlIsR0FBckIsRUFBMEI3akMsS0FBMUIsRUFBaUNQLEdBQWpDLEVBQXNDO0FBQ3BDLE1BQUkybkMsTUFBTSxFQUFWO0FBQ0EzbkMsUUFBTTRDLEtBQUt4RixHQUFMLENBQVNnbkMsSUFBSTE2QyxNQUFiLEVBQXFCc1csR0FBckIsQ0FBTjs7QUFFQSxPQUFLLElBQUkzVyxJQUFJa1gsS0FBYixFQUFvQmxYLElBQUkyVyxHQUF4QixFQUE2QixFQUFFM1csQ0FBL0IsRUFBa0M7QUFDaENzK0MsV0FBTzdrQyxPQUFPQyxZQUFQLENBQW9CcWhDLElBQUkvNkMsQ0FBSixJQUFTLElBQTdCLENBQVA7QUFDRDtBQUNELFNBQU9zK0MsR0FBUDtBQUNEOztBQUVELFNBQVM5QyxXQUFULENBQXNCVCxHQUF0QixFQUEyQjdqQyxLQUEzQixFQUFrQ1AsR0FBbEMsRUFBdUM7QUFDckMsTUFBSTJuQyxNQUFNLEVBQVY7QUFDQTNuQyxRQUFNNEMsS0FBS3hGLEdBQUwsQ0FBU2duQyxJQUFJMTZDLE1BQWIsRUFBcUJzVyxHQUFyQixDQUFOOztBQUVBLE9BQUssSUFBSTNXLElBQUlrWCxLQUFiLEVBQW9CbFgsSUFBSTJXLEdBQXhCLEVBQTZCLEVBQUUzVyxDQUEvQixFQUFrQztBQUNoQ3MrQyxXQUFPN2tDLE9BQU9DLFlBQVAsQ0FBb0JxaEMsSUFBSS82QyxDQUFKLENBQXBCLENBQVA7QUFDRDtBQUNELFNBQU9zK0MsR0FBUDtBQUNEOztBQUVELFNBQVNqRCxRQUFULENBQW1CTixHQUFuQixFQUF3QjdqQyxLQUF4QixFQUErQlAsR0FBL0IsRUFBb0M7QUFDbEMsTUFBSTZHLE1BQU11OUIsSUFBSTE2QyxNQUFkOztBQUVBLE1BQUksQ0FBQzZXLEtBQUQsSUFBVUEsUUFBUSxDQUF0QixFQUF5QkEsUUFBUSxDQUFSO0FBQ3pCLE1BQUksQ0FBQ1AsR0FBRCxJQUFRQSxNQUFNLENBQWQsSUFBbUJBLE1BQU02RyxHQUE3QixFQUFrQzdHLE1BQU02RyxHQUFOOztBQUVsQyxNQUFJdEMsTUFBTSxFQUFWO0FBQ0EsT0FBSyxJQUFJbGIsSUFBSWtYLEtBQWIsRUFBb0JsWCxJQUFJMlcsR0FBeEIsRUFBNkIsRUFBRTNXLENBQS9CLEVBQWtDO0FBQ2hDa2IsV0FBT3FqQyxNQUFNeEQsSUFBSS82QyxDQUFKLENBQU4sQ0FBUDtBQUNEO0FBQ0QsU0FBT2tiLEdBQVA7QUFDRDs7QUFFRCxTQUFTd2dDLFlBQVQsQ0FBdUJYLEdBQXZCLEVBQTRCN2pDLEtBQTVCLEVBQW1DUCxHQUFuQyxFQUF3QztBQUN0QyxNQUFJNm5DLFFBQVF6RCxJQUFJNXZDLEtBQUosQ0FBVStMLEtBQVYsRUFBaUJQLEdBQWpCLENBQVo7QUFDQSxNQUFJaW5DLE1BQU0sRUFBVjtBQUNBLE9BQUssSUFBSTU5QyxJQUFJLENBQWIsRUFBZ0JBLElBQUl3K0MsTUFBTW4rQyxNQUExQixFQUFrQ0wsS0FBSyxDQUF2QyxFQUEwQztBQUN4QzQ5QyxXQUFPbmtDLE9BQU9DLFlBQVAsQ0FBb0I4a0MsTUFBTXgrQyxDQUFOLElBQVd3K0MsTUFBTXgrQyxJQUFJLENBQVYsSUFBZSxHQUE5QyxDQUFQO0FBQ0Q7QUFDRCxTQUFPNDlDLEdBQVA7QUFDRDs7QUFFRGxJLE9BQU96NEIsU0FBUCxDQUFpQjlSLEtBQWpCLEdBQXlCLFNBQVNBLEtBQVQsQ0FBZ0IrTCxLQUFoQixFQUF1QlAsR0FBdkIsRUFBNEI7QUFDbkQsTUFBSTZHLE1BQU0sS0FBS25kLE1BQWY7QUFDQTZXLFVBQVEsQ0FBQyxDQUFDQSxLQUFWO0FBQ0FQLFFBQU1BLFFBQVEzUyxTQUFSLEdBQW9Cd1osR0FBcEIsR0FBMEIsQ0FBQyxDQUFDN0csR0FBbEM7O0FBRUEsTUFBSU8sUUFBUSxDQUFaLEVBQWU7QUFDYkEsYUFBU3NHLEdBQVQ7QUFDQSxRQUFJdEcsUUFBUSxDQUFaLEVBQWVBLFFBQVEsQ0FBUjtBQUNoQixHQUhELE1BR08sSUFBSUEsUUFBUXNHLEdBQVosRUFBaUI7QUFDdEJ0RyxZQUFRc0csR0FBUjtBQUNEOztBQUVELE1BQUk3RyxNQUFNLENBQVYsRUFBYTtBQUNYQSxXQUFPNkcsR0FBUDtBQUNBLFFBQUk3RyxNQUFNLENBQVYsRUFBYUEsTUFBTSxDQUFOO0FBQ2QsR0FIRCxNQUdPLElBQUlBLE1BQU02RyxHQUFWLEVBQWU7QUFDcEI3RyxVQUFNNkcsR0FBTjtBQUNEOztBQUVELE1BQUk3RyxNQUFNTyxLQUFWLEVBQWlCUCxNQUFNTyxLQUFOOztBQUVqQixNQUFJdW5DLE1BQUo7QUFDQSxNQUFJL0ksT0FBT3dELG1CQUFYLEVBQWdDO0FBQzlCdUYsYUFBUyxLQUFLbkYsUUFBTCxDQUFjcGlDLEtBQWQsRUFBcUJQLEdBQXJCLENBQVQ7QUFDQThuQyxXQUFPejRCLFNBQVAsR0FBbUIwdkIsT0FBT3o0QixTQUExQjtBQUNELEdBSEQsTUFHTztBQUNMLFFBQUl5aEMsV0FBVy9uQyxNQUFNTyxLQUFyQjtBQUNBdW5DLGFBQVMsSUFBSS9JLE1BQUosQ0FBV2dKLFFBQVgsRUFBcUIxNkMsU0FBckIsQ0FBVDtBQUNBLFNBQUssSUFBSWhFLElBQUksQ0FBYixFQUFnQkEsSUFBSTArQyxRQUFwQixFQUE4QixFQUFFMStDLENBQWhDLEVBQW1DO0FBQ2pDeStDLGFBQU96K0MsQ0FBUCxJQUFZLEtBQUtBLElBQUlrWCxLQUFULENBQVo7QUFDRDtBQUNGOztBQUVELFNBQU91bkMsTUFBUDtBQUNELENBbENEOztBQW9DQTs7O0FBR0EsU0FBU0UsV0FBVCxDQUFzQnBMLE1BQXRCLEVBQThCcUwsR0FBOUIsRUFBbUN2K0MsTUFBbkMsRUFBMkM7QUFDekMsTUFBS2t6QyxTQUFTLENBQVYsS0FBaUIsQ0FBakIsSUFBc0JBLFNBQVMsQ0FBbkMsRUFBc0MsTUFBTSxJQUFJNTVCLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQ3RDLE1BQUk0NUIsU0FBU3FMLEdBQVQsR0FBZXYrQyxNQUFuQixFQUEyQixNQUFNLElBQUlzWixVQUFKLENBQWUsdUNBQWYsQ0FBTjtBQUM1Qjs7QUFFRCs3QixPQUFPejRCLFNBQVAsQ0FBaUI0aEMsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQnRMLE1BQXJCLEVBQTZCZ0UsVUFBN0IsRUFBeUN1SCxRQUF6QyxFQUFtRDtBQUMvRXZMLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQWdFLGVBQWFBLGFBQWEsQ0FBMUI7QUFDQSxNQUFJLENBQUN1SCxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CZ0UsVUFBcEIsRUFBZ0MsS0FBS2wzQyxNQUFyQzs7QUFFZixNQUFJeS9CLE1BQU0sS0FBS3lULE1BQUwsQ0FBVjtBQUNBLE1BQUl3TCxNQUFNLENBQVY7QUFDQSxNQUFJLytDLElBQUksQ0FBUjtBQUNBLFNBQU8sRUFBRUEsQ0FBRixHQUFNdTNDLFVBQU4sS0FBcUJ3SCxPQUFPLEtBQTVCLENBQVAsRUFBMkM7QUFDekNqZixXQUFPLEtBQUt5VCxTQUFTdnpDLENBQWQsSUFBbUIrK0MsR0FBMUI7QUFDRDs7QUFFRCxTQUFPamYsR0FBUDtBQUNELENBYkQ7O0FBZUE0VixPQUFPejRCLFNBQVAsQ0FBaUIraEMsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQnpMLE1BQXJCLEVBQTZCZ0UsVUFBN0IsRUFBeUN1SCxRQUF6QyxFQUFtRDtBQUMvRXZMLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQWdFLGVBQWFBLGFBQWEsQ0FBMUI7QUFDQSxNQUFJLENBQUN1SCxRQUFMLEVBQWU7QUFDYkgsZ0JBQVlwTCxNQUFaLEVBQW9CZ0UsVUFBcEIsRUFBZ0MsS0FBS2wzQyxNQUFyQztBQUNEOztBQUVELE1BQUl5L0IsTUFBTSxLQUFLeVQsU0FBUyxFQUFFZ0UsVUFBaEIsQ0FBVjtBQUNBLE1BQUl3SCxNQUFNLENBQVY7QUFDQSxTQUFPeEgsYUFBYSxDQUFiLEtBQW1Cd0gsT0FBTyxLQUExQixDQUFQLEVBQXlDO0FBQ3ZDamYsV0FBTyxLQUFLeVQsU0FBUyxFQUFFZ0UsVUFBaEIsSUFBOEJ3SCxHQUFyQztBQUNEOztBQUVELFNBQU9qZixHQUFQO0FBQ0QsQ0FkRDs7QUFnQkE0VixPQUFPejRCLFNBQVAsQ0FBaUJnaUMsU0FBakIsR0FBNkIsU0FBU0EsU0FBVCxDQUFvQjFMLE1BQXBCLEVBQTRCdUwsUUFBNUIsRUFBc0M7QUFDakUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUtsekMsTUFBNUI7QUFDZixTQUFPLEtBQUtrekMsTUFBTCxDQUFQO0FBQ0QsQ0FIRDs7QUFLQW1DLE9BQU96NEIsU0FBUCxDQUFpQmlpQyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCM0wsTUFBdkIsRUFBK0J1TCxRQUEvQixFQUF5QztBQUN2RSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWXBMLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS2x6QyxNQUE1QjtBQUNmLFNBQU8sS0FBS2t6QyxNQUFMLElBQWdCLEtBQUtBLFNBQVMsQ0FBZCxLQUFvQixDQUEzQztBQUNELENBSEQ7O0FBS0FtQyxPQUFPejRCLFNBQVAsQ0FBaUIyL0IsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QnJKLE1BQXZCLEVBQStCdUwsUUFBL0IsRUFBeUM7QUFDdkUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUtsekMsTUFBNUI7QUFDZixTQUFRLEtBQUtrekMsTUFBTCxLQUFnQixDQUFqQixHQUFzQixLQUFLQSxTQUFTLENBQWQsQ0FBN0I7QUFDRCxDQUhEOztBQUtBbUMsT0FBT3o0QixTQUFQLENBQWlCa2lDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUI1TCxNQUF2QixFQUErQnVMLFFBQS9CLEVBQXlDO0FBQ3ZFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLbHpDLE1BQTVCOztBQUVmLFNBQU8sQ0FBRSxLQUFLa3pDLE1BQUwsQ0FBRCxHQUNILEtBQUtBLFNBQVMsQ0FBZCxLQUFvQixDQURqQixHQUVILEtBQUtBLFNBQVMsQ0FBZCxLQUFvQixFQUZsQixJQUdGLEtBQUtBLFNBQVMsQ0FBZCxJQUFtQixTQUh4QjtBQUlELENBUEQ7O0FBU0FtQyxPQUFPejRCLFNBQVAsQ0FBaUJtaUMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QjdMLE1BQXZCLEVBQStCdUwsUUFBL0IsRUFBeUM7QUFDdkUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUtsekMsTUFBNUI7O0FBRWYsU0FBUSxLQUFLa3pDLE1BQUwsSUFBZSxTQUFoQixJQUNILEtBQUtBLFNBQVMsQ0FBZCxLQUFvQixFQUFyQixHQUNBLEtBQUtBLFNBQVMsQ0FBZCxLQUFvQixDQURwQixHQUVELEtBQUtBLFNBQVMsQ0FBZCxDQUhLLENBQVA7QUFJRCxDQVBEOztBQVNBbUMsT0FBT3o0QixTQUFQLENBQWlCb2lDLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0I5TCxNQUFwQixFQUE0QmdFLFVBQTVCLEVBQXdDdUgsUUFBeEMsRUFBa0Q7QUFDN0V2TCxXQUFTQSxTQUFTLENBQWxCO0FBQ0FnRSxlQUFhQSxhQUFhLENBQTFCO0FBQ0EsTUFBSSxDQUFDdUgsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQmdFLFVBQXBCLEVBQWdDLEtBQUtsM0MsTUFBckM7O0FBRWYsTUFBSXkvQixNQUFNLEtBQUt5VCxNQUFMLENBQVY7QUFDQSxNQUFJd0wsTUFBTSxDQUFWO0FBQ0EsTUFBSS8rQyxJQUFJLENBQVI7QUFDQSxTQUFPLEVBQUVBLENBQUYsR0FBTXUzQyxVQUFOLEtBQXFCd0gsT0FBTyxLQUE1QixDQUFQLEVBQTJDO0FBQ3pDamYsV0FBTyxLQUFLeVQsU0FBU3Z6QyxDQUFkLElBQW1CKytDLEdBQTFCO0FBQ0Q7QUFDREEsU0FBTyxJQUFQOztBQUVBLE1BQUlqZixPQUFPaWYsR0FBWCxFQUFnQmpmLE9BQU92bUIsS0FBS3dYLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSXdtQixVQUFoQixDQUFQOztBQUVoQixTQUFPelgsR0FBUDtBQUNELENBaEJEOztBQWtCQTRWLE9BQU96NEIsU0FBUCxDQUFpQnFpQyxTQUFqQixHQUE2QixTQUFTQSxTQUFULENBQW9CL0wsTUFBcEIsRUFBNEJnRSxVQUE1QixFQUF3Q3VILFFBQXhDLEVBQWtEO0FBQzdFdkwsV0FBU0EsU0FBUyxDQUFsQjtBQUNBZ0UsZUFBYUEsYUFBYSxDQUExQjtBQUNBLE1BQUksQ0FBQ3VILFFBQUwsRUFBZUgsWUFBWXBMLE1BQVosRUFBb0JnRSxVQUFwQixFQUFnQyxLQUFLbDNDLE1BQXJDOztBQUVmLE1BQUlMLElBQUl1M0MsVUFBUjtBQUNBLE1BQUl3SCxNQUFNLENBQVY7QUFDQSxNQUFJamYsTUFBTSxLQUFLeVQsU0FBUyxFQUFFdnpDLENBQWhCLENBQVY7QUFDQSxTQUFPQSxJQUFJLENBQUosS0FBVSsrQyxPQUFPLEtBQWpCLENBQVAsRUFBZ0M7QUFDOUJqZixXQUFPLEtBQUt5VCxTQUFTLEVBQUV2ekMsQ0FBaEIsSUFBcUIrK0MsR0FBNUI7QUFDRDtBQUNEQSxTQUFPLElBQVA7O0FBRUEsTUFBSWpmLE9BQU9pZixHQUFYLEVBQWdCamYsT0FBT3ZtQixLQUFLd1gsR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJd21CLFVBQWhCLENBQVA7O0FBRWhCLFNBQU96WCxHQUFQO0FBQ0QsQ0FoQkQ7O0FBa0JBNFYsT0FBT3o0QixTQUFQLENBQWlCc2lDLFFBQWpCLEdBQTRCLFNBQVNBLFFBQVQsQ0FBbUJoTSxNQUFuQixFQUEyQnVMLFFBQTNCLEVBQXFDO0FBQy9ELE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLbHpDLE1BQTVCO0FBQ2YsTUFBSSxFQUFFLEtBQUtrekMsTUFBTCxJQUFlLElBQWpCLENBQUosRUFBNEIsT0FBUSxLQUFLQSxNQUFMLENBQVI7QUFDNUIsU0FBUSxDQUFDLE9BQU8sS0FBS0EsTUFBTCxDQUFQLEdBQXNCLENBQXZCLElBQTRCLENBQUMsQ0FBckM7QUFDRCxDQUpEOztBQU1BbUMsT0FBT3o0QixTQUFQLENBQWlCdWlDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JqTSxNQUF0QixFQUE4QnVMLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLbHpDLE1BQTVCO0FBQ2YsTUFBSXkvQixNQUFNLEtBQUt5VCxNQUFMLElBQWdCLEtBQUtBLFNBQVMsQ0FBZCxLQUFvQixDQUE5QztBQUNBLFNBQVF6VCxNQUFNLE1BQVAsR0FBaUJBLE1BQU0sVUFBdkIsR0FBb0NBLEdBQTNDO0FBQ0QsQ0FKRDs7QUFNQTRWLE9BQU96NEIsU0FBUCxDQUFpQndpQyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCbE0sTUFBdEIsRUFBOEJ1TCxRQUE5QixFQUF3QztBQUNyRSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWXBMLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS2x6QyxNQUE1QjtBQUNmLE1BQUl5L0IsTUFBTSxLQUFLeVQsU0FBUyxDQUFkLElBQW9CLEtBQUtBLE1BQUwsS0FBZ0IsQ0FBOUM7QUFDQSxTQUFRelQsTUFBTSxNQUFQLEdBQWlCQSxNQUFNLFVBQXZCLEdBQW9DQSxHQUEzQztBQUNELENBSkQ7O0FBTUE0VixPQUFPejRCLFNBQVAsQ0FBaUJ5aUMsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQm5NLE1BQXRCLEVBQThCdUwsUUFBOUIsRUFBd0M7QUFDckUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUtsekMsTUFBNUI7O0FBRWYsU0FBUSxLQUFLa3pDLE1BQUwsQ0FBRCxHQUNKLEtBQUtBLFNBQVMsQ0FBZCxLQUFvQixDQURoQixHQUVKLEtBQUtBLFNBQVMsQ0FBZCxLQUFvQixFQUZoQixHQUdKLEtBQUtBLFNBQVMsQ0FBZCxLQUFvQixFQUh2QjtBQUlELENBUEQ7O0FBU0FtQyxPQUFPejRCLFNBQVAsQ0FBaUIwaUMsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQnBNLE1BQXRCLEVBQThCdUwsUUFBOUIsRUFBd0M7QUFDckUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUtsekMsTUFBNUI7O0FBRWYsU0FBUSxLQUFLa3pDLE1BQUwsS0FBZ0IsRUFBakIsR0FDSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFEaEIsR0FFSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FGaEIsR0FHSixLQUFLQSxTQUFTLENBQWQsQ0FISDtBQUlELENBUEQ7O0FBU0FtQyxPQUFPejRCLFNBQVAsQ0FBaUIyaUMsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQnJNLE1BQXRCLEVBQThCdUwsUUFBOUIsRUFBd0M7QUFDckUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUtsekMsTUFBNUI7QUFDZixTQUFPMDRDLFFBQVE0RCxJQUFSLENBQWEsSUFBYixFQUFtQnBKLE1BQW5CLEVBQTJCLElBQTNCLEVBQWlDLEVBQWpDLEVBQXFDLENBQXJDLENBQVA7QUFDRCxDQUhEOztBQUtBbUMsT0FBT3o0QixTQUFQLENBQWlCNGlDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0J0TSxNQUF0QixFQUE4QnVMLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLbHpDLE1BQTVCO0FBQ2YsU0FBTzA0QyxRQUFRNEQsSUFBUixDQUFhLElBQWIsRUFBbUJwSixNQUFuQixFQUEyQixLQUEzQixFQUFrQyxFQUFsQyxFQUFzQyxDQUF0QyxDQUFQO0FBQ0QsQ0FIRDs7QUFLQW1DLE9BQU96NEIsU0FBUCxDQUFpQjZpQyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCdk0sTUFBdkIsRUFBK0J1TCxRQUEvQixFQUF5QztBQUN2RSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWXBMLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBS2x6QyxNQUE1QjtBQUNmLFNBQU8wNEMsUUFBUTRELElBQVIsQ0FBYSxJQUFiLEVBQW1CcEosTUFBbkIsRUFBMkIsSUFBM0IsRUFBaUMsRUFBakMsRUFBcUMsQ0FBckMsQ0FBUDtBQUNELENBSEQ7O0FBS0FtQyxPQUFPejRCLFNBQVAsQ0FBaUI4aUMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QnhNLE1BQXZCLEVBQStCdUwsUUFBL0IsRUFBeUM7QUFDdkUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUtsekMsTUFBNUI7QUFDZixTQUFPMDRDLFFBQVE0RCxJQUFSLENBQWEsSUFBYixFQUFtQnBKLE1BQW5CLEVBQTJCLEtBQTNCLEVBQWtDLEVBQWxDLEVBQXNDLENBQXRDLENBQVA7QUFDRCxDQUhEOztBQUtBLFNBQVN5TSxRQUFULENBQW1CakYsR0FBbkIsRUFBd0I3dUMsS0FBeEIsRUFBK0JxbkMsTUFBL0IsRUFBdUNxTCxHQUF2QyxFQUE0QzVxQyxHQUE1QyxFQUFpREQsR0FBakQsRUFBc0Q7QUFDcEQsTUFBSSxDQUFDMmhDLE9BQU9pRixRQUFQLENBQWdCSSxHQUFoQixDQUFMLEVBQTJCLE1BQU0sSUFBSXQ2QixTQUFKLENBQWMsNkNBQWQsQ0FBTjtBQUMzQixNQUFJdlUsUUFBUThILEdBQVIsSUFBZTlILFFBQVE2SCxHQUEzQixFQUFnQyxNQUFNLElBQUk0RixVQUFKLENBQWUsbUNBQWYsQ0FBTjtBQUNoQyxNQUFJNDVCLFNBQVNxTCxHQUFULEdBQWU3RCxJQUFJMTZDLE1BQXZCLEVBQStCLE1BQU0sSUFBSXNaLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQ2hDOztBQUVEKzdCLE9BQU96NEIsU0FBUCxDQUFpQmdqQyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCL3pDLEtBQXRCLEVBQTZCcW5DLE1BQTdCLEVBQXFDZ0UsVUFBckMsRUFBaUR1SCxRQUFqRCxFQUEyRDtBQUN4RjV5QyxVQUFRLENBQUNBLEtBQVQ7QUFDQXFuQyxXQUFTQSxTQUFTLENBQWxCO0FBQ0FnRSxlQUFhQSxhQUFhLENBQTFCO0FBQ0EsTUFBSSxDQUFDdUgsUUFBTCxFQUFlO0FBQ2IsUUFBSW9CLFdBQVczbUMsS0FBS3dYLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSXdtQixVQUFoQixJQUE4QixDQUE3QztBQUNBeUksYUFBUyxJQUFULEVBQWU5ekMsS0FBZixFQUFzQnFuQyxNQUF0QixFQUE4QmdFLFVBQTlCLEVBQTBDMkksUUFBMUMsRUFBb0QsQ0FBcEQ7QUFDRDs7QUFFRCxNQUFJbkIsTUFBTSxDQUFWO0FBQ0EsTUFBSS8rQyxJQUFJLENBQVI7QUFDQSxPQUFLdXpDLE1BQUwsSUFBZXJuQyxRQUFRLElBQXZCO0FBQ0EsU0FBTyxFQUFFbE0sQ0FBRixHQUFNdTNDLFVBQU4sS0FBcUJ3SCxPQUFPLEtBQTVCLENBQVAsRUFBMkM7QUFDekMsU0FBS3hMLFNBQVN2ekMsQ0FBZCxJQUFvQmtNLFFBQVE2eUMsR0FBVCxHQUFnQixJQUFuQztBQUNEOztBQUVELFNBQU94TCxTQUFTZ0UsVUFBaEI7QUFDRCxDQWpCRDs7QUFtQkE3QixPQUFPejRCLFNBQVAsQ0FBaUJrakMsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQmowQyxLQUF0QixFQUE2QnFuQyxNQUE3QixFQUFxQ2dFLFVBQXJDLEVBQWlEdUgsUUFBakQsRUFBMkQ7QUFDeEY1eUMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FxbkMsV0FBU0EsU0FBUyxDQUFsQjtBQUNBZ0UsZUFBYUEsYUFBYSxDQUExQjtBQUNBLE1BQUksQ0FBQ3VILFFBQUwsRUFBZTtBQUNiLFFBQUlvQixXQUFXM21DLEtBQUt3WCxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUl3bUIsVUFBaEIsSUFBOEIsQ0FBN0M7QUFDQXlJLGFBQVMsSUFBVCxFQUFlOXpDLEtBQWYsRUFBc0JxbkMsTUFBdEIsRUFBOEJnRSxVQUE5QixFQUEwQzJJLFFBQTFDLEVBQW9ELENBQXBEO0FBQ0Q7O0FBRUQsTUFBSWxnRCxJQUFJdTNDLGFBQWEsQ0FBckI7QUFDQSxNQUFJd0gsTUFBTSxDQUFWO0FBQ0EsT0FBS3hMLFNBQVN2ekMsQ0FBZCxJQUFtQmtNLFFBQVEsSUFBM0I7QUFDQSxTQUFPLEVBQUVsTSxDQUFGLElBQU8sQ0FBUCxLQUFhKytDLE9BQU8sS0FBcEIsQ0FBUCxFQUFtQztBQUNqQyxTQUFLeEwsU0FBU3Z6QyxDQUFkLElBQW9Ca00sUUFBUTZ5QyxHQUFULEdBQWdCLElBQW5DO0FBQ0Q7O0FBRUQsU0FBT3hMLFNBQVNnRSxVQUFoQjtBQUNELENBakJEOztBQW1CQTdCLE9BQU96NEIsU0FBUCxDQUFpQm1qQyxVQUFqQixHQUE4QixTQUFTQSxVQUFULENBQXFCbDBDLEtBQXJCLEVBQTRCcW5DLE1BQTVCLEVBQW9DdUwsUUFBcEMsRUFBOEM7QUFDMUU1eUMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FxbkMsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ3VMLFFBQUwsRUFBZWtCLFNBQVMsSUFBVCxFQUFlOXpDLEtBQWYsRUFBc0JxbkMsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsSUFBakMsRUFBdUMsQ0FBdkM7QUFDZixNQUFJLENBQUNtQyxPQUFPd0QsbUJBQVosRUFBaUNodEMsUUFBUXFOLEtBQUtwRixLQUFMLENBQVdqSSxLQUFYLENBQVI7QUFDakMsT0FBS3FuQyxNQUFMLElBQWdCcm5DLFFBQVEsSUFBeEI7QUFDQSxTQUFPcW5DLFNBQVMsQ0FBaEI7QUFDRCxDQVBEOztBQVNBLFNBQVM4TSxpQkFBVCxDQUE0QnRGLEdBQTVCLEVBQWlDN3VDLEtBQWpDLEVBQXdDcW5DLE1BQXhDLEVBQWdEK00sWUFBaEQsRUFBOEQ7QUFDNUQsTUFBSXAwQyxRQUFRLENBQVosRUFBZUEsUUFBUSxTQUFTQSxLQUFULEdBQWlCLENBQXpCO0FBQ2YsT0FBSyxJQUFJbE0sSUFBSSxDQUFSLEVBQVdzYixJQUFJL0IsS0FBS3hGLEdBQUwsQ0FBU2duQyxJQUFJMTZDLE1BQUosR0FBYWt6QyxNQUF0QixFQUE4QixDQUE5QixDQUFwQixFQUFzRHZ6QyxJQUFJc2IsQ0FBMUQsRUFBNkQsRUFBRXRiLENBQS9ELEVBQWtFO0FBQ2hFKzZDLFFBQUl4SCxTQUFTdnpDLENBQWIsSUFBa0IsQ0FBQ2tNLFFBQVMsUUFBUyxLQUFLbzBDLGVBQWV0Z0QsQ0FBZixHQUFtQixJQUFJQSxDQUE1QixDQUFuQixNQUNoQixDQUFDc2dELGVBQWV0Z0QsQ0FBZixHQUFtQixJQUFJQSxDQUF4QixJQUE2QixDQUQvQjtBQUVEO0FBQ0Y7O0FBRUQwMUMsT0FBT3o0QixTQUFQLENBQWlCc2pDLGFBQWpCLEdBQWlDLFNBQVNBLGFBQVQsQ0FBd0JyMEMsS0FBeEIsRUFBK0JxbkMsTUFBL0IsRUFBdUN1TCxRQUF2QyxFQUFpRDtBQUNoRjV5QyxVQUFRLENBQUNBLEtBQVQ7QUFDQXFuQyxXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDdUwsUUFBTCxFQUFla0IsU0FBUyxJQUFULEVBQWU5ekMsS0FBZixFQUFzQnFuQyxNQUF0QixFQUE4QixDQUE5QixFQUFpQyxNQUFqQyxFQUF5QyxDQUF6QztBQUNmLE1BQUltQyxPQUFPd0QsbUJBQVgsRUFBZ0M7QUFDOUIsU0FBSzNGLE1BQUwsSUFBZ0JybkMsUUFBUSxJQUF4QjtBQUNBLFNBQUtxbkMsU0FBUyxDQUFkLElBQW9Ccm5DLFVBQVUsQ0FBOUI7QUFDRCxHQUhELE1BR087QUFDTG0wQyxzQkFBa0IsSUFBbEIsRUFBd0JuMEMsS0FBeEIsRUFBK0JxbkMsTUFBL0IsRUFBdUMsSUFBdkM7QUFDRDtBQUNELFNBQU9BLFNBQVMsQ0FBaEI7QUFDRCxDQVhEOztBQWFBbUMsT0FBT3o0QixTQUFQLENBQWlCdWpDLGFBQWpCLEdBQWlDLFNBQVNBLGFBQVQsQ0FBd0J0MEMsS0FBeEIsRUFBK0JxbkMsTUFBL0IsRUFBdUN1TCxRQUF2QyxFQUFpRDtBQUNoRjV5QyxVQUFRLENBQUNBLEtBQVQ7QUFDQXFuQyxXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDdUwsUUFBTCxFQUFla0IsU0FBUyxJQUFULEVBQWU5ekMsS0FBZixFQUFzQnFuQyxNQUF0QixFQUE4QixDQUE5QixFQUFpQyxNQUFqQyxFQUF5QyxDQUF6QztBQUNmLE1BQUltQyxPQUFPd0QsbUJBQVgsRUFBZ0M7QUFDOUIsU0FBSzNGLE1BQUwsSUFBZ0JybkMsVUFBVSxDQUExQjtBQUNBLFNBQUtxbkMsU0FBUyxDQUFkLElBQW9Ccm5DLFFBQVEsSUFBNUI7QUFDRCxHQUhELE1BR087QUFDTG0wQyxzQkFBa0IsSUFBbEIsRUFBd0JuMEMsS0FBeEIsRUFBK0JxbkMsTUFBL0IsRUFBdUMsS0FBdkM7QUFDRDtBQUNELFNBQU9BLFNBQVMsQ0FBaEI7QUFDRCxDQVhEOztBQWFBLFNBQVNrTixpQkFBVCxDQUE0QjFGLEdBQTVCLEVBQWlDN3VDLEtBQWpDLEVBQXdDcW5DLE1BQXhDLEVBQWdEK00sWUFBaEQsRUFBOEQ7QUFDNUQsTUFBSXAwQyxRQUFRLENBQVosRUFBZUEsUUFBUSxhQUFhQSxLQUFiLEdBQXFCLENBQTdCO0FBQ2YsT0FBSyxJQUFJbE0sSUFBSSxDQUFSLEVBQVdzYixJQUFJL0IsS0FBS3hGLEdBQUwsQ0FBU2duQyxJQUFJMTZDLE1BQUosR0FBYWt6QyxNQUF0QixFQUE4QixDQUE5QixDQUFwQixFQUFzRHZ6QyxJQUFJc2IsQ0FBMUQsRUFBNkQsRUFBRXRiLENBQS9ELEVBQWtFO0FBQ2hFKzZDLFFBQUl4SCxTQUFTdnpDLENBQWIsSUFBbUJrTSxVQUFVLENBQUNvMEMsZUFBZXRnRCxDQUFmLEdBQW1CLElBQUlBLENBQXhCLElBQTZCLENBQXhDLEdBQTZDLElBQS9EO0FBQ0Q7QUFDRjs7QUFFRDAxQyxPQUFPejRCLFNBQVAsQ0FBaUJ5akMsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QngwQyxLQUF4QixFQUErQnFuQyxNQUEvQixFQUF1Q3VMLFFBQXZDLEVBQWlEO0FBQ2hGNXlDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcW5DLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUN1TCxRQUFMLEVBQWVrQixTQUFTLElBQVQsRUFBZTl6QyxLQUFmLEVBQXNCcW5DLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLFVBQWpDLEVBQTZDLENBQTdDO0FBQ2YsTUFBSW1DLE9BQU93RCxtQkFBWCxFQUFnQztBQUM5QixTQUFLM0YsU0FBUyxDQUFkLElBQW9Ccm5DLFVBQVUsRUFBOUI7QUFDQSxTQUFLcW5DLFNBQVMsQ0FBZCxJQUFvQnJuQyxVQUFVLEVBQTlCO0FBQ0EsU0FBS3FuQyxTQUFTLENBQWQsSUFBb0JybkMsVUFBVSxDQUE5QjtBQUNBLFNBQUtxbkMsTUFBTCxJQUFnQnJuQyxRQUFRLElBQXhCO0FBQ0QsR0FMRCxNQUtPO0FBQ0x1MEMsc0JBQWtCLElBQWxCLEVBQXdCdjBDLEtBQXhCLEVBQStCcW5DLE1BQS9CLEVBQXVDLElBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FiRDs7QUFlQW1DLE9BQU96NEIsU0FBUCxDQUFpQjBqQyxhQUFqQixHQUFpQyxTQUFTQSxhQUFULENBQXdCejBDLEtBQXhCLEVBQStCcW5DLE1BQS9CLEVBQXVDdUwsUUFBdkMsRUFBaUQ7QUFDaEY1eUMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FxbkMsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ3VMLFFBQUwsRUFBZWtCLFNBQVMsSUFBVCxFQUFlOXpDLEtBQWYsRUFBc0JxbkMsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsVUFBakMsRUFBNkMsQ0FBN0M7QUFDZixNQUFJbUMsT0FBT3dELG1CQUFYLEVBQWdDO0FBQzlCLFNBQUszRixNQUFMLElBQWdCcm5DLFVBQVUsRUFBMUI7QUFDQSxTQUFLcW5DLFNBQVMsQ0FBZCxJQUFvQnJuQyxVQUFVLEVBQTlCO0FBQ0EsU0FBS3FuQyxTQUFTLENBQWQsSUFBb0JybkMsVUFBVSxDQUE5QjtBQUNBLFNBQUtxbkMsU0FBUyxDQUFkLElBQW9Ccm5DLFFBQVEsSUFBNUI7QUFDRCxHQUxELE1BS087QUFDTHUwQyxzQkFBa0IsSUFBbEIsRUFBd0J2MEMsS0FBeEIsRUFBK0JxbkMsTUFBL0IsRUFBdUMsS0FBdkM7QUFDRDtBQUNELFNBQU9BLFNBQVMsQ0FBaEI7QUFDRCxDQWJEOztBQWVBbUMsT0FBT3o0QixTQUFQLENBQWlCMmpDLFVBQWpCLEdBQThCLFNBQVNBLFVBQVQsQ0FBcUIxMEMsS0FBckIsRUFBNEJxbkMsTUFBNUIsRUFBb0NnRSxVQUFwQyxFQUFnRHVILFFBQWhELEVBQTBEO0FBQ3RGNXlDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcW5DLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUN1TCxRQUFMLEVBQWU7QUFDYixRQUFJK0IsUUFBUXRuQyxLQUFLd1gsR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJd21CLFVBQUosR0FBaUIsQ0FBN0IsQ0FBWjs7QUFFQXlJLGFBQVMsSUFBVCxFQUFlOXpDLEtBQWYsRUFBc0JxbkMsTUFBdEIsRUFBOEJnRSxVQUE5QixFQUEwQ3NKLFFBQVEsQ0FBbEQsRUFBcUQsQ0FBQ0EsS0FBdEQ7QUFDRDs7QUFFRCxNQUFJN2dELElBQUksQ0FBUjtBQUNBLE1BQUkrK0MsTUFBTSxDQUFWO0FBQ0EsTUFBSStCLE1BQU0sQ0FBVjtBQUNBLE9BQUt2TixNQUFMLElBQWVybkMsUUFBUSxJQUF2QjtBQUNBLFNBQU8sRUFBRWxNLENBQUYsR0FBTXUzQyxVQUFOLEtBQXFCd0gsT0FBTyxLQUE1QixDQUFQLEVBQTJDO0FBQ3pDLFFBQUk3eUMsUUFBUSxDQUFSLElBQWE0MEMsUUFBUSxDQUFyQixJQUEwQixLQUFLdk4sU0FBU3Z6QyxDQUFULEdBQWEsQ0FBbEIsTUFBeUIsQ0FBdkQsRUFBMEQ7QUFDeEQ4Z0QsWUFBTSxDQUFOO0FBQ0Q7QUFDRCxTQUFLdk4sU0FBU3Z6QyxDQUFkLElBQW1CLENBQUVrTSxRQUFRNnlDLEdBQVQsSUFBaUIsQ0FBbEIsSUFBdUIrQixHQUF2QixHQUE2QixJQUFoRDtBQUNEOztBQUVELFNBQU92TixTQUFTZ0UsVUFBaEI7QUFDRCxDQXJCRDs7QUF1QkE3QixPQUFPejRCLFNBQVAsQ0FBaUI4akMsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQjcwQyxLQUFyQixFQUE0QnFuQyxNQUE1QixFQUFvQ2dFLFVBQXBDLEVBQWdEdUgsUUFBaEQsRUFBMEQ7QUFDdEY1eUMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FxbkMsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ3VMLFFBQUwsRUFBZTtBQUNiLFFBQUkrQixRQUFRdG5DLEtBQUt3WCxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUl3bUIsVUFBSixHQUFpQixDQUE3QixDQUFaOztBQUVBeUksYUFBUyxJQUFULEVBQWU5ekMsS0FBZixFQUFzQnFuQyxNQUF0QixFQUE4QmdFLFVBQTlCLEVBQTBDc0osUUFBUSxDQUFsRCxFQUFxRCxDQUFDQSxLQUF0RDtBQUNEOztBQUVELE1BQUk3Z0QsSUFBSXUzQyxhQUFhLENBQXJCO0FBQ0EsTUFBSXdILE1BQU0sQ0FBVjtBQUNBLE1BQUkrQixNQUFNLENBQVY7QUFDQSxPQUFLdk4sU0FBU3Z6QyxDQUFkLElBQW1Ca00sUUFBUSxJQUEzQjtBQUNBLFNBQU8sRUFBRWxNLENBQUYsSUFBTyxDQUFQLEtBQWErK0MsT0FBTyxLQUFwQixDQUFQLEVBQW1DO0FBQ2pDLFFBQUk3eUMsUUFBUSxDQUFSLElBQWE0MEMsUUFBUSxDQUFyQixJQUEwQixLQUFLdk4sU0FBU3Z6QyxDQUFULEdBQWEsQ0FBbEIsTUFBeUIsQ0FBdkQsRUFBMEQ7QUFDeEQ4Z0QsWUFBTSxDQUFOO0FBQ0Q7QUFDRCxTQUFLdk4sU0FBU3Z6QyxDQUFkLElBQW1CLENBQUVrTSxRQUFRNnlDLEdBQVQsSUFBaUIsQ0FBbEIsSUFBdUIrQixHQUF2QixHQUE2QixJQUFoRDtBQUNEOztBQUVELFNBQU92TixTQUFTZ0UsVUFBaEI7QUFDRCxDQXJCRDs7QUF1QkE3QixPQUFPejRCLFNBQVAsQ0FBaUIrakMsU0FBakIsR0FBNkIsU0FBU0EsU0FBVCxDQUFvQjkwQyxLQUFwQixFQUEyQnFuQyxNQUEzQixFQUFtQ3VMLFFBQW5DLEVBQTZDO0FBQ3hFNXlDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcW5DLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUN1TCxRQUFMLEVBQWVrQixTQUFTLElBQVQsRUFBZTl6QyxLQUFmLEVBQXNCcW5DLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLElBQWpDLEVBQXVDLENBQUMsSUFBeEM7QUFDZixNQUFJLENBQUNtQyxPQUFPd0QsbUJBQVosRUFBaUNodEMsUUFBUXFOLEtBQUtwRixLQUFMLENBQVdqSSxLQUFYLENBQVI7QUFDakMsTUFBSUEsUUFBUSxDQUFaLEVBQWVBLFFBQVEsT0FBT0EsS0FBUCxHQUFlLENBQXZCO0FBQ2YsT0FBS3FuQyxNQUFMLElBQWdCcm5DLFFBQVEsSUFBeEI7QUFDQSxTQUFPcW5DLFNBQVMsQ0FBaEI7QUFDRCxDQVJEOztBQVVBbUMsT0FBT3o0QixTQUFQLENBQWlCZ2tDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUIvMEMsS0FBdkIsRUFBOEJxbkMsTUFBOUIsRUFBc0N1TCxRQUF0QyxFQUFnRDtBQUM5RTV5QyxVQUFRLENBQUNBLEtBQVQ7QUFDQXFuQyxXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDdUwsUUFBTCxFQUFla0IsU0FBUyxJQUFULEVBQWU5ekMsS0FBZixFQUFzQnFuQyxNQUF0QixFQUE4QixDQUE5QixFQUFpQyxNQUFqQyxFQUF5QyxDQUFDLE1BQTFDO0FBQ2YsTUFBSW1DLE9BQU93RCxtQkFBWCxFQUFnQztBQUM5QixTQUFLM0YsTUFBTCxJQUFnQnJuQyxRQUFRLElBQXhCO0FBQ0EsU0FBS3FuQyxTQUFTLENBQWQsSUFBb0JybkMsVUFBVSxDQUE5QjtBQUNELEdBSEQsTUFHTztBQUNMbTBDLHNCQUFrQixJQUFsQixFQUF3Qm4wQyxLQUF4QixFQUErQnFuQyxNQUEvQixFQUF1QyxJQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBWEQ7O0FBYUFtQyxPQUFPejRCLFNBQVAsQ0FBaUJpa0MsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QmgxQyxLQUF2QixFQUE4QnFuQyxNQUE5QixFQUFzQ3VMLFFBQXRDLEVBQWdEO0FBQzlFNXlDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcW5DLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUN1TCxRQUFMLEVBQWVrQixTQUFTLElBQVQsRUFBZTl6QyxLQUFmLEVBQXNCcW5DLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLE1BQWpDLEVBQXlDLENBQUMsTUFBMUM7QUFDZixNQUFJbUMsT0FBT3dELG1CQUFYLEVBQWdDO0FBQzlCLFNBQUszRixNQUFMLElBQWdCcm5DLFVBQVUsQ0FBMUI7QUFDQSxTQUFLcW5DLFNBQVMsQ0FBZCxJQUFvQnJuQyxRQUFRLElBQTVCO0FBQ0QsR0FIRCxNQUdPO0FBQ0xtMEMsc0JBQWtCLElBQWxCLEVBQXdCbjBDLEtBQXhCLEVBQStCcW5DLE1BQS9CLEVBQXVDLEtBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FYRDs7QUFhQW1DLE9BQU96NEIsU0FBUCxDQUFpQmtrQyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCajFDLEtBQXZCLEVBQThCcW5DLE1BQTlCLEVBQXNDdUwsUUFBdEMsRUFBZ0Q7QUFDOUU1eUMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FxbkMsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ3VMLFFBQUwsRUFBZWtCLFNBQVMsSUFBVCxFQUFlOXpDLEtBQWYsRUFBc0JxbkMsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsVUFBakMsRUFBNkMsQ0FBQyxVQUE5QztBQUNmLE1BQUltQyxPQUFPd0QsbUJBQVgsRUFBZ0M7QUFDOUIsU0FBSzNGLE1BQUwsSUFBZ0JybkMsUUFBUSxJQUF4QjtBQUNBLFNBQUtxbkMsU0FBUyxDQUFkLElBQW9Ccm5DLFVBQVUsQ0FBOUI7QUFDQSxTQUFLcW5DLFNBQVMsQ0FBZCxJQUFvQnJuQyxVQUFVLEVBQTlCO0FBQ0EsU0FBS3FuQyxTQUFTLENBQWQsSUFBb0JybkMsVUFBVSxFQUE5QjtBQUNELEdBTEQsTUFLTztBQUNMdTBDLHNCQUFrQixJQUFsQixFQUF3QnYwQyxLQUF4QixFQUErQnFuQyxNQUEvQixFQUF1QyxJQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBYkQ7O0FBZUFtQyxPQUFPejRCLFNBQVAsQ0FBaUJta0MsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QmwxQyxLQUF2QixFQUE4QnFuQyxNQUE5QixFQUFzQ3VMLFFBQXRDLEVBQWdEO0FBQzlFNXlDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBcW5DLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUN1TCxRQUFMLEVBQWVrQixTQUFTLElBQVQsRUFBZTl6QyxLQUFmLEVBQXNCcW5DLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLFVBQWpDLEVBQTZDLENBQUMsVUFBOUM7QUFDZixNQUFJcm5DLFFBQVEsQ0FBWixFQUFlQSxRQUFRLGFBQWFBLEtBQWIsR0FBcUIsQ0FBN0I7QUFDZixNQUFJd3BDLE9BQU93RCxtQkFBWCxFQUFnQztBQUM5QixTQUFLM0YsTUFBTCxJQUFnQnJuQyxVQUFVLEVBQTFCO0FBQ0EsU0FBS3FuQyxTQUFTLENBQWQsSUFBb0JybkMsVUFBVSxFQUE5QjtBQUNBLFNBQUtxbkMsU0FBUyxDQUFkLElBQW9Ccm5DLFVBQVUsQ0FBOUI7QUFDQSxTQUFLcW5DLFNBQVMsQ0FBZCxJQUFvQnJuQyxRQUFRLElBQTVCO0FBQ0QsR0FMRCxNQUtPO0FBQ0x1MEMsc0JBQWtCLElBQWxCLEVBQXdCdjBDLEtBQXhCLEVBQStCcW5DLE1BQS9CLEVBQXVDLEtBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FkRDs7QUFnQkEsU0FBUzhOLFlBQVQsQ0FBdUJ0RyxHQUF2QixFQUE0Qjd1QyxLQUE1QixFQUFtQ3FuQyxNQUFuQyxFQUEyQ3FMLEdBQTNDLEVBQWdENXFDLEdBQWhELEVBQXFERCxHQUFyRCxFQUEwRDtBQUN4RCxNQUFJdy9CLFNBQVNxTCxHQUFULEdBQWU3RCxJQUFJMTZDLE1BQXZCLEVBQStCLE1BQU0sSUFBSXNaLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQy9CLE1BQUk0NUIsU0FBUyxDQUFiLEVBQWdCLE1BQU0sSUFBSTU1QixVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNqQjs7QUFFRCxTQUFTMm5DLFVBQVQsQ0FBcUJ2RyxHQUFyQixFQUEwQjd1QyxLQUExQixFQUFpQ3FuQyxNQUFqQyxFQUF5QytNLFlBQXpDLEVBQXVEeEIsUUFBdkQsRUFBaUU7QUFDL0QsTUFBSSxDQUFDQSxRQUFMLEVBQWU7QUFDYnVDLGlCQUFhdEcsR0FBYixFQUFrQjd1QyxLQUFsQixFQUF5QnFuQyxNQUF6QixFQUFpQyxDQUFqQyxFQUFvQyxzQkFBcEMsRUFBNEQsQ0FBQyxzQkFBN0Q7QUFDRDtBQUNEd0YsVUFBUXlCLEtBQVIsQ0FBY08sR0FBZCxFQUFtQjd1QyxLQUFuQixFQUEwQnFuQyxNQUExQixFQUFrQytNLFlBQWxDLEVBQWdELEVBQWhELEVBQW9ELENBQXBEO0FBQ0EsU0FBTy9NLFNBQVMsQ0FBaEI7QUFDRDs7QUFFRG1DLE9BQU96NEIsU0FBUCxDQUFpQnNrQyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCcjFDLEtBQXZCLEVBQThCcW5DLE1BQTlCLEVBQXNDdUwsUUFBdEMsRUFBZ0Q7QUFDOUUsU0FBT3dDLFdBQVcsSUFBWCxFQUFpQnAxQyxLQUFqQixFQUF3QnFuQyxNQUF4QixFQUFnQyxJQUFoQyxFQUFzQ3VMLFFBQXRDLENBQVA7QUFDRCxDQUZEOztBQUlBcEosT0FBT3o0QixTQUFQLENBQWlCdWtDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJ0MUMsS0FBdkIsRUFBOEJxbkMsTUFBOUIsRUFBc0N1TCxRQUF0QyxFQUFnRDtBQUM5RSxTQUFPd0MsV0FBVyxJQUFYLEVBQWlCcDFDLEtBQWpCLEVBQXdCcW5DLE1BQXhCLEVBQWdDLEtBQWhDLEVBQXVDdUwsUUFBdkMsQ0FBUDtBQUNELENBRkQ7O0FBSUEsU0FBUzJDLFdBQVQsQ0FBc0IxRyxHQUF0QixFQUEyQjd1QyxLQUEzQixFQUFrQ3FuQyxNQUFsQyxFQUEwQytNLFlBQTFDLEVBQXdEeEIsUUFBeEQsRUFBa0U7QUFDaEUsTUFBSSxDQUFDQSxRQUFMLEVBQWU7QUFDYnVDLGlCQUFhdEcsR0FBYixFQUFrQjd1QyxLQUFsQixFQUF5QnFuQyxNQUF6QixFQUFpQyxDQUFqQyxFQUFvQyx1QkFBcEMsRUFBNkQsQ0FBQyx1QkFBOUQ7QUFDRDtBQUNEd0YsVUFBUXlCLEtBQVIsQ0FBY08sR0FBZCxFQUFtQjd1QyxLQUFuQixFQUEwQnFuQyxNQUExQixFQUFrQytNLFlBQWxDLEVBQWdELEVBQWhELEVBQW9ELENBQXBEO0FBQ0EsU0FBTy9NLFNBQVMsQ0FBaEI7QUFDRDs7QUFFRG1DLE9BQU96NEIsU0FBUCxDQUFpQnlrQyxhQUFqQixHQUFpQyxTQUFTQSxhQUFULENBQXdCeDFDLEtBQXhCLEVBQStCcW5DLE1BQS9CLEVBQXVDdUwsUUFBdkMsRUFBaUQ7QUFDaEYsU0FBTzJDLFlBQVksSUFBWixFQUFrQnYxQyxLQUFsQixFQUF5QnFuQyxNQUF6QixFQUFpQyxJQUFqQyxFQUF1Q3VMLFFBQXZDLENBQVA7QUFDRCxDQUZEOztBQUlBcEosT0FBT3o0QixTQUFQLENBQWlCMGtDLGFBQWpCLEdBQWlDLFNBQVNBLGFBQVQsQ0FBd0J6MUMsS0FBeEIsRUFBK0JxbkMsTUFBL0IsRUFBdUN1TCxRQUF2QyxFQUFpRDtBQUNoRixTQUFPMkMsWUFBWSxJQUFaLEVBQWtCdjFDLEtBQWxCLEVBQXlCcW5DLE1BQXpCLEVBQWlDLEtBQWpDLEVBQXdDdUwsUUFBeEMsQ0FBUDtBQUNELENBRkQ7O0FBSUE7QUFDQXBKLE9BQU96NEIsU0FBUCxDQUFpQjI5QixJQUFqQixHQUF3QixTQUFTQSxJQUFULENBQWU1dkMsTUFBZixFQUF1QjQyQyxXQUF2QixFQUFvQzFxQyxLQUFwQyxFQUEyQ1AsR0FBM0MsRUFBZ0Q7QUFDdEUsTUFBSSxDQUFDTyxLQUFMLEVBQVlBLFFBQVEsQ0FBUjtBQUNaLE1BQUksQ0FBQ1AsR0FBRCxJQUFRQSxRQUFRLENBQXBCLEVBQXVCQSxNQUFNLEtBQUt0VyxNQUFYO0FBQ3ZCLE1BQUl1aEQsZUFBZTUyQyxPQUFPM0ssTUFBMUIsRUFBa0N1aEQsY0FBYzUyQyxPQUFPM0ssTUFBckI7QUFDbEMsTUFBSSxDQUFDdWhELFdBQUwsRUFBa0JBLGNBQWMsQ0FBZDtBQUNsQixNQUFJanJDLE1BQU0sQ0FBTixJQUFXQSxNQUFNTyxLQUFyQixFQUE0QlAsTUFBTU8sS0FBTjs7QUFFNUI7QUFDQSxNQUFJUCxRQUFRTyxLQUFaLEVBQW1CLE9BQU8sQ0FBUDtBQUNuQixNQUFJbE0sT0FBTzNLLE1BQVAsS0FBa0IsQ0FBbEIsSUFBdUIsS0FBS0EsTUFBTCxLQUFnQixDQUEzQyxFQUE4QyxPQUFPLENBQVA7O0FBRTlDO0FBQ0EsTUFBSXVoRCxjQUFjLENBQWxCLEVBQXFCO0FBQ25CLFVBQU0sSUFBSWpvQyxVQUFKLENBQWUsMkJBQWYsQ0FBTjtBQUNEO0FBQ0QsTUFBSXpDLFFBQVEsQ0FBUixJQUFhQSxTQUFTLEtBQUs3VyxNQUEvQixFQUF1QyxNQUFNLElBQUlzWixVQUFKLENBQWUsMkJBQWYsQ0FBTjtBQUN2QyxNQUFJaEQsTUFBTSxDQUFWLEVBQWEsTUFBTSxJQUFJZ0QsVUFBSixDQUFlLHlCQUFmLENBQU47O0FBRWI7QUFDQSxNQUFJaEQsTUFBTSxLQUFLdFcsTUFBZixFQUF1QnNXLE1BQU0sS0FBS3RXLE1BQVg7QUFDdkIsTUFBSTJLLE9BQU8zSyxNQUFQLEdBQWdCdWhELFdBQWhCLEdBQThCanJDLE1BQU1PLEtBQXhDLEVBQStDO0FBQzdDUCxVQUFNM0wsT0FBTzNLLE1BQVAsR0FBZ0J1aEQsV0FBaEIsR0FBOEIxcUMsS0FBcEM7QUFDRDs7QUFFRCxNQUFJc0csTUFBTTdHLE1BQU1PLEtBQWhCO0FBQ0EsTUFBSWxYLENBQUo7O0FBRUEsTUFBSSxTQUFTZ0wsTUFBVCxJQUFtQmtNLFFBQVEwcUMsV0FBM0IsSUFBMENBLGNBQWNqckMsR0FBNUQsRUFBaUU7QUFDL0Q7QUFDQSxTQUFLM1csSUFBSXdkLE1BQU0sQ0FBZixFQUFrQnhkLEtBQUssQ0FBdkIsRUFBMEIsRUFBRUEsQ0FBNUIsRUFBK0I7QUFDN0JnTCxhQUFPaEwsSUFBSTRoRCxXQUFYLElBQTBCLEtBQUs1aEQsSUFBSWtYLEtBQVQsQ0FBMUI7QUFDRDtBQUNGLEdBTEQsTUFLTyxJQUFJc0csTUFBTSxJQUFOLElBQWMsQ0FBQ2s0QixPQUFPd0QsbUJBQTFCLEVBQStDO0FBQ3BEO0FBQ0EsU0FBS2w1QyxJQUFJLENBQVQsRUFBWUEsSUFBSXdkLEdBQWhCLEVBQXFCLEVBQUV4ZCxDQUF2QixFQUEwQjtBQUN4QmdMLGFBQU9oTCxJQUFJNGhELFdBQVgsSUFBMEIsS0FBSzVoRCxJQUFJa1gsS0FBVCxDQUExQjtBQUNEO0FBQ0YsR0FMTSxNQUtBO0FBQ0wyZ0MsZUFBVzU2QixTQUFYLENBQXFCblMsR0FBckIsQ0FBeUJvUyxJQUF6QixDQUNFbFMsTUFERixFQUVFLEtBQUtzdUMsUUFBTCxDQUFjcGlDLEtBQWQsRUFBcUJBLFFBQVFzRyxHQUE3QixDQUZGLEVBR0Vva0MsV0FIRjtBQUtEOztBQUVELFNBQU9wa0MsR0FBUDtBQUNELENBOUNEOztBQWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBazRCLE9BQU96NEIsU0FBUCxDQUFpQnBPLElBQWpCLEdBQXdCLFNBQVNBLElBQVQsQ0FBZWl4QixHQUFmLEVBQW9CNW9CLEtBQXBCLEVBQTJCUCxHQUEzQixFQUFnQ2xKLFFBQWhDLEVBQTBDO0FBQ2hFO0FBQ0EsTUFBSSxPQUFPcXlCLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQixRQUFJLE9BQU81b0IsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QnpKLGlCQUFXeUosS0FBWDtBQUNBQSxjQUFRLENBQVI7QUFDQVAsWUFBTSxLQUFLdFcsTUFBWDtBQUNELEtBSkQsTUFJTyxJQUFJLE9BQU9zVyxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDbENsSixpQkFBV2tKLEdBQVg7QUFDQUEsWUFBTSxLQUFLdFcsTUFBWDtBQUNEO0FBQ0QsUUFBSXkvQixJQUFJei9CLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixVQUFJeTNDLE9BQU9oWSxJQUFJM2xCLFVBQUosQ0FBZSxDQUFmLENBQVg7QUFDQSxVQUFJMjlCLE9BQU8sR0FBWCxFQUFnQjtBQUNkaFksY0FBTWdZLElBQU47QUFDRDtBQUNGO0FBQ0QsUUFBSXJxQyxhQUFhekosU0FBYixJQUEwQixPQUFPeUosUUFBUCxLQUFvQixRQUFsRCxFQUE0RDtBQUMxRCxZQUFNLElBQUlnVCxTQUFKLENBQWMsMkJBQWQsQ0FBTjtBQUNEO0FBQ0QsUUFBSSxPQUFPaFQsUUFBUCxLQUFvQixRQUFwQixJQUFnQyxDQUFDaW9DLE9BQU82RSxVQUFQLENBQWtCOXNDLFFBQWxCLENBQXJDLEVBQWtFO0FBQ2hFLFlBQU0sSUFBSWdULFNBQUosQ0FBYyx1QkFBdUJoVCxRQUFyQyxDQUFOO0FBQ0Q7QUFDRixHQXJCRCxNQXFCTyxJQUFJLE9BQU9xeUIsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ2xDQSxVQUFNQSxNQUFNLEdBQVo7QUFDRDs7QUFFRDtBQUNBLE1BQUk1b0IsUUFBUSxDQUFSLElBQWEsS0FBSzdXLE1BQUwsR0FBYzZXLEtBQTNCLElBQW9DLEtBQUs3VyxNQUFMLEdBQWNzVyxHQUF0RCxFQUEyRDtBQUN6RCxVQUFNLElBQUlnRCxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNEOztBQUVELE1BQUloRCxPQUFPTyxLQUFYLEVBQWtCO0FBQ2hCLFdBQU8sSUFBUDtBQUNEOztBQUVEQSxVQUFRQSxVQUFVLENBQWxCO0FBQ0FQLFFBQU1BLFFBQVEzUyxTQUFSLEdBQW9CLEtBQUszRCxNQUF6QixHQUFrQ3NXLFFBQVEsQ0FBaEQ7O0FBRUEsTUFBSSxDQUFDbXBCLEdBQUwsRUFBVUEsTUFBTSxDQUFOOztBQUVWLE1BQUk5L0IsQ0FBSjtBQUNBLE1BQUksT0FBTzgvQixHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsU0FBSzkvQixJQUFJa1gsS0FBVCxFQUFnQmxYLElBQUkyVyxHQUFwQixFQUF5QixFQUFFM1csQ0FBM0IsRUFBOEI7QUFDNUIsV0FBS0EsQ0FBTCxJQUFVOC9CLEdBQVY7QUFDRDtBQUNGLEdBSkQsTUFJTztBQUNMLFFBQUkwZSxRQUFROUksT0FBT2lGLFFBQVAsQ0FBZ0I3YSxHQUFoQixJQUNSQSxHQURRLEdBRVJvYixZQUFZLElBQUl4RixNQUFKLENBQVc1VixHQUFYLEVBQWdCcnlCLFFBQWhCLEVBQTBCL0gsUUFBMUIsRUFBWixDQUZKO0FBR0EsUUFBSThYLE1BQU1naEMsTUFBTW4rQyxNQUFoQjtBQUNBLFNBQUtMLElBQUksQ0FBVCxFQUFZQSxJQUFJMlcsTUFBTU8sS0FBdEIsRUFBNkIsRUFBRWxYLENBQS9CLEVBQWtDO0FBQ2hDLFdBQUtBLElBQUlrWCxLQUFULElBQWtCc25DLE1BQU14K0MsSUFBSXdkLEdBQVYsQ0FBbEI7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNELENBekREOztBQTJEQTtBQUNBOztBQUVBLElBQUlxa0Msb0JBQW9CLG9CQUF4Qjs7QUFFQSxTQUFTQyxXQUFULENBQXNCNTVCLEdBQXRCLEVBQTJCO0FBQ3pCO0FBQ0FBLFFBQU02NUIsV0FBVzc1QixHQUFYLEVBQWdCcm5CLE9BQWhCLENBQXdCZ2hELGlCQUF4QixFQUEyQyxFQUEzQyxDQUFOO0FBQ0E7QUFDQSxNQUFJMzVCLElBQUk3bkIsTUFBSixHQUFhLENBQWpCLEVBQW9CLE9BQU8sRUFBUDtBQUNwQjtBQUNBLFNBQU82bkIsSUFBSTduQixNQUFKLEdBQWEsQ0FBYixLQUFtQixDQUExQixFQUE2QjtBQUMzQjZuQixVQUFNQSxNQUFNLEdBQVo7QUFDRDtBQUNELFNBQU9BLEdBQVA7QUFDRDs7QUFFRCxTQUFTNjVCLFVBQVQsQ0FBcUI3NUIsR0FBckIsRUFBMEI7QUFDeEIsTUFBSUEsSUFBSW5ILElBQVIsRUFBYyxPQUFPbUgsSUFBSW5ILElBQUosRUFBUDtBQUNkLFNBQU9tSCxJQUFJcm5CLE9BQUosQ0FBWSxZQUFaLEVBQTBCLEVBQTFCLENBQVA7QUFDRDs7QUFFRCxTQUFTMDlDLEtBQVQsQ0FBZ0JwakMsQ0FBaEIsRUFBbUI7QUFDakIsTUFBSUEsSUFBSSxFQUFSLEVBQVksT0FBTyxNQUFNQSxFQUFFelYsUUFBRixDQUFXLEVBQVgsQ0FBYjtBQUNaLFNBQU95VixFQUFFelYsUUFBRixDQUFXLEVBQVgsQ0FBUDtBQUNEOztBQUVELFNBQVN3MUMsV0FBVCxDQUFzQnRvQyxNQUF0QixFQUE4QnZHLEtBQTlCLEVBQXFDO0FBQ25DQSxVQUFRQSxTQUFTaUssUUFBakI7QUFDQSxNQUFJZ0UsU0FBSjtBQUNBLE1BQUlqYSxTQUFTdVMsT0FBT3ZTLE1BQXBCO0FBQ0EsTUFBSTJoRCxnQkFBZ0IsSUFBcEI7QUFDQSxNQUFJeEQsUUFBUSxFQUFaOztBQUVBLE9BQUssSUFBSXgrQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlLLE1BQXBCLEVBQTRCLEVBQUVMLENBQTlCLEVBQWlDO0FBQy9Cc2EsZ0JBQVkxSCxPQUFPdUgsVUFBUCxDQUFrQm5hLENBQWxCLENBQVo7O0FBRUE7QUFDQSxRQUFJc2EsWUFBWSxNQUFaLElBQXNCQSxZQUFZLE1BQXRDLEVBQThDO0FBQzVDO0FBQ0EsVUFBSSxDQUFDMG5DLGFBQUwsRUFBb0I7QUFDbEI7QUFDQSxZQUFJMW5DLFlBQVksTUFBaEIsRUFBd0I7QUFDdEI7QUFDQSxjQUFJLENBQUNqTyxTQUFTLENBQVYsSUFBZSxDQUFDLENBQXBCLEVBQXVCbXlDLE1BQU14OUMsSUFBTixDQUFXLElBQVgsRUFBaUIsSUFBakIsRUFBdUIsSUFBdkI7QUFDdkI7QUFDRCxTQUpELE1BSU8sSUFBSWhCLElBQUksQ0FBSixLQUFVSyxNQUFkLEVBQXNCO0FBQzNCO0FBQ0EsY0FBSSxDQUFDZ00sU0FBUyxDQUFWLElBQWUsQ0FBQyxDQUFwQixFQUF1Qm15QyxNQUFNeDlDLElBQU4sQ0FBVyxJQUFYLEVBQWlCLElBQWpCLEVBQXVCLElBQXZCO0FBQ3ZCO0FBQ0Q7O0FBRUQ7QUFDQWdoRCx3QkFBZ0IxbkMsU0FBaEI7O0FBRUE7QUFDRDs7QUFFRDtBQUNBLFVBQUlBLFlBQVksTUFBaEIsRUFBd0I7QUFDdEIsWUFBSSxDQUFDak8sU0FBUyxDQUFWLElBQWUsQ0FBQyxDQUFwQixFQUF1Qm15QyxNQUFNeDlDLElBQU4sQ0FBVyxJQUFYLEVBQWlCLElBQWpCLEVBQXVCLElBQXZCO0FBQ3ZCZ2hELHdCQUFnQjFuQyxTQUFoQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQUEsa0JBQVksQ0FBQzBuQyxnQkFBZ0IsTUFBaEIsSUFBMEIsRUFBMUIsR0FBK0IxbkMsWUFBWSxNQUE1QyxJQUFzRCxPQUFsRTtBQUNELEtBN0JELE1BNkJPLElBQUkwbkMsYUFBSixFQUFtQjtBQUN4QjtBQUNBLFVBQUksQ0FBQzMxQyxTQUFTLENBQVYsSUFBZSxDQUFDLENBQXBCLEVBQXVCbXlDLE1BQU14OUMsSUFBTixDQUFXLElBQVgsRUFBaUIsSUFBakIsRUFBdUIsSUFBdkI7QUFDeEI7O0FBRURnaEQsb0JBQWdCLElBQWhCOztBQUVBO0FBQ0EsUUFBSTFuQyxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLFVBQUksQ0FBQ2pPLFNBQVMsQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ3RCbXlDLFlBQU14OUMsSUFBTixDQUFXc1osU0FBWDtBQUNELEtBSEQsTUFHTyxJQUFJQSxZQUFZLEtBQWhCLEVBQXVCO0FBQzVCLFVBQUksQ0FBQ2pPLFNBQVMsQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ3RCbXlDLFlBQU14OUMsSUFBTixDQUNFc1osYUFBYSxHQUFiLEdBQW1CLElBRHJCLEVBRUVBLFlBQVksSUFBWixHQUFtQixJQUZyQjtBQUlELEtBTk0sTUFNQSxJQUFJQSxZQUFZLE9BQWhCLEVBQXlCO0FBQzlCLFVBQUksQ0FBQ2pPLFNBQVMsQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ3RCbXlDLFlBQU14OUMsSUFBTixDQUNFc1osYUFBYSxHQUFiLEdBQW1CLElBRHJCLEVBRUVBLGFBQWEsR0FBYixHQUFtQixJQUFuQixHQUEwQixJQUY1QixFQUdFQSxZQUFZLElBQVosR0FBbUIsSUFIckI7QUFLRCxLQVBNLE1BT0EsSUFBSUEsWUFBWSxRQUFoQixFQUEwQjtBQUMvQixVQUFJLENBQUNqTyxTQUFTLENBQVYsSUFBZSxDQUFuQixFQUFzQjtBQUN0Qm15QyxZQUFNeDlDLElBQU4sQ0FDRXNaLGFBQWEsSUFBYixHQUFvQixJQUR0QixFQUVFQSxhQUFhLEdBQWIsR0FBbUIsSUFBbkIsR0FBMEIsSUFGNUIsRUFHRUEsYUFBYSxHQUFiLEdBQW1CLElBQW5CLEdBQTBCLElBSDVCLEVBSUVBLFlBQVksSUFBWixHQUFtQixJQUpyQjtBQU1ELEtBUk0sTUFRQTtBQUNMLFlBQU0sSUFBSXZYLEtBQUosQ0FBVSxvQkFBVixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPeTdDLEtBQVA7QUFDRDs7QUFFRCxTQUFTbEIsWUFBVCxDQUF1QnAxQixHQUF2QixFQUE0QjtBQUMxQixNQUFJKzVCLFlBQVksRUFBaEI7QUFDQSxPQUFLLElBQUlqaUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJa29CLElBQUk3bkIsTUFBeEIsRUFBZ0MsRUFBRUwsQ0FBbEMsRUFBcUM7QUFDbkM7QUFDQWlpRCxjQUFVamhELElBQVYsQ0FBZWtuQixJQUFJL04sVUFBSixDQUFlbmEsQ0FBZixJQUFvQixJQUFuQztBQUNEO0FBQ0QsU0FBT2lpRCxTQUFQO0FBQ0Q7O0FBRUQsU0FBU3ZFLGNBQVQsQ0FBeUJ4MUIsR0FBekIsRUFBOEI3YixLQUE5QixFQUFxQztBQUNuQyxNQUFJaWhCLENBQUosRUFBTzQwQixFQUFQLEVBQVdDLEVBQVg7QUFDQSxNQUFJRixZQUFZLEVBQWhCO0FBQ0EsT0FBSyxJQUFJamlELElBQUksQ0FBYixFQUFnQkEsSUFBSWtvQixJQUFJN25CLE1BQXhCLEVBQWdDLEVBQUVMLENBQWxDLEVBQXFDO0FBQ25DLFFBQUksQ0FBQ3FNLFNBQVMsQ0FBVixJQUFlLENBQW5CLEVBQXNCOztBQUV0QmloQixRQUFJcEYsSUFBSS9OLFVBQUosQ0FBZW5hLENBQWYsQ0FBSjtBQUNBa2lELFNBQUs1MEIsS0FBSyxDQUFWO0FBQ0E2MEIsU0FBSzcwQixJQUFJLEdBQVQ7QUFDQTIwQixjQUFVamhELElBQVYsQ0FBZW1oRCxFQUFmO0FBQ0FGLGNBQVVqaEQsSUFBVixDQUFla2hELEVBQWY7QUFDRDs7QUFFRCxTQUFPRCxTQUFQO0FBQ0Q7O0FBRUQsU0FBUzlHLGFBQVQsQ0FBd0JqekIsR0FBeEIsRUFBNkI7QUFDM0IsU0FBTzJ3QixPQUFPckIsV0FBUCxDQUFtQnNLLFlBQVk1NUIsR0FBWixDQUFuQixDQUFQO0FBQ0Q7O0FBRUQsU0FBU2sxQixVQUFULENBQXFCbHpDLEdBQXJCLEVBQTBCazRDLEdBQTFCLEVBQStCN08sTUFBL0IsRUFBdUNsekMsTUFBdkMsRUFBK0M7QUFDN0MsT0FBSyxJQUFJTCxJQUFJLENBQWIsRUFBZ0JBLElBQUlLLE1BQXBCLEVBQTRCLEVBQUVMLENBQTlCLEVBQWlDO0FBQy9CLFFBQUtBLElBQUl1ekMsTUFBSixJQUFjNk8sSUFBSS9oRCxNQUFuQixJQUErQkwsS0FBS2tLLElBQUk3SixNQUE1QyxFQUFxRDtBQUNyRCtoRCxRQUFJcGlELElBQUl1ekMsTUFBUixJQUFrQnJwQyxJQUFJbEssQ0FBSixDQUFsQjtBQUNEO0FBQ0QsU0FBT0EsQ0FBUDtBQUNEOztBQUVELFNBQVM2NkMsS0FBVCxDQUFnQi9hLEdBQWhCLEVBQXFCO0FBQ25CLFNBQU9BLFFBQVFBLEdBQWYsQ0FEbUIsQ0FDQTtBQUNwQixDOzs7Ozs7Ozs7Ozs7Ozs7QUM1dkREM25CLFFBQVF3a0MsSUFBUixHQUFlLFVBQVU3dUMsTUFBVixFQUFrQnlsQyxNQUFsQixFQUEwQjhPLElBQTFCLEVBQWdDQyxJQUFoQyxFQUFzQ0MsTUFBdEMsRUFBOEM7QUFDM0QsTUFBSTM5QyxDQUFKLEVBQU9vWCxDQUFQO0FBQ0EsTUFBSXdtQyxPQUFRRCxTQUFTLENBQVYsR0FBZUQsSUFBZixHQUFzQixDQUFqQztBQUNBLE1BQUlHLE9BQU8sQ0FBQyxLQUFLRCxJQUFOLElBQWMsQ0FBekI7QUFDQSxNQUFJRSxRQUFRRCxRQUFRLENBQXBCO0FBQ0EsTUFBSUUsUUFBUSxDQUFDLENBQWI7QUFDQSxNQUFJM2lELElBQUlxaUQsT0FBUUUsU0FBUyxDQUFqQixHQUFzQixDQUE5QjtBQUNBLE1BQUk1dkIsSUFBSTB2QixPQUFPLENBQUMsQ0FBUixHQUFZLENBQXBCO0FBQ0EsTUFBSS8vQixJQUFJeFUsT0FBT3lsQyxTQUFTdnpDLENBQWhCLENBQVI7O0FBRUFBLE9BQUsyeUIsQ0FBTDs7QUFFQS90QixNQUFJMGQsSUFBSyxDQUFDLEtBQU0sQ0FBQ3FnQyxLQUFSLElBQWtCLENBQTNCO0FBQ0FyZ0MsUUFBTyxDQUFDcWdDLEtBQVI7QUFDQUEsV0FBU0gsSUFBVDtBQUNBLFNBQU9HLFFBQVEsQ0FBZixFQUFrQi85QyxJQUFLQSxJQUFJLEdBQUwsR0FBWWtKLE9BQU95bEMsU0FBU3Z6QyxDQUFoQixDQUFoQixFQUFvQ0EsS0FBSzJ5QixDQUF6QyxFQUE0Q2d3QixTQUFTLENBQXZFLEVBQTBFLENBQUU7O0FBRTVFM21DLE1BQUlwWCxJQUFLLENBQUMsS0FBTSxDQUFDKzlDLEtBQVIsSUFBa0IsQ0FBM0I7QUFDQS85QyxRQUFPLENBQUMrOUMsS0FBUjtBQUNBQSxXQUFTTCxJQUFUO0FBQ0EsU0FBT0ssUUFBUSxDQUFmLEVBQWtCM21DLElBQUtBLElBQUksR0FBTCxHQUFZbE8sT0FBT3lsQyxTQUFTdnpDLENBQWhCLENBQWhCLEVBQW9DQSxLQUFLMnlCLENBQXpDLEVBQTRDZ3dCLFNBQVMsQ0FBdkUsRUFBMEUsQ0FBRTs7QUFFNUUsTUFBSS85QyxNQUFNLENBQVYsRUFBYTtBQUNYQSxRQUFJLElBQUk4OUMsS0FBUjtBQUNELEdBRkQsTUFFTyxJQUFJOTlDLE1BQU02OUMsSUFBVixFQUFnQjtBQUNyQixXQUFPem1DLElBQUk0bUMsR0FBSixHQUFXLENBQUN0Z0MsSUFBSSxDQUFDLENBQUwsR0FBUyxDQUFWLElBQWVoTSxRQUFqQztBQUNELEdBRk0sTUFFQTtBQUNMMEYsUUFBSUEsSUFBSXpDLEtBQUt3WCxHQUFMLENBQVMsQ0FBVCxFQUFZdXhCLElBQVosQ0FBUjtBQUNBMTlDLFFBQUlBLElBQUk4OUMsS0FBUjtBQUNEO0FBQ0QsU0FBTyxDQUFDcGdDLElBQUksQ0FBQyxDQUFMLEdBQVMsQ0FBVixJQUFldEcsQ0FBZixHQUFtQnpDLEtBQUt3WCxHQUFMLENBQVMsQ0FBVCxFQUFZbnNCLElBQUkwOUMsSUFBaEIsQ0FBMUI7QUFDRCxDQS9CRDs7QUFpQ0FucUMsUUFBUXFpQyxLQUFSLEdBQWdCLFVBQVUxc0MsTUFBVixFQUFrQjVCLEtBQWxCLEVBQXlCcW5DLE1BQXpCLEVBQWlDOE8sSUFBakMsRUFBdUNDLElBQXZDLEVBQTZDQyxNQUE3QyxFQUFxRDtBQUNuRSxNQUFJMzlDLENBQUosRUFBT29YLENBQVAsRUFBVXNSLENBQVY7QUFDQSxNQUFJazFCLE9BQVFELFNBQVMsQ0FBVixHQUFlRCxJQUFmLEdBQXNCLENBQWpDO0FBQ0EsTUFBSUcsT0FBTyxDQUFDLEtBQUtELElBQU4sSUFBYyxDQUF6QjtBQUNBLE1BQUlFLFFBQVFELFFBQVEsQ0FBcEI7QUFDQSxNQUFJM2tCLEtBQU13a0IsU0FBUyxFQUFULEdBQWMvb0MsS0FBS3dYLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQyxFQUFiLElBQW1CeFgsS0FBS3dYLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQyxFQUFiLENBQWpDLEdBQW9ELENBQTlEO0FBQ0EsTUFBSS93QixJQUFJcWlELE9BQU8sQ0FBUCxHQUFZRSxTQUFTLENBQTdCO0FBQ0EsTUFBSTV2QixJQUFJMHZCLE9BQU8sQ0FBUCxHQUFXLENBQUMsQ0FBcEI7QUFDQSxNQUFJLy9CLElBQUlwVyxRQUFRLENBQVIsSUFBY0EsVUFBVSxDQUFWLElBQWUsSUFBSUEsS0FBSixHQUFZLENBQXpDLEdBQThDLENBQTlDLEdBQWtELENBQTFEOztBQUVBQSxVQUFRcU4sS0FBS3RGLEdBQUwsQ0FBUy9ILEtBQVQsQ0FBUjs7QUFFQSxNQUFJMGhCLE1BQU0xaEIsS0FBTixLQUFnQkEsVUFBVW9LLFFBQTlCLEVBQXdDO0FBQ3RDMEYsUUFBSTRSLE1BQU0xaEIsS0FBTixJQUFlLENBQWYsR0FBbUIsQ0FBdkI7QUFDQXRILFFBQUk2OUMsSUFBSjtBQUNELEdBSEQsTUFHTztBQUNMNzlDLFFBQUkyVSxLQUFLcEYsS0FBTCxDQUFXb0YsS0FBS2lYLEdBQUwsQ0FBU3RrQixLQUFULElBQWtCcU4sS0FBSzRsQixHQUFsQyxDQUFKO0FBQ0EsUUFBSWp6QixTQUFTb2hCLElBQUkvVCxLQUFLd1gsR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDbnNCLENBQWIsQ0FBYixJQUFnQyxDQUFwQyxFQUF1QztBQUNyQ0E7QUFDQTBvQixXQUFLLENBQUw7QUFDRDtBQUNELFFBQUkxb0IsSUFBSTg5QyxLQUFKLElBQWEsQ0FBakIsRUFBb0I7QUFDbEJ4MkMsZUFBUzR4QixLQUFLeFEsQ0FBZDtBQUNELEtBRkQsTUFFTztBQUNMcGhCLGVBQVM0eEIsS0FBS3ZrQixLQUFLd1gsR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJMnhCLEtBQWhCLENBQWQ7QUFDRDtBQUNELFFBQUl4MkMsUUFBUW9oQixDQUFSLElBQWEsQ0FBakIsRUFBb0I7QUFDbEIxb0I7QUFDQTBvQixXQUFLLENBQUw7QUFDRDs7QUFFRCxRQUFJMW9CLElBQUk4OUMsS0FBSixJQUFhRCxJQUFqQixFQUF1QjtBQUNyQnptQyxVQUFJLENBQUo7QUFDQXBYLFVBQUk2OUMsSUFBSjtBQUNELEtBSEQsTUFHTyxJQUFJNzlDLElBQUk4OUMsS0FBSixJQUFhLENBQWpCLEVBQW9CO0FBQ3pCMW1DLFVBQUksQ0FBRTlQLFFBQVFvaEIsQ0FBVCxHQUFjLENBQWYsSUFBb0IvVCxLQUFLd1gsR0FBTCxDQUFTLENBQVQsRUFBWXV4QixJQUFaLENBQXhCO0FBQ0ExOUMsVUFBSUEsSUFBSTg5QyxLQUFSO0FBQ0QsS0FITSxNQUdBO0FBQ0wxbUMsVUFBSTlQLFFBQVFxTixLQUFLd1gsR0FBTCxDQUFTLENBQVQsRUFBWTJ4QixRQUFRLENBQXBCLENBQVIsR0FBaUNucEMsS0FBS3dYLEdBQUwsQ0FBUyxDQUFULEVBQVl1eEIsSUFBWixDQUFyQztBQUNBMTlDLFVBQUksQ0FBSjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTzA5QyxRQUFRLENBQWYsRUFBa0J4MEMsT0FBT3lsQyxTQUFTdnpDLENBQWhCLElBQXFCZ2MsSUFBSSxJQUF6QixFQUErQmhjLEtBQUsyeUIsQ0FBcEMsRUFBdUMzVyxLQUFLLEdBQTVDLEVBQWlEc21DLFFBQVEsQ0FBM0UsRUFBOEUsQ0FBRTs7QUFFaEYxOUMsTUFBS0EsS0FBSzA5QyxJQUFOLEdBQWN0bUMsQ0FBbEI7QUFDQXdtQyxVQUFRRixJQUFSO0FBQ0EsU0FBT0UsT0FBTyxDQUFkLEVBQWlCMTBDLE9BQU95bEMsU0FBU3Z6QyxDQUFoQixJQUFxQjRFLElBQUksSUFBekIsRUFBK0I1RSxLQUFLMnlCLENBQXBDLEVBQXVDL3RCLEtBQUssR0FBNUMsRUFBaUQ0OUMsUUFBUSxDQUExRSxFQUE2RSxDQUFFOztBQUUvRTEwQyxTQUFPeWxDLFNBQVN2ekMsQ0FBVCxHQUFhMnlCLENBQXBCLEtBQTBCclEsSUFBSSxHQUE5QjtBQUNELENBbERELEM7Ozs7Ozs7Ozs7Ozs7O0FDakNBLElBQUk1YyxXQUFXLEdBQUdBLFFBQWxCOztBQUVBd1MsT0FBT0MsT0FBUCxHQUFpQmpZLE1BQU1DLE9BQU4sSUFBaUIsVUFBVW00QyxHQUFWLEVBQWU7QUFDL0MsU0FBTzV5QyxTQUFTd1gsSUFBVCxDQUFjbzdCLEdBQWQsS0FBc0IsZ0JBQTdCO0FBQ0QsQ0FGRCxDOzs7Ozs7Ozs7Ozs7OztBQ0ZBLElBQUl1SyxjQUFjO0FBQ2hCQyxRQUFNLEdBRFU7QUFFaEJDLFlBQVUsR0FGTTtBQUdoQixpQkFBZSxHQUhDO0FBSWhCLGlCQUFlLEdBSkM7QUFLaEJ4MkMsU0FBTyxHQUxTO0FBTWhCeTJDLFFBQU0sR0FOVTtBQU9oQkMsV0FBUyxHQVBPO0FBUWhCQyxVQUFRLEdBUlE7QUFTaEJDLFNBQU8sR0FUUztBQVVoQkMsU0FBTyxHQVZTO0FBV2hCQyxZQUFVLEdBWE07QUFZaEJDLFVBQVEsR0FaUTtBQWFoQixlQUFhLEdBYkc7QUFjaEIsZUFBYSxHQWRHO0FBZWhCQyxRQUFNLEdBZlU7QUFnQmhCQyxTQUFPLEdBaEJTO0FBaUJoQm42QixTQUFPLEdBakJTO0FBa0JoQixnQkFBYyxHQWxCRTtBQW1CaEIsaUJBQWUsR0FuQkM7QUFvQmhCLGlCQUFlLEdBcEJDO0FBcUJoQixnQkFBYyxHQXJCRTtBQXNCaEIsaUJBQWUsR0F0QkM7QUF1QmhCbzZCLE9BQUssR0F2Qlc7QUF3QmhCQyxVQUFRO0FBeEJRLENBQWxCO0FBMEJBLElBQUlDLEtBQUssR0FBVDtBQUNBLElBQUlDLFdBQVcsb0JBQWY7O0FBRUEsSUFBSUMsWUFBWSxFQUFoQjs7QUFFQTNyQyxPQUFPQyxPQUFQLEdBQWlCLFVBQVNwWSxLQUFULEVBQWdCa0gsSUFBaEIsRUFBc0I2OEMsVUFBdEIsRUFBa0M7QUFDakQsTUFBSUMsVUFBVUYsVUFBVTlqRCxLQUFWLENBQWQ7QUFDQSxNQUFJLENBQUNna0QsT0FBTCxFQUFjO0FBQ1osUUFBSSxDQUFDN2pELE1BQU1DLE9BQU4sQ0FBY0osS0FBZCxDQUFMLEVBQTJCO0FBQ3pCQSxjQUFRLENBQUNBLEtBQUQsQ0FBUjtBQUNEO0FBQ0QsUUFBSWlrRCxTQUFTLEdBQWI7QUFDQSxRQUFJMS9DLFFBQVEsUUFBWjtBQUNBLFFBQUkyL0MsZUFBZSxFQUFuQjtBQUNBLFFBQUlDLFVBQUosRUFBZ0JDLFNBQWhCO0FBQ0EsU0FBSyxJQUFJbmtELElBQUksQ0FBUixFQUFXQyxLQUFLRixNQUFNTSxNQUEzQixFQUFtQ0wsSUFBSUMsRUFBdkMsRUFBMkMsRUFBRUQsQ0FBN0MsRUFBZ0Q7QUFDOUMsVUFBSVcsT0FBT1osTUFBTUMsQ0FBTixDQUFYO0FBQ0EsVUFBSW9DLFFBQVF6QixLQUFLQyxLQUFMLENBQVcsR0FBWCxDQUFaO0FBQ0EsVUFBSXdqRCxjQUFjaGlELE1BQU1BLE1BQU0vQixNQUFOLEdBQWUsQ0FBckIsRUFBd0JrYyxXQUF4QixFQUFsQjtBQUNBLFVBQUk2bkMsZUFBZSxRQUFmLElBQTJCQSxlQUFlLFFBQTFDLElBQXNEQSxlQUFlLFNBQXpFLEVBQW9GO0FBQ2xGOS9DLGdCQUFRNi9DLFlBQVk3L0MsS0FBWixHQUFvQjgvQyxXQUE1QjtBQUNBaGlELGNBQU1taEIsR0FBTjtBQUNBNmdDLHNCQUFjaGlELE1BQU1BLE1BQU0vQixNQUFOLEdBQWUsQ0FBckIsRUFBd0JrYyxXQUF4QixFQUFkO0FBQ0QsT0FKRCxNQUlPLElBQUlxbkMsU0FBU3RuQyxJQUFULENBQWM4bkMsV0FBZCxDQUFKLEVBQWdDO0FBQ3JDQSxzQkFBY0EsWUFBWXZqRCxPQUFaLENBQW9CK2lELFFBQXBCLEVBQThCLEVBQTlCLENBQWQ7QUFDQXQvQyxnQkFBUTYvQyxZQUFZNy9DLEtBQVosR0FBb0JsQyxNQUFNQSxNQUFNL0IsTUFBTixHQUFlLENBQXJCLEVBQXdCUSxPQUF4QixDQUFnQ3VqRCxXQUFoQyxFQUE2QyxFQUE3QyxDQUE1QjtBQUNEO0FBQ0QsV0FBSyxJQUFJNW9DLENBQVQsSUFBY3FuQyxXQUFkLEVBQTJCO0FBQ3pCLFlBQUl1QixlQUFlNW9DLENBQWYsSUFBb0I0b0MsZUFBZTVvQyxFQUFFM2EsT0FBRixDQUFVLEdBQVYsRUFBZSxFQUFmLENBQW5DLElBQXlEdWpELGVBQWU1b0MsRUFBRTNhLE9BQUYsQ0FBVSxHQUFWLEVBQWU4aUQsRUFBZixDQUE1RSxFQUFnRztBQUM5RkssbUJBQVNFLGFBQWFGLE1BQWIsR0FBc0JuQixZQUFZcm5DLENBQVosQ0FBL0I7QUFDQXBaLGdCQUFNbWhCLEdBQU47QUFDQTtBQUNEO0FBQ0Y7QUFDRCxVQUFJLENBQUMyZ0MsVUFBRCxJQUFlLE9BQU9FLFdBQVAsSUFBc0IsUUFBekMsRUFBbUQ7QUFDakRKLGlCQUFTSSxXQUFUO0FBQ0Q7QUFDRCxVQUFJQyxhQUFhamlELE1BQU1nSixJQUFOLENBQVd1NEMsRUFBWCxFQUNkOWlELE9BRGMsQ0FDTixzQkFETSxFQUNrQixXQURsQixDQUFqQjtBQUVBLFVBQUl3akQsV0FBV3RqRCxPQUFYLENBQW1CNGlELEVBQW5CLE1BQTJCLENBQUMsQ0FBaEMsRUFBbUM7QUFDakNVLHFCQUFhLE1BQU1BLFVBQU4sR0FBbUIsR0FBaEM7QUFDRDtBQUNESixtQkFBYWpqRCxJQUFiLENBQWtCcWpELFVBQWxCO0FBQ0Q7QUFDRDtBQUNBTixjQUFVRixVQUFVOWpELEtBQVYsSUFBbUIsQ0FBQ3VFLEtBQUQsRUFBUTAvQyxNQUFSLEVBQWdCQyxZQUFoQixDQUE3QjtBQUNEO0FBQ0QsU0FBT0YsUUFBUSxDQUFSLElBQWFKLEVBQWIsR0FBa0JJLFFBQVEsQ0FBUixDQUFsQixHQUErQkosRUFBL0IsR0FBb0MxOEMsSUFBcEMsR0FBMkMsSUFBM0MsSUFBbUQ2OEMsYUFBYSxNQUFNQSxVQUFuQixHQUFnQyxFQUFuRixJQUF5RkgsRUFBekYsR0FBOEZJLFFBQVEsQ0FBUixDQUFyRztBQUNELENBM0NELEM7Ozs7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0EsQ0FBQyxZQUFXO0FBQ1YsTUFBSXRqRCxRQUFKOztBQUVBeVgsU0FBT0MsT0FBUCxHQUFpQjtBQUNmbXNDLFVBQU0sa0JBRFM7QUFFZnQ0QyxVQUFNLFFBRlM7QUFHZnU0QyxXQUFPLGNBSFE7QUFJZkMsVUFBTSxrQkFKUztBQUtmaGtELGNBQVUsb0JBQVc7QUFDbkIsYUFBT0MsUUFBUDtBQUNELEtBUGM7QUFRZmdrRCxhQUFTLGlCQUFTejRDLElBQVQsRUFBZTtBQUN0QixhQUFPLHVDQUF3Q0EsS0FBS25MLE9BQUwsQ0FBYSxNQUFiLEVBQXFCLEdBQXJCLENBQS9DO0FBQ0QsS0FWYztBQVdmNmpELG1CQUFlLHVCQUFTMTRDLElBQVQsRUFBZTtBQUM1QixhQUFPQSxJQUFQO0FBQ0Q7QUFiYyxHQUFqQjs7QUFnQkF2TCxhQUFXLENBQUMsU0FBRCxFQUFZLE1BQVosRUFBb0IsZUFBcEIsRUFBcUMsVUFBckMsRUFBaUQsTUFBakQsRUFBeUQsT0FBekQsRUFBa0UsU0FBbEUsRUFBNkUsWUFBN0UsRUFBMkYsaUJBQTNGLEVBQThHLFNBQTlHLEVBQXlILFFBQXpILEVBQW1JLFNBQW5JLEVBQThJLE1BQTlJLEVBQXNKLFVBQXRKLEVBQWtLLGFBQWxLLEVBQWlMLGVBQWpMLEVBQWtNLGtCQUFsTSxFQUFzTixZQUF0TixFQUFvTyxlQUFwTyxFQUFxUCxPQUFyUCxFQUE4UCxPQUE5UCxFQUF1USxlQUF2USxFQUF3UixPQUF4UixFQUFpUyxTQUFqUyxFQUE0UyxpQkFBNVMsRUFBK1QsUUFBL1QsRUFBeVUsVUFBelUsRUFBcVYsa0JBQXJWLEVBQXlXLGFBQXpXLEVBQXdYLFVBQXhYLEVBQW9ZLFVBQXBZLEVBQWdaLFdBQWhaLEVBQTZaLFdBQTdaLEVBQTBhLE9BQTFhLEVBQW1iLE9BQW5iLEVBQTRiLFNBQTViLEVBQXVjLFFBQXZjLEVBQWlkLFFBQWpkLEVBQTJkLFFBQTNkLEVBQXFlLDBCQUFyZSxFQUFpZ0IsZUFBamdCLEVBQWtoQixPQUFsaEIsRUFBMmhCLGNBQTNoQixFQUEyaUIsWUFBM2lCLEVBQXlqQixPQUF6akIsRUFBa2tCLFFBQWxrQixFQUE0a0IsU0FBNWtCLEVBQXVsQixjQUF2bEIsRUFBdW1CLHFCQUF2bUIsRUFBOG5CLGVBQTluQixFQUErb0IsZ0JBQS9vQixFQUFpcUIsT0FBanFCLEVBQTBxQixVQUExcUIsRUFBc3JCLFFBQXRyQixFQUFnc0IsVUFBaHNCLEVBQTRzQixNQUE1c0IsRUFBb3RCLE1BQXB0QixFQUE0dEIsTUFBNXRCLEVBQW91QixNQUFwdUIsRUFBNHVCLE9BQTV1QixFQUFxdkIsU0FBcnZCLEVBQWd3QixNQUFod0IsRUFBd3dCLFlBQXh3QixFQUFzeEIsUUFBdHhCLEVBQWd5QixXQUFoeUIsRUFBNnlCLFlBQTd5QixFQUEyekIsU0FBM3pCLEVBQXMwQixjQUF0MEIsRUFBczFCLHFCQUF0MUIsRUFBNjJCLGNBQTcyQixFQUE2M0IsbUJBQTczQixFQUFrNUIsb0JBQWw1QixFQUF3NkIsWUFBeDZCLEVBQXM3QixXQUF0N0IsRUFBbThCLFNBQW44QixFQUE4OEIsT0FBOThCLEVBQXU5QixZQUF2OUIsRUFBcStCLFNBQXIrQixFQUFnL0IsT0FBaC9CLEVBQXkvQixVQUF6L0IsRUFBcWdDLFNBQXJnQyxFQUFnaEMsV0FBaGhDLEVBQTZoQyxTQUE3aEMsRUFBd2lDLGlCQUF4aUMsRUFBMmpDLE9BQTNqQyxFQUFva0MsZUFBcGtDLEVBQXFsQyxhQUFybEMsRUFBb21DLE9BQXBtQyxFQUE2bUMsa0JBQTdtQyxFQUFpb0MsU0FBam9DLEVBQTRvQyxRQUE1b0MsRUFBc3BDLGVBQXRwQyxFQUF1cUMsT0FBdnFDLEVBQWdyQyxRQUFockMsRUFBMHJDLFVBQTFyQyxFQUFzc0MsWUFBdHNDLEVBQW90QyxlQUFwdEMsRUFBcXVDLFNBQXJ1QyxFQUFndkMsWUFBaHZDLEVBQTh2QyxnQkFBOXZDLEVBQWd4QyxhQUFoeEMsRUFBK3hDLE1BQS94QyxFQUF1eUMsU0FBdnlDLEVBQWt6QyxZQUFsekMsRUFBZzBDLGdCQUFoMEMsRUFBazFDLE9BQWwxQyxFQUEyMUMsaUJBQTMxQyxFQUE4MkMsY0FBOTJDLEVBQTgzQyxpQkFBOTNDLEVBQWk1QyxZQUFqNUMsRUFBKzVDLGdCQUEvNUMsRUFBaTdDLFFBQWo3QyxFQUEyN0MsT0FBMzdDLEVBQW84QyxRQUFwOEMsRUFBODhDLFdBQTk4QyxFQUEyOUMsYUFBMzlDLEVBQTArQyxhQUExK0MsRUFBeS9DLFVBQXovQyxFQUFxZ0QsT0FBcmdELEVBQThnRCxPQUE5Z0QsRUFBdWhELGdCQUF2aEQsRUFBeWlELG1CQUF6aUQsRUFBOGpELFlBQTlqRCxFQUE0a0QsV0FBNWtELEVBQXlsRCxRQUF6bEQsRUFBbW1ELFFBQW5tRCxFQUE2bUQsY0FBN21ELEVBQTZuRCxvQkFBN25ELEVBQW1wRCxhQUFucEQsRUFBa3FELFlBQWxxRCxFQUFnckQsUUFBaHJELEVBQTByRCxvQkFBMXJELEVBQWd0RCxXQUFodEQsRUFBNnRELGdCQUE3dEQsRUFBK3VELFFBQS91RCxFQUF5dkQsbUJBQXp2RCxFQUE4d0QsY0FBOXdELEVBQTh4RCxPQUE5eEQsRUFBdXlELFFBQXZ5RCxFQUFpekQsT0FBanpELEVBQTB6RCxVQUExekQsRUFBczBELFFBQXQwRCxFQUFnMUQsbUJBQWgxRCxFQUFxMkQsZ0JBQXIyRCxFQUF1M0QsTUFBdjNELEVBQSszRCxjQUEvM0QsRUFBKzRELFVBQS80RCxFQUEyNUQsT0FBMzVELEVBQW82RCxXQUFwNkQsRUFBaTdELGFBQWo3RCxFQUFnOEQsYUFBaDhELEVBQSs4RCxXQUEvOEQsRUFBNDlELFNBQTU5RCxFQUF1K0QsY0FBditELEVBQXUvRCxhQUF2L0QsRUFBc2dFLFFBQXRnRSxFQUFnaEUsT0FBaGhFLEVBQXloRSxRQUF6aEUsRUFBbWlFLFdBQW5pRSxFQUFnakUsU0FBaGpFLEVBQTJqRSxVQUEzakUsRUFBdWtFLHVCQUF2a0UsRUFBZ21FLGNBQWhtRSxFQUFnbkUsV0FBaG5FLEVBQTZuRSxhQUE3bkUsRUFBNG9FLGNBQTVvRSxFQUE0cEUsZUFBNXBFLEVBQTZxRSxTQUE3cUUsRUFBd3JFLFFBQXhyRSxFQUFrc0UsUUFBbHNFLEVBQTRzRSxhQUE1c0UsRUFBMnRFLFFBQTN0RSxFQUFxdUUsZ0JBQXJ1RSxFQUF1dkUsU0FBdnZFLEVBQWt3RSxzQkFBbHdFLEVBQTB4RSxVQUExeEUsRUFBc3lFLE9BQXR5RSxFQUEreUUsUUFBL3lFLEVBQXl6RSxtQkFBenpFLEVBQTgwRSxnQkFBOTBFLEVBQWcyRSxlQUFoMkUsRUFBaTNFLFVBQWozRSxFQUE2M0UsWUFBNzNFLEVBQTI0RSxVQUEzNEUsRUFBdTVFLGVBQXY1RSxFQUF3NkUsV0FBeDZFLEVBQXE3RSxjQUFyN0UsRUFBcThFLFFBQXI4RSxFQUErOEUsYUFBLzhFLEVBQTg5RSxZQUE5OUUsRUFBNCtFLE9BQTUrRSxFQUFxL0UsT0FBci9FLEVBQTgvRSxhQUE5L0UsRUFBNmdGLFlBQTdnRixFQUEyaEYsaUJBQTNoRixFQUE4aUYsYUFBOWlGLEVBQTZqRixXQUE3akYsRUFBMGtGLFdBQTFrRixFQUF1bEYsYUFBdmxGLEVBQXNtRixZQUF0bUYsRUFBb25GLE9BQXBuRixFQUE2bkYsV0FBN25GLEVBQTBvRixPQUExb0YsRUFBbXBGLFVBQW5wRixFQUErcEYsYUFBL3BGLEVBQThxRixPQUE5cUYsRUFBdXJGLGtCQUF2ckYsRUFBMnNGLGFBQTNzRixFQUEwdEYsY0FBMXRGLEVBQTB1RixZQUExdUYsRUFBd3ZGLFdBQXh2RixFQUFxd0YsV0FBcndGLEVBQWt4RixXQUFseEYsRUFBK3hGLFNBQS94RixFQUEweUYsaUJBQTF5RixFQUE2ekYsT0FBN3pGLEVBQXMwRixLQUF0MEYsRUFBNjBGLE9BQTcwRixFQUFzMUYsZUFBdDFGLEVBQXUyRixjQUF2MkYsRUFBdTNGLFdBQXYzRixFQUFvNEYsa0JBQXA0RixFQUF3NUYsWUFBeDVGLEVBQXM2RixVQUF0NkYsRUFBazdGLFdBQWw3RixFQUErN0YsVUFBLzdGLEVBQTI4RixRQUEzOEYsRUFBcTlGLFFBQXI5RixFQUErOUYsT0FBLzlGLEVBQXcrRixjQUF4K0YsRUFBdy9GLFdBQXgvRixFQUFxZ0csV0FBcmdHLEVBQWtoRyxZQUFsaEcsRUFBZ2lHLFdBQWhpRyxFQUE2aUcsVUFBN2lHLEVBQXlqRyxTQUF6akcsRUFBb2tHLFlBQXBrRyxFQUFrbEcsa0JBQWxsRyxFQUFzbUcsT0FBdG1HLEVBQSttRyxjQUEvbUcsRUFBK25HLGNBQS9uRyxFQUErb0csc0JBQS9vRyxFQUF1cUcsYUFBdnFHLEVBQXNyRyxVQUF0ckcsRUFBa3NHLFFBQWxzRyxFQUE0c0csU0FBNXNHLEVBQXV0RyxTQUF2dEcsRUFBa3VHLFdBQWx1RyxFQUErdUcsV0FBL3VHLEVBQTR2RyxpQkFBNXZHLEVBQSt3RyxVQUEvd0csRUFBMnhHLFFBQTN4RyxFQUFxeUcsVUFBcnlHLEVBQWl6RyxTQUFqekcsRUFBNHpHLGVBQTV6RyxFQUE2MEcsb0JBQTcwRyxFQUFtMkcsS0FBbjJHLEVBQTAyRyxTQUExMkcsRUFBcTNHLGNBQXIzRyxFQUFxNEcsY0FBcjRHLEVBQXE1RyxRQUFyNUcsRUFBKzVHLGVBQS81RyxFQUFnN0csZ0JBQWg3RyxFQUFrOEcsZUFBbDhHLEVBQW05RyxRQUFuOUcsRUFBNjlHLG1CQUE3OUcsRUFBay9HLFlBQWwvRyxFQUFnZ0gsWUFBaGdILEVBQThnSCxVQUE5Z0gsRUFBMGhILHVCQUExaEgsRUFBbWpILFVBQW5qSCxFQUErakgsYUFBL2pILEVBQThrSCxjQUE5a0gsRUFBOGxILGFBQTlsSCxFQUE2bUgsUUFBN21ILEVBQXVuSCxRQUF2bkgsRUFBaW9ILE9BQWpvSCxFQUEwb0gsVUFBMW9ILEVBQXNwSCxRQUF0cEgsRUFBZ3FILFFBQWhxSCxFQUEwcUgsaUJBQTFxSCxFQUE2ckgsU0FBN3JILEVBQXdzSCxjQUF4c0gsRUFBd3RILFNBQXh0SCxFQUFtdUgsU0FBbnVILEVBQTh1SCxjQUE5dUgsRUFBOHZILGNBQTl2SCxFQUE4d0gsYUFBOXdILEVBQTZ4SCxzQkFBN3hILEVBQXF6SCxNQUFyekgsRUFBNnpILGVBQTd6SCxFQUE4MEgsZUFBOTBILEVBQSsxSCxpQkFBLzFILEVBQWszSCxnQkFBbDNILEVBQW80SCxVQUFwNEgsRUFBZzVILGlCQUFoNUgsRUFBbTZILG9CQUFuNkgsRUFBeTdILHFCQUF6N0gsRUFBZzlILHdCQUFoOUgsRUFBMCtILGlCQUExK0gsRUFBNi9ILG9CQUE3L0gsRUFBbWhJLHNCQUFuaEksRUFBMmlJLHlCQUEzaUksRUFBc2tJLHNCQUF0a0ksRUFBOGxJLHlCQUE5bEksRUFBeW5JLFNBQXpuSSxFQUFvb0ksU0FBcG9JLEVBQStvSSxTQUEvb0ksRUFBMHBJLGFBQTFwSSxFQUF5cUksT0FBenFJLEVBQWtySSxjQUFsckksRUFBa3NJLE9BQWxzSSxFQUEyc0ksZ0JBQTNzSSxFQUE2dEksY0FBN3RJLEVBQTZ1SSxXQUE3dUksRUFBMHZJLFVBQTF2SSxFQUFzd0ksV0FBdHdJLEVBQW14SSxNQUFueEksRUFBMnhJLGtCQUEzeEksRUFBK3lJLHlCQUEveUksRUFBMDBJLE9BQTEwSSxFQUFtMUksZ0JBQW4xSSxFQUFxMkksWUFBcjJJLEVBQW0zSSxjQUFuM0ksRUFBbTRJLGNBQW40SSxFQUFtNUksY0FBbjVJLEVBQW02SSxVQUFuNkksRUFBKzZJLFFBQS82SSxFQUF5N0ksT0FBejdJLEVBQWs4SSxpQkFBbDhJLEVBQXE5SSxPQUFyOUksRUFBODlJLE1BQTk5SSxFQUFzK0ksbUJBQXQrSSxFQUEyL0kseUJBQTMvSSxFQUFzaEosT0FBdGhKLEVBQStoSixPQUEvaEosRUFBd2lKLFNBQXhpSixFQUFtakosV0FBbmpKLEVBQWdrSixPQUFoa0osRUFBeWtKLE9BQXprSixFQUFrbEosZ0JBQWxsSixFQUFvbUosUUFBcG1KLEVBQThtSixZQUE5bUosRUFBNG5KLFlBQTVuSixFQUEwb0osWUFBMW9KLEVBQXdwSixPQUF4cEosRUFBaXFKLE9BQWpxSixFQUEwcUosT0FBMXFKLEVBQW1ySixPQUFuckosRUFBNHJKLFVBQTVySixFQUF3c0osU0FBeHNKLEVBQW10SixXQUFudEosRUFBZ3VKLFFBQWh1SixFQUEwdUosUUFBMXVKLEVBQW92SixPQUFwdkosRUFBNnZKLFFBQTd2SixFQUF1d0osV0FBdndKLEVBQW94SixRQUFweEosRUFBOHhKLGlCQUE5eEosRUFBaXpKLE9BQWp6SixFQUEwekosYUFBMXpKLEVBQXkwSixVQUF6MEosRUFBcTFKLFFBQXIxSixFQUErMUosTUFBLzFKLEVBQXUySixlQUF2MkosRUFBdzNKLGNBQXgzSixFQUF3NEosUUFBeDRKLEVBQWs1SixRQUFsNUosRUFBNDVKLE9BQTU1SixFQUFxNkosbUJBQXI2SixFQUEwN0osYUFBMTdKLEVBQXk4SixZQUF6OEosRUFBdTlKLGlCQUF2OUosRUFBMCtKLFdBQTErSixFQUF1L0osYUFBdi9KLEVBQXNnSyxTQUF0Z0ssRUFBaWhLLGFBQWpoSyxFQUFnaUssa0JBQWhpSyxFQUFvakssaUJBQXBqSyxFQUF1a0ssaUJBQXZrSyxFQUEwbEssZ0JBQTFsSyxFQUE0bUssTUFBNW1LLEVBQW9uSyx1QkFBcG5LLEVBQTZvSyxtQkFBN29LLEVBQWtxSyxnQkFBbHFLLEVBQW9ySyxjQUFwckssRUFBb3NLLFVBQXBzSyxFQUFndEssU0FBaHRLLEVBQTJ0SyxTQUEzdEssRUFBc3VLLG9CQUF0dUssRUFBNHZLLE9BQTV2SyxFQUFxd0ssZUFBcndLLEVBQXN4SyxNQUF0eEssRUFBOHhLLFVBQTl4SyxFQUEweUssU0FBMXlLLEVBQXF6SyxXQUFyekssRUFBazBLLGNBQWwwSyxFQUFrMUssY0FBbDFLLEVBQWsySyxXQUFsMkssRUFBKzJLLFdBQS8ySyxFQUE0M0ssVUFBNTNLLEVBQXc0SyxRQUF4NEssRUFBazVLLGFBQWw1SyxFQUFpNkssUUFBajZLLEVBQTI2SyxNQUEzNkssRUFBbTdLLFNBQW43SyxFQUE4N0ssV0FBOTdLLEVBQTI4SyxTQUEzOEssRUFBczlLLFFBQXQ5SyxFQUFnK0ssZUFBaCtLLEVBQWkvSyxZQUFqL0ssRUFBKy9LLFFBQS8vSyxFQUF5Z0wsYUFBemdMLEVBQXdoTCxVQUF4aEwsRUFBb2lMLGNBQXBpTCxFQUFvakwsY0FBcGpMLEVBQW9rTCxtQkFBcGtMLEVBQXlsTCxPQUF6bEwsRUFBa21MLGFBQWxtTCxFQUFpbkwsY0FBam5MLEVBQWlvTCxhQUFqb0wsRUFBZ3BMLFVBQWhwTCxFQUE0cEwsU0FBNXBMLEVBQXVxTCxXQUF2cUwsRUFBb3JMLGtCQUFwckwsRUFBd3NMLFNBQXhzTCxFQUFtdEwsZ0JBQW50TCxFQUFxdUwsT0FBcnVMLEVBQTh1TCxnQkFBOXVMLEVBQWd3TCxTQUFod0wsRUFBMndMLE9BQTN3TCxFQUFveEwsT0FBcHhMLEVBQTZ4TCxVQUE3eEwsRUFBeXlMLFNBQXp5TCxFQUFvekwsc0JBQXB6TCxFQUE0MEwsU0FBNTBMLEVBQXUxTCxRQUF2MUwsRUFBaTJMLFlBQWoyTCxFQUErMkwsdUJBQS8yTCxFQUF3NEwsc0JBQXg0TCxFQUFnNkwsTUFBaDZMLEVBQXc2TCxVQUF4NkwsRUFBbzdMLHdCQUFwN0wsRUFBODhMLGVBQTk4TCxFQUErOUwsWUFBLzlMLEVBQTYrTCxVQUE3K0wsRUFBeS9MLGdCQUF6L0wsRUFBMmdNLHFCQUEzZ00sRUFBa2lNLGVBQWxpTSxFQUFtak0sTUFBbmpNLEVBQTJqTSxlQUEzak0sRUFBNGtNLEtBQTVrTSxFQUFtbE0sUUFBbmxNLEVBQTZsTSxRQUE3bE0sRUFBdW1NLFlBQXZtTSxFQUFxbk0sWUFBcm5NLEVBQW1vTSxTQUFub00sRUFBOG9NLFdBQTlvTSxFQUEycE0sUUFBM3BNLEVBQXFxTSxRQUFycU0sRUFBK3FNLFNBQS9xTSxFQUEwck0sU0FBMXJNLEVBQXFzTSxzQkFBcnNNLEVBQTZ0TSxjQUE3dE0sRUFBNnVNLFdBQTd1TSxFQUEwdk0sWUFBMXZNLEVBQXd3TSxVQUF4d00sRUFBb3hNLFdBQXB4TSxFQUFpeU0sV0FBanlNLEVBQTh5TSxXQUE5eU0sRUFBMnpNLFlBQTN6TSxFQUF5ME0sYUFBejBNLEVBQXcxTSxXQUF4MU0sRUFBcTJNLGFBQXIyTSxFQUFvM00sUUFBcDNNLEVBQTgzTSxRQUE5M00sRUFBdzRNLGdCQUF4NE0sRUFBMDVNLFNBQTE1TSxFQUFxNk0saUJBQXI2TSxFQUF3N00sV0FBeDdNLEVBQXE4TSxhQUFyOE0sRUFBbzlNLHdCQUFwOU0sRUFBOCtNLFdBQTkrTSxFQUEyL00scUJBQTMvTSxFQUFraE4sYUFBbGhOLEVBQWlpTixVQUFqaU4sRUFBNmlOLFNBQTdpTixFQUF3ak4sU0FBeGpOLEVBQW1rTixpQkFBbmtOLEVBQXNsTixRQUF0bE4sRUFBZ21OLGtCQUFobU4sRUFBb25OLFVBQXBuTixFQUFnb04sYUFBaG9OLEVBQStvTixLQUEvb04sRUFBc3BOLFFBQXRwTixFQUFncU4sYUFBaHFOLEVBQStxTixTQUEvcU4sRUFBMHJOLFNBQTFyTixFQUFxc04saUJBQXJzTixFQUF3dE4sZ0JBQXh0TixFQUEwdU4sVUFBMXVOLEVBQXN2TixrQkFBdHZOLEVBQTB3TixVQUExd04sRUFBc3hOLFdBQXR4TixFQUFteU4sZ0JBQW55TixFQUFxek4sU0FBcnpOLEVBQWcwTixZQUFoME4sRUFBODBOLGFBQTkwTixFQUE2MU4sYUFBNzFOLEVBQTQyTixvQkFBNTJOLEVBQWs0TixjQUFsNE4sRUFBazVOLGlCQUFsNU4sRUFBcTZOLFdBQXI2TixFQUFrN04sYUFBbDdOLEVBQWk4TixTQUFqOE4sRUFBNDhOLFNBQTU4TixFQUF1OU4sa0JBQXY5TixFQUEyK04scUJBQTMrTixFQUFrZ08sU0FBbGdPLEVBQTZnTyxhQUE3Z08sRUFBNGhPLFFBQTVoTyxFQUFzaU8sZUFBdGlPLEVBQXVqTyxZQUF2ak8sRUFBcWtPLFNBQXJrTyxFQUFnbE8sTUFBaGxPLEVBQXdsTyxVQUF4bE8sRUFBb21PLGtCQUFwbU8sRUFBd25PLHFCQUF4bk8sRUFBK29PLFNBQS9vTyxFQUEwcE8sWUFBMXBPLEVBQXdxTyxZQUF4cU8sRUFBc3JPLE1BQXRyTyxFQUE4ck8sVUFBOXJPLEVBQTBzTyxjQUExc08sRUFBMHRPLFNBQTF0TyxFQUFxdU8sa0JBQXJ1TyxFQUF5dk8sa0JBQXp2TyxFQUE2d08sZ0JBQTd3TyxFQUEreE8sT0FBL3hPLEVBQXd5TyxhQUF4eU8sRUFBdXpPLGdCQUF2ek8sRUFBeTBPLGdCQUF6ME8sRUFBMjFPLFVBQTMxTyxFQUF1Mk8sWUFBdjJPLEVBQXEzTyxTQUFyM08sRUFBZzRPLGNBQWg0TyxFQUFnNU8sUUFBaDVPLEVBQTA1TyxVQUExNU8sRUFBczZPLGNBQXQ2TyxFQUFzN08sbUJBQXQ3TyxFQUEyOE8sV0FBMzhPLEVBQXc5TyxXQUF4OU8sRUFBcStPLGdCQUFyK08sRUFBdS9PLFNBQXYvTyxFQUFrZ1AsaUJBQWxnUCxFQUFxaFAsUUFBcmhQLEVBQStoUCxVQUEvaFAsRUFBMmlQLFNBQTNpUCxFQUFzalAsY0FBdGpQLEVBQXNrUCxZQUF0a1AsRUFBb2xQLFVBQXBsUCxFQUFnbVAsUUFBaG1QLEVBQTBtUCxjQUExbVAsRUFBMG5QLFVBQTFuUCxFQUFzb1AsUUFBdG9QLEVBQWdwUCxPQUFocFAsRUFBeXBQLFdBQXpwUCxFQUFzcVAsY0FBdHFQLEVBQXNyUCxXQUF0clAsRUFBbXNQLGVBQW5zUCxFQUFvdFAsU0FBcHRQLEVBQSt0UCxlQUEvdFAsRUFBZ3ZQLFFBQWh2UCxFQUEwdlAsZUFBMXZQLEVBQTJ3UCxXQUEzd1AsRUFBd3hQLFFBQXh4UCxFQUFreVAsUUFBbHlQLEVBQTR5UCxrQkFBNXlQLEVBQWcwUCxhQUFoMFAsRUFBKzBQLGFBQS8wUCxFQUE4MVAsV0FBOTFQLEVBQTIyUCxXQUEzMlAsRUFBdzNQLFNBQXgzUCxFQUFtNFAsV0FBbjRQLEVBQWc1UCxXQUFoNVAsRUFBNjVQLFNBQTc1UCxFQUF3NlAsVUFBeDZQLEVBQW83UCxjQUFwN1AsRUFBbzhQLFdBQXA4UCxFQUFpOVAsT0FBajlQLEVBQTA5UCxnQkFBMTlQLEVBQTQrUCxXQUE1K1AsRUFBeS9QLE1BQXovUCxFQUFpZ1EsUUFBamdRLEVBQTJnUSxhQUEzZ1EsRUFBMGhRLFFBQTFoUSxFQUFvaVEsWUFBcGlRLEVBQWtqUSxnQkFBbGpRLEVBQW9rUSxXQUFwa1EsRUFBaWxRLFFBQWpsUSxFQUEybFEsS0FBM2xRLEVBQWttUSxZQUFsbVEsRUFBZ25RLFNBQWhuUSxFQUEyblEsTUFBM25RLEVBQW1vUSxPQUFub1EsRUFBNG9RLFNBQTVvUSxFQUF1cFEsVUFBdnBRLEVBQW1xUSxhQUFucVEsRUFBa3JRLFFBQWxyUSxFQUE0clEsUUFBNXJRLEVBQXNzUSxVQUF0c1EsRUFBa3RRLFNBQWx0USxFQUE2dFEsT0FBN3RRLEVBQXN1USxjQUF0dVEsRUFBc3ZRLFlBQXR2USxFQUFvd1EsZ0JBQXB3USxFQUFzeFEsV0FBdHhRLEVBQW15USxhQUFueVEsRUFBa3pRLG9CQUFselEsRUFBdzBRLHdCQUF4MFEsRUFBazJRLFFBQWwyUSxFQUE0MlEsT0FBNTJRLEVBQXEzUSxZQUFyM1EsRUFBbTRRLGlCQUFuNFEsRUFBczVRLFdBQXQ1USxFQUFtNlEsYUFBbjZRLEVBQWs3USxVQUFsN1EsRUFBODdRLFlBQTk3USxFQUE0OFEsU0FBNThRLEVBQXU5USxrQkFBdjlRLEVBQTIrUSxXQUEzK1EsRUFBdy9RLFNBQXgvUSxFQUFtZ1IsZUFBbmdSLEVBQW9oUixVQUFwaFIsRUFBZ2lSLFNBQWhpUixFQUEyaVIsWUFBM2lSLEVBQXlqUixZQUF6alIsRUFBdWtSLFNBQXZrUixFQUFrbFIsUUFBbGxSLEVBQTRsUixRQUE1bFIsRUFBc21SLFNBQXRtUixFQUFpblIsU0FBam5SLEVBQTRuUixlQUE1blIsRUFBNm9SLFlBQTdvUixFQUEycFIsT0FBM3BSLEVBQW9xUixZQUFwcVIsRUFBa3JSLGtCQUFsclIsRUFBc3NSLGlCQUF0c1IsRUFBeXRSLGlCQUF6dFIsRUFBNHVSLGtCQUE1dVIsRUFBZ3dSLGVBQWh3UixFQUFpeFIsWUFBanhSLEVBQSt4UixXQUEveFIsRUFBNHlSLFFBQTV5UixFQUFzelIsWUFBdHpSLEVBQW8wUixzQkFBcDBSLEVBQTQxUixXQUE1MVIsRUFBeTJSLGVBQXoyUixFQUEwM1IsaUJBQTEzUixFQUE2NFIsdUJBQTc0UixFQUFzNlIsc0JBQXQ2UixFQUE4N1IsT0FBOTdSLEVBQXU4UixRQUF2OFIsRUFBaTlSLHFCQUFqOVIsRUFBdytSLFFBQXgrUixFQUFrL1IsV0FBbC9SLEVBQSsvUixrQkFBLy9SLEVBQW1oUyxNQUFuaFMsRUFBMmhTLFNBQTNoUyxFQUFzaVMsV0FBdGlTLEVBQW1qUyxhQUFualMsRUFBa2tTLG9CQUFsa1MsRUFBd2xTLFdBQXhsUyxFQUFxbVMsV0FBcm1TLEVBQWtuUyxRQUFsblMsRUFBNG5TLE9BQTVuUyxFQUFxb1MsTUFBcm9TLEVBQTZvUyxPQUE3b1MsRUFBc3BTLG9CQUF0cFMsRUFBNHFTLFlBQTVxUyxFQUEwclMsYUFBMXJTLEVBQXlzUyxvQkFBenNTLEVBQSt0UyxRQUEvdFMsRUFBeXVTLFNBQXp1UyxFQUFvdlMsU0FBcHZTLEVBQSt2UyxPQUEvdlMsRUFBd3dTLFdBQXh3UyxFQUFxeFMsZUFBcnhTLEVBQXN5UyxhQUF0eVMsRUFBcXpTLFNBQXJ6UyxFQUFnMFMsU0FBaDBTLEVBQTIwUyxTQUEzMFMsRUFBczFTLFlBQXQxUyxFQUFvMlMsUUFBcDJTLEVBQTgyUyxrQkFBOTJTLEVBQWs0UyxhQUFsNFMsRUFBaTVTLE9BQWo1UyxFQUEwNVMsZ0JBQTE1UyxFQUE0NlMsVUFBNTZTLEVBQXc3UyxXQUF4N1MsRUFBcThTLGdCQUFyOFMsRUFBdTlTLG9CQUF2OVMsRUFBNitTLFNBQTcrUyxFQUF3L1MsUUFBeC9TLEVBQWtnVCxNQUFsZ1QsRUFBMGdULE9BQTFnVCxFQUFtaFQsYUFBbmhULEVBQWtpVCxRQUFsaVQsRUFBNGlULGNBQTVpVCxFQUE0alQsYUFBNWpULEVBQTJrVCxjQUEza1QsRUFBMmxULE9BQTNsVCxFQUFvbVQsVUFBcG1ULEVBQWduVCxNQUFoblQsRUFBd25ULE9BQXhuVCxFQUFpb1QsU0FBam9ULEVBQTRvVCxVQUE1b1QsRUFBd3BULFVBQXhwVCxFQUFvcVQseUJBQXBxVCxFQUErclQsVUFBL3JULEVBQTJzVCxpQkFBM3NULEVBQTh0VCxRQUE5dFQsRUFBd3VULFdBQXh1VCxFQUFxdlQsV0FBcnZULEVBQWt3VCxVQUFsd1QsRUFBOHdULFdBQTl3VCxFQUEyeFQsbUJBQTN4VCxFQUFnelQsYUFBaHpULEVBQSt6VCxZQUEvelQsRUFBNjBULFlBQTcwVCxFQUEyMVQsWUFBMzFULEVBQXkyVCxRQUF6MlQsQ0FBWDtBQUVELENBckJELEVBcUJHeWMsSUFyQkgsWTs7Ozs7Ozs7Ozs7Ozs7OztBQ0RBLElBQUlnTSxDQUFKOztBQUVBO0FBQ0FBLElBQUssWUFBVztBQUNmLFFBQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0FBQ0g7QUFDQUEsS0FBSUEsS0FBSyxJQUFJeTdCLFFBQUosQ0FBYSxhQUFiLEdBQVQ7QUFDQSxDQUhELENBR0UsT0FBTy8vQyxDQUFQLEVBQVU7QUFDWDtBQUNBLEtBQUksUUFBT3hCLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBdEIsRUFBZ0M4bEIsSUFBSTlsQixNQUFKO0FBQ2hDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQThVLE9BQU9DLE9BQVAsR0FBaUIrUSxDQUFqQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQkE7O0FBQ0E7Ozs7OztrQkFFZTtBQUNieHBCLFNBQU9BLFlBRE07QUFFYkQsbUJBQWlCQSxzQkFGSjtBQUdiRCxjQUFZQSxpQkFIQztBQUlib2xELGlCQUFlQTtBQUpGLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDMERDQyxRLEdBQUFBLFE7O2tCQTZKRCxVQUFTQyxPQUFULEVBQWtCeGlELE9BQWxCLEVBQTJCQyxNQUEzQixFQUFtQ0MsV0FBbkMsRUFBZ0RTLFVBQWhELEVBQTREQyxjQUE1RCxFQUEyRTZoRCxXQUEzRSxFQUF3RmhsRCxLQUF4RixFQUErRjtBQUM1RyxNQUFJLENBQUN5QyxXQUFMLEVBQWtCO0FBQ2hCQSxrQkFBYyxFQUFkO0FBQ0EsU0FBSyxJQUFJbzdDLE1BQU0saUJBQWYsRUFBa0NwN0MsWUFBWW5DLE1BQVosR0FBcUIsRUFBdkQsRUFBMkR1OUMsT0FBTyxDQUFsRSxFQUFxRTtBQUNuRXA3QyxrQkFBWXhCLElBQVosQ0FBaUI0OEMsR0FBakI7QUFDRDtBQUNGO0FBQ0QsTUFBSSxPQUFPdDdDLE9BQVAsSUFBa0IsUUFBdEIsRUFBZ0M7QUFDOUJBLGNBQVVNLEtBQUtDLEtBQUwsQ0FBV1AsT0FBWCxDQUFWO0FBQ0Q7QUFDRCxNQUFJQSxRQUFRUSxPQUFSLElBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLFVBQU0sSUFBSUMsS0FBSixDQUFVLDZCQUFWLENBQU47QUFDRDs7QUFFRCxNQUFJaWlELHNCQUFKO0FBQ0EsTUFBSTloRCxrQkFBa0IsQ0FBQzZoRCxXQUF2QixFQUFvQztBQUNsQyxRQUFNRSxNQUFNLElBQUlDLEtBQUosRUFBWjtBQUNBRCxRQUFJbDdDLFdBQUosR0FBa0IsV0FBbEI7QUFDQWs3QyxRQUFJRSxNQUFKLEdBQWEsWUFBVztBQUN0Qkosb0JBQWNFLEdBQWQ7QUFDQUQsc0JBQWdCLENBQUNDLElBQUl0MEMsS0FBTCxFQUFZczBDLElBQUlyMEMsTUFBaEIsQ0FBaEI7QUFDQWswQyxjQUFRTSxPQUFSO0FBQ0QsS0FKRDtBQUtBSCxRQUFJLzZDLEdBQUosR0FBVWhILGNBQVY7QUFDRDs7QUFFRCxNQUFNcXBCLE1BQU1yckIsU0FBU0csYUFBVCxDQUF1QixRQUF2QixFQUFpQ2drRCxVQUFqQyxDQUE0QyxJQUE1QyxDQUFaO0FBQ0EsTUFBTUMsZUFBZSxFQUFyQjs7QUFFQSxXQUFTQyxRQUFULENBQWtCajdCLElBQWxCLEVBQXdCM3BCLElBQXhCLEVBQThCNmtELEVBQTlCLEVBQWtDO0FBQ2hDLFFBQU1uOEMsTUFBTW04QyxLQUFLLEdBQUwsR0FBVzdrRCxJQUFYLEdBQWtCLEdBQWxCLEdBQXdCMnBCLElBQXBDO0FBQ0EsUUFBSW03QixjQUFjSCxhQUFhajhDLEdBQWIsQ0FBbEI7QUFDQSxRQUFJLENBQUNvOEMsV0FBTCxFQUFrQjtBQUNoQmw1QixVQUFJNXJCLElBQUosR0FBV0EsSUFBWDtBQUNBLFVBQU0ra0QsUUFBUW41QixJQUFJbzVCLFdBQUosQ0FBZ0IsR0FBaEIsRUFBcUJoMUMsS0FBbkM7QUFDQSxVQUFNQSxRQUFRKzBDLFFBQVFGLEVBQXRCO0FBQ0EsVUFBTUksUUFBUXQ3QixLQUFLMXBCLEtBQUwsQ0FBVyxHQUFYLENBQWQ7QUFDQSxVQUFJc08sT0FBTyxFQUFYO0FBQ0EsVUFBTXVrQyxRQUFRLEVBQWQ7QUFDQSxXQUFLLElBQUl6ekMsSUFBSSxDQUFSLEVBQVdDLEtBQUsybEQsTUFBTXZsRCxNQUEzQixFQUFtQ0wsSUFBSUMsRUFBdkMsRUFBMkMsRUFBRUQsQ0FBN0MsRUFBZ0Q7QUFDOUMsWUFBTTZsRCxPQUFPRCxNQUFNNWxELENBQU4sQ0FBYjtBQUNBLFlBQUt1c0IsSUFBSW81QixXQUFKLENBQWdCejJDLE9BQU8yMkMsSUFBdkIsRUFBNkJsMUMsS0FBN0IsSUFBc0NBLEtBQTNDLEVBQW1EO0FBQ2pEekIsa0JBQVEsQ0FBQ0EsT0FBTyxHQUFQLEdBQWEsRUFBZCxJQUFvQjIyQyxJQUE1QjtBQUNELFNBRkQsTUFFTztBQUNMLGNBQUkzMkMsSUFBSixFQUFVO0FBQ1J1a0Msa0JBQU16eUMsSUFBTixDQUFXa08sSUFBWDtBQUNEO0FBQ0RBLGlCQUFPMjJDLElBQVA7QUFDRDtBQUNGO0FBQ0QsVUFBSTMyQyxJQUFKLEVBQVU7QUFDUnVrQyxjQUFNenlDLElBQU4sQ0FBV2tPLElBQVg7QUFDRDtBQUNEbzJDLG1CQUFhajhDLEdBQWIsSUFBb0JvOEMsY0FBY2hTLE1BQU1yb0MsSUFBTixDQUFXLElBQVgsQ0FBbEM7QUFDRDtBQUNELFdBQU9xNkMsV0FBUDtBQUNEOztBQUVELE1BQU1LLFlBQVksb0NBQVl4akQsUUFBUW9DLE1BQXBCLENBQWxCOztBQUVBLE1BQU1xaEQsc0JBQXNCLEVBQTVCO0FBQ0EsTUFBTUMsZUFBZSxFQUFyQjtBQUNBLE1BQUlDLHFCQUFKO0FBQ0EsT0FBSyxJQUFJam1ELElBQUksQ0FBUixFQUFXQyxLQUFLNmxELFVBQVV6bEQsTUFBL0IsRUFBdUNMLElBQUlDLEVBQTNDLEVBQStDLEVBQUVELENBQWpELEVBQW9EO0FBQ2xELFFBQU00QixRQUFRa2tELFVBQVU5bEQsQ0FBVixDQUFkO0FBQ0EsUUFBTXNMLFVBQVUxSixNQUFNK0MsRUFBdEI7QUFDQSxRQUFJLE9BQU9wQyxNQUFQLElBQWlCLFFBQWpCLElBQTZCWCxNQUFNVyxNQUFOLElBQWdCQSxNQUE3QyxJQUNGQSxPQUFPeEIsT0FBUCxDQUFldUssT0FBZixNQUE0QixDQUFDLENBRC9CLEVBQ2tDO0FBQ2hDLFVBQU00NkMsY0FBY3RrRCxNQUFNLGNBQU4sQ0FBcEI7QUFDQSxVQUFJLENBQUNxa0QsWUFBTCxFQUFtQjtBQUNqQkEsdUJBQWVya0QsTUFBTVcsTUFBckI7QUFDRDtBQUNELFVBQUltQyxTQUFTcWhELG9CQUFvQkcsV0FBcEIsQ0FBYjtBQUNBLFVBQUksQ0FBQ3hoRCxNQUFMLEVBQWE7QUFDWEEsaUJBQVNxaEQsb0JBQW9CRyxXQUFwQixJQUFtQyxFQUE1QztBQUNEO0FBQ0R4aEQsYUFBTzFELElBQVAsQ0FBWTtBQUNWWSxlQUFPQSxLQURHO0FBRVZnVixlQUFPNVc7QUFGRyxPQUFaO0FBSUFnbUQsbUJBQWFobEQsSUFBYixDQUFrQnNLLE9BQWxCO0FBQ0Q7QUFDRDtBQUNBLFdBQU82NkMsY0FBYzc2QyxPQUFkLENBQVA7QUFDQSxXQUFPODZDLFlBQVk5NkMsT0FBWixDQUFQO0FBQ0Q7QUFDRCxNQUFNKzZDLGlCQUFpQixFQUF2Qjs7QUFFQSxNQUFNQyxTQUFTLEVBQWY7QUFDQSxNQUFNQyxlQUFlLEVBQXJCOztBQUVBLE1BQU1yUCxnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQVNqcEIsT0FBVCxFQUFrQnU0QixVQUFsQixFQUE4QjtBQUNsRCxRQUFNcnpDLGFBQWE4YSxRQUFRdzRCLGFBQVIsRUFBbkI7QUFDQXg0QixZQUFReTRCLFFBQVIsR0FBbUJ6NEIsUUFBUXk0QixRQUFSLElBQW9CLEVBQXZDO0FBQ0EsUUFBTWhpRCxTQUFTcWhELG9CQUFvQjV5QyxXQUFXdlIsS0FBL0IsQ0FBZjtBQUNBLFFBQUksQ0FBQzhDLE1BQUwsRUFBYTtBQUNYO0FBQ0Q7QUFDRCxRQUFJVyxPQUFPN0MsWUFBWXpCLE9BQVosQ0FBb0J5bEQsVUFBcEIsQ0FBWDtBQUNBLFFBQUluaEQsUUFBUSxDQUFDLENBQWIsRUFBZ0I7QUFDZEEsYUFBT2tVLEtBQUtySixLQUFMLENBQVcsZ0NBQXFCczJDLFVBQXJCLEVBQWlDaGtELFdBQWpDLENBQVgsQ0FBUDtBQUNEO0FBQ0QsUUFBTXdDLE9BQU9tbkIsTUFBTThCLFFBQVEwNEIsV0FBUixHQUFzQjltQixPQUF0QixFQUFOLENBQWI7QUFDQSxRQUFNN1gsSUFBSTtBQUNSN1Usa0JBQVlBLFVBREo7QUFFUm5PLFlBQU1BO0FBRkUsS0FBVjtBQUlBLFFBQUk0aEQsZUFBZSxDQUFDLENBQXBCO0FBQ0EsU0FBSyxJQUFJNW1ELEtBQUksQ0FBUixFQUFXQyxNQUFLeUUsT0FBT3JFLE1BQTVCLEVBQW9DTCxLQUFJQyxHQUF4QyxFQUE0QyxFQUFFRCxFQUE5QyxFQUFpRDtBQUMvQyxVQUFNNm1ELFlBQVluaUQsT0FBTzFFLEVBQVAsQ0FBbEI7QUFDQSxVQUFNNEIsU0FBUWlsRCxVQUFVamxELEtBQXhCO0FBQ0EsVUFBTTBKLFdBQVUxSixPQUFNK0MsRUFBdEI7O0FBRUEsVUFBTTlDLFNBQVNELE9BQU1DLE1BQU4sSUFBZ0JpbEQsUUFBL0I7QUFDQSxVQUFNMWhELFFBQVF4RCxPQUFNd0QsS0FBTixJQUFlMGhELFFBQTdCO0FBQ0EsVUFBSWpsRCxPQUFPK0QsVUFBUCxLQUFzQixNQUF0QixJQUFpQyxhQUFhaEUsTUFBYixJQUFzQnlELE9BQU96RCxPQUFNMEcsT0FBcEUsSUFDRCxhQUFhMUcsTUFBYixJQUFzQnlELFFBQVF6RCxPQUFNd0csT0FEdkMsRUFDaUQ7QUFDL0M7QUFDRDtBQUNENmxCLGNBQVF5NEIsUUFBUixDQUFpQnJoRCxJQUFqQixJQUF5QjRvQixRQUFReTRCLFFBQVIsQ0FBaUJyaEQsSUFBakIsS0FBMEIsRUFBbkQ7QUFDQSxVQUFNa0ssU0FBUzNOLE9BQU0yTixNQUFyQjtBQUNBLFVBQUkrMEMsYUFBSjtBQUFBLFVBQVV5QyxnQkFBVjtBQUNBLFVBQUksQ0FBQ3gzQyxNQUFELElBQVd5M0MsZUFBZTE3QyxRQUFmLEVBQXdCaUUsTUFBeEIsRUFBZ0N5WSxDQUFoQyxFQUFtQzNpQixJQUFuQyxDQUFmLEVBQXlEO0FBQ3ZELFlBQUlvSCxjQUFKO0FBQUEsWUFBVzlHLGdCQUFYO0FBQUEsWUFBb0JrSixhQUFwQjtBQUFBLFlBQTBCbzRDLGVBQTFCO0FBQUEsWUFBa0NDLG9CQUFsQztBQUFBLFlBQStDNWlELGNBQS9DO0FBQ0EsWUFBTXNTLFFBQVFpd0MsVUFBVWp3QyxLQUF4QjtBQUNBLFlBQUk1UixRQUFRLENBQVIsSUFBYXBELE9BQU1vRCxJQUFOLElBQWMsTUFBL0IsRUFBdUM7QUFDckNXLG9CQUFVay9DLFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixjQUF6QixFQUF5Q3lELElBQXpDLEVBQStDMmlCLENBQS9DLENBQVY7QUFDQSxjQUFJLGtCQUFrQjVpQixLQUF0QixFQUE2QjtBQUMzQixnQkFBTStoRCxZQUFZdEMsU0FBU2pqRCxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLGNBQXpCLEVBQXlDeUQsSUFBekMsRUFBK0MyaUIsQ0FBL0MsQ0FBbEI7QUFDQSxnQkFBSW0vQixTQUFKLEVBQWU7QUFDYjdDLHFCQUFPLE9BQU82QyxTQUFQLEtBQXFCLFFBQXJCLEdBQWdDQyxhQUFhRCxTQUFiLEVBQXdCaDBDLFVBQXhCLENBQWhDLEdBQXNFZzBDLFVBQVV6aEQsUUFBVixFQUE3RTtBQUNBLGtCQUFJcS9DLGVBQWU5aEQsVUFBZixJQUE2QkEsV0FBV3FoRCxJQUFYLENBQWpDLEVBQW1EO0FBQ2pELGtCQUFFc0MsWUFBRjtBQUNBLG9CQUFJMzRCLFFBQVF5NEIsUUFBUixDQUFpQnJoRCxJQUFqQixFQUF1QnRFLE9BQXZCLENBQStCdUssUUFBL0IsTUFBNEMsQ0FBQyxDQUFqRCxFQUFvRDtBQUNsRDJpQiwwQkFBUXk0QixRQUFSLENBQWlCcmhELElBQWpCLEVBQXVCckUsSUFBdkIsQ0FBNEJzSyxRQUE1QjtBQUNEO0FBQ0RoSCx3QkFBUWdpRCxPQUFPTSxZQUFQLENBQVI7QUFDQSxvQkFBSSxDQUFDdGlELEtBQUQsSUFBVSxDQUFDQSxNQUFNK2lELE9BQU4sRUFBWCxJQUE4Qi9pRCxNQUFNZ2pELFNBQU4sRUFBOUIsSUFBbURoakQsTUFBTWlqRCxPQUFOLEVBQXZELEVBQXdFO0FBQ3RFampELDBCQUFRZ2lELE9BQU9NLFlBQVAsSUFBdUIsSUFBSVksZUFBSixDQUFVO0FBQ3ZDMzRDLDBCQUFNLElBQUk0NEMsY0FBSjtBQURpQyxtQkFBVixDQUEvQjtBQUdEO0FBQ0Q1NEMsdUJBQU92SyxNQUFNK2lELE9BQU4sRUFBUDtBQUNBL2lELHNCQUFNb2pELFNBQU4sQ0FBZ0I5d0MsS0FBaEI7QUFDQSxvQkFBTSt3QyxpQkFBaUJyRCxPQUFPLEdBQVAsR0FBYTMrQyxPQUFwQztBQUNBLG9CQUFJaWlELFVBQVVyQixhQUFhb0IsY0FBYixDQUFkO0FBQ0Esb0JBQUksQ0FBQ0MsT0FBTCxFQUFjO0FBQ1osc0JBQU1DLGtCQUFrQjVrRCxXQUFXcWhELElBQVgsQ0FBeEI7QUFDQSxzQkFBTXdELFNBQVM1bUQsU0FBU0csYUFBVCxDQUF1QixRQUF2QixDQUFmO0FBQ0F5bUQseUJBQU9uM0MsS0FBUCxHQUFlazNDLGdCQUFnQmwzQyxLQUEvQjtBQUNBbTNDLHlCQUFPbDNDLE1BQVAsR0FBZ0JpM0MsZ0JBQWdCajNDLE1BQWhDO0FBQ0Esc0JBQU0yYixPQUFNdTdCLE9BQU96QyxVQUFQLENBQWtCLElBQWxCLENBQVo7QUFDQTk0Qix1QkFBSXc3QixXQUFKLEdBQWtCcGlELE9BQWxCO0FBQ0E0bUIsdUJBQUl5N0IsU0FBSixDQUNFakQsV0FERixFQUVFOEMsZ0JBQWdCcHFDLENBRmxCLEVBR0VvcUMsZ0JBQWdCaDNCLENBSGxCLEVBSUVnM0IsZ0JBQWdCbDNDLEtBSmxCLEVBS0VrM0MsZ0JBQWdCajNDLE1BTGxCLEVBTUUsQ0FORixFQU9FLENBUEYsRUFRRWkzQyxnQkFBZ0JsM0MsS0FSbEIsRUFTRWszQyxnQkFBZ0JqM0MsTUFUbEI7QUFXQWczQyw0QkFBVXI3QixLQUFJMDdCLGFBQUosQ0FBa0JILE1BQWxCLEVBQTBCLFFBQTFCLENBQVY7QUFDQXZCLCtCQUFhb0IsY0FBYixJQUErQkMsT0FBL0I7QUFDRDtBQUNELzRDLHFCQUFLcTVDLFFBQUwsQ0FBY04sT0FBZDtBQUNEO0FBQ0Y7QUFDRixXQTNDRCxNQTJDTyxJQUFJLGdCQUFnQnhpRCxLQUFwQixFQUEyQjtBQUNoQ3FILG9CQUFRMDdDLGlCQUFpQnRELFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixZQUF6QixFQUF1Q3lELElBQXZDLEVBQTZDMmlCLENBQTdDLENBQWpCLEVBQWtFcmlCLE9BQWxFLENBQVI7QUFDQSxnQkFBSThHLEtBQUosRUFBVztBQUNULGdCQUFFbTZDLFlBQUY7QUFDQSxrQkFBSTM0QixRQUFReTRCLFFBQVIsQ0FBaUJyaEQsSUFBakIsRUFBdUJ0RSxPQUF2QixDQUErQnVLLFFBQS9CLE1BQTRDLENBQUMsQ0FBakQsRUFBb0Q7QUFDbEQyaUIsd0JBQVF5NEIsUUFBUixDQUFpQnJoRCxJQUFqQixFQUF1QnJFLElBQXZCLENBQTRCc0ssUUFBNUI7QUFDRDtBQUNEaEgsc0JBQVFnaUQsT0FBT00sWUFBUCxDQUFSO0FBQ0Esa0JBQUksQ0FBQ3RpRCxLQUFELElBQVUsQ0FBQ0EsTUFBTStpRCxPQUFOLEVBQVgsSUFBOEIvaUQsTUFBTWdqRCxTQUFOLEVBQTlCLElBQW1EaGpELE1BQU1pakQsT0FBTixFQUF2RCxFQUF3RTtBQUN0RWpqRCx3QkFBUWdpRCxPQUFPTSxZQUFQLElBQXVCLElBQUlZLGVBQUosQ0FBVTtBQUN2QzM0Qyx3QkFBTSxJQUFJNDRDLGNBQUo7QUFEaUMsaUJBQVYsQ0FBL0I7QUFHRDtBQUNENTRDLHFCQUFPdkssTUFBTStpRCxPQUFOLEVBQVA7QUFDQXg0QyxtQkFBS3E1QyxRQUFMLENBQWN6N0MsS0FBZDtBQUNBbkksb0JBQU1vakQsU0FBTixDQUFnQjl3QyxLQUFoQjtBQUNEO0FBQ0QsZ0JBQUksd0JBQXdCeFIsS0FBNUIsRUFBbUM7QUFDakM4aEQsNEJBQWNpQixpQkFBaUJ0RCxTQUFTampELE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsb0JBQXpCLEVBQStDeUQsSUFBL0MsRUFBcUQ4TixVQUFyRCxDQUFqQixFQUFtRnhOLE9BQW5GLENBQWQ7QUFDRCxhQUZELE1BRU8sSUFBSSxvQkFBb0JQLEtBQXhCLEVBQStCO0FBQ3BDOGhELDRCQUFjejZDLEtBQWQ7QUFDRDtBQUNELGdCQUFJeTZDLFdBQUosRUFBaUI7QUFDZixnQkFBRU4sWUFBRjtBQUNBLGtCQUFJMzRCLFFBQVF5NEIsUUFBUixDQUFpQnJoRCxJQUFqQixFQUF1QnRFLE9BQXZCLENBQStCdUssUUFBL0IsTUFBNEMsQ0FBQyxDQUFqRCxFQUFvRDtBQUNsRDJpQix3QkFBUXk0QixRQUFSLENBQWlCcmhELElBQWpCLEVBQXVCckUsSUFBdkIsQ0FBNEJzSyxRQUE1QjtBQUNEO0FBQ0RoSCxzQkFBUWdpRCxPQUFPTSxZQUFQLENBQVI7QUFDQSxrQkFBSSxDQUFDdGlELEtBQUQsSUFBVSxDQUFDQSxNQUFNZ2pELFNBQU4sRUFBWCxJQUFnQ2hqRCxNQUFNK2lELE9BQU4sRUFBaEMsSUFBbUQvaUQsTUFBTWlqRCxPQUFOLEVBQXZELEVBQXdFO0FBQ3RFampELHdCQUFRZ2lELE9BQU9NLFlBQVAsSUFBdUIsSUFBSVksZUFBSixDQUFVO0FBQ3ZDUCwwQkFBUSxJQUFJbUIsZ0JBQUo7QUFEK0IsaUJBQVYsQ0FBL0I7QUFHRDtBQUNEbkIsdUJBQVMzaUQsTUFBTWdqRCxTQUFOLEVBQVQ7QUFDQUwscUJBQU9pQixRQUFQLENBQWdCaEIsV0FBaEI7QUFDQUQscUJBQU9vQixRQUFQLENBQWdCLENBQWhCO0FBQ0EvakQsb0JBQU1vakQsU0FBTixDQUFnQjl3QyxLQUFoQjtBQUNEO0FBQ0Y7QUFDRjtBQUNELFlBQUk1UixRQUFRLENBQVIsSUFBYXBELE9BQU1vRCxJQUFOLElBQWMsTUFBL0IsRUFBdUM7QUFBQTtBQUNyQ3lILG9CQUFRLEVBQUUsa0JBQWtCckgsS0FBcEIsS0FBOEIsZ0JBQWdCQSxLQUE5QyxHQUNOK2lELGlCQUFpQnRELFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixZQUF6QixFQUF1Q3lELElBQXZDLEVBQTZDMmlCLENBQTdDLENBQWpCLEVBQWtFNjhCLFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixjQUF6QixFQUF5Q3lELElBQXpDLEVBQStDMmlCLENBQS9DLENBQWxFLENBRE0sR0FFTmhrQixTQUZGO0FBR0EsZ0JBQU0yTSxRQUFRazBDLFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixZQUF6QixFQUF1Q3lELElBQXZDLEVBQTZDMmlCLENBQTdDLENBQWQ7QUFDQSxnQkFBSXZiLFNBQVNrRSxRQUFRLENBQXJCLEVBQXdCO0FBQ3RCLGdCQUFFaTJDLFlBQUY7QUFDQSxrQkFBSTM0QixRQUFReTRCLFFBQVIsQ0FBaUJyaEQsSUFBakIsRUFBdUJ0RSxPQUF2QixDQUErQnVLLFFBQS9CLE1BQTRDLENBQUMsQ0FBakQsRUFBb0Q7QUFDbEQyaUIsd0JBQVF5NEIsUUFBUixDQUFpQnJoRCxJQUFqQixFQUF1QnJFLElBQXZCLENBQTRCc0ssUUFBNUI7QUFDRDtBQUNEaEgsc0JBQVFnaUQsT0FBT00sWUFBUCxDQUFSO0FBQ0Esa0JBQUksQ0FBQ3RpRCxLQUFELElBQVUsQ0FBQ0EsTUFBTWdqRCxTQUFOLEVBQVgsSUFBZ0NoakQsTUFBTStpRCxPQUFOLEVBQWhDLElBQW1EL2lELE1BQU1pakQsT0FBTixFQUF2RCxFQUF3RTtBQUN0RWpqRCx3QkFBUWdpRCxPQUFPTSxZQUFQLElBQXVCLElBQUlZLGVBQUosQ0FBVTtBQUN2Q1AsMEJBQVEsSUFBSW1CLGdCQUFKO0FBRCtCLGlCQUFWLENBQS9CO0FBR0Q7QUFDRG5CLHVCQUFTM2lELE1BQU1nakQsU0FBTixFQUFUO0FBQ0FMLHFCQUFPcUIsVUFBUCxDQUFrQnpELFNBQVNqakQsTUFBVCxFQUFnQixRQUFoQixFQUEwQixVQUExQixFQUFzQ3lELElBQXRDLEVBQTRDMmlCLENBQTVDLENBQWxCO0FBQ0FpL0IscUJBQU9zQixXQUFQLENBQW1CMUQsU0FBU2pqRCxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLFdBQTFCLEVBQXVDeUQsSUFBdkMsRUFBNkMyaUIsQ0FBN0MsQ0FBbkI7QUFDQWkvQixxQkFBT3VCLGFBQVAsQ0FBcUIzRCxTQUFTampELE1BQVQsRUFBZ0IsUUFBaEIsRUFBMEIsa0JBQTFCLEVBQThDeUQsSUFBOUMsRUFBb0QyaUIsQ0FBcEQsQ0FBckI7QUFDQWkvQixxQkFBT2lCLFFBQVAsQ0FBZ0J6N0MsS0FBaEI7QUFDQXc2QyxxQkFBT29CLFFBQVAsQ0FBZ0IxM0MsS0FBaEI7QUFDQXMyQyxxQkFBT3dCLFdBQVAsQ0FBbUJyakQsTUFBTSxnQkFBTixJQUNqQnkvQyxTQUFTampELE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsZ0JBQXpCLEVBQTJDeUQsSUFBM0MsRUFBaUQyaUIsQ0FBakQsRUFBb0R0bkIsR0FBcEQsQ0FBd0QsVUFBUytjLENBQVQsRUFBWTtBQUNsRSx1QkFBT0EsSUFBSTlNLEtBQVg7QUFDRCxlQUZELENBRGlCLEdBR1osSUFIUDtBQUlBck0sb0JBQU1vakQsU0FBTixDQUFnQjl3QyxLQUFoQjtBQUNEO0FBM0JvQztBQTRCdEM7O0FBRUQsWUFBSTh4QyxXQUFXLEtBQWY7QUFDQSxZQUFJcCtCLE9BQU8sSUFBWDtBQUNBLFlBQUlxK0Isa0JBQUo7QUFDQSxZQUFJLENBQUMzakQsUUFBUSxDQUFSLElBQWFBLFFBQVEsQ0FBdEIsS0FBNEIsZ0JBQWdCbkQsTUFBaEQsRUFBd0Q7QUFDdEQsY0FBTXNsRCxhQUFZdEMsU0FBU2pqRCxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLFlBQTFCLEVBQXdDeUQsSUFBeEMsRUFBOEMyaUIsQ0FBOUMsQ0FBbEI7QUFDQSxjQUFJbS9CLFVBQUosRUFBZTtBQUNiN0MsbUJBQU8sT0FBTzZDLFVBQVAsS0FBcUIsUUFBckIsR0FDSEMsYUFBYUQsVUFBYixFQUF3QmgwQyxVQUF4QixDQURHLEdBRUhnMEMsV0FBVXpoRCxRQUFWLEVBRko7QUFHQSxnQkFBSWtqRCxZQUFZNWtELFNBQWhCO0FBQ0EsZ0JBQUkrZ0QsZUFBZTloRCxVQUFmLElBQTZCQSxXQUFXcWhELElBQVgsQ0FBakMsRUFBbUQ7QUFDakQsa0JBQUl0L0MsUUFBUSxDQUFaLEVBQWU7QUFDYixvQkFBTTZqRCxPQUFPNTZCLFFBQVEwNEIsV0FBUixFQUFiO0FBQ0E7QUFDQSxvQkFBSWtDLEtBQUtDLGVBQVQsRUFBMEI7QUFDeEIsc0JBQU1DLFNBQVNGLEtBQUs5aEQsU0FBTCxFQUFmO0FBQ0Esc0JBQU1FLE9BQU9zUyxLQUFLbEcsSUFBTCxDQUFVa0csS0FBS3ZGLEdBQUwsQ0FDckJ1RixLQUFLd1gsR0FBTCxDQUFTLENBQUNnNEIsT0FBTyxDQUFQLElBQVlBLE9BQU8sQ0FBUCxDQUFiLElBQTBCdkMsVUFBbkMsRUFBK0MsQ0FBL0MsQ0FEcUIsRUFFckJqdEMsS0FBS3dYLEdBQUwsQ0FBUyxDQUFDZzRCLE9BQU8sQ0FBUCxJQUFZQSxPQUFPLENBQVAsQ0FBYixJQUEwQnZDLFVBQW5DLEVBQStDLENBQS9DLENBRnFCLENBQVYsQ0FBYjtBQUdBLHNCQUFJdi9DLE9BQU8sR0FBWCxFQUFnQjtBQUNkO0FBQ0EyaEQsZ0NBQVksSUFBSTkyQyxlQUFKLENBQVUrMkMsS0FBS0MsZUFBTCxFQUFWLENBQVo7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxrQkFBSTlqRCxTQUFTLENBQVQsSUFBYzRqRCxTQUFsQixFQUE2QjtBQUMzQixrQkFBRWhDLFlBQUY7QUFDQSxvQkFBSTM0QixRQUFReTRCLFFBQVIsQ0FBaUJyaEQsSUFBakIsRUFBdUJ0RSxPQUF2QixDQUErQnVLLFFBQS9CLE1BQTRDLENBQUMsQ0FBakQsRUFBb0Q7QUFDbEQyaUIsMEJBQVF5NEIsUUFBUixDQUFpQnJoRCxJQUFqQixFQUF1QnJFLElBQXZCLENBQTRCc0ssUUFBNUI7QUFDRDtBQUNEaEgsd0JBQVFnaUQsT0FBT00sWUFBUCxDQUFSO0FBQ0Esb0JBQUksQ0FBQ3RpRCxLQUFELElBQVUsQ0FBQ0EsTUFBTWdHLFFBQU4sRUFBWCxJQUErQmhHLE1BQU0raUQsT0FBTixFQUEvQixJQUFrRC9pRCxNQUFNZ2pELFNBQU4sRUFBdEQsRUFBeUU7QUFDdkVoakQsMEJBQVFnaUQsT0FBT00sWUFBUCxJQUF1QixJQUFJWSxlQUFKLEVBQS9CO0FBQ0Q7QUFDRGxqRCxzQkFBTTBrRCxXQUFOLENBQWtCSixTQUFsQjtBQUNBLG9CQUFNSyxXQUFXcEUsU0FBU2pqRCxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLFdBQTFCLEVBQXVDeUQsSUFBdkMsRUFBNkMyaUIsQ0FBN0MsQ0FBakI7QUFDQSxvQkFBTWtoQyxZQUFZOWpELE1BQU0sWUFBTixNQUF3QnBCLFNBQXhCLEdBQW9DNmdELFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixZQUF6QixFQUF1Q3lELElBQXZDLEVBQTZDMmlCLENBQTdDLENBQXBDLEdBQXNGLElBQXhHO0FBQ0Esb0JBQU1taEMsZ0JBQWdCdEUsU0FBU2pqRCxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLGdCQUF6QixFQUEyQ3lELElBQTNDLEVBQWlEMmlCLENBQWpELENBQXRCO0FBQ0Esb0JBQU1vaEMsc0JBQXNCdkUsU0FBU2pqRCxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLHVCQUF6QixFQUFrRHlELElBQWxELEVBQXdEMmlCLENBQXhELENBQTVCO0FBQ0Esb0JBQU1xaEMsa0JBQWtCeEUsU0FBU2pqRCxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLGFBQTFCLEVBQXlDeUQsSUFBekMsRUFBK0MyaUIsQ0FBL0MsQ0FBeEI7QUFDQSxvQkFBTXNoQyxhQUFhekUsU0FBU2pqRCxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLGFBQTFCLEVBQXlDeUQsSUFBekMsRUFBK0MyaUIsQ0FBL0MsQ0FBbkI7O0FBZjJCLHdDQW1CdkJ1aEMsaUJBQWlCRixlQUFqQixDQW5CdUI7QUFBQSxvQkFpQnpCRyxZQWpCeUIscUJBaUJ6QkEsWUFqQnlCO0FBQUEsOERBa0J6QkMsVUFsQnlCO0FBQUEsb0JBa0J6QkEsVUFsQnlCLHlDQWtCWkosZUFsQlk7O0FBb0IzQixvQkFBSTFCLGtCQUFpQnJELE9BQU8sR0FBUCxHQUFhMkUsUUFBYixHQUF3QixHQUF4QixHQUE4QkUsYUFBOUIsR0FBOEMsR0FBOUMsR0FBb0RDLG1CQUFwRCxHQUEwRSxHQUExRSxHQUFnRkssVUFBaEYsR0FBNkYsR0FBN0YsR0FBbUdILFVBQW5HLEdBQWdILEdBQWhILEdBQXNIRSxZQUEzSTtBQUNBLG9CQUFJTixjQUFjLElBQWxCLEVBQXdCO0FBQ3RCdkIscUNBQWtCLE1BQU11QixTQUF4QjtBQUNEO0FBQ0RuQywwQkFBVVYsZUFBZXNCLGVBQWYsQ0FBVjtBQUNBLG9CQUFJLENBQUNaLE9BQUwsRUFBYztBQUNaLHNCQUFNYyxtQkFBa0I1a0QsV0FBV3FoRCxJQUFYLENBQXhCO0FBQ0Esc0JBQU13RCxVQUFTNW1ELFNBQVNHLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtBQUNBeW1ELDBCQUFPbjNDLEtBQVAsR0FBZWszQyxpQkFBZ0JsM0MsS0FBL0I7QUFDQW0zQywwQkFBT2wzQyxNQUFQLEdBQWdCaTNDLGlCQUFnQmozQyxNQUFoQztBQUNBLHNCQUFNMmIsUUFBTXU3QixRQUFPekMsVUFBUCxDQUFrQixJQUFsQixDQUFaO0FBQ0E5NEIsd0JBQUl5N0IsU0FBSixDQUNFakQsV0FERixFQUVFOEMsaUJBQWdCcHFDLENBRmxCLEVBR0VvcUMsaUJBQWdCaDNCLENBSGxCLEVBSUVnM0IsaUJBQWdCbDNDLEtBSmxCLEVBS0VrM0MsaUJBQWdCajNDLE1BTGxCLEVBTUUsQ0FORixFQU9FLENBUEYsRUFRRWkzQyxpQkFBZ0JsM0MsS0FSbEIsRUFTRWszQyxpQkFBZ0JqM0MsTUFUbEI7QUFXQSxzQkFBTXBHLE9BQU8raEIsTUFBSW05QixZQUFKLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCNUIsUUFBT24zQyxLQUE5QixFQUFxQ20zQyxRQUFPbDNDLE1BQTVDLENBQWI7QUFDQSxzQkFBSXM0QyxjQUFjLElBQWxCLEVBQXdCO0FBQ3RCO0FBQ0F6OEMsNEJBQVEwN0MsaUJBQWlCZSxTQUFqQixFQUE0QixDQUE1QixDQUFSO0FBQ0EseUJBQUssSUFBSTU3QixJQUFJLENBQVIsRUFBV3E4QixLQUFLbi9DLEtBQUtBLElBQUwsQ0FBVW5LLE1BQS9CLEVBQXVDaXRCLElBQUlxOEIsRUFBM0MsRUFBK0NyOEIsS0FBSyxDQUFwRCxFQUF1RDtBQUNyRDlpQiwyQkFBS0EsSUFBTCxDQUFVOGlCLENBQVYsSUFBZTdnQixNQUFNLENBQU4sQ0FBZjtBQUNBakMsMkJBQUtBLElBQUwsQ0FBVThpQixJQUFJLENBQWQsSUFBbUI3Z0IsTUFBTSxDQUFOLENBQW5CO0FBQ0FqQywyQkFBS0EsSUFBTCxDQUFVOGlCLElBQUksQ0FBZCxJQUFtQjdnQixNQUFNLENBQU4sQ0FBbkI7QUFDRDtBQUNGO0FBQ0Q4Zix3QkFBSXE5QixZQUFKLENBQWlCcC9DLElBQWpCLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCO0FBQ0Esc0JBQU1xL0Msa0JBQWtCLENBQUNWLGNBQWMsQ0FBZCxJQUFtQnRCLGlCQUFnQmwzQyxLQUFwQyxFQUEyQ3c0QyxjQUFjLENBQWQsSUFBbUJ0QixpQkFBZ0JqM0MsTUFBOUUsQ0FBeEI7QUFDQW0yQyw0QkFBVVYsZUFBZXNCLGVBQWYsSUFBaUMsSUFBSW1DLGNBQUosQ0FBUztBQUNsRDdFLHlCQUFLNkMsT0FENkM7QUFFbERpQyxrQ0FBY04sVUFGb0M7QUFHbERqOUMsNEJBQVEsQ0FBQzg4QyxXQUFXLENBQVgsSUFBZ0JFLGFBQWEsQ0FBYixDQUFoQixHQUFrQ0ssZ0JBQWdCLENBQWhCLENBQW5DLEVBQXVEUCxXQUFXLENBQVgsSUFBZ0JFLGFBQWEsQ0FBYixDQUFoQixHQUFrQ0ssZ0JBQWdCLENBQWhCLENBQXpGLENBSDBDO0FBSWxERyw2QkFBUyxDQUFDbEMsUUFBT24zQyxLQUFSLEVBQWVtM0MsUUFBT2wzQyxNQUF0QixDQUp5QztBQUtsRDJaLDJCQUFPMCtCLFdBQVdwQixpQkFBZ0JvQztBQUxnQixtQkFBVCxDQUEzQztBQU9EO0FBQ0Qsb0JBQUlDLGNBQWNyRixTQUFTampELE1BQVQsRUFBZ0IsUUFBaEIsRUFBMEIsYUFBMUIsRUFBeUN5RCxJQUF6QyxFQUErQzJpQixDQUEvQyxDQUFsQjtBQUNBLG9CQUFJa2lDLFlBQVlucEQsT0FBWixJQUF1Qm1wRCxZQUFZbnBELE9BQVosQ0FBb0IsR0FBcEIsTUFBNkIsQ0FBeEQsRUFBMkQ7QUFDekRtcEQsZ0NBQWMsTUFBTTlDLGFBQWE4QyxXQUFiLEVBQTBCLzJDLFVBQTFCLENBQXBCO0FBQ0Q7QUFDRDR6Qyx3QkFBUW9ELFdBQVIsQ0FBb0IsbUJBQVFELFdBQVIsQ0FBcEI7QUFDQW5ELHdCQUFRcUQsVUFBUixDQUFtQnZGLFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixjQUF6QixFQUF5Q3lELElBQXpDLEVBQStDMmlCLENBQS9DLENBQW5CO0FBQ0ExakIsc0JBQU0rbEQsUUFBTixDQUFldEQsT0FBZjtBQUNBejhCLHVCQUFPaG1CLE1BQU1pakQsT0FBTixFQUFQO0FBQ0FqakQsc0JBQU1nbUQsT0FBTixDQUFjdG1ELFNBQWQ7QUFDQU0sc0JBQU1vakQsU0FBTixDQUFnQixRQUFROXdDLEtBQXhCO0FBQ0E4eEMsMkJBQVcsSUFBWDtBQUNBQyw0QkFBWSxLQUFaO0FBQ0QsZUExRUQsTUEwRU87QUFDTEEsNEJBQVksSUFBWjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFlBQUkzakQsUUFBUSxDQUFSLElBQWEsbUJBQW1CSSxLQUFwQyxFQUEyQztBQUN6QyxZQUFFd2hELFlBQUY7QUFDQSxjQUFJMzRCLFFBQVF5NEIsUUFBUixDQUFpQnJoRCxJQUFqQixFQUF1QnRFLE9BQXZCLENBQStCdUssUUFBL0IsTUFBNEMsQ0FBQyxDQUFqRCxFQUFvRDtBQUNsRDJpQixvQkFBUXk0QixRQUFSLENBQWlCcmhELElBQWpCLEVBQXVCckUsSUFBdkIsQ0FBNEJzSyxRQUE1QjtBQUNEO0FBQ0RoSCxrQkFBUWdpRCxPQUFPTSxZQUFQLENBQVI7QUFDQSxjQUFJLENBQUN0aUQsS0FBRCxJQUFVLENBQUNBLE1BQU1nRyxRQUFOLEVBQVgsSUFBK0JoRyxNQUFNK2lELE9BQU4sRUFBL0IsSUFBa0QvaUQsTUFBTWdqRCxTQUFOLEVBQXRELEVBQXlFO0FBQ3ZFaGpELG9CQUFRZ2lELE9BQU9NLFlBQVAsSUFBdUIsSUFBSVksZUFBSixFQUEvQjtBQUNEO0FBQ0QsY0FBTStDLGVBQWUxRixTQUFTampELE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsZUFBekIsRUFBMEN5RCxJQUExQyxFQUFnRDJpQixDQUFoRCxDQUFyQjtBQUNBLGNBQU13aUMsb0JBQW9CM0YsU0FBU2pqRCxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLHFCQUF6QixFQUFnRHlELElBQWhELEVBQXNEMmlCLENBQXRELENBQTFCO0FBQ0EsY0FBTXlpQyxjQUFjNUYsU0FBU2pqRCxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLGNBQXpCLEVBQXlDeUQsSUFBekMsRUFBK0MyaUIsQ0FBL0MsQ0FBcEI7QUFDQSxjQUFNMGlDLGdCQUFnQjdGLFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixnQkFBekIsRUFBMkN5RCxJQUEzQyxFQUFpRDJpQixDQUFqRCxDQUF0QjtBQUNBLGNBQU0yaUMsb0JBQW9COUYsU0FBU2pqRCxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLHFCQUF6QixFQUFnRHlELElBQWhELEVBQXNEMmlCLENBQXRELENBQTFCO0FBQ0EsY0FBTTRpQyxzQkFBc0IvRixTQUFTampELE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsdUJBQXpCLEVBQWtEeUQsSUFBbEQsRUFBd0QyaUIsQ0FBeEQsQ0FBNUI7QUFDQSxjQUFNNmlDLFlBQVlOLGVBQWUsR0FBZixHQUFxQkMsaUJBQXJCLEdBQXlDLEdBQXpDLEdBQ2hCQyxXQURnQixHQUNGLEdBREUsR0FDSUMsYUFESixHQUNvQixHQURwQixHQUMwQkMsaUJBRDFCLEdBQzhDLEdBRDlDLEdBQ29EQyxtQkFEdEU7QUFFQTdELG9CQUFVVixlQUFld0UsU0FBZixDQUFWO0FBQ0EsY0FBSSxDQUFDOUQsT0FBTCxFQUFjO0FBQ1pBLHNCQUFVLElBQUkrRCxnQkFBSixDQUFXO0FBQ25CQyxzQkFBUVIsWUFEVztBQUVuQnRELHNCQUFRMEQsc0JBQXNCLENBQXRCLEdBQTBCM21ELFNBQTFCLEdBQXNDLElBQUlva0QsZ0JBQUosQ0FBVztBQUN2RHozQyx1QkFBT2c2QyxpQkFEZ0Q7QUFFdkRsK0MsdUJBQU8wN0MsaUJBQWlCcUMsaUJBQWpCLEVBQW9DSSxtQkFBcEM7QUFGZ0QsZUFBWCxDQUYzQjtBQU1uQi83QyxvQkFBTSxJQUFJNDRDLGNBQUosQ0FBUztBQUNiaDdDLHVCQUFPMDdDLGlCQUFpQnNDLFdBQWpCLEVBQThCQyxhQUE5QjtBQURNLGVBQVQ7QUFOYSxhQUFYLENBQVY7QUFVRDtBQUNEcG1ELGdCQUFNK2xELFFBQU4sQ0FBZXRELE9BQWY7QUFDQXo4QixpQkFBT2htQixNQUFNaWpELE9BQU4sRUFBUDtBQUNBampELGdCQUFNZ21ELE9BQU4sQ0FBY3RtRCxTQUFkO0FBQ0FNLGdCQUFNMGtELFdBQU4sQ0FBa0JobEQsU0FBbEI7QUFDQU0sZ0JBQU1vakQsU0FBTixDQUFnQixRQUFROXdDLEtBQXhCO0FBQ0E4eEMscUJBQVcsSUFBWDtBQUNEOztBQUVELFlBQUlqeUIsY0FBSjtBQUNBLFlBQUksZ0JBQWdCNTBCLE1BQXBCLEVBQTRCO0FBQzFCLGNBQU1tcEQsWUFBWW5HLFNBQVNqakQsTUFBVCxFQUFnQixRQUFoQixFQUEwQixZQUExQixFQUF3Q3lELElBQXhDLEVBQThDMmlCLENBQTlDLENBQWxCO0FBQ0F5TyxrQkFBUTJ3QixhQUFhNEQsU0FBYixFQUF3QjczQyxVQUF4QixDQUFSO0FBQ0Q7QUFDRCxZQUFJc2pCLFNBQVMsQ0FBQ2t5QixTQUFkLEVBQXlCO0FBQ3ZCLGNBQUksQ0FBQ0QsUUFBTCxFQUFlO0FBQ2IsY0FBRTlCLFlBQUY7QUFDQSxnQkFBSTM0QixRQUFReTRCLFFBQVIsQ0FBaUJyaEQsSUFBakIsRUFBdUJ0RSxPQUF2QixDQUErQnVLLFFBQS9CLE1BQTRDLENBQUMsQ0FBakQsRUFBb0Q7QUFDbEQyaUIsc0JBQVF5NEIsUUFBUixDQUFpQnJoRCxJQUFqQixFQUF1QnJFLElBQXZCLENBQTRCc0ssUUFBNUI7QUFDRDtBQUNEaEgsb0JBQVFnaUQsT0FBT00sWUFBUCxDQUFSO0FBQ0EsZ0JBQUksQ0FBQ3RpRCxLQUFELElBQVUsQ0FBQ0EsTUFBTWlqRCxPQUFOLEVBQVgsSUFBOEJqakQsTUFBTStpRCxPQUFOLEVBQTlCLElBQWlEL2lELE1BQU1nakQsU0FBTixFQUFyRCxFQUF3RTtBQUN0RWhqRCxzQkFBUWdpRCxPQUFPTSxZQUFQLElBQXVCLElBQUlZLGVBQUosRUFBL0I7QUFDRDtBQUNEbGpELGtCQUFNK2xELFFBQU4sQ0FBZXJtRCxTQUFmO0FBQ0FNLGtCQUFNMGtELFdBQU4sQ0FBa0JobEQsU0FBbEI7QUFDRDtBQUNELGNBQUksQ0FBQ00sTUFBTWlqRCxPQUFOLEVBQUwsRUFBc0I7QUFDcEJqakQsa0JBQU1nbUQsT0FBTixDQUFjaGdDLFFBQVEsSUFBSTJnQyxjQUFKLEVBQXRCO0FBQ0Q7QUFDRDNnQyxpQkFBT2htQixNQUFNaWpELE9BQU4sRUFBUDtBQUNBLGNBQU0yRCxXQUFXckcsU0FBU2pqRCxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLFdBQTFCLEVBQXVDeUQsSUFBdkMsRUFBNkMyaUIsQ0FBN0MsQ0FBakI7QUFDQSxjQUFNbWpDLGlCQUFpQnRHLFNBQVNqakQsTUFBVCxFQUFnQixRQUFoQixFQUEwQixrQkFBMUIsRUFBOEN5RCxJQUE5QyxFQUFvRDJpQixDQUFwRCxDQUF2QjtBQUNBLGNBQU1ybkIsT0FBTywrQkFBT3lxRCxXQUFXdkcsU0FBU2pqRCxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLFdBQTFCLEVBQXVDeUQsSUFBdkMsRUFBNkMyaUIsQ0FBN0MsQ0FBWCxDQUFQLEVBQW9Fa2pDLFFBQXBFLENBQWI7QUFDQSxjQUFNRyxnQkFBZ0J4cEQsT0FBTyxnQkFBUCxDQUF0QjtBQUNBLGNBQUl3cEQsaUJBQWlCLFdBQXJCLEVBQWtDO0FBQ2hDNTBCLG9CQUFRQSxNQUFNOEksV0FBTixFQUFSO0FBQ0QsV0FGRCxNQUVPLElBQUk4ckIsaUJBQWlCLFdBQXJCLEVBQWtDO0FBQ3ZDNTBCLG9CQUFRQSxNQUFNbGEsV0FBTixFQUFSO0FBQ0Q7QUFDRCxjQUFNK3VDLGVBQWV0bUQsUUFBUSxDQUFSLEdBQVl5eEIsS0FBWixHQUFvQjh1QixTQUFTOXVCLEtBQVQsRUFBZ0I5MUIsSUFBaEIsRUFBc0Jra0QsU0FBU2pqRCxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLGdCQUExQixFQUE0Q3lELElBQTVDLEVBQWtEMmlCLENBQWxELENBQXRCLENBQXpDO0FBQ0FzQyxlQUFLZ2dDLE9BQUwsQ0FBYWdCLFlBQWI7QUFDQWhoQyxlQUFLaWhDLE9BQUwsQ0FBYTVxRCxJQUFiO0FBQ0EycEIsZUFBSzYvQixXQUFMLENBQWlCLG1CQUFRdEYsU0FBU2pqRCxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLGFBQTFCLEVBQXlDeUQsSUFBekMsRUFBK0MyaUIsQ0FBL0MsQ0FBUixDQUFqQjtBQUNBLGNBQU13akMsYUFBYTNHLFNBQVNqakQsTUFBVCxFQUFnQixRQUFoQixFQUEwQixhQUExQixFQUF5Q3lELElBQXpDLEVBQStDMmlCLENBQS9DLENBQW5CO0FBQ0EsY0FBTXlqQyxZQUFhL0MsWUFBWTFqRCxRQUFRLENBQXJCLEdBQTBCLE9BQTFCLEdBQW9DNi9DLFNBQVNqakQsTUFBVCxFQUFnQixRQUFoQixFQUEwQixrQkFBMUIsRUFBOEN5RCxJQUE5QyxFQUFvRDJpQixDQUFwRCxDQUF0RDtBQUNBc0MsZUFBS29oQyxZQUFMLENBQWtCRCxTQUFsQjtBQUNBLGNBQUlFLGdCQUFnQjlHLFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixpQkFBekIsRUFBNEN5RCxJQUE1QyxFQUFrRDJpQixDQUFsRCxDQUFwQjtBQUNBLGNBQU00akMsYUFBYS9HLFNBQVNqakQsTUFBVCxFQUFnQixRQUFoQixFQUEwQixhQUExQixFQUF5Q3lELElBQXpDLEVBQStDMmlCLENBQS9DLENBQW5CO0FBQ0EsY0FBTTZqQyxnQkFBZ0JoSCxTQUFTampELE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsZ0JBQXpCLEVBQTJDeUQsSUFBM0MsRUFBaUQyaUIsQ0FBakQsQ0FBdEI7QUFDQSxjQUFJOGpDLFVBQVUsQ0FBZDtBQUNBLGNBQUlDLFVBQVUsQ0FBZDtBQUNBLGNBQUlDLFlBQVksUUFBaEI7QUFDQSxjQUFJUixXQUFXenFELE9BQVgsQ0FBbUIsTUFBbkIsTUFBK0IsQ0FBQyxDQUFwQyxFQUF1QztBQUNyQ2lyRCx3QkFBWSxNQUFaO0FBQ0FELHNCQUFVSixhQUFWO0FBQ0QsV0FIRCxNQUdPLElBQUlILFdBQVd6cUQsT0FBWCxDQUFtQixPQUFuQixNQUFnQyxDQUFDLENBQXJDLEVBQXdDO0FBQzdDaXJELHdCQUFZLE9BQVo7QUFDQUQsc0JBQVUsQ0FBQ0osYUFBWDtBQUNEO0FBQ0QsY0FBSUYsYUFBYSxPQUFqQixFQUEwQjtBQUN4Qm5oQyxpQkFBSzJoQyxZQUFMLENBQWtCRCxTQUFsQjtBQUNELFdBRkQsTUFFTztBQUNMMWhDLGlCQUFLNGhDLFdBQUwsQ0FBaUIsbUJBQVFySCxTQUFTampELE1BQVQsRUFBZ0IsUUFBaEIsRUFBMEIsZ0JBQTFCLEVBQTRDeUQsSUFBNUMsRUFBa0QyaUIsQ0FBbEQsQ0FBUixJQUFnRXlPLE1BQU1wMkIsTUFBdEUsR0FBK0VpckQsYUFBYWpyRCxNQUE3RztBQUNBaXFCLGlCQUFLMmhDLFlBQUw7QUFDRDtBQUNELGNBQUlFLGVBQWUsUUFBbkI7QUFDQSxjQUFJWCxXQUFXenFELE9BQVgsQ0FBbUIsUUFBbkIsS0FBZ0MsQ0FBcEMsRUFBdUM7QUFDckNvckQsMkJBQWUsUUFBZjtBQUNBTCxzQkFBVSxDQUFDSCxhQUFELEdBQWtCLE9BQU9SLGlCQUFpQixDQUF4QixDQUFELEdBQStCRCxRQUExRDtBQUNELFdBSEQsTUFHTyxJQUFJTSxXQUFXenFELE9BQVgsQ0FBbUIsS0FBbkIsS0FBNkIsQ0FBakMsRUFBb0M7QUFDekNvckQsMkJBQWUsS0FBZjtBQUNBTCxzQkFBVUgsZ0JBQWlCLE9BQU9SLGlCQUFpQixDQUF4QixDQUFELEdBQStCRCxRQUF6RDtBQUNEO0FBQ0Q1Z0MsZUFBSzhoQyxlQUFMLENBQXFCRCxZQUFyQjtBQUNBN2hDLGVBQUsraEMsVUFBTCxDQUFnQlQsV0FBVyxDQUFYLElBQWdCVixRQUFoQixHQUEyQmEsT0FBM0IsR0FBcUNGLGNBQWMsQ0FBZCxDQUFyRDtBQUNBdmhDLGVBQUtnaUMsVUFBTCxDQUFnQlYsV0FBVyxDQUFYLElBQWdCVixRQUFoQixHQUEyQlksT0FBM0IsR0FBcUNELGNBQWMsQ0FBZCxDQUFyRDtBQUNBbG1ELG9CQUFVay9DLFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixjQUF6QixFQUF5Q3lELElBQXpDLEVBQStDMmlCLENBQS9DLENBQVY7QUFDQSxjQUFNeUMsWUFBWSxJQUFJZzlCLGNBQUosRUFBbEI7O0FBRUFoOUIsb0JBQVV5OUIsUUFBVixDQUFtQkMsaUJBQWlCdEQsU0FBU2pqRCxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLFlBQXpCLEVBQXVDeUQsSUFBdkMsRUFBNkMyaUIsQ0FBN0MsQ0FBakIsRUFBa0VyaUIsT0FBbEUsQ0FBbkI7QUFDQTJrQixlQUFLaWlDLE9BQUwsQ0FBYTloQyxTQUFiO0FBQ0EsY0FBTStoQyxZQUFZckUsaUJBQWlCdEQsU0FBU2pqRCxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLGlCQUF6QixFQUE0Q3lELElBQTVDLEVBQWtEMmlCLENBQWxELENBQWpCLEVBQXVFcmlCLE9BQXZFLENBQWxCO0FBQ0EsY0FBSTZtRCxTQUFKLEVBQWU7QUFDYixnQkFBTUMsV0FBVyxJQUFJckUsZ0JBQUosRUFBakI7QUFDQXFFLHFCQUFTdkUsUUFBVCxDQUFrQnNFLFNBQWxCO0FBQ0FDLHFCQUFTcEUsUUFBVCxDQUFrQnhELFNBQVNqakQsTUFBVCxFQUFnQixPQUFoQixFQUF5QixpQkFBekIsRUFBNEN5RCxJQUE1QyxFQUFrRDJpQixDQUFsRCxDQUFsQjtBQUNBc0MsaUJBQUtvaUMsU0FBTCxDQUFlRCxRQUFmO0FBQ0QsV0FMRCxNQUtPO0FBQ0xuaUMsaUJBQUtvaUMsU0FBTCxDQUFlMW9ELFNBQWY7QUFDRDtBQUNETSxnQkFBTW9qRCxTQUFOLENBQWdCLFFBQVE5d0MsS0FBeEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsUUFBSWd3QyxlQUFlLENBQUMsQ0FBcEIsRUFBdUI7QUFDckJOLGFBQU9qbUQsTUFBUCxHQUFnQnVtRCxlQUFlLENBQS9CO0FBQ0EsYUFBT04sTUFBUDtBQUNEO0FBQ0YsR0FoWUQ7O0FBa1lBeEIsVUFBUXZnRCxRQUFSLENBQWlCMnlDLGFBQWpCO0FBQ0E0TixVQUFRaDZDLEdBQVIsQ0FBWSxlQUFaLEVBQTZCbTdDLFlBQTdCO0FBQ0FuQixVQUFRaDZDLEdBQVIsQ0FBWSxlQUFaLEVBQTZCazdDLFlBQTdCO0FBQ0EsU0FBTzlPLGFBQVA7QUFDRCxDOztBQXJyQkQ7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFPQTs7OztBQUNBOzs7O0FBTUEsSUFBTXR5QixhQUFhM00sNEJBQUcyTSxVQUF0QixDLENBM0JBOzs7Ozs7QUE0QkEsSUFBTWdmLGtCQUFrQjNyQiw0QkFBRzJyQixlQUEzQjtBQUNBLElBQU14QixlQUFlenlCLDhCQUFXeXlCLFlBQWhDO0FBQ0EsSUFBTVEsMkJBQTJCanpCLDhCQUFXaXpCLHdCQUE1Qzs7QUFFQSxJQUFNelcsUUFBUTtBQUNaLFdBQVMsQ0FERztBQUVaLGdCQUFjLENBRkY7QUFHWixnQkFBYyxDQUhGO0FBSVoscUJBQW1CLENBSlA7QUFLWixhQUFXLENBTEM7QUFNWixrQkFBZ0I7QUFOSixDQUFkO0FBUUEsSUFBTXdnQyxpQkFBaUIsU0FBakJBLGNBQWlCLENBQVNDLGFBQVQsRUFBd0Ixc0IsWUFBeEIsRUFBc0M7QUFDM0QsTUFBTTJzQixxQkFBcUJqcUIseUJBQXlCZ3FCLGFBQXpCLEVBQXdDMXNCLFlBQXhDLENBQTNCO0FBQ0EsTUFBSTJzQixtQkFBbUJyMUMsTUFBbkIsS0FBOEIsT0FBbEMsRUFBMkM7QUFDekMsVUFBTSxJQUFJelUsS0FBSixDQUFVOHBELG1CQUFtQjNnRCxLQUFuQixDQUF5QnhMLEdBQXpCLENBQTZCO0FBQUEsYUFBVXlELElBQUlrRixHQUFkLFVBQXNCbEYsSUFBSTRoQixPQUExQjtBQUFBLEtBQTdCLEVBQWtFM2EsSUFBbEUsQ0FBdUUsSUFBdkUsQ0FBVixDQUFOO0FBQ0Q7QUFDRCxTQUFPeWhELG1CQUFtQjNnRCxLQUExQjtBQUNELENBTkQ7O0FBUUEsSUFBTTQ2QyxXQUFXLEVBQWpCO0FBQ0EsSUFBTWdHLFVBQVUsRUFBQ3puRCxNQUFNLENBQVAsRUFBaEI7QUFDQSxJQUFNOGdELGdCQUFnQixFQUF0Qjs7QUFFQTs7Ozs7Ozs7O0FBU08sU0FBU3RCLFFBQVQsQ0FBa0JqakQsS0FBbEIsRUFBeUJtckQsYUFBekIsRUFBd0MxM0MsUUFBeEMsRUFBa0RoUSxJQUFsRCxFQUF3RDRvQixPQUF4RCxFQUFpRTtBQUN0RSxNQUFNM2lCLFVBQVUxSixNQUFNK0MsRUFBdEI7QUFDQSxNQUFJLENBQUN3aEQsY0FBYzc2QyxPQUFkLENBQUwsRUFBNkI7QUFDM0I2NkMsa0JBQWM3NkMsT0FBZCxJQUF5QixFQUF6QjtBQUNEO0FBQ0QsTUFBTTBoRCxZQUFZN0csY0FBYzc2QyxPQUFkLENBQWxCO0FBQ0EsTUFBSSxDQUFDMGhELFVBQVUzM0MsUUFBVixDQUFMLEVBQTBCO0FBQ3hCLFFBQUluSixRQUFRLENBQUN0SyxNQUFNbXJELGFBQU4sS0FBd0JqRyxRQUF6QixFQUFtQ3p4QyxRQUFuQyxDQUFaO0FBQ0EsUUFBTTZxQixlQUFlUiwwQkFBUXF0QixhQUFSLFNBQXlCbnJELE1BQU1vRCxJQUEvQixFQUF1Q3FRLFFBQXZDLENBQXJCO0FBQ0EsUUFBSW5KLFVBQVVsSSxTQUFkLEVBQXlCO0FBQ3ZCa0ksY0FBUWcwQixhQUFhSyxPQUFyQjtBQUNEO0FBQ0QsUUFBSTBzQixTQUFTN3FCLGFBQWNsMkIsS0FBZCxDQUFiO0FBQ0EsUUFBSSxDQUFDK2dELE1BQUQsSUFBV3JvQyxXQUFXMVksS0FBWCxDQUFmLEVBQWtDO0FBQ2hDQSxjQUFRMDNCLGdCQUFnQjEzQixLQUFoQixFQUF1QmcwQixZQUF2QixDQUFSO0FBQ0Erc0IsZUFBUyxJQUFUO0FBQ0Q7QUFDRCxRQUFJQSxNQUFKLEVBQVk7QUFDVixVQUFNSixxQkFBcUJGLGVBQWV6Z0QsS0FBZixFQUFzQmcwQixZQUF0QixDQUEzQjtBQUNBOHNCLGdCQUFVMzNDLFFBQVYsSUFBc0J3M0MsbUJBQW1COWdDLFFBQW5CLENBQTRCcVYsSUFBNUIsQ0FBaUN5ckIsa0JBQWpDLENBQXRCO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsVUFBSTNzQixhQUFhbDdCLElBQWIsSUFBcUIsT0FBekIsRUFBa0M7QUFDaENrSCxnQkFBUXpHLHlCQUFNNUMsS0FBTixDQUFZcUosS0FBWixDQUFSO0FBQ0Q7QUFDRDhnRCxnQkFBVTMzQyxRQUFWLElBQXNCLFlBQVc7QUFDL0IsZUFBT25KLEtBQVA7QUFDRCxPQUZEO0FBR0Q7QUFDRjtBQUNENGdELFVBQVF6bkQsSUFBUixHQUFlQSxJQUFmO0FBQ0EsU0FBTzJuRCxVQUFVMzNDLFFBQVYsRUFBb0J5M0MsT0FBcEIsRUFBNkI3K0IsT0FBN0IsQ0FBUDtBQUNEOztBQUVELFNBQVNzN0IsZ0JBQVQsQ0FBMEJFLFVBQTFCLEVBQXNDO0FBQ3BDLE1BQUlELGVBQWUsQ0FBQyxHQUFELEVBQU0sR0FBTixDQUFuQjtBQUNBLE1BQUksQ0FBQyxVQUFELEVBQWEsV0FBYixFQUEwQixhQUExQixFQUF5QyxjQUF6QyxFQUF5RHpNLFFBQXpELENBQWtFME0sVUFBbEUsQ0FBSixFQUFtRjtBQUNqRkQsbUJBQWUsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFmO0FBQ0Q7QUFDRCxNQUFJQyxlQUFlLE1BQW5CLEVBQTJCO0FBQ3pCQSxpQkFBYSxVQUFiO0FBQ0FELG1CQUFlLENBQUMsQ0FBRCxFQUFJLEdBQUosQ0FBZjtBQUNEO0FBQ0QsTUFBSUMsZUFBZSxPQUFuQixFQUE0QjtBQUMxQkEsaUJBQWEsVUFBYjtBQUNBRCxtQkFBZSxDQUFDLENBQUQsRUFBSSxHQUFKLENBQWY7QUFDRDtBQUNELE1BQUlDLGVBQWUsUUFBbkIsRUFBNkI7QUFDM0JBLGlCQUFhLFVBQWI7QUFDQUQsbUJBQWUsQ0FBQyxHQUFELEVBQU0sQ0FBTixDQUFmO0FBQ0Q7QUFDRCxNQUFJQyxlQUFlLEtBQW5CLEVBQTBCO0FBQ3hCQSxpQkFBYSxVQUFiO0FBQ0FELG1CQUFlLENBQUMsR0FBRCxFQUFNLENBQU4sQ0FBZjtBQUNEO0FBQ0Q7QUFDQSxTQUFPO0FBQ0xBLGtCQUFjQSxZQURUO0FBRUxDLGdCQUFZQTtBQUZQLEdBQVA7QUFJRDs7QUFFRCxJQUFNeUQsVUFBVSxFQUFoQjs7QUFFQSxTQUFTOUIsVUFBVCxDQUFvQnJyRCxLQUFwQixFQUEyQkYsY0FBM0IsRUFBMkM7QUFDekMsTUFBSXF0RCxRQUFRbnRELEtBQVIsQ0FBSixFQUFvQjtBQUNsQixXQUFPbXRELFFBQVFudEQsS0FBUixDQUFQO0FBQ0Q7QUFDRCxNQUFJRixjQUFKLEVBQW9CO0FBQ2xCLFNBQUssSUFBSUcsSUFBSSxDQUFSLEVBQVdDLEtBQUtGLE1BQU1NLE1BQTNCLEVBQW1DTCxJQUFJQyxFQUF2QyxFQUEyQyxFQUFFRCxDQUE3QyxFQUFnRDtBQUM5QyxVQUFNVyxPQUFPWixNQUFNQyxDQUFOLENBQWI7QUFDQSxVQUFJSCxlQUFla0IsT0FBZixDQUF1QkosSUFBdkIsS0FBZ0MsQ0FBQyxDQUFyQyxFQUF3QztBQUN0Q3VzRCxnQkFBUW50RCxLQUFSLElBQWlCWSxJQUFqQjtBQUNBO0FBQ0Q7QUFDRjtBQUNELFFBQUksQ0FBQ3VzRCxRQUFRbnRELEtBQVIsQ0FBTCxFQUFxQjtBQUNuQjtBQUNBbXRELGNBQVFudEQsS0FBUixJQUFpQkEsTUFBTUEsTUFBTU0sTUFBTixHQUFlLENBQXJCLENBQWpCO0FBQ0Q7QUFDRixHQVpELE1BWU87QUFDTDZzRCxZQUFRbnRELEtBQVIsSUFBaUJBLE1BQU0sQ0FBTixDQUFqQjtBQUNEO0FBQ0QsU0FBT210RCxRQUFRbnRELEtBQVIsQ0FBUDtBQUNEOztBQUVELElBQU1xbUQsY0FBYyxFQUFwQjs7QUFFQSxTQUFTWSxjQUFULENBQXdCMTdDLE9BQXhCLEVBQWlDaUUsTUFBakMsRUFBeUMwZSxPQUF6QyxFQUFrRDVvQixJQUFsRCxFQUF3RDtBQUN0RCxNQUFJLEVBQUVpRyxXQUFXODZDLFdBQWIsQ0FBSixFQUErQjtBQUM3QkEsZ0JBQVk5NkMsT0FBWixJQUF1QixzQ0FBYWlFLE1BQWIsRUFBcUJBLE1BQTVDO0FBQ0Q7QUFDRHU5QyxVQUFRem5ELElBQVIsR0FBZUEsSUFBZjtBQUNBLFNBQU8rZ0QsWUFBWTk2QyxPQUFaLEVBQXFCd2hELE9BQXJCLEVBQThCNytCLE9BQTlCLENBQVA7QUFDRDs7QUFHRCxTQUFTazZCLGdCQUFULENBQTBCMTdDLEtBQTFCLEVBQWlDOUcsT0FBakMsRUFBMEM7QUFDeEMsTUFBSThHLEtBQUosRUFBVztBQUNULFFBQUlBLE1BQU14QixDQUFOLEtBQVksQ0FBWixJQUFpQnRGLFlBQVksQ0FBakMsRUFBb0M7QUFDbEMsYUFBTzNCLFNBQVA7QUFDRDtBQUNELFFBQU1pSCxJQUFJd0IsTUFBTXhCLENBQWhCO0FBQ0F0RixjQUFVQSxZQUFZM0IsU0FBWixHQUF3QixDQUF4QixHQUE0QjJCLE9BQXRDO0FBQ0EsV0FBTyxVQUFVNFQsS0FBS3JKLEtBQUwsQ0FBV3pELE1BQU0zSSxDQUFOLEdBQVUsR0FBVixHQUFnQm1ILENBQTNCLENBQVYsR0FBMEMsR0FBMUMsR0FBZ0RzTyxLQUFLckosS0FBTCxDQUFXekQsTUFBTXljLENBQU4sR0FBVSxHQUFWLEdBQWdCamUsQ0FBM0IsQ0FBaEQsR0FDTCxHQURLLEdBQ0NzTyxLQUFLckosS0FBTCxDQUFXekQsTUFBTTBjLENBQU4sR0FBVSxHQUFWLEdBQWdCbGUsQ0FBM0IsQ0FERCxHQUNpQyxHQURqQyxHQUN3Q0EsSUFBSXRGLE9BRDVDLEdBQ3VELEdBRDlEO0FBRUQ7QUFDRCxTQUFPOEcsS0FBUDtBQUNEOztBQUVELElBQU0wZ0QsZ0JBQWdCLHdCQUF0Qjs7QUFFQSxTQUFTL0YsWUFBVCxDQUFzQjk4QixJQUF0QixFQUE0Qm5YLFVBQTVCLEVBQXdDO0FBQ3RDLE1BQUkvUSxjQUFKO0FBQ0EsS0FBRztBQUNEQSxZQUFRa29CLEtBQUtqb0IsS0FBTCxDQUFXOHFELGFBQVgsQ0FBUjtBQUNBLFFBQUkvcUQsS0FBSixFQUFXO0FBQ1QsVUFBTThKLFFBQVFpSCxXQUFXL1EsTUFBTSxDQUFOLENBQVgsS0FBd0IsRUFBdEM7QUFDQWtvQixhQUFPbG9CLE1BQU0sQ0FBTixJQUFXOEosS0FBWCxHQUFtQjlKLE1BQU0sQ0FBTixDQUExQjtBQUNEO0FBQ0YsR0FORCxRQU1TQSxLQU5UO0FBT0EsU0FBT2tvQixJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDeExnQm9PLE8sR0FBQUEsTztRQUlBMDBCLG9CLEdBQUFBLG9CO0FBSlQsU0FBUzEwQixPQUFULENBQWlCMjBCLE9BQWpCLEVBQTBCO0FBQy9CLFNBQU9BLFVBQVU5ekMsS0FBS2dYLEVBQWYsR0FBb0IsR0FBM0I7QUFDRDs7QUFFTSxTQUFTNjhCLG9CQUFULENBQThCNUcsVUFBOUIsRUFBMENoa0QsV0FBMUMsRUFBdUQ7QUFDNUQsTUFBSXhDLElBQUksQ0FBUjtBQUNBLE1BQU1DLEtBQUt1QyxZQUFZbkMsTUFBdkI7QUFDQSxTQUFPTCxJQUFJQyxFQUFYLEVBQWUsRUFBRUQsQ0FBakIsRUFBb0I7QUFDbEIsUUFBTXN0RCxZQUFZOXFELFlBQVl4QyxDQUFaLENBQWxCO0FBQ0EsUUFBSXN0RCxZQUFZOUcsVUFBWixJQUEwQnhtRCxJQUFJLENBQUosR0FBUUMsRUFBdEMsRUFBMEM7QUFDeEMsVUFBTXN0RCxhQUFhL3FELFlBQVl4QyxDQUFaLElBQWlCd0MsWUFBWXhDLElBQUksQ0FBaEIsQ0FBcEM7QUFDQSxhQUFPQSxJQUFJdVosS0FBS2lYLEdBQUwsQ0FBU2h1QixZQUFZeEMsQ0FBWixJQUFpQndtRCxVQUExQixJQUF3Q2p0QyxLQUFLaVgsR0FBTCxDQUFTKzhCLFVBQVQsQ0FBbkQ7QUFDRDtBQUNGO0FBQ0QsU0FBT3R0RCxLQUFLLENBQVo7QUFDRCxDOzs7Ozs7Ozs7OztBQ2ZELHdCOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLG1DOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLHFDOzs7Ozs7Ozs7OztBQ0FBLHlCOzs7Ozs7Ozs7OztBQ0FBLG9DOzs7Ozs7Ozs7OztBQ0FBLGtDOzs7Ozs7Ozs7OztBQ0FBLHNDOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLGdDOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLDZCIiwiZmlsZSI6Im9sbXMtZGVidWcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL29sbXMuanNcIik7XG4iLCIvKlxyXG5vbC1tYXBib3gtc3R5bGUgLSBVc2UgTWFwYm94IFN0eWxlIG9iamVjdHMgd2l0aCBPcGVuTGF5ZXJzXHJcbkNvcHlyaWdodCAyMDE2LXByZXNlbnQgQm91bmRsZXNzIFNwYXRpYWwsIEluYy5cclxuTGljZW5zZTogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2JvdW5kbGVzc2dlby9vbC1tYXBib3gtZ2wtc3R5bGUvbWFzdGVyL0xJQ0VOU0VcclxuKi9cclxuXHJcbmltcG9ydCB7Q29sb3J9IGZyb20gJ0BtYXBib3gvbWFwYm94LWdsLXN0eWxlLXNwZWMnO1xyXG5pbXBvcnQgbWIyY3NzIGZyb20gJ21hcGJveC10by1jc3MtZm9udCc7XHJcbmltcG9ydCBhcHBseVN0eWxlRnVuY3Rpb24sIHtnZXRWYWx1ZX0gZnJvbSAnLi9zdHlsZWZ1bmN0aW9uJztcclxuaW1wb3J0IGdvb2dsZUZvbnRzIGZyb20gJ3dlYmZvbnQtbWF0Y2hlci9saWIvZm9udHMvZ29vZ2xlJztcclxuaW1wb3J0IHtmcm9tTG9uTGF0fSBmcm9tICdvbC9wcm9qJztcclxuaW1wb3J0IHtjcmVhdGVYWVp9IGZyb20gJ29sL3RpbGVncmlkJztcclxuaW1wb3J0IE1hcCBmcm9tICdvbC9NYXAnO1xyXG5pbXBvcnQgR2VvSlNPTiBmcm9tICdvbC9mb3JtYXQvR2VvSlNPTic7XHJcbmltcG9ydCBNVlQgZnJvbSAnb2wvZm9ybWF0L01WVCc7XHJcbmltcG9ydCB7dW5CeUtleX0gZnJvbSAnb2wvT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCBUaWxlTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVGlsZSc7XHJcbmltcG9ydCBWZWN0b3JMYXllciBmcm9tICdvbC9sYXllci9WZWN0b3InO1xyXG5pbXBvcnQgVmVjdG9yVGlsZUxheWVyIGZyb20gJ29sL2xheWVyL1ZlY3RvclRpbGUnO1xyXG5pbXBvcnQgVGlsZUpTT04gZnJvbSAnb2wvc291cmNlL1RpbGVKU09OJztcclxuaW1wb3J0IFZlY3RvclNvdXJjZSBmcm9tICdvbC9zb3VyY2UvVmVjdG9yJztcclxuaW1wb3J0IFZlY3RvclRpbGVTb3VyY2UgZnJvbSAnb2wvc291cmNlL1ZlY3RvclRpbGUnO1xyXG5pbXBvcnQgWFlaIGZyb20gJ29sL3NvdXJjZS9YWVonO1xyXG5cclxudmFyIGF2YWlsYWJsZUZvbnRzO1xyXG5cclxuZnVuY3Rpb24gbG9hZEZvbnQoZm9udHMpIHtcclxuICB2YXIgaSwgaWk7XHJcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZvbnRzKSkge1xyXG4gICAgdmFyIHN0b3BzID0gZm9udHMuc3RvcHM7XHJcbiAgICBpZiAoc3RvcHMpIHtcclxuICAgICAgZm9yIChpID0gMCwgaWkgPSBzdG9wcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICAgICAgbG9hZEZvbnQoc3RvcHNbaV1bMV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBnb29nbGVGYW1pbGllcyA9IGdvb2dsZUZvbnRzLmdldE5hbWVzKCk7XHJcbiAgdmFyIGZhbWlsaWVzID0gZm9udHMubWFwKGZ1bmN0aW9uKGZvbnQpIHtcclxuICAgIHJldHVybiBtYjJjc3MoZm9udCwgMSkuc3BsaXQoJyAxcHggJylbMV0ucmVwbGFjZSgvXCIvZywgJycpO1xyXG4gIH0pO1xyXG4gIGZvciAoaSA9IDAsIGlpID0gZmFtaWxpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgdmFyIGZhbWlseSA9IGZhbWlsaWVzW2ldO1xyXG4gICAgdmFyIGZvbnQgPSBmb250c1tpXTtcclxuICAgIGlmIChnb29nbGVGYW1pbGllcy5pbmRleE9mKGZhbWlseSkgIT09IC0xKSB7XHJcbiAgICAgIGlmICghYXZhaWxhYmxlRm9udHMpIHtcclxuICAgICAgICBhdmFpbGFibGVGb250cyA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhdmFpbGFibGVGb250cy5pbmRleE9mKGZvbnQpID09IC0xKSB7XHJcbiAgICAgICAgYXZhaWxhYmxlRm9udHMucHVzaChmb250KTtcclxuICAgICAgICB2YXIgZm9udFVybCA9ICdodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9JyArIGZhbWlseS5yZXBsYWNlKC8gL2csICcrJyk7XHJcbiAgICAgICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsaW5rW2hyZWY9XCInICsgZm9udFVybCArICdcIl0nKSkge1xyXG4gICAgICAgICAgdmFyIG1hcmt1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcclxuICAgICAgICAgIG1hcmt1cC5ocmVmID0gZm9udFVybDtcclxuICAgICAgICAgIG1hcmt1cC5yZWwgPSAnc3R5bGVzaGVldCc7XHJcbiAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKG1hcmt1cCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIGRlZmF1bHRGb250ID0gWydPcGVuIFNhbnMgUmVndWxhcicsICdBcmlhbCBSZWd1bGFyJ107XHJcblxyXG5mdW5jdGlvbiBwcmVwcm9jZXNzKGxheWVyKSB7XHJcbiAgaWYgKCdsYXlvdXQnIGluIGxheWVyICYmICd0ZXh0LWZpZWxkJyBpbiBsYXllci5sYXlvdXQpIHtcclxuICAgIGxvYWRGb250KGxheWVyLmxheW91dFsndGV4dC1mb250J10gfHwgZGVmYXVsdEZvbnQpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIHNwcml0ZVJlZ0V4ID0gL14oLiopKFxcPy4qKSQvO1xyXG5cclxuZnVuY3Rpb24gd2l0aFBhdGgodXJsLCBwYXRoKSB7XHJcbiAgaWYgKHBhdGggJiYgdXJsLmluZGV4T2YoJ2h0dHAnKSAhPSAwKSB7XHJcbiAgICB1cmwgPSBwYXRoICsgdXJsO1xyXG4gIH1cclxuICByZXR1cm4gdXJsO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b1Nwcml0ZVVybCh1cmwsIHBhdGgsIGV4dGVuc2lvbikge1xyXG4gIHVybCA9IHdpdGhQYXRoKHVybCwgcGF0aCk7XHJcbiAgdmFyIHBhcnRzID0gdXJsLm1hdGNoKHNwcml0ZVJlZ0V4KTtcclxuICByZXR1cm4gcGFydHMgP1xyXG4gICAgcGFydHNbMV0gKyBleHRlbnNpb24gKyAocGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzJdIDogJycpIDpcclxuICAgIHVybCArIGV4dGVuc2lvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBzdHlsZSBmdW5jdGlvbiB0byBhbiBgb2wubGF5ZXIuVmVjdG9yVGlsZWAgb3IgYG9sLmxheWVyLlZlY3RvcmBcclxuICogd2l0aCBhbiBgb2wuc291cmNlLlZlY3RvclRpbGVgIG9yIGFuIGBvbC5zb3VyY2UuVmVjdG9yYC4gVGhlIHN0eWxlIGZ1bmN0aW9uXHJcbiAqIHdpbGwgcmVuZGVyIGFsbCBsYXllcnMgZnJvbSB0aGUgYGdsU3R5bGVgIG9iamVjdCB0aGF0IHVzZSB0aGUgc3BlY2lmaWVkXHJcbiAqIGBzb3VyY2VgLCBvciBhIHN1YnNldCBvZiBsYXllcnMgZnJvbSB0aGUgc2FtZSBzb3VyY2UuIFRoZSBzb3VyY2UgbmVlZHMgdG8gYmVcclxuICogYSBgXCJ0eXBlXCI6IFwidmVjdG9yXCJgLCBgXCJ0eXBlXCI6IFwiZ2VvanNvblwiYCBvciBgXCJ0eXBlXCI6IFwicmFzdGVyXCJgIHNvdXJjZS5cclxuICpcclxuICogQHBhcmFtIHtvbC5sYXllci5WZWN0b3JUaWxlfSBsYXllciBPcGVuTGF5ZXJzIGxheWVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGdsU3R5bGUgTWFwYm94IFN0eWxlIG9iamVjdC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBgc291cmNlYCBrZXkgb3IgYW4gYXJyYXkgb2YgbGF5ZXIgYGlkYHMgZnJvbSB0aGVcclxuICogTWFwYm94IFN0eWxlIG9iamVjdC4gV2hlbiBhIGBzb3VyY2VgIGtleSBpcyBwcm92aWRlZCwgYWxsIGxheWVycyBmb3IgdGhlXHJcbiAqIHNwZWNpZmllZCBzb3VyY2Ugd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgc3R5bGUgZnVuY3Rpb24uIFdoZW4gbGF5ZXIgYGlkYHNcclxuICogYXJlIHByb3ZpZGVkLCB0aGV5IG11c3QgYmUgZnJvbSBsYXllcnMgdGhhdCB1c2UgdGhlIHNhbWUgc291cmNlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhdGg9dW5kZWZpbmVkXSBQYXRoIG9mIHRoZSBzdHlsZSBmaWxlLiBPbmx5IHJlcXVpcmVkIHdoZW5cclxuICogYSByZWxhdGl2ZSBwYXRoIGlzIHVzZWQgd2l0aCB0aGUgYFwic3ByaXRlXCJgIHByb3BlcnR5IG9mIHRoZSBzdHlsZS5cclxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcmVzb2x1dGlvbnM9dW5kZWZpbmVkXSBSZXNvbHV0aW9ucyBmb3IgbWFwcGluZyByZXNvbHV0aW9uIHRvIHpvb20gbGV2ZWwuXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBzdHlsZSBjYW4gYmUgdXNlZFxyXG4gKiBmb3IgcmVuZGVyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3R5bGUobGF5ZXIsIGdsU3R5bGUsIHNvdXJjZSwgcGF0aCwgcmVzb2x1dGlvbnMpIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBnbFN0eWxlICE9ICdvYmplY3QnKSB7XHJcbiAgICAgIGdsU3R5bGUgPSBKU09OLnBhcnNlKGdsU3R5bGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGdsU3R5bGUudmVyc2lvbiAhPSA4KSB7XHJcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dsU3R5bGUgdmVyc2lvbiA4IHJlcXVpcmVkLicpKTtcclxuICAgIH1cclxuICAgIHZhciBzcHJpdGVTY2FsZSwgc3ByaXRlRGF0YSwgc3ByaXRlSW1hZ2VVcmw7XHJcbiAgICBpZiAoZ2xTdHlsZS5zcHJpdGUpIHtcclxuICAgICAgc3ByaXRlU2NhbGUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+PSAxLjUgPyAwLjUgOiAxO1xyXG4gICAgICB2YXIgc2l6ZUZhY3RvciA9IHNwcml0ZVNjYWxlID09IDAuNSA/ICdAMngnIDogJyc7XHJcbiAgICAgIHZhciBzcHJpdGVVcmwgPSB0b1Nwcml0ZVVybChnbFN0eWxlLnNwcml0ZSwgcGF0aCwgc2l6ZUZhY3RvciArICcuanNvbicpO1xyXG5cclxuICAgICAgZmV0Y2goc3ByaXRlVXJsLCB7Y3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbid9KVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAvLyBpZiB0aGUgcmVzcG9uc2UgaXMgcmVhZHkgcmV0dXJuIHRoZSBKU09OIHByb21pc2VcclxuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChzaXplRmFjdG9yICE9PSAnJykge1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIEpTT04gcHJvbWlzZSBmb3IgdGhlIGxvdy1yZXNvbHV0aW9uIHNwcml0ZXMuXHJcbiAgICAgICAgICAgIHNpemVGYWN0b3IgPSAnJztcclxuICAgICAgICAgICAgc3ByaXRlVXJsID0gdG9TcHJpdGVVcmwoZ2xTdHlsZS5zcHJpdGUsIHBhdGgsICcuanNvbicpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goc3ByaXRlVXJsLCB7Y3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbid9KS50aGVuKHIgPT4gci5qc29uKCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc3ByaXRlc0pzb24pIHtcclxuICAgICAgICAgIGlmIChzcHJpdGVzSnNvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdObyBzcHJpdGVzIGZvdW5kLic7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzcHJpdGVEYXRhID0gc3ByaXRlc0pzb247XHJcbiAgICAgICAgICBzcHJpdGVJbWFnZVVybCA9IHRvU3ByaXRlVXJsKGdsU3R5bGUuc3ByaXRlLCBwYXRoLCBzaXplRmFjdG9yICsgJy5wbmcnKTtcclxuICAgICAgICAgIG9uQ2hhbmdlKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTcHJpdGVzIGNhbm5vdCBiZSBsb2FkZWQgZnJvbSAnICsgc3ByaXRlVXJsKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0eWxlO1xyXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XHJcbiAgICAgIGlmICghc3R5bGUgJiYgKCFnbFN0eWxlLnNwcml0ZSB8fCBzcHJpdGVEYXRhKSAmJiAoIWF2YWlsYWJsZUZvbnRzIHx8IGF2YWlsYWJsZUZvbnRzLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgc3R5bGUgPSBhcHBseVN0eWxlRnVuY3Rpb24obGF5ZXIsIGdsU3R5bGUsIHNvdXJjZSwgcmVzb2x1dGlvbnMsIHNwcml0ZURhdGEsIHNwcml0ZUltYWdlVXJsLCBhdmFpbGFibGVGb250cyk7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKHN0eWxlKSB7XHJcbiAgICAgICAgbGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxheWVyIGluc3RhbmNlb2YgVmVjdG9yVGlsZUxheWVyIHx8IGxheWVyIGluc3RhbmNlb2YgVmVjdG9yTGF5ZXIpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgbGF5ZXJzID0gZ2xTdHlsZS5sYXllcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09ICdzdHJpbmcnICYmIGxheWVyc1tpXS5zb3VyY2UgPT0gc291cmNlIHx8IHNvdXJjZS5pbmRleE9mKGxheWVyc1tpXS5pZCkgPj0gMCkge1xyXG4gICAgICAgICAgICBwcmVwcm9jZXNzKGxheWVyc1tpXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9uQ2hhbmdlKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEJhY2tncm91bmQobWFwLCBsYXllcikge1xyXG4gIGNvbnN0IGJhY2tncm91bmQgPSB7XHJcbiAgICB0eXBlOiBsYXllci50eXBlXHJcbiAgfTtcclxuICBmdW5jdGlvbiB1cGRhdGVTdHlsZSgpIHtcclxuICAgIHZhciBlbGVtZW50ID0gbWFwLmdldFRhcmdldEVsZW1lbnQoKTtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgbGF5b3V0ID0gbGF5ZXIubGF5b3V0IHx8IHt9O1xyXG4gICAgdmFyIHBhaW50ID0gbGF5ZXIucGFpbnQgfHwge307XHJcbiAgICBiYWNrZ3JvdW5kWydwYWludCddID0gcGFpbnQ7XHJcbiAgICBiYWNrZ3JvdW5kLmlkID0gJ29sbXMtYmctJyArIHBhaW50WydiYWNrZ3JvdW5kLW9wYWNpdHknXSArIHBhaW50WydiYWNrZ3JvdW5kLWNvbG9yJ107XHJcbiAgICB2YXIgem9vbSA9IG1hcC5nZXRWaWV3KCkuZ2V0Wm9vbSgpO1xyXG4gICAgaWYgKHBhaW50WydiYWNrZ3JvdW5kLWNvbG9yJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBiZyA9IGdldFZhbHVlKGJhY2tncm91bmQsICdwYWludCcsICdiYWNrZ3JvdW5kLWNvbG9yJywgem9vbSwge30pO1xyXG4gICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmQgPSBDb2xvci5wYXJzZShiZykudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIGlmIChwYWludFsnYmFja2dyb3VuZC1vcGFjaXR5J10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBnZXRWYWx1ZShiYWNrZ3JvdW5kLCAncGFpbnQnLCAnYmFja2dyb3VuZC1vcGFjaXR5Jywgem9vbSwge30pO1xyXG4gICAgfVxyXG4gICAgaWYgKGxheW91dC52aXNpYmlsaXR5ID09ICdub25lJykge1xyXG4gICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcnO1xyXG4gICAgICBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAnJztcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKG1hcC5nZXRUYXJnZXRFbGVtZW50KCkpIHtcclxuICAgIHVwZGF0ZVN0eWxlKCk7XHJcbiAgfVxyXG4gIG1hcC5vbihbJ2NoYW5nZTpyZXNvbHV0aW9uJywgJ2NoYW5nZTp0YXJnZXQnXSwgdXBkYXRlU3R5bGUpO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbGllcyBwcm9wZXJ0aWVzIG9mIHRoZSBNYXBib3ggU3R5bGUncyBmaXJzdCBgYmFja2dyb3VuZGAgbGF5ZXIgdG8gdGhlIG1hcC5cclxuICogQHBhcmFtIHtvbC5NYXB9IG1hcCBPcGVuTGF5ZXJzIE1hcC5cclxuICogQHBhcmFtIHtPYmplY3R9IGdsU3R5bGUgTWFwYm94IFN0eWxlIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseUJhY2tncm91bmQobWFwLCBnbFN0eWxlKSB7XHJcbiAgZ2xTdHlsZS5sYXllcnMuc29tZShmdW5jdGlvbihsKSB7XHJcbiAgICBpZiAobC50eXBlID09ICdiYWNrZ3JvdW5kJykge1xyXG4gICAgICBzZXRCYWNrZ3JvdW5kKG1hcCwgbCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTb3VyY2VJZEJ5UmVmKGxheWVycywgcmVmKSB7XHJcbiAgdmFyIHNvdXJjZUlkO1xyXG4gIGxheWVycy5zb21lKGZ1bmN0aW9uKGxheWVyKSB7XHJcbiAgICBpZiAobGF5ZXIuaWQgPT0gcmVmKSB7XHJcbiAgICAgIHNvdXJjZUlkID0gbGF5ZXIuc291cmNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gc291cmNlSWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NTdHlsZShnbFN0eWxlLCBtYXAsIGJhc2VVcmwsIGhvc3QsIHBhdGgsIGFjY2Vzc1Rva2VuKSB7XHJcbiAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xyXG4gIGlmICgnY2VudGVyJyBpbiBnbFN0eWxlICYmICF2aWV3LmdldENlbnRlcigpKSB7XHJcbiAgICB2aWV3LnNldENlbnRlcihmcm9tTG9uTGF0KGdsU3R5bGUuY2VudGVyKSk7XHJcbiAgfVxyXG4gIGlmICgnem9vbScgaW4gZ2xTdHlsZSAmJiB2aWV3LmdldFpvb20oKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICB2aWV3LnNldFpvb20oZ2xTdHlsZS56b29tKTtcclxuICB9XHJcbiAgaWYgKCF2aWV3LmdldENlbnRlcigpIHx8IHZpZXcuZ2V0Wm9vbSgpID09PSB1bmRlZmluZWQpIHtcclxuICAgIHZpZXcuZml0KHZpZXcuZ2V0UHJvamVjdGlvbigpLmdldEV4dGVudCgpLCB7XHJcbiAgICAgIG5lYXJlc3Q6IHRydWUsXHJcbiAgICAgIHNpemU6IG1hcC5nZXRTaXplKClcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAoZ2xTdHlsZS5zcHJpdGUpIHtcclxuICAgIGlmIChnbFN0eWxlLnNwcml0ZS5pbmRleE9mKCdtYXBib3g6Ly8nKSA9PSAwKSB7XHJcbiAgICAgIGdsU3R5bGUuc3ByaXRlID0gYmFzZVVybCArICcvc3ByaXRlJyArIGFjY2Vzc1Rva2VuO1xyXG4gICAgfSBlbHNlIGlmIChnbFN0eWxlLnNwcml0ZS5pbmRleE9mKCdodHRwJykgIT0gMCkge1xyXG4gICAgICBnbFN0eWxlLnNwcml0ZSA9IChob3N0ID8gKGhvc3QgKyBwYXRoKSA6ICcnKSArIGdsU3R5bGUuc3ByaXRlICsgYWNjZXNzVG9rZW47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgZ2xMYXllcnMgPSBnbFN0eWxlLmxheWVycztcclxuICB2YXIgZ2VvSnNvbkZvcm1hdCA9IG5ldyBHZW9KU09OKCk7XHJcbiAgdmFyIGxheWVySWRzID0gW107XHJcblxyXG4gIGZ1bmN0aW9uIGZpbmFsaXplTGF5ZXIobGF5ZXIpIHtcclxuICAgIGlmIChsYXllcklkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIG1hcC5hZGRMYXllcihsYXllcik7XHJcbiAgICAgIHZhciBzZXRTdHlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFwcGx5U3R5bGUobGF5ZXIsIGdsU3R5bGUsIGxheWVySWRzLCBwYXRoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgbGF5ZXIuc2V0VmlzaWJsZSh0cnVlKTtcclxuICAgICAgICB9LCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAvKmVzbGludCBuby1jb25zb2xlOiBbXCJlcnJvclwiLCB7IGFsbG93OiBbXCJlcnJvclwiXSB9XSAqL1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgaWYgKGxheWVyLmdldFNvdXJjZSgpKSB7XHJcbiAgICAgICAgc2V0U3R5bGUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsYXllci5vbmNlKCdjaGFuZ2U6c291cmNlJywgc2V0U3R5bGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgZ2xMYXllciwgZ2xTb3VyY2UsIGdsU291cmNlSWQsIGlkLCBsYXllciwgbWFwaWQsIHVybDtcclxuICBmb3IgKHZhciBpID0gMCwgaWkgPSBnbExheWVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICBnbExheWVyID0gZ2xMYXllcnNbaV07XHJcbiAgICBpZiAoZ2xMYXllci50eXBlID09ICdiYWNrZ3JvdW5kJykge1xyXG4gICAgICBzZXRCYWNrZ3JvdW5kKG1hcCwgZ2xMYXllcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZCA9IGdsTGF5ZXIuc291cmNlIHx8IGdldFNvdXJjZUlkQnlSZWYoZ2xMYXllcnMsIGdsTGF5ZXIucmVmKTtcclxuICAgICAgaWYgKGlkICE9IGdsU291cmNlSWQpIHtcclxuICAgICAgICBmaW5hbGl6ZUxheWVyKGxheWVyKTtcclxuICAgICAgICBsYXllcklkcyA9IFtdO1xyXG4gICAgICAgIGdsU291cmNlID0gZ2xTdHlsZS5zb3VyY2VzW2lkXTtcclxuICAgICAgICB1cmwgPSBnbFNvdXJjZS51cmw7XHJcbiAgICAgICAgdmFyIHRpbGVzID0gZ2xTb3VyY2UudGlsZXM7XHJcbiAgICAgICAgaWYgKHVybCkge1xyXG4gICAgICAgICAgaWYgKHVybC5pbmRleE9mKCdtYXBib3g6Ly8nKSA9PSAwKSB7XHJcbiAgICAgICAgICAgIG1hcGlkID0gdXJsLnJlcGxhY2UoJ21hcGJveDovLycsICcnKTtcclxuICAgICAgICAgICAgdGlsZXMgPSBbJ2EnLCAnYicsICdjJywgJ2QnXS5tYXAoZnVuY3Rpb24oaG9zdCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiAnaHR0cHM6Ly8nICsgaG9zdCArICcudGlsZXMubWFwYm94LmNvbS92NC8nICsgbWFwaWQgK1xyXG4gICAgICAgICAgICAgICAgICAnL3t6fS97eH0ve3l9LicgK1xyXG4gICAgICAgICAgICAgICAgICAoZ2xTb3VyY2UudHlwZSA9PSAndmVjdG9yJyA/ICd2ZWN0b3IucGJmJyA6ICdwbmcnKSArXHJcbiAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChnbFNvdXJjZS50eXBlID09ICd2ZWN0b3InKSB7XHJcbiAgICAgICAgICBsYXllciA9IHRpbGVzID8gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdGlsZUdyaWQgPSBjcmVhdGVYWVooe1xyXG4gICAgICAgICAgICAgIHRpbGVTaXplOiA1MTIsXHJcbiAgICAgICAgICAgICAgbWF4Wm9vbTogJ21heHpvb20nIGluIGdsU291cmNlID8gZ2xTb3VyY2UubWF4em9vbSA6IDIyLFxyXG4gICAgICAgICAgICAgIG1pblpvb206IGdsU291cmNlLm1pbnpvb21cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yVGlsZUxheWVyKHtcclxuICAgICAgICAgICAgICBkZWNsdXR0ZXI6IHRydWUsXHJcbiAgICAgICAgICAgICAgbWF4UmVzb2x1dGlvbjogdGlsZUdyaWQuZ2V0TWluWm9vbSgpID4gMCA/XHJcbiAgICAgICAgICAgICAgICB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHRpbGVHcmlkLmdldE1pblpvb20oKSkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgc291cmNlOiBuZXcgVmVjdG9yVGlsZVNvdXJjZSh7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGlvbnM6IGdsU291cmNlLmF0dHJpYnV0aW9uLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBuZXcgTVZUKCksXHJcbiAgICAgICAgICAgICAgICB0aWxlR3JpZDogdGlsZUdyaWQsXHJcbiAgICAgICAgICAgICAgICB1cmxzOiB0aWxlc1xyXG4gICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIHpJbmRleDogaVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pKCkgOiAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IG5ldyBWZWN0b3JUaWxlTGF5ZXIoe1xyXG4gICAgICAgICAgICAgIGRlY2x1dHRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICB6SW5kZXg6IGlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciB0aWxlanNvbiA9IG5ldyBUaWxlSlNPTih7XHJcbiAgICAgICAgICAgICAgdXJsOiB1cmxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aWxlanNvbi5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRpbGVqc29uLmdldFN0YXRlKCkgPT0gJ3JlYWR5Jykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVKU09ORG9jID0gdGlsZWpzb24uZ2V0VGlsZUpTT04oKTtcclxuICAgICAgICAgICAgICAgIHZhciB0aWxlcyA9IEFycmF5LmlzQXJyYXkodGlsZUpTT05Eb2MudGlsZXMpID8gdGlsZUpTT05Eb2MudGlsZXMgOiBbdGlsZUpTT05Eb2MudGlsZXNdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGlsZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgdGlsZSA9IHRpbGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICBpZiAodGlsZS5pbmRleE9mKCdodHRwJykgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVzW2ldID0gZ2xTb3VyY2UudXJsICsgdGlsZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVHcmlkID0gdGlsZWpzb24uZ2V0VGlsZUdyaWQoKTtcclxuICAgICAgICAgICAgICAgIGxheWVyLnNldFNvdXJjZShuZXcgVmVjdG9yVGlsZVNvdXJjZSh7XHJcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0aW9uczogdGlsZWpzb24uZ2V0QXR0cmlidXRpb25zKCkgfHwgdGlsZUpTT05Eb2MuYXR0cmlidXRpb24sXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdDogbmV3IE1WVCgpLFxyXG4gICAgICAgICAgICAgICAgICB0aWxlR3JpZDogY3JlYXRlWFlaKHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ab29tOiB0aWxlR3JpZC5nZXRNaW5ab29tKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4Wm9vbTogdGlsZUdyaWQuZ2V0TWF4Wm9vbSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVTaXplOiA1MTJcclxuICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgIHVybHM6IHRpbGVzXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGlsZUdyaWQuZ2V0TWluWm9vbSgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICBsYXllci5zZXRNYXhSZXNvbHV0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVHcmlkLmdldFJlc29sdXRpb24odGlsZUdyaWQuZ2V0TWluWm9vbSgpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1bkJ5S2V5KGtleSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGxheWVyO1xyXG4gICAgICAgICAgfSkoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGdsU291cmNlLnR5cGUgPT0gJ3Jhc3RlcicpIHtcclxuICAgICAgICAgIHZhciBzb3VyY2U7XHJcbiAgICAgICAgICBpZiAoIWdsU291cmNlLnRpbGVzKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFRpbGVKU09OKHtcclxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBuZXcgWFlaKHtcclxuICAgICAgICAgICAgICBhdHRyaWJ1dGlvbnM6IGdsU291cmNlLmF0dHJpYnV0aW9uLFxyXG4gICAgICAgICAgICAgIG1pblpvb206IGdsU291cmNlLm1pbnpvb20sXHJcbiAgICAgICAgICAgICAgbWF4Wm9vbTogJ21heHpvb20nIGluIGdsU291cmNlID8gZ2xTb3VyY2UubWF4em9vbSA6IDIyLFxyXG4gICAgICAgICAgICAgIHRpbGVTaXplOiBnbFNvdXJjZS50aWxlU2l6ZSB8fCA1MTIsXHJcbiAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgICAgdXJsczogZ2xTb3VyY2UudGlsZXMsXHJcbiAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc291cmNlLnNldFRpbGVMb2FkRnVuY3Rpb24oZnVuY3Rpb24odGlsZSwgc3JjKSB7XHJcbiAgICAgICAgICAgIGlmIChzcmMuaW5kZXhPZigne2Jib3gtZXBzZy0zODU3fScpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGJib3ggPSBzb3VyY2UuZ2V0VGlsZUdyaWQoKS5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZS5nZXRUaWxlQ29vcmQoKSk7XHJcbiAgICAgICAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoJ3tiYm94LWVwc2ctMzg1N30nLCBiYm94LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGxheWVyID0gbmV3IFRpbGVMYXllcih7XHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBnbExheWVyLmxheW91dCA/IGdsTGF5ZXIubGF5b3V0LnZpc2liaWxpdHkgIT09ICdub25lJyA6IHRydWVcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZ2xTb3VyY2UudHlwZSA9PSAnZ2VvanNvbicpIHtcclxuICAgICAgICAgIHZhciBkYXRhID0gZ2xTb3VyY2UuZGF0YTtcclxuICAgICAgICAgIHZhciBmZWF0dXJlcywgZ2VvSnNvblVybDtcclxuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBnZW9Kc29uVXJsID0gd2l0aFBhdGgoZGF0YSwgcGF0aCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmZWF0dXJlcyA9IGdlb0pzb25Gb3JtYXQucmVhZEZlYXR1cmVzKGRhdGEsIHtmZWF0dXJlUHJvamVjdGlvbjogJ0VQU0c6Mzg1Nyd9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxheWVyID0gbmV3IFZlY3RvckxheWVyKHtcclxuICAgICAgICAgICAgc291cmNlOiBuZXcgVmVjdG9yU291cmNlKHtcclxuICAgICAgICAgICAgICBhdHRyaWJ1dGlvbnM6IGdsU291cmNlLmF0dHJpYnV0aW9uLFxyXG4gICAgICAgICAgICAgIGZlYXR1cmVzOiBmZWF0dXJlcyxcclxuICAgICAgICAgICAgICBmb3JtYXQ6IGdlb0pzb25Gb3JtYXQsXHJcbiAgICAgICAgICAgICAgdXJsOiBnZW9Kc29uVXJsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgekluZGV4OiBpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2xTb3VyY2VJZCA9IGlkO1xyXG4gICAgICB9XHJcbiAgICAgIGxheWVySWRzLnB1c2goZ2xMYXllci5pZCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZpbmFsaXplTGF5ZXIobGF5ZXIpO1xyXG4gIG1hcC5zZXQoJ21hcGJveC1zdHlsZScsIGdsU3R5bGUpO1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZHMgYW5kIGFwcGxpZXMgYSBNYXBib3ggU3R5bGUgb2JqZWN0IHRvIGFuIE9wZW5MYXllcnMgTWFwLiBUaGlzIGluY2x1ZGVzXHJcbiAqIHRoZSBtYXAgYmFja2dyb3VuZCwgdGhlIGxheWVycywgdGhlIGNlbnRlciBhbmQgdGhlIHpvb20uXHJcbiAqXHJcbiAqIFRoZSBjZW50ZXIgYW5kIHpvb20gd2lsbCBvbmx5IGJlIHNldCBpZiBwcmVzZW50IGluIHRoZSBNYXBib3ggU3R5bGUgZG9jdW1lbnQsXHJcbiAqIGFuZCBpZiBub3QgYWxyZWFkeSBzZXQgb24gdGhlIE9wZW5MYXllcnMgbWFwLlxyXG4gKlxyXG4gKiBMYXllcnMgd2lsbCBiZSBhZGRlZCB0byB0aGUgT3BlbkxheWVycyBtYXAsIHdpdGhvdXQgYWZmZWN0aW5nIGFueSBsYXllcnMgdGhhdFxyXG4gKiBtaWdodCBhbHJlYWR5IGJlIHNldCBvbiB0aGUgbWFwLlxyXG4gKlxyXG4gKiBMYXllcnMgYWRkZWQgYnkgYGFwcGx5KClgIHdpbGwgaGF2ZSB0d28gYWRkaXRpb25hbCBwcm9wZXJ0aWVzOlxyXG4gKlxyXG4gKiAgKiBgbWFwYm94LXNvdXJjZWA6IFRoZSBgaWRgIG9mIHRoZSBNYXBib3ggU3R5bGUgZG9jdW1lbnQncyBzb3VyY2UgdGhhdCB0aGVcclxuICogICAgT3BlbkxheWVycyBsYXllciB3YXMgY3JlYXRlZCBmcm9tLiBVc3VhbGx5IGBhcHBseSgpYCBjcmVhdGVzIG9uZVxyXG4gKiAgICBPcGVuTGF5ZXJzIGxheWVyIHBlciBNYXBib3ggU3R5bGUgc291cmNlLCB1bmxlc3MgdGhlIGxheWVyIHN0YWNrIGhhc1xyXG4gKiAgICBsYXllcnMgZnJvbSBkaWZmZXJlbnQgc291cmNlcyBpbiBiZXR3ZWVuLlxyXG4gKiAgKiBgbWFwYm94LWxheWVyc2A6IFRoZSBgaWRgcyBvZiB0aGUgTWFwYm94IFN0eWxlIGRvY3VtZW50J3MgbGF5ZXJzIHRoYXQgYXJlXHJcbiAqICAgIGluY2x1ZGVkIGluIHRoZSBPcGVuTGF5ZXJzIGxheWVyLlxyXG4gKlxyXG4gKiBUaGUgbWFwIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gd2lsbCBoYXZlIGFuIGFkZGl0aW9uYWwgYG1hcGJveC1zdHlsZWBcclxuICogcHJvcGVydHkgd2hpY2ggaG9sZHMgdGhlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2wuTWFwfEhUTUxFbGVtZW50fHN0cmluZ30gbWFwIEVpdGhlciBhbiBleGlzdGluZyBPcGVuTGF5ZXJzIE1hcFxyXG4gKiBpbnN0YW5jZSwgb3IgYSBIVE1MIGVsZW1lbnQsIG9yIHRoZSBpZCBvZiBhIEhUTUwgZWxlbWVudCB0aGF0IHdpbGwgYmUgdGhlXHJcbiAqIHRhcmdldCBvZiBhIG5ldyBPcGVuTGF5ZXJzIE1hcC5cclxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBzdHlsZSBKU09OIHN0eWxlIG9iamVjdCBvciBzdHlsZSB1cmwgcG9pbnRpbmcgdG8gYVxyXG4gKiBNYXBib3ggU3R5bGUgb2JqZWN0LiBXaGVuIHVzaW5nIE1hcGJveCBBUElzLCB0aGUgdXJsIG11c3QgY29udGFpbiBhbiBhY2Nlc3NcclxuICogdG9rZW4gYW5kIGxvb2sgbGlrZVxyXG4gKiBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9zdHlsZXMvdjEvbWFwYm94L2JyaWdodC12OT9hY2Nlc3NfdG9rZW49W3lvdXJfYWNjZXNzX3Rva2VuX2hlcmVdYC5cclxuICogV2hlbiBwYXNzZWQgYXMgSlNPTiBzdHlsZSBvYmplY3QsIGFsbCBPcGVuTGF5ZXJzIGxheWVycyBjcmVhdGVkIGJ5IGBhcHBseSgpYFxyXG4gKiB3aWxsIGJlIGltbWVkaWF0ZWx5IGF2YWlsYWJsZSwgYnV0IHRoZXkgbWF5IG5vdCBoYXZlIGEgc291cmNlIHlldCAoaS5lLiB3aGVuXHJcbiAqIHRoZXkgYXJlIGRlZmluZWQgYnkgYSBUaWxlSlNPTiB1cmwgaW4gdGhlIE1hcGJveCBTdHlsZSBkb2N1bWVudCkuIFdoZW4gcGFzc2VkXHJcbiAqIGFzIHN0eWxlIHVybCwgbGF5ZXJzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCB3aGVuIHRoZSBNYXBib3ggU3R5bGUgZG9jdW1lbnRcclxuICogaXMgbG9hZGVkIGFuZCBwYXJzZWQuXHJcbiAqIEByZXR1cm4ge29sLk1hcH0gVGhlIE9wZW5MYXllcnMgTWFwIGluc3RhbmNlIHRoYXQgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCB0aGVcclxuICogY29udGVudHMgZGVzY3JpYmVkIGluIHRoZSBNYXBib3ggU3R5bGUgb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5KG1hcCwgc3R5bGUpIHtcclxuXHJcbiAgdmFyIGFjY2Vzc1Rva2VuLCBiYXNlVXJsLCBob3N0LCBwYXRoO1xyXG4gIGFjY2Vzc1Rva2VuID0gYmFzZVVybCA9IGhvc3QgPSBwYXRoID0gJyc7XHJcblxyXG4gIGlmICghKG1hcCBpbnN0YW5jZW9mIE1hcCkpIHtcclxuICAgIG1hcCA9IG5ldyBNYXAoe1xyXG4gICAgICB0YXJnZXQ6IG1hcFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFyIHBhcnRzID0gc3R5bGUubWF0Y2goc3ByaXRlUmVnRXgpO1xyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgIGJhc2VVcmwgPSBwYXJ0c1sxXTtcclxuICAgICAgYWNjZXNzVG9rZW4gPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiAnJztcclxuICAgIH1cclxuXHJcbiAgICBmZXRjaChzdHlsZSwge1xyXG4gICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ1xyXG4gICAgfSlcclxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICB9KVxyXG4gICAgICAudGhlbihmdW5jdGlvbihnbFN0eWxlKSB7XHJcbiAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdBJyk7XHJcbiAgICAgICAgYS5ocmVmID0gc3R5bGU7XHJcbiAgICAgICAgcGF0aCA9IGEucGF0aG5hbWUuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuam9pbignLycpICsgJy8nO1xyXG4gICAgICAgIGhvc3QgPSBzdHlsZS5zdWJzdHIoMCwgc3R5bGUuaW5kZXhPZihwYXRoKSk7XHJcblxyXG4gICAgICAgIHByb2Nlc3NTdHlsZShnbFN0eWxlLCBtYXAsIGJhc2VVcmwsIGhvc3QsIHBhdGgsIGFjY2Vzc1Rva2VuKTtcclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2FkICcgKyBzdHlsZSk7XHJcbiAgICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICBwcm9jZXNzU3R5bGUoc3R5bGUsIG1hcCk7XHJcbiAgICB9LCAwKTtcclxuICB9XHJcbiAgcmV0dXJuIG1hcDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgT3BlbkxheWVycyBsYXllciBpbnN0YW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBwcm92aWRlZCBNYXBib3ggU3R5bGVcclxuICogYGxheWVyYC4gTm90ZSB0aGF0IG11bHRpcGxlIE1hcGJveCBTdHlsZSBsYXllcnMgYXJlIGNvbWJpbmVkIGluIGEgc2luZ2xlXHJcbiAqIE9wZW5MYXllcnMgbGF5ZXIgaW5zdGFuY2Ugd2hlbiB0aGV5IHVzZSB0aGUgc2FtZSBNYXBib3ggU3R5bGUgYHNvdXJjZWAuXHJcbiAqIEBwYXJhbSB7b2wuTWFwfSBtYXAgT3BlbkxheWVycyBNYXAuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYXllcklkIE1hcGJveCBTdHlsZSBsYXllciBpZC5cclxuICogQHJldHVybiB7b2wubGF5ZXIuTGF5ZXJ9IGxheWVyIE9wZW5MYXllcnMgbGF5ZXIgaW5zdGFuY2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF5ZXIobWFwLCBsYXllcklkKSB7XHJcbiAgY29uc3QgbGF5ZXJzID0gbWFwLmdldExheWVycygpLmdldEFycmF5KCk7XHJcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgIGlmIChsYXllcnNbaV0uZ2V0KCdtYXBib3gtbGF5ZXJzJykuaW5kZXhPZihsYXllcklkKSAhPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIGxheWVyc1tpXTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIE9wZW5MYXllcnMgc291cmNlIGluc3RhbmNlIGZvciB0aGUgcHJvdmlkZWQgTWFwYm94IFN0eWxlIGBzb3VyY2VgLlxyXG4gKiBAcGFyYW0ge29sLk1hcH0gbWFwIE9wZW5MYXllcnMgTWFwLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlSWQgTWFwYm94IFN0eWxlIHNvdXJjZSBpZC5cclxuICogQHJldHVybiB7b2wubGF5ZXIuTGF5ZXJ9IGxheWVyIE9wZW5MYXllcnMgbGF5ZXIgaW5zdGFuY2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U291cmNlKG1hcCwgc291cmNlSWQpIHtcclxuICBjb25zdCBsYXllcnMgPSBtYXAuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKTtcclxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgY29uc3Qgc291cmNlID0gbGF5ZXJzW2ldLmdldFNvdXJjZSgpO1xyXG4gICAgaWYgKGxheWVyc1tpXS5nZXQoJ21hcGJveC1zb3VyY2UnKS5pbmRleE9mKHNvdXJjZUlkKSAhPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwidmFyICR2ZXJzaW9uID0gODtcbnZhciAkcm9vdCA9IHtcblx0dmVyc2lvbjoge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczogW1xuXHRcdFx0OFxuXHRcdF0sXG5cdFx0ZG9jOiBcIlN0eWxlIHNwZWNpZmljYXRpb24gdmVyc2lvbiBudW1iZXIuIE11c3QgYmUgOC5cIixcblx0XHRleGFtcGxlOiA4XG5cdH0sXG5cdG5hbWU6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIGh1bWFuLXJlYWRhYmxlIG5hbWUgZm9yIHRoZSBzdHlsZS5cIixcblx0XHRleGFtcGxlOiBcIkJyaWdodFwiXG5cdH0sXG5cdG1ldGFkYXRhOiB7XG5cdFx0dHlwZTogXCIqXCIsXG5cdFx0ZG9jOiBcIkFyYml0cmFyeSBwcm9wZXJ0aWVzIHVzZWZ1bCB0byB0cmFjayB3aXRoIHRoZSBzdHlsZXNoZWV0LCBidXQgZG8gbm90IGluZmx1ZW5jZSByZW5kZXJpbmcuIFByb3BlcnRpZXMgc2hvdWxkIGJlIHByZWZpeGVkIHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgJ21hcGJveDonLlwiXG5cdH0sXG5cdGNlbnRlcjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiRGVmYXVsdCBtYXAgY2VudGVyIGluIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUuICBUaGUgc3R5bGUgY2VudGVyIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG5cdFx0ZXhhbXBsZTogW1xuXHRcdFx0LTczLjk3NDksXG5cdFx0XHQ0MC43NzM2XG5cdFx0XVxuXHR9LFxuXHR6b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiRGVmYXVsdCB6b29tIGxldmVsLiAgVGhlIHN0eWxlIHpvb20gd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcblx0XHRleGFtcGxlOiAxMi41XG5cdH0sXG5cdGJlYXJpbmc6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdHBlcmlvZDogMzYwLFxuXHRcdHVuaXRzOiBcImRlZ3JlZXNcIixcblx0XHRkb2M6IFwiRGVmYXVsdCBiZWFyaW5nLCBpbiBkZWdyZWVzLiBUaGUgYmVhcmluZyBpcyB0aGUgY29tcGFzcyBkaXJlY3Rpb24gdGhhdCBpcyBcXFwidXBcXFwiOyBmb3IgZXhhbXBsZSwgYSBiZWFyaW5nIG9mIDkwwrAgb3JpZW50cyB0aGUgbWFwIHNvIHRoYXQgZWFzdCBpcyB1cC4gVGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuXHRcdGV4YW1wbGU6IDI5XG5cdH0sXG5cdHBpdGNoOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHR1bml0czogXCJkZWdyZWVzXCIsXG5cdFx0ZG9jOiBcIkRlZmF1bHQgcGl0Y2gsIGluIGRlZ3JlZXMuIFplcm8gaXMgcGVycGVuZGljdWxhciB0byB0aGUgc3VyZmFjZSwgZm9yIGEgbG9vayBzdHJhaWdodCBkb3duIGF0IHRoZSBtYXAsIHdoaWxlIGEgZ3JlYXRlciB2YWx1ZSBsaWtlIDYwIGxvb2tzIGFoZWFkIHRvd2FyZHMgdGhlIGhvcml6b24uIFRoZSBzdHlsZSBwaXRjaCB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuXHRcdGV4YW1wbGU6IDUwXG5cdH0sXG5cdGxpZ2h0OiB7XG5cdFx0dHlwZTogXCJsaWdodFwiLFxuXHRcdGRvYzogXCJUaGUgZ2xvYmFsIGxpZ2h0IHNvdXJjZS5cIixcblx0XHRleGFtcGxlOiB7XG5cdFx0XHRhbmNob3I6IFwidmlld3BvcnRcIixcblx0XHRcdGNvbG9yOiBcIndoaXRlXCIsXG5cdFx0XHRpbnRlbnNpdHk6IDAuNFxuXHRcdH1cblx0fSxcblx0c291cmNlczoge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwic291cmNlc1wiLFxuXHRcdGRvYzogXCJEYXRhIHNvdXJjZSBzcGVjaWZpY2F0aW9ucy5cIixcblx0XHRleGFtcGxlOiB7XG5cdFx0XHRcIm1hcGJveC1zdHJlZXRzXCI6IHtcblx0XHRcdFx0dHlwZTogXCJ2ZWN0b3JcIixcblx0XHRcdFx0dXJsOiBcIm1hcGJveDovL21hcGJveC5tYXBib3gtc3RyZWV0cy12NlwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRzcHJpdGU6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIGJhc2UgVVJMIGZvciByZXRyaWV2aW5nIHRoZSBzcHJpdGUgaW1hZ2UgYW5kIG1ldGFkYXRhLiBUaGUgZXh0ZW5zaW9ucyBgLnBuZ2AsIGAuanNvbmAgYW5kIHNjYWxlIGZhY3RvciBgQDJ4LnBuZ2Agd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFwcGVuZGVkLiBUaGlzIHByb3BlcnR5IGlzIHJlcXVpcmVkIGlmIGFueSBsYXllciB1c2VzIHRoZSBgYmFja2dyb3VuZC1wYXR0ZXJuYCwgYGZpbGwtcGF0dGVybmAsIGBsaW5lLXBhdHRlcm5gLCBgZmlsbC1leHRydXNpb24tcGF0dGVybmAsIG9yIGBpY29uLWltYWdlYCBwcm9wZXJ0aWVzLiBUaGUgVVJMIG11c3QgYmUgYWJzb2x1dGUsIGNvbnRhaW5pbmcgdGhlIFtzY2hlbWUsIGF1dGhvcml0eSBhbmQgcGF0aCBjb21wb25lbnRzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VUkwjU3ludGF4KS5cIixcblx0XHRleGFtcGxlOiBcIm1hcGJveDovL3Nwcml0ZXMvbWFwYm94L2JyaWdodC12OFwiXG5cdH0sXG5cdGdseXBoczoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkEgVVJMIHRlbXBsYXRlIGZvciBsb2FkaW5nIHNpZ25lZC1kaXN0YW5jZS1maWVsZCBnbHlwaCBzZXRzIGluIFBCRiBmb3JtYXQuIFRoZSBVUkwgbXVzdCBpbmNsdWRlIGB7Zm9udHN0YWNrfWAgYW5kIGB7cmFuZ2V9YCB0b2tlbnMuIFRoaXMgcHJvcGVydHkgaXMgcmVxdWlyZWQgaWYgYW55IGxheWVyIHVzZXMgdGhlIGB0ZXh0LWZpZWxkYCBsYXlvdXQgcHJvcGVydHkuIFRoZSBVUkwgbXVzdCBiZSBhYnNvbHV0ZSwgY29udGFpbmluZyB0aGUgW3NjaGVtZSwgYXV0aG9yaXR5IGFuZCBwYXRoIGNvbXBvbmVudHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VSTCNTeW50YXgpLlwiLFxuXHRcdGV4YW1wbGU6IFwibWFwYm94Oi8vZm9udHMvbWFwYm94L3tmb250c3RhY2t9L3tyYW5nZX0ucGJmXCJcblx0fSxcblx0dHJhbnNpdGlvbjoge1xuXHRcdHR5cGU6IFwidHJhbnNpdGlvblwiLFxuXHRcdGRvYzogXCJBIGdsb2JhbCB0cmFuc2l0aW9uIGRlZmluaXRpb24gdG8gdXNlIGFzIGEgZGVmYXVsdCBhY3Jvc3MgcHJvcGVydGllcywgdG8gYmUgdXNlZCBmb3IgdGltaW5nIHRyYW5zaXRpb25zIGJldHdlZW4gb25lIHZhbHVlIGFuZCB0aGUgbmV4dCB3aGVuIG5vIHByb3BlcnR5LXNwZWNpZmljIHRyYW5zaXRpb24gaXMgc2V0LiBDb2xsaXNpb24tYmFzZWQgc3ltYm9sIGZhZGluZyBpcyBjb250cm9sbGVkIGluZGVwZW5kZW50bHkgb2YgdGhlIHN0eWxlJ3MgYHRyYW5zaXRpb25gIHByb3BlcnR5LlwiLFxuXHRcdGV4YW1wbGU6IHtcblx0XHRcdGR1cmF0aW9uOiAzMDAsXG5cdFx0XHRkZWxheTogMFxuXHRcdH1cblx0fSxcblx0bGF5ZXJzOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcImxheWVyXCIsXG5cdFx0ZG9jOiBcIkxheWVycyB3aWxsIGJlIGRyYXduIGluIHRoZSBvcmRlciBvZiB0aGlzIGFycmF5LlwiLFxuXHRcdGV4YW1wbGU6IFtcblx0XHRcdHtcblx0XHRcdFx0aWQ6IFwid2F0ZXJcIixcblx0XHRcdFx0c291cmNlOiBcIm1hcGJveC1zdHJlZXRzXCIsXG5cdFx0XHRcdFwic291cmNlLWxheWVyXCI6IFwid2F0ZXJcIixcblx0XHRcdFx0dHlwZTogXCJmaWxsXCIsXG5cdFx0XHRcdHBhaW50OiB7XG5cdFx0XHRcdFx0XCJmaWxsLWNvbG9yXCI6IFwiIzAwZmZmZlwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdXG5cdH1cbn07XG52YXIgc291cmNlcyA9IHtcblx0XCIqXCI6IHtcblx0XHR0eXBlOiBcInNvdXJjZVwiLFxuXHRcdGRvYzogXCJTcGVjaWZpY2F0aW9uIG9mIGEgZGF0YSBzb3VyY2UuIEZvciB2ZWN0b3IgYW5kIHJhc3RlciBzb3VyY2VzLCBlaXRoZXIgVGlsZUpTT04gb3IgYSBVUkwgdG8gYSBUaWxlSlNPTiBtdXN0IGJlIHByb3ZpZGVkLiBGb3IgaW1hZ2UgYW5kIHZpZGVvIHNvdXJjZXMsIGEgVVJMIG11c3QgYmUgcHJvdmlkZWQuIEZvciBHZW9KU09OIHNvdXJjZXMsIGEgVVJMIG9yIGlubGluZSBHZW9KU09OIG11c3QgYmUgcHJvdmlkZWQuXCJcblx0fVxufTtcbnZhciBzb3VyY2UgPSBbXG5cdFwic291cmNlX3ZlY3RvclwiLFxuXHRcInNvdXJjZV9yYXN0ZXJcIixcblx0XCJzb3VyY2VfcmFzdGVyX2RlbVwiLFxuXHRcInNvdXJjZV9nZW9qc29uXCIsXG5cdFwic291cmNlX3ZpZGVvXCIsXG5cdFwic291cmNlX2ltYWdlXCJcbl07XG52YXIgc291cmNlX3ZlY3RvciA9IHtcblx0dHlwZToge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmVjdG9yOiB7XG5cdFx0XHRcdGRvYzogXCJBIHZlY3RvciB0aWxlIHNvdXJjZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSB0eXBlIG9mIHRoZSBzb3VyY2UuXCJcblx0fSxcblx0dXJsOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQSBVUkwgdG8gYSBUaWxlSlNPTiByZXNvdXJjZS4gU3VwcG9ydGVkIHByb3RvY29scyBhcmUgYGh0dHA6YCwgYGh0dHBzOmAsIGFuZCBgbWFwYm94Oi8vPFRpbGVzZXQgSUQ+YC5cIlxuXHR9LFxuXHR0aWxlczoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgdGlsZSBzb3VyY2UgVVJMcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcblx0fSxcblx0Ym91bmRzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogNCxcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0LTE4MCxcblx0XHRcdC04NS4wNTExMjksXG5cdFx0XHQxODAsXG5cdFx0XHQ4NS4wNTExMjlcblx0XHRdLFxuXHRcdGRvYzogXCJBbiBhcnJheSBjb250YWluaW5nIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBjb3JuZXJzIG9mIHRoZSBzb3VyY2UncyBib3VuZGluZyBib3ggaW4gdGhlIGZvbGxvd2luZyBvcmRlcjogYFtzdy5sbmcsIHN3LmxhdCwgbmUubG5nLCBuZS5sYXRdYC4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIGluY2x1ZGVkIGluIGEgc291cmNlLCBubyB0aWxlcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBib3VuZHMgYXJlIHJlcXVlc3RlZCBieSBNYXBib3ggR0wuXCJcblx0fSxcblx0c2NoZW1lOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR4eXo6IHtcblx0XHRcdFx0ZG9jOiBcIlNsaXBweSBtYXAgdGlsZW5hbWVzIHNjaGVtZS5cIlxuXHRcdFx0fSxcblx0XHRcdHRtczoge1xuXHRcdFx0XHRkb2M6IFwiT1NHZW8gc3BlYyBzY2hlbWUuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInh5elwiLFxuXHRcdGRvYzogXCJJbmZsdWVuY2VzIHRoZSB5IGRpcmVjdGlvbiBvZiB0aGUgdGlsZSBjb29yZGluYXRlcy4gVGhlIGdsb2JhbC1tZXJjYXRvciAoYWthIFNwaGVyaWNhbCBNZXJjYXRvcikgcHJvZmlsZSBpcyBhc3N1bWVkLlwiXG5cdH0sXG5cdG1pbnpvb206IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdGRvYzogXCJNaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG5cdH0sXG5cdG1heHpvb206IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAyMixcblx0XHRkb2M6IFwiTWF4aW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy4gRGF0YSBmcm9tIHRpbGVzIGF0IHRoZSBtYXh6b29tIGFyZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGUgbWFwIGF0IGhpZ2hlciB6b29tIGxldmVscy5cIlxuXHR9LFxuXHRhdHRyaWJ1dGlvbjoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLlwiXG5cdH0sXG5cdHByb21vdGVJZDoge1xuXHRcdHR5cGU6IFwicHJvbW90ZUlkXCIsXG5cdFx0ZG9jOiBcIkEgcHJvcGVydHkgdG8gdXNlIGFzIGEgZmVhdHVyZSBpZCAoZm9yIGZlYXR1cmUgc3RhdGUpLiBFaXRoZXIgYSBwcm9wZXJ0eSBuYW1lLCBvciBhbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHs8c291cmNlTGF5ZXI+OiA8cHJvcGVydHlOYW1lPn1gLiBJZiBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgZm9yIGEgdmVjdG9yIHRpbGUgc291cmNlLCB0aGUgc2FtZSBwcm9wZXJ0eSBpcyB1c2VkIGFjcm9zcyBhbGwgaXRzIHNvdXJjZSBsYXllcnMuXCJcblx0fSxcblx0XCIqXCI6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRkb2M6IFwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwiXG5cdH1cbn07XG52YXIgc291cmNlX3Jhc3RlciA9IHtcblx0dHlwZToge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0cmFzdGVyOiB7XG5cdFx0XHRcdGRvYzogXCJBIHJhc3RlciB0aWxlIHNvdXJjZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSB0eXBlIG9mIHRoZSBzb3VyY2UuXCJcblx0fSxcblx0dXJsOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQSBVUkwgdG8gYSBUaWxlSlNPTiByZXNvdXJjZS4gU3VwcG9ydGVkIHByb3RvY29scyBhcmUgYGh0dHA6YCwgYGh0dHBzOmAsIGFuZCBgbWFwYm94Oi8vPFRpbGVzZXQgSUQ+YC5cIlxuXHR9LFxuXHR0aWxlczoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgdGlsZSBzb3VyY2UgVVJMcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcblx0fSxcblx0Ym91bmRzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogNCxcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0LTE4MCxcblx0XHRcdC04NS4wNTExMjksXG5cdFx0XHQxODAsXG5cdFx0XHQ4NS4wNTExMjlcblx0XHRdLFxuXHRcdGRvYzogXCJBbiBhcnJheSBjb250YWluaW5nIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBjb3JuZXJzIG9mIHRoZSBzb3VyY2UncyBib3VuZGluZyBib3ggaW4gdGhlIGZvbGxvd2luZyBvcmRlcjogYFtzdy5sbmcsIHN3LmxhdCwgbmUubG5nLCBuZS5sYXRdYC4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIGluY2x1ZGVkIGluIGEgc291cmNlLCBubyB0aWxlcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBib3VuZHMgYXJlIHJlcXVlc3RlZCBieSBNYXBib3ggR0wuXCJcblx0fSxcblx0bWluem9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0ZG9jOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcblx0fSxcblx0bWF4em9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDIyLFxuXHRcdGRvYzogXCJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLlwiXG5cdH0sXG5cdHRpbGVTaXplOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogNTEyLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy5cIlxuXHR9LFxuXHRzY2hlbWU6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHh5ejoge1xuXHRcdFx0XHRkb2M6IFwiU2xpcHB5IG1hcCB0aWxlbmFtZXMgc2NoZW1lLlwiXG5cdFx0XHR9LFxuXHRcdFx0dG1zOiB7XG5cdFx0XHRcdGRvYzogXCJPU0dlbyBzcGVjIHNjaGVtZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwieHl6XCIsXG5cdFx0ZG9jOiBcIkluZmx1ZW5jZXMgdGhlIHkgZGlyZWN0aW9uIG9mIHRoZSB0aWxlIGNvb3JkaW5hdGVzLiBUaGUgZ2xvYmFsLW1lcmNhdG9yIChha2EgU3BoZXJpY2FsIE1lcmNhdG9yKSBwcm9maWxlIGlzIGFzc3VtZWQuXCJcblx0fSxcblx0YXR0cmlidXRpb246IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJDb250YWlucyBhbiBhdHRyaWJ1dGlvbiB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgbWFwIGlzIHNob3duIHRvIGEgdXNlci5cIlxuXHR9LFxuXHRcIipcIjoge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcblx0fVxufTtcbnZhciBzb3VyY2VfcmFzdGVyX2RlbSA9IHtcblx0dHlwZToge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0XCJyYXN0ZXItZGVtXCI6IHtcblx0XHRcdFx0ZG9jOiBcIkEgUkdCLWVuY29kZWQgcmFzdGVyIERFTSBzb3VyY2VcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSB0eXBlIG9mIHRoZSBzb3VyY2UuXCJcblx0fSxcblx0dXJsOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQSBVUkwgdG8gYSBUaWxlSlNPTiByZXNvdXJjZS4gU3VwcG9ydGVkIHByb3RvY29scyBhcmUgYGh0dHA6YCwgYGh0dHBzOmAsIGFuZCBgbWFwYm94Oi8vPFRpbGVzZXQgSUQ+YC5cIlxuXHR9LFxuXHR0aWxlczoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgdGlsZSBzb3VyY2UgVVJMcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcblx0fSxcblx0Ym91bmRzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogNCxcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0LTE4MCxcblx0XHRcdC04NS4wNTExMjksXG5cdFx0XHQxODAsXG5cdFx0XHQ4NS4wNTExMjlcblx0XHRdLFxuXHRcdGRvYzogXCJBbiBhcnJheSBjb250YWluaW5nIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBjb3JuZXJzIG9mIHRoZSBzb3VyY2UncyBib3VuZGluZyBib3ggaW4gdGhlIGZvbGxvd2luZyBvcmRlcjogYFtzdy5sbmcsIHN3LmxhdCwgbmUubG5nLCBuZS5sYXRdYC4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIGluY2x1ZGVkIGluIGEgc291cmNlLCBubyB0aWxlcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBib3VuZHMgYXJlIHJlcXVlc3RlZCBieSBNYXBib3ggR0wuXCJcblx0fSxcblx0bWluem9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0ZG9jOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcblx0fSxcblx0bWF4em9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDIyLFxuXHRcdGRvYzogXCJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLlwiXG5cdH0sXG5cdHRpbGVTaXplOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogNTEyLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy5cIlxuXHR9LFxuXHRhdHRyaWJ1dGlvbjoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLlwiXG5cdH0sXG5cdGVuY29kaW5nOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR0ZXJyYXJpdW06IHtcblx0XHRcdFx0ZG9jOiBcIlRlcnJhcml1bSBmb3JtYXQgUE5HIHRpbGVzLiBTZWUgaHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9lcy9wdWJsaWMtZGF0YXNldHMvdGVycmFpbi8gZm9yIG1vcmUgaW5mby5cIlxuXHRcdFx0fSxcblx0XHRcdG1hcGJveDoge1xuXHRcdFx0XHRkb2M6IFwiTWFwYm94IFRlcnJhaW4gUkdCIHRpbGVzLiBTZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9oZWxwL2FjY2Vzcy1lbGV2YXRpb24tZGF0YS8jbWFwYm94LXRlcnJhaW4tcmdiIGZvciBtb3JlIGluZm8uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcGJveFwiLFxuXHRcdGRvYzogXCJUaGUgZW5jb2RpbmcgdXNlZCBieSB0aGlzIHNvdXJjZS4gTWFwYm94IFRlcnJhaW4gUkdCIGlzIHVzZWQgYnkgZGVmYXVsdFwiXG5cdH0sXG5cdFwiKlwiOiB7XG5cdFx0dHlwZTogXCIqXCIsXG5cdFx0ZG9jOiBcIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS5cIlxuXHR9XG59O1xudmFyIHNvdXJjZV9nZW9qc29uID0ge1xuXHR0eXBlOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRnZW9qc29uOiB7XG5cdFx0XHRcdGRvYzogXCJBIEdlb0pTT04gZGF0YSBzb3VyY2UuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSBHZW9KU09OIHNvdXJjZS5cIlxuXHR9LFxuXHRkYXRhOiB7XG5cdFx0dHlwZTogXCIqXCIsXG5cdFx0ZG9jOiBcIkEgVVJMIHRvIGEgR2VvSlNPTiBmaWxlLCBvciBpbmxpbmUgR2VvSlNPTi5cIlxuXHR9LFxuXHRtYXh6b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMTgsXG5cdFx0ZG9jOiBcIk1heGltdW0gem9vbSBsZXZlbCBhdCB3aGljaCB0byBjcmVhdGUgdmVjdG9yIHRpbGVzIChoaWdoZXIgbWVhbnMgZ3JlYXRlciBkZXRhaWwgYXQgaGlnaCB6b29tIGxldmVscykuXCJcblx0fSxcblx0YXR0cmlidXRpb246IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJDb250YWlucyBhbiBhdHRyaWJ1dGlvbiB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgbWFwIGlzIHNob3duIHRvIGEgdXNlci5cIlxuXHR9LFxuXHRidWZmZXI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxMjgsXG5cdFx0bWF4aW11bTogNTEyLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0ZG9jOiBcIlNpemUgb2YgdGhlIHRpbGUgYnVmZmVyIG9uIGVhY2ggc2lkZS4gQSB2YWx1ZSBvZiAwIHByb2R1Y2VzIG5vIGJ1ZmZlci4gQSB2YWx1ZSBvZiA1MTIgcHJvZHVjZXMgYSBidWZmZXIgYXMgd2lkZSBhcyB0aGUgdGlsZSBpdHNlbGYuIExhcmdlciB2YWx1ZXMgcHJvZHVjZSBmZXdlciByZW5kZXJpbmcgYXJ0aWZhY3RzIG5lYXIgdGlsZSBlZGdlcyBhbmQgc2xvd2VyIHBlcmZvcm1hbmNlLlwiXG5cdH0sXG5cdHRvbGVyYW5jZToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAuMzc1LFxuXHRcdGRvYzogXCJEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlciBnZW9tZXRyaWVzIGFuZCBmYXN0ZXIgcGVyZm9ybWFuY2UpLlwiXG5cdH0sXG5cdGNsdXN0ZXI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRoZSBkYXRhIGlzIGEgY29sbGVjdGlvbiBvZiBwb2ludCBmZWF0dXJlcywgc2V0dGluZyB0aGlzIHRvIHRydWUgY2x1c3RlcnMgdGhlIHBvaW50cyBieSByYWRpdXMgaW50byBncm91cHMuIENsdXN0ZXIgZ3JvdXBzIGJlY29tZSBuZXcgYFBvaW50YCBmZWF0dXJlcyBpbiB0aGUgc291cmNlIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzOlxcbiAqIGBjbHVzdGVyYCBJcyBgdHJ1ZWAgaWYgdGhlIHBvaW50IGlzIGEgY2x1c3RlciBcXG4gKiBgY2x1c3Rlcl9pZGAgQSB1bnFpdWUgaWQgZm9yIHRoZSBjbHVzdGVyIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgW2NsdXN0ZXIgaW5zcGVjdGlvbiBtZXRob2RzXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI2dlb2pzb25zb3VyY2UjZ2V0Y2x1c3RlcmV4cGFuc2lvbnpvb20pXFxuICogYHBvaW50X2NvdW50YCBOdW1iZXIgb2Ygb3JpZ2luYWwgcG9pbnRzIGdyb3VwZWQgaW50byB0aGlzIGNsdXN0ZXJcXG4gKiBgcG9pbnRfY291bnRfYWJicmV2aWF0ZWRgIEFuIGFiYnJldmlhdGVkIHBvaW50IGNvdW50XCJcblx0fSxcblx0Y2x1c3RlclJhZGl1czoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDUwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0ZG9jOiBcIlJhZGl1cyBvZiBlYWNoIGNsdXN0ZXIgaWYgY2x1c3RlcmluZyBpcyBlbmFibGVkLiBBIHZhbHVlIG9mIDUxMiBpbmRpY2F0ZXMgYSByYWRpdXMgZXF1YWwgdG8gdGhlIHdpZHRoIG9mIGEgdGlsZS5cIlxuXHR9LFxuXHRjbHVzdGVyTWF4Wm9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIk1heCB6b29tIG9uIHdoaWNoIHRvIGNsdXN0ZXIgcG9pbnRzIGlmIGNsdXN0ZXJpbmcgaXMgZW5hYmxlZC4gRGVmYXVsdHMgdG8gb25lIHpvb20gbGVzcyB0aGFuIG1heHpvb20gKHNvIHRoYXQgbGFzdCB6b29tIGZlYXR1cmVzIGFyZSBub3QgY2x1c3RlcmVkKS5cIlxuXHR9LFxuXHRjbHVzdGVyUHJvcGVydGllczoge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJBbiBvYmplY3QgZGVmaW5pbmcgY3VzdG9tIHByb3BlcnRpZXMgb24gdGhlIGdlbmVyYXRlZCBjbHVzdGVycyBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQsIGFnZ3JlZ2F0aW5nIHZhbHVlcyBmcm9tIGNsdXN0ZXJlZCBwb2ludHMuIEhhcyB0aGUgZm9ybSBge1xcXCJwcm9wZXJ0eV9uYW1lXFxcIjogW29wZXJhdG9yLCBtYXBfZXhwcmVzc2lvbl19YC4gYG9wZXJhdG9yYCBpcyBhbnkgZXhwcmVzc2lvbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXQgbGVhc3QgMiBvcGVyYW5kcyAoZS5nLiBgXFxcIitcXFwiYCBvciBgXFxcIm1heFxcXCJgKSDigJQgaXQgYWNjdW11bGF0ZXMgdGhlIHByb3BlcnR5IHZhbHVlIGZyb20gY2x1c3RlcnMvcG9pbnRzIHRoZSBjbHVzdGVyIGNvbnRhaW5zOyBgbWFwX2V4cHJlc3Npb25gIHByb2R1Y2VzIHRoZSB2YWx1ZSBvZiBhIHNpbmdsZSBwb2ludC5cXG5cXG5FeGFtcGxlOiBge1xcXCJzdW1cXFwiOiBbXFxcIitcXFwiLCBbXFxcImdldFxcXCIsIFxcXCJzY2FsZXJhbmtcXFwiXV19YC5cXG5cXG5Gb3IgbW9yZSBhZHZhbmNlZCB1c2UgY2FzZXMsIGluIHBsYWNlIG9mIGBvcGVyYXRvcmAsIHlvdSBjYW4gdXNlIGEgY3VzdG9tIHJlZHVjZSBleHByZXNzaW9uIHRoYXQgcmVmZXJlbmNlcyBhIHNwZWNpYWwgYFtcXFwiYWNjdW11bGF0ZWRcXFwiXWAgdmFsdWUsIGUuZy46XFxuYHtcXFwic3VtXFxcIjogW1tcXFwiK1xcXCIsIFtcXFwiYWNjdW11bGF0ZWRcXFwiXSwgW1xcXCJnZXRcXFwiLCBcXFwic3VtXFxcIl1dLCBbXFxcImdldFxcXCIsIFxcXCJzY2FsZXJhbmtcXFwiXV19YFwiXG5cdH0sXG5cdGxpbmVNZXRyaWNzOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRvIGNhbGN1bGF0ZSBsaW5lIGRpc3RhbmNlIG1ldHJpY3MuIFRoaXMgaXMgcmVxdWlyZWQgZm9yIGxpbmUgbGF5ZXJzIHRoYXQgc3BlY2lmeSBgbGluZS1ncmFkaWVudGAgdmFsdWVzLlwiXG5cdH0sXG5cdGdlbmVyYXRlSWQ6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdG8gZ2VuZXJhdGUgaWRzIGZvciB0aGUgZ2VvanNvbiBmZWF0dXJlcy4gV2hlbiBlbmFibGVkLCB0aGUgYGZlYXR1cmUuaWRgIHByb3BlcnR5IHdpbGwgYmUgYXV0byBhc3NpZ25lZCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gdGhlIGBmZWF0dXJlc2AgYXJyYXksIG92ZXItd3JpdGluZyBhbnkgcHJldmlvdXMgdmFsdWVzLlwiXG5cdH0sXG5cdHByb21vdGVJZDoge1xuXHRcdHR5cGU6IFwicHJvbW90ZUlkXCIsXG5cdFx0ZG9jOiBcIkEgcHJvcGVydHkgdG8gdXNlIGFzIGEgZmVhdHVyZSBpZCAoZm9yIGZlYXR1cmUgc3RhdGUpLiBFaXRoZXIgYSBwcm9wZXJ0eSBuYW1lLCBvciBhbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHs8c291cmNlTGF5ZXI+OiA8cHJvcGVydHlOYW1lPn1gLlwiXG5cdH1cbn07XG52YXIgc291cmNlX3ZpZGVvID0ge1xuXHR0eXBlOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2aWRlbzoge1xuXHRcdFx0XHRkb2M6IFwiQSB2aWRlbyBkYXRhIHNvdXJjZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIHZpZGVvIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmxzOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJVUkxzIHRvIHZpZGVvIGNvbnRlbnQgaW4gb3JkZXIgb2YgcHJlZmVycmVkIGZvcm1hdC5cIlxuXHR9LFxuXHRjb29yZGluYXRlczoge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdGRvYzogXCJDb3JuZXJzIG9mIHZpZGVvIHNwZWNpZmllZCBpbiBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXJzLlwiLFxuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRsZW5ndGg6IDQsXG5cdFx0dmFsdWU6IHtcblx0XHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRcdGxlbmd0aDogMixcblx0XHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdFx0ZG9jOiBcIkEgc2luZ2xlIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpci5cIlxuXHRcdH1cblx0fVxufTtcbnZhciBzb3VyY2VfaW1hZ2UgPSB7XG5cdHR5cGU6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGltYWdlOiB7XG5cdFx0XHRcdGRvYzogXCJBbiBpbWFnZSBkYXRhIHNvdXJjZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIGltYWdlIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmw6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJVUkwgdGhhdCBwb2ludHMgdG8gYW4gaW1hZ2UuXCJcblx0fSxcblx0Y29vcmRpbmF0ZXM6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHRkb2M6IFwiQ29ybmVycyBvZiBpbWFnZSBzcGVjaWZpZWQgaW4gbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlycy5cIixcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdHZhbHVlOiB7XG5cdFx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0XHRsZW5ndGg6IDIsXG5cdFx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRcdGRvYzogXCJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuXCJcblx0XHR9XG5cdH1cbn07XG52YXIgbGF5ZXIgPSB7XG5cdGlkOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiVW5pcXVlIGxheWVyIG5hbWUuXCIsXG5cdFx0cmVxdWlyZWQ6IHRydWVcblx0fSxcblx0dHlwZToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0ZmlsbDoge1xuXHRcdFx0XHRkb2M6IFwiQSBmaWxsZWQgcG9seWdvbiB3aXRoIGFuIG9wdGlvbmFsIHN0cm9rZWQgYm9yZGVyLlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRsaW5lOiB7XG5cdFx0XHRcdGRvYzogXCJBIHN0cm9rZWQgbGluZS5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c3ltYm9sOiB7XG5cdFx0XHRcdGRvYzogXCJBbiBpY29uIG9yIGEgdGV4dCBsYWJlbC5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Y2lyY2xlOiB7XG5cdFx0XHRcdGRvYzogXCJBIGZpbGxlZCBjaXJjbGUuXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhlYXRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIkEgaGVhdG1hcC5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0XCJmaWxsLWV4dHJ1c2lvblwiOiB7XG5cdFx0XHRcdGRvYzogXCJBbiBleHRydWRlZCAoM0QpIHBvbHlnb24uXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJhc3Rlcjoge1xuXHRcdFx0XHRkb2M6IFwiUmFzdGVyIG1hcCB0ZXh0dXJlcyBzdWNoIGFzIHNhdGVsbGl0ZSBpbWFnZXJ5LlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRoaWxsc2hhZGU6IHtcblx0XHRcdFx0ZG9jOiBcIkNsaWVudC1zaWRlIGhpbGxzaGFkaW5nIHZpc3VhbGl6YXRpb24gYmFzZWQgb24gREVNIGRhdGEuIEN1cnJlbnRseSwgdGhlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgTWFwYm94IFRlcnJhaW4gUkdCIGFuZCBNYXB6ZW4gVGVycmFyaXVtIHRpbGVzLlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRiYWNrZ3JvdW5kOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYmFja2dyb3VuZCBjb2xvciBvciBwYXR0ZXJuIG9mIHRoZSBtYXAuXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlJlbmRlcmluZyB0eXBlIG9mIHRoaXMgbGF5ZXIuXCIsXG5cdFx0cmVxdWlyZWQ6IHRydWVcblx0fSxcblx0bWV0YWRhdGE6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRkb2M6IFwiQXJiaXRyYXJ5IHByb3BlcnRpZXMgdXNlZnVsIHRvIHRyYWNrIHdpdGggdGhlIGxheWVyLCBidXQgZG8gbm90IGluZmx1ZW5jZSByZW5kZXJpbmcuIFByb3BlcnRpZXMgc2hvdWxkIGJlIHByZWZpeGVkIHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgJ21hcGJveDonLlwiXG5cdH0sXG5cdHNvdXJjZToge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIk5hbWUgb2YgYSBzb3VyY2UgZGVzY3JpcHRpb24gdG8gYmUgdXNlZCBmb3IgdGhpcyBsYXllci4gUmVxdWlyZWQgZm9yIGFsbCBsYXllciB0eXBlcyBleGNlcHQgYGJhY2tncm91bmRgLlwiXG5cdH0sXG5cdFwic291cmNlLWxheWVyXCI6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJMYXllciB0byB1c2UgZnJvbSBhIHZlY3RvciB0aWxlIHNvdXJjZS4gUmVxdWlyZWQgZm9yIHZlY3RvciB0aWxlIHNvdXJjZXM7IHByb2hpYml0ZWQgZm9yIGFsbCBvdGhlciBzb3VyY2UgdHlwZXMsIGluY2x1ZGluZyBHZW9KU09OIHNvdXJjZXMuXCJcblx0fSxcblx0bWluem9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAyNCxcblx0XHRkb2M6IFwiVGhlIG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGxheWVyLiBBdCB6b29tIGxldmVscyBsZXNzIHRoYW4gdGhlIG1pbnpvb20sIHRoZSBsYXllciB3aWxsIGJlIGhpZGRlbi5cIlxuXHR9LFxuXHRtYXh6b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDI0LFxuXHRcdGRvYzogXCJUaGUgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgbGF5ZXIuIEF0IHpvb20gbGV2ZWxzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWF4em9vbSwgdGhlIGxheWVyIHdpbGwgYmUgaGlkZGVuLlwiXG5cdH0sXG5cdGZpbHRlcjoge1xuXHRcdHR5cGU6IFwiZmlsdGVyXCIsXG5cdFx0ZG9jOiBcIkEgZXhwcmVzc2lvbiBzcGVjaWZ5aW5nIGNvbmRpdGlvbnMgb24gc291cmNlIGZlYXR1cmVzLiBPbmx5IGZlYXR1cmVzIHRoYXQgbWF0Y2ggdGhlIGZpbHRlciBhcmUgZGlzcGxheWVkLiBab29tIGV4cHJlc3Npb25zIGluIGZpbHRlcnMgYXJlIG9ubHkgZXZhbHVhdGVkIGF0IGludGVnZXIgem9vbSBsZXZlbHMuIFRoZSBgZmVhdHVyZS1zdGF0ZWAgZXhwcmVzc2lvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGZpbHRlciBleHByZXNzaW9ucy5cIlxuXHR9LFxuXHRsYXlvdXQ6IHtcblx0XHR0eXBlOiBcImxheW91dFwiLFxuXHRcdGRvYzogXCJMYXlvdXQgcHJvcGVydGllcyBmb3IgdGhlIGxheWVyLlwiXG5cdH0sXG5cdHBhaW50OiB7XG5cdFx0dHlwZTogXCJwYWludFwiLFxuXHRcdGRvYzogXCJEZWZhdWx0IHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuXCJcblx0fVxufTtcbnZhciBsYXlvdXQgPSBbXG5cdFwibGF5b3V0X2ZpbGxcIixcblx0XCJsYXlvdXRfbGluZVwiLFxuXHRcImxheW91dF9jaXJjbGVcIixcblx0XCJsYXlvdXRfaGVhdG1hcFwiLFxuXHRcImxheW91dF9maWxsLWV4dHJ1c2lvblwiLFxuXHRcImxheW91dF9zeW1ib2xcIixcblx0XCJsYXlvdXRfcmFzdGVyXCIsXG5cdFwibGF5b3V0X2hpbGxzaGFkZVwiLFxuXHRcImxheW91dF9iYWNrZ3JvdW5kXCJcbl07XG52YXIgbGF5b3V0X2JhY2tncm91bmQgPSB7XG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn07XG52YXIgbGF5b3V0X2ZpbGwgPSB7XG5cdFwiZmlsbC1zb3J0LWtleVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiU29ydHMgZmVhdHVyZXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoaXMgdmFsdWUuIEZlYXR1cmVzIHdpdGggYSBoaWdoZXIgc29ydCBrZXkgd2lsbCBhcHBlYXIgYWJvdmUgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMS4yLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjEuMi4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHR2aXNpYmlsaXR5OiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2aXNpYmxlOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcblx0XHRcdH0sXG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIGxheW91dF9jaXJjbGUgPSB7XG5cdFwiY2lyY2xlLXNvcnQta2V5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJTb3J0cyBmZWF0dXJlcyBpbiBhc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhpcyB2YWx1ZS4gRmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIGFwcGVhciBhYm92ZSBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIxLjIuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMS4yLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn07XG52YXIgbGF5b3V0X2hlYXRtYXAgPSB7XG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn07XG52YXIgbGF5b3V0X2xpbmUgPSB7XG5cdFwibGluZS1jYXBcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0YnV0dDoge1xuXHRcdFx0XHRkb2M6IFwiQSBjYXAgd2l0aCBhIHNxdWFyZWQtb2ZmIGVuZCB3aGljaCBpcyBkcmF3biB0byB0aGUgZXhhY3QgZW5kcG9pbnQgb2YgdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHRyb3VuZDoge1xuXHRcdFx0XHRkb2M6IFwiQSBjYXAgd2l0aCBhIHJvdW5kZWQgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSByYWRpdXMgb2Ygb25lLWhhbGYgb2YgdGhlIGxpbmUncyB3aWR0aCBhbmQgY2VudGVyZWQgb24gdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lLlwiXG5cdFx0XHR9LFxuXHRcdFx0c3F1YXJlOiB7XG5cdFx0XHRcdGRvYzogXCJBIGNhcCB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSBkaXN0YW5jZSBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJidXR0XCIsXG5cdFx0ZG9jOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmUgZW5kaW5ncy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwibGluZS1qb2luXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGJldmVsOiB7XG5cdFx0XHRcdGRvYzogXCJBIGpvaW4gd2l0aCBhIHNxdWFyZWQtb2ZmIGVuZCB3aGljaCBpcyBkcmF3biBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIGF0IGEgZGlzdGFuY2Ugb2Ygb25lLWhhbGYgb2YgdGhlIGxpbmUncyB3aWR0aC5cIlxuXHRcdFx0fSxcblx0XHRcdHJvdW5kOiB7XG5cdFx0XHRcdGRvYzogXCJBIGpvaW4gd2l0aCBhIHJvdW5kZWQgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSByYWRpdXMgb2Ygb25lLWhhbGYgb2YgdGhlIGxpbmUncyB3aWR0aCBhbmQgY2VudGVyZWQgb24gdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lLlwiXG5cdFx0XHR9LFxuXHRcdFx0bWl0ZXI6IHtcblx0XHRcdFx0ZG9jOiBcIkEgam9pbiB3aXRoIGEgc2hhcnAsIGFuZ2xlZCBjb3JuZXIgd2hpY2ggaXMgZHJhd24gd2l0aCB0aGUgb3V0ZXIgc2lkZXMgYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgcGF0aCB1bnRpbCB0aGV5IG1lZXQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1pdGVyXCIsXG5cdFx0ZG9jOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmVzIHdoZW4gam9pbmluZy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40MC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtbWl0ZXItbGltaXRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDIsXG5cdFx0ZG9jOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IG1pdGVyIGpvaW5zIHRvIGJldmVsIGpvaW5zIGZvciBzaGFycCBhbmdsZXMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCJsaW5lLWpvaW5cIjogXCJtaXRlclwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJsaW5lLXJvdW5kLWxpbWl0XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLjA1LFxuXHRcdGRvYzogXCJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCByb3VuZCBqb2lucyB0byBtaXRlciBqb2lucyBmb3Igc2hhbGxvdyBhbmdsZXMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCJsaW5lLWpvaW5cIjogXCJyb3VuZFwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJsaW5lLXNvcnQta2V5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJTb3J0cyBmZWF0dXJlcyBpbiBhc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhpcyB2YWx1ZS4gRmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIGFwcGVhciBhYm92ZSBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIxLjIuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMS4yLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn07XG52YXIgbGF5b3V0X3N5bWJvbCA9IHtcblx0XCJzeW1ib2wtcGxhY2VtZW50XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHBvaW50OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGFiZWwgaXMgcGxhY2VkIGF0IHRoZSBwb2ludCB3aGVyZSB0aGUgZ2VvbWV0cnkgaXMgbG9jYXRlZC5cIlxuXHRcdFx0fSxcblx0XHRcdGxpbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYWJlbCBpcyBwbGFjZWQgYWxvbmcgdGhlIGxpbmUgb2YgdGhlIGdlb21ldHJ5LiBDYW4gb25seSBiZSB1c2VkIG9uIGBMaW5lU3RyaW5nYCBhbmQgYFBvbHlnb25gIGdlb21ldHJpZXMuXCJcblx0XHRcdH0sXG5cdFx0XHRcImxpbmUtY2VudGVyXCI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYWJlbCBpcyBwbGFjZWQgYXQgdGhlIGNlbnRlciBvZiB0aGUgbGluZSBvZiB0aGUgZ2VvbWV0cnkuIENhbiBvbmx5IGJlIHVzZWQgb24gYExpbmVTdHJpbmdgIGFuZCBgUG9seWdvbmAgZ2VvbWV0cmllcy4gTm90ZSB0aGF0IGEgc2luZ2xlIGZlYXR1cmUgaW4gYSB2ZWN0b3IgdGlsZSBtYXkgY29udGFpbiBtdWx0aXBsZSBsaW5lIGdlb21ldHJpZXMuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInBvaW50XCIsXG5cdFx0ZG9jOiBcIkxhYmVsIHBsYWNlbWVudCByZWxhdGl2ZSB0byBpdHMgZ2VvbWV0cnkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiYGxpbmUtY2VudGVyYCB2YWx1ZVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjMuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEwLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInN5bWJvbC1zcGFjaW5nXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAyNTAsXG5cdFx0bWluaW11bTogMSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiRGlzdGFuY2UgYmV0d2VlbiB0d28gc3ltYm9sIGFuY2hvcnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJzeW1ib2wtYXZvaWQtZWRnZXNcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiSWYgdHJ1ZSwgdGhlIHN5bWJvbHMgd2lsbCBub3QgY3Jvc3MgdGlsZSBlZGdlcyB0byBhdm9pZCBtdXR1YWwgY29sbGlzaW9ucy4gUmVjb21tZW5kZWQgaW4gbGF5ZXJzIHRoYXQgZG9uJ3QgaGF2ZSBlbm91Z2ggcGFkZGluZyBpbiB0aGUgdmVjdG9yIHRpbGUgdG8gcHJldmVudCBjb2xsaXNpb25zLCBvciBpZiBpdCBpcyBhIHBvaW50IHN5bWJvbCBsYXllciBwbGFjZWQgYWZ0ZXIgYSBsaW5lIHN5bWJvbCBsYXllci4gV2hlbiB1c2luZyBhIGNsaWVudCB0aGF0IHN1cHBvcnRzIGdsb2JhbCBjb2xsaXNpb24gZGV0ZWN0aW9uLCBsaWtlIE1hcGJveCBHTCBKUyB2ZXJzaW9uIDAuNDIuMCBvciBncmVhdGVyLCBlbmFibGluZyB0aGlzIHByb3BlcnR5IGlzIG5vdCBuZWVkZWQgdG8gcHJldmVudCBjbGlwcGVkIGxhYmVscyBhdCB0aWxlIGJvdW5kYXJpZXMuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInN5bWJvbC1zb3J0LWtleVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiU29ydHMgZmVhdHVyZXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoaXMgdmFsdWUuIEZlYXR1cmVzIHdpdGggbG93ZXIgc29ydCBrZXlzIGFyZSBkcmF3biBhbmQgcGxhY2VkIGZpcnN0LiAgV2hlbiBgaWNvbi1hbGxvdy1vdmVybGFwYCBvciBgdGV4dC1hbGxvdy1vdmVybGFwYCBpcyBgZmFsc2VgLCBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkgd2lsbCBoYXZlIHByaW9yaXR5IGR1cmluZyBwbGFjZW1lbnQuIFdoZW4gYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgc2V0IHRvIGB0cnVlYCwgZmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIG92ZXJsYXAgb3ZlciBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjUzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI3LjQuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4xMS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTQuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC41My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNy40LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMTEuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwic3ltYm9sLXotb3JkZXJcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRkb2M6IFwiSWYgYHN5bWJvbC1zb3J0LWtleWAgaXMgc2V0LCBzb3J0IGJhc2VkIG9uIHRoYXQuIE90aGVyd2lzZSBzb3J0IHN5bWJvbHMgYnkgdGhlaXIgeS1wb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH0sXG5cdFx0XHRcInZpZXdwb3J0LXlcIjoge1xuXHRcdFx0XHRkb2M6IFwiU3ltYm9scyB3aWxsIGJlIHNvcnRlZCBieSB0aGVpciB5LXBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fSxcblx0XHRcdHNvdXJjZToge1xuXHRcdFx0XHRkb2M6IFwiU3ltYm9scyB3aWxsIGJlIHJlbmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBzb3VyY2UgZGF0YSB3aXRoIG5vIHNvcnRpbmcgYXBwbGllZC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwiYXV0b1wiLFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgb3JkZXIgaW4gd2hpY2ggb3ZlcmxhcHBpbmcgc3ltYm9scyBpbiB0aGUgc2FtZSBsYXllciBhcmUgcmVuZGVyZWRcIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuNi4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEyLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCB0aGUgaWNvbiB3aWxsIGJlIHZpc2libGUgZXZlbiBpZiBpdCBjb2xsaWRlcyB3aXRoIG90aGVyIHByZXZpb3VzbHkgZHJhd24gc3ltYm9scy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiSWYgdHJ1ZSwgb3RoZXIgc3ltYm9scyBjYW4gYmUgdmlzaWJsZSBldmVuIGlmIHRoZXkgY29sbGlkZSB3aXRoIHRoZSBpY29uLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24tb3B0aW9uYWxcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiSWYgdHJ1ZSwgdGV4dCB3aWxsIGRpc3BsYXkgd2l0aG91dCB0aGVpciBjb3JyZXNwb25kaW5nIGljb25zIHdoZW4gdGhlIGljb24gY29sbGlkZXMgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCB0aGUgdGV4dCBkb2VzIG5vdC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCIsXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIGFsaWducyBpY29ucyBlYXN0LXdlc3QuIFdoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgbGluZWAgb3IgYGxpbmUtY2VudGVyYCwgYWxpZ25zIGljb24geC1heGVzIHdpdGggdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiUHJvZHVjZXMgaWNvbnMgd2hvc2UgeC1heGVzIGFyZSBhbGlnbmVkIHdpdGggdGhlIHgtYXhpcyBvZiB0aGUgdmlld3BvcnQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBzeW1ib2wtcGxhY2VtZW50YC5cIlxuXHRcdFx0fSxcblx0XHRcdGF1dG86IHtcblx0XHRcdFx0ZG9jOiBcIldoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgcG9pbnRgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYHZpZXdwb3J0YC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCBvciBgbGluZS1jZW50ZXJgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYG1hcGAuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImF1dG9cIixcblx0XHRkb2M6IFwiSW4gY29tYmluYXRpb24gd2l0aCBgc3ltYm9sLXBsYWNlbWVudGAsIGRldGVybWluZXMgdGhlIHJvdGF0aW9uIGJlaGF2aW9yIG9mIGljb25zLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiYGF1dG9gIHZhbHVlXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLXNpemVcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHR1bml0czogXCJmYWN0b3Igb2YgdGhlIG9yaWdpbmFsIGljb24gc2l6ZVwiLFxuXHRcdGRvYzogXCJTY2FsZXMgdGhlIG9yaWdpbmFsIHNpemUgb2YgdGhlIGljb24gYnkgdGhlIHByb3ZpZGVkIGZhY3Rvci4gVGhlIG5ldyBwaXhlbCBzaXplIG9mIHRoZSBpbWFnZSB3aWxsIGJlIHRoZSBvcmlnaW5hbCBwaXhlbCBzaXplIG11bHRpcGxpZWQgYnkgYGljb24tc2l6ZWAuIDEgaXMgdGhlIG9yaWdpbmFsIHNpemU7IDMgdHJpcGxlcyB0aGUgc2l6ZSBvZiB0aGUgaW1hZ2UuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi10ZXh0LWZpdFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaWNvbiBpcyBkaXNwbGF5ZWQgYXQgaXRzIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uXCJcblx0XHRcdH0sXG5cdFx0XHR3aWR0aDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGljb24gaXMgc2NhbGVkIGluIHRoZSB4LWRpbWVuc2lvbiB0byBmaXQgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0LlwiXG5cdFx0XHR9LFxuXHRcdFx0aGVpZ2h0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaWNvbiBpcyBzY2FsZWQgaW4gdGhlIHktZGltZW5zaW9uIHRvIGZpdCB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0LlwiXG5cdFx0XHR9LFxuXHRcdFx0Ym90aDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGljb24gaXMgc2NhbGVkIGluIGJvdGggeC0gYW5kIHktZGltZW5zaW9ucy5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibm9uZVwiLFxuXHRcdGRvYzogXCJTY2FsZXMgdGhlIGljb24gdG8gZml0IGFyb3VuZCB0aGUgYXNzb2NpYXRlZCB0ZXh0LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIixcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjQuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjQuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjIuMVwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi10ZXh0LWZpdC1wYWRkaW5nXCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MCxcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiU2l6ZSBvZiB0aGUgYWRkaXRpb25hbCBhcmVhIGFkZGVkIHRvIGRpbWVuc2lvbnMgZGV0ZXJtaW5lZCBieSBgaWNvbi10ZXh0LWZpdGAsIGluIGNsb2Nrd2lzZSBvcmRlcjogdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIixcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcImljb24tdGV4dC1maXRcIjogW1xuXHRcdFx0XHRcdFwiYm90aFwiLFxuXHRcdFx0XHRcdFwid2lkdGhcIixcblx0XHRcdFx0XHRcImhlaWdodFwiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMi4xXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24taW1hZ2VcIjoge1xuXHRcdHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuXHRcdGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgYW4gaW1hZ2UgYmFja2dyb3VuZC5cIixcblx0XHR0b2tlbnM6IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzUuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLXJvdGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRwZXJpb2Q6IDM2MCxcblx0XHR1bml0czogXCJkZWdyZWVzXCIsXG5cdFx0ZG9jOiBcIlJvdGF0ZXMgdGhlIGljb24gY2xvY2t3aXNlLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24tcGFkZGluZ1wiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYXJvdW5kIHRoZSBpY29uIGJvdW5kaW5nIGJveCB1c2VkIGZvciBkZXRlY3Rpbmcgc3ltYm9sIGNvbGxpc2lvbnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLWtlZXAtdXByaWdodFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCB0aGUgaWNvbiBtYXkgYmUgZmxpcHBlZCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG5cdFx0XHRcdFx0XCJsaW5lXCIsXG5cdFx0XHRcdFx0XCJsaW5lLWNlbnRlclwiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLW9mZnNldFwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogMixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdGRvYzogXCJPZmZzZXQgZGlzdGFuY2Ugb2YgaWNvbiBmcm9tIGl0cyBhbmNob3IuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLiBFYWNoIGNvbXBvbmVudCBpcyBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZSBvZiBgaWNvbi1zaXplYCB0byBvYnRhaW4gdGhlIGZpbmFsIG9mZnNldCBpbiBwaXhlbHMuIFdoZW4gY29tYmluZWQgd2l0aCBgaWNvbi1yb3RhdGVgIHRoZSBvZmZzZXQgd2lsbCBiZSBhcyBpZiB0aGUgcm90YXRlZCBkaXJlY3Rpb24gd2FzIHVwLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24tYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGNlbnRlcjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGNlbnRlciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0bGVmdDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHR0b3A6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3Agb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdGJvdHRvbToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ0b3AtbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcInRvcC1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJib3R0b20tbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcImJvdHRvbS1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcblx0XHRkb2M6IFwiUGFydCBvZiB0aGUgaWNvbiBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLXBpdGNoLWFsaWdubWVudFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBpY29uIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSBtYXAuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGljb24gaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9LFxuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRkb2M6IFwiQXV0b21hdGljYWxseSBtYXRjaGVzIHRoZSB2YWx1ZSBvZiBgaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRgLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJhdXRvXCIsXG5cdFx0ZG9jOiBcIk9yaWVudGF0aW9uIG9mIGljb24gd2hlbiBtYXAgaXMgcGl0Y2hlZC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4zOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSBtYXAuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9LFxuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRkb2M6IFwiQXV0b21hdGljYWxseSBtYXRjaGVzIHRoZSB2YWx1ZSBvZiBgdGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRgLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJhdXRvXCIsXG5cdFx0ZG9jOiBcIk9yaWVudGF0aW9uIG9mIHRleHQgd2hlbiBtYXAgaXMgcGl0Y2hlZC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMi4xXCJcblx0XHRcdH0sXG5cdFx0XHRcImBhdXRvYCB2YWx1ZVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjUuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjQuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjQuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjMuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgYWxpZ25zIHRleHQgZWFzdC13ZXN0LiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIGFsaWducyB0ZXh0IHgtYXhlcyB3aXRoIHRoZSBsaW5lLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlByb2R1Y2VzIGdseXBocyB3aG9zZSB4LWF4ZXMgYXJlIGFsaWduZWQgd2l0aCB0aGUgeC1heGlzIG9mIHRoZSB2aWV3cG9ydCwgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYHN5bWJvbC1wbGFjZW1lbnRgLlwiXG5cdFx0XHR9LFxuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRkb2M6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgdmlld3BvcnRgLiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgbWFwYC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwiYXV0b1wiLFxuXHRcdGRvYzogXCJJbiBjb21iaW5hdGlvbiB3aXRoIGBzeW1ib2wtcGxhY2VtZW50YCwgZGV0ZXJtaW5lcyB0aGUgcm90YXRpb24gYmVoYXZpb3Igb2YgdGhlIGluZGl2aWR1YWwgZ2x5cGhzIGZvcm1pbmcgdGhlIHRleHQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJgYXV0b2AgdmFsdWVcIjoge1xuXHRcdFx0XHRqczogXCIwLjI1LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI0LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy40LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4zLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtZmllbGRcIjoge1xuXHRcdHR5cGU6IFwiZm9ybWF0dGVkXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiXCIsXG5cdFx0dG9rZW5zOiB0cnVlLFxuXHRcdGRvYzogXCJWYWx1ZSB0byB1c2UgZm9yIGEgdGV4dCBsYWJlbC4gSWYgYSBwbGFpbiBgc3RyaW5nYCBpcyBwcm92aWRlZCwgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgYGZvcm1hdHRlZGAgd2l0aCBkZWZhdWx0L2luaGVyaXRlZCBmb3JtYXR0aW5nIG9wdGlvbnMuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LWZvbnRcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJzdHJpbmdcIixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0XCJPcGVuIFNhbnMgUmVndWxhclwiLFxuXHRcdFx0XCJBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXJcIlxuXHRcdF0sXG5cdFx0ZG9jOiBcIkZvbnQgc3RhY2sgdG8gdXNlIGZvciBkaXNwbGF5aW5nIHRleHQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtc2l6ZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMTYsXG5cdFx0bWluaW11bTogMCxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiRm9udCBzaXplLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzUuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtbWF4LXdpZHRoXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcImVtc1wiLFxuXHRcdGRvYzogXCJUaGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciB0ZXh0IHdyYXBwaW5nLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtbGluZS1oZWlnaHRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEuMixcblx0XHR1bml0czogXCJlbXNcIixcblx0XHRkb2M6IFwiVGV4dCBsZWFkaW5nIHZhbHVlIGZvciBtdWx0aS1saW5lIHRleHQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdHVuaXRzOiBcImVtc1wiLFxuXHRcdGRvYzogXCJUZXh0IHRyYWNraW5nIGFtb3VudC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LWp1c3RpZnlcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRleHQgaXMgYWxpZ25lZCB0b3dhcmRzIHRoZSBhbmNob3IgcG9zaXRpb24uXCJcblx0XHRcdH0sXG5cdFx0XHRsZWZ0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBsZWZ0LlwiXG5cdFx0XHR9LFxuXHRcdFx0Y2VudGVyOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyBjZW50ZXJlZC5cIlxuXHRcdFx0fSxcblx0XHRcdHJpZ2h0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSByaWdodC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG5cdFx0ZG9jOiBcIlRleHQganVzdGlmaWNhdGlvbiBvcHRpb25zLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9LFxuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRqczogXCIwLjU0LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI3LjQuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4xMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LXJhZGlhbC1vZmZzZXRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0dW5pdHM6IFwiZW1zXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0ZG9jOiBcIlJhZGlhbCBvZmZzZXQgb2YgdGV4dCwgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3ltYm9sJ3MgYW5jaG9yLiBVc2VmdWwgaW4gY29tYmluYXRpb24gd2l0aCBgdGV4dC12YXJpYWJsZS1hbmNob3JgLCB3aGljaCBkZWZhdWx0cyB0byB1c2luZyB0aGUgdHdvLWRpbWVuc2lvbmFsIGB0ZXh0LW9mZnNldGAgaWYgcHJlc2VudC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTQuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjEwLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjU0LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI3LjQuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4xMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCIsXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9XG5cdH0sXG5cdFwidGV4dC12YXJpYWJsZS1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRjZW50ZXI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBjZW50ZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdGxlZnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsZWZ0IHNpZGUgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdHJpZ2h0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgcmlnaHQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0dG9wOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRib3R0b206IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBib3R0b20gb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdFwidG9wLWxlZnRcIjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ0b3AtcmlnaHRcIjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdFwiYm90dG9tLWxlZnRcIjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJib3R0b20tcmlnaHRcIjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcInN5bWJvbC1wbGFjZW1lbnRcIjogW1xuXHRcdFx0XHRcdFwicG9pbnRcIlxuXHRcdFx0XHRdXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRkb2M6IFwiVG8gaW5jcmVhc2UgdGhlIGNoYW5jZSBvZiBwbGFjaW5nIGhpZ2gtcHJpb3JpdHkgbGFiZWxzIG9uIHRoZSBtYXAsIHlvdSBjYW4gcHJvdmlkZSBhbiBhcnJheSBvZiBgdGV4dC1hbmNob3JgIGxvY2F0aW9uczogdGhlIHJlbmRlcmVyIHdpbGwgYXR0ZW1wdCB0byBwbGFjZSB0aGUgbGFiZWwgYXQgZWFjaCBsb2NhdGlvbiwgaW4gb3JkZXIsIGJlZm9yZSBtb3Zpbmcgb250byB0aGUgbmV4dCBsYWJlbC4gVXNlIGB0ZXh0LWp1c3RpZnk6IGF1dG9gIHRvIGNob29zZSBqdXN0aWZpY2F0aW9uIGJhc2VkIG9uIGFuY2hvciBwb3NpdGlvbi4gVG8gYXBwbHkgYW4gb2Zmc2V0LCB1c2UgdGhlIGB0ZXh0LXJhZGlhbC1vZmZzZXRgIG9yIHRoZSB0d28tZGltZW5zaW9uYWwgYHRleHQtb2Zmc2V0YC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTQuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjEwLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRjZW50ZXI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBjZW50ZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdGxlZnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsZWZ0IHNpZGUgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdHJpZ2h0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgcmlnaHQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0dG9wOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRib3R0b206IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBib3R0b20gb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdFwidG9wLWxlZnRcIjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ0b3AtcmlnaHRcIjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdFwiYm90dG9tLWxlZnRcIjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJib3R0b20tcmlnaHRcIjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG5cdFx0ZG9jOiBcIlBhcnQgb2YgdGhlIHRleHQgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcInRleHQtdmFyaWFibGUtYW5jaG9yXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjM5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1tYXgtYW5nbGVcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDQ1LFxuXHRcdHVuaXRzOiBcImRlZ3JlZXNcIixcblx0XHRkb2M6IFwiTWF4aW11bSBhbmdsZSBjaGFuZ2UgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdHtcblx0XHRcdFx0XCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcblx0XHRcdFx0XHRcImxpbmVcIixcblx0XHRcdFx0XHRcImxpbmUtY2VudGVyXCJcblx0XHRcdFx0XVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC13cml0aW5nLW1vZGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRob3Jpem9udGFsOiB7XG5cdFx0XHRcdGRvYzogXCJJZiBhIHRleHQncyBsYW5ndWFnZSBzdXBwb3J0cyBob3Jpem9udGFsIHdyaXRpbmcgbW9kZSwgc3ltYm9scyB3aXRoIHBvaW50IHBsYWNlbWVudCB3b3VsZCBiZSBsYWlkIG91dCBob3Jpem9udGFsbHkuXCJcblx0XHRcdH0sXG5cdFx0XHR2ZXJ0aWNhbDoge1xuXHRcdFx0XHRkb2M6IFwiSWYgYSB0ZXh0J3MgbGFuZ3VhZ2Ugc3VwcG9ydHMgdmVydGljYWwgd3JpdGluZyBtb2RlLCBzeW1ib2xzIHdpdGggcG9pbnQgcGxhY2VtZW50IHdvdWxkIGJlIGxhaWQgb3V0IHZlcnRpY2FsbHkuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJUaGUgcHJvcGVydHkgYWxsb3dzIGNvbnRyb2wgb3ZlciBhIHN5bWJvbCdzIG9yaWVudGF0aW9uLiBOb3RlIHRoYXQgdGhlIHByb3BlcnR5IHZhbHVlcyBhY3QgYXMgYSBoaW50LCBzbyB0aGF0IGEgc3ltYm9sIHdob3NlIGxhbmd1YWdlIGRvZXNu4oCZdCBzdXBwb3J0IHRoZSBwcm92aWRlZCBvcmllbnRhdGlvbiB3aWxsIGJlIGxhaWQgb3V0IGluIGl0cyBuYXR1cmFsIG9yaWVudGF0aW9uLiBFeGFtcGxlOiBFbmdsaXNoIHBvaW50IHN5bWJvbCB3aWxsIGJlIHJlbmRlcmVkIGhvcml6b250YWxseSBldmVuIGlmIGFycmF5IHZhbHVlIGNvbnRhaW5zIHNpbmdsZSAndmVydGljYWwnIGVudW0gdmFsdWUuIFRoZSBvcmRlciBvZiBlbGVtZW50cyBpbiBhbiBhcnJheSBkZWZpbmUgcHJpb3JpdHkgb3JkZXIgZm9yIHRoZSBwbGFjZW1lbnQgb2YgYW4gb3JpZW50YXRpb24gdmFyaWFudC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG5cdFx0XHRcdFx0XCJwb2ludFwiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMS4zLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI4LjMuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNS4zLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXJvdGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRwZXJpb2Q6IDM2MCxcblx0XHR1bml0czogXCJkZWdyZWVzXCIsXG5cdFx0ZG9jOiBcIlJvdGF0ZXMgdGhlIHRleHQgY2xvY2t3aXNlLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzUuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtcGFkZGluZ1wiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYXJvdW5kIHRoZSB0ZXh0IGJvdW5kaW5nIGJveCB1c2VkIGZvciBkZXRlY3Rpbmcgc3ltYm9sIGNvbGxpc2lvbnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LWtlZXAtdXByaWdodFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IHRydWUsXG5cdFx0ZG9jOiBcIklmIHRydWUsIHRoZSB0ZXh0IG1heSBiZSBmbGlwcGVkIHZlcnRpY2FsbHkgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdHtcblx0XHRcdFx0XCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRcInN5bWJvbC1wbGFjZW1lbnRcIjogW1xuXHRcdFx0XHRcdFwibGluZVwiLFxuXHRcdFx0XHRcdFwibGluZS1jZW50ZXJcIlxuXHRcdFx0XHRdXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC10cmFuc2Zvcm1cIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRleHQgaXMgbm90IGFsdGVyZWQuXCJcblx0XHRcdH0sXG5cdFx0XHR1cHBlcmNhc2U6IHtcblx0XHRcdFx0ZG9jOiBcIkZvcmNlcyBhbGwgbGV0dGVycyB0byBiZSBkaXNwbGF5ZWQgaW4gdXBwZXJjYXNlLlwiXG5cdFx0XHR9LFxuXHRcdFx0bG93ZXJjYXNlOiB7XG5cdFx0XHRcdGRvYzogXCJGb3JjZXMgYWxsIGxldHRlcnMgdG8gYmUgZGlzcGxheWVkIGluIGxvd2VyY2FzZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibm9uZVwiLFxuXHRcdGRvYzogXCJTcGVjaWZpZXMgaG93IHRvIGNhcGl0YWxpemUgdGV4dCwgc2ltaWxhciB0byB0aGUgQ1NTIGB0ZXh0LXRyYW5zZm9ybWAgcHJvcGVydHkuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtb2Zmc2V0XCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0ZG9jOiBcIk9mZnNldCBkaXN0YW5jZSBvZiB0ZXh0IGZyb20gaXRzIGFuY2hvci4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuIElmIHVzZWQgd2l0aCB0ZXh0LXZhcmlhYmxlLWFuY2hvciwgaW5wdXQgdmFsdWVzIHdpbGwgYmUgdGFrZW4gYXMgYWJzb2x1dGUgdmFsdWVzLiBPZmZzZXRzIGFsb25nIHRoZSB4LSBhbmQgeS1heGlzIHdpbGwgYmUgYXBwbGllZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoZSBhbmNob3IgcG9zaXRpb24uXCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0dW5pdHM6IFwiZW1zXCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MFxuXHRcdF0sXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJ0ZXh0LXJhZGlhbC1vZmZzZXRcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzUuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtYWxsb3ctb3ZlcmxhcFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCB0aGUgdGV4dCB3aWxsIGJlIHZpc2libGUgZXZlbiBpZiBpdCBjb2xsaWRlcyB3aXRoIG90aGVyIHByZXZpb3VzbHkgZHJhd24gc3ltYm9scy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiSWYgdHJ1ZSwgb3RoZXIgc3ltYm9scyBjYW4gYmUgdmlzaWJsZSBldmVuIGlmIHRoZXkgY29sbGlkZSB3aXRoIHRoZSB0ZXh0LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtb3B0aW9uYWxcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiSWYgdHJ1ZSwgaWNvbnMgd2lsbCBkaXNwbGF5IHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyB0ZXh0IHdoZW4gdGhlIHRleHQgY29sbGlkZXMgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCB0aGUgaWNvbiBkb2VzIG5vdC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHR2aXNpYmlsaXR5OiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2aXNpYmxlOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcblx0XHRcdH0sXG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIGxheW91dF9yYXN0ZXIgPSB7XG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn07XG52YXIgbGF5b3V0X2hpbGxzaGFkZSA9IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBmaWx0ZXIgPSB7XG5cdHR5cGU6IFwiYXJyYXlcIixcblx0dmFsdWU6IFwiKlwiLFxuXHRkb2M6IFwiQSBmaWx0ZXIgc2VsZWN0cyBzcGVjaWZpYyBmZWF0dXJlcyBmcm9tIGEgbGF5ZXIuXCJcbn07XG52YXIgZmlsdGVyX29wZXJhdG9yID0ge1xuXHR0eXBlOiBcImVudW1cIixcblx0dmFsdWVzOiB7XG5cdFx0XCI9PVwiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiPT1cXFwiLCBrZXksIHZhbHVlXWAgZXF1YWxpdHk6IGBmZWF0dXJlW2tleV0gPSB2YWx1ZWBcIlxuXHRcdH0sXG5cdFx0XCIhPVwiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiIT1cXFwiLCBrZXksIHZhbHVlXWAgaW5lcXVhbGl0eTogYGZlYXR1cmVba2V5XSDiiaAgdmFsdWVgXCJcblx0XHR9LFxuXHRcdFwiPlwiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiPlxcXCIsIGtleSwgdmFsdWVdYCBncmVhdGVyIHRoYW46IGBmZWF0dXJlW2tleV0gPiB2YWx1ZWBcIlxuXHRcdH0sXG5cdFx0XCI+PVwiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiPj1cXFwiLCBrZXksIHZhbHVlXWAgZ3JlYXRlciB0aGFuIG9yIGVxdWFsOiBgZmVhdHVyZVtrZXldIOKJpSB2YWx1ZWBcIlxuXHRcdH0sXG5cdFx0XCI8XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCI8XFxcIiwga2V5LCB2YWx1ZV1gIGxlc3MgdGhhbjogYGZlYXR1cmVba2V5XSA8IHZhbHVlYFwiXG5cdFx0fSxcblx0XHRcIjw9XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCI8PVxcXCIsIGtleSwgdmFsdWVdYCBsZXNzIHRoYW4gb3IgZXF1YWw6IGBmZWF0dXJlW2tleV0g4omkIHZhbHVlYFwiXG5cdFx0fSxcblx0XHRcImluXCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCJpblxcXCIsIGtleSwgdjAsIC4uLiwgdm5dYCBzZXQgaW5jbHVzaW9uOiBgZmVhdHVyZVtrZXldIOKIiCB7djAsIC4uLiwgdm59YFwiXG5cdFx0fSxcblx0XHRcIiFpblwiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiIWluXFxcIiwga2V5LCB2MCwgLi4uLCB2bl1gIHNldCBleGNsdXNpb246IGBmZWF0dXJlW2tleV0g4oiJIHt2MCwgLi4uLCB2bn1gXCJcblx0XHR9LFxuXHRcdGFsbDoge1xuXHRcdFx0ZG9jOiBcImBbXFxcImFsbFxcXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgQU5EYDogYGYwIOKIpyAuLi4g4oinIGZuYFwiXG5cdFx0fSxcblx0XHRhbnk6IHtcblx0XHRcdGRvYzogXCJgW1xcXCJhbnlcXFwiLCBmMCwgLi4uLCBmbl1gIGxvZ2ljYWwgYE9SYDogYGYwIOKIqCAuLi4g4oioIGZuYFwiXG5cdFx0fSxcblx0XHRub25lOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwibm9uZVxcXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgTk9SYDogYMKsZjAg4oinIC4uLiDiiKcgwqxmbmBcIlxuXHRcdH0sXG5cdFx0aGFzOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiaGFzXFxcIiwga2V5XWAgYGZlYXR1cmVba2V5XWAgZXhpc3RzXCJcblx0XHR9LFxuXHRcdFwiIWhhc1wiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiIWhhc1xcXCIsIGtleV1gIGBmZWF0dXJlW2tleV1gIGRvZXMgbm90IGV4aXN0XCJcblx0XHR9XG5cdH0sXG5cdGRvYzogXCJUaGUgZmlsdGVyIG9wZXJhdG9yLlwiXG59O1xudmFyIGdlb21ldHJ5X3R5cGUgPSB7XG5cdHR5cGU6IFwiZW51bVwiLFxuXHR2YWx1ZXM6IHtcblx0XHRQb2ludDoge1xuXHRcdFx0ZG9jOiBcIkZpbHRlciB0byBwb2ludCBnZW9tZXRyaWVzLlwiXG5cdFx0fSxcblx0XHRMaW5lU3RyaW5nOiB7XG5cdFx0XHRkb2M6IFwiRmlsdGVyIHRvIGxpbmUgZ2VvbWV0cmllcy5cIlxuXHRcdH0sXG5cdFx0UG9seWdvbjoge1xuXHRcdFx0ZG9jOiBcIkZpbHRlciB0byBwb2x5Z29uIGdlb21ldHJpZXMuXCJcblx0XHR9XG5cdH0sXG5cdGRvYzogXCJUaGUgZ2VvbWV0cnkgdHlwZSBmb3IgdGhlIGZpbHRlciB0byBzZWxlY3QuXCJcbn07XG52YXIgZnVuY3Rpb25fc3RvcCA9IHtcblx0dHlwZTogXCJhcnJheVwiLFxuXHRtaW5pbXVtOiAwLFxuXHRtYXhpbXVtOiAyNCxcblx0dmFsdWU6IFtcblx0XHRcIm51bWJlclwiLFxuXHRcdFwiY29sb3JcIlxuXHRdLFxuXHRsZW5ndGg6IDIsXG5cdGRvYzogXCJab29tIGxldmVsIGFuZCB2YWx1ZSBwYWlyLlwiXG59O1xudmFyIGV4cHJlc3Npb24gPSB7XG5cdHR5cGU6IFwiYXJyYXlcIixcblx0dmFsdWU6IFwiKlwiLFxuXHRtaW5pbXVtOiAxLFxuXHRkb2M6IFwiQW4gZXhwcmVzc2lvbiBkZWZpbmVzIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGF0YS1kcml2ZW4gc3R5bGUgcHJvcGVydGllcyBvciBmZWF0dXJlIGZpbHRlcnMuXCJcbn07XG52YXIgZXhwcmVzc2lvbl9uYW1lID0ge1xuXHRkb2M6IFwiXCIsXG5cdHR5cGU6IFwiZW51bVwiLFxuXHR2YWx1ZXM6IHtcblx0XHRcImxldFwiOiB7XG5cdFx0XHRkb2M6IFwiQmluZHMgZXhwcmVzc2lvbnMgdG8gbmFtZWQgdmFyaWFibGVzLCB3aGljaCBjYW4gdGhlbiBiZSByZWZlcmVuY2VkIGluIHRoZSByZXN1bHQgZXhwcmVzc2lvbiB1c2luZyBbXFxcInZhclxcXCIsIFxcXCJ2YXJpYWJsZV9uYW1lXFxcIl0uXCIsXG5cdFx0XHRncm91cDogXCJWYXJpYWJsZSBiaW5kaW5nXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInZhclwiOiB7XG5cdFx0XHRkb2M6IFwiUmVmZXJlbmNlcyB2YXJpYWJsZSBib3VuZCB1c2luZyBcXFwibGV0XFxcIi5cIixcblx0XHRcdGdyb3VwOiBcIlZhcmlhYmxlIGJpbmRpbmdcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGxpdGVyYWw6IHtcblx0XHRcdGRvYzogXCJQcm92aWRlcyBhIGxpdGVyYWwgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFycmF5OiB7XG5cdFx0XHRkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCBpcyBhbiBhcnJheSAob3B0aW9uYWxseSB3aXRoIGEgc3BlY2lmaWMgaXRlbSB0eXBlIGFuZCBsZW5ndGgpLiAgSWYsIHdoZW4gdGhlIGlucHV0IGV4cHJlc3Npb24gaXMgZXZhbHVhdGVkLCBpdCBpcyBub3Qgb2YgdGhlIGFzc2VydGVkIHR5cGUsIHRoZW4gdGhpcyBhc3NlcnRpb24gd2lsbCBjYXVzZSB0aGUgd2hvbGUgZXhwcmVzc2lvbiB0byBiZSBhYm9ydGVkLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGF0OiB7XG5cdFx0XHRkb2M6IFwiUmV0cmlldmVzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cIixcblx0XHRcdGdyb3VwOiBcIkxvb2t1cFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJpblwiOiB7XG5cdFx0XHRkb2M6IFwiRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGl0ZW0gZXhpc3RzIGluIGFuIGFycmF5IG9yIGEgc3Vic3RyaW5nIGV4aXN0cyBpbiBhIHN0cmluZy5cIixcblx0XHRcdGdyb3VwOiBcIkxvb2t1cFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMS42LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImluZGV4LW9mXCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIGFuIGFycmF5LCBvciBmb3IgYSBzdHJpbmcsIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBzcGVjaWZpZWQgdmFsdWUuIElmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB0aGVuIHRoZSBzZWFyY2ggaXMgc3RhcnRlZCBmcm9tIHRoYXQgcG9zaXRpb24uIFJldHVybnMgLTEgaWYgdGhlIHZhbHVlIGlzIG5vdCBmb3VuZC5cIixcblx0XHRcdGdyb3VwOiBcIkxvb2t1cFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMS4xMC4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJjYXNlXCI6IHtcblx0XHRcdGRvYzogXCJTZWxlY3RzIHRoZSBmaXJzdCBvdXRwdXQgd2hvc2UgY29ycmVzcG9uZGluZyB0ZXN0IGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZSwgb3IgdGhlIGZhbGxiYWNrIHZhbHVlIG90aGVyd2lzZS5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRtYXRjaDoge1xuXHRcdFx0ZG9jOiBcIlNlbGVjdHMgdGhlIG91dHB1dCB3aG9zZSBsYWJlbCB2YWx1ZSBtYXRjaGVzIHRoZSBpbnB1dCB2YWx1ZSwgb3IgdGhlIGZhbGxiYWNrIHZhbHVlIGlmIG5vIG1hdGNoIGlzIGZvdW5kLiBUaGUgaW5wdXQgY2FuIGJlIGFueSBleHByZXNzaW9uIChlLmcuIGBbXFxcImdldFxcXCIsIFxcXCJidWlsZGluZ190eXBlXFxcIl1gKS4gRWFjaCBsYWJlbCBtdXN0IGJlIGVpdGhlcjpcXG4gKiBhIHNpbmdsZSBsaXRlcmFsIHZhbHVlOyBvclxcbiAqIGFuIGFycmF5IG9mIGxpdGVyYWwgdmFsdWVzLCB3aG9zZSB2YWx1ZXMgbXVzdCBiZSBhbGwgc3RyaW5ncyBvciBhbGwgbnVtYmVycyAoZS5nLiBgWzEwMCwgMTAxXWAgb3IgYFtcXFwiY1xcXCIsIFxcXCJiXFxcIl1gKS4gVGhlIGlucHV0IG1hdGNoZXMgaWYgYW55IG9mIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IG1hdGNoZXMsIHNpbWlsYXIgdG8gdGhlIGBcXFwiaW5cXFwiYCBvcGVyYXRvci5cXG5cXG5FYWNoIGxhYmVsIG11c3QgYmUgdW5pcXVlLiBJZiB0aGUgaW5wdXQgdHlwZSBkb2VzIG5vdCBtYXRjaCB0aGUgdHlwZSBvZiB0aGUgbGFiZWxzLCB0aGUgcmVzdWx0IHdpbGwgYmUgdGhlIGZhbGxiYWNrIHZhbHVlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNvYWxlc2NlOiB7XG5cdFx0XHRkb2M6IFwiRXZhbHVhdGVzIGVhY2ggZXhwcmVzc2lvbiBpbiB0dXJuIHVudGlsIHRoZSBmaXJzdCBub24tbnVsbCB2YWx1ZSBpcyBvYnRhaW5lZCwgYW5kIHJldHVybnMgdGhhdCB2YWx1ZS5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdGVwOiB7XG5cdFx0XHRkb2M6IFwiUHJvZHVjZXMgZGlzY3JldGUsIHN0ZXBwZWQgcmVzdWx0cyBieSBldmFsdWF0aW5nIGEgcGllY2V3aXNlLWNvbnN0YW50IGZ1bmN0aW9uIGRlZmluZWQgYnkgcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFxcXCJzdG9wc1xcXCIpLiBUaGUgYGlucHV0YCBtYXkgYmUgYW55IG51bWVyaWMgZXhwcmVzc2lvbiAoZS5nLiwgYFtcXFwiZ2V0XFxcIiwgXFxcInBvcHVsYXRpb25cXFwiXWApLiBTdG9wIGlucHV0cyBtdXN0IGJlIG51bWVyaWMgbGl0ZXJhbHMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLiBSZXR1cm5zIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhlIHN0b3AganVzdCBsZXNzIHRoYW4gdGhlIGlucHV0LCBvciB0aGUgZmlyc3Qgb3V0cHV0IGlmIHRoZSBpbnB1dCBpcyBsZXNzIHRoYW4gdGhlIGZpcnN0IHN0b3AuXCIsXG5cdFx0XHRncm91cDogXCJSYW1wcywgc2NhbGVzLCBjdXJ2ZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDIuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGludGVycG9sYXRlOiB7XG5cdFx0XHRkb2M6IFwiUHJvZHVjZXMgY29udGludW91cywgc21vb3RoIHJlc3VsdHMgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcXFwic3RvcHNcXFwiKS4gVGhlIGBpbnB1dGAgbWF5IGJlIGFueSBudW1lcmljIGV4cHJlc3Npb24gKGUuZy4sIGBbXFxcImdldFxcXCIsIFxcXCJwb3B1bGF0aW9uXFxcIl1gKS4gU3RvcCBpbnB1dHMgbXVzdCBiZSBudW1lcmljIGxpdGVyYWxzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4gVGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYG51bWJlcmAsIGBhcnJheTxudW1iZXI+YCwgb3IgYGNvbG9yYC5cXG5cXG5JbnRlcnBvbGF0aW9uIHR5cGVzOlxcbi0gYFtcXFwibGluZWFyXFxcIl1gOiBpbnRlcnBvbGF0ZXMgbGluZWFybHkgYmV0d2VlbiB0aGUgcGFpciBvZiBzdG9wcyBqdXN0IGxlc3MgdGhhbiBhbmQganVzdCBncmVhdGVyIHRoYW4gdGhlIGlucHV0Llxcbi0gYFtcXFwiZXhwb25lbnRpYWxcXFwiLCBiYXNlXWA6IGludGVycG9sYXRlcyBleHBvbmVudGlhbGx5IGJldHdlZW4gdGhlIHN0b3BzIGp1c3QgbGVzcyB0aGFuIGFuZCBqdXN0IGdyZWF0ZXIgdGhhbiB0aGUgaW5wdXQuIGBiYXNlYCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgb3V0cHV0IGluY3JlYXNlczogaGlnaGVyIHZhbHVlcyBtYWtlIHRoZSBvdXRwdXQgaW5jcmVhc2UgbW9yZSB0b3dhcmRzIHRoZSBoaWdoIGVuZCBvZiB0aGUgcmFuZ2UuIFdpdGggdmFsdWVzIGNsb3NlIHRvIDEgdGhlIG91dHB1dCBpbmNyZWFzZXMgbGluZWFybHkuXFxuLSBgW1xcXCJjdWJpYy1iZXppZXJcXFwiLCB4MSwgeTEsIHgyLCB5Ml1gOiBpbnRlcnBvbGF0ZXMgdXNpbmcgdGhlIGN1YmljIGJlemllciBjdXJ2ZSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBjb250cm9sIHBvaW50cy5cIixcblx0XHRcdGdyb3VwOiBcIlJhbXBzLCBzY2FsZXMsIGN1cnZlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40Mi4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJpbnRlcnBvbGF0ZS1oY2xcIjoge1xuXHRcdFx0ZG9jOiBcIlByb2R1Y2VzIGNvbnRpbnVvdXMsIHNtb290aCByZXN1bHRzIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBwYWlycyBvZiBpbnB1dCBhbmQgb3V0cHV0IHZhbHVlcyAoXFxcInN0b3BzXFxcIikuIFdvcmtzIGxpa2UgYGludGVycG9sYXRlYCwgYnV0IHRoZSBvdXRwdXQgdHlwZSBtdXN0IGJlIGBjb2xvcmAsIGFuZCB0aGUgaW50ZXJwb2xhdGlvbiBpcyBwZXJmb3JtZWQgaW4gdGhlIEh1ZS1DaHJvbWEtTHVtaW5hbmNlIGNvbG9yIHNwYWNlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiUmFtcHMsIHNjYWxlcywgY3VydmVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ5LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImludGVycG9sYXRlLWxhYlwiOiB7XG5cdFx0XHRkb2M6IFwiUHJvZHVjZXMgY29udGludW91cywgc21vb3RoIHJlc3VsdHMgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcXFwic3RvcHNcXFwiKS4gV29ya3MgbGlrZSBgaW50ZXJwb2xhdGVgLCBidXQgdGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYGNvbG9yYCwgYW5kIHRoZSBpbnRlcnBvbGF0aW9uIGlzIHBlcmZvcm1lZCBpbiB0aGUgQ0lFTEFCIGNvbG9yIHNwYWNlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiUmFtcHMsIHNjYWxlcywgY3VydmVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ5LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsbjI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIG1hdGhlbWF0aWNhbCBjb25zdGFudCBsbigyKS5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHBpOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgbWF0aGVtYXRpY2FsIGNvbnN0YW50IHBpLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZToge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIG1hdGhlbWF0aWNhbCBjb25zdGFudCBlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ0eXBlb2ZcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiB0aGUgZ2l2ZW4gdmFsdWUuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3RyaW5nOiB7XG5cdFx0XHRkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHN0cmluZy4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgc3RyaW5nIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIHN0cmluZ3MsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG51bWJlcjoge1xuXHRcdFx0ZG9jOiBcIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYSBudW1iZXIuIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIG51bWJlciBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGFyZSBudW1iZXJzLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRib29sZWFuOiB7XG5cdFx0XHRkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIGJvb2xlYW4uIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIGJvb2xlYW4gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgYm9vbGVhbnMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG9iamVjdDoge1xuXHRcdFx0ZG9jOiBcIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYW4gb2JqZWN0LiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgYW4gb2JqZWN0IGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIG9iamVjdHMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhIGBjb2xsYXRvcmAgZm9yIHVzZSBpbiBsb2NhbGUtZGVwZW5kZW50IGNvbXBhcmlzb24gb3BlcmF0aW9ucy4gVGhlIGBjYXNlLXNlbnNpdGl2ZWAgYW5kIGBkaWFjcml0aWMtc2Vuc2l0aXZlYCBvcHRpb25zIGRlZmF1bHQgdG8gYGZhbHNlYC4gVGhlIGBsb2NhbGVgIGFyZ3VtZW50IHNwZWNpZmllcyB0aGUgSUVURiBsYW5ndWFnZSB0YWcgb2YgdGhlIGxvY2FsZSB0byB1c2UuIElmIG5vbmUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGxvY2FsZSBpcyB1c2VkLiBJZiB0aGUgcmVxdWVzdGVkIGxvY2FsZSBpcyBub3QgYXZhaWxhYmxlLCB0aGUgYGNvbGxhdG9yYCB3aWxsIHVzZSBhIHN5c3RlbS1kZWZpbmVkIGZhbGxiYWNrIGxvY2FsZS4gVXNlIGByZXNvbHZlZC1sb2NhbGVgIHRvIHRlc3QgdGhlIHJlc3VsdHMgb2YgbG9jYWxlIGZhbGxiYWNrIGJlaGF2aW9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4yLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGZvcm1hdDoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYGZvcm1hdHRlZGAgdGV4dCBjb250YWluaW5nIGFubm90YXRpb25zIGZvciB1c2UgaW4gbWl4ZWQtZm9ybWF0IGB0ZXh0LWZpZWxkYCBlbnRyaWVzLiBGb3IgYSBgdGV4dC1maWVsZGAgZW50cmllcyBvZiBhIHN0cmluZyB0eXBlLCBmb2xsb3dpbmcgb3B0aW9uIG9iamVjdCdzIHByb3BlcnRpZXMgYXJlIHN1cHBvcnRlZDogSWYgc2V0LCB0aGUgYHRleHQtZm9udGAgdmFsdWUgb3ZlcnJpZGVzIHRoZSBmb250IHNwZWNpZmllZCBieSB0aGUgcm9vdCBsYXlvdXQgcHJvcGVydGllcy4gSWYgc2V0LCB0aGUgYGZvbnQtc2NhbGVgIHZhbHVlIHNwZWNpZmllcyBhIHNjYWxpbmcgZmFjdG9yIHJlbGF0aXZlIHRvIHRoZSBgdGV4dC1zaXplYCBzcGVjaWZpZWQgaW4gdGhlIHJvb3QgbGF5b3V0IHByb3BlcnRpZXMuIElmIHNldCwgdGhlIGB0ZXh0LWNvbG9yYCB2YWx1ZSBvdmVycmlkZXMgdGhlIGNvbG9yIHNwZWNpZmllZCBieSB0aGUgcm9vdCBwYWludCBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDguMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi43LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC42LjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjEyLjBcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInRleHQtZm9udFwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40OC4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjcuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjYuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuMTIuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiZm9udC1zY2FsZVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40OC4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjcuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjYuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuMTIuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwidGV4dC1jb2xvclwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMS4zLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjcuMy4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMTAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuMTQuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGltYWdlOiB7XG5cdFx0XHRcdFx0anM6IFwiMS42LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbWFnZToge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYW4gYGltYWdlYCB0eXBlIGZvciB1c2UgaW4gYGljb24taW1hZ2VgLCBgKi1wYXR0ZXJuYCBlbnRyaWVzIGFuZCBhcyBhIHNlY3Rpb24gaW4gdGhlIGBmb3JtYXRgIGV4cHJlc3Npb24uIElmIHNldCwgdGhlIGBpbWFnZWAgYXJndW1lbnQgd2lsbCBjaGVjayB0aGF0IHRoZSByZXF1ZXN0ZWQgaW1hZ2UgZXhpc3RzIGluIHRoZSBzdHlsZSBhbmQgd2lsbCByZXR1cm4gZWl0aGVyIHRoZSByZXNvbHZlZCBpbWFnZSBuYW1lIG9yIGBudWxsYCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBpbWFnZSBpcyBjdXJyZW50bHkgaW4gdGhlIHN0eWxlLiBUaGlzIHZhbGlkYXRpb24gcHJvY2VzcyBpcyBzeW5jaHJvbm91cyBhbmQgcmVxdWlyZXMgdGhlIGltYWdlIHRvIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgc3R5bGUgYmVmb3JlIHJlcXVlc3RpbmcgaXQgaW4gdGhlIGBpbWFnZWAgYXJndW1lbnQuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMS40LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjguNi4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjUuNi4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJudW1iZXItZm9ybWF0XCI6IHtcblx0XHRcdGRvYzogXCJDb252ZXJ0cyB0aGUgaW5wdXQgbnVtYmVyIGludG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gdXNpbmcgdGhlIHByb3ZpZGluZyBmb3JtYXR0aW5nIHJ1bGVzLiBJZiBzZXQsIHRoZSBgbG9jYWxlYCBhcmd1bWVudCBzcGVjaWZpZXMgdGhlIGxvY2FsZSB0byB1c2UsIGFzIGEgQkNQIDQ3IGxhbmd1YWdlIHRhZy4gSWYgc2V0LCB0aGUgYGN1cnJlbmN5YCBhcmd1bWVudCBzcGVjaWZpZXMgYW4gSVNPIDQyMTcgY29kZSB0byB1c2UgZm9yIGN1cnJlbmN5LXN0eWxlIGZvcm1hdHRpbmcuIElmIHNldCwgdGhlIGBtaW4tZnJhY3Rpb24tZGlnaXRzYCBhbmQgYG1heC1mcmFjdGlvbi1kaWdpdHNgIGFyZ3VtZW50cyBzcGVjaWZ5IHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG51bWJlciBvZiBmcmFjdGlvbmFsIGRpZ2l0cyB0byBpbmNsdWRlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNTQuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwidG8tc3RyaW5nXCI6IHtcblx0XHRcdGRvYzogXCJDb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBzdHJpbmcuIElmIHRoZSBpbnB1dCBpcyBgbnVsbGAsIHRoZSByZXN1bHQgaXMgYFxcXCJcXFwiYC4gSWYgdGhlIGlucHV0IGlzIGEgYm9vbGVhbiwgdGhlIHJlc3VsdCBpcyBgXFxcInRydWVcXFwiYCBvciBgXFxcImZhbHNlXFxcImAuIElmIHRoZSBpbnB1dCBpcyBhIG51bWJlciwgaXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGFzIHNwZWNpZmllZCBieSB0aGUgW1xcXCJOdW1iZXJUb1N0cmluZ1xcXCIgYWxnb3JpdGhtXShodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3N0cmluZy1hcHBsaWVkLXRvLXRoZS1udW1iZXItdHlwZSkgb2YgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgU3BlY2lmaWNhdGlvbi4gSWYgdGhlIGlucHV0IGlzIGEgY29sb3IsIGl0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBvZiB0aGUgZm9ybSBgXFxcInJnYmEocixnLGIsYSlcXFwiYCwgd2hlcmUgYHJgLCBgZ2AsIGFuZCBgYmAgYXJlIG51bWVyYWxzIHJhbmdpbmcgZnJvbSAwIHRvIDI1NSwgYW5kIGBhYCByYW5nZXMgZnJvbSAwIHRvIDEuIE90aGVyd2lzZSwgdGhlIGlucHV0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSB0aGUgW2BKU09OLnN0cmluZ2lmeWBdKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5KSBmdW5jdGlvbiBvZiB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwidG8tbnVtYmVyXCI6IHtcblx0XHRcdGRvYzogXCJDb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIsIGlmIHBvc3NpYmxlLiBJZiB0aGUgaW5wdXQgaXMgYG51bGxgIG9yIGBmYWxzZWAsIHRoZSByZXN1bHQgaXMgMC4gSWYgdGhlIGlucHV0IGlzIGB0cnVlYCwgdGhlIHJlc3VsdCBpcyAxLiBJZiB0aGUgaW5wdXQgaXMgYSBzdHJpbmcsIGl0IGlzIGNvbnZlcnRlZCB0byBhIG51bWJlciBhcyBzcGVjaWZpZWQgYnkgdGhlIFtcXFwiVG9OdW1iZXIgQXBwbGllZCB0byB0aGUgU3RyaW5nIFR5cGVcXFwiIGFsZ29yaXRobV0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9udW1iZXItYXBwbGllZC10by10aGUtc3RyaW5nLXR5cGUpIG9mIHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb24uIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCB0aGUgZmlyc3Qgc3VjY2Vzc2Z1bCBjb252ZXJzaW9uIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgY2FuIGJlIGNvbnZlcnRlZCwgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ0by1ib29sZWFuXCI6IHtcblx0XHRcdGRvYzogXCJDb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBib29sZWFuLiBUaGUgcmVzdWx0IGlzIGBmYWxzZWAgd2hlbiB0aGVuIGlucHV0IGlzIGFuIGVtcHR5IHN0cmluZywgMCwgYGZhbHNlYCwgYG51bGxgLCBvciBgTmFOYDsgb3RoZXJ3aXNlIGl0IGlzIGB0cnVlYC5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInRvLXJnYmFcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYSBmb3VyLWVsZW1lbnQgYXJyYXkgY29udGFpbmluZyB0aGUgaW5wdXQgY29sb3IncyByZWQsIGdyZWVuLCBibHVlLCBhbmQgYWxwaGEgY29tcG9uZW50cywgaW4gdGhhdCBvcmRlci5cIixcblx0XHRcdGdyb3VwOiBcIkNvbG9yXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInRvLWNvbG9yXCI6IHtcblx0XHRcdGRvYzogXCJDb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBjb2xvci4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGNvbnZlcnNpb24gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBjYW4gYmUgY29udmVydGVkLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZ2I6IHtcblx0XHRcdGRvYzogXCJDcmVhdGVzIGEgY29sb3IgdmFsdWUgZnJvbSByZWQsIGdyZWVuLCBhbmQgYmx1ZSBjb21wb25lbnRzLCB3aGljaCBtdXN0IHJhbmdlIGJldHdlZW4gMCBhbmQgMjU1LCBhbmQgYW4gYWxwaGEgY29tcG9uZW50IG9mIDEuIElmIGFueSBjb21wb25lbnQgaXMgb3V0IG9mIHJhbmdlLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcblx0XHRcdGdyb3VwOiBcIkNvbG9yXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZ2JhOiB7XG5cdFx0XHRkb2M6IFwiQ3JlYXRlcyBhIGNvbG9yIHZhbHVlIGZyb20gcmVkLCBncmVlbiwgYmx1ZSBjb21wb25lbnRzLCB3aGljaCBtdXN0IHJhbmdlIGJldHdlZW4gMCBhbmQgMjU1LCBhbmQgYW4gYWxwaGEgY29tcG9uZW50IHdoaWNoIG11c3QgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLiBJZiBhbnkgY29tcG9uZW50IGlzIG91dCBvZiByYW5nZSwgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG5cdFx0XHRncm91cDogXCJDb2xvclwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2V0OiB7XG5cdFx0XHRkb2M6IFwiUmV0cmlldmVzIGEgcHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgY3VycmVudCBmZWF0dXJlJ3MgcHJvcGVydGllcywgb3IgZnJvbSBhbm90aGVyIG9iamVjdCBpZiBhIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZC4gUmV0dXJucyBudWxsIGlmIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHkgaXMgbWlzc2luZy5cIixcblx0XHRcdGdyb3VwOiBcIkxvb2t1cFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aGFzOiB7XG5cdFx0XHRkb2M6IFwiVGVzdHMgZm9yIHRoZSBwcmVzZW5jZSBvZiBhbiBwcm9wZXJ0eSB2YWx1ZSBpbiB0aGUgY3VycmVudCBmZWF0dXJlJ3MgcHJvcGVydGllcywgb3IgZnJvbSBhbm90aGVyIG9iamVjdCBpZiBhIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZC5cIixcblx0XHRcdGdyb3VwOiBcIkxvb2t1cFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bGVuZ3RoOiB7XG5cdFx0XHRkb2M6IFwiR2V0cyB0aGUgbGVuZ3RoIG9mIGFuIGFycmF5IG9yIHN0cmluZy5cIixcblx0XHRcdGdyb3VwOiBcIkxvb2t1cFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cHJvcGVydGllczoge1xuXHRcdFx0ZG9jOiBcIkdldHMgdGhlIGZlYXR1cmUgcHJvcGVydGllcyBvYmplY3QuICBOb3RlIHRoYXQgaW4gc29tZSBjYXNlcywgaXQgbWF5IGJlIG1vcmUgZWZmaWNpZW50IHRvIHVzZSBbXFxcImdldFxcXCIsIFxcXCJwcm9wZXJ0eV9uYW1lXFxcIl0gZGlyZWN0bHkuXCIsXG5cdFx0XHRncm91cDogXCJGZWF0dXJlIGRhdGFcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZmVhdHVyZS1zdGF0ZVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0cmlldmVzIGEgcHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgY3VycmVudCBmZWF0dXJlJ3Mgc3RhdGUuIFJldHVybnMgbnVsbCBpZiB0aGUgcmVxdWVzdGVkIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IG9uIHRoZSBmZWF0dXJlJ3Mgc3RhdGUuIEEgZmVhdHVyZSdzIHN0YXRlIGlzIG5vdCBwYXJ0IG9mIHRoZSBHZW9KU09OIG9yIHZlY3RvciB0aWxlIGRhdGEsIGFuZCBtdXN0IGJlIHNldCBwcm9ncmFtbWF0aWNhbGx5IG9uIGVhY2ggZmVhdHVyZS4gRmVhdHVyZXMgYXJlIGlkZW50aWZpZWQgYnkgdGhlaXIgYGlkYCBhdHRyaWJ1dGUsIHdoaWNoIG11c3QgYmUgYW4gaW50ZWdlciBvciBhIHN0cmluZyB0aGF0IGNhbiBiZSBjYXN0IHRvIGFuIGludGVnZXIuIE5vdGUgdGhhdCBbXFxcImZlYXR1cmUtc3RhdGVcXFwiXSBjYW4gb25seSBiZSB1c2VkIHdpdGggcGFpbnQgcHJvcGVydGllcyB0aGF0IHN1cHBvcnQgZGF0YS1kcml2ZW4gc3R5bGluZy5cIixcblx0XHRcdGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40Ni4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJnZW9tZXRyeS10eXBlXCI6IHtcblx0XHRcdGRvYzogXCJHZXRzIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkgdHlwZTogUG9pbnQsIE11bHRpUG9pbnQsIExpbmVTdHJpbmcsIE11bHRpTGluZVN0cmluZywgUG9seWdvbiwgTXVsdGlQb2x5Z29uLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpZDoge1xuXHRcdFx0ZG9jOiBcIkdldHMgdGhlIGZlYXR1cmUncyBpZCwgaWYgaXQgaGFzIG9uZS5cIixcblx0XHRcdGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0em9vbToge1xuXHRcdFx0ZG9jOiBcIkdldHMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbC4gIE5vdGUgdGhhdCBpbiBzdHlsZSBsYXlvdXQgYW5kIHBhaW50IHByb3BlcnRpZXMsIFtcXFwiem9vbVxcXCJdIG1heSBvbmx5IGFwcGVhciBhcyB0aGUgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgXFxcInN0ZXBcXFwiIG9yIFxcXCJpbnRlcnBvbGF0ZVxcXCIgZXhwcmVzc2lvbi5cIixcblx0XHRcdGdyb3VwOiBcIlpvb21cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiaGVhdG1hcC1kZW5zaXR5XCI6IHtcblx0XHRcdGRvYzogXCJHZXRzIHRoZSBrZXJuZWwgZGVuc2l0eSBlc3RpbWF0aW9uIG9mIGEgcGl4ZWwgaW4gYSBoZWF0bWFwIGxheWVyLCB3aGljaCBpcyBhIHJlbGF0aXZlIG1lYXN1cmUgb2YgaG93IG1hbnkgZGF0YSBwb2ludHMgYXJlIGNyb3dkZWQgYXJvdW5kIGEgcGFydGljdWxhciBwaXhlbC4gQ2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgYGhlYXRtYXAtY29sb3JgIHByb3BlcnR5LlwiLFxuXHRcdFx0Z3JvdXA6IFwiSGVhdG1hcFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJsaW5lLXByb2dyZXNzXCI6IHtcblx0XHRcdGRvYzogXCJHZXRzIHRoZSBwcm9ncmVzcyBhbG9uZyBhIGdyYWRpZW50IGxpbmUuIENhbiBvbmx5IGJlIHVzZWQgaW4gdGhlIGBsaW5lLWdyYWRpZW50YCBwcm9wZXJ0eS5cIixcblx0XHRcdGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjYuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuMTIuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFjY3VtdWxhdGVkOiB7XG5cdFx0XHRkb2M6IFwiR2V0cyB0aGUgdmFsdWUgb2YgYSBjbHVzdGVyIHByb3BlcnR5IGFjY3VtdWxhdGVkIHNvIGZhci4gQ2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgYGNsdXN0ZXJQcm9wZXJ0aWVzYCBvcHRpb24gb2YgYSBjbHVzdGVyZWQgR2VvSlNPTiBzb3VyY2UuXCIsXG5cdFx0XHRncm91cDogXCJGZWF0dXJlIGRhdGFcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNTMuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiK1wiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgc3VtIG9mIHRoZSBpbnB1dHMuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIipcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhlIGlucHV0cy5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiLVwiOiB7XG5cdFx0XHRkb2M6IFwiRm9yIHR3byBpbnB1dHMsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGluZyB0aGUgc2Vjb25kIGlucHV0IGZyb20gdGhlIGZpcnN0LiBGb3IgYSBzaW5nbGUgaW5wdXQsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGluZyBpdCBmcm9tIDAuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIi9cIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIHJlc3VsdCBvZiBmbG9hdGluZyBwb2ludCBkaXZpc2lvbiBvZiB0aGUgZmlyc3QgaW5wdXQgYnkgdGhlIHNlY29uZC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiJVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgcmVtYWluZGVyIGFmdGVyIGludGVnZXIgZGl2aXNpb24gb2YgdGhlIGZpcnN0IGlucHV0IGJ5IHRoZSBzZWNvbmQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIl5cIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIHJlc3VsdCBvZiByYWlzaW5nIHRoZSBmaXJzdCBpbnB1dCB0byB0aGUgcG93ZXIgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzcXJ0OiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40Mi4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bG9nMTA6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBiYXNlLXRlbiBsb2dhcml0aG0gb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bG46IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsb2cyOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgYmFzZS10d28gbG9nYXJpdGhtIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNpbjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIHNpbmUgb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29zOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgY29zaW5lIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHRhbjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIHRhbmdlbnQgb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXNpbjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGFyY3NpbmUgb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YWNvczoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGFyY2Nvc2luZSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhdGFuOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgYXJjdGFuZ2VudCBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRtaW46IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBpbnB1dHMuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRtYXg6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBpbnB1dHMuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyb3VuZDoge1xuXHRcdFx0ZG9jOiBcIlJvdW5kcyB0aGUgaW5wdXQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4gSGFsZndheSB2YWx1ZXMgYXJlIHJvdW5kZWQgYXdheSBmcm9tIHplcm8uIEZvciBleGFtcGxlLCBgW1xcXCJyb3VuZFxcXCIsIC0xLjVdYCBldmFsdWF0ZXMgdG8gLTIuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhYnM6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjZWlsOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgc21hbGxlc3QgaW50ZWdlciB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRmbG9vcjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGxhcmdlc3QgaW50ZWdlciB0aGF0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIj09XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBjb21wYXJpc29uIGlzIHN0cmljdGx5IHR5cGVkOiB2YWx1ZXMgb2YgZGlmZmVyZW50IHJ1bnRpbWUgdHlwZXMgYXJlIGFsd2F5cyBjb25zaWRlcmVkIHVuZXF1YWwuIENhc2VzIHdoZXJlIHRoZSB0eXBlcyBhcmUga25vd24gdG8gYmUgZGlmZmVyZW50IGF0IHBhcnNlIHRpbWUgYXJlIGNvbnNpZGVyZWQgaW52YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIhPVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgbm90IGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGNvbXBhcmlzb24gaXMgc3RyaWN0bHkgdHlwZWQ6IHZhbHVlcyBvZiBkaWZmZXJlbnQgcnVudGltZSB0eXBlcyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQgdW5lcXVhbC4gQ2FzZXMgd2hlcmUgdGhlIHR5cGVzIGFyZSBrbm93biB0byBiZSBkaWZmZXJlbnQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbnZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29sbGF0b3I6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIj5cIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBpbnB1dCBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gdGhlIHNlY29uZCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBhcmd1bWVudHMgYXJlIHJlcXVpcmVkIHRvIGJlIGVpdGhlciBib3RoIHN0cmluZ3Mgb3IgYm90aCBudW1iZXJzOyBpZiBkdXJpbmcgZXZhbHVhdGlvbiB0aGV5IGFyZSBub3QsIGV4cHJlc3Npb24gZXZhbHVhdGlvbiBwcm9kdWNlcyBhbiBlcnJvci4gQ2FzZXMgd2hlcmUgdGhpcyBjb25zdHJhaW50IGlzIGtub3duIG5vdCB0byBob2xkIGF0IHBhcnNlIHRpbWUgYXJlIGNvbnNpZGVyZWQgaW4gdmFsaWQgYW5kIHdpbGwgcHJvZHVjZSBhIHBhcnNlIGVycm9yLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGBjb2xsYXRvcmAgYXJndW1lbnQgdG8gY29udHJvbCBsb2NhbGUtZGVwZW5kZW50IHN0cmluZyBjb21wYXJpc29ucy5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb2xsYXRvcjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4yLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiPFwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIHN0cmljdGx5IGxlc3MgdGhhbiB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI+PVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI8PVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YWxsOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIHRoZSBpbnB1dHMgYXJlIGB0cnVlYCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBpbnB1dHMgYXJlIGV2YWx1YXRlZCBpbiBvcmRlciwgYW5kIGV2YWx1YXRpb24gaXMgc2hvcnQtY2lyY3VpdGluZzogb25jZSBhbiBpbnB1dCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBgZmFsc2VgLCB0aGUgcmVzdWx0IGlzIGBmYWxzZWAgYW5kIG5vIGZ1cnRoZXIgaW5wdXQgZXhwcmVzc2lvbnMgYXJlIGV2YWx1YXRlZC5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbnk6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiBhbnkgb2YgdGhlIGlucHV0cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGlucHV0cyBhcmUgZXZhbHVhdGVkIGluIG9yZGVyLCBhbmQgZXZhbHVhdGlvbiBpcyBzaG9ydC1jaXJjdWl0aW5nOiBvbmNlIGFuIGlucHV0IGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGB0cnVlYCwgdGhlIHJlc3VsdCBpcyBgdHJ1ZWAgYW5kIG5vIGZ1cnRoZXIgaW5wdXQgZXhwcmVzc2lvbnMgYXJlIGV2YWx1YXRlZC5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIiFcIjoge1xuXHRcdFx0ZG9jOiBcIkxvZ2ljYWwgbmVnYXRpb24uIFJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCBpcyBgZmFsc2VgLCBhbmQgYGZhbHNlYCBpZiB0aGUgaW5wdXQgaXMgYHRydWVgLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHdpdGhpbjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBmZWF0dXJlIGJlaW5nIGV2YWx1YXRlZCBpcyBpbnNpZGUgdGhlIHByZS1kZWZpbmVkIGdlb21ldHJ5IGJvdW5kYXJ5LCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGV4cHJlc3Npb24gaGFzIG9uZSBhcmd1bWVudCB3aGljaCBtdXN0IGJlIGEgdmFsaWQgR2VvSlNPTiBQb2x5Z29uL011bHRpLVBvbHlnb24gb2JqZWN0LiBUaGUgZXhwcmVzc2lvbiBvbmx5IGV2YWx1YXRlcyBvbiBgUG9pbnRgIG9yIGBMaW5lU3RyaW5nYCBmZWF0dXJlLiBGb3IgYFBvaW50YCBmZWF0dXJlLCBUaGUgZXhwcmVzc2lvbiB3aWxsIHJldHVybiBmYWxzZSBpZiBhbnkgcG9pbnQgb2YgdGhlIGZlYXR1cmUgaXMgb24gdGhlIGJvdW5kYXJ5IG9yIG91dHNpZGUgdGhlIGJvdW5kYXJ5LiBGb3IgYExpbmVTdHJpbmdgIGZlYXR1cmUsIHRoZSBleHByZXNzaW9uIHdpbGwgcmV0dXJuIGZhbHNlIGlmIHRoZSBsaW5lIGlzIGZ1bGx5IG91dHNpZGUgdGhlIGJvdW5kYXJ5LCBvciB0aGUgbGluZSBpcyBwYXJ0aWFsbHkgaW50ZXJzZWN0aW5nIHRoZSBib3VuZGFyeSwgd2hpY2ggbWVhbnMgZWl0aGVyIHBhcnQgb2YgdGhlIGxpbmUgaXMgb3V0c2lkZSBvZiB0aGUgYm91bmRhcnksIG9yIGVuZCBwb2ludCBvZiB0aGUgbGluZSBsaWVzIG9uIHRoZSBib3VuZGFyeS5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiaXMtc3VwcG9ydGVkLXNjcmlwdFwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IHN0cmluZyBpcyBleHBlY3RlZCB0byByZW5kZXIgbGVnaWJseS4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBpbnB1dCBzdHJpbmcgY29udGFpbnMgc2VjdGlvbnMgdGhhdCBjYW5ub3QgYmUgcmVuZGVyZWQgd2l0aG91dCBwb3RlbnRpYWwgbG9zcyBvZiBtZWFuaW5nIChlLmcuIEluZGljIHNjcmlwdHMgdGhhdCByZXF1aXJlIGNvbXBsZXggdGV4dCBzaGFwaW5nLCBvciByaWdodC10by1sZWZ0IHNjcmlwdHMgaWYgdGhlIHRoZSBgbWFwYm94LWdsLXJ0bC10ZXh0YCBwbHVnaW4gaXMgbm90IGluIHVzZSBpbiBNYXBib3ggR0wgSlMpLlwiLFxuXHRcdFx0Z3JvdXA6IFwiU3RyaW5nXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNi4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dXBjYXNlOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgaW5wdXQgc3RyaW5nIGNvbnZlcnRlZCB0byB1cHBlcmNhc2UuIEZvbGxvd3MgdGhlIFVuaWNvZGUgRGVmYXVsdCBDYXNlIENvbnZlcnNpb24gYWxnb3JpdGhtIGFuZCB0aGUgbG9jYWxlLWluc2Vuc2l0aXZlIGNhc2UgbWFwcGluZ3MgaW4gdGhlIFVuaWNvZGUgQ2hhcmFjdGVyIERhdGFiYXNlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiU3RyaW5nXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb3duY2FzZToge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGlucHV0IHN0cmluZyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLiBGb2xsb3dzIHRoZSBVbmljb2RlIERlZmF1bHQgQ2FzZSBDb252ZXJzaW9uIGFsZ29yaXRobSBhbmQgdGhlIGxvY2FsZS1pbnNlbnNpdGl2ZSBjYXNlIG1hcHBpbmdzIGluIHRoZSBVbmljb2RlIENoYXJhY3RlciBEYXRhYmFzZS5cIixcblx0XHRcdGdyb3VwOiBcIlN0cmluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29uY2F0OiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhIGBzdHJpbmdgIGNvbnNpc3Rpbmcgb2YgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIGlucHV0cy4gRWFjaCBpbnB1dCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgYXMgaWYgYnkgYHRvLXN0cmluZ2AuXCIsXG5cdFx0XHRncm91cDogXCJTdHJpbmdcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicmVzb2x2ZWQtbG9jYWxlXCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBJRVRGIGxhbmd1YWdlIHRhZyBvZiB0aGUgbG9jYWxlIGJlaW5nIHVzZWQgYnkgdGhlIHByb3ZpZGVkIGBjb2xsYXRvcmAuIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IHN5c3RlbSBsb2NhbGUsIG9yIHRvIGRldGVybWluZSBpZiBhIHJlcXVlc3RlZCBsb2NhbGUgd2FzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXCIsXG5cdFx0XHRncm91cDogXCJTdHJpbmdcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4yLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNsaWNlOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhIHBvcnRpb24gb2YgYSBzdHJpbmcgb3IgYW4gYXJyYXkgc3RhcnRpbmcgZnJvbSB0aGUgcHJvdmlkZWQgYmVnaW5uaW5nIGluZGV4LiBJZiBhIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZCwgdGhlbiB0aGUgcmV0dXJuIHBvcnRpb24gd2lsbCBydW4gdG8sIGJ1dCBub3QgaW5jbHVkZSwgdGhlIGVuZCBpbmRleC5cIixcblx0XHRcdGdyb3VwOiBcIlN0cmluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMS4xMC4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbnZhciBsaWdodCA9IHtcblx0YW5jaG9yOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgaXMgYWxpZ25lZCB0byB0aGUgcm90YXRpb24gb2YgdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSBpcyBhbGlnbmVkIHRvIHRoZSByb3RhdGlvbiBvZiB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0ZG9jOiBcIldoZXRoZXIgZXh0cnVkZWQgZ2VvbWV0cmllcyBhcmUgbGl0IHJlbGF0aXZlIHRvIHRoZSBtYXAgb3Igdmlld3BvcnQuXCIsXG5cdFx0ZXhhbXBsZTogXCJtYXBcIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRwb3NpdGlvbjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MS4xNSxcblx0XHRcdDIxMCxcblx0XHRcdDMwXG5cdFx0XSxcblx0XHRsZW5ndGg6IDMsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgcmVsYXRpdmUgdG8gbGl0IChleHRydWRlZCkgZ2VvbWV0cmllcywgaW4gW3IgcmFkaWFsIGNvb3JkaW5hdGUsIGEgYXppbXV0aGFsIGFuZ2xlLCBwIHBvbGFyIGFuZ2xlXSB3aGVyZSByIGluZGljYXRlcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBiYXNlIG9mIGFuIG9iamVjdCB0byBpdHMgbGlnaHQsIGEgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGlnaHQgcmVsYXRpdmUgdG8gMMKwICgwwrAgd2hlbiBgbGlnaHQuYW5jaG9yYCBpcyBzZXQgdG8gYHZpZXdwb3J0YCBjb3JyZXNwb25kcyB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydCwgb3IgMMKwIHdoZW4gYGxpZ2h0LmFuY2hvcmAgaXMgc2V0IHRvIGBtYXBgIGNvcnJlc3BvbmRzIHRvIGR1ZSBub3J0aCwgYW5kIGRlZ3JlZXMgcHJvY2VlZCBjbG9ja3dpc2UpLCBhbmQgcCBpbmRpY2F0ZXMgdGhlIGhlaWdodCBvZiB0aGUgbGlnaHQgKGZyb20gMMKwLCBkaXJlY3RseSBhYm92ZSwgdG8gMTgwwrAsIGRpcmVjdGx5IGJlbG93KS5cIixcblx0XHRleGFtcGxlOiBbXG5cdFx0XHQxLjUsXG5cdFx0XHQ5MCxcblx0XHRcdDgwXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRjb2xvcjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiI2ZmZmZmZlwiLFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIkNvbG9yIHRpbnQgZm9yIGxpZ2h0aW5nIGV4dHJ1ZGVkIGdlb21ldHJpZXMuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aW50ZW5zaXR5OiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAuNSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiSW50ZW5zaXR5IG9mIGxpZ2h0aW5nIChvbiBhIHNjYWxlIGZyb20gMCB0byAxKS4gSGlnaGVyIG51bWJlcnMgd2lsbCBwcmVzZW50IGFzIG1vcmUgZXh0cmVtZSBjb250cmFzdC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xudmFyIHBhaW50ID0gW1xuXHRcInBhaW50X2ZpbGxcIixcblx0XCJwYWludF9saW5lXCIsXG5cdFwicGFpbnRfY2lyY2xlXCIsXG5cdFwicGFpbnRfaGVhdG1hcFwiLFxuXHRcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCIsXG5cdFwicGFpbnRfc3ltYm9sXCIsXG5cdFwicGFpbnRfcmFzdGVyXCIsXG5cdFwicGFpbnRfaGlsbHNoYWRlXCIsXG5cdFwicGFpbnRfYmFja2dyb3VuZFwiXG5dO1xudmFyIHBhaW50X2ZpbGwgPSB7XG5cdFwiZmlsbC1hbnRpYWxpYXNcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiB0cnVlLFxuXHRcdGRvYzogXCJXaGV0aGVyIG9yIG5vdCB0aGUgZmlsbCBzaG91bGQgYmUgYW50aWFsaWFzZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImZpbGwtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBlbnRpcmUgZmlsbCBsYXllci4gSW4gY29udHJhc3QgdG8gdGhlIGBmaWxsLWNvbG9yYCwgdGhpcyB2YWx1ZSB3aWxsIGFsc28gYWZmZWN0IHRoZSAxcHggc3Ryb2tlIGFyb3VuZCB0aGUgZmlsbCwgaWYgdGhlIHN0cm9rZSBpcyB1c2VkLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJmaWxsLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIGZpbGxlZCBwYXJ0IG9mIHRoaXMgbGF5ZXIuIFRoaXMgY29sb3IgY2FuIGJlIHNwZWNpZmllZCBhcyBgcmdiYWAgd2l0aCBhbiBhbHBoYSBjb21wb25lbnQgYW5kIHRoZSBjb2xvcidzIG9wYWNpdHkgd2lsbCBub3QgYWZmZWN0IHRoZSBvcGFjaXR5IG9mIHRoZSAxcHggc3Ryb2tlLCBpZiBpdCBpcyB1c2VkLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjE5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiZmlsbC1vdXRsaW5lLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0ZG9jOiBcIlRoZSBvdXRsaW5lIGNvbG9yIG9mIHRoZSBmaWxsLiBNYXRjaGVzIHRoZSB2YWx1ZSBvZiBgZmlsbC1jb2xvcmAgaWYgdW5zcGVjaWZpZWQuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJmaWxsLXBhdHRlcm5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0XCJmaWxsLWFudGlhbGlhc1wiOiB0cnVlXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4xOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImZpbGwtdHJhbnNsYXRlXCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MFxuXHRcdF0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgZmlsbCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGZpbGwgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgZmlsbC10cmFuc2xhdGVgLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImZpbGwtdHJhbnNsYXRlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJmaWxsLXBhdHRlcm5cIjoge1xuXHRcdHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBmaWxscy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG5cdH1cbn07XG52YXIgcGFpbnRfbGluZSA9IHtcblx0XCJsaW5lLW9wYWNpdHlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBsaW5lIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSBsaW5lIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjIzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS10cmFuc2xhdGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsaW5lIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGluZSBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBsaW5lLXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwibGluZS10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImxpbmUtd2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJTdHJva2UgdGhpY2tuZXNzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjM5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS1nYXAtd2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHRkb2M6IFwiRHJhd3MgYSBsaW5lIGNhc2luZyBvdXRzaWRlIG9mIGEgbGluZSdzIGFjdHVhbCBwYXRoLiBWYWx1ZSBpbmRpY2F0ZXMgdGhlIHdpZHRoIG9mIHRoZSBpbm5lciBnYXAuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtb2Zmc2V0XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdGRvYzogXCJUaGUgbGluZSdzIG9mZnNldC4gRm9yIGxpbmVhciBmZWF0dXJlcywgYSBwb3NpdGl2ZSB2YWx1ZSBvZmZzZXRzIHRoZSBsaW5lIHRvIHRoZSByaWdodCwgcmVsYXRpdmUgdG8gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGluZSwgYW5kIGEgbmVnYXRpdmUgdmFsdWUgdG8gdGhlIGxlZnQuIEZvciBwb2x5Z29uIGZlYXR1cmVzLCBhIHBvc2l0aXZlIHZhbHVlIHJlc3VsdHMgaW4gYW4gaW5zZXQsIGFuZCBhIG5lZ2F0aXZlIHZhbHVlIHJlc3VsdHMgaW4gYW4gb3V0c2V0LlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEyLjFcIixcblx0XHRcdFx0YW5kcm9pZDogXCIzLjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy4xLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLWJsdXJcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJCbHVyIGFwcGxpZWQgdG8gdGhlIGxpbmUsIGluIHBpeGVscy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtZGFzaGFycmF5XCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlNwZWNpZmllcyB0aGUgbGVuZ3RocyBvZiB0aGUgYWx0ZXJuYXRpbmcgZGFzaGVzIGFuZCBnYXBzIHRoYXQgZm9ybSB0aGUgZGFzaCBwYXR0ZXJuLiBUaGUgbGVuZ3RocyBhcmUgbGF0ZXIgc2NhbGVkIGJ5IHRoZSBsaW5lIHdpZHRoLiBUbyBjb252ZXJ0IGEgZGFzaCBsZW5ndGggdG8gcGl4ZWxzLCBtdWx0aXBseSB0aGUgbGVuZ3RoIGJ5IHRoZSBjdXJyZW50IGxpbmUgd2lkdGguIE5vdGUgdGhhdCBHZW9KU09OIHNvdXJjZXMgd2l0aCBgbGluZU1ldHJpY3M6IHRydWVgIHNwZWNpZmllZCB3b24ndCByZW5kZXIgZGFzaGVkIGxpbmVzIHRvIHRoZSBleHBlY3RlZCBzY2FsZS4gQWxzbyBub3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLlwiLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJsaW5lIHdpZHRoc1wiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcImxpbmUtcGF0dGVyblwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZFwiXG5cdH0sXG5cdFwibGluZS1wYXR0ZXJuXCI6IHtcblx0XHR0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgbGluZXMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40OS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMS4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLWdyYWRpZW50XCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0ZG9jOiBcIkRlZmluZXMgYSBncmFkaWVudCB3aXRoIHdoaWNoIHRvIGNvbG9yIGEgbGluZSBmZWF0dXJlLiBDYW4gb25seSBiZSB1c2VkIHdpdGggR2VvSlNPTiBzb3VyY2VzIHRoYXQgc3BlY2lmeSBgXFxcImxpbmVNZXRyaWNzXFxcIjogdHJ1ZWAuXCIsXG5cdFx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwibGluZS1kYXNoYXJyYXlcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHNvdXJjZTogXCJnZW9qc29uXCIsXG5cdFx0XHRcdGhhczoge1xuXHRcdFx0XHRcdGxpbmVNZXRyaWNzOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJsaW5lLXByb2dyZXNzXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbG9yLXJhbXBcIlxuXHR9XG59O1xudmFyIHBhaW50X2NpcmNsZSA9IHtcblx0XCJjaXJjbGUtcmFkaXVzXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiA1LFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiQ2lyY2xlIHJhZGl1cy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4xOC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImNpcmNsZS1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIGZpbGwgY29sb3Igb2YgdGhlIGNpcmNsZS5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjE4LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiY2lyY2xlLWJsdXJcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0ZG9jOiBcIkFtb3VudCB0byBibHVyIHRoZSBjaXJjbGUuIDEgYmx1cnMgdGhlIGNpcmNsZSBzdWNoIHRoYXQgb25seSB0aGUgY2VudGVycG9pbnQgaXMgZnVsbCBvcGFjaXR5LlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJjaXJjbGUtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGNpcmNsZSB3aWxsIGJlIGRyYXduLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjIwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiY2lyY2xlLXRyYW5zbGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogMixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgY2lyY2xlIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgY2lyY2xlIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiQ29udHJvbHMgdGhlIGZyYW1lIG9mIHJlZmVyZW5jZSBmb3IgYGNpcmNsZS10cmFuc2xhdGVgLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImNpcmNsZS10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImNpcmNsZS1waXRjaC1zY2FsZVwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIkNpcmNsZXMgYXJlIHNjYWxlZCBhY2NvcmRpbmcgdG8gdGhlaXIgYXBwYXJlbnQgZGlzdGFuY2UgdG8gdGhlIGNhbWVyYS5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJDaXJjbGVzIGFyZSBub3Qgc2NhbGVkLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJtYXBcIixcblx0XHRkb2M6IFwiQ29udHJvbHMgdGhlIHNjYWxpbmcgYmVoYXZpb3Igb2YgdGhlIGNpcmNsZSB3aGVuIHRoZSBtYXAgaXMgcGl0Y2hlZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjQuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjQuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjIuMVwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBjaXJjbGUgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgY2lyY2xlIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcblx0XHRkb2M6IFwiT3JpZW50YXRpb24gb2YgY2lyY2xlIHdoZW4gbWFwIGlzIHBpdGNoZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjM5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImNpcmNsZS1zdHJva2Utd2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgd2lkdGggb2YgdGhlIGNpcmNsZSdzIHN0cm9rZS4gU3Ryb2tlcyBhcmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGBjaXJjbGUtcmFkaXVzYC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImNpcmNsZS1zdHJva2UtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0ZG9jOiBcIlRoZSBzdHJva2UgY29sb3Igb2YgdGhlIGNpcmNsZS5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJUaGUgb3BhY2l0eSBvZiB0aGUgY2lyY2xlJ3Mgc3Ryb2tlLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH1cbn07XG52YXIgcGFpbnRfaGVhdG1hcCA9IHtcblx0XCJoZWF0bWFwLXJhZGl1c1wiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMzAsXG5cdFx0bWluaW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJSYWRpdXMgb2YgaW5mbHVlbmNlIG9mIG9uZSBoZWF0bWFwIHBvaW50IGluIHBpeGVscy4gSW5jcmVhc2luZyB0aGUgdmFsdWUgbWFrZXMgdGhlIGhlYXRtYXAgc21vb3RoZXIsIGJ1dCBsZXNzIGRldGFpbGVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaGVhdG1hcC13ZWlnaHRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRkb2M6IFwiQSBtZWFzdXJlIG9mIGhvdyBtdWNoIGFuIGluZGl2aWR1YWwgcG9pbnQgY29udHJpYnV0ZXMgdG8gdGhlIGhlYXRtYXAuIEEgdmFsdWUgb2YgMTAgd291bGQgYmUgZXF1aXZhbGVudCB0byBoYXZpbmcgMTAgcG9pbnRzIG9mIHdlaWdodCAxIGluIHRoZSBzYW1lIHNwb3QuIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gY29tYmluZWQgd2l0aCBjbHVzdGVyaW5nLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaGVhdG1hcC1pbnRlbnNpdHlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJTaW1pbGFyIHRvIGBoZWF0bWFwLXdlaWdodGAgYnV0IGNvbnRyb2xzIHRoZSBpbnRlbnNpdHkgb2YgdGhlIGhlYXRtYXAgZ2xvYmFsbHkuIFByaW1hcmlseSB1c2VkIGZvciBhZGp1c3RpbmcgdGhlIGhlYXRtYXAgYmFzZWQgb24gem9vbSBsZXZlbC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJoZWF0bWFwLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdFwiaW50ZXJwb2xhdGVcIixcblx0XHRcdFtcblx0XHRcdFx0XCJsaW5lYXJcIlxuXHRcdFx0XSxcblx0XHRcdFtcblx0XHRcdFx0XCJoZWF0bWFwLWRlbnNpdHlcIlxuXHRcdFx0XSxcblx0XHRcdDAsXG5cdFx0XHRcInJnYmEoMCwgMCwgMjU1LCAwKVwiLFxuXHRcdFx0MC4xLFxuXHRcdFx0XCJyb3lhbGJsdWVcIixcblx0XHRcdDAuMyxcblx0XHRcdFwiY3lhblwiLFxuXHRcdFx0MC41LFxuXHRcdFx0XCJsaW1lXCIsXG5cdFx0XHQwLjcsXG5cdFx0XHRcInllbGxvd1wiLFxuXHRcdFx0MSxcblx0XHRcdFwicmVkXCJcblx0XHRdLFxuXHRcdGRvYzogXCJEZWZpbmVzIHRoZSBjb2xvciBvZiBlYWNoIHBpeGVsIGJhc2VkIG9uIGl0cyBkZW5zaXR5IHZhbHVlIGluIGEgaGVhdG1hcC4gIFNob3VsZCBiZSBhbiBleHByZXNzaW9uIHRoYXQgdXNlcyBgW1xcXCJoZWF0bWFwLWRlbnNpdHlcXFwiXWAgYXMgaW5wdXQuXCIsXG5cdFx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiaGVhdG1hcC1kZW5zaXR5XCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbG9yLXJhbXBcIlxuXHR9LFxuXHRcImhlYXRtYXAtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiVGhlIGdsb2JhbCBvcGFjaXR5IGF0IHdoaWNoIHRoZSBoZWF0bWFwIGxheWVyIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH1cbn07XG52YXIgcGFpbnRfc3ltYm9sID0ge1xuXHRcImljb24tb3BhY2l0eVwiOiB7XG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpY29uIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIGljb24uIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNkZiBpY29ucy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi1oYWxvLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciBvZiB0aGUgaWNvbidzIGhhbG8uIEljb24gaGFsb3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFNERiBpY29ucy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi1oYWxvLXdpZHRoXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgaWNvbiBvdXRsaW5lLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLWhhbG8tYmx1clwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIkZhZGUgb3V0IHRoZSBoYWxvIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24tdHJhbnNsYXRlXCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MFxuXHRcdF0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiRGlzdGFuY2UgdGhhdCB0aGUgaWNvbidzIGFuY2hvciBpcyBtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwbGFjZW1lbnQuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiSWNvbnMgYXJlIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJJY29ucyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgaWNvbi10cmFuc2xhdGVgLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIixcblx0XHRcdFwiaWNvbi10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIHRleHQgd2lsbCBiZSBkcmF3bi5cIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdGRvYzogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdG92ZXJyaWRhYmxlOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LWhhbG8tY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiVGhlIGNvbG9yIG9mIHRoZSB0ZXh0J3MgaGFsbywgd2hpY2ggaGVscHMgaXQgc3RhbmQgb3V0IGZyb20gYmFja2dyb3VuZHMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtaGFsby13aWR0aFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGZvbnQgb3V0bGluZS4gTWF4IHRleHQgaGFsbyB3aWR0aCBpcyAxLzQgb2YgdGhlIGZvbnQtc2l6ZS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1oYWxvLWJsdXJcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgaGFsbydzIGZhZGVvdXQgZGlzdGFuY2UgdG93YXJkcyB0aGUgb3V0c2lkZS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC10cmFuc2xhdGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJEaXN0YW5jZSB0aGF0IHRoZSB0ZXh0J3MgYW5jaG9yIGlzIG1vdmVkIGZyb20gaXRzIG9yaWdpbmFsIHBsYWNlbWVudC4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRleHQgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgdGV4dC10cmFuc2xhdGVgLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdFwidGV4dC10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIHBhaW50X3Jhc3RlciA9IHtcblx0XCJyYXN0ZXItb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGltYWdlIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwicmFzdGVyLWh1ZS1yb3RhdGVcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0cGVyaW9kOiAzNjAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJkZWdyZWVzXCIsXG5cdFx0ZG9jOiBcIlJvdGF0ZXMgaHVlcyBhcm91bmQgdGhlIGNvbG9yIHdoZWVsLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInJhc3Rlci1icmlnaHRuZXNzLW1pblwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIGJyaWdodG5lc3MuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwicmFzdGVyLWJyaWdodG5lc3MtbWF4XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1heGltdW0gYnJpZ2h0bmVzcy5cIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItc2F0dXJhdGlvblwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBpbWFnZS5cIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAtMSxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwicmFzdGVyLWNvbnRyYXN0XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGNvbnRyYXN0IG9mIHRoZSBpbWFnZS5cIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAtMSxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwicmFzdGVyLXJlc2FtcGxpbmdcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdGRvYzogXCJUaGUgcmVzYW1wbGluZy9pbnRlcnBvbGF0aW9uIG1ldGhvZCB0byB1c2UgZm9yIG92ZXJzY2FsaW5nLCBhbHNvIGtub3duIGFzIHRleHR1cmUgbWFnbmlmaWNhdGlvbiBmaWx0ZXJcIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGxpbmVhcjoge1xuXHRcdFx0XHRkb2M6IFwiKEJpKWxpbmVhciBmaWx0ZXJpbmcgaW50ZXJwb2xhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgZm91ciBjbG9zZXN0IG9yaWdpbmFsIHNvdXJjZSBwaXhlbHMgY3JlYXRpbmcgYSBzbW9vdGggYnV0IGJsdXJyeSBsb29rIHdoZW4gb3ZlcnNjYWxlZFwiXG5cdFx0XHR9LFxuXHRcdFx0bmVhcmVzdDoge1xuXHRcdFx0XHRkb2M6IFwiTmVhcmVzdCBuZWlnaGJvciBmaWx0ZXJpbmcgaW50ZXJwb2xhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgbmVhcmVzdCBvcmlnaW5hbCBzb3VyY2UgcGl4ZWwgY3JlYXRpbmcgYSBzaGFycCBidXQgcGl4ZWxhdGVkIGxvb2sgd2hlbiBvdmVyc2NhbGVkXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImxpbmVhclwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40Ny4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4zLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMzAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0dW5pdHM6IFwibWlsbGlzZWNvbmRzXCIsXG5cdFx0ZG9jOiBcIkZhZGUgZHVyYXRpb24gd2hlbiBhIG5ldyB0aWxlIGlzIGFkZGVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIHBhaW50X2hpbGxzaGFkZSA9IHtcblx0XCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWRpcmVjdGlvblwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMzM1LFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMzU5LFxuXHRcdGRvYzogXCJUaGUgZGlyZWN0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgdXNlZCB0byBnZW5lcmF0ZSB0aGUgaGlsbHNoYWRpbmcgd2l0aCAwIGFzIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IGlmIGBoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvcmAgaXMgc2V0IHRvIGB2aWV3cG9ydGAgYW5kIGR1ZSBub3J0aCBpZiBgaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1hbmNob3JgIGlzIHNldCB0byBgbWFwYC5cIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBoaWxsc2hhZGUgaWxsdW1pbmF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBub3J0aCBkaXJlY3Rpb24uXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGhpbGxzaGFkZSBpbGx1bWluYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpZXdwb3J0XCIsXG5cdFx0ZG9jOiBcIkRpcmVjdGlvbiBvZiBsaWdodCBzb3VyY2Ugd2hlbiBtYXAgaXMgcm90YXRlZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaGlsbHNoYWRlLWV4YWdnZXJhdGlvblwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiSW50ZW5zaXR5IG9mIHRoZSBoaWxsc2hhZGVcIixcblx0XHRcImRlZmF1bHRcIjogMC41LFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImhpbGxzaGFkZS1zaGFkb3ctY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0ZG9jOiBcIlRoZSBzaGFkaW5nIGNvbG9yIG9mIGFyZWFzIHRoYXQgZmFjZSBhd2F5IGZyb20gdGhlIGxpZ2h0IHNvdXJjZS5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImhpbGxzaGFkZS1oaWdobGlnaHQtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjRkZGRkZGXCIsXG5cdFx0ZG9jOiBcIlRoZSBzaGFkaW5nIGNvbG9yIG9mIGFyZWFzIHRoYXQgZmFjZXMgdG93YXJkcyB0aGUgbGlnaHQgc291cmNlLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaGlsbHNoYWRlLWFjY2VudC1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIHNoYWRpbmcgY29sb3IgdXNlZCB0byBhY2NlbnR1YXRlIHJ1Z2dlZCB0ZXJyYWluIGxpa2Ugc2hhcnAgY2xpZmZzIGFuZCBnb3JnZXMuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fVxufTtcbnZhciBwYWludF9iYWNrZ3JvdW5kID0ge1xuXHRcImJhY2tncm91bmQtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiYmFja2dyb3VuZC1wYXR0ZXJuXCI6IHtcblx0XHR0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgYW4gaW1hZ2UgYmFja2dyb3VuZC4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWRcIlxuXHR9LFxuXHRcImJhY2tncm91bmQtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fVxufTtcbnZhciB0cmFuc2l0aW9uID0ge1xuXHRkdXJhdGlvbjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDMwMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcIm1pbGxpc2Vjb25kc1wiLFxuXHRcdGRvYzogXCJUaW1lIGFsbG90dGVkIGZvciB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZS5cIlxuXHR9LFxuXHRkZWxheToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR1bml0czogXCJtaWxsaXNlY29uZHNcIixcblx0XHRkb2M6IFwiTGVuZ3RoIG9mIHRpbWUgYmVmb3JlIGEgdHJhbnNpdGlvbiBiZWdpbnMuXCJcblx0fVxufTtcbnZhciBwcm9tb3RlSWQgPSB7XG5cdFwiKlwiOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQSBuYW1lIG9mIGEgZmVhdHVyZSBwcm9wZXJ0eSB0byB1c2UgYXMgSUQgZm9yIGZlYXR1cmUgc3RhdGUuXCJcblx0fVxufTtcbnZhciB2OCA9IHtcblx0JHZlcnNpb246ICR2ZXJzaW9uLFxuXHQkcm9vdDogJHJvb3QsXG5cdHNvdXJjZXM6IHNvdXJjZXMsXG5cdHNvdXJjZTogc291cmNlLFxuXHRzb3VyY2VfdmVjdG9yOiBzb3VyY2VfdmVjdG9yLFxuXHRzb3VyY2VfcmFzdGVyOiBzb3VyY2VfcmFzdGVyLFxuXHRzb3VyY2VfcmFzdGVyX2RlbTogc291cmNlX3Jhc3Rlcl9kZW0sXG5cdHNvdXJjZV9nZW9qc29uOiBzb3VyY2VfZ2VvanNvbixcblx0c291cmNlX3ZpZGVvOiBzb3VyY2VfdmlkZW8sXG5cdHNvdXJjZV9pbWFnZTogc291cmNlX2ltYWdlLFxuXHRsYXllcjogbGF5ZXIsXG5cdGxheW91dDogbGF5b3V0LFxuXHRsYXlvdXRfYmFja2dyb3VuZDogbGF5b3V0X2JhY2tncm91bmQsXG5cdGxheW91dF9maWxsOiBsYXlvdXRfZmlsbCxcblx0bGF5b3V0X2NpcmNsZTogbGF5b3V0X2NpcmNsZSxcblx0bGF5b3V0X2hlYXRtYXA6IGxheW91dF9oZWF0bWFwLFxuXHRcImxheW91dF9maWxsLWV4dHJ1c2lvblwiOiB7XG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn0sXG5cdGxheW91dF9saW5lOiBsYXlvdXRfbGluZSxcblx0bGF5b3V0X3N5bWJvbDogbGF5b3V0X3N5bWJvbCxcblx0bGF5b3V0X3Jhc3RlcjogbGF5b3V0X3Jhc3Rlcixcblx0bGF5b3V0X2hpbGxzaGFkZTogbGF5b3V0X2hpbGxzaGFkZSxcblx0ZmlsdGVyOiBmaWx0ZXIsXG5cdGZpbHRlcl9vcGVyYXRvcjogZmlsdGVyX29wZXJhdG9yLFxuXHRnZW9tZXRyeV90eXBlOiBnZW9tZXRyeV90eXBlLFxuXHRcImZ1bmN0aW9uXCI6IHtcblx0ZXhwcmVzc2lvbjoge1xuXHRcdHR5cGU6IFwiZXhwcmVzc2lvblwiLFxuXHRcdGRvYzogXCJBbiBleHByZXNzaW9uLlwiXG5cdH0sXG5cdHN0b3BzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdGRvYzogXCJBbiBhcnJheSBvZiBzdG9wcy5cIixcblx0XHR2YWx1ZTogXCJmdW5jdGlvbl9zdG9wXCJcblx0fSxcblx0YmFzZToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRkb2M6IFwiVGhlIGV4cG9uZW50aWFsIGJhc2Ugb2YgdGhlIGludGVycG9sYXRpb24gY3VydmUuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSByZXN1bHQgaW5jcmVhc2VzLiBIaWdoZXIgdmFsdWVzIG1ha2UgdGhlIHJlc3VsdCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCBgMWAgdGhlIHN0b3BzIGFyZSBpbnRlcnBvbGF0ZWQgbGluZWFybHkuXCJcblx0fSxcblx0cHJvcGVydHk6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJUaGUgbmFtZSBvZiBhIGZlYXR1cmUgcHJvcGVydHkgdG8gdXNlIGFzIHRoZSBmdW5jdGlvbiBpbnB1dC5cIixcblx0XHRcImRlZmF1bHRcIjogXCIkem9vbVwiXG5cdH0sXG5cdHR5cGU6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGlkZW50aXR5OiB7XG5cdFx0XHRcdGRvYzogXCJSZXR1cm4gdGhlIGlucHV0IHZhbHVlIGFzIHRoZSBvdXRwdXQgdmFsdWUuXCJcblx0XHRcdH0sXG5cdFx0XHRleHBvbmVudGlhbDoge1xuXHRcdFx0XHRkb2M6IFwiR2VuZXJhdGUgYW4gb3V0cHV0IGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBzdG9wcyBqdXN0IGxlc3MgdGhhbiBhbmQganVzdCBncmVhdGVyIHRoYW4gdGhlIGZ1bmN0aW9uIGlucHV0LlwiXG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJ2YWw6IHtcblx0XHRcdFx0ZG9jOiBcIlJldHVybiB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoZSBzdG9wIGp1c3QgbGVzcyB0aGFuIHRoZSBmdW5jdGlvbiBpbnB1dC5cIlxuXHRcdFx0fSxcblx0XHRcdGNhdGVnb3JpY2FsOiB7XG5cdFx0XHRcdGRvYzogXCJSZXR1cm4gdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBlcXVhbCB0byB0aGUgZnVuY3Rpb24gaW5wdXQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJUaGUgaW50ZXJwb2xhdGlvbiBzdHJhdGVneSB0byB1c2UgaW4gZnVuY3Rpb24gZXZhbHVhdGlvbi5cIixcblx0XHRcImRlZmF1bHRcIjogXCJleHBvbmVudGlhbFwiXG5cdH0sXG5cdGNvbG9yU3BhY2U6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHJnYjoge1xuXHRcdFx0XHRkb2M6IFwiVXNlIHRoZSBSR0IgY29sb3Igc3BhY2UgdG8gaW50ZXJwb2xhdGUgY29sb3IgdmFsdWVzXCJcblx0XHRcdH0sXG5cdFx0XHRsYWI6IHtcblx0XHRcdFx0ZG9jOiBcIlVzZSB0aGUgTEFCIGNvbG9yIHNwYWNlIHRvIGludGVycG9sYXRlIGNvbG9yIHZhbHVlcy5cIlxuXHRcdFx0fSxcblx0XHRcdGhjbDoge1xuXHRcdFx0XHRkb2M6IFwiVXNlIHRoZSBIQ0wgY29sb3Igc3BhY2UgdG8gaW50ZXJwb2xhdGUgY29sb3IgdmFsdWVzLCBpbnRlcnBvbGF0aW5nIHRoZSBIdWUsIENocm9tYSwgYW5kIEx1bWluYW5jZSBjaGFubmVscyBpbmRpdmlkdWFsbHkuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJUaGUgY29sb3Igc3BhY2UgaW4gd2hpY2ggY29sb3JzIGludGVycG9sYXRlZC4gSW50ZXJwb2xhdGluZyBjb2xvcnMgaW4gcGVyY2VwdHVhbCBjb2xvciBzcGFjZXMgbGlrZSBMQUIgYW5kIEhDTCB0ZW5kIHRvIHByb2R1Y2UgY29sb3IgcmFtcHMgdGhhdCBsb29rIG1vcmUgY29uc2lzdGVudCBhbmQgcHJvZHVjZSBjb2xvcnMgdGhhdCBjYW4gYmUgZGlmZmVyZW50aWF0ZWQgbW9yZSBlYXNpbHkgdGhhbiB0aG9zZSBpbnRlcnBvbGF0ZWQgaW4gUkdCIHNwYWNlLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcInJnYlwiXG5cdH0sXG5cdFwiZGVmYXVsdFwiOiB7XG5cdFx0dHlwZTogXCIqXCIsXG5cdFx0cmVxdWlyZWQ6IGZhbHNlLFxuXHRcdGRvYzogXCJBIHZhbHVlIHRvIHNlcnZlIGFzIGEgZmFsbGJhY2sgZnVuY3Rpb24gcmVzdWx0IHdoZW4gYSB2YWx1ZSBpc24ndCBvdGhlcndpc2UgYXZhaWxhYmxlLiBJdCBpcyB1c2VkIGluIHRoZSBmb2xsb3dpbmcgY2lyY3Vtc3RhbmNlczpcXG4qIEluIGNhdGVnb3JpY2FsIGZ1bmN0aW9ucywgd2hlbiB0aGUgZmVhdHVyZSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHN0b3AgZG9tYWluIHZhbHVlcy5cXG4qIEluIHByb3BlcnR5IGFuZCB6b29tLWFuZC1wcm9wZXJ0eSBmdW5jdGlvbnMsIHdoZW4gYSBmZWF0dXJlIGRvZXMgbm90IGNvbnRhaW4gYSB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cXG4qIEluIGlkZW50aXR5IGZ1bmN0aW9ucywgd2hlbiB0aGUgZmVhdHVyZSB2YWx1ZSBpcyBub3QgdmFsaWQgZm9yIHRoZSBzdHlsZSBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIGlmIHRoZSBmdW5jdGlvbiBpcyBiZWluZyB1c2VkIGZvciBhIGBjaXJjbGUtY29sb3JgIHByb3BlcnR5IGJ1dCB0aGUgZmVhdHVyZSBwcm9wZXJ0eSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcgb3Igbm90IGEgdmFsaWQgY29sb3IpLlxcbiogSW4gaW50ZXJ2YWwgb3IgZXhwb25lbnRpYWwgcHJvcGVydHkgYW5kIHpvb20tYW5kLXByb3BlcnR5IGZ1bmN0aW9ucywgd2hlbiB0aGUgZmVhdHVyZSB2YWx1ZSBpcyBub3QgbnVtZXJpYy5cXG5JZiBubyBkZWZhdWx0IGlzIHByb3ZpZGVkLCB0aGUgc3R5bGUgcHJvcGVydHkncyBkZWZhdWx0IGlzIHVzZWQgaW4gdGhlc2UgY2lyY3Vtc3RhbmNlcy5cIlxuXHR9XG59LFxuXHRmdW5jdGlvbl9zdG9wOiBmdW5jdGlvbl9zdG9wLFxuXHRleHByZXNzaW9uOiBleHByZXNzaW9uLFxuXHRleHByZXNzaW9uX25hbWU6IGV4cHJlc3Npb25fbmFtZSxcblx0bGlnaHQ6IGxpZ2h0LFxuXHRwYWludDogcGFpbnQsXG5cdHBhaW50X2ZpbGw6IHBhaW50X2ZpbGwsXG5cdFwicGFpbnRfZmlsbC1leHRydXNpb25cIjoge1xuXHRcImZpbGwtZXh0cnVzaW9uLW9wYWNpdHlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdGRvYzogXCJUaGUgb3BhY2l0eSBvZiB0aGUgZW50aXJlIGZpbGwgZXh0cnVzaW9uIGxheWVyLiBUaGlzIGlzIHJlbmRlcmVkIG9uIGEgcGVyLWxheWVyLCBub3QgcGVyLWZlYXR1cmUsIGJhc2lzLCBhbmQgZGF0YS1kcml2ZW4gc3R5bGluZyBpcyBub3QgYXZhaWxhYmxlLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiZmlsbC1leHRydXNpb24tY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0ZG9jOiBcIlRoZSBiYXNlIGNvbG9yIG9mIHRoZSBleHRydWRlZCBmaWxsLiBUaGUgZXh0cnVzaW9uJ3Mgc3VyZmFjZXMgd2lsbCBiZSBzaGFkZWQgZGlmZmVyZW50bHkgYmFzZWQgb24gdGhpcyBjb2xvciBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSByb290IGBsaWdodGAgc2V0dGluZ3MuIElmIHRoaXMgY29sb3IgaXMgc3BlY2lmaWVkIGFzIGByZ2JhYCB3aXRoIGFuIGFscGhhIGNvbXBvbmVudCwgdGhlIGFscGhhIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQ7IHVzZSBgZmlsbC1leHRydXNpb24tb3BhY2l0eWAgdG8gc2V0IGxheWVyIG9wYWNpdHkuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MFxuXHRcdF0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAgKG9uIHRoZSBmbGF0IHBsYW5lKSwgcmVzcGVjdGl2ZWx5LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgZmlsbCBleHRydXNpb24gaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBmaWxsIGV4dHJ1c2lvbiBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVgLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiZmlsbC1leHRydXNpb24tcGF0dGVyblwiOiB7XG5cdFx0dHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlcyBvbiBleHRydWRlZCBmaWxscy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiZmlsbC1leHRydXNpb24taGVpZ2h0XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwibWV0ZXJzXCIsXG5cdFx0ZG9jOiBcIlRoZSBoZWlnaHQgd2l0aCB3aGljaCB0byBleHRydWRlIHRoaXMgbGF5ZXIuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImZpbGwtZXh0cnVzaW9uLWJhc2VcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR1bml0czogXCJtZXRlcnNcIixcblx0XHRkb2M6IFwiVGhlIGhlaWdodCB3aXRoIHdoaWNoIHRvIGV4dHJ1ZGUgdGhlIGJhc2Ugb2YgdGhpcyBsYXllci4gTXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYGZpbGwtZXh0cnVzaW9uLWhlaWdodGAuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJmaWxsLWV4dHJ1c2lvbi1oZWlnaHRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi12ZXJ0aWNhbC1ncmFkaWVudFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IHRydWUsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdG8gYXBwbHkgYSB2ZXJ0aWNhbCBncmFkaWVudCB0byB0aGUgc2lkZXMgb2YgYSBmaWxsLWV4dHJ1c2lvbiBsYXllci4gSWYgdHJ1ZSwgc2lkZXMgd2lsbCBiZSBzaGFkZWQgc2xpZ2h0bHkgZGFya2VyIGZhcnRoZXIgZG93bi5cIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fVxufSxcblx0cGFpbnRfbGluZTogcGFpbnRfbGluZSxcblx0cGFpbnRfY2lyY2xlOiBwYWludF9jaXJjbGUsXG5cdHBhaW50X2hlYXRtYXA6IHBhaW50X2hlYXRtYXAsXG5cdHBhaW50X3N5bWJvbDogcGFpbnRfc3ltYm9sLFxuXHRwYWludF9yYXN0ZXI6IHBhaW50X3Jhc3Rlcixcblx0cGFpbnRfaGlsbHNoYWRlOiBwYWludF9oaWxsc2hhZGUsXG5cdHBhaW50X2JhY2tncm91bmQ6IHBhaW50X2JhY2tncm91bmQsXG5cdHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG5cdFwicHJvcGVydHktdHlwZVwiOiB7XG5cdFwiZGF0YS1kcml2ZW5cIjoge1xuXHRcdHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuXHRcdGRvYzogXCJQcm9wZXJ0eSBpcyBpbnRlcnBvbGFibGUgYW5kIGNhbiBiZSByZXByZXNlbnRlZCB1c2luZyBhIHByb3BlcnR5IGV4cHJlc3Npb24uXCJcblx0fSxcblx0XCJjcm9zcy1mYWRlZFwiOiB7XG5cdFx0dHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG5cdFx0ZG9jOiBcIlByb3BlcnR5IGlzIG5vbi1pbnRlcnBvbGFibGU7IHJhdGhlciwgaXRzIHZhbHVlcyB3aWxsIGJlIGNyb3NzLWZhZGVkIHRvIHNtb290aGx5IHRyYW5zaXRpb24gYmV0d2VlbiBpbnRlZ2VyIHpvb21zLlwiXG5cdH0sXG5cdFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIjoge1xuXHRcdHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuXHRcdGRvYzogXCJQcm9wZXJ0eSBpcyBub24taW50ZXJwb2xhYmxlOyByYXRoZXIsIGl0cyB2YWx1ZXMgd2lsbCBiZSBjcm9zcy1mYWRlZCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIGJldHdlZW4gaW50ZWdlciB6b29tcy4gSXQgY2FuIGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi5cIlxuXHR9LFxuXHRcImNvbG9yLXJhbXBcIjoge1xuXHRcdHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuXHRcdGRvYzogXCJQcm9wZXJ0eSBzaG91bGQgYmUgc3BlY2lmaWVkIHVzaW5nIGEgY29sb3IgcmFtcCBmcm9tIHdoaWNoIHRoZSBvdXRwdXQgY29sb3IgY2FuIGJlIHNhbXBsZWQgYmFzZWQgb24gYSBwcm9wZXJ0eSBjYWxjdWxhdGlvbi5cIlxuXHR9LFxuXHRcImRhdGEtY29uc3RhbnRcIjoge1xuXHRcdHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuXHRcdGRvYzogXCJQcm9wZXJ0eSBpcyBpbnRlcnBvbGFibGUgYnV0IGNhbm5vdCBiZSByZXByZXNlbnRlZCB1c2luZyBhIHByb3BlcnR5IGV4cHJlc3Npb24uXCJcblx0fSxcblx0Y29uc3RhbnQ6IHtcblx0XHR0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcblx0XHRkb2M6IFwiUHJvcGVydHkgaXMgY29uc3RhbnQgYWNyb3NzIGFsbCB6b29tIGxldmVscyBhbmQgcHJvcGVydHkgdmFsdWVzLlwiXG5cdH1cbn0sXG5cdHByb21vdGVJZDogcHJvbW90ZUlkXG59O1xuXG4vLyBOb3RlOiBUaGlzIHJlZ2V4IG1hdGNoZXMgZXZlbiBpbnZhbGlkIEpTT04gc3RyaW5ncywgYnV0IHNpbmNlIHdl4oCZcmVcbi8vIHdvcmtpbmcgb24gdGhlIG91dHB1dCBvZiBgSlNPTi5zdHJpbmdpZnlgIHdlIGtub3cgdGhhdCBvbmx5IHZhbGlkIHN0cmluZ3Ncbi8vIGFyZSBwcmVzZW50ICh1bmxlc3MgdGhlIHVzZXIgc3VwcGxpZWQgYSB3ZWlyZCBgb3B0aW9ucy5pbmRlbnRgIGJ1dCBpblxuLy8gdGhhdCBjYXNlIHdlIGRvbuKAmXQgY2FyZSBzaW5jZSB0aGUgb3V0cHV0IHdvdWxkIGJlIGludmFsaWQgYW55d2F5KS5cbnZhciBzdHJpbmdPckNoYXIgPSAvKFwiKD86W15cXFxcXCJdfFxcXFwuKSpcIil8WzosXS9nO1xuXG52YXIganNvblN0cmluZ2lmeVByZXR0eUNvbXBhY3QgPSBmdW5jdGlvbiBzdHJpbmdpZnkocGFzc2VkT2JqLCBvcHRpb25zKSB7XG4gIHZhciBpbmRlbnQsIG1heExlbmd0aCwgcmVwbGFjZXI7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGluZGVudCA9IEpTT04uc3RyaW5naWZ5KFxuICAgIFsxXSxcbiAgICB1bmRlZmluZWQsXG4gICAgb3B0aW9ucy5pbmRlbnQgPT09IHVuZGVmaW5lZCA/IDIgOiBvcHRpb25zLmluZGVudFxuICApLnNsaWNlKDIsIC0zKTtcbiAgbWF4TGVuZ3RoID1cbiAgICBpbmRlbnQgPT09IFwiXCJcbiAgICAgID8gSW5maW5pdHlcbiAgICAgIDogb3B0aW9ucy5tYXhMZW5ndGggPT09IHVuZGVmaW5lZFxuICAgICAgPyA4MFxuICAgICAgOiBvcHRpb25zLm1heExlbmd0aDtcbiAgcmVwbGFjZXIgPSBvcHRpb25zLnJlcGxhY2VyO1xuXG4gIHJldHVybiAoZnVuY3Rpb24gX3N0cmluZ2lmeShvYmosIGN1cnJlbnRJbmRlbnQsIHJlc2VydmVkKSB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgdmFyIGVuZCwgaW5kZXgsIGl0ZW1zLCBrZXksIGtleVBhcnQsIGtleXMsIGxlbmd0aCwgbmV4dEluZGVudCwgcHJldHRpZmllZCwgc3RhcnQsIHN0cmluZywgdmFsdWU7XG5cbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmoudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICB9XG5cbiAgICBzdHJpbmcgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyKTtcblxuICAgIGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICBsZW5ndGggPSBtYXhMZW5ndGggLSBjdXJyZW50SW5kZW50Lmxlbmd0aCAtIHJlc2VydmVkO1xuXG4gICAgaWYgKHN0cmluZy5sZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICBwcmV0dGlmaWVkID0gc3RyaW5nLnJlcGxhY2Uoc3RyaW5nT3JDaGFyLCBmdW5jdGlvbihtYXRjaCwgc3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbCB8fCBtYXRjaCArIFwiIFwiO1xuICAgICAgfSk7XG4gICAgICBpZiAocHJldHRpZmllZC5sZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcmV0dGlmaWVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXBsYWNlciAhPSBudWxsKSB7XG4gICAgICBvYmogPSBKU09OLnBhcnNlKHN0cmluZyk7XG4gICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgIG5leHRJbmRlbnQgPSBjdXJyZW50SW5kZW50ICsgaW5kZW50O1xuICAgICAgaXRlbXMgPSBbXTtcbiAgICAgIGluZGV4ID0gMDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBzdGFydCA9IFwiW1wiO1xuICAgICAgICBlbmQgPSBcIl1cIjtcbiAgICAgICAgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChcbiAgICAgICAgICAgIF9zdHJpbmdpZnkob2JqW2luZGV4XSwgbmV4dEluZGVudCwgaW5kZXggPT09IGxlbmd0aCAtIDEgPyAwIDogMSkgfHxcbiAgICAgICAgICAgICAgXCJudWxsXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IFwie1wiO1xuICAgICAgICBlbmQgPSBcIn1cIjtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgICBrZXlQYXJ0ID0gSlNPTi5zdHJpbmdpZnkoa2V5KSArIFwiOiBcIjtcbiAgICAgICAgICB2YWx1ZSA9IF9zdHJpbmdpZnkoXG4gICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgIG5leHRJbmRlbnQsXG4gICAgICAgICAgICBrZXlQYXJ0Lmxlbmd0aCArIChpbmRleCA9PT0gbGVuZ3RoIC0gMSA/IDAgOiAxKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goa2V5UGFydCArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtzdGFydCwgaW5kZW50ICsgaXRlbXMuam9pbihcIixcXG5cIiArIG5leHRJbmRlbnQpLCBlbmRdLmpvaW4oXG4gICAgICAgICAgXCJcXG5cIiArIGN1cnJlbnRJbmRlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9KShwYXNzZWRPYmosIFwiXCIsIDApO1xufTtcblxuZnVuY3Rpb24gc29ydEtleXNCeShvYmosIHJlZmVyZW5jZSkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcmVmZXJlbmNlKSB7XG4gICAgICAgIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSQxIGluIG9iaikge1xuICAgICAgICBpZiAocmVzdWx0W2tleSQxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5JDFdID0gb2JqW2tleSQxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ybWF0KHN0eWxlLCBzcGFjZSkge1xuICAgIGlmIChzcGFjZSA9PT0gdm9pZCAwKVxuICAgICAgICBzcGFjZSA9IDI7XG4gICAgc3R5bGUgPSBzb3J0S2V5c0J5KHN0eWxlLCB2OC4kcm9vdCk7XG4gICAgaWYgKHN0eWxlLmxheWVycykge1xuICAgICAgICBzdHlsZS5sYXllcnMgPSBzdHlsZS5sYXllcnMubWFwKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRLZXlzQnkobGF5ZXIsIHY4LmxheWVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uU3RyaW5naWZ5UHJldHR5Q29tcGFjdChzdHlsZSwgeyBpbmRlbnQ6IHNwYWNlIH0pO1xufVxuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlICgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSByb2xsdXAtcGx1Z2luLWNvbW1vbmpzJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgcHVueWNvZGUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4oZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9ICBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KGNvbW1vbmpzR2xvYmFsKSk7XG59KTtcblxudmFyIHV0aWwgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBkZWNvZGUgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbnZhciBlbmNvZGUgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSB7IHJldHVybiAnJzsgfVxuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIHF1ZXJ5c3RyaW5nID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZW5jb2RlO1xufSk7XG52YXIgcXVlcnlzdHJpbmdfMSA9IHF1ZXJ5c3RyaW5nLmRlY29kZTtcbnZhciBxdWVyeXN0cmluZ18yID0gcXVlcnlzdHJpbmcucGFyc2U7XG52YXIgcXVlcnlzdHJpbmdfMyA9IHF1ZXJ5c3RyaW5nLmVuY29kZTtcbnZhciBxdWVyeXN0cmluZ180ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5O1xuXG52YXIgcGFyc2UgPSB1cmxQYXJzZTtcbnZhciByZXNvbHZlID0gdXJsUmVzb2x2ZTtcbnZhciByZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbnZhciBmb3JtYXQkMSA9IHVybEZvcm1hdDtcblxudmFyIFVybF8xID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHsgcmV0dXJuIHVybDsgfVxuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgeyBob3N0RW5kID0gaGVjOyB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgeyBob3N0RW5kID0gaGVjOyB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICB7IGhvc3RFbmQgPSByZXN0Lmxlbmd0aDsgfVxuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgeyBjb250aW51ZTsgfVxuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgeyB0aGlzLnBhdGhuYW1lID0gcmVzdDsgfVxuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSB7IG9iaiA9IHVybFBhcnNlKG9iaik7IH1cbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgeyByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopOyB9XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSB7IHByb3RvY29sICs9ICc6JzsgfVxuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7IHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7IH1cbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHsgaGFzaCA9ICcjJyArIGhhc2g7IH1cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHsgc2VhcmNoID0gJz8nICsgc2VhcmNoOyB9XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgeyByZXR1cm4gcmVsYXRpdmU7IH1cbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgeyByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTsgfVxuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpeyB9XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHsgcmVsYXRpdmUuaG9zdCA9ICcnOyB9XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSB7IHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7IH1cbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgeyByZWxQYXRoLnVuc2hpZnQoJycpOyB9XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSB7IHJlbFBhdGgudW5zaGlmdCgnJyk7IH1cbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgeyBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7IH1cbiAgICAgIGVsc2UgeyBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpOyB9XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgeyByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDsgfVxuICAgICAgICBlbHNlIHsgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpOyB9XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgeyBzcmNQYXRoID0gW107IH1cbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgeyB0aGlzLmhvc3RuYW1lID0gaG9zdDsgfVxufTtcblxudmFyIHVybCA9IHtcblx0cGFyc2U6IHBhcnNlLFxuXHRyZXNvbHZlOiByZXNvbHZlLFxuXHRyZXNvbHZlT2JqZWN0OiByZXNvbHZlT2JqZWN0LFxuXHRmb3JtYXQ6IGZvcm1hdCQxLFxuXHRVcmw6IFVybF8xXG59O1xuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eVJlZmVyZW5jZShwcm9wZXJ0eU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHY4LmxheW91dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdjhbdjgubGF5b3V0W2ldXSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY4W3Y4LmxheW91dFtpXV1ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB2OC5wYWludC5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIGZvciAodmFyIGtleSQxIGluIHY4W3Y4LnBhaW50W2kkMV1dKSB7XG4gICAgICAgICAgICBpZiAoa2V5JDEgPT09IHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2OFt2OC5wYWludFtpJDFdXVtrZXkkMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlYWNoU291cmNlKHN0eWxlLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGsgaW4gc3R5bGUuc291cmNlcykge1xuICAgICAgICBjYWxsYmFjayhzdHlsZS5zb3VyY2VzW2tdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlYWNoTGF5ZXIoc3R5bGUsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdHlsZS5sYXllcnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBsYXllciA9IGxpc3RbaV07XG4gICAgICAgIGNhbGxiYWNrKGxheWVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlYWNoUHJvcGVydHkoc3R5bGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gaW5uZXIobGF5ZXIsIHByb3BlcnR5VHlwZSkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGxheWVyW3Byb3BlcnR5VHlwZV07XG4gICAgICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5VHlwZSxcbiAgICAgICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcGVydGllc1trZXldLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogZ2V0UHJvcGVydHlSZWZlcmVuY2Uoa2V5KSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlYWNoTGF5ZXIoc3R5bGUsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAob3B0aW9ucy5wYWludCkge1xuICAgICAgICAgICAgaW5uZXIobGF5ZXIsICdwYWludCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmxheW91dCkge1xuICAgICAgICAgICAgaW5uZXIobGF5ZXIsICdsYXlvdXQnKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBlYWNoTGF5b3V0KGxheWVyLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGsgaW4gbGF5ZXIpIHtcbiAgICAgICAgaWYgKGsuaW5kZXhPZignbGF5b3V0JykgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyW2tdLCBrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGVhY2hQYWludChsYXllciwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBrIGluIGxheWVyKSB7XG4gICAgICAgIGlmIChrLmluZGV4T2YoJ3BhaW50JykgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyW2tdLCBrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDb25zdGFudChzdHlsZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJ0AnKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHN0eWxlLmNvbnN0YW50c1t2YWx1ZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUuc3RvcHMpO1xufVxuZnVuY3Rpb24gcmVuYW1lUHJvcGVydHkob2JqLCBmcm9tLCB0bykge1xuICAgIG9ialt0b10gPSBvYmpbZnJvbV07XG4gICAgZGVsZXRlIG9ialtmcm9tXTtcbn1cbmZ1bmN0aW9uIG1pZ3JhdGVUb1Y4IChzdHlsZSkge1xuICAgIHN0eWxlLnZlcnNpb24gPSA4O1xuICAgIGVhY2hTb3VyY2Uoc3R5bGUsIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS50eXBlID09PSAndmlkZW8nICYmIHNvdXJjZS51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVuYW1lUHJvcGVydHkoc291cmNlLCAndXJsJywgJ3VybHMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHNvdXJjZS5jb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGVhY2hMYXlvdXQobGF5ZXIsIGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICAgICAgICAgIGlmIChsYXlvdXRbJ3N5bWJvbC1taW4tZGlzdGFuY2UnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuYW1lUHJvcGVydHkobGF5b3V0LCAnc3ltYm9sLW1pbi1kaXN0YW5jZScsICdzeW1ib2wtc3BhY2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWFjaFBhaW50KGxheWVyLCBmdW5jdGlvbiAocGFpbnQpIHtcbiAgICAgICAgICAgIGlmIChwYWludFsnYmFja2dyb3VuZC1pbWFnZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShwYWludCwgJ2JhY2tncm91bmQtaW1hZ2UnLCAnYmFja2dyb3VuZC1wYXR0ZXJuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFpbnRbJ2xpbmUtaW1hZ2UnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuYW1lUHJvcGVydHkocGFpbnQsICdsaW5lLWltYWdlJywgJ2xpbmUtcGF0dGVybicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhaW50WydmaWxsLWltYWdlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmFtZVByb3BlcnR5KHBhaW50LCAnZmlsbC1pbWFnZScsICdmaWxsLXBhdHRlcm4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWFjaFByb3BlcnR5KHN0eWxlLCB7XG4gICAgICAgIHBhaW50OiB0cnVlLFxuICAgICAgICBsYXlvdXQ6IHRydWVcbiAgICB9LCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzb2x2ZUNvbnN0YW50KHN0eWxlLCBwcm9wZXJ0eS52YWx1ZSk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuc3RvcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICAgICAgICAgIHN0b3BbMV0gPSByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHN0b3BbMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcGVydHkuc2V0KHZhbHVlKTtcbiAgICB9KTtcbiAgICBkZWxldGUgc3R5bGUuY29uc3RhbnRzO1xuICAgIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGVhY2hMYXlvdXQobGF5ZXIsIGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXlvdXRbJ3RleHQtbWF4LXNpemUnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXlvdXRbJ2ljb24tbWF4LXNpemUnXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hQYWludChsYXllciwgZnVuY3Rpb24gKHBhaW50KSB7XG4gICAgICAgICAgICBpZiAocGFpbnRbJ3RleHQtc2l6ZSddKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIubGF5b3V0ID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxheWVyLmxheW91dFsndGV4dC1zaXplJ10gPSBwYWludFsndGV4dC1zaXplJ107XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhaW50Wyd0ZXh0LXNpemUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWludFsnaWNvbi1zaXplJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLmxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5sYXlvdXQgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGF5ZXIubGF5b3V0WydpY29uLXNpemUnXSA9IHBhaW50WydpY29uLXNpemUnXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFpbnRbJ2ljb24tc2l6ZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBtaWdyYXRlRm9udHN0YWNrVVJMKGlucHV0KSB7XG4gICAgICAgIHZhciBpbnB1dFBhcnNlZCA9IHVybC5wYXJzZShpbnB1dCk7XG4gICAgICAgIHZhciBpbnB1dFBhdGhuYW1lUGFydHMgPSBpbnB1dFBhcnNlZC5wYXRobmFtZS5zcGxpdCgnLycpO1xuICAgICAgICBpZiAoaW5wdXRQYXJzZWQucHJvdG9jb2wgIT09ICdtYXBib3g6Jykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0UGFyc2VkLmhvc3RuYW1lID09PSAnZm9udHN0YWNrJykge1xuICAgICAgICAgICAgcmV0dXJuICdtYXBib3g6Ly9mb250cy9tYXBib3gve2ZvbnRzdGFja30ve3JhbmdlfS5wYmYnO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0UGFyc2VkLmhvc3RuYW1lID09PSAnZm9udHMnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21hcGJveDovL2ZvbnRzLycgKyBpbnB1dFBhdGhuYW1lUGFydHNbMl0gKyAnL3tmb250c3RhY2t9L3tyYW5nZX0ucGJmJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGUuZ2x5cGhzKSB7XG4gICAgICAgIHN0eWxlLmdseXBocyA9IG1pZ3JhdGVGb250c3RhY2tVUkwoc3R5bGUuZ2x5cGhzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWlncmF0ZUZvbnRTdGFjayhmb250KSB7XG4gICAgICAgIGZ1bmN0aW9uIHNwbGl0QW5kVHJpbShzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcy50cmltKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmb250KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRBbmRUcmltKGZvbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb250ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9udC5zdG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgc3RvcFsxXSA9IHNwbGl0QW5kVHJpbShzdG9wWzFdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZm9udCB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGVhY2hMYXlvdXQobGF5ZXIsIGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICAgICAgICAgIGlmIChsYXlvdXRbJ3RleHQtZm9udCddKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Wyd0ZXh0LWZvbnQnXSA9IG1pZ3JhdGVGb250U3RhY2sobGF5b3V0Wyd0ZXh0LWZvbnQnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBmaXJzdFN5bWJvbExheWVyID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3R5bGUubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBsYXllciA9IHN0eWxlLmxheWVyc1tpXTtcbiAgICAgICAgaWYgKGxheWVyLnR5cGUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICBmaXJzdFN5bWJvbExheWVyID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3ltYm9sTGF5ZXJzID0gc3R5bGUubGF5ZXJzLnNwbGljZShmaXJzdFN5bWJvbExheWVyKTtcbiAgICBzeW1ib2xMYXllcnMucmV2ZXJzZSgpO1xuICAgIHN0eWxlLmxheWVycyA9IHN0eWxlLmxheWVycy5jb25jYXQoc3ltYm9sTGF5ZXJzKTtcbiAgICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCAob3V0cHV0KSB7XG4gICAgdmFyIGlucHV0cyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAobGVuLS0gPiAwKVxuICAgICAgICBpbnB1dHNbbGVuXSA9IGFyZ3VtZW50c1tsZW4gKyAxXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGlucHV0czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gbGlzdFtpXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBpbnB1dCkge1xuICAgICAgICAgICAgb3V0cHV0W2tdID0gaW5wdXRba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxudmFyIFBhcnNpbmdFcnJvciA9IGZ1bmN0aW9uIChFcnJvcikge1xuICAgIGZ1bmN0aW9uIFBhcnNpbmdFcnJvcihrZXksIG1lc3NhZ2UpIHtcbiAgICAgICAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuICAgIGlmIChFcnJvcilcbiAgICAgICAgUGFyc2luZ0Vycm9yLl9fcHJvdG9fXyA9IEVycm9yO1xuICAgIFBhcnNpbmdFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yICYmIEVycm9yLnByb3RvdHlwZSk7XG4gICAgUGFyc2luZ0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnNpbmdFcnJvcjtcbiAgICByZXR1cm4gUGFyc2luZ0Vycm9yO1xufShFcnJvcik7XG5cbnZhciBTY29wZSA9IGZ1bmN0aW9uIFNjb3BlKHBhcmVudCwgYmluZGluZ3MpIHtcbiAgICBpZiAoYmluZGluZ3MgPT09IHZvaWQgMClcbiAgICAgICAgYmluZGluZ3MgPSBbXTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBiaW5kaW5nczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IGxpc3RbaV07XG4gICAgICAgIHZhciBuYW1lID0gcmVmWzBdO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJlZlsxXTtcbiAgICAgICAgdGhpcy5iaW5kaW5nc1tuYW1lXSA9IGV4cHJlc3Npb247XG4gICAgfVxufTtcblNjb3BlLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQoYmluZGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMsIGJpbmRpbmdzKTtcbn07XG5TY29wZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICBpZiAodGhpcy5iaW5kaW5nc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nc1tuYW1lXTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXQobmFtZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJyBub3QgZm91bmQgaW4gc2NvcGUuJyk7XG59O1xuU2NvcGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgaWYgKHRoaXMuYmluZGluZ3NbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmhhcyhuYW1lKSA6IGZhbHNlO1xufTtcblxudmFyIE51bGxUeXBlID0geyBraW5kOiAnbnVsbCcgfTtcbnZhciBOdW1iZXJUeXBlID0geyBraW5kOiAnbnVtYmVyJyB9O1xudmFyIFN0cmluZ1R5cGUgPSB7IGtpbmQ6ICdzdHJpbmcnIH07XG52YXIgQm9vbGVhblR5cGUgPSB7IGtpbmQ6ICdib29sZWFuJyB9O1xudmFyIENvbG9yVHlwZSA9IHsga2luZDogJ2NvbG9yJyB9O1xudmFyIE9iamVjdFR5cGUgPSB7IGtpbmQ6ICdvYmplY3QnIH07XG52YXIgVmFsdWVUeXBlID0geyBraW5kOiAndmFsdWUnIH07XG52YXIgRXJyb3JUeXBlID0geyBraW5kOiAnZXJyb3InIH07XG52YXIgQ29sbGF0b3JUeXBlID0geyBraW5kOiAnY29sbGF0b3InIH07XG52YXIgRm9ybWF0dGVkVHlwZSA9IHsga2luZDogJ2Zvcm1hdHRlZCcgfTtcbnZhciBSZXNvbHZlZEltYWdlVHlwZSA9IHsga2luZDogJ3Jlc29sdmVkSW1hZ2UnIH07XG5mdW5jdGlvbiBhcnJheShpdGVtVHlwZSwgTikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6ICdhcnJheScsXG4gICAgICAgIGl0ZW1UeXBlOiBpdGVtVHlwZSxcbiAgICAgICAgTjogTlxuICAgIH07XG59XG5mdW5jdGlvbiB0b1N0cmluZyh0eXBlKSB7XG4gICAgaWYgKHR5cGUua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgICB2YXIgaXRlbVR5cGUgPSB0b1N0cmluZyh0eXBlLml0ZW1UeXBlKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlLk4gPT09ICdudW1iZXInID8gJ2FycmF5PCcgKyBpdGVtVHlwZSArICcsICcgKyB0eXBlLk4gKyAnPicgOiB0eXBlLml0ZW1UeXBlLmtpbmQgPT09ICd2YWx1ZScgPyAnYXJyYXknIDogJ2FycmF5PCcgKyBpdGVtVHlwZSArICc+JztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZS5raW5kO1xuICAgIH1cbn1cbnZhciB2YWx1ZU1lbWJlclR5cGVzID0gW1xuICAgIE51bGxUeXBlLFxuICAgIE51bWJlclR5cGUsXG4gICAgU3RyaW5nVHlwZSxcbiAgICBCb29sZWFuVHlwZSxcbiAgICBDb2xvclR5cGUsXG4gICAgRm9ybWF0dGVkVHlwZSxcbiAgICBPYmplY3RUeXBlLFxuICAgIGFycmF5KFZhbHVlVHlwZSksXG4gICAgUmVzb2x2ZWRJbWFnZVR5cGVcbl07XG5mdW5jdGlvbiBjaGVja1N1YnR5cGUoZXhwZWN0ZWQsIHQpIHtcbiAgICBpZiAodC5raW5kID09PSAnZXJyb3InKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgICBpZiAodC5raW5kID09PSAnYXJyYXknICYmICh0Lk4gPT09IDAgJiYgdC5pdGVtVHlwZS5raW5kID09PSAndmFsdWUnIHx8ICFjaGVja1N1YnR5cGUoZXhwZWN0ZWQuaXRlbVR5cGUsIHQuaXRlbVR5cGUpKSAmJiAodHlwZW9mIGV4cGVjdGVkLk4gIT09ICdudW1iZXInIHx8IGV4cGVjdGVkLk4gPT09IHQuTikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZC5raW5kID09PSB0LmtpbmQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZC5raW5kID09PSAndmFsdWUnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdmFsdWVNZW1iZXJUeXBlczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBtZW1iZXJUeXBlID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmICghY2hlY2tTdWJ0eXBlKG1lbWJlclR5cGUsIHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdFeHBlY3RlZCAnICsgdG9TdHJpbmcoZXhwZWN0ZWQpICsgJyBidXQgZm91bmQgJyArIHRvU3RyaW5nKHQpICsgJyBpbnN0ZWFkLic7XG59XG5mdW5jdGlvbiBpc1ZhbGlkVHlwZShwcm92aWRlZCwgYWxsb3dlZFR5cGVzKSB7XG4gICAgcmV0dXJuIGFsbG93ZWRUeXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmtpbmQgPT09IHByb3ZpZGVkLmtpbmQ7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkTmF0aXZlVHlwZShwcm92aWRlZCwgYWxsb3dlZFR5cGVzKSB7XG4gICAgcmV0dXJuIGFsbG93ZWRUeXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlZCA9PT0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0ID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwcm92aWRlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlZCAmJiAhQXJyYXkuaXNBcnJheShwcm92aWRlZCkgJiYgdHlwZW9mIHByb3ZpZGVkID09PSAnb2JqZWN0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ID09PSB0eXBlb2YgcHJvdmlkZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxudmFyIGNzc2NvbG9ycGFyc2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLy8gKGMpIERlYW4gTWNOYW1lZSA8ZGVhbkBnbWFpbC5jb20+LCAyMDEyLlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncbi8vIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci9cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgXCJ0cmFuc3BhcmVudFwiOiBbMCwwLDAsMF0sIFwiYWxpY2VibHVlXCI6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwyMzUsMjE1LDFdLCBcImFxdWFcIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsMjU1LDIxMiwxXSwgXCJhenVyZVwiOiBbMjQwLDI1NSwyNTUsMV0sXG4gIFwiYmVpZ2VcIjogWzI0NSwyNDUsMjIwLDFdLCBcImJpc3F1ZVwiOiBbMjU1LDIyOCwxOTYsMV0sXG4gIFwiYmxhY2tcIjogWzAsMCwwLDFdLCBcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNSwxXSxcbiAgXCJibHVlXCI6IFswLDAsMjU1LDFdLCBcImJsdWV2aW9sZXRcIjogWzEzOCw0MywyMjYsMV0sXG4gIFwiYnJvd25cIjogWzE2NSw0Miw0MiwxXSwgXCJidXJseXdvb2RcIjogWzIyMiwxODQsMTM1LDFdLFxuICBcImNhZGV0Ymx1ZVwiOiBbOTUsMTU4LDE2MCwxXSwgXCJjaGFydHJldXNlXCI6IFsxMjcsMjU1LDAsMV0sXG4gIFwiY2hvY29sYXRlXCI6IFsyMTAsMTA1LDMwLDFdLCBcImNvcmFsXCI6IFsyNTUsMTI3LDgwLDFdLFxuICBcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsMTQ5LDIzNywxXSwgXCJjb3Juc2lsa1wiOiBbMjU1LDI0OCwyMjAsMV0sXG4gIFwiY3JpbXNvblwiOiBbMjIwLDIwLDYwLDFdLCBcImN5YW5cIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJkYXJrYmx1ZVwiOiBbMCwwLDEzOSwxXSwgXCJkYXJrY3lhblwiOiBbMCwxMzksMTM5LDFdLFxuICBcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwxMzQsMTEsMV0sIFwiZGFya2dyYXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtncmVlblwiOiBbMCwxMDAsMCwxXSwgXCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2toYWtpXCI6IFsxODksMTgzLDEwNywxXSwgXCJkYXJrbWFnZW50YVwiOiBbMTM5LDAsMTM5LDFdLFxuICBcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwxMDcsNDcsMV0sIFwiZGFya29yYW5nZVwiOiBbMjU1LDE0MCwwLDFdLFxuICBcImRhcmtvcmNoaWRcIjogWzE1Myw1MCwyMDQsMV0sIFwiZGFya3JlZFwiOiBbMTM5LDAsMCwxXSxcbiAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsMTUwLDEyMiwxXSwgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywxODgsMTQzLDFdLFxuICBcImRhcmtzbGF0ZWJsdWVcIjogWzcyLDYxLDEzOSwxXSwgXCJkYXJrc2xhdGVncmF5XCI6IFs0Nyw3OSw3OSwxXSxcbiAgXCJkYXJrc2xhdGVncmV5XCI6IFs0Nyw3OSw3OSwxXSwgXCJkYXJrdHVycXVvaXNlXCI6IFswLDIwNiwyMDksMV0sXG4gIFwiZGFya3Zpb2xldFwiOiBbMTQ4LDAsMjExLDFdLCBcImRlZXBwaW5rXCI6IFsyNTUsMjAsMTQ3LDFdLFxuICBcImRlZXBza3libHVlXCI6IFswLDE5MSwyNTUsMV0sIFwiZGltZ3JheVwiOiBbMTA1LDEwNSwxMDUsMV0sXG4gIFwiZGltZ3JleVwiOiBbMTA1LDEwNSwxMDUsMV0sIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NSwxXSxcbiAgXCJmaXJlYnJpY2tcIjogWzE3OCwzNCwzNCwxXSwgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LDI1MCwyNDAsMV0sXG4gIFwiZm9yZXN0Z3JlZW5cIjogWzM0LDEzOSwzNCwxXSwgXCJmdWNoc2lhXCI6IFsyNTUsMCwyNTUsMV0sXG4gIFwiZ2FpbnNib3JvXCI6IFsyMjAsMjIwLDIyMCwxXSwgXCJnaG9zdHdoaXRlXCI6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgXCJnb2xkXCI6IFsyNTUsMjE1LDAsMV0sIFwiZ29sZGVucm9kXCI6IFsyMTgsMTY1LDMyLDFdLFxuICBcImdyYXlcIjogWzEyOCwxMjgsMTI4LDFdLCBcImdyZWVuXCI6IFswLDEyOCwwLDFdLFxuICBcImdyZWVueWVsbG93XCI6IFsxNzMsMjU1LDQ3LDFdLCBcImdyZXlcIjogWzEyOCwxMjgsMTI4LDFdLFxuICBcImhvbmV5ZGV3XCI6IFsyNDAsMjU1LDI0MCwxXSwgXCJob3RwaW5rXCI6IFsyNTUsMTA1LDE4MCwxXSxcbiAgXCJpbmRpYW5yZWRcIjogWzIwNSw5Miw5MiwxXSwgXCJpbmRpZ29cIjogWzc1LDAsMTMwLDFdLFxuICBcIml2b3J5XCI6IFsyNTUsMjU1LDI0MCwxXSwgXCJraGFraVwiOiBbMjQwLDIzMCwxNDAsMV0sXG4gIFwibGF2ZW5kZXJcIjogWzIzMCwyMzAsMjUwLDFdLCBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwyNDAsMjQ1LDFdLFxuICBcImxhd25ncmVlblwiOiBbMTI0LDI1MiwwLDFdLCBcImxlbW9uY2hpZmZvblwiOiBbMjU1LDI1MCwyMDUsMV0sXG4gIFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMCwxXSwgXCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOCwxXSxcbiAgXCJsaWdodGN5YW5cIjogWzIyNCwyNTUsMjU1LDFdLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsMjUwLDIxMCwxXSxcbiAgXCJsaWdodGdyYXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0Z3JlZW5cIjogWzE0NCwyMzgsMTQ0LDFdLFxuICBcImxpZ2h0Z3JleVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRwaW5rXCI6IFsyNTUsMTgyLDE5MywxXSxcbiAgXCJsaWdodHNhbG1vblwiOiBbMjU1LDE2MCwxMjIsMV0sIFwibGlnaHRzZWFncmVlblwiOiBbMzIsMTc4LDE3MCwxXSxcbiAgXCJsaWdodHNreWJsdWVcIjogWzEzNSwyMDYsMjUwLDFdLCBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksMTM2LDE1MywxXSxcbiAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LDEzNiwxNTMsMV0sIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwxOTYsMjIyLDFdLFxuICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsMjU1LDIyNCwxXSwgXCJsaW1lXCI6IFswLDI1NSwwLDFdLFxuICBcImxpbWVncmVlblwiOiBbNTAsMjA1LDUwLDFdLCBcImxpbmVuXCI6IFsyNTAsMjQwLDIzMCwxXSxcbiAgXCJtYWdlbnRhXCI6IFsyNTUsMCwyNTUsMV0sIFwibWFyb29uXCI6IFsxMjgsMCwwLDFdLFxuICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwyMDUsMTcwLDFdLCBcIm1lZGl1bWJsdWVcIjogWzAsMCwyMDUsMV0sXG4gIFwibWVkaXVtb3JjaGlkXCI6IFsxODYsODUsMjExLDFdLCBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LDExMiwyMTksMV0sXG4gIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTMsMV0sIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsMTA0LDIzOCwxXSxcbiAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwyNTAsMTU0LDFdLCBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsMjA5LDIwNCwxXSxcbiAgXCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwyMSwxMzMsMV0sIFwibWlkbmlnaHRibHVlXCI6IFsyNSwyNSwxMTIsMV0sXG4gIFwibWludGNyZWFtXCI6IFsyNDUsMjU1LDI1MCwxXSwgXCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1LDFdLFxuICBcIm1vY2Nhc2luXCI6IFsyNTUsMjI4LDE4MSwxXSwgXCJuYXZham93aGl0ZVwiOiBbMjU1LDIyMiwxNzMsMV0sXG4gIFwibmF2eVwiOiBbMCwwLDEyOCwxXSwgXCJvbGRsYWNlXCI6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgXCJvbGl2ZVwiOiBbMTI4LDEyOCwwLDFdLCBcIm9saXZlZHJhYlwiOiBbMTA3LDE0MiwzNSwxXSxcbiAgXCJvcmFuZ2VcIjogWzI1NSwxNjUsMCwxXSwgXCJvcmFuZ2VyZWRcIjogWzI1NSw2OSwwLDFdLFxuICBcIm9yY2hpZFwiOiBbMjE4LDExMiwyMTQsMV0sIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LDIzMiwxNzAsMV0sXG4gIFwicGFsZWdyZWVuXCI6IFsxNTIsMjUxLDE1MiwxXSwgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOCwxXSxcbiAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksMTEyLDE0NywxXSwgXCJwYXBheWF3aGlwXCI6IFsyNTUsMjM5LDIxMywxXSxcbiAgXCJwZWFjaHB1ZmZcIjogWzI1NSwyMTgsMTg1LDFdLCBcInBlcnVcIjogWzIwNSwxMzMsNjMsMV0sXG4gIFwicGlua1wiOiBbMjU1LDE5MiwyMDMsMV0sIFwicGx1bVwiOiBbMjIxLDE2MCwyMjEsMV0sXG4gIFwicG93ZGVyYmx1ZVwiOiBbMTc2LDIyNCwyMzAsMV0sIFwicHVycGxlXCI6IFsxMjgsMCwxMjgsMV0sXG4gIFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLDUxLDE1MywxXSxcbiAgXCJyZWRcIjogWzI1NSwwLDAsMV0sIFwicm9zeWJyb3duXCI6IFsxODgsMTQzLDE0MywxXSxcbiAgXCJyb3lhbGJsdWVcIjogWzY1LDEwNSwyMjUsMV0sIFwic2FkZGxlYnJvd25cIjogWzEzOSw2OSwxOSwxXSxcbiAgXCJzYWxtb25cIjogWzI1MCwxMjgsMTE0LDFdLCBcInNhbmR5YnJvd25cIjogWzI0NCwxNjQsOTYsMV0sXG4gIFwic2VhZ3JlZW5cIjogWzQ2LDEzOSw4NywxXSwgXCJzZWFzaGVsbFwiOiBbMjU1LDI0NSwyMzgsMV0sXG4gIFwic2llbm5hXCI6IFsxNjAsODIsNDUsMV0sIFwic2lsdmVyXCI6IFsxOTIsMTkyLDE5MiwxXSxcbiAgXCJza3libHVlXCI6IFsxMzUsMjA2LDIzNSwxXSwgXCJzbGF0ZWJsdWVcIjogWzEwNiw5MCwyMDUsMV0sXG4gIFwic2xhdGVncmF5XCI6IFsxMTIsMTI4LDE0NCwxXSwgXCJzbGF0ZWdyZXlcIjogWzExMiwxMjgsMTQ0LDFdLFxuICBcInNub3dcIjogWzI1NSwyNTAsMjUwLDFdLCBcInNwcmluZ2dyZWVuXCI6IFswLDI1NSwxMjcsMV0sXG4gIFwic3RlZWxibHVlXCI6IFs3MCwxMzAsMTgwLDFdLCBcInRhblwiOiBbMjEwLDE4MCwxNDAsMV0sXG4gIFwidGVhbFwiOiBbMCwxMjgsMTI4LDFdLCBcInRoaXN0bGVcIjogWzIxNiwxOTEsMjE2LDFdLFxuICBcInRvbWF0b1wiOiBbMjU1LDk5LDcxLDFdLCBcInR1cnF1b2lzZVwiOiBbNjQsMjI0LDIwOCwxXSxcbiAgXCJ2aW9sZXRcIjogWzIzOCwxMzAsMjM4LDFdLCBcIndoZWF0XCI6IFsyNDUsMjIyLDE3OSwxXSxcbiAgXCJ3aGl0ZVwiOiBbMjU1LDI1NSwyNTUsMV0sIFwid2hpdGVzbW9rZVwiOiBbMjQ1LDI0NSwyNDUsMV0sXG4gIFwieWVsbG93XCI6IFsyNTUsMjU1LDAsMV0sIFwieWVsbG93Z3JlZW5cIjogWzE1NCwyMDUsNTAsMV19O1xuXG5mdW5jdGlvbiBjbGFtcF9jc3NfYnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19mbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHsgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7IH1cbiAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlSW50KHN0cikpO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfZmxvYXQoc3RyKSB7ICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHsgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApOyB9XG4gIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbn1cblxuZnVuY3Rpb24gY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSB7XG4gIGlmIChoIDwgMCkgeyBoICs9IDE7IH1cbiAgZWxzZSBpZiAoaCA+IDEpIHsgaCAtPSAxOyB9XG5cbiAgaWYgKGggKiA2IDwgMSkgeyByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjsgfVxuICBpZiAoaCAqIDIgPCAxKSB7IHJldHVybiBtMjsgfVxuICBpZiAoaCAqIDMgPCAyKSB7IHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7IH1cbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNTU0NvbG9yKGNzc19zdHIpIHtcbiAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gIHZhciBzdHIgPSBjc3Nfc3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSB7IHJldHVybiBrQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7IH0gIC8vIGR1cC5cblxuICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZikpIHsgcmV0dXJuIG51bGw7IH0gIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWygoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHsgcmV0dXJuIG51bGw7IH0gIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wKzEsIGVwLShvcCsxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgcmV0dXJuIFtwYXJzZV9jc3NfaW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KHBhcmFtc1swXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjA7ICAvLyAwIC4uIDFcbiAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgdmFyIHMgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzFdKTtcbiAgICAgICAgdmFyIGwgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzJdKTtcbiAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBtMSA9IGwgKiAyIC0gbTI7XG4gICAgICAgIHJldHVybiBbY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKzEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaC0xLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudHJ5IHsgZXhwb3J0cy5wYXJzZUNTU0NvbG9yID0gcGFyc2VDU1NDb2xvcjsgfSBjYXRjaChlKSB7IH1cbn0pO1xudmFyIGNzc2NvbG9ycGFyc2VyXzEgPSBjc3Njb2xvcnBhcnNlci5wYXJzZUNTU0NvbG9yO1xuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiBDb2xvcihyLCBnLCBiLCBhKSB7XG4gICAgaWYgKGEgPT09IHZvaWQgMClcbiAgICAgICAgYSA9IDE7XG4gICAgdGhpcy5yID0gcjtcbiAgICB0aGlzLmcgPSBnO1xuICAgIHRoaXMuYiA9IGI7XG4gICAgdGhpcy5hID0gYTtcbn07XG5Db2xvci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciByZ2JhID0gY3NzY29sb3JwYXJzZXJfMShpbnB1dCk7XG4gICAgaWYgKCFyZ2JhKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29sb3IocmdiYVswXSAvIDI1NSAqIHJnYmFbM10sIHJnYmFbMV0gLyAyNTUgKiByZ2JhWzNdLCByZ2JhWzJdIC8gMjU1ICogcmdiYVszXSwgcmdiYVszXSk7XG59O1xuQ29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMudG9BcnJheSgpO1xuICAgIHZhciByID0gcmVmWzBdO1xuICAgIHZhciBnID0gcmVmWzFdO1xuICAgIHZhciBiID0gcmVmWzJdO1xuICAgIHZhciBhID0gcmVmWzNdO1xuICAgIHJldHVybiAncmdiYSgnICsgTWF0aC5yb3VuZChyKSArICcsJyArIE1hdGgucm91bmQoZykgKyAnLCcgKyBNYXRoLnJvdW5kKGIpICsgJywnICsgYSArICcpJztcbn07XG5Db2xvci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIHIgPSByZWYucjtcbiAgICB2YXIgZyA9IHJlZi5nO1xuICAgIHZhciBiID0gcmVmLmI7XG4gICAgdmFyIGEgPSByZWYuYTtcbiAgICByZXR1cm4gYSA9PT0gMCA/IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgIF0gOiBbXG4gICAgICAgIHIgKiAyNTUgLyBhLFxuICAgICAgICBnICogMjU1IC8gYSxcbiAgICAgICAgYiAqIDI1NSAvIGEsXG4gICAgICAgIGFcbiAgICBdO1xufTtcbkNvbG9yLmJsYWNrID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xuQ29sb3Iud2hpdGUgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSk7XG5Db2xvci50cmFuc3BhcmVudCA9IG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcbkNvbG9yLnJlZCA9IG5ldyBDb2xvcigxLCAwLCAwLCAxKTtcblxudmFyIENvbGxhdG9yID0gZnVuY3Rpb24gQ29sbGF0b3IoY2FzZVNlbnNpdGl2ZSwgZGlhY3JpdGljU2Vuc2l0aXZlLCBsb2NhbGUpIHtcbiAgICBpZiAoY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICB0aGlzLnNlbnNpdGl2aXR5ID0gZGlhY3JpdGljU2Vuc2l0aXZlID8gJ3ZhcmlhbnQnIDogJ2Nhc2UnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSBkaWFjcml0aWNTZW5zaXRpdmUgPyAnYWNjZW50JyA6ICdiYXNlJztcbiAgICB9XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5jb2xsYXRvciA9IG5ldyBJbnRsLkNvbGxhdG9yKHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUgOiBbXSwge1xuICAgICAgICBzZW5zaXRpdml0eTogdGhpcy5zZW5zaXRpdml0eSxcbiAgICAgICAgdXNhZ2U6ICdzZWFyY2gnXG4gICAgfSk7XG59O1xuQ29sbGF0b3IucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGF0b3IuY29tcGFyZShsaHMsIHJocyk7XG59O1xuQ29sbGF0b3IucHJvdG90eXBlLnJlc29sdmVkTG9jYWxlID0gZnVuY3Rpb24gcmVzb2x2ZWRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRsLkNvbGxhdG9yKHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUgOiBbXSkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlO1xufTtcblxudmFyIEZvcm1hdHRlZFNlY3Rpb24gPSBmdW5jdGlvbiBGb3JtYXR0ZWRTZWN0aW9uKHRleHQsIGltYWdlLCBzY2FsZSwgZm9udFN0YWNrLCB0ZXh0Q29sb3IpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5mb250U3RhY2sgPSBmb250U3RhY2s7XG4gICAgdGhpcy50ZXh0Q29sb3IgPSB0ZXh0Q29sb3I7XG59O1xudmFyIEZvcm1hdHRlZCA9IGZ1bmN0aW9uIEZvcm1hdHRlZChzZWN0aW9ucykge1xuICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9ucztcbn07XG5Gb3JtYXR0ZWQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcodW5mb3JtYXR0ZWQpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdHRlZChbbmV3IEZvcm1hdHRlZFNlY3Rpb24odW5mb3JtYXR0ZWQsIG51bGwsIG51bGwsIG51bGwsIG51bGwpXSk7XG59O1xuRm9ybWF0dGVkLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy5zZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5zZWN0aW9ucy5zb21lKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBzZWN0aW9uLnRleHQubGVuZ3RoICE9PSAwIHx8IHNlY3Rpb24uaW1hZ2UgJiYgc2VjdGlvbi5pbWFnZS5uYW1lLmxlbmd0aCAhPT0gMDtcbiAgICB9KTtcbn07XG5Gb3JtYXR0ZWQuZmFjdG9yeSA9IGZ1bmN0aW9uIGZhY3RvcnkodGV4dCkge1xuICAgIGlmICh0ZXh0IGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZWQuZnJvbVN0cmluZyh0ZXh0KTtcbiAgICB9XG59O1xuRm9ybWF0dGVkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlY3Rpb25zLm1hcChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gc2VjdGlvbi50ZXh0O1xuICAgIH0pLmpvaW4oJycpO1xufTtcbkZvcm1hdHRlZC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gWydmb3JtYXQnXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHRoaXMuc2VjdGlvbnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKHNlY3Rpb24uaW1hZ2UpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChbXG4gICAgICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICBzZWN0aW9uLmltYWdlLm5hbWVcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKHNlY3Rpb24udGV4dCk7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChzZWN0aW9uLmZvbnRTdGFjaykge1xuICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1mb250J10gPSBbXG4gICAgICAgICAgICAgICAgJ2xpdGVyYWwnLFxuICAgICAgICAgICAgICAgIHNlY3Rpb24uZm9udFN0YWNrLnNwbGl0KCcsJylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb24uc2NhbGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ2ZvbnQtc2NhbGUnXSA9IHNlY3Rpb24uc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb24udGV4dENvbG9yKSB7XG4gICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWNvbG9yJ10gPSBbJ3JnYmEnXS5jb25jYXQoc2VjdGlvbi50ZXh0Q29sb3IudG9BcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkLnB1c2gob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIFJlc29sdmVkSW1hZ2UgPSBmdW5jdGlvbiBSZXNvbHZlZEltYWdlKG9wdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5hdmFpbGFibGUgPSBvcHRpb25zLmF2YWlsYWJsZTtcbn07XG5SZXNvbHZlZEltYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG59O1xuUmVzb2x2ZWRJbWFnZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlc29sdmVkSW1hZ2Uoe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBhdmFpbGFibGU6IGZhbHNlXG4gICAgfSk7XG59O1xuUmVzb2x2ZWRJbWFnZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgIHRoaXMubmFtZVxuICAgIF07XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVJHQkEociwgZywgYiwgYSkge1xuICAgIGlmICghKHR5cGVvZiByID09PSAnbnVtYmVyJyAmJiByID49IDAgJiYgciA8PSAyNTUgJiYgdHlwZW9mIGcgPT09ICdudW1iZXInICYmIGcgPj0gMCAmJiBnIDw9IDI1NSAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicgJiYgYiA+PSAwICYmIGIgPD0gMjU1KSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBbXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBhXG4gICAgICAgIF0gOiBbXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIGJcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuICdJbnZhbGlkIHJnYmEgdmFsdWUgWycgKyB2YWx1ZS5qb2luKCcsICcpICsgJ106IFxcJ3JcXCcsIFxcJ2dcXCcsIGFuZCBcXCdiXFwnIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTUuJztcbiAgICB9XG4gICAgaWYgKCEodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiBhID49IDAgJiYgYSA8PSAxKSkge1xuICAgICAgICByZXR1cm4gJ0ludmFsaWQgcmdiYSB2YWx1ZSBbJyArIFtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGFcbiAgICAgICAgXS5qb2luKCcsICcpICsgJ106IFxcJ2FcXCcgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1ZhbHVlKG1peGVkKSB7XG4gICAgaWYgKG1peGVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIENvbGxhdG9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiBGb3JtYXR0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIFJlc29sdmVkSW1hZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1peGVkKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG1peGVkOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbHVlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWl4ZWQpIHtcbiAgICAgICAgICAgIGlmICghaXNWYWx1ZShtaXhlZFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdHlwZU9mKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBOdWxsVHlwZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZ1R5cGU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gQm9vbGVhblR5cGU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXJUeXBlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICByZXR1cm4gQ29sb3JUeXBlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBDb2xsYXRvcikge1xuICAgICAgICByZXR1cm4gQ29sbGF0b3JUeXBlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGb3JtYXR0ZWQpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlZFR5cGU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlc29sdmVkSW1hZ2UpIHtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVkSW1hZ2VUeXBlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW1UeXBlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHZhbHVlOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgdmFyIHQgPSB0eXBlT2YoaXRlbSk7XG4gICAgICAgICAgICBpZiAoIWl0ZW1UeXBlKSB7XG4gICAgICAgICAgICAgICAgaXRlbVR5cGUgPSB0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtVHlwZSA9PT0gdCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtVHlwZSA9IFZhbHVlVHlwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXkoaXRlbVR5cGUgfHwgVmFsdWVUeXBlLCBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPYmplY3RUeXBlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU3RyaW5nJDEodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBDb2xvciB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZvcm1hdHRlZCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlc29sdmVkSW1hZ2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG59XG5cbnZhciBMaXRlcmFsID0gZnVuY3Rpb24gTGl0ZXJhbCh0eXBlLCB2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufTtcbkxpdGVyYWwucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdcXCdsaXRlcmFsXFwnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIGJ1dCBmb3VuZCAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmICghaXNWYWx1ZShhcmdzWzFdKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignaW52YWxpZCB2YWx1ZScpO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBhcmdzWzFdO1xuICAgIHZhciB0eXBlID0gdHlwZU9mKHZhbHVlKTtcbiAgICB2YXIgZXhwZWN0ZWQgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICBpZiAodHlwZS5raW5kID09PSAnYXJyYXknICYmIHR5cGUuTiA9PT0gMCAmJiBleHBlY3RlZCAmJiBleHBlY3RlZC5raW5kID09PSAnYXJyYXknICYmICh0eXBlb2YgZXhwZWN0ZWQuTiAhPT0gJ251bWJlcicgfHwgZXhwZWN0ZWQuTiA9PT0gMCkpIHtcbiAgICAgICAgdHlwZSA9IGV4cGVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExpdGVyYWwodHlwZSwgdmFsdWUpO1xufTtcbkxpdGVyYWwucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG59O1xuTGl0ZXJhbC5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKCkge1xufTtcbkxpdGVyYWwucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcbkxpdGVyYWwucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdhcnJheScgfHwgdGhpcy50eXBlLmtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICB0aGlzLnZhbHVlXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFsncmdiYSddLmNvbmNhdCh0aGlzLnZhbHVlLnRvQXJyYXkoKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnNlcmlhbGl6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbn07XG5cbnZhciBSdW50aW1lRXJyb3IgPSBmdW5jdGlvbiBSdW50aW1lRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubmFtZSA9ICdFeHByZXNzaW9uRXZhbHVhdGlvbkVycm9yJztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufTtcblJ1bnRpbWVFcnJvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG59O1xuXG52YXIgdHlwZXMgPSB7XG4gICAgc3RyaW5nOiBTdHJpbmdUeXBlLFxuICAgIG51bWJlcjogTnVtYmVyVHlwZSxcbiAgICBib29sZWFuOiBCb29sZWFuVHlwZSxcbiAgICBvYmplY3Q6IE9iamVjdFR5cGVcbn07XG52YXIgQXNzZXJ0aW9uID0gZnVuY3Rpb24gQXNzZXJ0aW9uKHR5cGUsIGFyZ3MpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG59O1xuQXNzZXJ0aW9uLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC4nKTtcbiAgICB9XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciB0eXBlO1xuICAgIHZhciBuYW1lID0gYXJnc1swXTtcbiAgICBpZiAobmFtZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICB2YXIgaXRlbVR5cGU7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciB0eXBlJDEgPSBhcmdzWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlJDEgIT09ICdzdHJpbmcnIHx8ICEodHlwZSQxIGluIHR5cGVzKSB8fCB0eXBlJDEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1RoZSBpdGVtIHR5cGUgYXJndW1lbnQgb2YgXCJhcnJheVwiIG11c3QgYmUgb25lIG9mIHN0cmluZywgbnVtYmVyLCBib29sZWFuJywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtVHlwZSA9IHR5cGVzW3R5cGUkMV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtVHlwZSA9IFZhbHVlVHlwZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgTjtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgaWYgKGFyZ3NbMl0gIT09IG51bGwgJiYgKHR5cGVvZiBhcmdzWzJdICE9PSAnbnVtYmVyJyB8fCBhcmdzWzJdIDwgMCB8fCBhcmdzWzJdICE9PSBNYXRoLmZsb29yKGFyZ3NbMl0pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdUaGUgbGVuZ3RoIGFyZ3VtZW50IHRvIFwiYXJyYXlcIiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsaXRlcmFsJywgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBOID0gYXJnc1syXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gYXJyYXkoaXRlbVR5cGUsIE4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSB0eXBlc1tuYW1lXTtcbiAgICB9XG4gICAgdmFyIHBhcnNlZCA9IFtdO1xuICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIGksIFZhbHVlVHlwZSk7XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5wdXNoKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odHlwZSwgcGFyc2VkKTtcbn07XG5Bc3NlcnRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcmdzW2ldLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrU3VidHlwZSh0aGlzLnR5cGUsIHR5cGVPZih2YWx1ZSkpO1xuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gdGhpcy5hcmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgJyArIHRvU3RyaW5nKHRoaXMudHlwZSkgKyAnLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZih2YWx1ZSkpICsgJyBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbkFzc2VydGlvbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgdGhpcy5hcmdzLmZvckVhY2goZm4pO1xufTtcbkFzc2VydGlvbi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmcub3V0cHV0RGVmaW5lZCgpO1xuICAgIH0pO1xufTtcbkFzc2VydGlvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgIHZhciBzZXJpYWxpemVkID0gW3R5cGUua2luZF07XG4gICAgaWYgKHR5cGUua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgICB2YXIgaXRlbVR5cGUgPSB0eXBlLml0ZW1UeXBlO1xuICAgICAgICBpZiAoaXRlbVR5cGUua2luZCA9PT0gJ3N0cmluZycgfHwgaXRlbVR5cGUua2luZCA9PT0gJ251bWJlcicgfHwgaXRlbVR5cGUua2luZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goaXRlbVR5cGUua2luZCk7XG4gICAgICAgICAgICB2YXIgTiA9IHR5cGUuTjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgTiA9PT0gJ251bWJlcicgfHwgdGhpcy5hcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQuY29uY2F0KHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnLnNlcmlhbGl6ZSgpO1xuICAgIH0pKTtcbn07XG5cbnZhciBGb3JtYXRFeHByZXNzaW9uID0gZnVuY3Rpb24gRm9ybWF0RXhwcmVzc2lvbihzZWN0aW9ucykge1xuICAgIHRoaXMudHlwZSA9IEZvcm1hdHRlZFR5cGU7XG4gICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xufTtcbkZvcm1hdEV4cHJlc3Npb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgICB2YXIgZmlyc3RBcmcgPSBhcmdzWzFdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmaXJzdEFyZykgJiYgdHlwZW9mIGZpcnN0QXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBpbWFnZSBvciB0ZXh0IHNlY3Rpb24uJyk7XG4gICAgfVxuICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuICAgIHZhciBuZXh0VG9rZW5NYXlCZU9iamVjdCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGFyZ3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgICAgICBpZiAobmV4dFRva2VuTWF5QmVPYmplY3QgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgbmV4dFRva2VuTWF5QmVPYmplY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJnWydmb250LXNjYWxlJ10pIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IGNvbnRleHQucGFyc2UoYXJnWydmb250LXNjYWxlJ10sIDEsIE51bWJlclR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZvbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGFyZ1sndGV4dC1mb250J10pIHtcbiAgICAgICAgICAgICAgICBmb250ID0gY29udGV4dC5wYXJzZShhcmdbJ3RleHQtZm9udCddLCAxLCBhcnJheShTdHJpbmdUeXBlKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb250KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ZXh0Q29sb3IgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGFyZ1sndGV4dC1jb2xvciddKSB7XG4gICAgICAgICAgICAgICAgdGV4dENvbG9yID0gY29udGV4dC5wYXJzZShhcmdbJ3RleHQtY29sb3InXSwgMSwgQ29sb3JUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRleHRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGFzdEV4cHJlc3Npb24gPSBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxhc3RFeHByZXNzaW9uLnNjYWxlID0gc2NhbGU7XG4gICAgICAgICAgICBsYXN0RXhwcmVzc2lvbi5mb250ID0gZm9udDtcbiAgICAgICAgICAgIGxhc3RFeHByZXNzaW9uLnRleHRDb2xvciA9IHRleHRDb2xvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIga2luZCA9IGNvbnRlbnQudHlwZS5raW5kO1xuICAgICAgICAgICAgaWYgKGtpbmQgIT09ICdzdHJpbmcnICYmIGtpbmQgIT09ICd2YWx1ZScgJiYga2luZCAhPT0gJ251bGwnICYmIGtpbmQgIT09ICdyZXNvbHZlZEltYWdlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdGb3JtYXR0ZWQgdGV4dCB0eXBlIG11c3QgYmUgXFwnc3RyaW5nXFwnLCBcXCd2YWx1ZVxcJywgXFwnaW1hZ2VcXCcgb3IgXFwnbnVsbFxcJy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgc2NhbGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZm9udDogbnVsbCxcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRm9ybWF0RXhwcmVzc2lvbihzZWN0aW9ucyk7XG59O1xuRm9ybWF0RXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgZXZhbHVhdGVTZWN0aW9uID0gZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGV2YWx1YXRlZENvbnRlbnQgPSBzZWN0aW9uLmNvbnRlbnQuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgaWYgKHR5cGVPZihldmFsdWF0ZWRDb250ZW50KSA9PT0gUmVzb2x2ZWRJbWFnZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkU2VjdGlvbignJywgZXZhbHVhdGVkQ29udGVudCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWRTZWN0aW9uKHRvU3RyaW5nJDEoZXZhbHVhdGVkQ29udGVudCksIG51bGwsIHNlY3Rpb24uc2NhbGUgPyBzZWN0aW9uLnNjYWxlLmV2YWx1YXRlKGN0eCkgOiBudWxsLCBzZWN0aW9uLmZvbnQgPyBzZWN0aW9uLmZvbnQuZXZhbHVhdGUoY3R4KS5qb2luKCcsJykgOiBudWxsLCBzZWN0aW9uLnRleHRDb2xvciA/IHNlY3Rpb24udGV4dENvbG9yLmV2YWx1YXRlKGN0eCkgOiBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgRm9ybWF0dGVkKHRoaXMuc2VjdGlvbnMubWFwKGV2YWx1YXRlU2VjdGlvbikpO1xufTtcbkZvcm1hdEV4cHJlc3Npb24ucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5zZWN0aW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBsaXN0W2ldO1xuICAgICAgICBmbihzZWN0aW9uLmNvbnRlbnQpO1xuICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkge1xuICAgICAgICAgICAgZm4oc2VjdGlvbi5zY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb24uZm9udCkge1xuICAgICAgICAgICAgZm4oc2VjdGlvbi5mb250KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbi50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIGZuKHNlY3Rpb24udGV4dENvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5Gb3JtYXRFeHByZXNzaW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuRm9ybWF0RXhwcmVzc2lvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gWydmb3JtYXQnXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHRoaXMuc2VjdGlvbnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gbGlzdFtpXTtcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKHNlY3Rpb24uY29udGVudC5zZXJpYWxpemUoKSk7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChzZWN0aW9uLnNjYWxlKSB7XG4gICAgICAgICAgICBvcHRpb25zWydmb250LXNjYWxlJ10gPSBzZWN0aW9uLnNjYWxlLnNlcmlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uLmZvbnQpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ3RleHQtZm9udCddID0gc2VjdGlvbi5mb250LnNlcmlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uLnRleHRDb2xvcikge1xuICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1jb2xvciddID0gc2VjdGlvbi50ZXh0Q29sb3Iuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbnZhciBJbWFnZUV4cHJlc3Npb24gPSBmdW5jdGlvbiBJbWFnZUV4cHJlc3Npb24oaW5wdXQpIHtcbiAgICB0aGlzLnR5cGUgPSBSZXNvbHZlZEltYWdlVHlwZTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG59O1xuSW1hZ2VFeHByZXNzaW9uLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgdHdvIGFyZ3VtZW50cy4nKTtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFN0cmluZ1R5cGUpO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignTm8gaW1hZ2UgbmFtZSBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbWFnZUV4cHJlc3Npb24obmFtZSk7XG59O1xuSW1hZ2VFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBldmFsdWF0ZWRJbWFnZU5hbWUgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7XG4gICAgdmFyIHZhbHVlID0gUmVzb2x2ZWRJbWFnZS5mcm9tU3RyaW5nKGV2YWx1YXRlZEltYWdlTmFtZSk7XG4gICAgaWYgKHZhbHVlICYmIGN0eC5hdmFpbGFibGVJbWFnZXMpIHtcbiAgICAgICAgdmFsdWUuYXZhaWxhYmxlID0gY3R4LmF2YWlsYWJsZUltYWdlcy5pbmRleE9mKGV2YWx1YXRlZEltYWdlTmFtZSkgPiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbkltYWdlRXhwcmVzc2lvbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5pbnB1dCk7XG59O1xuSW1hZ2VFeHByZXNzaW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuSW1hZ2VFeHByZXNzaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKVxuICAgIF07XG59O1xuXG52YXIgdHlwZXMkMSA9IHtcbiAgICAndG8tYm9vbGVhbic6IEJvb2xlYW5UeXBlLFxuICAgICd0by1jb2xvcic6IENvbG9yVHlwZSxcbiAgICAndG8tbnVtYmVyJzogTnVtYmVyVHlwZSxcbiAgICAndG8tc3RyaW5nJzogU3RyaW5nVHlwZVxufTtcbnZhciBDb2VyY2lvbiA9IGZ1bmN0aW9uIENvZXJjaW9uKHR5cGUsIGFyZ3MpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG59O1xuQ29lcmNpb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IGFyZ3NbMF07XG4gICAgaWYgKChuYW1lID09PSAndG8tYm9vbGVhbicgfHwgbmFtZSA9PT0gJ3RvLXN0cmluZycpICYmIGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBvbmUgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIHZhciB0eXBlID0gdHlwZXMkMVtuYW1lXTtcbiAgICB2YXIgcGFyc2VkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgaSwgVmFsdWVUeXBlKTtcbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLnB1c2goaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvZXJjaW9uKHR5cGUsIHBhcnNlZCk7XG59O1xuQ29lcmNpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgaWYgKHRoaXMudHlwZS5raW5kID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5hcmdzWzBdLmV2YWx1YXRlKGN0eCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdjb2xvcicpIHtcbiAgICAgICAgdmFyIGlucHV0O1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5hcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGFyZyA9IGxpc3RbaV07XG4gICAgICAgICAgICBpbnB1dCA9IGFyZy5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGN0eC5wYXJzZUNvbG9yKGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA8IDMgfHwgaW5wdXQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICdJbnZhbGlkIHJiZ2EgdmFsdWUgJyArIEpTT04uc3RyaW5naWZ5KGlucHV0KSArICc6IGV4cGVjdGVkIGFuIGFycmF5IGNvbnRhaW5pbmcgZWl0aGVyIHRocmVlIG9yIGZvdXIgbnVtZXJpYyB2YWx1ZXMuJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHZhbGlkYXRlUkdCQShpbnB1dFswXSwgaW5wdXRbMV0sIGlucHV0WzJdLCBpbnB1dFszXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihpbnB1dFswXSAvIDI1NSwgaW5wdXRbMV0gLyAyNTUsIGlucHV0WzJdIC8gMjU1LCBpbnB1dFszXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoZXJyb3IgfHwgJ0NvdWxkIG5vdCBwYXJzZSBjb2xvciBmcm9tIHZhbHVlIFxcJycgKyAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyA/IGlucHV0IDogU3RyaW5nKEpTT04uc3RyaW5naWZ5KGlucHV0KSkpICsgJ1xcJycpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHRoaXMuYXJnczsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBhcmckMSA9IGxpc3QkMVtpJDFdO1xuICAgICAgICAgICAgdmFsdWUgPSBhcmckMS5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnIHRvIG51bWJlci4nKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5raW5kID09PSAnZm9ybWF0dGVkJykge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVkLmZyb21TdHJpbmcodG9TdHJpbmckMSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdyZXNvbHZlZEltYWdlJykge1xuICAgICAgICByZXR1cm4gUmVzb2x2ZWRJbWFnZS5mcm9tU3RyaW5nKHRvU3RyaW5nJDEodGhpcy5hcmdzWzBdLmV2YWx1YXRlKGN0eCkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmckMSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSk7XG4gICAgfVxufTtcbkNvZXJjaW9uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG59O1xuQ29lcmNpb24ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnLm91dHB1dERlZmluZWQoKTtcbiAgICB9KTtcbn07XG5Db2VyY2lvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2Zvcm1hdHRlZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXRFeHByZXNzaW9uKFt7XG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5hcmdzWzBdLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICAgICAgICAgIGZvbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiBudWxsXG4gICAgICAgICAgICB9XSkuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VFeHByZXNzaW9uKHRoaXMuYXJnc1swXSkuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIHZhciBzZXJpYWxpemVkID0gWyd0by0nICsgdGhpcy50eXBlLmtpbmRdO1xuICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIGdlb21ldHJ5VHlwZXMgPSBbXG4gICAgJ1Vua25vd24nLFxuICAgICdQb2ludCcsXG4gICAgJ0xpbmVTdHJpbmcnLFxuICAgICdQb2x5Z29uJ1xuXTtcbnZhciBFdmFsdWF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIEV2YWx1YXRpb25Db250ZXh0KCkge1xuICAgIHRoaXMuZ2xvYmFscyA9IG51bGw7XG4gICAgdGhpcy5mZWF0dXJlID0gbnVsbDtcbiAgICB0aGlzLmZlYXR1cmVTdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5mb3JtYXR0ZWRTZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLl9wYXJzZUNvbG9yQ2FjaGUgPSB7fTtcbiAgICB0aGlzLmF2YWlsYWJsZUltYWdlcyA9IG51bGw7XG4gICAgdGhpcy5jYW5vbmljYWwgPSBudWxsO1xufTtcbkV2YWx1YXRpb25Db250ZXh0LnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uIGlkKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgJ2lkJyBpbiB0aGlzLmZlYXR1cmUgPyB0aGlzLmZlYXR1cmUuaWQgOiBudWxsO1xufTtcbkV2YWx1YXRpb25Db250ZXh0LnByb3RvdHlwZS5nZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZW9tZXRyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZSA/IHR5cGVvZiB0aGlzLmZlYXR1cmUudHlwZSA9PT0gJ251bWJlcicgPyBnZW9tZXRyeVR5cGVzW3RoaXMuZmVhdHVyZS50eXBlXSA6IHRoaXMuZmVhdHVyZS50eXBlIDogbnVsbDtcbn07XG5FdmFsdWF0aW9uQ29udGV4dC5wcm90b3R5cGUuZ2VvbWV0cnkgPSBmdW5jdGlvbiBnZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlICYmICdnZW9tZXRyeScgaW4gdGhpcy5mZWF0dXJlID8gdGhpcy5mZWF0dXJlLmdlb21ldHJ5IDogbnVsbDtcbn07XG5FdmFsdWF0aW9uQ29udGV4dC5wcm90b3R5cGUuY2Fub25pY2FsSUQgPSBmdW5jdGlvbiBjYW5vbmljYWxJRCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5vbmljYWw7XG59O1xuRXZhbHVhdGlvbkNvbnRleHQucHJvdG90eXBlLnByb3BlcnRpZXMgPSBmdW5jdGlvbiBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLnByb3BlcnRpZXMgfHwge307XG59O1xuRXZhbHVhdGlvbkNvbnRleHQucHJvdG90eXBlLnBhcnNlQ29sb3IgPSBmdW5jdGlvbiBwYXJzZUNvbG9yKGlucHV0KSB7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuX3BhcnNlQ29sb3JDYWNoZVtpbnB1dF07XG4gICAgaWYgKCFjYWNoZWQpIHtcbiAgICAgICAgY2FjaGVkID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW2lucHV0XSA9IENvbG9yLnBhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbn07XG5cbnZhciBDb21wb3VuZEV4cHJlc3Npb24gPSBmdW5jdGlvbiBDb21wb3VuZEV4cHJlc3Npb24obmFtZSwgdHlwZSwgZXZhbHVhdGUsIGFyZ3MpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fZXZhbHVhdGUgPSBldmFsdWF0ZTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xufTtcbkNvbXBvdW5kRXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGUoY3R4LCB0aGlzLmFyZ3MpO1xufTtcbkNvbXBvdW5kRXhwcmVzc2lvbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgdGhpcy5hcmdzLmZvckVhY2goZm4pO1xufTtcbkNvbXBvdW5kRXhwcmVzc2lvbi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbkNvbXBvdW5kRXhwcmVzc2lvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBbdGhpcy5uYW1lXS5jb25jYXQodGhpcy5hcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmcuc2VyaWFsaXplKCk7XG4gICAgfSkpO1xufTtcbkNvbXBvdW5kRXhwcmVzc2lvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVmJDE7XG4gICAgdmFyIG9wID0gYXJnc1swXTtcbiAgICB2YXIgZGVmaW5pdGlvbiA9IENvbXBvdW5kRXhwcmVzc2lvbi5kZWZpbml0aW9uc1tvcF07XG4gICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdVbmtub3duIGV4cHJlc3Npb24gXCInICsgb3AgKyAnXCIuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uJywgMCk7XG4gICAgfVxuICAgIHZhciB0eXBlID0gQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSA/IGRlZmluaXRpb25bMF0gOiBkZWZpbml0aW9uLnR5cGU7XG4gICAgdmFyIGF2YWlsYWJsZU92ZXJsb2FkcyA9IEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikgPyBbW1xuICAgICAgICAgICAgZGVmaW5pdGlvblsxXSxcbiAgICAgICAgICAgIGRlZmluaXRpb25bMl1cbiAgICAgICAgXV0gOiBkZWZpbml0aW9uLm92ZXJsb2FkcztcbiAgICB2YXIgb3ZlcmxvYWRzID0gYXZhaWxhYmxlT3ZlcmxvYWRzLmZpbHRlcihmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSByZWZbMF07XG4gICAgICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShzaWduYXR1cmUpIHx8IHNpZ25hdHVyZS5sZW5ndGggPT09IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICB9KTtcbiAgICB2YXIgc2lnbmF0dXJlQ29udGV4dCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSQzID0gMCwgbGlzdCA9IG92ZXJsb2FkczsgaSQzIDwgbGlzdC5sZW5ndGg7IGkkMyArPSAxKSB7XG4gICAgICAgIHZhciByZWYgPSBsaXN0W2kkM107XG4gICAgICAgIHZhciBwYXJhbXMgPSByZWZbMF07XG4gICAgICAgIHZhciBldmFsdWF0ZSA9IHJlZlsxXTtcbiAgICAgICAgc2lnbmF0dXJlQ29udGV4dCA9IG5ldyBQYXJzaW5nQ29udGV4dChjb250ZXh0LnJlZ2lzdHJ5LCBjb250ZXh0LnBhdGgsIG51bGwsIGNvbnRleHQuc2NvcGUpO1xuICAgICAgICB2YXIgcGFyc2VkQXJncyA9IFtdO1xuICAgICAgICB2YXIgYXJnUGFyc2VGYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZFR5cGUgPSBBcnJheS5pc0FycmF5KHBhcmFtcykgPyBwYXJhbXNbaSAtIDFdIDogcGFyYW1zLnR5cGU7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gc2lnbmF0dXJlQ29udGV4dC5wYXJzZShhcmcsIDEgKyBwYXJzZWRBcmdzLmxlbmd0aCwgZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgYXJnUGFyc2VGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VkQXJncy5wdXNoKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ1BhcnNlRmFpbGVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gcGFyc2VkQXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVDb250ZXh0LmVycm9yKCdFeHBlY3RlZCAnICsgcGFyYW1zLmxlbmd0aCArICcgYXJndW1lbnRzLCBidXQgZm91bmQgJyArIHBhcnNlZEFyZ3MubGVuZ3RoICsgJyBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBhcnNlZEFyZ3MubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gQXJyYXkuaXNBcnJheShwYXJhbXMpID8gcGFyYW1zW2kkMV0gOiBwYXJhbXMudHlwZTtcbiAgICAgICAgICAgIHZhciBhcmckMSA9IHBhcnNlZEFyZ3NbaSQxXTtcbiAgICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQuY29uY2F0KGkkMSArIDEpLmNoZWNrU3VidHlwZShleHBlY3RlZCwgYXJnJDEudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ25hdHVyZUNvbnRleHQuZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZEV4cHJlc3Npb24ob3AsIHR5cGUsIGV2YWx1YXRlLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3ZlcmxvYWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAocmVmJDEgPSBjb250ZXh0LmVycm9ycykucHVzaC5hcHBseShyZWYkMSwgc2lnbmF0dXJlQ29udGV4dC5lcnJvcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBlY3RlZCQxID0gb3ZlcmxvYWRzLmxlbmd0aCA/IG92ZXJsb2FkcyA6IGF2YWlsYWJsZU92ZXJsb2FkcztcbiAgICAgICAgdmFyIHNpZ25hdHVyZXMgPSBleHBlY3RlZCQxLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVNpZ25hdHVyZShwYXJhbXMpO1xuICAgICAgICB9KS5qb2luKCcgfCAnKTtcbiAgICAgICAgdmFyIGFjdHVhbFR5cGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGFyZ3MubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCQxID0gY29udGV4dC5wYXJzZShhcmdzW2kkMl0sIDEgKyBhY3R1YWxUeXBlcy5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKCFwYXJzZWQkMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0dWFsVHlwZXMucHVzaCh0b1N0cmluZyhwYXJzZWQkMS50eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXJndW1lbnRzIG9mIHR5cGUgJyArIHNpZ25hdHVyZXMgKyAnLCBidXQgZm91bmQgKCcgKyBhY3R1YWxUeXBlcy5qb2luKCcsICcpICsgJykgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIocmVnaXN0cnksIGRlZmluaXRpb25zKSB7XG4gICAgQ29tcG91bmRFeHByZXNzaW9uLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBkZWZpbml0aW9ucykge1xuICAgICAgICByZWdpc3RyeVtuYW1lXSA9IENvbXBvdW5kRXhwcmVzc2lvbjtcbiAgICB9XG59O1xuZnVuY3Rpb24gc3RyaW5naWZ5U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNpZ25hdHVyZSkpIHtcbiAgICAgICAgcmV0dXJuICcoJyArIHNpZ25hdHVyZS5tYXAodG9TdHJpbmcpLmpvaW4oJywgJykgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcoJyArIHRvU3RyaW5nKHNpZ25hdHVyZS50eXBlKSArICcuLi4pJztcbiAgICB9XG59XG5cbnZhciBDb2xsYXRvckV4cHJlc3Npb24gPSBmdW5jdGlvbiBDb2xsYXRvckV4cHJlc3Npb24oY2FzZVNlbnNpdGl2ZSwgZGlhY3JpdGljU2Vuc2l0aXZlLCBsb2NhbGUpIHtcbiAgICB0aGlzLnR5cGUgPSBDb2xsYXRvclR5cGU7XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5jYXNlU2Vuc2l0aXZlID0gY2FzZVNlbnNpdGl2ZTtcbiAgICB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSA9IGRpYWNyaXRpY1NlbnNpdGl2ZTtcbn07XG5Db2xsYXRvckV4cHJlc3Npb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBvbmUgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gYXJnc1sxXTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0NvbGxhdG9yIG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIHZhciBjYXNlU2Vuc2l0aXZlID0gY29udGV4dC5wYXJzZShvcHRpb25zWydjYXNlLXNlbnNpdGl2ZSddID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnNbJ2Nhc2Utc2Vuc2l0aXZlJ10sIDEsIEJvb2xlYW5UeXBlKTtcbiAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBkaWFjcml0aWNTZW5zaXRpdmUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2RpYWNyaXRpYy1zZW5zaXRpdmUnXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zWydkaWFjcml0aWMtc2Vuc2l0aXZlJ10sIDEsIEJvb2xlYW5UeXBlKTtcbiAgICBpZiAoIWRpYWNyaXRpY1NlbnNpdGl2ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxvY2FsZSA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnNbJ2xvY2FsZSddKSB7XG4gICAgICAgIGxvY2FsZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbG9jYWxlJ10sIDEsIFN0cmluZ1R5cGUpO1xuICAgICAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb2xsYXRvckV4cHJlc3Npb24oY2FzZVNlbnNpdGl2ZSwgZGlhY3JpdGljU2Vuc2l0aXZlLCBsb2NhbGUpO1xufTtcbkNvbGxhdG9yRXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICByZXR1cm4gbmV3IENvbGxhdG9yKHRoaXMuY2FzZVNlbnNpdGl2ZS5ldmFsdWF0ZShjdHgpLCB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5ldmFsdWF0ZShjdHgpLCB0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlLmV2YWx1YXRlKGN0eCkgOiBudWxsKTtcbn07XG5Db2xsYXRvckV4cHJlc3Npb24ucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZuKHRoaXMuY2FzZVNlbnNpdGl2ZSk7XG4gICAgZm4odGhpcy5kaWFjcml0aWNTZW5zaXRpdmUpO1xuICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICBmbih0aGlzLmxvY2FsZSk7XG4gICAgfVxufTtcbkNvbGxhdG9yRXhwcmVzc2lvbi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbkNvbGxhdG9yRXhwcmVzc2lvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgb3B0aW9uc1snY2FzZS1zZW5zaXRpdmUnXSA9IHRoaXMuY2FzZVNlbnNpdGl2ZS5zZXJpYWxpemUoKTtcbiAgICBvcHRpb25zWydkaWFjcml0aWMtc2Vuc2l0aXZlJ10gPSB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5zZXJpYWxpemUoKTtcbiAgICBpZiAodGhpcy5sb2NhbGUpIHtcbiAgICAgICAgb3B0aW9uc1snbG9jYWxlJ10gPSB0aGlzLmxvY2FsZS5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2NvbGxhdG9yJyxcbiAgICAgICAgb3B0aW9uc1xuICAgIF07XG59O1xuXG52YXIgRVhURU5UID0gODE5MjtcbmZ1bmN0aW9uIHVwZGF0ZUJCb3goYmJveCwgY29vcmQpIHtcbiAgICBiYm94WzBdID0gTWF0aC5taW4oYmJveFswXSwgY29vcmRbMF0pO1xuICAgIGJib3hbMV0gPSBNYXRoLm1pbihiYm94WzFdLCBjb29yZFsxXSk7XG4gICAgYmJveFsyXSA9IE1hdGgubWF4KGJib3hbMl0sIGNvb3JkWzBdKTtcbiAgICBiYm94WzNdID0gTWF0aC5tYXgoYmJveFszXSwgY29vcmRbMV0pO1xufVxuZnVuY3Rpb24gbWVyY2F0b3JYZnJvbUxuZyhsbmcpIHtcbiAgICByZXR1cm4gKDE4MCArIGxuZykgLyAzNjA7XG59XG5mdW5jdGlvbiBtZXJjYXRvcllmcm9tTGF0KGxhdCkge1xuICAgIHJldHVybiAoMTgwIC0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgbGF0ICogTWF0aC5QSSAvIDM2MCkpKSAvIDM2MDtcbn1cbmZ1bmN0aW9uIGJveFdpdGhpbkJveChiYm94MSwgYmJveDIpIHtcbiAgICBpZiAoYmJveDFbMF0gPD0gYmJveDJbMF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYmJveDFbMl0gPj0gYmJveDJbMl0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYmJveDFbMV0gPD0gYmJveDJbMV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYmJveDFbM10gPj0gYmJveDJbM10pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldFRpbGVDb29yZGluYXRlcyhwLCBjYW5vbmljYWwpIHtcbiAgICB2YXIgeCA9IG1lcmNhdG9yWGZyb21MbmcocFswXSk7XG4gICAgdmFyIHkgPSBtZXJjYXRvcllmcm9tTGF0KHBbMV0pO1xuICAgIHZhciB0aWxlc0F0Wm9vbSA9IE1hdGgucG93KDIsIGNhbm9uaWNhbC56KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBNYXRoLnJvdW5kKHggKiB0aWxlc0F0Wm9vbSAqIEVYVEVOVCksXG4gICAgICAgIE1hdGgucm91bmQoeSAqIHRpbGVzQXRab29tICogRVhURU5UKVxuICAgIF07XG59XG5mdW5jdGlvbiBvbkJvdW5kYXJ5KHAsIHAxLCBwMikge1xuICAgIHZhciB4MSA9IHBbMF0gLSBwMVswXTtcbiAgICB2YXIgeTEgPSBwWzFdIC0gcDFbMV07XG4gICAgdmFyIHgyID0gcFswXSAtIHAyWzBdO1xuICAgIHZhciB5MiA9IHBbMV0gLSBwMlsxXTtcbiAgICByZXR1cm4geDEgKiB5MiAtIHgyICogeTEgPT09IDAgJiYgeDEgKiB4MiA8PSAwICYmIHkxICogeTIgPD0gMDtcbn1cbmZ1bmN0aW9uIHJheUludGVyc2VjdChwLCBwMSwgcDIpIHtcbiAgICByZXR1cm4gcDFbMV0gPiBwWzFdICE9PSBwMlsxXSA+IHBbMV0gJiYgcFswXSA8IChwMlswXSAtIHAxWzBdKSAqIChwWzFdIC0gcDFbMV0pIC8gKHAyWzFdIC0gcDFbMV0pICsgcDFbMF07XG59XG5mdW5jdGlvbiBwb2ludFdpdGhpblBvbHlnb24ocG9pbnQsIHJpbmdzKSB7XG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IHJpbmcubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuICAgICAgICAgICAgaWYgKG9uQm91bmRhcnkocG9pbnQsIHJpbmdbal0sIHJpbmdbaiArIDFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyYXlJbnRlcnNlY3QocG9pbnQsIHJpbmdbal0sIHJpbmdbaiArIDFdKSkge1xuICAgICAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc2lkZTtcbn1cbmZ1bmN0aW9uIHBvaW50V2l0aGluUG9seWdvbnMocG9pbnQsIHBvbHlnb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocG9pbnRXaXRoaW5Qb2x5Z29uKHBvaW50LCBwb2x5Z29uc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBlcnAodjEsIHYyKSB7XG4gICAgcmV0dXJuIHYxWzBdICogdjJbMV0gLSB2MVsxXSAqIHYyWzBdO1xufVxuZnVuY3Rpb24gdHdvU2lkZWQocDEsIHAyLCBxMSwgcTIpIHtcbiAgICB2YXIgeDEgPSBwMVswXSAtIHExWzBdO1xuICAgIHZhciB5MSA9IHAxWzFdIC0gcTFbMV07XG4gICAgdmFyIHgyID0gcDJbMF0gLSBxMVswXTtcbiAgICB2YXIgeTIgPSBwMlsxXSAtIHExWzFdO1xuICAgIHZhciB4MyA9IHEyWzBdIC0gcTFbMF07XG4gICAgdmFyIHkzID0gcTJbMV0gLSBxMVsxXTtcbiAgICB2YXIgZGV0MSA9IHgxICogeTMgLSB4MyAqIHkxO1xuICAgIHZhciBkZXQyID0geDIgKiB5MyAtIHgzICogeTI7XG4gICAgaWYgKGRldDEgPiAwICYmIGRldDIgPCAwIHx8IGRldDEgPCAwICYmIGRldDIgPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0TGluZShhLCBiLCBjLCBkKSB7XG4gICAgdmFyIHZlY3RvclAgPSBbXG4gICAgICAgIGJbMF0gLSBhWzBdLFxuICAgICAgICBiWzFdIC0gYVsxXVxuICAgIF07XG4gICAgdmFyIHZlY3RvclEgPSBbXG4gICAgICAgIGRbMF0gLSBjWzBdLFxuICAgICAgICBkWzFdIC0gY1sxXVxuICAgIF07XG4gICAgaWYgKHBlcnAodmVjdG9yUSwgdmVjdG9yUCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHdvU2lkZWQoYSwgYiwgYywgZCkgJiYgdHdvU2lkZWQoYywgZCwgYSwgYikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RQb2x5Z29uKHAxLCBwMiwgcG9seWdvbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcG9seWdvbjsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJpbmcgPSBsaXN0W2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoIC0gMTsgKytqKSB7XG4gICAgICAgICAgICBpZiAobGluZUludGVyc2VjdExpbmUocDEsIHAyLCByaW5nW2pdLCByaW5nW2ogKyAxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBsaW5lU3RyaW5nV2l0aGluUG9seWdvbihsaW5lLCBwb2x5Z29uKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghcG9pbnRXaXRoaW5Qb2x5Z29uKGxpbmVbaV0sIHBvbHlnb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGluZS5sZW5ndGggLSAxOyArK2kkMSkge1xuICAgICAgICBpZiAobGluZUludGVyc2VjdFBvbHlnb24obGluZVtpJDFdLCBsaW5lW2kkMSArIDFdLCBwb2x5Z29uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbGluZVN0cmluZ1dpdGhpblBvbHlnb25zKGxpbmUsIHBvbHlnb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGluZVN0cmluZ1dpdGhpblBvbHlnb24obGluZSwgcG9seWdvbnNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRUaWxlUG9seWdvbihjb29yZGluYXRlcywgYmJveCwgY2Fub25pY2FsKSB7XG4gICAgdmFyIHBvbHlnb24gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmRpbmF0ZXNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjb29yZCA9IGdldFRpbGVDb29yZGluYXRlcyhjb29yZGluYXRlc1tpXVtqXSwgY2Fub25pY2FsKTtcbiAgICAgICAgICAgIHVwZGF0ZUJCb3goYmJveCwgY29vcmQpO1xuICAgICAgICAgICAgcmluZy5wdXNoKGNvb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gICAgfVxuICAgIHJldHVybiBwb2x5Z29uO1xufVxuZnVuY3Rpb24gZ2V0VGlsZVBvbHlnb25zKGNvb3JkaW5hdGVzLCBiYm94LCBjYW5vbmljYWwpIHtcbiAgICB2YXIgcG9seWdvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gZ2V0VGlsZVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIGJib3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gICAgfVxuICAgIHJldHVybiBwb2x5Z29ucztcbn1cbmZ1bmN0aW9uIHVwZGF0ZVBvaW50KHAsIGJib3gsIHBvbHlCQm94LCB3b3JsZFNpemUpIHtcbiAgICBpZiAocFswXSA8IHBvbHlCQm94WzBdIHx8IHBbMF0gPiBwb2x5QkJveFsyXSkge1xuICAgICAgICB2YXIgaGFsZldvcmxkU2l6ZSA9IHdvcmxkU2l6ZSAqIDAuNTtcbiAgICAgICAgdmFyIHNoaWZ0ID0gcFswXSAtIHBvbHlCQm94WzBdID4gaGFsZldvcmxkU2l6ZSA/IC13b3JsZFNpemUgOiBwb2x5QkJveFswXSAtIHBbMF0gPiBoYWxmV29ybGRTaXplID8gd29ybGRTaXplIDogMDtcbiAgICAgICAgaWYgKHNoaWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBzaGlmdCA9IHBbMF0gLSBwb2x5QkJveFsyXSA+IGhhbGZXb3JsZFNpemUgPyAtd29ybGRTaXplIDogcG9seUJCb3hbMl0gLSBwWzBdID4gaGFsZldvcmxkU2l6ZSA/IHdvcmxkU2l6ZSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgcFswXSArPSBzaGlmdDtcbiAgICB9XG4gICAgdXBkYXRlQkJveChiYm94LCBwKTtcbn1cbmZ1bmN0aW9uIHJlc2V0QkJveChiYm94KSB7XG4gICAgYmJveFswXSA9IGJib3hbMV0gPSBJbmZpbml0eTtcbiAgICBiYm94WzJdID0gYmJveFszXSA9IC1JbmZpbml0eTtcbn1cbmZ1bmN0aW9uIGdldFRpbGVQb2ludHMoZ2VvbWV0cnksIHBvaW50QkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCkge1xuICAgIHZhciB3b3JsZFNpemUgPSBNYXRoLnBvdygyLCBjYW5vbmljYWwueikgKiBFWFRFTlQ7XG4gICAgdmFyIHNoaWZ0cyA9IFtcbiAgICAgICAgY2Fub25pY2FsLnggKiBFWFRFTlQsXG4gICAgICAgIGNhbm9uaWNhbC55ICogRVhURU5UXG4gICAgXTtcbiAgICB2YXIgdGlsZVBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGdlb21ldHJ5OyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gbGlzdCQxW2kkMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcG9pbnRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgICAgIHBvaW50LnggKyBzaGlmdHNbMF0sXG4gICAgICAgICAgICAgICAgcG9pbnQueSArIHNoaWZ0c1sxXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHVwZGF0ZVBvaW50KHAsIHBvaW50QkJveCwgcG9seUJCb3gsIHdvcmxkU2l6ZSk7XG4gICAgICAgICAgICB0aWxlUG9pbnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbGVQb2ludHM7XG59XG5mdW5jdGlvbiBnZXRUaWxlTGluZXMoZ2VvbWV0cnksIGxpbmVCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKSB7XG4gICAgdmFyIHdvcmxkU2l6ZSA9IE1hdGgucG93KDIsIGNhbm9uaWNhbC56KSAqIEVYVEVOVDtcbiAgICB2YXIgc2hpZnRzID0gW1xuICAgICAgICBjYW5vbmljYWwueCAqIEVYVEVOVCxcbiAgICAgICAgY2Fub25pY2FsLnkgKiBFWFRFTlRcbiAgICBdO1xuICAgIHZhciB0aWxlTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBnZW9tZXRyeTsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaXN0JDFbaSQxXTtcbiAgICAgICAgdmFyIHRpbGVMaW5lID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbGluZTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGxpc3RbaV07XG4gICAgICAgICAgICB2YXIgcCA9IFtcbiAgICAgICAgICAgICAgICBwb2ludC54ICsgc2hpZnRzWzBdLFxuICAgICAgICAgICAgICAgIHBvaW50LnkgKyBzaGlmdHNbMV1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB1cGRhdGVCQm94KGxpbmVCQm94LCBwKTtcbiAgICAgICAgICAgIHRpbGVMaW5lLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgICAgdGlsZUxpbmVzLnB1c2godGlsZUxpbmUpO1xuICAgIH1cbiAgICBpZiAobGluZUJCb3hbMl0gLSBsaW5lQkJveFswXSA8PSB3b3JsZFNpemUgLyAyKSB7XG4gICAgICAgIHJlc2V0QkJveChsaW5lQkJveCk7XG4gICAgICAgIGZvciAodmFyIGkkMyA9IDAsIGxpc3QkMyA9IHRpbGVMaW5lczsgaSQzIDwgbGlzdCQzLmxlbmd0aDsgaSQzICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsaW5lJDEgPSBsaXN0JDNbaSQzXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDAsIGxpc3QkMiA9IGxpbmUkMTsgaSQyIDwgbGlzdCQyLmxlbmd0aDsgaSQyICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCQxID0gbGlzdCQyW2kkMl07XG4gICAgICAgICAgICAgICAgdXBkYXRlUG9pbnQocCQxLCBsaW5lQkJveCwgcG9seUJCb3gsIHdvcmxkU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbGVMaW5lcztcbn1cbmZ1bmN0aW9uIHBvaW50c1dpdGhpblBvbHlnb25zKGN0eCwgcG9seWdvbkdlb21ldHJ5KSB7XG4gICAgdmFyIHBvaW50QkJveCA9IFtcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICAtSW5maW5pdHksXG4gICAgICAgIC1JbmZpbml0eVxuICAgIF07XG4gICAgdmFyIHBvbHlCQm94ID0gW1xuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIC1JbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5XG4gICAgXTtcbiAgICB2YXIgY2Fub25pY2FsID0gY3R4LmNhbm9uaWNhbElEKCk7XG4gICAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgdmFyIHRpbGVQb2x5Z29uID0gZ2V0VGlsZVBvbHlnb24ocG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICAgICAgdmFyIHRpbGVQb2ludHMgPSBnZXRUaWxlUG9pbnRzKGN0eC5nZW9tZXRyeSgpLCBwb2ludEJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICBpZiAoIWJveFdpdGhpbkJveChwb2ludEJCb3gsIHBvbHlCQm94KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGlsZVBvaW50czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoIXBvaW50V2l0aGluUG9seWdvbihwb2ludCwgdGlsZVBvbHlnb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwb2x5Z29uR2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgdmFyIHRpbGVQb2x5Z29ucyA9IGdldFRpbGVQb2x5Z29ucyhwb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICB2YXIgdGlsZVBvaW50cyQxID0gZ2V0VGlsZVBvaW50cyhjdHguZ2VvbWV0cnkoKSwgcG9pbnRCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICAgICAgaWYgKCFib3hXaXRoaW5Cb3gocG9pbnRCQm94LCBwb2x5QkJveCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSB0aWxlUG9pbnRzJDE7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQkMSA9IGxpc3QkMVtpJDFdO1xuICAgICAgICAgICAgaWYgKCFwb2ludFdpdGhpblBvbHlnb25zKHBvaW50JDEsIHRpbGVQb2x5Z29ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaW5lc1dpdGhpblBvbHlnb25zKGN0eCwgcG9seWdvbkdlb21ldHJ5KSB7XG4gICAgdmFyIGxpbmVCQm94ID0gW1xuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIC1JbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5XG4gICAgXTtcbiAgICB2YXIgcG9seUJCb3ggPSBbXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5LFxuICAgICAgICAtSW5maW5pdHlcbiAgICBdO1xuICAgIHZhciBjYW5vbmljYWwgPSBjdHguY2Fub25pY2FsSUQoKTtcbiAgICBpZiAocG9seWdvbkdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICB2YXIgdGlsZVBvbHlnb24gPSBnZXRUaWxlUG9seWdvbihwb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICB2YXIgdGlsZUxpbmVzID0gZ2V0VGlsZUxpbmVzKGN0eC5nZW9tZXRyeSgpLCBsaW5lQkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIGlmICghYm94V2l0aGluQm94KGxpbmVCQm94LCBwb2x5QkJveCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHRpbGVMaW5lczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmICghbGluZVN0cmluZ1dpdGhpblBvbHlnb24obGluZSwgdGlsZVBvbHlnb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwb2x5Z29uR2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgdmFyIHRpbGVQb2x5Z29ucyA9IGdldFRpbGVQb2x5Z29ucyhwb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICB2YXIgdGlsZUxpbmVzJDEgPSBnZXRUaWxlTGluZXMoY3R4Lmdlb21ldHJ5KCksIGxpbmVCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICAgICAgaWYgKCFib3hXaXRoaW5Cb3gobGluZUJCb3gsIHBvbHlCQm94KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHRpbGVMaW5lcyQxOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGxpbmUkMSA9IGxpc3QkMVtpJDFdO1xuICAgICAgICAgICAgaWYgKCFsaW5lU3RyaW5nV2l0aGluUG9seWdvbnMobGluZSQxLCB0aWxlUG9seWdvbnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxudmFyIFdpdGhpbiA9IGZ1bmN0aW9uIFdpdGhpbihnZW9qc29uLCBnZW9tZXRyaWVzKSB7XG4gICAgdGhpcy50eXBlID0gQm9vbGVhblR5cGU7XG4gICAgdGhpcy5nZW9qc29uID0gZ2VvanNvbjtcbiAgICB0aGlzLmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xufTtcbldpdGhpbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1xcJ3dpdGhpblxcJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBidXQgZm91bmQgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAoaXNWYWx1ZShhcmdzWzFdKSkge1xuICAgICAgICB2YXIgZ2VvanNvbiA9IGFyZ3NbMV07XG4gICAgICAgIGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZ2VvanNvbi5mZWF0dXJlc1tpXS5nZW9tZXRyeS50eXBlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnUG9seWdvbicgfHwgdHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXaXRoaW4oZ2VvanNvbiwgZ2VvanNvbi5mZWF0dXJlc1tpXS5nZW9tZXRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSQxID0gZ2VvanNvbi5nZW9tZXRyeS50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUkMSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUkMSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdpdGhpbihnZW9qc29uLCBnZW9qc29uLmdlb21ldHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChnZW9qc29uLnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9qc29uLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdpdGhpbihnZW9qc29uLCBnZW9qc29uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGV4dC5lcnJvcignXFwnd2l0aGluXFwnIGV4cHJlc3Npb24gcmVxdWlyZXMgdmFsaWQgZ2VvanNvbiBvYmplY3QgdGhhdCBjb250YWlucyBwb2x5Z29uIGdlb21ldHJ5IHR5cGUuJyk7XG59O1xuV2l0aGluLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIGlmIChjdHguZ2VvbWV0cnkoKSAhPSBudWxsICYmIGN0eC5jYW5vbmljYWxJRCgpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gJ1BvaW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50c1dpdGhpblBvbHlnb25zKGN0eCwgdGhpcy5nZW9tZXRyaWVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdHguZ2VvbWV0cnlUeXBlKCkgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVzV2l0aGluUG9seWdvbnMoY3R4LCB0aGlzLmdlb21ldHJpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5XaXRoaW4ucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZCgpIHtcbn07XG5XaXRoaW4ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcbldpdGhpbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICd3aXRoaW4nLFxuICAgICAgICB0aGlzLmdlb2pzb25cbiAgICBdO1xufTtcblxuZnVuY3Rpb24gaXNGZWF0dXJlQ29uc3RhbnQoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uKSB7XG4gICAgICAgIGlmIChlLm5hbWUgPT09ICdnZXQnICYmIGUuYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdmZWF0dXJlLXN0YXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ2hhcycgJiYgZS5hcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ3Byb3BlcnRpZXMnIHx8IGUubmFtZSA9PT0gJ2dlb21ldHJ5LXR5cGUnIHx8IGUubmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKC9eZmlsdGVyLS8udGVzdChlLm5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBXaXRoaW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBlLmVhY2hDaGlsZChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgIWlzRmVhdHVyZUNvbnN0YW50KGFyZykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzU3RhdGVDb25zdGFudChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ2ZlYXR1cmUtc3RhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgZS5lYWNoQ2hpbGQoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICBpZiAocmVzdWx0ICYmICFpc1N0YXRlQ29uc3RhbnQoYXJnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGUsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbiAmJiBwcm9wZXJ0aWVzLmluZGV4T2YoZS5uYW1lKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgZS5lYWNoQ2hpbGQoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICBpZiAocmVzdWx0ICYmICFpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoYXJnLCBwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgVmFyID0gZnVuY3Rpb24gVmFyKG5hbWUsIGJvdW5kRXhwcmVzc2lvbikge1xuICAgIHRoaXMudHlwZSA9IGJvdW5kRXhwcmVzc2lvbi50eXBlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5ib3VuZEV4cHJlc3Npb24gPSBib3VuZEV4cHJlc3Npb247XG59O1xuVmFyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMiB8fCB0eXBlb2YgYXJnc1sxXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1xcJ3ZhclxcJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIHN0cmluZyBsaXRlcmFsIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IGFyZ3NbMV07XG4gICAgaWYgKCFjb250ZXh0LnNjb3BlLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignVW5rbm93biB2YXJpYWJsZSBcIicgKyBuYW1lICsgJ1wiLiBNYWtlIHN1cmUgXCInICsgbmFtZSArICdcIiBoYXMgYmVlbiBib3VuZCBpbiBhbiBlbmNsb3NpbmcgXCJsZXRcIiBleHByZXNzaW9uIGJlZm9yZSB1c2luZyBpdC4nLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWYXIobmFtZSwgY29udGV4dC5zY29wZS5nZXQobmFtZSkpO1xufTtcblZhci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZEV4cHJlc3Npb24uZXZhbHVhdGUoY3R4KTtcbn07XG5WYXIucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZCgpIHtcbn07XG5WYXIucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5WYXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAndmFyJyxcbiAgICAgICAgdGhpcy5uYW1lXG4gICAgXTtcbn07XG5cbnZhciBQYXJzaW5nQ29udGV4dCA9IGZ1bmN0aW9uIFBhcnNpbmdDb250ZXh0KHJlZ2lzdHJ5LCBwYXRoLCBleHBlY3RlZFR5cGUsIHNjb3BlLCBlcnJvcnMpIHtcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKVxuICAgICAgICBwYXRoID0gW107XG4gICAgaWYgKHNjb3BlID09PSB2b2lkIDApXG4gICAgICAgIHNjb3BlID0gbmV3IFNjb3BlKCk7XG4gICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKVxuICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmtleSA9IHBhdGgubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIHJldHVybiAnWycgKyBwYXJ0ICsgJ10nO1xuICAgIH0pLmpvaW4oJycpO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLmV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcbn07XG5QYXJzaW5nQ29udGV4dC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShleHByLCBpbmRleCwgZXhwZWN0ZWRUeXBlLCBiaW5kaW5ncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uY2F0KGluZGV4LCBleHBlY3RlZFR5cGUsIGJpbmRpbmdzKS5fcGFyc2UoZXhwciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wYXJzZShleHByLCBvcHRpb25zKTtcbn07XG5QYXJzaW5nQ29udGV4dC5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24gX3BhcnNlKGV4cHIsIG9wdGlvbnMpIHtcbiAgICBpZiAoZXhwciA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGV4cHIgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgZXhwciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZXhwciA9IFtcbiAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgIGV4cHJcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW5ub3RhdGUocGFyc2VkLCB0eXBlLCB0eXBlQW5ub3RhdGlvbikge1xuICAgICAgICBpZiAodHlwZUFubm90YXRpb24gPT09ICdhc3NlcnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0eXBlLCBbcGFyc2VkXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZUFubm90YXRpb24gPT09ICdjb2VyY2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvZXJjaW9uKHR5cGUsIFtwYXJzZWRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwcikpIHtcbiAgICAgICAgaWYgKGV4cHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignRXhwZWN0ZWQgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFtdXS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3AgPSBleHByWzBdO1xuICAgICAgICBpZiAodHlwZW9mIG9wICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5lcnJvcignRXhwcmVzc2lvbiBuYW1lIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCBmb3VuZCAnICsgdHlwZW9mIG9wICsgJyBpbnN0ZWFkLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgWy4uLl1dLicsIDApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEV4cHIgPSB0aGlzLnJlZ2lzdHJ5W29wXTtcbiAgICAgICAgaWYgKEV4cHIpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBFeHByLnBhcnNlKGV4cHIsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmV4cGVjdGVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZCA9IHRoaXMuZXhwZWN0ZWRUeXBlO1xuICAgICAgICAgICAgICAgIHZhciBhY3R1YWwgPSBwYXJzZWQudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoKGV4cGVjdGVkLmtpbmQgPT09ICdzdHJpbmcnIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdudW1iZXInIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdib29sZWFuJyB8fCBleHBlY3RlZC5raW5kID09PSAnb2JqZWN0JyB8fCBleHBlY3RlZC5raW5kID09PSAnYXJyYXknKSAmJiBhY3R1YWwua2luZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBhbm5vdGF0ZShwYXJzZWQsIGV4cGVjdGVkLCBvcHRpb25zLnR5cGVBbm5vdGF0aW9uIHx8ICdhc3NlcnQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChleHBlY3RlZC5raW5kID09PSAnY29sb3InIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdmb3JtYXR0ZWQnIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdyZXNvbHZlZEltYWdlJykgJiYgKGFjdHVhbC5raW5kID09PSAndmFsdWUnIHx8IGFjdHVhbC5raW5kID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gYW5ub3RhdGUocGFyc2VkLCBleHBlY3RlZCwgb3B0aW9ucy50eXBlQW5ub3RhdGlvbiB8fCAnY29lcmNlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrU3VidHlwZShleHBlY3RlZCwgYWN0dWFsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShwYXJzZWQgaW5zdGFuY2VvZiBMaXRlcmFsKSAmJiBwYXJzZWQudHlwZS5raW5kICE9PSAncmVzb2x2ZWRJbWFnZScgJiYgaXNDb25zdGFudChwYXJzZWQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVjID0gbmV3IEV2YWx1YXRpb25Db250ZXh0KCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gbmV3IExpdGVyYWwocGFyc2VkLnR5cGUsIHBhcnNlZC5ldmFsdWF0ZShlYykpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdVbmtub3duIGV4cHJlc3Npb24gXCInICsgb3AgKyAnXCIuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uJywgMCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1xcJ3VuZGVmaW5lZFxcJyB2YWx1ZSBpbnZhbGlkLiBVc2UgbnVsbCBpbnN0ZWFkLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cHIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdCYXJlIG9iamVjdHMgaW52YWxpZC4gVXNlIFtcImxpdGVyYWxcIiwgey4uLn1dIGluc3RlYWQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0V4cGVjdGVkIGFuIGFycmF5LCBidXQgZm91bmQgJyArIHR5cGVvZiBleHByICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbn07XG5QYXJzaW5nQ29udGV4dC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KGluZGV4LCBleHBlY3RlZFR5cGUsIGJpbmRpbmdzKSB7XG4gICAgdmFyIHBhdGggPSB0eXBlb2YgaW5kZXggPT09ICdudW1iZXInID8gdGhpcy5wYXRoLmNvbmNhdChpbmRleCkgOiB0aGlzLnBhdGg7XG4gICAgdmFyIHNjb3BlID0gYmluZGluZ3MgPyB0aGlzLnNjb3BlLmNvbmNhdChiaW5kaW5ncykgOiB0aGlzLnNjb3BlO1xuICAgIHJldHVybiBuZXcgUGFyc2luZ0NvbnRleHQodGhpcy5yZWdpc3RyeSwgcGF0aCwgZXhwZWN0ZWRUeXBlIHx8IG51bGwsIHNjb3BlLCB0aGlzLmVycm9ycyk7XG59O1xuUGFyc2luZ0NvbnRleHQucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZXJyb3IkMSkge1xuICAgIHZhciBrZXlzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsZW4tLSA+IDApXG4gICAgICAgIGtleXNbbGVuXSA9IGFyZ3VtZW50c1tsZW4gKyAxXTtcbiAgICB2YXIga2V5ID0gJycgKyB0aGlzLmtleSArIGtleXMubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiAnWycgKyBrICsgJ10nO1xuICAgIH0pLmpvaW4oJycpO1xuICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNpbmdFcnJvcihrZXksIGVycm9yJDEpKTtcbn07XG5QYXJzaW5nQ29udGV4dC5wcm90b3R5cGUuY2hlY2tTdWJ0eXBlID0gZnVuY3Rpb24gY2hlY2tTdWJ0eXBlJDEoZXhwZWN0ZWQsIHQpIHtcbiAgICB2YXIgZXJyb3IgPSBjaGVja1N1YnR5cGUoZXhwZWN0ZWQsIHQpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufTtcbmZ1bmN0aW9uIGlzQ29uc3RhbnQoZXhwcmVzc2lvbikge1xuICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgVmFyKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnN0YW50KGV4cHJlc3Npb24uYm91bmRFeHByZXNzaW9uKTtcbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24gJiYgZXhwcmVzc2lvbi5uYW1lID09PSAnZXJyb3InKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2xsYXRvckV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFdpdGhpbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpc1R5cGVBbm5vdGF0aW9uID0gZXhwcmVzc2lvbiBpbnN0YW5jZW9mIENvZXJjaW9uIHx8IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBBc3NlcnRpb247XG4gICAgdmFyIGNoaWxkcmVuQ29uc3RhbnQgPSB0cnVlO1xuICAgIGV4cHJlc3Npb24uZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoaXNUeXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgY2hpbGRyZW5Db25zdGFudCA9IGNoaWxkcmVuQ29uc3RhbnQgJiYgaXNDb25zdGFudChjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZHJlbkNvbnN0YW50ID0gY2hpbGRyZW5Db25zdGFudCAmJiBjaGlsZCBpbnN0YW5jZW9mIExpdGVyYWw7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNoaWxkcmVuQ29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNGZWF0dXJlQ29uc3RhbnQoZXhwcmVzc2lvbikgJiYgaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGV4cHJlc3Npb24sIFtcbiAgICAgICAgJ3pvb20nLFxuICAgICAgICAnaGVhdG1hcC1kZW5zaXR5JyxcbiAgICAgICAgJ2xpbmUtcHJvZ3Jlc3MnLFxuICAgICAgICAnYWNjdW11bGF0ZWQnLFxuICAgICAgICAnaXMtc3VwcG9ydGVkLXNjcmlwdCdcbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhzdG9wcywgaW5wdXQpIHtcbiAgICB2YXIgbGFzdEluZGV4ID0gc3RvcHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbG93ZXJJbmRleCA9IDA7XG4gICAgdmFyIHVwcGVySW5kZXggPSBsYXN0SW5kZXg7XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlO1xuICAgIHdoaWxlIChsb3dlckluZGV4IDw9IHVwcGVySW5kZXgpIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gTWF0aC5mbG9vcigobG93ZXJJbmRleCArIHVwcGVySW5kZXgpIC8gMik7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IHN0b3BzW2N1cnJlbnRJbmRleF07XG4gICAgICAgIG5leHRWYWx1ZSA9IHN0b3BzW2N1cnJlbnRJbmRleCArIDFdO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlIDw9IGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSBsYXN0SW5kZXggfHwgaW5wdXQgPCBuZXh0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG93ZXJJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gaW5wdXQpIHtcbiAgICAgICAgICAgIHVwcGVySW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignSW5wdXQgaXMgbm90IGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG52YXIgU3RlcCA9IGZ1bmN0aW9uIFN0ZXAodHlwZSwgaW5wdXQsIHN0b3BzKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0b3BzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmVmID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIGxhYmVsID0gcmVmWzBdO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJlZlsxXTtcbiAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKGV4cHJlc3Npb24pO1xuICAgIH1cbn07XG5TdGVwLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCAtIDEgPCA0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJy4nKTtcbiAgICB9XG4gICAgaWYgKChhcmdzLmxlbmd0aCAtIDEpICUgMiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLicpO1xuICAgIH1cbiAgICB2YXIgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIE51bWJlclR5cGUpO1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBzdG9wcyA9IFtdO1xuICAgIHZhciBvdXRwdXRUeXBlID0gbnVsbDtcbiAgICBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICBvdXRwdXRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgbGFiZWwgPSBpID09PSAxID8gLUluZmluaXR5IDogYXJnc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1tpICsgMV07XG4gICAgICAgIHZhciBsYWJlbEtleSA9IGk7XG4gICAgICAgIHZhciB2YWx1ZUtleSA9IGkgKyAxO1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJzdGVwXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgbGFiZWxLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wcy5sZW5ndGggJiYgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV1bMF0gPj0gbGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwic3RlcFwiIGV4cHJlc3Npb25zIG11c3QgYmUgYXJyYW5nZWQgd2l0aCBpbnB1dCB2YWx1ZXMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLicsIGxhYmVsS2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyc2VkID0gY29udGV4dC5wYXJzZSh2YWx1ZSwgdmFsdWVLZXksIG91dHB1dFR5cGUpO1xuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcGFyc2VkLnR5cGU7XG4gICAgICAgIHN0b3BzLnB1c2goW1xuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBwYXJzZWRcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RlcChvdXRwdXRUeXBlLCBpbnB1dCwgc3RvcHMpO1xufTtcblN0ZXAucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgdmFyIGxhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgIHZhciBvdXRwdXRzID0gdGhpcy5vdXRwdXRzO1xuICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAodmFsdWUgPD0gbGFiZWxzWzBdKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICAgIHZhciBzdG9wQ291bnQgPSBsYWJlbHMubGVuZ3RoO1xuICAgIGlmICh2YWx1ZSA+PSBsYWJlbHNbc3RvcENvdW50IC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbc3RvcENvdW50IC0gMV0uZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhsYWJlbHMsIHZhbHVlKTtcbiAgICByZXR1cm4gb3V0cHV0c1tpbmRleF0uZXZhbHVhdGUoY3R4KTtcbn07XG5TdGVwLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLmlucHV0KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHRoaXMub3V0cHV0czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBsaXN0W2ldO1xuICAgICAgICBmbihleHByZXNzaW9uKTtcbiAgICB9XG59O1xuU3RlcC5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHJldHVybiBvdXQub3V0cHV0RGVmaW5lZCgpO1xuICAgIH0pO1xufTtcblN0ZXAucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgJ3N0ZXAnLFxuICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXG4gICAgXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKHRoaXMubGFiZWxzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5vdXRwdXRzW2ldLnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSAyMDA4IEFwcGxlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogYXJlIG1ldDpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEFQUExFIElOQy4gYGBBUyBJUycnIEFORCBBTllcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBBUFBMRSBJTkMuIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWVxuICogT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogUG9ydGVkIGZyb20gV2Via2l0XG4gKiBodHRwOi8vc3ZuLndlYmtpdC5vcmcvcmVwb3NpdG9yeS93ZWJraXQvdHJ1bmsvU291cmNlL1dlYkNvcmUvcGxhdGZvcm0vZ3JhcGhpY3MvVW5pdEJlemllci5oXG4gKi9cblxudmFyIHVuaXRiZXppZXIgPSBVbml0QmV6aWVyO1xuXG5mdW5jdGlvbiBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9seW5vbWlhbCBjb2VmZmljaWVudHMsIGltcGxpY2l0IGZpcnN0IGFuZCBsYXN0IGNvbnRyb2wgcG9pbnRzIGFyZSAoMCwwKSBhbmQgKDEsMSkuXG4gICAgdGhpcy5jeCA9IDMuMCAqIHAxeDtcbiAgICB0aGlzLmJ4ID0gMy4wICogKHAyeCAtIHAxeCkgLSB0aGlzLmN4O1xuICAgIHRoaXMuYXggPSAxLjAgLSB0aGlzLmN4IC0gdGhpcy5ieDtcblxuICAgIHRoaXMuY3kgPSAzLjAgKiBwMXk7XG4gICAgdGhpcy5ieSA9IDMuMCAqIChwMnkgLSBwMXkpIC0gdGhpcy5jeTtcbiAgICB0aGlzLmF5ID0gMS4wIC0gdGhpcy5jeSAtIHRoaXMuYnk7XG5cbiAgICB0aGlzLnAxeCA9IHAxeDtcbiAgICB0aGlzLnAxeSA9IHAyeTtcbiAgICB0aGlzLnAyeCA9IHAyeDtcbiAgICB0aGlzLnAyeSA9IHAyeTtcbn1cblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVYID0gZnVuY3Rpb24odCkge1xuICAgIC8vIGBheCB0XjMgKyBieCB0XjIgKyBjeCB0JyBleHBhbmRlZCB1c2luZyBIb3JuZXIncyBydWxlLlxuICAgIHJldHVybiAoKHRoaXMuYXggKiB0ICsgdGhpcy5ieCkgKiB0ICsgdGhpcy5jeCkgKiB0O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVZID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAoKHRoaXMuYXkgKiB0ICsgdGhpcy5ieSkgKiB0ICsgdGhpcy5jeSkgKiB0O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gKDMuMCAqIHRoaXMuYXggKiB0ICsgMi4wICogdGhpcy5ieCkgKiB0ICsgdGhpcy5jeDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNvbHZlQ3VydmVYID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xuICAgIGlmICh0eXBlb2YgZXBzaWxvbiA9PT0gJ3VuZGVmaW5lZCcpIHsgZXBzaWxvbiA9IDFlLTY7IH1cblxuICAgIHZhciB0MCwgdDEsIHQyLCB4MiwgaTtcblxuICAgIC8vIEZpcnN0IHRyeSBhIGZldyBpdGVyYXRpb25zIG9mIE5ld3RvbidzIG1ldGhvZCAtLSBub3JtYWxseSB2ZXJ5IGZhc3QuXG4gICAgZm9yICh0MiA9IHgsIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0MikgLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIpIDwgZXBzaWxvbikgeyByZXR1cm4gdDI7IH1cblxuICAgICAgICB2YXIgZDIgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZDIpIDwgMWUtNikgeyBicmVhazsgfVxuXG4gICAgICAgIHQyID0gdDIgLSB4MiAvIGQyO1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byB0aGUgYmlzZWN0aW9uIG1ldGhvZCBmb3IgcmVsaWFiaWxpdHkuXG4gICAgdDAgPSAwLjA7XG4gICAgdDEgPSAxLjA7XG4gICAgdDIgPSB4O1xuXG4gICAgaWYgKHQyIDwgdDApIHsgcmV0dXJuIHQwOyB9XG4gICAgaWYgKHQyID4gdDEpIHsgcmV0dXJuIHQxOyB9XG5cbiAgICB3aGlsZSAodDAgPCB0MSkge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIgLSB4KSA8IGVwc2lsb24pIHsgcmV0dXJuIHQyOyB9XG5cbiAgICAgICAgaWYgKHggPiB4Mikge1xuICAgICAgICAgICAgdDAgPSB0MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgIH1cblxuICAgICAgICB0MiA9ICh0MSAtIHQwKSAqIDAuNSArIHQwO1xuICAgIH1cblxuICAgIC8vIEZhaWx1cmUuXG4gICAgcmV0dXJuIHQyO1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlQ3VydmVZKHRoaXMuc29sdmVDdXJ2ZVgoeCwgZXBzaWxvbikpO1xufTtcblxuZnVuY3Rpb24gbnVtYmVyKGEsIGIsIHQpIHtcbiAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbn1cbmZ1bmN0aW9uIGNvbG9yKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihudW1iZXIoZnJvbS5yLCB0by5yLCB0KSwgbnVtYmVyKGZyb20uZywgdG8uZywgdCksIG51bWJlcihmcm9tLmIsIHRvLmIsIHQpLCBudW1iZXIoZnJvbS5hLCB0by5hLCB0KSk7XG59XG5mdW5jdGlvbiBhcnJheSQxKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIGZyb20ubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIoZCwgdG9baV0sIHQpO1xuICAgIH0pO1xufVxuXG52YXIgaW50ZXJwb2xhdGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgbnVtYmVyOiBudW1iZXIsXG4gIGNvbG9yOiBjb2xvcixcbiAgYXJyYXk6IGFycmF5JDFcbn0pO1xuXG52YXIgWG4gPSAwLjk1MDQ3LCBZbiA9IDEsIFpuID0gMS4wODg4MywgdDAgPSA0IC8gMjksIHQxID0gNiAvIDI5LCB0MiA9IDMgKiB0MSAqIHQxLCB0MyA9IHQxICogdDEgKiB0MSwgZGVnMnJhZCA9IE1hdGguUEkgLyAxODAsIHJhZDJkZWcgPSAxODAgLyBNYXRoLlBJO1xuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gICAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gICAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG59XG5mdW5jdGlvbiB4eXoycmdiKHgpIHtcbiAgICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbn1cbmZ1bmN0aW9uIHJnYjJ4eXooeCkge1xuICAgIHggLz0gMjU1O1xuICAgIHJldHVybiB4IDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuZnVuY3Rpb24gcmdiVG9MYWIocmdiQ29sb3IpIHtcbiAgICB2YXIgYiA9IHJnYjJ4eXoocmdiQ29sb3IuciksIGEgPSByZ2IyeHl6KHJnYkNvbG9yLmcpLCBsID0gcmdiMnh5eihyZ2JDb2xvci5iKSwgeCA9IHh5ejJsYWIoKDAuNDEyNDU2NCAqIGIgKyAwLjM1NzU3NjEgKiBhICsgMC4xODA0Mzc1ICogbCkgLyBYbiksIHkgPSB4eXoybGFiKCgwLjIxMjY3MjkgKiBiICsgMC43MTUxNTIyICogYSArIDAuMDcyMTc1ICogbCkgLyBZbiksIHogPSB4eXoybGFiKCgwLjAxOTMzMzkgKiBiICsgMC4xMTkxOTIgKiBhICsgMC45NTAzMDQxICogbCkgLyBabik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbDogMTE2ICogeSAtIDE2LFxuICAgICAgICBhOiA1MDAgKiAoeCAtIHkpLFxuICAgICAgICBiOiAyMDAgKiAoeSAtIHopLFxuICAgICAgICBhbHBoYTogcmdiQ29sb3IuYVxuICAgIH07XG59XG5mdW5jdGlvbiBsYWJUb1JnYihsYWJDb2xvcikge1xuICAgIHZhciB5ID0gKGxhYkNvbG9yLmwgKyAxNikgLyAxMTYsIHggPSBpc05hTihsYWJDb2xvci5hKSA/IHkgOiB5ICsgbGFiQ29sb3IuYSAvIDUwMCwgeiA9IGlzTmFOKGxhYkNvbG9yLmIpID8geSA6IHkgLSBsYWJDb2xvci5iIC8gMjAwO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgQ29sb3IoeHl6MnJnYigzLjI0MDQ1NDIgKiB4IC0gMS41MzcxMzg1ICogeSAtIDAuNDk4NTMxNCAqIHopLCB4eXoycmdiKC0wLjk2OTI2NiAqIHggKyAxLjg3NjAxMDggKiB5ICsgMC4wNDE1NTYgKiB6KSwgeHl6MnJnYigwLjA1NTY0MzQgKiB4IC0gMC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopLCBsYWJDb2xvci5hbHBoYSk7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUxhYihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGw6IG51bWJlcihmcm9tLmwsIHRvLmwsIHQpLFxuICAgICAgICBhOiBudW1iZXIoZnJvbS5hLCB0by5hLCB0KSxcbiAgICAgICAgYjogbnVtYmVyKGZyb20uYiwgdG8uYiwgdCksXG4gICAgICAgIGFscGhhOiBudW1iZXIoZnJvbS5hbHBoYSwgdG8uYWxwaGEsIHQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJnYlRvSGNsKHJnYkNvbG9yKSB7XG4gICAgdmFyIHJlZiA9IHJnYlRvTGFiKHJnYkNvbG9yKTtcbiAgICB2YXIgbCA9IHJlZi5sO1xuICAgIHZhciBhID0gcmVmLmE7XG4gICAgdmFyIGIgPSByZWYuYjtcbiAgICB2YXIgaCA9IE1hdGguYXRhbjIoYiwgYSkgKiByYWQyZGVnO1xuICAgIHJldHVybiB7XG4gICAgICAgIGg6IGggPCAwID8gaCArIDM2MCA6IGgsXG4gICAgICAgIGM6IE1hdGguc3FydChhICogYSArIGIgKiBiKSxcbiAgICAgICAgbDogbCxcbiAgICAgICAgYWxwaGE6IHJnYkNvbG9yLmFcbiAgICB9O1xufVxuZnVuY3Rpb24gaGNsVG9SZ2IoaGNsQ29sb3IpIHtcbiAgICB2YXIgaCA9IGhjbENvbG9yLmggKiBkZWcycmFkLCBjID0gaGNsQ29sb3IuYywgbCA9IGhjbENvbG9yLmw7XG4gICAgcmV0dXJuIGxhYlRvUmdiKHtcbiAgICAgICAgbDogbCxcbiAgICAgICAgYTogTWF0aC5jb3MoaCkgKiBjLFxuICAgICAgICBiOiBNYXRoLnNpbihoKSAqIGMsXG4gICAgICAgIGFscGhhOiBoY2xDb2xvci5hbHBoYVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVIdWUoYSwgYiwgdCkge1xuICAgIHZhciBkID0gYiAtIGE7XG4gICAgcmV0dXJuIGEgKyB0ICogKGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpO1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVIY2woZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoOiBpbnRlcnBvbGF0ZUh1ZShmcm9tLmgsIHRvLmgsIHQpLFxuICAgICAgICBjOiBudW1iZXIoZnJvbS5jLCB0by5jLCB0KSxcbiAgICAgICAgbDogbnVtYmVyKGZyb20ubCwgdG8ubCwgdCksXG4gICAgICAgIGFscGhhOiBudW1iZXIoZnJvbS5hbHBoYSwgdG8uYWxwaGEsIHQpXG4gICAgfTtcbn1cbnZhciBsYWIgPSB7XG4gICAgZm9yd2FyZDogcmdiVG9MYWIsXG4gICAgcmV2ZXJzZTogbGFiVG9SZ2IsXG4gICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlTGFiXG59O1xudmFyIGhjbCA9IHtcbiAgICBmb3J3YXJkOiByZ2JUb0hjbCxcbiAgICByZXZlcnNlOiBoY2xUb1JnYixcbiAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGVIY2xcbn07XG5cbnZhciBjb2xvclNwYWNlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBsYWI6IGxhYixcbiAgaGNsOiBoY2xcbn0pO1xuXG52YXIgSW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBJbnRlcnBvbGF0ZSh0eXBlLCBvcGVyYXRvciwgaW50ZXJwb2xhdGlvbiwgaW5wdXQsIHN0b3BzKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0b3BzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmVmID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIGxhYmVsID0gcmVmWzBdO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJlZlsxXTtcbiAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKGV4cHJlc3Npb24pO1xuICAgIH1cbn07XG5JbnRlcnBvbGF0ZS5pbnRlcnBvbGF0aW9uRmFjdG9yID0gZnVuY3Rpb24gaW50ZXJwb2xhdGlvbkZhY3RvcihpbnRlcnBvbGF0aW9uLCBpbnB1dCwgbG93ZXIsIHVwcGVyKSB7XG4gICAgdmFyIHQgPSAwO1xuICAgIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgdCA9IGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgaW50ZXJwb2xhdGlvbi5iYXNlLCBsb3dlciwgdXBwZXIpO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnbGluZWFyJykge1xuICAgICAgICB0ID0gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCAxLCBsb3dlciwgdXBwZXIpO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnY3ViaWMtYmV6aWVyJykge1xuICAgICAgICB2YXIgYyA9IGludGVycG9sYXRpb24uY29udHJvbFBvaW50cztcbiAgICAgICAgdmFyIHViID0gbmV3IHVuaXRiZXppZXIoY1swXSwgY1sxXSwgY1syXSwgY1szXSk7XG4gICAgICAgIHQgPSB1Yi5zb2x2ZShleHBvbmVudGlhbEludGVycG9sYXRpb24oaW5wdXQsIDEsIGxvd2VyLCB1cHBlcikpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5JbnRlcnBvbGF0ZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBhcmdzWzBdO1xuICAgIHZhciBpbnRlcnBvbGF0aW9uID0gYXJnc1sxXTtcbiAgICB2YXIgaW5wdXQgPSBhcmdzWzJdO1xuICAgIHZhciByZXN0ID0gYXJncy5zbGljZSgzKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW50ZXJwb2xhdGlvbikgfHwgaW50ZXJwb2xhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGFuIGludGVycG9sYXRpb24gdHlwZSBleHByZXNzaW9uLicsIDEpO1xuICAgIH1cbiAgICBpZiAoaW50ZXJwb2xhdGlvblswXSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgaW50ZXJwb2xhdGlvbiA9IHsgbmFtZTogJ2xpbmVhcicgfTtcbiAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBpbnRlcnBvbGF0aW9uWzFdO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBhIG51bWVyaWMgYmFzZS4nLCAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcnBvbGF0aW9uID0ge1xuICAgICAgICAgICAgbmFtZTogJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgICAgIGJhc2U6IGJhc2VcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdjdWJpYy1iZXppZXInKSB7XG4gICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gaW50ZXJwb2xhdGlvbi5zbGljZSgxKTtcbiAgICAgICAgaWYgKGNvbnRyb2xQb2ludHMubGVuZ3RoICE9PSA0IHx8IGNvbnRyb2xQb2ludHMuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdCAhPT0gJ251bWJlcicgfHwgdCA8IDAgfHwgdCA+IDE7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0N1YmljIGJlemllciBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGZvdXIgbnVtZXJpYyBhcmd1bWVudHMgd2l0aCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLicsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGludGVycG9sYXRpb24gPSB7XG4gICAgICAgICAgICBuYW1lOiAnY3ViaWMtYmV6aWVyJyxcbiAgICAgICAgICAgIGNvbnRyb2xQb2ludHM6IGNvbnRyb2xQb2ludHNcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignVW5rbm93biBpbnRlcnBvbGF0aW9uIHR5cGUgJyArIFN0cmluZyhpbnRlcnBvbGF0aW9uWzBdKSwgMSwgMCk7XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCAtIDEgPCA0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJy4nKTtcbiAgICB9XG4gICAgaWYgKChhcmdzLmxlbmd0aCAtIDEpICUgMiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLicpO1xuICAgIH1cbiAgICBpbnB1dCA9IGNvbnRleHQucGFyc2UoaW5wdXQsIDIsIE51bWJlclR5cGUpO1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBzdG9wcyA9IFtdO1xuICAgIHZhciBvdXRwdXRUeXBlID0gbnVsbDtcbiAgICBpZiAob3BlcmF0b3IgPT09ICdpbnRlcnBvbGF0ZS1oY2wnIHx8IG9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUtbGFiJykge1xuICAgICAgICBvdXRwdXRUeXBlID0gQ29sb3JUeXBlO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICBvdXRwdXRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgbGFiZWwgPSByZXN0W2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN0W2kgKyAxXTtcbiAgICAgICAgdmFyIGxhYmVsS2V5ID0gaSArIDM7XG4gICAgICAgIHZhciB2YWx1ZUtleSA9IGkgKyA0O1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb25zIG11c3QgYmUgZGVmaW5lZCB1c2luZyBsaXRlcmFsIG51bWVyaWMgdmFsdWVzIChub3QgY29tcHV0ZWQgZXhwcmVzc2lvbnMpIGZvciB0aGUgaW5wdXQgdmFsdWVzLicsIGxhYmVsS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcHMubGVuZ3RoICYmIHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdWzBdID49IGxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBhcnJhbmdlZCB3aXRoIGlucHV0IHZhbHVlcyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuJywgbGFiZWxLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCB2YWx1ZUtleSwgb3V0cHV0VHlwZSk7XG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCBwYXJzZWQudHlwZTtcbiAgICAgICAgc3RvcHMucHVzaChbXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIHBhcnNlZFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgaWYgKG91dHB1dFR5cGUua2luZCAhPT0gJ251bWJlcicgJiYgb3V0cHV0VHlwZS5raW5kICE9PSAnY29sb3InICYmICEob3V0cHV0VHlwZS5raW5kID09PSAnYXJyYXknICYmIG91dHB1dFR5cGUuaXRlbVR5cGUua2luZCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG91dHB1dFR5cGUuTiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdUeXBlICcgKyB0b1N0cmluZyhvdXRwdXRUeXBlKSArICcgaXMgbm90IGludGVycG9sYXRhYmxlLicpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEludGVycG9sYXRlKG91dHB1dFR5cGUsIG9wZXJhdG9yLCBpbnRlcnBvbGF0aW9uLCBpbnB1dCwgc3RvcHMpO1xufTtcbkludGVycG9sYXRlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBsYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICB2YXIgb3V0cHV0cyA9IHRoaXMub3V0cHV0cztcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0c1swXS5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7XG4gICAgaWYgKHZhbHVlIDw9IGxhYmVsc1swXSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0c1swXS5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgICB2YXIgc3RvcENvdW50ID0gbGFiZWxzLmxlbmd0aDtcbiAgICBpZiAodmFsdWUgPj0gbGFiZWxzW3N0b3BDb3VudCAtIDFdKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzW3N0b3BDb3VudCAtIDFdLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZpbmRTdG9wTGVzc1RoYW5PckVxdWFsVG8obGFiZWxzLCB2YWx1ZSk7XG4gICAgdmFyIGxvd2VyID0gbGFiZWxzW2luZGV4XTtcbiAgICB2YXIgdXBwZXIgPSBsYWJlbHNbaW5kZXggKyAxXTtcbiAgICB2YXIgdCA9IEludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IodGhpcy5pbnRlcnBvbGF0aW9uLCB2YWx1ZSwgbG93ZXIsIHVwcGVyKTtcbiAgICB2YXIgb3V0cHV0TG93ZXIgPSBvdXRwdXRzW2luZGV4XS5ldmFsdWF0ZShjdHgpO1xuICAgIHZhciBvdXRwdXRVcHBlciA9IG91dHB1dHNbaW5kZXggKyAxXS5ldmFsdWF0ZShjdHgpO1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUnKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVt0aGlzLnR5cGUua2luZC50b0xvd2VyQ2FzZSgpXShvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIsIHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlLWhjbCcpIHtcbiAgICAgICAgcmV0dXJuIGhjbC5yZXZlcnNlKGhjbC5pbnRlcnBvbGF0ZShoY2wuZm9yd2FyZChvdXRwdXRMb3dlciksIGhjbC5mb3J3YXJkKG91dHB1dFVwcGVyKSwgdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsYWIucmV2ZXJzZShsYWIuaW50ZXJwb2xhdGUobGFiLmZvcndhcmQob3V0cHV0TG93ZXIpLCBsYWIuZm9yd2FyZChvdXRwdXRVcHBlciksIHQpKTtcbiAgICB9XG59O1xuSW50ZXJwb2xhdGUucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5vdXRwdXRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGxpc3RbaV07XG4gICAgICAgIGZuKGV4cHJlc3Npb24pO1xuICAgIH1cbn07XG5JbnRlcnBvbGF0ZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHJldHVybiBvdXQub3V0cHV0RGVmaW5lZCgpO1xuICAgIH0pO1xufTtcbkludGVycG9sYXRlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIGludGVycG9sYXRpb247XG4gICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnbGluZWFyJykge1xuICAgICAgICBpbnRlcnBvbGF0aW9uID0gWydsaW5lYXInXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVycG9sYXRpb24uYmFzZSA9PT0gMSkge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IFsnbGluZWFyJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uID0gW1xuICAgICAgICAgICAgICAgICdleHBvbmVudGlhbCcsXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uLmJhc2VcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnBvbGF0aW9uID0gWydjdWJpYy1iZXppZXInXS5jb25jYXQodGhpcy5pbnRlcnBvbGF0aW9uLmNvbnRyb2xQb2ludHMpO1xuICAgIH1cbiAgICB2YXIgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgdGhpcy5vcGVyYXRvcixcbiAgICAgICAgaW50ZXJwb2xhdGlvbixcbiAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKVxuICAgIF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5sYWJlbHNbaV0sIHRoaXMub3V0cHV0c1tpXS5zZXJpYWxpemUoKSk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcbmZ1bmN0aW9uIGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgYmFzZSwgbG93ZXJWYWx1ZSwgdXBwZXJWYWx1ZSkge1xuICAgIHZhciBkaWZmZXJlbmNlID0gdXBwZXJWYWx1ZSAtIGxvd2VyVmFsdWU7XG4gICAgdmFyIHByb2dyZXNzID0gaW5wdXQgLSBsb3dlclZhbHVlO1xuICAgIGlmIChkaWZmZXJlbmNlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAoYmFzZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcHJvZ3Jlc3MgLyBkaWZmZXJlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5wb3coYmFzZSwgcHJvZ3Jlc3MpIC0gMSkgLyAoTWF0aC5wb3coYmFzZSwgZGlmZmVyZW5jZSkgLSAxKTtcbiAgICB9XG59XG5cbnZhciBDb2FsZXNjZSA9IGZ1bmN0aW9uIENvYWxlc2NlKHR5cGUsIGFyZ3MpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG59O1xuQ29hbGVzY2UucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0VHlwZSA9IG51bGw7XG4gICAgdmFyIGV4cGVjdGVkVHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgIGlmIChleHBlY3RlZFR5cGUgJiYgZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgb3V0cHV0VHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgdmFyIHBhcnNlZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGFyZ3Muc2xpY2UoMSk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBhcmcgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgcGFyc2VkID0gY29udGV4dC5wYXJzZShhcmcsIDEgKyBwYXJzZWRBcmdzLmxlbmd0aCwgb3V0cHV0VHlwZSwgdW5kZWZpbmVkLCB7IHR5cGVBbm5vdGF0aW9uOiAnb21pdCcgfSk7XG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCBwYXJzZWQudHlwZTtcbiAgICAgICAgcGFyc2VkQXJncy5wdXNoKHBhcnNlZCk7XG4gICAgfVxuICAgIHZhciBuZWVkc0Fubm90YXRpb24gPSBleHBlY3RlZFR5cGUgJiYgcGFyc2VkQXJncy5zb21lKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrU3VidHlwZShleHBlY3RlZFR5cGUsIGFyZy50eXBlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmVlZHNBbm5vdGF0aW9uID8gbmV3IENvYWxlc2NlKFZhbHVlVHlwZSwgcGFyc2VkQXJncykgOiBuZXcgQ29hbGVzY2Uob3V0cHV0VHlwZSwgcGFyc2VkQXJncyk7XG59O1xuQ29hbGVzY2UucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgdmFyIGFyZ0NvdW50ID0gMDtcbiAgICB2YXIgcmVxdWVzdGVkSW1hZ2VOYW1lO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5hcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTtcbiAgICAgICAgYXJnQ291bnQrKztcbiAgICAgICAgcmVzdWx0ID0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSAmJiAhcmVzdWx0LmF2YWlsYWJsZSkge1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0ZWRJbWFnZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRJbWFnZU5hbWUgPSByZXN1bHQubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJnQ291bnQgPT09IHRoaXMuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXF1ZXN0ZWRJbWFnZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5Db2FsZXNjZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgdGhpcy5hcmdzLmZvckVhY2goZm4pO1xufTtcbkNvYWxlc2NlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSk7XG59O1xuQ29hbGVzY2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9IFsnY29hbGVzY2UnXTtcbiAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbnZhciBMZXQgPSBmdW5jdGlvbiBMZXQoYmluZGluZ3MsIHJlc3VsdCkge1xuICAgIHRoaXMudHlwZSA9IHJlc3VsdC50eXBlO1xuICAgIHRoaXMuYmluZGluZ3MgPSBbXS5jb25jYXQoYmluZGluZ3MpO1xuICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcbkxldC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQuZXZhbHVhdGUoY3R4KTtcbn07XG5MZXQucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5iaW5kaW5nczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBsaXN0W2ldO1xuICAgICAgICBmbihiaW5kaW5nWzFdKTtcbiAgICB9XG4gICAgZm4odGhpcy5yZXN1bHQpO1xufTtcbkxldC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCA0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCAzIGFyZ3VtZW50cywgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgdmFyIGJpbmRpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICB2YXIgbmFtZSA9IGFyZ3NbaV07XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBzdHJpbmcsIGJ1dCBmb3VuZCAnICsgdHlwZW9mIG5hbWUgKyAnIGluc3RlYWQuJywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9bXmEtekEtWjAtOV9dLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignVmFyaWFibGUgbmFtZXMgbXVzdCBjb250YWluIG9ubHkgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgb3IgXFwnX1xcJy4nLCBpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaSArIDFdLCBpICsgMSk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJpbmRpbmdzLnB1c2goW1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgY29udGV4dC5leHBlY3RlZFR5cGUsIGJpbmRpbmdzKTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMZXQoYmluZGluZ3MsIHJlc3VsdCk7XG59O1xuTGV0LnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3V0cHV0RGVmaW5lZCgpO1xufTtcbkxldC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gWydsZXQnXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHRoaXMuYmluZGluZ3M7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByZWYgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgbmFtZSA9IHJlZlswXTtcbiAgICAgICAgdmFyIGV4cHIgPSByZWZbMV07XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaChuYW1lLCBleHByLnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5wdXNoKHRoaXMucmVzdWx0LnNlcmlhbGl6ZSgpKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbnZhciBBdCA9IGZ1bmN0aW9uIEF0KHR5cGUsIGluZGV4LCBpbnB1dCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbn07XG5BdC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIE51bWJlclR5cGUpO1xuICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgYXJyYXkoY29udGV4dC5leHBlY3RlZFR5cGUgfHwgVmFsdWVUeXBlKSk7XG4gICAgaWYgKCFpbmRleCB8fCAhaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB0ID0gaW5wdXQudHlwZTtcbiAgICByZXR1cm4gbmV3IEF0KHQuaXRlbVR5cGUsIGluZGV4LCBpbnB1dCk7XG59O1xuQXQucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleC5ldmFsdWF0ZShjdHgpO1xuICAgIHZhciBhcnJheSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0FycmF5IGluZGV4IG91dCBvZiBib3VuZHM6ICcgKyBpbmRleCArICcgPCAwLicpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0FycmF5IGluZGV4IG91dCBvZiBib3VuZHM6ICcgKyBpbmRleCArICcgPiAnICsgKGFycmF5Lmxlbmd0aCAtIDEpICsgJy4nKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSBNYXRoLmZsb29yKGluZGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdBcnJheSBpbmRleCBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBmb3VuZCAnICsgaW5kZXggKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVtpbmRleF07XG59O1xuQXQucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZuKHRoaXMuaW5kZXgpO1xuICAgIGZuKHRoaXMuaW5wdXQpO1xufTtcbkF0LnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuQXQucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAnYXQnLFxuICAgICAgICB0aGlzLmluZGV4LnNlcmlhbGl6ZSgpLFxuICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXG4gICAgXTtcbn07XG5cbnZhciBJbiA9IGZ1bmN0aW9uIEluKG5lZWRsZSwgaGF5c3RhY2spIHtcbiAgICB0aGlzLnR5cGUgPSBCb29sZWFuVHlwZTtcbiAgICB0aGlzLm5lZWRsZSA9IG5lZWRsZTtcbiAgICB0aGlzLmhheXN0YWNrID0gaGF5c3RhY2s7XG59O1xuSW4ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCAyIGFyZ3VtZW50cywgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgdmFyIG5lZWRsZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTtcbiAgICB2YXIgaGF5c3RhY2sgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7XG4gICAgaWYgKCFuZWVkbGUgfHwgIWhheXN0YWNrKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRUeXBlKG5lZWRsZS50eXBlLCBbXG4gICAgICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVsbFR5cGUsXG4gICAgICAgICAgICBWYWx1ZVR5cGVcbiAgICAgICAgXSkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kICcgKyB0b1N0cmluZyhuZWVkbGUudHlwZSkgKyAnIGluc3RlYWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbihuZWVkbGUsIGhheXN0YWNrKTtcbn07XG5Jbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgbmVlZGxlID0gdGhpcy5uZWVkbGUuZXZhbHVhdGUoY3R4KTtcbiAgICB2YXIgaGF5c3RhY2sgPSB0aGlzLmhheXN0YWNrLmV2YWx1YXRlKGN0eCk7XG4gICAgaWYgKCFoYXlzdGFjaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZE5hdGl2ZVR5cGUobmVlZGxlLCBbXG4gICAgICAgICAgICAnYm9vbGVhbicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgJ251bGwnXG4gICAgICAgIF0pKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kICcgKyB0b1N0cmluZyh0eXBlT2YobmVlZGxlKSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZE5hdGl2ZVR5cGUoaGF5c3RhY2ssIFtcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ2FycmF5J1xuICAgICAgICBdKSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdFeHBlY3RlZCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodHlwZU9mKGhheXN0YWNrKSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSkgPj0gMDtcbn07XG5Jbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5uZWVkbGUpO1xuICAgIGZuKHRoaXMuaGF5c3RhY2spO1xufTtcbkluLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5Jbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICdpbicsXG4gICAgICAgIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLFxuICAgICAgICB0aGlzLmhheXN0YWNrLnNlcmlhbGl6ZSgpXG4gICAgXTtcbn07XG5cbnZhciBJbmRleE9mID0gZnVuY3Rpb24gSW5kZXhPZihuZWVkbGUsIGhheXN0YWNrLCBmcm9tSW5kZXgpIHtcbiAgICB0aGlzLnR5cGUgPSBOdW1iZXJUeXBlO1xuICAgIHRoaXMubmVlZGxlID0gbmVlZGxlO1xuICAgIHRoaXMuaGF5c3RhY2sgPSBoYXlzdGFjaztcbiAgICB0aGlzLmZyb21JbmRleCA9IGZyb21JbmRleDtcbn07XG5JbmRleE9mLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8PSAyIHx8IGFyZ3MubGVuZ3RoID49IDUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIDMgb3IgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHZhciBuZWVkbGUgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgdmFyIGhheXN0YWNrID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBWYWx1ZVR5cGUpO1xuICAgIGlmICghbmVlZGxlIHx8ICFoYXlzdGFjaykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkVHlwZShuZWVkbGUudHlwZSwgW1xuICAgICAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bGxUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0pKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcobmVlZGxlLnR5cGUpICsgJyBpbnN0ZWFkJyk7XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzNdLCAzLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFmcm9tSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZihuZWVkbGUsIGhheXN0YWNrLCBmcm9tSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZihuZWVkbGUsIGhheXN0YWNrKTtcbiAgICB9XG59O1xuSW5kZXhPZi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgbmVlZGxlID0gdGhpcy5uZWVkbGUuZXZhbHVhdGUoY3R4KTtcbiAgICB2YXIgaGF5c3RhY2sgPSB0aGlzLmhheXN0YWNrLmV2YWx1YXRlKGN0eCk7XG4gICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShuZWVkbGUsIFtcbiAgICAgICAgICAgICdib29sZWFuJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAnbnVsbCdcbiAgICAgICAgXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZihuZWVkbGUpKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShoYXlzdGFjaywgW1xuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnYXJyYXknXG4gICAgICAgIF0pKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICcgKyB0b1N0cmluZyh0eXBlT2YoaGF5c3RhY2spKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSB0aGlzLmZyb21JbmRleC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUsIGZyb21JbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSk7XG59O1xuSW5kZXhPZi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5uZWVkbGUpO1xuICAgIGZuKHRoaXMuaGF5c3RhY2spO1xuICAgIGlmICh0aGlzLmZyb21JbmRleCkge1xuICAgICAgICBmbih0aGlzLmZyb21JbmRleCk7XG4gICAgfVxufTtcbkluZGV4T2YucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5JbmRleE9mLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuZnJvbUluZGV4ICE9IG51bGwgJiYgdGhpcy5mcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gdGhpcy5mcm9tSW5kZXguc2VyaWFsaXplKCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnaW5kZXgtb2YnLFxuICAgICAgICAgICAgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksXG4gICAgICAgICAgICB0aGlzLmhheXN0YWNrLnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgZnJvbUluZGV4XG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgICdpbmRleC1vZicsXG4gICAgICAgIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLFxuICAgICAgICB0aGlzLmhheXN0YWNrLnNlcmlhbGl6ZSgpXG4gICAgXTtcbn07XG5cbnZhciBNYXRjaCA9IGZ1bmN0aW9uIE1hdGNoKGlucHV0VHlwZSwgb3V0cHV0VHlwZSwgaW5wdXQsIGNhc2VzLCBvdXRwdXRzLCBvdGhlcndpc2UpIHtcbiAgICB0aGlzLmlucHV0VHlwZSA9IGlucHV0VHlwZTtcbiAgICB0aGlzLnR5cGUgPSBvdXRwdXRUeXBlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmNhc2VzID0gY2FzZXM7XG4gICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICB0aGlzLm90aGVyd2lzZSA9IG90aGVyd2lzZTtcbn07XG5NYXRjaC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCA1KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJy4nKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoICUgMiAhPT0gMSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLicpO1xuICAgIH1cbiAgICB2YXIgaW5wdXRUeXBlO1xuICAgIHZhciBvdXRwdXRUeXBlO1xuICAgIGlmIChjb250ZXh0LmV4cGVjdGVkVHlwZSAmJiBjb250ZXh0LmV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgdmFyIGNhc2VzID0ge307XG4gICAgdmFyIG91dHB1dHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIHZhciBsYWJlbHMgPSBhcmdzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpIHtcbiAgICAgICAgICAgIGxhYmVscyA9IFtsYWJlbHNdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYWJlbENvbnRleHQgPSBjb250ZXh0LmNvbmNhdChpKTtcbiAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSBicmFuY2ggbGFiZWwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCA9IGxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBsaXN0W2kkMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGFiZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignQnJhbmNoIGxhYmVscyBtdXN0IGJlIG51bWJlcnMgb3Igc3RyaW5ncy4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVsID09PSAnbnVtYmVyJyAmJiBNYXRoLmFicyhsYWJlbCkgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoJ0JyYW5jaCBsYWJlbHMgbXVzdCBiZSBpbnRlZ2VycyBubyBsYXJnZXIgdGhhbiAnICsgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgKyAnLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGFiZWwgPT09ICdudW1iZXInICYmIE1hdGguZmxvb3IobGFiZWwpICE9PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoJ051bWVyaWMgYnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXIgdmFsdWVzLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRUeXBlID0gdHlwZU9mKGxhYmVsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb250ZXh0LmNoZWNrU3VidHlwZShpbnB1dFR5cGUsIHR5cGVPZihsYWJlbCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhc2VzW1N0cmluZyhsYWJlbCldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoJ0JyYW5jaCBsYWJlbHMgbXVzdCBiZSB1bmlxdWUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlc1tTdHJpbmcobGFiZWwpXSA9IG91dHB1dHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCBpLCBvdXRwdXRUeXBlKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHJlc3VsdC50eXBlO1xuICAgICAgICBvdXRwdXRzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvdGhlcndpc2UgPSBjb250ZXh0LnBhcnNlKGFyZ3NbYXJncy5sZW5ndGggLSAxXSwgYXJncy5sZW5ndGggLSAxLCBvdXRwdXRUeXBlKTtcbiAgICBpZiAoIW90aGVyd2lzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlucHV0LnR5cGUua2luZCAhPT0gJ3ZhbHVlJyAmJiBjb250ZXh0LmNvbmNhdCgxKS5jaGVja1N1YnR5cGUoaW5wdXRUeXBlLCBpbnB1dC50eXBlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNYXRjaChpbnB1dFR5cGUsIG91dHB1dFR5cGUsIGlucHV0LCBjYXNlcywgb3V0cHV0cywgb3RoZXJ3aXNlKTtcbn07XG5NYXRjaC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7XG4gICAgdmFyIG91dHB1dCA9IHR5cGVPZihpbnB1dCkgPT09IHRoaXMuaW5wdXRUeXBlICYmIHRoaXMub3V0cHV0c1t0aGlzLmNhc2VzW2lucHV0XV0gfHwgdGhpcy5vdGhlcndpc2U7XG4gICAgcmV0dXJuIG91dHB1dC5ldmFsdWF0ZShjdHgpO1xufTtcbk1hdGNoLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLmlucHV0KTtcbiAgICB0aGlzLm91dHB1dHMuZm9yRWFjaChmbik7XG4gICAgZm4odGhpcy5vdGhlcndpc2UpO1xufTtcbk1hdGNoLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSkgJiYgdGhpcy5vdGhlcndpc2Uub3V0cHV0RGVmaW5lZCgpO1xufTtcbk1hdGNoLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbXG4gICAgICAgICdtYXRjaCcsXG4gICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKClcbiAgICBdO1xuICAgIHZhciBzb3J0ZWRMYWJlbHMgPSBPYmplY3Qua2V5cyh0aGlzLmNhc2VzKS5zb3J0KCk7XG4gICAgdmFyIGdyb3VwZWRCeU91dHB1dCA9IFtdO1xuICAgIHZhciBvdXRwdXRMb29rdXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHNvcnRlZExhYmVsczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gb3V0cHV0TG9va3VwW3RoaXMuY2FzZXNbbGFiZWxdXTtcbiAgICAgICAgaWYgKG91dHB1dEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG91dHB1dExvb2t1cFt0aGlzLmNhc2VzW2xhYmVsXV0gPSBncm91cGVkQnlPdXRwdXQubGVuZ3RoO1xuICAgICAgICAgICAgZ3JvdXBlZEJ5T3V0cHV0LnB1c2goW1xuICAgICAgICAgICAgICAgIHRoaXMuY2FzZXNbbGFiZWxdLFxuICAgICAgICAgICAgICAgIFtsYWJlbF1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXBlZEJ5T3V0cHV0W291dHB1dEluZGV4XVsxXS5wdXNoKGxhYmVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29lcmNlTGFiZWwgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMkMS5pbnB1dFR5cGUua2luZCA9PT0gJ251bWJlcicgPyBOdW1iZXIobGFiZWwpIDogbGFiZWw7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBncm91cGVkQnlPdXRwdXQ7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciByZWYgPSBsaXN0JDFbaSQxXTtcbiAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gcmVmWzBdO1xuICAgICAgICB2YXIgbGFiZWxzID0gcmVmWzFdO1xuICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNvZXJjZUxhYmVsKGxhYmVsc1swXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGxhYmVscy5tYXAoY29lcmNlTGFiZWwpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5vdXRwdXRzW291dHB1dEluZGV4JDFdLnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5wdXNoKHRoaXMub3RoZXJ3aXNlLnNlcmlhbGl6ZSgpKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbnZhciBDYXNlID0gZnVuY3Rpb24gQ2FzZSh0eXBlLCBicmFuY2hlcywgb3RoZXJ3aXNlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmJyYW5jaGVzID0gYnJhbmNoZXM7XG4gICAgdGhpcy5vdGhlcndpc2UgPSBvdGhlcndpc2U7XG59O1xuQ2FzZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCA0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCAzIGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJy4nKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYW4gb2RkIG51bWJlciBvZiBhcmd1bWVudHMuJyk7XG4gICAgfVxuICAgIHZhciBvdXRwdXRUeXBlO1xuICAgIGlmIChjb250ZXh0LmV4cGVjdGVkVHlwZSAmJiBjb250ZXh0LmV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgdmFyIGJyYW5jaGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICB2YXIgdGVzdCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgaSwgQm9vbGVhblR5cGUpO1xuICAgICAgICBpZiAoIXRlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaSArIDFdLCBpICsgMSwgb3V0cHV0VHlwZSk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmFuY2hlcy5wdXNoKFtcbiAgICAgICAgICAgIHRlc3QsXG4gICAgICAgICAgICByZXN1bHRcbiAgICAgICAgXSk7XG4gICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHJlc3VsdC50eXBlO1xuICAgIH1cbiAgICB2YXIgb3RoZXJ3aXNlID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgb3V0cHV0VHlwZSk7XG4gICAgaWYgKCFvdGhlcndpc2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ2FzZShvdXRwdXRUeXBlLCBicmFuY2hlcywgb3RoZXJ3aXNlKTtcbn07XG5DYXNlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5icmFuY2hlczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IGxpc3RbaV07XG4gICAgICAgIHZhciB0ZXN0ID0gcmVmWzBdO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJlZlsxXTtcbiAgICAgICAgaWYgKHRlc3QuZXZhbHVhdGUoY3R4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vdGhlcndpc2UuZXZhbHVhdGUoY3R4KTtcbn07XG5DYXNlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHRoaXMuYnJhbmNoZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByZWYgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgdGVzdCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSByZWZbMV07XG4gICAgICAgIGZuKHRlc3QpO1xuICAgICAgICBmbihleHByZXNzaW9uKTtcbiAgICB9XG4gICAgZm4odGhpcy5vdGhlcndpc2UpO1xufTtcbkNhc2UucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmJyYW5jaGVzLmV2ZXJ5KGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIF8gPSByZWZbMF07XG4gICAgICAgIHZhciBvdXQgPSByZWZbMV07XG4gICAgICAgIHJldHVybiBvdXQub3V0cHV0RGVmaW5lZCgpO1xuICAgIH0pICYmIHRoaXMub3RoZXJ3aXNlLm91dHB1dERlZmluZWQoKTtcbn07XG5DYXNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2Nhc2UnXTtcbiAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbnZhciBTbGljZSA9IGZ1bmN0aW9uIFNsaWNlKHR5cGUsIGlucHV0LCBiZWdpbkluZGV4LCBlbmRJbmRleCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuYmVnaW5JbmRleCA9IGJlZ2luSW5kZXg7XG4gICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xufTtcblNsaWNlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8PSAyIHx8IGFyZ3MubGVuZ3RoID49IDUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIDMgb3IgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTtcbiAgICB2YXIgYmVnaW5JbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgTnVtYmVyVHlwZSk7XG4gICAgaWYgKCFpbnB1dCB8fCAhYmVnaW5JbmRleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkVHlwZShpbnB1dC50eXBlLCBbXG4gICAgICAgICAgICBhcnJheShWYWx1ZVR5cGUpLFxuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcoaW5wdXQudHlwZSkgKyAnIGluc3RlYWQnKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1szXSwgMywgTnVtYmVyVHlwZSk7XG4gICAgICAgIGlmICghZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoaW5wdXQudHlwZSwgaW5wdXQsIGJlZ2luSW5kZXgsIGVuZEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGlucHV0LnR5cGUsIGlucHV0LCBiZWdpbkluZGV4KTtcbiAgICB9XG59O1xuU2xpY2UucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgIHZhciBiZWdpbkluZGV4ID0gdGhpcy5iZWdpbkluZGV4LmV2YWx1YXRlKGN0eCk7XG4gICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShpbnB1dCwgW1xuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnYXJyYXknXG4gICAgICAgIF0pKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZihpbnB1dCkpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbmRJbmRleCkge1xuICAgICAgICB2YXIgZW5kSW5kZXggPSB0aGlzLmVuZEluZGV4LmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIHJldHVybiBpbnB1dC5zbGljZShiZWdpbkluZGV4LCBlbmRJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5zbGljZShiZWdpbkluZGV4KTtcbn07XG5TbGljZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5pbnB1dCk7XG4gICAgZm4odGhpcy5iZWdpbkluZGV4KTtcbiAgICBpZiAodGhpcy5lbmRJbmRleCkge1xuICAgICAgICBmbih0aGlzLmVuZEluZGV4KTtcbiAgICB9XG59O1xuU2xpY2UucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5TbGljZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLmVuZEluZGV4ICE9IG51bGwgJiYgdGhpcy5lbmRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHRoaXMuZW5kSW5kZXguc2VyaWFsaXplKCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnc2xpY2UnLFxuICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgIHRoaXMuYmVnaW5JbmRleC5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgIGVuZEluZGV4XG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgICdzbGljZScsXG4gICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKCksXG4gICAgICAgIHRoaXMuYmVnaW5JbmRleC5zZXJpYWxpemUoKVxuICAgIF07XG59O1xuXG5mdW5jdGlvbiBpc0NvbXBhcmFibGVUeXBlKG9wLCB0eXBlKSB7XG4gICAgaWYgKG9wID09PSAnPT0nIHx8IG9wID09PSAnIT0nKSB7XG4gICAgICAgIHJldHVybiB0eXBlLmtpbmQgPT09ICdib29sZWFuJyB8fCB0eXBlLmtpbmQgPT09ICdzdHJpbmcnIHx8IHR5cGUua2luZCA9PT0gJ251bWJlcicgfHwgdHlwZS5raW5kID09PSAnbnVsbCcgfHwgdHlwZS5raW5kID09PSAndmFsdWUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0eXBlLmtpbmQgPT09ICdzdHJpbmcnIHx8IHR5cGUua2luZCA9PT0gJ251bWJlcicgfHwgdHlwZS5raW5kID09PSAndmFsdWUnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVxKGN0eCwgYSwgYikge1xuICAgIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gbmVxKGN0eCwgYSwgYikge1xuICAgIHJldHVybiBhICE9PSBiO1xufVxuZnVuY3Rpb24gbHQoY3R4LCBhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiO1xufVxuZnVuY3Rpb24gZ3QoY3R4LCBhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiO1xufVxuZnVuY3Rpb24gbHRlcShjdHgsIGEsIGIpIHtcbiAgICByZXR1cm4gYSA8PSBiO1xufVxuZnVuY3Rpb24gZ3RlcShjdHgsIGEsIGIpIHtcbiAgICByZXR1cm4gYSA+PSBiO1xufVxuZnVuY3Rpb24gZXFDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPT09IDA7XG59XG5mdW5jdGlvbiBuZXFDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICAgIHJldHVybiAhZXFDb2xsYXRlKGN0eCwgYSwgYiwgYyk7XG59XG5mdW5jdGlvbiBsdENvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA8IDA7XG59XG5mdW5jdGlvbiBndENvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA+IDA7XG59XG5mdW5jdGlvbiBsdGVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYy5jb21wYXJlKGEsIGIpIDw9IDA7XG59XG5mdW5jdGlvbiBndGVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYy5jb21wYXJlKGEsIGIpID49IDA7XG59XG5mdW5jdGlvbiBtYWtlQ29tcGFyaXNvbihvcCwgY29tcGFyZUJhc2ljLCBjb21wYXJlV2l0aENvbGxhdG9yKSB7XG4gICAgdmFyIGlzT3JkZXJDb21wYXJpc29uID0gb3AgIT09ICc9PScgJiYgb3AgIT09ICchPSc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29tcGFyaXNvbihsaHMsIHJocywgY29sbGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlO1xuICAgICAgICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgICAgIHRoaXMuY29sbGF0b3IgPSBjb2xsYXRvcjtcbiAgICAgICAgICAgIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50ID0gbGhzLnR5cGUua2luZCA9PT0gJ3ZhbHVlJyB8fCByaHMudHlwZS5raW5kID09PSAndmFsdWUnO1xuICAgICAgICB9XG4gICAgICAgIENvbXBhcmlzb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDMgJiYgYXJncy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcCA9IGFyZ3NbMF07XG4gICAgICAgICAgICB2YXIgbGhzID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgICAgICAgaWYgKCFsaHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDb21wYXJhYmxlVHlwZShvcCwgbGhzLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uY2F0KDEpLmVycm9yKCdcIicgKyBvcCArICdcIiBjb21wYXJpc29ucyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgdHlwZSBcXCcnICsgdG9TdHJpbmcobGhzLnR5cGUpICsgJ1xcJy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByaHMgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIXJocykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0NvbXBhcmFibGVUeXBlKG9wLCByaHMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb25jYXQoMikuZXJyb3IoJ1wiJyArIG9wICsgJ1wiIGNvbXBhcmlzb25zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlIFxcJycgKyB0b1N0cmluZyhyaHMudHlwZSkgKyAnXFwnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgIT09IHJocy50eXBlLmtpbmQgJiYgbGhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJyAmJiByaHMudHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0Nhbm5vdCBjb21wYXJlIHR5cGVzIFxcJycgKyB0b1N0cmluZyhsaHMudHlwZSkgKyAnXFwnIGFuZCBcXCcnICsgdG9TdHJpbmcocmhzLnR5cGUpICsgJ1xcJy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc09yZGVyQ29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgIGlmIChsaHMudHlwZS5raW5kID09PSAndmFsdWUnICYmIHJocy50eXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGhzID0gbmV3IEFzc2VydGlvbihyaHMudHlwZSwgW2xoc10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJyAmJiByaHMudHlwZS5raW5kID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJocyA9IG5ldyBBc3NlcnRpb24obGhzLnR5cGUsIFtyaHNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29sbGF0b3IgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIHJocy50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIGxocy50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignQ2Fubm90IHVzZSBjb2xsYXRvciB0byBjb21wYXJlIG5vbi1zdHJpbmcgdHlwZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbGxhdG9yID0gY29udGV4dC5wYXJzZShhcmdzWzNdLCAzLCBDb2xsYXRvclR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghY29sbGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wYXJpc29uKGxocywgcmhzLCBjb2xsYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIENvbXBhcmlzb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICAgICAgICB2YXIgbGhzID0gdGhpcy5saHMuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIHZhciByaHMgPSB0aGlzLnJocy5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgaWYgKGlzT3JkZXJDb21wYXJpc29uICYmIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGx0ID0gdHlwZU9mKGxocyk7XG4gICAgICAgICAgICAgICAgdmFyIHJ0ID0gdHlwZU9mKHJocyk7XG4gICAgICAgICAgICAgICAgaWYgKGx0LmtpbmQgIT09IHJ0LmtpbmQgfHwgIShsdC5raW5kID09PSAnc3RyaW5nJyB8fCBsdC5raW5kID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgYXJndW1lbnRzIGZvciBcIicgKyBvcCArICdcIiB0byBiZSAoc3RyaW5nLCBzdHJpbmcpIG9yIChudW1iZXIsIG51bWJlciksIGJ1dCBmb3VuZCAoJyArIGx0LmtpbmQgKyAnLCAnICsgcnQua2luZCArICcpIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGF0b3IgJiYgIWlzT3JkZXJDb21wYXJpc29uICYmIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGx0JDEgPSB0eXBlT2YobGhzKTtcbiAgICAgICAgICAgICAgICB2YXIgcnQkMSA9IHR5cGVPZihyaHMpO1xuICAgICAgICAgICAgICAgIGlmIChsdCQxLmtpbmQgIT09ICdzdHJpbmcnIHx8IHJ0JDEua2luZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVCYXNpYyhjdHgsIGxocywgcmhzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsYXRvciA/IGNvbXBhcmVXaXRoQ29sbGF0b3IoY3R4LCBsaHMsIHJocywgdGhpcy5jb2xsYXRvci5ldmFsdWF0ZShjdHgpKSA6IGNvbXBhcmVCYXNpYyhjdHgsIGxocywgcmhzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29tcGFyaXNvbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICAgICAgICBmbih0aGlzLmxocyk7XG4gICAgICAgICAgICBmbih0aGlzLnJocyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsYXRvcikge1xuICAgICAgICAgICAgICAgIGZuKHRoaXMuY29sbGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDb21wYXJpc29uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBDb21wYXJpc29uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZCA9IFtvcF07XG4gICAgICAgICAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbXBhcmlzb247XG4gICAgfSgpO1xufVxudmFyIEVxdWFscyA9IG1ha2VDb21wYXJpc29uKCc9PScsIGVxLCBlcUNvbGxhdGUpO1xudmFyIE5vdEVxdWFscyA9IG1ha2VDb21wYXJpc29uKCchPScsIG5lcSwgbmVxQ29sbGF0ZSk7XG52YXIgTGVzc1RoYW4gPSBtYWtlQ29tcGFyaXNvbignPCcsIGx0LCBsdENvbGxhdGUpO1xudmFyIEdyZWF0ZXJUaGFuID0gbWFrZUNvbXBhcmlzb24oJz4nLCBndCwgZ3RDb2xsYXRlKTtcbnZhciBMZXNzVGhhbk9yRXF1YWwgPSBtYWtlQ29tcGFyaXNvbignPD0nLCBsdGVxLCBsdGVxQ29sbGF0ZSk7XG52YXIgR3JlYXRlclRoYW5PckVxdWFsID0gbWFrZUNvbXBhcmlzb24oJz49JywgZ3RlcSwgZ3RlcUNvbGxhdGUpO1xuXG52YXIgTnVtYmVyRm9ybWF0ID0gZnVuY3Rpb24gTnVtYmVyRm9ybWF0KG51bWJlciwgbG9jYWxlLCBjdXJyZW5jeSwgbWluRnJhY3Rpb25EaWdpdHMsIG1heEZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdGhpcy50eXBlID0gU3RyaW5nVHlwZTtcbiAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB0aGlzLmN1cnJlbmN5ID0gY3VycmVuY3k7XG4gICAgdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyA9IG1pbkZyYWN0aW9uRGlnaXRzO1xuICAgIHRoaXMubWF4RnJhY3Rpb25EaWdpdHMgPSBtYXhGcmFjdGlvbkRpZ2l0cztcbn07XG5OdW1iZXJGb3JtYXQucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCB0d28gYXJndW1lbnRzLicpO1xuICAgIH1cbiAgICB2YXIgbnVtYmVyID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBOdW1iZXJUeXBlKTtcbiAgICBpZiAoIW51bWJlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSBhcmdzWzJdO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignTnVtYmVyRm9ybWF0IG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIHZhciBsb2NhbGUgPSBudWxsO1xuICAgIGlmIChvcHRpb25zWydsb2NhbGUnXSkge1xuICAgICAgICBsb2NhbGUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2xvY2FsZSddLCAxLCBTdHJpbmdUeXBlKTtcbiAgICAgICAgaWYgKCFsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjdXJyZW5jeSA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnNbJ2N1cnJlbmN5J10pIHtcbiAgICAgICAgY3VycmVuY3kgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2N1cnJlbmN5J10sIDEsIFN0cmluZ1R5cGUpO1xuICAgICAgICBpZiAoIWN1cnJlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWluRnJhY3Rpb25EaWdpdHMgPSBudWxsO1xuICAgIGlmIChvcHRpb25zWydtaW4tZnJhY3Rpb24tZGlnaXRzJ10pIHtcbiAgICAgICAgbWluRnJhY3Rpb25EaWdpdHMgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ21pbi1mcmFjdGlvbi1kaWdpdHMnXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgICAgIGlmICghbWluRnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBtYXhGcmFjdGlvbkRpZ2l0cyA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnNbJ21heC1mcmFjdGlvbi1kaWdpdHMnXSkge1xuICAgICAgICBtYXhGcmFjdGlvbkRpZ2l0cyA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbWF4LWZyYWN0aW9uLWRpZ2l0cyddLCAxLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFtYXhGcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJGb3JtYXQobnVtYmVyLCBsb2NhbGUsIGN1cnJlbmN5LCBtaW5GcmFjdGlvbkRpZ2l0cywgbWF4RnJhY3Rpb25EaWdpdHMpO1xufTtcbk51bWJlckZvcm1hdC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUoY3R4KSA6IFtdLCB7XG4gICAgICAgIHN0eWxlOiB0aGlzLmN1cnJlbmN5ID8gJ2N1cnJlbmN5JyA6ICdkZWNpbWFsJyxcbiAgICAgICAgY3VycmVuY3k6IHRoaXMuY3VycmVuY3kgPyB0aGlzLmN1cnJlbmN5LmV2YWx1YXRlKGN0eCkgOiB1bmRlZmluZWQsXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyA/IHRoaXMubWluRnJhY3Rpb25EaWdpdHMuZXZhbHVhdGUoY3R4KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1heEZyYWN0aW9uRGlnaXRzID8gdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cy5ldmFsdWF0ZShjdHgpIDogdW5kZWZpbmVkXG4gICAgfSkuZm9ybWF0KHRoaXMubnVtYmVyLmV2YWx1YXRlKGN0eCkpO1xufTtcbk51bWJlckZvcm1hdC5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5udW1iZXIpO1xuICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICBmbih0aGlzLmxvY2FsZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbmN5KSB7XG4gICAgICAgIGZuKHRoaXMuY3VycmVuY3kpO1xuICAgIH1cbiAgICBpZiAodGhpcy5taW5GcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICBmbih0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgICAgZm4odGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyk7XG4gICAgfVxufTtcbk51bWJlckZvcm1hdC5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbk51bWJlckZvcm1hdC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgIG9wdGlvbnNbJ2xvY2FsZSddID0gdGhpcy5sb2NhbGUuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbmN5KSB7XG4gICAgICAgIG9wdGlvbnNbJ2N1cnJlbmN5J10gPSB0aGlzLmN1cnJlbmN5LnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5taW5GcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICBvcHRpb25zWydtaW4tZnJhY3Rpb24tZGlnaXRzJ10gPSB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhGcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICBvcHRpb25zWydtYXgtZnJhY3Rpb24tZGlnaXRzJ10gPSB0aGlzLm1heEZyYWN0aW9uRGlnaXRzLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICAnbnVtYmVyLWZvcm1hdCcsXG4gICAgICAgIHRoaXMubnVtYmVyLnNlcmlhbGl6ZSgpLFxuICAgICAgICBvcHRpb25zXG4gICAgXTtcbn07XG5cbnZhciBMZW5ndGggPSBmdW5jdGlvbiBMZW5ndGgoaW5wdXQpIHtcbiAgICB0aGlzLnR5cGUgPSBOdW1iZXJUeXBlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbn07XG5MZW5ndGgucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCAxIGFyZ3VtZW50LCBidXQgZm91bmQgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICB2YXIgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEpO1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpbnB1dC50eXBlLmtpbmQgIT09ICdhcnJheScgJiYgaW5wdXQudHlwZS5raW5kICE9PSAnc3RyaW5nJyAmJiBpbnB1dC50eXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nIG9yIGFycmF5LCBidXQgZm91bmQgJyArIHRvU3RyaW5nKGlucHV0LnR5cGUpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExlbmd0aChpbnB1dCk7XG59O1xuTGVuZ3RoLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5wdXQubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0Lmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlIHN0cmluZyBvciBhcnJheSwgYnV0IGZvdW5kICcgKyB0b1N0cmluZyh0eXBlT2YoaW5wdXQpKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG59O1xuTGVuZ3RoLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLmlucHV0KTtcbn07XG5MZW5ndGgucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5MZW5ndGgucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9IFsnbGVuZ3RoJ107XG4gICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaChjaGlsZC5zZXJpYWxpemUoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG52YXIgZXhwcmVzc2lvbnMgPSB7XG4gICAgJz09JzogRXF1YWxzLFxuICAgICchPSc6IE5vdEVxdWFscyxcbiAgICAnPic6IEdyZWF0ZXJUaGFuLFxuICAgICc8JzogTGVzc1RoYW4sXG4gICAgJz49JzogR3JlYXRlclRoYW5PckVxdWFsLFxuICAgICc8PSc6IExlc3NUaGFuT3JFcXVhbCxcbiAgICAnYXJyYXknOiBBc3NlcnRpb24sXG4gICAgJ2F0JzogQXQsXG4gICAgJ2Jvb2xlYW4nOiBBc3NlcnRpb24sXG4gICAgJ2Nhc2UnOiBDYXNlLFxuICAgICdjb2FsZXNjZSc6IENvYWxlc2NlLFxuICAgICdjb2xsYXRvcic6IENvbGxhdG9yRXhwcmVzc2lvbixcbiAgICAnZm9ybWF0JzogRm9ybWF0RXhwcmVzc2lvbixcbiAgICAnaW1hZ2UnOiBJbWFnZUV4cHJlc3Npb24sXG4gICAgJ2luJzogSW4sXG4gICAgJ2luZGV4LW9mJzogSW5kZXhPZixcbiAgICAnaW50ZXJwb2xhdGUnOiBJbnRlcnBvbGF0ZSxcbiAgICAnaW50ZXJwb2xhdGUtaGNsJzogSW50ZXJwb2xhdGUsXG4gICAgJ2ludGVycG9sYXRlLWxhYic6IEludGVycG9sYXRlLFxuICAgICdsZW5ndGgnOiBMZW5ndGgsXG4gICAgJ2xldCc6IExldCxcbiAgICAnbGl0ZXJhbCc6IExpdGVyYWwsXG4gICAgJ21hdGNoJzogTWF0Y2gsXG4gICAgJ251bWJlcic6IEFzc2VydGlvbixcbiAgICAnbnVtYmVyLWZvcm1hdCc6IE51bWJlckZvcm1hdCxcbiAgICAnb2JqZWN0JzogQXNzZXJ0aW9uLFxuICAgICdzbGljZSc6IFNsaWNlLFxuICAgICdzdGVwJzogU3RlcCxcbiAgICAnc3RyaW5nJzogQXNzZXJ0aW9uLFxuICAgICd0by1ib29sZWFuJzogQ29lcmNpb24sXG4gICAgJ3RvLWNvbG9yJzogQ29lcmNpb24sXG4gICAgJ3RvLW51bWJlcic6IENvZXJjaW9uLFxuICAgICd0by1zdHJpbmcnOiBDb2VyY2lvbixcbiAgICAndmFyJzogVmFyLFxuICAgICd3aXRoaW4nOiBXaXRoaW5cbn07XG5mdW5jdGlvbiByZ2JhKGN0eCwgcmVmKSB7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgdmFyIGEgPSByZWZbM107XG4gICAgciA9IHIuZXZhbHVhdGUoY3R4KTtcbiAgICBnID0gZy5ldmFsdWF0ZShjdHgpO1xuICAgIGIgPSBiLmV2YWx1YXRlKGN0eCk7XG4gICAgdmFyIGFscGhhID0gYSA/IGEuZXZhbHVhdGUoY3R4KSA6IDE7XG4gICAgdmFyIGVycm9yID0gdmFsaWRhdGVSR0JBKHIsIGcsIGIsIGFscGhhKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29sb3IociAvIDI1NSAqIGFscGhhLCBnIC8gMjU1ICogYWxwaGEsIGIgLyAyNTUgKiBhbHBoYSwgYWxwaGEpO1xufVxuZnVuY3Rpb24gaGFzKGtleSwgb2JqKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmo7XG59XG5mdW5jdGlvbiBnZXQoa2V5LCBvYmopIHtcbiAgICB2YXIgdiA9IG9ialtrZXldO1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdjtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaCh2LCBhLCBpLCBqKSB7XG4gICAgd2hpbGUgKGkgPD0gaikge1xuICAgICAgICB2YXIgbSA9IGkgKyBqID4+IDE7XG4gICAgICAgIGlmIChhW21dID09PSB2KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVttXSA+IHYpIHtcbiAgICAgICAgICAgIGogPSBtIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgPSBtICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB2YXJhcmdzKHR5cGUpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0eXBlIH07XG59XG5Db21wb3VuZEV4cHJlc3Npb24ucmVnaXN0ZXIoZXhwcmVzc2lvbnMsIHtcbiAgICAnZXJyb3InOiBbXG4gICAgICAgIEVycm9yVHlwZSxcbiAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcih2LmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAndHlwZW9mJzogW1xuICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZyh0eXBlT2Yodi5ldmFsdWF0ZShjdHgpKSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICd0by1yZ2JhJzogW1xuICAgICAgICBhcnJheShOdW1iZXJUeXBlLCA0KSxcbiAgICAgICAgW0NvbG9yVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gdi5ldmFsdWF0ZShjdHgpLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3JnYic6IFtcbiAgICAgICAgQ29sb3JUeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGVcbiAgICAgICAgXSxcbiAgICAgICAgcmdiYVxuICAgIF0sXG4gICAgJ3JnYmEnOiBbXG4gICAgICAgIENvbG9yVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZVxuICAgICAgICBdLFxuICAgICAgICByZ2JhXG4gICAgXSxcbiAgICAnaGFzJzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuVHlwZSxcbiAgICAgICAgb3ZlcmxvYWRzOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcmVmWzBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzKGtleS5ldmFsdWF0ZShjdHgpLCBjdHgucHJvcGVydGllcygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0VHlwZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSByZWZbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXMoa2V5LmV2YWx1YXRlKGN0eCksIG9iai5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIF1cbiAgICB9LFxuICAgICdnZXQnOiB7XG4gICAgICAgIHR5cGU6IFZhbHVlVHlwZSxcbiAgICAgICAgb3ZlcmxvYWRzOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcmVmWzBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KGtleS5ldmFsdWF0ZShjdHgpLCBjdHgucHJvcGVydGllcygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0VHlwZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSByZWZbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIG9iai5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIF1cbiAgICB9LFxuICAgICdmZWF0dXJlLXN0YXRlJzogW1xuICAgICAgICBWYWx1ZVR5cGUsXG4gICAgICAgIFtTdHJpbmdUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGdldChrZXkuZXZhbHVhdGUoY3R4KSwgY3R4LmZlYXR1cmVTdGF0ZSB8fCB7fSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdwcm9wZXJ0aWVzJzogW1xuICAgICAgICBPYmplY3RUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5wcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdnZW9tZXRyeS10eXBlJzogW1xuICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5nZW9tZXRyeVR5cGUoKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2lkJzogW1xuICAgICAgICBWYWx1ZVR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmlkKCk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICd6b29tJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5nbG9iYWxzLnpvb207XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdoZWF0bWFwLWRlbnNpdHknOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lmdsb2JhbHMuaGVhdG1hcERlbnNpdHkgfHwgMDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2xpbmUtcHJvZ3Jlc3MnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lmdsb2JhbHMubGluZVByb2dyZXNzIHx8IDA7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdhY2N1bXVsYXRlZCc6IFtcbiAgICAgICAgVmFsdWVUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5nbG9iYWxzLmFjY3VtdWxhdGVkID09PSB1bmRlZmluZWQgPyBudWxsIDogY3R4Lmdsb2JhbHMuYWNjdW11bGF0ZWQ7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICcrJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gYXJnczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnKic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgdmFyYXJncyhOdW1iZXJUeXBlKSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IDE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGFyZ3M7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0ICo9IGFyZy5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJy0nOiB7XG4gICAgICAgIHR5cGU6IE51bWJlclR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyVHlwZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gcmVmWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZXZhbHVhdGUoY3R4KSAtIGIuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtYS5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJy8nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgYiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJldHVybiBhLmV2YWx1YXRlKGN0eCkgLyBiLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICclJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZVxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBhID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSByZWZbMV07XG4gICAgICAgICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpICUgYi5ldmFsdWF0ZShjdHgpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnbG4yJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguTE4yO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAncGknOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2UnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5FO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnXic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGVcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciBlID0gcmVmWzFdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KGIuZXZhbHVhdGUoY3R4KSwgZS5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3NxcnQnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoeC5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2xvZzEwJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2cobi5ldmFsdWF0ZShjdHgpKSAvIE1hdGguTE4xMDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2xuJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2cobi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2xvZzInOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpIC8gTWF0aC5MTjI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdzaW4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbihuLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnY29zJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jb3Mobi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3Rhbic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBuID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgudGFuKG4uZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdhc2luJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hc2luKG4uZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdhY29zJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hY29zKG4uZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdhdGFuJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuKG4uZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdtaW4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIHZhcmFyZ3MoTnVtYmVyVHlwZSksXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnbWF4JzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2Ficyc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBuID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG4uZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdyb3VuZCc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBuID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIHYgPSBuLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gdiA8IDAgPyAtTWF0aC5yb3VuZCgtdikgOiBNYXRoLnJvdW5kKHYpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmxvb3InOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG4uZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdjZWlsJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG4uZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItPT0nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJldHVybiBjdHgucHJvcGVydGllcygpW2sudmFsdWVdID09PSB2LnZhbHVlO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLT09JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1ZhbHVlVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gY3R4LmlkKCkgPT09IHYudmFsdWU7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItdHlwZS09PSc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtTdHJpbmdUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBjdHguZ2VvbWV0cnlUeXBlKCkgPT09IHYudmFsdWU7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItPCc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBWYWx1ZVR5cGVcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgayA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzFdO1xuICAgICAgICAgICAgdmFyIGEgPSBjdHgucHJvcGVydGllcygpW2sudmFsdWVdO1xuICAgICAgICAgICAgdmFyIGIgPSB2LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDwgYjtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1pZC08JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1ZhbHVlVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgYSA9IGN0eC5pZCgpO1xuICAgICAgICAgICAgdmFyIGIgPSB2LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDwgYjtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci0+JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBrID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07XG4gICAgICAgICAgICB2YXIgYSA9IGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV07XG4gICAgICAgICAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPiBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLT4nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciBhID0gY3R4LmlkKCk7XG4gICAgICAgICAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPiBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLTw9JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBrID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07XG4gICAgICAgICAgICB2YXIgYSA9IGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV07XG4gICAgICAgICAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPD0gYjtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1pZC08PSc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtWYWx1ZVR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIGEgPSBjdHguaWQoKTtcbiAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA8PSBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLT49JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBrID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07XG4gICAgICAgICAgICB2YXIgYSA9IGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV07XG4gICAgICAgICAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPj0gYjtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1pZC0+PSc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtWYWx1ZVR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIGEgPSBjdHguaWQoKTtcbiAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+PSBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWhhcyc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtWYWx1ZVR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBrID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGsudmFsdWUgaW4gY3R4LnByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1oYXMtaWQnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5pZCgpICE9PSBudWxsICYmIGN0eC5pZCgpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItdHlwZS1pbic6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFthcnJheShTdHJpbmdUeXBlKV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gdi52YWx1ZS5pbmRleE9mKGN0eC5nZW9tZXRyeVR5cGUoKSkgPj0gMDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1pZC1pbic6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFthcnJheShWYWx1ZVR5cGUpXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiB2LnZhbHVlLmluZGV4T2YoY3R4LmlkKCkpID49IDA7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItaW4tc21hbGwnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgYXJyYXkoVmFsdWVUeXBlKVxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBrID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07XG4gICAgICAgICAgICByZXR1cm4gdi52YWx1ZS5pbmRleE9mKGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0pID49IDA7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItaW4tbGFyZ2UnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgYXJyYXkoVmFsdWVUeXBlKVxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBrID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07XG4gICAgICAgICAgICByZXR1cm4gYmluYXJ5U2VhcmNoKGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0sIHYudmFsdWUsIDAsIHYudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdhbGwnOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5UeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICAgICAgICAgICAgICBCb29sZWFuVHlwZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gcmVmWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZXZhbHVhdGUoY3R4KSAmJiBiLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB2YXJhcmdzKEJvb2xlYW5UeXBlKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gYXJnczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmcuZXZhbHVhdGUoY3R4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIF1cbiAgICB9LFxuICAgICdhbnknOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5UeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICAgICAgICAgICAgICBCb29sZWFuVHlwZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gcmVmWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZXZhbHVhdGUoY3R4KSB8fCBiLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB2YXJhcmdzKEJvb2xlYW5UeXBlKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gYXJnczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5ldmFsdWF0ZShjdHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJyEnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbQm9vbGVhblR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBiID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuICFiLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdpcy1zdXBwb3J0ZWQtc2NyaXB0JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBzID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIGlzU3VwcG9ydGVkU2NyaXB0ID0gY3R4Lmdsb2JhbHMgJiYgY3R4Lmdsb2JhbHMuaXNTdXBwb3J0ZWRTY3JpcHQ7XG4gICAgICAgICAgICBpZiAoaXNTdXBwb3J0ZWRTY3JpcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTdXBwb3J0ZWRTY3JpcHQocy5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAndXBjYXNlJzogW1xuICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHMgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gcy5ldmFsdWF0ZShjdHgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdkb3duY2FzZSc6IFtcbiAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBzID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHMuZXZhbHVhdGUoY3R4KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnY29uY2F0JzogW1xuICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICB2YXJhcmdzKFZhbHVlVHlwZSksXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nJDEoYXJnLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdyZXNvbHZlZC1sb2NhbGUnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtDb2xsYXRvclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBjb2xsYXRvciA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsYXRvci5ldmFsdWF0ZShjdHgpLnJlc29sdmVkTG9jYWxlKCk7XG4gICAgICAgIH1cbiAgICBdXG59KTtcblxuZnVuY3Rpb24gc3VjY2Vzcyh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogJ3N1Y2Nlc3MnLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6ICdlcnJvcicsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKHNwZWMpIHtcbiAgICByZXR1cm4gc3BlY1sncHJvcGVydHktdHlwZSddID09PSAnZGF0YS1kcml2ZW4nIHx8IHNwZWNbJ3Byb3BlcnR5LXR5cGUnXSA9PT0gJ2Nyb3NzLWZhZGVkLWRhdGEtZHJpdmVuJztcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzWm9vbUV4cHJlc3Npb24oc3BlYykge1xuICAgIHJldHVybiAhIXNwZWMuZXhwcmVzc2lvbiAmJiBzcGVjLmV4cHJlc3Npb24ucGFyYW1ldGVycy5pbmRleE9mKCd6b29tJykgPiAtMTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJwb2xhdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuICEhc3BlYy5leHByZXNzaW9uICYmIHNwZWMuZXhwcmVzc2lvbi5pbnRlcnBvbGF0ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldFR5cGUodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uJDEodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykge1xuICAgIHZhciBpc0NvbG9yID0gcHJvcGVydHlTcGVjLnR5cGUgPT09ICdjb2xvcic7XG4gICAgdmFyIHpvb21BbmRGZWF0dXJlRGVwZW5kZW50ID0gcGFyYW1ldGVycy5zdG9wcyAmJiB0eXBlb2YgcGFyYW1ldGVycy5zdG9wc1swXVswXSA9PT0gJ29iamVjdCc7XG4gICAgdmFyIGZlYXR1cmVEZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCBwYXJhbWV0ZXJzLnByb3BlcnR5ICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHpvb21EZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCAhZmVhdHVyZURlcGVuZGVudDtcbiAgICB2YXIgdHlwZSA9IHBhcmFtZXRlcnMudHlwZSB8fCAoc3VwcG9ydHNJbnRlcnBvbGF0aW9uKHByb3BlcnR5U3BlYykgPyAnZXhwb25lbnRpYWwnIDogJ2ludGVydmFsJyk7XG4gICAgaWYgKGlzQ29sb3IpIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IGV4dGVuZCh7fSwgcGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnN0b3BzKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnN0b3BzID0gcGFyYW1ldGVycy5zdG9wcy5tYXAoZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBzdG9wWzBdLFxuICAgICAgICAgICAgICAgICAgICBDb2xvci5wYXJzZShzdG9wWzFdKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1ldGVycy5kZWZhdWx0KSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmRlZmF1bHQgPSBDb2xvci5wYXJzZShwYXJhbWV0ZXJzLmRlZmF1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5kZWZhdWx0ID0gQ29sb3IucGFyc2UocHJvcGVydHlTcGVjLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgJiYgcGFyYW1ldGVycy5jb2xvclNwYWNlICE9PSAncmdiJyAmJiAhY29sb3JTcGFjZXNbcGFyYW1ldGVycy5jb2xvclNwYWNlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29sb3Igc3BhY2U6ICcgKyBwYXJhbWV0ZXJzLmNvbG9yU3BhY2UpO1xuICAgIH1cbiAgICB2YXIgaW5uZXJGdW47XG4gICAgdmFyIGhhc2hlZFN0b3BzO1xuICAgIHZhciBjYXRlZ29yaWNhbEtleVR5cGU7XG4gICAgaWYgKHR5cGUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUV4cG9uZW50aWFsRnVuY3Rpb247XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnKSB7XG4gICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVJbnRlcnZhbEZ1bmN0aW9uO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NhdGVnb3JpY2FsJykge1xuICAgICAgICBpbm5lckZ1biA9IGV2YWx1YXRlQ2F0ZWdvcmljYWxGdW5jdGlvbjtcbiAgICAgICAgaGFzaGVkU3RvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhcmFtZXRlcnMuc3RvcHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IGxpc3RbaV07XG4gICAgICAgICAgICBoYXNoZWRTdG9wc1tzdG9wWzBdXSA9IHN0b3BbMV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0ZWdvcmljYWxLZXlUeXBlID0gdHlwZW9mIHBhcmFtZXRlcnMuc3RvcHNbMF1bMF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVJZGVudGl0eUZ1bmN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmdW5jdGlvbiB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcbiAgICB9XG4gICAgaWYgKHpvb21BbmRGZWF0dXJlRGVwZW5kZW50KSB7XG4gICAgICAgIHZhciBmZWF0dXJlRnVuY3Rpb25zID0ge307XG4gICAgICAgIHZhciB6b29tU3RvcHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCQxID0gcGFyYW1ldGVycy5zdG9wc1tzXTtcbiAgICAgICAgICAgIHZhciB6b29tID0gc3RvcCQxWzBdLnpvb207XG4gICAgICAgICAgICBpZiAoZmVhdHVyZUZ1bmN0aW9uc1t6b29tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uc1t6b29tXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcGFyYW1ldGVycy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyYW1ldGVycy5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcGFyYW1ldGVycy5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBzdG9wczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHpvb21TdG9wcy5wdXNoKHpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uc1t6b29tXS5zdG9wcy5wdXNoKFtcbiAgICAgICAgICAgICAgICBzdG9wJDFbMF0udmFsdWUsXG4gICAgICAgICAgICAgICAgc3RvcCQxWzFdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmVhdHVyZUZ1bmN0aW9uU3RvcHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gem9vbVN0b3BzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHogPSBsaXN0JDFbaSQxXTtcbiAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvblN0b3BzLnB1c2goW1xuICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbel0uem9vbSxcbiAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25zW3pdLCBwcm9wZXJ0eVNwZWMpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJwb2xhdGlvblR5cGUgPSB7IG5hbWU6ICdsaW5lYXInIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAnY29tcG9zaXRlJyxcbiAgICAgICAgICAgIGludGVycG9sYXRpb25UeXBlOiBpbnRlcnBvbGF0aW9uVHlwZSxcbiAgICAgICAgICAgIGludGVycG9sYXRpb25GYWN0b3I6IEludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IuYmluZCh1bmRlZmluZWQsIGludGVycG9sYXRpb25UeXBlKSxcbiAgICAgICAgICAgIHpvb21TdG9wczogZmVhdHVyZUZ1bmN0aW9uU3RvcHMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNbMF07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZShyZWYsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgem9vbSA9IHJlZi56b29tO1xuICAgICAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZUV4cG9uZW50aWFsRnVuY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBzdG9wczogZmVhdHVyZUZ1bmN0aW9uU3RvcHMsXG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IHBhcmFtZXRlcnMuYmFzZVxuICAgICAgICAgICAgICAgIH0sIHByb3BlcnR5U3BlYywgem9vbSkuZXZhbHVhdGUoem9vbSwgcHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh6b29tRGVwZW5kZW50KSB7XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uVHlwZSQxID0gdHlwZSA9PT0gJ2V4cG9uZW50aWFsJyA/IHtcbiAgICAgICAgICAgIG5hbWU6ICdleHBvbmVudGlhbCcsXG4gICAgICAgICAgICBiYXNlOiBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDFcbiAgICAgICAgfSA6IG51bGw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAnY2FtZXJhJyxcbiAgICAgICAgICAgIGludGVycG9sYXRpb25UeXBlOiBpbnRlcnBvbGF0aW9uVHlwZSQxLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkZhY3RvcjogSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvci5iaW5kKHVuZGVmaW5lZCwgaW50ZXJwb2xhdGlvblR5cGUkMSksXG4gICAgICAgICAgICB6b29tU3RvcHM6IHBhcmFtZXRlcnMuc3RvcHMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNbMF07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIHpvb20gPSByZWYuem9vbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJGdW4ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCB6b29tLCBoYXNoZWRTdG9wcywgY2F0ZWdvcmljYWxLZXlUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2luZDogJ3NvdXJjZScsXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUoXywgZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZlYXR1cmUgJiYgZmVhdHVyZS5wcm9wZXJ0aWVzID8gZmVhdHVyZS5wcm9wZXJ0aWVzW3BhcmFtZXRlcnMucHJvcGVydHldIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2FsZXNjZShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyRnVuKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgdmFsdWUsIGhhc2hlZFN0b3BzLCBjYXRlZ29yaWNhbEtleVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvYWxlc2NlKGEsIGIsIGMpIHtcbiAgICBpZiAoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV2YWx1YXRlQ2F0ZWdvcmljYWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0LCBoYXNoZWRTdG9wcywga2V5VHlwZSkge1xuICAgIHZhciBldmFsdWF0ZWQgPSB0eXBlb2YgaW5wdXQgPT09IGtleVR5cGUgPyBoYXNoZWRTdG9wc1tpbnB1dF0gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGNvYWxlc2NlKGV2YWx1YXRlZCwgcGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZUludGVydmFsRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBpbnB1dCkge1xuICAgIGlmIChnZXRUeXBlKGlucHV0KSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGNvYWxlc2NlKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xuICAgIH1cbiAgICB2YXIgbiA9IHBhcmFtZXRlcnMuc3RvcHMubGVuZ3RoO1xuICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPD0gcGFyYW1ldGVycy5zdG9wc1swXVswXSkge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1swXVsxXTtcbiAgICB9XG4gICAgaWYgKGlucHV0ID49IHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzBdKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVsxXTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhwYXJhbWV0ZXJzLnN0b3BzLm1hcChmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICByZXR1cm4gc3RvcFswXTtcbiAgICB9KSwgaW5wdXQpO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVsxXTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0KSB7XG4gICAgdmFyIGJhc2UgPSBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDE7XG4gICAgaWYgKGdldFR5cGUoaW5wdXQpICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gY29hbGVzY2UocGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG4gICAgfVxuICAgIHZhciBuID0gcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7XG4gICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07XG4gICAgfVxuICAgIGlmIChpbnB1dCA8PSBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPj0gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMF0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzFdO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHBhcmFtZXRlcnMuc3RvcHMubWFwKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgIHJldHVybiBzdG9wWzBdO1xuICAgIH0pLCBpbnB1dCk7XG4gICAgdmFyIHQgPSBpbnRlcnBvbGF0aW9uRmFjdG9yKGlucHV0LCBiYXNlLCBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVswXSwgcGFyYW1ldGVycy5zdG9wc1tpbmRleCArIDFdWzBdKTtcbiAgICB2YXIgb3V0cHV0TG93ZXIgPSBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVsxXTtcbiAgICB2YXIgb3V0cHV0VXBwZXIgPSBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4ICsgMV1bMV07XG4gICAgdmFyIGludGVycCA9IGludGVycG9sYXRlW3Byb3BlcnR5U3BlYy50eXBlXSB8fCBpZGVudGl0eUZ1bmN0aW9uO1xuICAgIGlmIChwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgJiYgcGFyYW1ldGVycy5jb2xvclNwYWNlICE9PSAncmdiJykge1xuICAgICAgICB2YXIgY29sb3JzcGFjZSA9IGNvbG9yU3BhY2VzW3BhcmFtZXRlcnMuY29sb3JTcGFjZV07XG4gICAgICAgIGludGVycCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3JzcGFjZS5yZXZlcnNlKGNvbG9yc3BhY2UuaW50ZXJwb2xhdGUoY29sb3JzcGFjZS5mb3J3YXJkKGEpLCBjb2xvcnNwYWNlLmZvcndhcmQoYiksIHQpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRwdXRMb3dlci5ldmFsdWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIGV2YWx1YXRlKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxlbi0tKVxuICAgICAgICAgICAgICAgICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICAgICAgICAgICAgICB2YXIgZXZhbHVhdGVkTG93ZXIgPSBvdXRwdXRMb3dlci5ldmFsdWF0ZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBldmFsdWF0ZWRVcHBlciA9IG91dHB1dFVwcGVyLmV2YWx1YXRlLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKGV2YWx1YXRlZExvd2VyID09PSB1bmRlZmluZWQgfHwgZXZhbHVhdGVkVXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwKGV2YWx1YXRlZExvd2VyLCBldmFsdWF0ZWRVcHBlciwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnAob3V0cHV0TG93ZXIsIG91dHB1dFVwcGVyLCB0KTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlSWRlbnRpdHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0KSB7XG4gICAgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnY29sb3InKSB7XG4gICAgICAgIGlucHV0ID0gQ29sb3IucGFyc2UoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdmb3JtYXR0ZWQnKSB7XG4gICAgICAgIGlucHV0ID0gRm9ybWF0dGVkLmZyb21TdHJpbmcoaW5wdXQudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSB7XG4gICAgICAgIGlucHV0ID0gUmVzb2x2ZWRJbWFnZS5mcm9tU3RyaW5nKGlucHV0LnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSBpZiAoZ2V0VHlwZShpbnB1dCkgIT09IHByb3BlcnR5U3BlYy50eXBlICYmIChwcm9wZXJ0eVNwZWMudHlwZSAhPT0gJ2VudW0nIHx8ICFwcm9wZXJ0eVNwZWMudmFsdWVzW2lucHV0XSkpIHtcbiAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjb2FsZXNjZShpbnB1dCwgcGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0aW9uRmFjdG9yKGlucHV0LCBiYXNlLCBsb3dlclZhbHVlLCB1cHBlclZhbHVlKSB7XG4gICAgdmFyIGRpZmZlcmVuY2UgPSB1cHBlclZhbHVlIC0gbG93ZXJWYWx1ZTtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBpbnB1dCAtIGxvd2VyVmFsdWU7XG4gICAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChiYXNlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwcm9ncmVzcyAvIGRpZmZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyhiYXNlLCBwcm9ncmVzcykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCBkaWZmZXJlbmNlKSAtIDEpO1xuICAgIH1cbn1cblxudmFyIFN0eWxlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIFN0eWxlRXhwcmVzc2lvbihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHRoaXMuX3dhcm5pbmdIaXN0b3J5ID0ge307XG4gICAgdGhpcy5fZXZhbHVhdG9yID0gbmV3IEV2YWx1YXRpb25Db250ZXh0KCk7XG4gICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gcHJvcGVydHlTcGVjID8gZ2V0RGVmYXVsdFZhbHVlKHByb3BlcnR5U3BlYykgOiBudWxsO1xuICAgIHRoaXMuX2VudW1WYWx1ZXMgPSBwcm9wZXJ0eVNwZWMgJiYgcHJvcGVydHlTcGVjLnR5cGUgPT09ICdlbnVtJyA/IHByb3BlcnR5U3BlYy52YWx1ZXMgOiBudWxsO1xufTtcblN0eWxlRXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyA9IGZ1bmN0aW9uIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgIHRoaXMuX2V2YWx1YXRvci5nbG9iYWxzID0gZ2xvYmFscztcbiAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IGZlYXR1cmVTdGF0ZTtcbiAgICB0aGlzLl9ldmFsdWF0b3IuY2Fub25pY2FsID0gY2Fub25pY2FsO1xuICAgIHRoaXMuX2V2YWx1YXRvci5hdmFpbGFibGVJbWFnZXMgPSBhdmFpbGFibGVJbWFnZXMgfHwgbnVsbDtcbiAgICB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGZvcm1hdHRlZFNlY3Rpb247XG4gICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSh0aGlzLl9ldmFsdWF0b3IpO1xufTtcblN0eWxlRXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmdsb2JhbHMgPSBnbG9iYWxzO1xuICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gZmVhdHVyZSB8fCBudWxsO1xuICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlU3RhdGUgPSBmZWF0dXJlU3RhdGUgfHwgbnVsbDtcbiAgICB0aGlzLl9ldmFsdWF0b3IuY2Fub25pY2FsID0gY2Fub25pY2FsO1xuICAgIHRoaXMuX2V2YWx1YXRvci5hdmFpbGFibGVJbWFnZXMgPSBhdmFpbGFibGVJbWFnZXMgfHwgbnVsbDtcbiAgICB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGZvcm1hdHRlZFNlY3Rpb24gfHwgbnVsbDtcbiAgICB0cnkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHRoaXMuX2V2YWx1YXRvcik7XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgdmFsICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2VudW1WYWx1ZXMgJiYgISh2YWwgaW4gdGhpcy5fZW51bVZhbHVlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIHZhbHVlIHRvIGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXModGhpcy5fZW51bVZhbHVlcykubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICAgICAgfSkuam9pbignLCAnKSArICcsIGJ1dCBmb3VuZCAnICsgSlNPTi5zdHJpbmdpZnkodmFsKSArICcgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93YXJuaW5nSGlzdG9yeVtlLm1lc3NhZ2VdKSB7XG4gICAgICAgICAgICB0aGlzLl93YXJuaW5nSGlzdG9yeVtlLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFZhbHVlO1xuICAgIH1cbn07XG5mdW5jdGlvbiBpc0V4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGV4cHJlc3Npb24pICYmIGV4cHJlc3Npb24ubGVuZ3RoID4gMCAmJiB0eXBlb2YgZXhwcmVzc2lvblswXSA9PT0gJ3N0cmluZycgJiYgZXhwcmVzc2lvblswXSBpbiBleHByZXNzaW9ucztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzaW5nQ29udGV4dChleHByZXNzaW9ucywgW10sIHByb3BlcnR5U3BlYyA/IGdldEV4cGVjdGVkVHlwZShwcm9wZXJ0eVNwZWMpIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlKGV4cHJlc3Npb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5U3BlYyAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ3N0cmluZycgPyB7IHR5cGVBbm5vdGF0aW9uOiAnY29lcmNlJyB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICByZXR1cm4gZXJyb3IocGFyc2VyLmVycm9ycyk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKG5ldyBTdHlsZUV4cHJlc3Npb24ocGFyc2VkLCBwcm9wZXJ0eVNwZWMpKTtcbn1cbnZhciBab29tQ29uc3RhbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gWm9vbUNvbnN0YW50RXhwcmVzc2lvbihraW5kLCBleHByZXNzaW9uKSB7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLl9zdHlsZUV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IGtpbmQgIT09ICdjb25zdGFudCcgJiYgIWlzU3RhdGVDb25zdGFudChleHByZXNzaW9uLmV4cHJlc3Npb24pO1xufTtcblpvb21Db25zdGFudEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcgPSBmdW5jdGlvbiBldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7XG59O1xuWm9vbUNvbnN0YW50RXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTtcbn07XG52YXIgWm9vbURlcGVuZGVudEV4cHJlc3Npb24gPSBmdW5jdGlvbiBab29tRGVwZW5kZW50RXhwcmVzc2lvbihraW5kLCBleHByZXNzaW9uLCB6b29tU3RvcHMsIGludGVycG9sYXRpb25UeXBlKSB7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLnpvb21TdG9wcyA9IHpvb21TdG9wcztcbiAgICB0aGlzLl9zdHlsZUV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IGtpbmQgIT09ICdjYW1lcmEnICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbi5leHByZXNzaW9uKTtcbiAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID0gaW50ZXJwb2xhdGlvblR5cGU7XG59O1xuWm9vbURlcGVuZGVudEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcgPSBmdW5jdGlvbiBldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7XG59O1xuWm9vbURlcGVuZGVudEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGUoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7XG59O1xuWm9vbURlcGVuZGVudEV4cHJlc3Npb24ucHJvdG90eXBlLmludGVycG9sYXRpb25GYWN0b3IgPSBmdW5jdGlvbiBpbnRlcnBvbGF0aW9uRmFjdG9yKGlucHV0LCBsb3dlciwgdXBwZXIpIHtcbiAgICBpZiAodGhpcy5pbnRlcnBvbGF0aW9uVHlwZSkge1xuICAgICAgICByZXR1cm4gSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvcih0aGlzLmludGVycG9sYXRpb25UeXBlLCBpbnB1dCwgbG93ZXIsIHVwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uKGV4cHJlc3Npb24sIHByb3BlcnR5U3BlYykge1xuICAgIGV4cHJlc3Npb24gPSBjcmVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHByb3BlcnR5U3BlYyk7XG4gICAgaWYgKGV4cHJlc3Npb24ucmVzdWx0ID09PSAnZXJyb3InKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cbiAgICB2YXIgcGFyc2VkID0gZXhwcmVzc2lvbi52YWx1ZS5leHByZXNzaW9uO1xuICAgIHZhciBpc0ZlYXR1cmVDb25zdGFudCQxID0gaXNGZWF0dXJlQ29uc3RhbnQocGFyc2VkKTtcbiAgICBpZiAoIWlzRmVhdHVyZUNvbnN0YW50JDEgJiYgIXN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKHByb3BlcnR5U3BlYykpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFtuZXcgUGFyc2luZ0Vycm9yKCcnLCAnZGF0YSBleHByZXNzaW9ucyBub3Qgc3VwcG9ydGVkJyldKTtcbiAgICB9XG4gICAgdmFyIGlzWm9vbUNvbnN0YW50ID0gaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KHBhcnNlZCwgWyd6b29tJ10pO1xuICAgIGlmICghaXNab29tQ29uc3RhbnQgJiYgIXN1cHBvcnRzWm9vbUV4cHJlc3Npb24ocHJvcGVydHlTcGVjKSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoW25ldyBQYXJzaW5nRXJyb3IoJycsICd6b29tIGV4cHJlc3Npb25zIG5vdCBzdXBwb3J0ZWQnKV0pO1xuICAgIH1cbiAgICB2YXIgem9vbUN1cnZlID0gZmluZFpvb21DdXJ2ZShwYXJzZWQpO1xuICAgIGlmICghem9vbUN1cnZlICYmICFpc1pvb21Db25zdGFudCkge1xuICAgICAgICByZXR1cm4gZXJyb3IoW25ldyBQYXJzaW5nRXJyb3IoJycsICdcInpvb21cIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgXCJzdGVwXCIgb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb24uJyldKTtcbiAgICB9IGVsc2UgaWYgKHpvb21DdXJ2ZSBpbnN0YW5jZW9mIFBhcnNpbmdFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IoW3pvb21DdXJ2ZV0pO1xuICAgIH0gZWxzZSBpZiAoem9vbUN1cnZlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGUgJiYgIXN1cHBvcnRzSW50ZXJwb2xhdGlvbihwcm9wZXJ0eVNwZWMpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ1wiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBjYW5ub3QgYmUgdXNlZCB3aXRoIHRoaXMgcHJvcGVydHknKV0pO1xuICAgIH1cbiAgICBpZiAoIXpvb21DdXJ2ZSkge1xuICAgICAgICByZXR1cm4gc3VjY2Vzcyhpc0ZlYXR1cmVDb25zdGFudCQxID8gbmV3IFpvb21Db25zdGFudEV4cHJlc3Npb24oJ2NvbnN0YW50JywgZXhwcmVzc2lvbi52YWx1ZSkgOiBuZXcgWm9vbUNvbnN0YW50RXhwcmVzc2lvbignc291cmNlJywgZXhwcmVzc2lvbi52YWx1ZSkpO1xuICAgIH1cbiAgICB2YXIgaW50ZXJwb2xhdGlvblR5cGUgPSB6b29tQ3VydmUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0ZSA/IHpvb21DdXJ2ZS5pbnRlcnBvbGF0aW9uIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdWNjZXNzKGlzRmVhdHVyZUNvbnN0YW50JDEgPyBuZXcgWm9vbURlcGVuZGVudEV4cHJlc3Npb24oJ2NhbWVyYScsIGV4cHJlc3Npb24udmFsdWUsIHpvb21DdXJ2ZS5sYWJlbHMsIGludGVycG9sYXRpb25UeXBlKSA6IG5ldyBab29tRGVwZW5kZW50RXhwcmVzc2lvbignY29tcG9zaXRlJywgZXhwcmVzc2lvbi52YWx1ZSwgem9vbUN1cnZlLmxhYmVscywgaW50ZXJwb2xhdGlvblR5cGUpKTtcbn1cbnZhciBTdHlsZVByb3BlcnR5RnVuY3Rpb24gPSBmdW5jdGlvbiBTdHlsZVByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgc3BlY2lmaWNhdGlvbikge1xuICAgIHRoaXMuX3BhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgIHRoaXMuX3NwZWNpZmljYXRpb24gPSBzcGVjaWZpY2F0aW9uO1xuICAgIGV4dGVuZCh0aGlzLCBjcmVhdGVGdW5jdGlvbih0aGlzLl9wYXJhbWV0ZXJzLCB0aGlzLl9zcGVjaWZpY2F0aW9uKSk7XG59O1xuU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIHJldHVybiBuZXcgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uKHNlcmlhbGl6ZWQuX3BhcmFtZXRlcnMsIHNlcmlhbGl6ZWQuX3NwZWNpZmljYXRpb24pO1xufTtcblN0eWxlUHJvcGVydHlGdW5jdGlvbi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfcGFyYW1ldGVyczogaW5wdXQuX3BhcmFtZXRlcnMsXG4gICAgICAgIF9zcGVjaWZpY2F0aW9uOiBpbnB1dC5fc3BlY2lmaWNhdGlvblxuICAgIH07XG59O1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydHlFeHByZXNzaW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24kMSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHlsZVByb3BlcnR5RnVuY3Rpb24odmFsdWUsIHNwZWNpZmljYXRpb24pO1xuICAgIH0gZWxzZSBpZiAoaXNFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbih2YWx1ZSwgc3BlY2lmaWNhdGlvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uLnJlc3VsdCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cHJlc3Npb24udmFsdWUubWFwKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyLmtleSArICc6ICcgKyBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgIH0pLmpvaW4oJywgJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb25zdGFudCA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBzcGVjaWZpY2F0aW9uLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgIGNvbnN0YW50ID0gQ29sb3IucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAnY29uc3RhbnQnLFxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZFpvb21DdXJ2ZShleHByZXNzaW9uKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBMZXQpIHtcbiAgICAgICAgcmVzdWx0ID0gZmluZFpvb21DdXJ2ZShleHByZXNzaW9uLnJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQ29hbGVzY2UpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByZXNzaW9uLmFyZ3M7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZpbmRab29tQ3VydmUoYXJnKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBTdGVwIHx8IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBJbnRlcnBvbGF0ZSkgJiYgZXhwcmVzc2lvbi5pbnB1dCBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbiAmJiBleHByZXNzaW9uLmlucHV0Lm5hbWUgPT09ICd6b29tJykge1xuICAgICAgICByZXN1bHQgPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGV4cHJlc3Npb24uZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRSZXN1bHQgPSBmaW5kWm9vbUN1cnZlKGNoaWxkKTtcbiAgICAgICAgaWYgKGNoaWxkUmVzdWx0IGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjaGlsZFJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmICghcmVzdWx0ICYmIGNoaWxkUmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgUGFyc2luZ0Vycm9yKCcnLCAnXCJ6b29tXCIgZXhwcmVzc2lvbiBtYXkgb25seSBiZSB1c2VkIGFzIGlucHV0IHRvIGEgdG9wLWxldmVsIFwic3RlcFwiIG9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9uLicpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAmJiBjaGlsZFJlc3VsdCAmJiByZXN1bHQgIT09IGNoaWxkUmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgUGFyc2luZ0Vycm9yKCcnLCAnT25seSBvbmUgem9vbS1iYXNlZCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgc3ViZXhwcmVzc2lvbiBtYXkgYmUgdXNlZCBpbiBhbiBleHByZXNzaW9uLicpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEV4cGVjdGVkVHlwZShzcGVjKSB7XG4gICAgdmFyIHR5cGVzID0ge1xuICAgICAgICBjb2xvcjogQ29sb3JUeXBlLFxuICAgICAgICBzdHJpbmc6IFN0cmluZ1R5cGUsXG4gICAgICAgIG51bWJlcjogTnVtYmVyVHlwZSxcbiAgICAgICAgZW51bTogU3RyaW5nVHlwZSxcbiAgICAgICAgYm9vbGVhbjogQm9vbGVhblR5cGUsXG4gICAgICAgIGZvcm1hdHRlZDogRm9ybWF0dGVkVHlwZSxcbiAgICAgICAgcmVzb2x2ZWRJbWFnZTogUmVzb2x2ZWRJbWFnZVR5cGVcbiAgICB9O1xuICAgIGlmIChzcGVjLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5KHR5cGVzW3NwZWMudmFsdWVdIHx8IFZhbHVlVHlwZSwgc3BlYy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZXNbc3BlYy50eXBlXTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRWYWx1ZShzcGVjKSB7XG4gICAgaWYgKHNwZWMudHlwZSA9PT0gJ2NvbG9yJyAmJiBpc0Z1bmN0aW9uJDEoc3BlYy5kZWZhdWx0KSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuICAgIH0gZWxzZSBpZiAoc3BlYy50eXBlID09PSAnY29sb3InKSB7XG4gICAgICAgIHJldHVybiBDb2xvci5wYXJzZShzcGVjLmRlZmF1bHQpIHx8IG51bGw7XG4gICAgfSBlbHNlIGlmIChzcGVjLmRlZmF1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3BlYy5kZWZhdWx0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29udmVydExpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IFtcbiAgICAgICAgJ2xpdGVyYWwnLFxuICAgICAgICB2YWx1ZVxuICAgIF0gOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICB2YXIgc3RvcHMgPSBwYXJhbWV0ZXJzLnN0b3BzO1xuICAgIGlmICghc3RvcHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRJZGVudGl0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYyk7XG4gICAgfVxuICAgIHZhciB6b29tQW5kRmVhdHVyZURlcGVuZGVudCA9IHN0b3BzICYmIHR5cGVvZiBzdG9wc1swXVswXSA9PT0gJ29iamVjdCc7XG4gICAgdmFyIGZlYXR1cmVEZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCBwYXJhbWV0ZXJzLnByb3BlcnR5ICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHpvb21EZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCAhZmVhdHVyZURlcGVuZGVudDtcbiAgICBzdG9wcyA9IHN0b3BzLm1hcChmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICBpZiAoIWZlYXR1cmVEZXBlbmRlbnQgJiYgcHJvcGVydHlTcGVjLnRva2VucyAmJiB0eXBlb2Ygc3RvcFsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc3RvcFswXSxcbiAgICAgICAgICAgICAgICBjb252ZXJ0VG9rZW5TdHJpbmcoc3RvcFsxXSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHN0b3BbMF0sXG4gICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChzdG9wWzFdKVxuICAgICAgICBdO1xuICAgIH0pO1xuICAgIGlmICh6b29tQW5kRmVhdHVyZURlcGVuZGVudCkge1xuICAgICAgICByZXR1cm4gY29udmVydFpvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpO1xuICAgIH0gZWxzZSBpZiAoem9vbURlcGVuZGVudCkge1xuICAgICAgICByZXR1cm4gY29udmVydFpvb21GdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udmVydFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydElkZW50aXR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKSB7XG4gICAgdmFyIGdldCA9IFtcbiAgICAgICAgJ2dldCcsXG4gICAgICAgIHBhcmFtZXRlcnMucHJvcGVydHlcbiAgICBdO1xuICAgIGlmIChwYXJhbWV0ZXJzLmRlZmF1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlTcGVjLnR5cGUgPT09ICdzdHJpbmcnID8gW1xuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICBnZXRcbiAgICAgICAgXSA6IGdldDtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnZW51bScpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdtYXRjaCcsXG4gICAgICAgICAgICBnZXQsXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0eVNwZWMudmFsdWVzKSxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZGVmYXVsdFxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gW1xuICAgICAgICAgICAgcHJvcGVydHlTcGVjLnR5cGUgPT09ICdjb2xvcicgPyAndG8tY29sb3InIDogcHJvcGVydHlTcGVjLnR5cGUsXG4gICAgICAgICAgICBnZXQsXG4gICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpXG4gICAgICAgIF07XG4gICAgICAgIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbi5zcGxpY2UoMSwgMCwgcHJvcGVydHlTcGVjLnZhbHVlLCBwcm9wZXJ0eVNwZWMubGVuZ3RoIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycykge1xuICAgIHN3aXRjaCAocGFyYW1ldGVycy5jb2xvclNwYWNlKSB7XG4gICAgY2FzZSAnaGNsJzpcbiAgICAgICAgcmV0dXJuICdpbnRlcnBvbGF0ZS1oY2wnO1xuICAgIGNhc2UgJ2xhYic6XG4gICAgICAgIHJldHVybiAnaW50ZXJwb2xhdGUtbGFiJztcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ2ludGVycG9sYXRlJztcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcykge1xuICAgIHZhciBmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzID0ge307XG4gICAgdmFyIGZlYXR1cmVGdW5jdGlvblN0b3BzID0ge307XG4gICAgdmFyIHpvb21TdG9wcyA9IFtdO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc3RvcHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tzXTtcbiAgICAgICAgdmFyIHpvb20gPSBzdG9wWzBdLnpvb207XG4gICAgICAgIGlmIChmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3pvb21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnNbem9vbV0gPSB7XG4gICAgICAgICAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbWV0ZXJzLnR5cGUsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcmFtZXRlcnMucHJvcGVydHksXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcGFyYW1ldGVycy5kZWZhdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHNbem9vbV0gPSBbXTtcbiAgICAgICAgICAgIHpvb21TdG9wcy5wdXNoKHpvb20pO1xuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVGdW5jdGlvblN0b3BzW3pvb21dLnB1c2goW1xuICAgICAgICAgICAgc3RvcFswXS52YWx1ZSxcbiAgICAgICAgICAgIHN0b3BbMV1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHZhciBmdW5jdGlvblR5cGUgPSBnZXRGdW5jdGlvblR5cGUoe30sIHByb3BlcnR5U3BlYyk7XG4gICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IFtcbiAgICAgICAgICAgIGdldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycyksXG4gICAgICAgICAgICBbJ2xpbmVhciddLFxuICAgICAgICAgICAgWyd6b29tJ11cbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB6b29tU3RvcHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeiA9IGxpc3RbaV07XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gY29udmVydFByb3BlcnR5RnVuY3Rpb24oZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6XSwgcHJvcGVydHlTcGVjLCBmZWF0dXJlRnVuY3Rpb25TdG9wc1t6XSk7XG4gICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uLCB6LCBvdXRwdXQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiQxID0gW1xuICAgICAgICAgICAgJ3N0ZXAnLFxuICAgICAgICAgICAgWyd6b29tJ11cbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gem9vbVN0b3BzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHokMSA9IGxpc3QkMVtpJDFdO1xuICAgICAgICAgICAgdmFyIG91dHB1dCQxID0gY29udmVydFByb3BlcnR5RnVuY3Rpb24oZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6JDFdLCBwcm9wZXJ0eVNwZWMsIGZlYXR1cmVGdW5jdGlvblN0b3BzW3okMV0pO1xuICAgICAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiQxLCB6JDEsIG91dHB1dCQxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUoZXhwcmVzc2lvbiQxKTtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24kMTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb2FsZXNjZSQxKGEsIGIpIHtcbiAgICBpZiAoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpIHtcbiAgICB2YXIgdHlwZSA9IGdldEZ1bmN0aW9uVHlwZShwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpO1xuICAgIHZhciBnZXQgPSBbXG4gICAgICAgICdnZXQnLFxuICAgICAgICBwYXJhbWV0ZXJzLnByb3BlcnR5XG4gICAgXTtcbiAgICBpZiAodHlwZSA9PT0gJ2NhdGVnb3JpY2FsJyAmJiB0eXBlb2Ygc3RvcHNbMF1bMF0gPT09ICdib29sZWFuJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IFsnY2FzZSddO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0b3BzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHN0b3AgPSBsaXN0W2ldO1xuICAgICAgICAgICAgZXhwcmVzc2lvbi5wdXNoKFtcbiAgICAgICAgICAgICAgICAnPT0nLFxuICAgICAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgICAgICBzdG9wWzBdXG4gICAgICAgICAgICBdLCBzdG9wWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBleHByZXNzaW9uLnB1c2goY29udmVydExpdGVyYWwoY29hbGVzY2UkMShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KSkpO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjYXRlZ29yaWNhbCcpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24kMSA9IFtcbiAgICAgICAgICAgICdtYXRjaCcsXG4gICAgICAgICAgICBnZXRcbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gc3RvcHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCQxID0gbGlzdCQxW2kkMV07XG4gICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uJDEsIHN0b3AkMVswXSwgc3RvcCQxWzFdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwcmVzc2lvbiQxLnB1c2goY29udmVydExpdGVyYWwoY29hbGVzY2UkMShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KSkpO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbiQxO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiQyID0gW1xuICAgICAgICAgICAgJ3N0ZXAnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgICAgIGdldFxuICAgICAgICAgICAgXVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpJDIgPSAwLCBsaXN0JDIgPSBzdG9wczsgaSQyIDwgbGlzdCQyLmxlbmd0aDsgaSQyICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzdG9wJDIgPSBsaXN0JDJbaSQyXTtcbiAgICAgICAgICAgIGFwcGVuZFN0b3BQYWlyKGV4cHJlc3Npb24kMiwgc3RvcCQyWzBdLCBzdG9wJDJbMV0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShleHByZXNzaW9uJDIpO1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5kZWZhdWx0ID09PSB1bmRlZmluZWQgPyBleHByZXNzaW9uJDIgOiBbXG4gICAgICAgICAgICAnY2FzZScsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJz09JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICd0eXBlb2YnLFxuICAgICAgICAgICAgICAgICAgICBnZXRcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICdudW1iZXInXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbiQyLFxuICAgICAgICAgICAgY29udmVydExpdGVyYWwocGFyYW1ldGVycy5kZWZhdWx0KVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICB2YXIgYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24kMyA9IFtcbiAgICAgICAgICAgIGdldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycyksXG4gICAgICAgICAgICBiYXNlID09PSAxID8gWydsaW5lYXInXSA6IFtcbiAgICAgICAgICAgICAgICAnZXhwb25lbnRpYWwnLFxuICAgICAgICAgICAgICAgIGJhc2VcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAgICAgZ2V0XG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGkkMyA9IDAsIGxpc3QkMyA9IHN0b3BzOyBpJDMgPCBsaXN0JDMubGVuZ3RoOyBpJDMgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHN0b3AkMyA9IGxpc3QkM1tpJDNdO1xuICAgICAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiQzLCBzdG9wJDNbMF0sIHN0b3AkM1sxXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLmRlZmF1bHQgPT09IHVuZGVmaW5lZCA/IGV4cHJlc3Npb24kMyA6IFtcbiAgICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPT0nLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGVvZicsXG4gICAgICAgICAgICAgICAgICAgIGdldFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ251bWJlcidcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHByZXNzaW9uJDMsXG4gICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb3BlcnR5IGZ1bmN0aW9uIHR5cGUgJyArIHR5cGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRab29tRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcywgaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT09IHZvaWQgMClcbiAgICAgICAgaW5wdXQgPSBbJ3pvb20nXTtcbiAgICB2YXIgdHlwZSA9IGdldEZ1bmN0aW9uVHlwZShwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpO1xuICAgIHZhciBleHByZXNzaW9uO1xuICAgIHZhciBpc1N0ZXAgPSBmYWxzZTtcbiAgICBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykge1xuICAgICAgICBleHByZXNzaW9uID0gW1xuICAgICAgICAgICAgJ3N0ZXAnLFxuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgXTtcbiAgICAgICAgaXNTdGVwID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBbXG4gICAgICAgICAgICBnZXRJbnRlcnBvbGF0ZU9wZXJhdG9yKHBhcmFtZXRlcnMpLFxuICAgICAgICAgICAgYmFzZSA9PT0gMSA/IFsnbGluZWFyJ10gOiBbXG4gICAgICAgICAgICAgICAgJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgICAgICAgICBiYXNlXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gem9vbSBmdW5jdGlvbiB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdG9wczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHN0b3AgPSBsaXN0W2ldO1xuICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uLCBzdG9wWzBdLCBzdG9wWzFdLCBpc1N0ZXApO1xuICAgIH1cbiAgICBmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUoZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG59XG5mdW5jdGlvbiBmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUoZXhwcmVzc2lvbikge1xuICAgIGlmIChleHByZXNzaW9uWzBdID09PSAnc3RlcCcgJiYgZXhwcmVzc2lvbi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgZXhwcmVzc2lvbi5wdXNoKDApO1xuICAgICAgICBleHByZXNzaW9uLnB1c2goZXhwcmVzc2lvblszXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kU3RvcFBhaXIoY3VydmUsIGlucHV0LCBvdXRwdXQsIGlzU3RlcCkge1xuICAgIGlmIChjdXJ2ZS5sZW5ndGggPiAzICYmIGlucHV0ID09PSBjdXJ2ZVtjdXJ2ZS5sZW5ndGggLSAyXSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKGlzU3RlcCAmJiBjdXJ2ZS5sZW5ndGggPT09IDIpKSB7XG4gICAgICAgIGN1cnZlLnB1c2goaW5wdXQpO1xuICAgIH1cbiAgICBjdXJ2ZS5wdXNoKG91dHB1dCk7XG59XG5mdW5jdGlvbiBnZXRGdW5jdGlvblR5cGUocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKSB7XG4gICAgaWYgKHBhcmFtZXRlcnMudHlwZSkge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy50eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eVNwZWMuZXhwcmVzc2lvbi5pbnRlcnBvbGF0ZWQgPyAnZXhwb25lbnRpYWwnIDogJ2ludGVydmFsJztcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9rZW5TdHJpbmcocykge1xuICAgIHZhciByZXN1bHQgPSBbJ2NvbmNhdCddO1xuICAgIHZhciByZSA9IC97KFtee31dKyl9L2c7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgZm9yICh2YXIgbWF0Y2ggPSByZS5leGVjKHMpOyBtYXRjaCAhPT0gbnVsbDsgbWF0Y2ggPSByZS5leGVjKHMpKSB7XG4gICAgICAgIHZhciBsaXRlcmFsID0gcy5zbGljZShwb3MsIHJlLmxhc3RJbmRleCAtIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIHBvcyA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgaWYgKGxpdGVyYWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobGl0ZXJhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goW1xuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICBtYXRjaFsxXVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGlmIChwb3MgPCBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQucHVzaChzLnNsaWNlKHBvcykpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ3RvLXN0cmluZycsXG4gICAgICAgICAgICByZXN1bHRbMV1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNFeHByZXNzaW9uRmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIgPT09IHRydWUgfHwgZmlsdGVyID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcikgfHwgZmlsdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAoZmlsdGVyWzBdKSB7XG4gICAgY2FzZSAnaGFzJzpcbiAgICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggPj0gMiAmJiBmaWx0ZXJbMV0gIT09ICckaWQnICYmIGZpbHRlclsxXSAhPT0gJyR0eXBlJztcbiAgICBjYXNlICdpbic6XG4gICAgICAgIHJldHVybiBmaWx0ZXIubGVuZ3RoID49IDMgJiYgKHR5cGVvZiBmaWx0ZXJbMV0gIT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoZmlsdGVyWzJdKSk7XG4gICAgY2FzZSAnIWluJzpcbiAgICBjYXNlICchaGFzJzpcbiAgICBjYXNlICdub25lJzpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgJz09JzpcbiAgICBjYXNlICchPSc6XG4gICAgY2FzZSAnPic6XG4gICAgY2FzZSAnPj0nOlxuICAgIGNhc2UgJzwnOlxuICAgIGNhc2UgJzw9JzpcbiAgICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggIT09IDMgfHwgKEFycmF5LmlzQXJyYXkoZmlsdGVyWzFdKSB8fCBBcnJheS5pc0FycmF5KGZpbHRlclsyXSkpO1xuICAgIGNhc2UgJ2FueSc6XG4gICAgY2FzZSAnYWxsJzpcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBmaWx0ZXIuc2xpY2UoMSk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoIWlzRXhwcmVzc2lvbkZpbHRlcihmKSAmJiB0eXBlb2YgZiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbnZhciBmaWx0ZXJTcGVjID0ge1xuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2UsXG4gICAgJ3RyYW5zaXRpb24nOiBmYWxzZSxcbiAgICAncHJvcGVydHktdHlwZSc6ICdkYXRhLWRyaXZlbicsXG4gICAgJ2V4cHJlc3Npb24nOiB7XG4gICAgICAgICdpbnRlcnBvbGF0ZWQnOiBmYWxzZSxcbiAgICAgICAgJ3BhcmFtZXRlcnMnOiBbXG4gICAgICAgICAgICAnem9vbScsXG4gICAgICAgICAgICAnZmVhdHVyZSdcbiAgICAgICAgXVxuICAgIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciA9PT0gbnVsbCB8fCBmaWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmVlZEdlb21ldHJ5OiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWlzRXhwcmVzc2lvbkZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IGNvbnZlcnRGaWx0ZXIoZmlsdGVyKTtcbiAgICB9XG4gICAgdmFyIGNvbXBpbGVkID0gY3JlYXRlRXhwcmVzc2lvbihmaWx0ZXIsIGZpbHRlclNwZWMpO1xuICAgIGlmIChjb21waWxlZC5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXBpbGVkLnZhbHVlLm1hcChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyLmtleSArICc6ICcgKyBlcnIubWVzc2FnZTtcbiAgICAgICAgfSkuam9pbignLCAnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5lZWRHZW9tZXRyeSA9IEFycmF5LmlzQXJyYXkoZmlsdGVyKSAmJiBmaWx0ZXIubGVuZ3RoICE9PSAwICYmIGZpbHRlclswXSA9PT0gJ3dpdGhpbic7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIChnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlLCBjYW5vbmljYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZWQudmFsdWUuZXZhbHVhdGUoZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZSwge30sIGNhbm9uaWNhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmVlZEdlb21ldHJ5OiBuZWVkR2VvbWV0cnlcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG5mdW5jdGlvbiBjb252ZXJ0RmlsdGVyKGZpbHRlcikge1xuICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgb3AgPSBmaWx0ZXJbMF07XG4gICAgaWYgKGZpbHRlci5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gb3AgIT09ICdhbnknO1xuICAgIH1cbiAgICB2YXIgY29udmVydGVkID0gb3AgPT09ICc9PScgPyBjb252ZXJ0Q29tcGFyaXNvbk9wKGZpbHRlclsxXSwgZmlsdGVyWzJdLCAnPT0nKSA6IG9wID09PSAnIT0nID8gY29udmVydE5lZ2F0aW9uKGNvbnZlcnRDb21wYXJpc29uT3AoZmlsdGVyWzFdLCBmaWx0ZXJbMl0sICc9PScpKSA6IG9wID09PSAnPCcgfHwgb3AgPT09ICc+JyB8fCBvcCA9PT0gJzw9JyB8fCBvcCA9PT0gJz49JyA/IGNvbnZlcnRDb21wYXJpc29uT3AoZmlsdGVyWzFdLCBmaWx0ZXJbMl0sIG9wKSA6IG9wID09PSAnYW55JyA/IGNvbnZlcnREaXNqdW5jdGlvbk9wKGZpbHRlci5zbGljZSgxKSkgOiBvcCA9PT0gJ2FsbCcgPyBbJ2FsbCddLmNvbmNhdChmaWx0ZXIuc2xpY2UoMSkubWFwKGNvbnZlcnRGaWx0ZXIpKSA6IG9wID09PSAnbm9uZScgPyBbJ2FsbCddLmNvbmNhdChmaWx0ZXIuc2xpY2UoMSkubWFwKGNvbnZlcnRGaWx0ZXIpLm1hcChjb252ZXJ0TmVnYXRpb24pKSA6IG9wID09PSAnaW4nID8gY29udmVydEluT3AoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMikpIDogb3AgPT09ICchaW4nID8gY29udmVydE5lZ2F0aW9uKGNvbnZlcnRJbk9wKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpKSkgOiBvcCA9PT0gJ2hhcycgPyBjb252ZXJ0SGFzT3AoZmlsdGVyWzFdKSA6IG9wID09PSAnIWhhcycgPyBjb252ZXJ0TmVnYXRpb24oY29udmVydEhhc09wKGZpbHRlclsxXSkpIDogdHJ1ZTtcbiAgICByZXR1cm4gY29udmVydGVkO1xufVxuZnVuY3Rpb24gY29udmVydENvbXBhcmlzb25PcChwcm9wZXJ0eSwgdmFsdWUsIG9wKSB7XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgIGNhc2UgJyR0eXBlJzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdmaWx0ZXItdHlwZS0nICsgb3AsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICBdO1xuICAgIGNhc2UgJyRpZCc6XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnZmlsdGVyLWlkLScgKyBvcCxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdmaWx0ZXItJyArIG9wLFxuICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnREaXNqdW5jdGlvbk9wKGZpbHRlcnMpIHtcbiAgICByZXR1cm4gWydhbnknXS5jb25jYXQoZmlsdGVycy5tYXAoY29udmVydEZpbHRlcikpO1xufVxuZnVuY3Rpb24gY29udmVydEluT3AocHJvcGVydHksIHZhbHVlcykge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgIGNhc2UgJyR0eXBlJzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdmaWx0ZXItdHlwZS1pbicsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2xpdGVyYWwnLFxuICAgICAgICAgICAgICAgIHZhbHVlc1xuICAgICAgICAgICAgXVxuICAgICAgICBdO1xuICAgIGNhc2UgJyRpZCc6XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnZmlsdGVyLWlkLWluJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgdmFsdWVzXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAyMDAgJiYgIXZhbHVlcy5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2ICE9PSB0eXBlb2YgdmFsdWVzWzBdO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2ZpbHRlci1pbi1sYXJnZScsXG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zb3J0KGNvbXBhcmUpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2ZpbHRlci1pbi1zbWFsbCcsXG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0SGFzT3AocHJvcGVydHkpIHtcbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnJHR5cGUnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICckaWQnOlxuICAgICAgICByZXR1cm4gWydmaWx0ZXItaGFzLWlkJ107XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdmaWx0ZXItaGFzJyxcbiAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgIF07XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydE5lZ2F0aW9uKGZpbHRlcikge1xuICAgIHJldHVybiBbXG4gICAgICAgICchJyxcbiAgICAgICAgZmlsdGVyXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gY29udmVydEZpbHRlciQxKGZpbHRlcikge1xuICAgIHJldHVybiBfY29udmVydEZpbHRlcihmaWx0ZXIsIHt9KTtcbn1cbmZ1bmN0aW9uIF9jb252ZXJ0RmlsdGVyKGZpbHRlciwgZXhwZWN0ZWRUeXBlcykge1xuICAgIHZhciByZWYkMTtcbiAgICBpZiAoaXNFeHByZXNzaW9uRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9XG4gICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBvcCA9IGZpbHRlclswXTtcbiAgICBpZiAoZmlsdGVyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBvcCAhPT0gJ2FueSc7XG4gICAgfVxuICAgIHZhciBjb252ZXJ0ZWQ7XG4gICAgaWYgKG9wID09PSAnPT0nIHx8IG9wID09PSAnIT0nIHx8IG9wID09PSAnPCcgfHwgb3AgPT09ICc+JyB8fCBvcCA9PT0gJzw9JyB8fCBvcCA9PT0gJz49Jykge1xuICAgICAgICB2YXIgcmVmID0gZmlsdGVyO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSByZWZbMV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlZlsyXTtcbiAgICAgICAgY29udmVydGVkID0gY29udmVydENvbXBhcmlzb25PcCQxKHByb3BlcnR5LCB2YWx1ZSwgb3AsIGV4cGVjdGVkVHlwZXMpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICdhbnknKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGZpbHRlci5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX2NvbnZlcnRGaWx0ZXIoZiwgdHlwZXMpO1xuICAgICAgICAgICAgdmFyIHR5cGVjaGVja3MgPSBydW50aW1lVHlwZUNoZWNrcyh0eXBlcyk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZWNoZWNrcyA9PT0gdHJ1ZSA/IGNoaWxkIDogW1xuICAgICAgICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICAgICAgICB0eXBlY2hlY2tzLFxuICAgICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsnYW55J10uY29uY2F0KGNoaWxkcmVuKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnYWxsJykge1xuICAgICAgICB2YXIgY2hpbGRyZW4kMSA9IGZpbHRlci5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29udmVydEZpbHRlcihmLCBleHBlY3RlZFR5cGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbiQxLmxlbmd0aCA+IDEgPyBbJ2FsbCddLmNvbmNhdChjaGlsZHJlbiQxKSA6IChyZWYkMSA9IFtdKS5jb25jYXQuYXBwbHkocmVmJDEsIGNoaWxkcmVuJDEpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJyEnLFxuICAgICAgICAgICAgX2NvbnZlcnRGaWx0ZXIoWydhbnknXS5jb25jYXQoZmlsdGVyLnNsaWNlKDEpKSwge30pXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJ2luJykge1xuICAgICAgICBjb252ZXJ0ZWQgPSBjb252ZXJ0SW5PcCQxKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnIWluJykge1xuICAgICAgICBjb252ZXJ0ZWQgPSBjb252ZXJ0SW5PcCQxKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnaGFzJykge1xuICAgICAgICBjb252ZXJ0ZWQgPSBjb252ZXJ0SGFzT3AkMShmaWx0ZXJbMV0pO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICchaGFzJykge1xuICAgICAgICBjb252ZXJ0ZWQgPSBbXG4gICAgICAgICAgICAnIScsXG4gICAgICAgICAgICBjb252ZXJ0SGFzT3AkMShmaWx0ZXJbMV0pXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29udmVydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbmZ1bmN0aW9uIHJ1bnRpbWVUeXBlQ2hlY2tzKGV4cGVjdGVkVHlwZXMpIHtcbiAgICB2YXIgY29uZGl0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIGV4cGVjdGVkVHlwZXMpIHtcbiAgICAgICAgdmFyIGdldCA9IHByb3BlcnR5ID09PSAnJGlkJyA/IFsnaWQnXSA6IFtcbiAgICAgICAgICAgICdnZXQnLFxuICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgXTtcbiAgICAgICAgY29uZGl0aW9ucy5wdXNoKFtcbiAgICAgICAgICAgICc9PScsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3R5cGVvZicsXG4gICAgICAgICAgICAgICAgZ2V0XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlc1twcm9wZXJ0eV1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGlmIChjb25kaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjb25kaXRpb25zWzBdO1xuICAgIH1cbiAgICByZXR1cm4gWydhbGwnXS5jb25jYXQoY29uZGl0aW9ucyk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29tcGFyaXNvbk9wJDEocHJvcGVydHksIHZhbHVlLCBvcCwgZXhwZWN0ZWRUeXBlcykge1xuICAgIHZhciBnZXQ7XG4gICAgaWYgKHByb3BlcnR5ID09PSAnJHR5cGUnKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvcCxcbiAgICAgICAgICAgIFsnZ2VvbWV0cnktdHlwZSddLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnJGlkJykge1xuICAgICAgICBnZXQgPSBbJ2lkJ107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0ID0gW1xuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICBdO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0ZWRUeXBlcyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgZXhwZWN0ZWRUeXBlc1twcm9wZXJ0eV0gPSB0eXBlO1xuICAgIH1cbiAgICBpZiAob3AgPT09ICc9PScgJiYgcHJvcGVydHkgIT09ICckaWQnICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnYWxsJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnaGFzJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPT0nLFxuICAgICAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyE9JyAmJiBwcm9wZXJ0eSAhPT0gJyRpZCcgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdhbnknLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICchJyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICdoYXMnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJyE9JyxcbiAgICAgICAgICAgICAgICBnZXQsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBvcCxcbiAgICAgICAgZ2V0LFxuICAgICAgICB2YWx1ZVxuICAgIF07XG59XG5mdW5jdGlvbiBjb252ZXJ0SW5PcCQxKHByb3BlcnR5LCB2YWx1ZXMsIG5lZ2F0ZSkge1xuICAgIGlmIChuZWdhdGUgPT09IHZvaWQgMClcbiAgICAgICAgbmVnYXRlID0gZmFsc2U7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5lZ2F0ZTtcbiAgICB9XG4gICAgdmFyIGdldDtcbiAgICBpZiAocHJvcGVydHkgPT09ICckdHlwZScpIHtcbiAgICAgICAgZ2V0ID0gWydnZW9tZXRyeS10eXBlJ107XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJyRpZCcpIHtcbiAgICAgICAgZ2V0ID0gWydpZCddO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldCA9IFtcbiAgICAgICAgICAgICdnZXQnLFxuICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHVuaWZvcm1UeXBlcyA9IHRydWU7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVzWzBdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdmFsdWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB1bmlmb3JtVHlwZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh1bmlmb3JtVHlwZXMgJiYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgICB2YXIgdW5pcXVlVmFsdWVzID0gdmFsdWVzLnNvcnQoKS5maWx0ZXIoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpID09PSAwIHx8IHZhbHVlc1tpIC0gMV0gIT09IHY7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ21hdGNoJyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHVuaXF1ZVZhbHVlcyxcbiAgICAgICAgICAgICFuZWdhdGUsXG4gICAgICAgICAgICBuZWdhdGVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtuZWdhdGUgPyAnYWxsJyA6ICdhbnknXS5jb25jYXQodmFsdWVzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmVnYXRlID8gJyE9JyA6ICc9PScsXG4gICAgICAgICAgICBnZXQsXG4gICAgICAgICAgICB2XG4gICAgICAgIF07XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gY29udmVydEhhc09wJDEocHJvcGVydHkpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICckdHlwZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJyRpZCcpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICchPScsXG4gICAgICAgICAgICBbJ2lkJ10sXG4gICAgICAgICAgICBudWxsXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdoYXMnLFxuICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1pZ3JhdGVUb0V4cHJlc3Npb25zIChzdHlsZSkge1xuICAgIHZhciBjb252ZXJ0ZWQgPSBbXTtcbiAgICBlYWNoTGF5ZXIoc3R5bGUsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAobGF5ZXIuZmlsdGVyKSB7XG4gICAgICAgICAgICBsYXllci5maWx0ZXIgPSBjb252ZXJ0RmlsdGVyJDEobGF5ZXIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGVhY2hQcm9wZXJ0eShzdHlsZSwge1xuICAgICAgICBwYWludDogdHJ1ZSxcbiAgICAgICAgbGF5b3V0OiB0cnVlXG4gICAgfSwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgcGF0aCA9IHJlZi5wYXRoO1xuICAgICAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgICAgIHZhciByZWZlcmVuY2UgPSByZWYucmVmZXJlbmNlO1xuICAgICAgICB2YXIgc2V0ID0gcmVmLnNldDtcbiAgICAgICAgaWYgKGlzRXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHNldChjb252ZXJ0RnVuY3Rpb24odmFsdWUsIHJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgY29udmVydGVkLnB1c2gocGF0aC5qb2luKCcuJykpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZmVyZW5jZS50b2tlbnMgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2V0KGNvbnZlcnRUb2tlblN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBtaWdyYXRlIChzdHlsZSkge1xuICAgIHZhciBtaWdyYXRlZCA9IGZhbHNlO1xuICAgIGlmIChzdHlsZS52ZXJzaW9uID09PSA3KSB7XG4gICAgICAgIHN0eWxlID0gbWlncmF0ZVRvVjgoc3R5bGUpO1xuICAgICAgICBtaWdyYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzdHlsZS52ZXJzaW9uID09PSA4KSB7XG4gICAgICAgIG1pZ3JhdGVkID0gbWlncmF0ZVRvRXhwcmVzc2lvbnMoc3R5bGUpO1xuICAgICAgICBtaWdyYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICghbWlncmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgbWlncmF0ZSBmcm9tJywgc3R5bGUudmVyc2lvbik7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zaXRlIChzdHlsZSkge1xuICAgIHZhciBzdHlsZUlEcyA9IFtdO1xuICAgIHZhciBzb3VyY2VJRHMgPSBbXTtcbiAgICB2YXIgY29tcG9zaXRlZFNvdXJjZUxheWVycyA9IFtdO1xuICAgIGZvciAodmFyIGlkIGluIHN0eWxlLnNvdXJjZXMpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHN0eWxlLnNvdXJjZXNbaWRdO1xuICAgICAgICBpZiAoc291cmNlLnR5cGUgIT09ICd2ZWN0b3InKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2ggPSAvXm1hcGJveDpcXC9cXC8oLiopLy5leGVjKHNvdXJjZS51cmwpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZUlEcy5wdXNoKGlkKTtcbiAgICAgICAgc291cmNlSURzLnB1c2gobWF0Y2hbMV0pO1xuICAgIH1cbiAgICBpZiAoc3R5bGVJRHMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICAgIHN0eWxlSURzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGRlbGV0ZSBzdHlsZS5zb3VyY2VzW2lkXTtcbiAgICB9KTtcbiAgICB2YXIgY29tcG9zaXRlSUQgPSBzb3VyY2VJRHMuam9pbignLCcpO1xuICAgIHN0eWxlLnNvdXJjZXNbY29tcG9zaXRlSURdID0ge1xuICAgICAgICAndHlwZSc6ICd2ZWN0b3InLFxuICAgICAgICAndXJsJzogJ21hcGJveDovLycgKyBjb21wb3NpdGVJRFxuICAgIH07XG4gICAgc3R5bGUubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmIChzdHlsZUlEcy5pbmRleE9mKGxheWVyLnNvdXJjZSkgPj0gMCkge1xuICAgICAgICAgICAgbGF5ZXIuc291cmNlID0gY29tcG9zaXRlSUQ7XG4gICAgICAgICAgICBpZiAoJ3NvdXJjZS1sYXllcicgaW4gbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRlZFNvdXJjZUxheWVycy5pbmRleE9mKGxheWVyWydzb3VyY2UtbGF5ZXInXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZsaWN0aW5nIHNvdXJjZSBsYXllciBuYW1lcycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZWRTb3VyY2VMYXllcnMucHVzaChsYXllclsnc291cmNlLWxheWVyJ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHlsZTtcbn1cblxudmFyIHJlZlByb3BlcnRpZXMgPSBbXG4gICAgJ3R5cGUnLFxuICAgICdzb3VyY2UnLFxuICAgICdzb3VyY2UtbGF5ZXInLFxuICAgICdtaW56b29tJyxcbiAgICAnbWF4em9vbScsXG4gICAgJ2ZpbHRlcicsXG4gICAgJ2xheW91dCdcbl07XG5cbmZ1bmN0aW9uIGRlcmVmKGxheWVyLCBwYXJlbnQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgayBpbiBsYXllcikge1xuICAgICAgICBpZiAoayAhPT0gJ3JlZicpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IGxheWVyW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZlByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayBpbiBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHBhcmVudFtrXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkZXJlZkxheWVycyhsYXllcnMpIHtcbiAgICBsYXllcnMgPSBsYXllcnMuc2xpY2UoKTtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXBbbGF5ZXJzW2ldLmlkXSA9IGxheWVyc1tpXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGF5ZXJzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgaWYgKCdyZWYnIGluIGxheWVyc1tpJDFdKSB7XG4gICAgICAgICAgICBsYXllcnNbaSQxXSA9IGRlcmVmKGxheWVyc1tpJDFdLCBtYXBbbGF5ZXJzW2kkMV0ucmVmXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVycztcbn1cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYikgfHwgYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhICE9PSBudWxsICYmIGIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIGIgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5cbnZhciBvcGVyYXRpb25zID0ge1xuICAgIHNldFN0eWxlOiAnc2V0U3R5bGUnLFxuICAgIGFkZExheWVyOiAnYWRkTGF5ZXInLFxuICAgIHJlbW92ZUxheWVyOiAncmVtb3ZlTGF5ZXInLFxuICAgIHNldFBhaW50UHJvcGVydHk6ICdzZXRQYWludFByb3BlcnR5JyxcbiAgICBzZXRMYXlvdXRQcm9wZXJ0eTogJ3NldExheW91dFByb3BlcnR5JyxcbiAgICBzZXRGaWx0ZXI6ICdzZXRGaWx0ZXInLFxuICAgIGFkZFNvdXJjZTogJ2FkZFNvdXJjZScsXG4gICAgcmVtb3ZlU291cmNlOiAncmVtb3ZlU291cmNlJyxcbiAgICBzZXRHZW9KU09OU291cmNlRGF0YTogJ3NldEdlb0pTT05Tb3VyY2VEYXRhJyxcbiAgICBzZXRMYXllclpvb21SYW5nZTogJ3NldExheWVyWm9vbVJhbmdlJyxcbiAgICBzZXRMYXllclByb3BlcnR5OiAnc2V0TGF5ZXJQcm9wZXJ0eScsXG4gICAgc2V0Q2VudGVyOiAnc2V0Q2VudGVyJyxcbiAgICBzZXRab29tOiAnc2V0Wm9vbScsXG4gICAgc2V0QmVhcmluZzogJ3NldEJlYXJpbmcnLFxuICAgIHNldFBpdGNoOiAnc2V0UGl0Y2gnLFxuICAgIHNldFNwcml0ZTogJ3NldFNwcml0ZScsXG4gICAgc2V0R2x5cGhzOiAnc2V0R2x5cGhzJyxcbiAgICBzZXRUcmFuc2l0aW9uOiAnc2V0VHJhbnNpdGlvbicsXG4gICAgc2V0TGlnaHQ6ICdzZXRMaWdodCdcbn07XG5mdW5jdGlvbiBhZGRTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcykge1xuICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLmFkZFNvdXJjZSxcbiAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgc291cmNlSWQsXG4gICAgICAgICAgICBhZnRlcltzb3VyY2VJZF1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlU291cmNlKHNvdXJjZUlkLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpIHtcbiAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVTb3VyY2UsXG4gICAgICAgIGFyZ3M6IFtzb3VyY2VJZF1cbiAgICB9KTtcbiAgICBzb3VyY2VzUmVtb3ZlZFtzb3VyY2VJZF0gPSB0cnVlO1xufVxuZnVuY3Rpb24gdXBkYXRlU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKSB7XG4gICAgcmVtb3ZlU291cmNlKHNvdXJjZUlkLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpO1xuICAgIGFkZFNvdXJjZShzb3VyY2VJZCwgYWZ0ZXIsIGNvbW1hbmRzKTtcbn1cbmZ1bmN0aW9uIGNhblVwZGF0ZUdlb0pTT04oYmVmb3JlLCBhZnRlciwgc291cmNlSWQpIHtcbiAgICB2YXIgcHJvcDtcbiAgICBmb3IgKHByb3AgaW4gYmVmb3JlW3NvdXJjZUlkXSkge1xuICAgICAgICBpZiAoIWJlZm9yZVtzb3VyY2VJZF0uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wICE9PSAnZGF0YScgJiYgIWRlZXBFcXVhbChiZWZvcmVbc291cmNlSWRdW3Byb3BdLCBhZnRlcltzb3VyY2VJZF1bcHJvcF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wIGluIGFmdGVyW3NvdXJjZUlkXSkge1xuICAgICAgICBpZiAoIWFmdGVyW3NvdXJjZUlkXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3AgIT09ICdkYXRhJyAmJiAhZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF1bcHJvcF0sIGFmdGVyW3NvdXJjZUlkXVtwcm9wXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRpZmZTb3VyY2VzKGJlZm9yZSwgYWZ0ZXIsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCkge1xuICAgIGJlZm9yZSA9IGJlZm9yZSB8fCB7fTtcbiAgICBhZnRlciA9IGFmdGVyIHx8IHt9O1xuICAgIHZhciBzb3VyY2VJZDtcbiAgICBmb3IgKHNvdXJjZUlkIGluIGJlZm9yZSkge1xuICAgICAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWZ0ZXIuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSB7XG4gICAgICAgICAgICByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChzb3VyY2VJZCBpbiBhZnRlcikge1xuICAgICAgICBpZiAoIWFmdGVyLmhhc093blByb3BlcnR5KHNvdXJjZUlkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiZWZvcmUuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSB7XG4gICAgICAgICAgICBhZGRTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChiZWZvcmVbc291cmNlSWRdLCBhZnRlcltzb3VyY2VJZF0pKSB7XG4gICAgICAgICAgICBpZiAoYmVmb3JlW3NvdXJjZUlkXS50eXBlID09PSAnZ2VvanNvbicgJiYgYWZ0ZXJbc291cmNlSWRdLnR5cGUgPT09ICdnZW9qc29uJyAmJiBjYW5VcGRhdGVHZW9KU09OKGJlZm9yZSwgYWZ0ZXIsIHNvdXJjZUlkKSkge1xuICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEdlb0pTT05Tb3VyY2VEYXRhLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyW3NvdXJjZUlkXS5kYXRhXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmUsIGFmdGVyLCBjb21tYW5kcywgbGF5ZXJJZCwga2xhc3MsIGNvbW1hbmQpIHtcbiAgICBiZWZvcmUgPSBiZWZvcmUgfHwge307XG4gICAgYWZ0ZXIgPSBhZnRlciB8fCB7fTtcbiAgICB2YXIgcHJvcDtcbiAgICBmb3IgKHByb3AgaW4gYmVmb3JlKSB7XG4gICAgICAgIGlmICghYmVmb3JlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVbcHJvcF0sIGFmdGVyW3Byb3BdKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyW3Byb3BdLFxuICAgICAgICAgICAgICAgICAgICBrbGFzc1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcCBpbiBhZnRlcikge1xuICAgICAgICBpZiAoIWFmdGVyLmhhc093blByb3BlcnR5KHByb3ApIHx8IGJlZm9yZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlW3Byb3BdLCBhZnRlcltwcm9wXSkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBsYXllcklkLFxuICAgICAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICAgICAgICBhZnRlcltwcm9wXSxcbiAgICAgICAgICAgICAgICAgICAga2xhc3NcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBsdWNrSWQobGF5ZXIpIHtcbiAgICByZXR1cm4gbGF5ZXIuaWQ7XG59XG5mdW5jdGlvbiBpbmRleEJ5SWQoZ3JvdXAsIGxheWVyKSB7XG4gICAgZ3JvdXBbbGF5ZXIuaWRdID0gbGF5ZXI7XG4gICAgcmV0dXJuIGdyb3VwO1xufVxuZnVuY3Rpb24gZGlmZkxheWVycyhiZWZvcmUsIGFmdGVyLCBjb21tYW5kcykge1xuICAgIGJlZm9yZSA9IGJlZm9yZSB8fCBbXTtcbiAgICBhZnRlciA9IGFmdGVyIHx8IFtdO1xuICAgIHZhciBiZWZvcmVPcmRlciA9IGJlZm9yZS5tYXAocGx1Y2tJZCk7XG4gICAgdmFyIGFmdGVyT3JkZXIgPSBhZnRlci5tYXAocGx1Y2tJZCk7XG4gICAgdmFyIGJlZm9yZUluZGV4ID0gYmVmb3JlLnJlZHVjZShpbmRleEJ5SWQsIHt9KTtcbiAgICB2YXIgYWZ0ZXJJbmRleCA9IGFmdGVyLnJlZHVjZShpbmRleEJ5SWQsIHt9KTtcbiAgICB2YXIgdHJhY2tlciA9IGJlZm9yZU9yZGVyLnNsaWNlKCk7XG4gICAgdmFyIGNsZWFuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgaSwgZCwgbGF5ZXJJZCwgYmVmb3JlTGF5ZXIsIGFmdGVyTGF5ZXIsIGluc2VydEJlZm9yZUxheWVySWQsIHByb3A7XG4gICAgZm9yIChpID0gMCwgZCA9IDA7IGkgPCBiZWZvcmVPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYXllcklkID0gYmVmb3JlT3JkZXJbaV07XG4gICAgICAgIGlmICghYWZ0ZXJJbmRleC5oYXNPd25Qcm9wZXJ0eShsYXllcklkKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXJJZF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhY2tlci5zcGxpY2UodHJhY2tlci5pbmRleE9mKGxheWVySWQsIGQpLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBkID0gMDsgaSA8IGFmdGVyT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGF5ZXJJZCA9IGFmdGVyT3JkZXJbYWZ0ZXJPcmRlci5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIGlmICh0cmFja2VyW3RyYWNrZXIubGVuZ3RoIC0gMSAtIGldID09PSBsYXllcklkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVmb3JlSW5kZXguaGFzT3duUHJvcGVydHkobGF5ZXJJZCkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlTGF5ZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW2xheWVySWRdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyYWNrZXIuc3BsaWNlKHRyYWNrZXIubGFzdEluZGV4T2YobGF5ZXJJZCwgdHJhY2tlci5sZW5ndGggLSBkKSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkKys7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0QmVmb3JlTGF5ZXJJZCA9IHRyYWNrZXJbdHJhY2tlci5sZW5ndGggLSBpXTtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLmFkZExheWVyLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIGFmdGVySW5kZXhbbGF5ZXJJZF0sXG4gICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTGF5ZXJJZFxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgdHJhY2tlci5zcGxpY2UodHJhY2tlci5sZW5ndGggLSBpLCAwLCBsYXllcklkKTtcbiAgICAgICAgY2xlYW5bbGF5ZXJJZF0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWZ0ZXJPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYXllcklkID0gYWZ0ZXJPcmRlcltpXTtcbiAgICAgICAgYmVmb3JlTGF5ZXIgPSBiZWZvcmVJbmRleFtsYXllcklkXTtcbiAgICAgICAgYWZ0ZXJMYXllciA9IGFmdGVySW5kZXhbbGF5ZXJJZF07XG4gICAgICAgIGlmIChjbGVhbltsYXllcklkXSB8fCBkZWVwRXF1YWwoYmVmb3JlTGF5ZXIsIGFmdGVyTGF5ZXIpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllci5zb3VyY2UsIGFmdGVyTGF5ZXIuc291cmNlKSB8fCAhZGVlcEVxdWFsKGJlZm9yZUxheWVyWydzb3VyY2UtbGF5ZXInXSwgYWZ0ZXJMYXllclsnc291cmNlLWxheWVyJ10pIHx8ICFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIudHlwZSwgYWZ0ZXJMYXllci50eXBlKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXJJZF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTGF5ZXJJZCA9IHRyYWNrZXJbdHJhY2tlci5sYXN0SW5kZXhPZihsYXllcklkKSArIDFdO1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5hZGRMYXllcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyTGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZUxheWVySWRcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmVMYXllci5sYXlvdXQsIGFmdGVyTGF5ZXIubGF5b3V0LCBjb21tYW5kcywgbGF5ZXJJZCwgbnVsbCwgb3BlcmF0aW9ucy5zZXRMYXlvdXRQcm9wZXJ0eSk7XG4gICAgICAgIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmVMYXllci5wYWludCwgYWZ0ZXJMYXllci5wYWludCwgY29tbWFuZHMsIGxheWVySWQsIG51bGwsIG9wZXJhdGlvbnMuc2V0UGFpbnRQcm9wZXJ0eSk7XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyLmZpbHRlciwgYWZ0ZXJMYXllci5maWx0ZXIpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEZpbHRlcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyTGF5ZXIuZmlsdGVyXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIubWluem9vbSwgYWZ0ZXJMYXllci5taW56b29tKSB8fCAhZGVlcEVxdWFsKGJlZm9yZUxheWVyLm1heHpvb20sIGFmdGVyTGF5ZXIubWF4em9vbSkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGF5ZXJab29tUmFuZ2UsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBsYXllcklkLFxuICAgICAgICAgICAgICAgICAgICBhZnRlckxheWVyLm1pbnpvb20sXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyTGF5ZXIubWF4em9vbVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBiZWZvcmVMYXllcikge1xuICAgICAgICAgICAgaWYgKCFiZWZvcmVMYXllci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdsYXlvdXQnIHx8IHByb3AgPT09ICdwYWludCcgfHwgcHJvcCA9PT0gJ2ZpbHRlcicgfHwgcHJvcCA9PT0gJ21ldGFkYXRhJyB8fCBwcm9wID09PSAnbWluem9vbScgfHwgcHJvcCA9PT0gJ21heHpvb20nKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcC5pbmRleE9mKCdwYWludC4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmVMYXllcltwcm9wXSwgYWZ0ZXJMYXllcltwcm9wXSwgY29tbWFuZHMsIGxheWVySWQsIHByb3Auc2xpY2UoNiksIG9wZXJhdGlvbnMuc2V0UGFpbnRQcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXJbcHJvcF0sIGFmdGVyTGF5ZXJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGF5ZXJQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlckxheWVyW3Byb3BdXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gYWZ0ZXJMYXllcikge1xuICAgICAgICAgICAgaWYgKCFhZnRlckxheWVyLmhhc093blByb3BlcnR5KHByb3ApIHx8IGJlZm9yZUxheWVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2xheW91dCcgfHwgcHJvcCA9PT0gJ3BhaW50JyB8fCBwcm9wID09PSAnZmlsdGVyJyB8fCBwcm9wID09PSAnbWV0YWRhdGEnIHx8IHByb3AgPT09ICdtaW56b29tJyB8fCBwcm9wID09PSAnbWF4em9vbScpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wLmluZGV4T2YoJ3BhaW50LicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdLCBjb21tYW5kcywgbGF5ZXJJZCwgcHJvcC5zbGljZSg2KSwgb3BlcmF0aW9ucy5zZXRQYWludFByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllcltwcm9wXSwgYWZ0ZXJMYXllcltwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRMYXllclByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGF5ZXJbcHJvcF1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGlmZlN0eWxlcyhiZWZvcmUsIGFmdGVyKSB7XG4gICAgaWYgKCFiZWZvcmUpIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTdHlsZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXJdXG4gICAgICAgICAgICB9XTtcbiAgICB9XG4gICAgdmFyIGNvbW1hbmRzID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLnZlcnNpb24sIGFmdGVyLnZlcnNpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2FmdGVyXVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5jZW50ZXIsIGFmdGVyLmNlbnRlcikpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0Q2VudGVyLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci5jZW50ZXJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuem9vbSwgYWZ0ZXIuem9vbSkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0Wm9vbSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIuem9vbV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5iZWFyaW5nLCBhZnRlci5iZWFyaW5nKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRCZWFyaW5nLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci5iZWFyaW5nXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLnBpdGNoLCBhZnRlci5waXRjaCkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0UGl0Y2gsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLnBpdGNoXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLnNwcml0ZSwgYWZ0ZXIuc3ByaXRlKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTcHJpdGUsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLnNwcml0ZV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5nbHlwaHMsIGFmdGVyLmdseXBocykpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0R2x5cGhzLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci5nbHlwaHNdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUudHJhbnNpdGlvbiwgYWZ0ZXIudHJhbnNpdGlvbikpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0VHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIudHJhbnNpdGlvbl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5saWdodCwgYWZ0ZXIubGlnaHQpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldExpZ2h0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci5saWdodF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2VzUmVtb3ZlZCA9IHt9O1xuICAgICAgICB2YXIgcmVtb3ZlT3JBZGRTb3VyY2VDb21tYW5kcyA9IFtdO1xuICAgICAgICBkaWZmU291cmNlcyhiZWZvcmUuc291cmNlcywgYWZ0ZXIuc291cmNlcywgcmVtb3ZlT3JBZGRTb3VyY2VDb21tYW5kcywgc291cmNlc1JlbW92ZWQpO1xuICAgICAgICB2YXIgYmVmb3JlTGF5ZXJzID0gW107XG4gICAgICAgIGlmIChiZWZvcmUubGF5ZXJzKSB7XG4gICAgICAgICAgICBiZWZvcmUubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZXNSZW1vdmVkW2xheWVyLnNvdXJjZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZUxheWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2xheWVyLmlkXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVMYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWFuZHMgPSBjb21tYW5kcy5jb25jYXQocmVtb3ZlT3JBZGRTb3VyY2VDb21tYW5kcyk7XG4gICAgICAgIGRpZmZMYXllcnMoYmVmb3JlTGF5ZXJzLCBhZnRlci5sYXllcnMsIGNvbW1hbmRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGNvbXB1dGUgc3R5bGUgZGlmZjonLCBlKTtcbiAgICAgICAgY29tbWFuZHMgPSBbe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0U3R5bGUsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyXVxuICAgICAgICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcztcbn1cblxudmFyIFZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBtZXNzYWdlLCBpZGVudGlmaWVyKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gKGtleSA/IGtleSArICc6ICcgOiAnJykgKyBtZXNzYWdlO1xuICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLl9fbGluZV9fKSB7XG4gICAgICAgIHRoaXMubGluZSA9IHZhbHVlLl9fbGluZV9fO1xuICAgIH1cbn07XG5cbnZhciBQYXJzaW5nRXJyb3IkMSA9IGZ1bmN0aW9uIFBhcnNpbmdFcnJvcihlcnJvcikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIHZhciBtYXRjaCA9IGVycm9yLm1lc3NhZ2UubWF0Y2goL2xpbmUgKFxcZCspLyk7XG4gICAgdGhpcy5saW5lID0gbWF0Y2ggPyBwYXJzZUludChtYXRjaFsxXSwgMTApIDogMDtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RhbnRzKG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIGNvbnN0YW50cyA9IG9wdGlvbnMudmFsdWU7XG4gICAgaWYgKGNvbnN0YW50cykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBjb25zdGFudHMsICdjb25zdGFudHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjgnKV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW5idW5kbGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlZXBVbmJ1bmRsZSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGRlZXBVbmJ1bmRsZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikpIHtcbiAgICAgICAgdmFyIHVuYnVuZGxlZFZhbHVlID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgdW5idW5kbGVkVmFsdWVba2V5XSA9IGRlZXBVbmJ1bmRsZSh2YWx1ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5idW5kbGVkVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB1bmJ1bmRsZSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIG9iamVjdCA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGVsZW1lbnRTcGVjcyA9IG9wdGlvbnMudmFsdWVTcGVjIHx8IHt9O1xuICAgIHZhciBlbGVtZW50VmFsaWRhdG9ycyA9IG9wdGlvbnMub2JqZWN0RWxlbWVudFZhbGlkYXRvcnMgfHwge307XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZShvYmplY3QpO1xuICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3QsICdvYmplY3QgZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgZm9yICh2YXIgb2JqZWN0S2V5IGluIG9iamVjdCkge1xuICAgICAgICB2YXIgZWxlbWVudFNwZWNLZXkgPSBvYmplY3RLZXkuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgdmFyIGVsZW1lbnRTcGVjID0gZWxlbWVudFNwZWNzW2VsZW1lbnRTcGVjS2V5XSB8fCBlbGVtZW50U3BlY3NbJyonXTtcbiAgICAgICAgdmFyIHZhbGlkYXRlRWxlbWVudCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGVsZW1lbnRWYWxpZGF0b3JzW2VsZW1lbnRTcGVjS2V5XSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gZWxlbWVudFZhbGlkYXRvcnNbZWxlbWVudFNwZWNLZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRTcGVjc1tlbGVtZW50U3BlY0tleV0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRWxlbWVudCA9IHZhbGlkYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRWYWxpZGF0b3JzWycqJ10pIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRWxlbWVudCA9IGVsZW1lbnRWYWxpZGF0b3JzWycqJ107XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFNwZWNzWycqJ10pIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRWxlbWVudCA9IHZhbGlkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG9iamVjdFtvYmplY3RLZXldLCAndW5rbm93biBwcm9wZXJ0eSBcIicgKyBvYmplY3RLZXkgKyAnXCInKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlRWxlbWVudCh7XG4gICAgICAgICAgICBrZXk6IChrZXkgPyBrZXkgKyAnLicgOiBrZXkpICsgb2JqZWN0S2V5LFxuICAgICAgICAgICAgdmFsdWU6IG9iamVjdFtvYmplY3RLZXldLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBlbGVtZW50U3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgICBvYmplY3RLZXk6IG9iamVjdEtleVxuICAgICAgICB9LCBvYmplY3QpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgZWxlbWVudFNwZWNLZXkkMSBpbiBlbGVtZW50U3BlY3MpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRWYWxpZGF0b3JzW2VsZW1lbnRTcGVjS2V5JDFdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudFNwZWNzW2VsZW1lbnRTcGVjS2V5JDFdLnJlcXVpcmVkICYmIGVsZW1lbnRTcGVjc1tlbGVtZW50U3BlY0tleSQxXVsnZGVmYXVsdCddID09PSB1bmRlZmluZWQgJiYgb2JqZWN0W2VsZW1lbnRTcGVjS2V5JDFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3QsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwiJyArIGVsZW1lbnRTcGVjS2V5JDEgKyAnXCInKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBcnJheShvcHRpb25zKSB7XG4gICAgdmFyIGFycmF5ID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgYXJyYXlTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB2YWxpZGF0ZUFycmF5RWxlbWVudCA9IG9wdGlvbnMuYXJyYXlFbGVtZW50VmFsaWRhdG9yIHx8IHZhbGlkYXRlO1xuICAgIGlmIChnZXRUeXBlKGFycmF5KSAhPT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgJ2FycmF5IGV4cGVjdGVkLCAnICsgZ2V0VHlwZShhcnJheSkgKyAnIGZvdW5kJyldO1xuICAgIH1cbiAgICBpZiAoYXJyYXlTcGVjLmxlbmd0aCAmJiBhcnJheS5sZW5ndGggIT09IGFycmF5U3BlYy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgYXJyYXksICdhcnJheSBsZW5ndGggJyArIGFycmF5U3BlYy5sZW5ndGggKyAnIGV4cGVjdGVkLCBsZW5ndGggJyArIGFycmF5Lmxlbmd0aCArICcgZm91bmQnKV07XG4gICAgfVxuICAgIGlmIChhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSAmJiBhcnJheS5sZW5ndGggPCBhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgJ2FycmF5IGxlbmd0aCBhdCBsZWFzdCAnICsgYXJyYXlTcGVjWydtaW4tbGVuZ3RoJ10gKyAnIGV4cGVjdGVkLCBsZW5ndGggJyArIGFycmF5Lmxlbmd0aCArICcgZm91bmQnKV07XG4gICAgfVxuICAgIHZhciBhcnJheUVsZW1lbnRTcGVjID0ge1xuICAgICAgICAndHlwZSc6IGFycmF5U3BlYy52YWx1ZSxcbiAgICAgICAgJ3ZhbHVlcyc6IGFycmF5U3BlYy52YWx1ZXNcbiAgICB9O1xuICAgIGlmIChzdHlsZVNwZWMuJHZlcnNpb24gPCA3KSB7XG4gICAgICAgIGFycmF5RWxlbWVudFNwZWMuZnVuY3Rpb24gPSBhcnJheVNwZWMuZnVuY3Rpb247XG4gICAgfVxuICAgIGlmIChnZXRUeXBlKGFycmF5U3BlYy52YWx1ZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFycmF5RWxlbWVudFNwZWMgPSBhcnJheVNwZWMudmFsdWU7XG4gICAgfVxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVBcnJheUVsZW1lbnQoe1xuICAgICAgICAgICAgYXJyYXk6IGFycmF5LFxuICAgICAgICAgICAgYXJyYXlJbmRleDogaSxcbiAgICAgICAgICAgIHZhbHVlOiBhcnJheVtpXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogYXJyYXlFbGVtZW50U3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICAgICAga2V5OiBrZXkgKyAnWycgKyBpICsgJ10nXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdHlwZSA9ICdOYU4nO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdudW1iZXIgZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgaWYgKCdtaW5pbXVtJyBpbiB2YWx1ZVNwZWMgJiYgdmFsdWUgPCB2YWx1ZVNwZWMubWluaW11bSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgdmFsdWUgKyAnIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSB2YWx1ZSAnICsgdmFsdWVTcGVjLm1pbmltdW0pXTtcbiAgICB9XG4gICAgaWYgKCdtYXhpbXVtJyBpbiB2YWx1ZVNwZWMgJiYgdmFsdWUgPiB2YWx1ZVNwZWMubWF4aW11bSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgdmFsdWUgKyAnIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSAnICsgdmFsdWVTcGVjLm1heGltdW0pXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZnVuY3Rpb25WYWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIgZnVuY3Rpb25UeXBlID0gdW5idW5kbGUob3B0aW9ucy52YWx1ZS50eXBlKTtcbiAgICB2YXIgc3RvcEtleVR5cGU7XG4gICAgdmFyIHN0b3BEb21haW5WYWx1ZXMgPSB7fTtcbiAgICB2YXIgcHJldmlvdXNTdG9wRG9tYWluVmFsdWU7XG4gICAgdmFyIHByZXZpb3VzU3RvcERvbWFpblpvb207XG4gICAgdmFyIGlzWm9vbUZ1bmN0aW9uID0gZnVuY3Rpb25UeXBlICE9PSAnY2F0ZWdvcmljYWwnICYmIG9wdGlvbnMudmFsdWUucHJvcGVydHkgPT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaXNQcm9wZXJ0eUZ1bmN0aW9uID0gIWlzWm9vbUZ1bmN0aW9uO1xuICAgIHZhciBpc1pvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uID0gZ2V0VHlwZShvcHRpb25zLnZhbHVlLnN0b3BzKSA9PT0gJ2FycmF5JyAmJiBnZXRUeXBlKG9wdGlvbnMudmFsdWUuc3RvcHNbMF0pID09PSAnYXJyYXknICYmIGdldFR5cGUob3B0aW9ucy52YWx1ZS5zdG9wc1swXVswXSkgPT09ICdvYmplY3QnO1xuICAgIHZhciBlcnJvcnMgPSB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLFxuICAgICAgICB2YWx1ZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLmZ1bmN0aW9uLFxuICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgIHN0b3BzOiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcHMsXG4gICAgICAgICAgICBkZWZhdWx0OiB2YWxpZGF0ZUZ1bmN0aW9uRGVmYXVsdFxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2lkZW50aXR5JyAmJiBpc1pvb21GdW5jdGlvbikge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInByb3BlcnR5XCInKSk7XG4gICAgfVxuICAgIGlmIChmdW5jdGlvblR5cGUgIT09ICdpZGVudGl0eScgJiYgIW9wdGlvbnMudmFsdWUuc3RvcHMpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJzdG9wc1wiJykpO1xuICAgIH1cbiAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnZXhwb25lbnRpYWwnICYmIG9wdGlvbnMudmFsdWVTcGVjLmV4cHJlc3Npb24gJiYgIXN1cHBvcnRzSW50ZXJwb2xhdGlvbihvcHRpb25zLnZhbHVlU3BlYykpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ2V4cG9uZW50aWFsIGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkJykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHlsZVNwZWMuJHZlcnNpb24gPj0gOCkge1xuICAgICAgICBpZiAoaXNQcm9wZXJ0eUZ1bmN0aW9uICYmICFzdXBwb3J0c1Byb3BlcnR5RXhwcmVzc2lvbihvcHRpb25zLnZhbHVlU3BlYykpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdwcm9wZXJ0eSBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1pvb21GdW5jdGlvbiAmJiAhc3VwcG9ydHNab29tRXhwcmVzc2lvbihvcHRpb25zLnZhbHVlU3BlYykpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICd6b29tIGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnIHx8IGlzWm9vbUFuZFByb3BlcnR5RnVuY3Rpb24pICYmIG9wdGlvbnMudmFsdWUucHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnXCJwcm9wZXJ0eVwiIHByb3BlcnR5IGlzIHJlcXVpcmVkJykpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25TdG9wcyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ2lkZW50aXR5IGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBhIFwic3RvcHNcIiBwcm9wZXJ0eScpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVBcnJheSh7XG4gICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBvcHRpb25zLnZhbHVlU3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICAgIGFycmF5RWxlbWVudFZhbGlkYXRvcjogdmFsaWRhdGVGdW5jdGlvblN0b3BcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdhcnJheScgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCB2YWx1ZSwgJ2FycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc3RvcCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcChvcHRpb25zKSB7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYXJyYXkgZXhwZWN0ZWQsICcgKyBnZXRUeXBlKHZhbHVlKSArICcgZm91bmQnKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdhcnJheSBsZW5ndGggMiBleHBlY3RlZCwgbGVuZ3RoICcgKyB2YWx1ZS5sZW5ndGggKyAnIGZvdW5kJyldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1pvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZVswXSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdvYmplY3QgZXhwZWN0ZWQsICcgKyBnZXRUeXBlKHZhbHVlWzBdKSArICcgZm91bmQnKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVbMF0uem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHpvb20nKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVbMF0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnb2JqZWN0IHN0b3Aga2V5IG11c3QgaGF2ZSB2YWx1ZScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1N0b3BEb21haW5ab29tICYmIHByZXZpb3VzU3RvcERvbWFpblpvb20gPiB1bmJ1bmRsZSh2YWx1ZVswXS56b29tKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlWzBdLnpvb20sICdzdG9wIHpvb20gdmFsdWVzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlcicpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmJ1bmRsZSh2YWx1ZVswXS56b29tKSAhPT0gcHJldmlvdXNTdG9wRG9tYWluWm9vbSkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU3RvcERvbWFpblpvb20gPSB1bmJ1bmRsZSh2YWx1ZVswXS56b29tKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzdG9wRG9tYWluVmFsdWVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSArICdbMF0nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHsgem9vbToge30gfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgIHpvb206IHZhbGlkYXRlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsaWRhdGVTdG9wRG9tYWluVmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlU3RvcERvbWFpblZhbHVlKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSArICdbMF0nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHt9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgICAgIH0sIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXhwcmVzc2lvbihkZWVwVW5idW5kbGUodmFsdWVbMV0pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJ1sxXScsIHZhbHVlWzFdLCAnZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGZ1bmN0aW9uIHN0b3BzLicpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICAgICAga2V5OiBrZXkgKyAnWzFdJyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVsxXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogZnVuY3Rpb25WYWx1ZVNwZWMsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVN0b3BEb21haW5WYWx1ZShvcHRpb25zLCBzdG9wKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZShvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdW5idW5kbGUob3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIHZhciByZXBvcnRWYWx1ZSA9IG9wdGlvbnMudmFsdWUgIT09IG51bGwgPyBvcHRpb25zLnZhbHVlIDogc3RvcDtcbiAgICAgICAgaWYgKCFzdG9wS2V5VHlwZSkge1xuICAgICAgICAgICAgc3RvcEtleVR5cGUgPSB0eXBlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHN0b3BLZXlUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCB0eXBlICsgJyBzdG9wIGRvbWFpbiB0eXBlIG11c3QgbWF0Y2ggcHJldmlvdXMgc3RvcCBkb21haW4gdHlwZSAnICsgc3RvcEtleVR5cGUpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSAhPT0gJ251bWJlcicgJiYgdHlwZSAhPT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCAnc3RvcCBkb21haW4gdmFsdWUgbXVzdCBiZSBhIG51bWJlciwgc3RyaW5nLCBvciBib29sZWFuJyldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJiBmdW5jdGlvblR5cGUgIT09ICdjYXRlZ29yaWNhbCcpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gJ251bWJlciBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJztcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1Byb3BlcnR5RXhwcmVzc2lvbihmdW5jdGlvblZhbHVlU3BlYykgJiYgZnVuY3Rpb25UeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICdcXG5JZiB5b3UgaW50ZW5kZWQgdG8gdXNlIGEgY2F0ZWdvcmljYWwgZnVuY3Rpb24sIHNwZWNpZnkgYFwidHlwZVwiOiBcImNhdGVnb3JpY2FsXCJgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCBtZXNzYWdlKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2NhdGVnb3JpY2FsJyAmJiB0eXBlID09PSAnbnVtYmVyJyAmJiAoIWlzRmluaXRlKHZhbHVlKSB8fCBNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCAnaW50ZWdlciBleHBlY3RlZCwgZm91bmQgJyArIHZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmN0aW9uVHlwZSAhPT0gJ2NhdGVnb3JpY2FsJyAmJiB0eXBlID09PSAnbnVtYmVyJyAmJiBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgcHJldmlvdXNTdG9wRG9tYWluVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsICdzdG9wIGRvbWFpbiB2YWx1ZXMgbXVzdCBhcHBlYXIgaW4gYXNjZW5kaW5nIG9yZGVyJyldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNTdG9wRG9tYWluVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHZhbHVlIGluIHN0b3BEb21haW5WYWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsICdzdG9wIGRvbWFpbiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWUnKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9wRG9tYWluVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uRGVmYXVsdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IGZ1bmN0aW9uVmFsdWVTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHByZXNzaW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAncHJvcGVydHknID8gY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uIDogY3JlYXRlRXhwcmVzc2lvbikoZGVlcFVuYnVuZGxlKG9wdGlvbnMudmFsdWUpLCBvcHRpb25zLnZhbHVlU3BlYyk7XG4gICAgaWYgKGV4cHJlc3Npb24ucmVzdWx0ID09PSAnZXJyb3InKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uLnZhbHVlLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFsaWRhdGlvbkVycm9yKCcnICsgb3B0aW9ucy5rZXkgKyBlcnJvci5rZXksIG9wdGlvbnMudmFsdWUsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGV4cHJlc3Npb25PYmogPSBleHByZXNzaW9uLnZhbHVlLmV4cHJlc3Npb24gfHwgZXhwcmVzc2lvbi52YWx1ZS5fc3R5bGVFeHByZXNzaW9uLmV4cHJlc3Npb247XG4gICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdwcm9wZXJ0eScgJiYgb3B0aW9ucy5wcm9wZXJ0eUtleSA9PT0gJ3RleHQtZm9udCcgJiYgIWV4cHJlc3Npb25PYmoub3V0cHV0RGVmaW5lZCgpKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ0ludmFsaWQgZGF0YSBleHByZXNzaW9uIGZvciBcIicgKyBvcHRpb25zLnByb3BlcnR5S2V5ICsgJ1wiLiBPdXRwdXQgdmFsdWVzIG11c3QgYmUgY29udGFpbmVkIGFzIGxpdGVyYWxzIHdpdGhpbiB0aGUgZXhwcmVzc2lvbi4nKV07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAncHJvcGVydHknICYmIG9wdGlvbnMucHJvcGVydHlUeXBlID09PSAnbGF5b3V0JyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb25PYmopKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ1wiZmVhdHVyZS1zdGF0ZVwiIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBsYXlvdXQgcHJvcGVydGllcy4nKV07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAnZmlsdGVyJyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb25PYmopKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ1wiZmVhdHVyZS1zdGF0ZVwiIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBmaWx0ZXJzLicpXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgJiYgb3B0aW9ucy5leHByZXNzaW9uQ29udGV4dC5pbmRleE9mKCdjbHVzdGVyJykgPT09IDApIHtcbiAgICAgICAgaWYgKCFpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoZXhwcmVzc2lvbk9iaiwgW1xuICAgICAgICAgICAgICAgICd6b29tJyxcbiAgICAgICAgICAgICAgICAnZmVhdHVyZS1zdGF0ZSdcbiAgICAgICAgICAgIF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdcInpvb21cIiBhbmQgXCJmZWF0dXJlLXN0YXRlXCIgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBjbHVzdGVyIHByb3BlcnRpZXMuJyldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAnY2x1c3Rlci1pbml0aWFsJyAmJiAhaXNGZWF0dXJlQ29uc3RhbnQoZXhwcmVzc2lvbk9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ0ZlYXR1cmUgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGluaXRpYWwgZXhwcmVzc2lvbiBwYXJ0IG9mIGNsdXN0ZXIgcHJvcGVydGllcy4nKV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUJvb2xlYW4ob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2Jvb2xlYW4gZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbG9yKG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2NvbG9yIGV4cGVjdGVkLCAnICsgdHlwZSArICcgZm91bmQnKV07XG4gICAgfVxuICAgIGlmIChjc3Njb2xvcnBhcnNlcl8xKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2NvbG9yIGV4cGVjdGVkLCBcIicgKyB2YWx1ZSArICdcIiBmb3VuZCcpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUVudW0ob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVTcGVjLnZhbHVlcykpIHtcbiAgICAgICAgaWYgKHZhbHVlU3BlYy52YWx1ZXMuaW5kZXhPZih1bmJ1bmRsZSh2YWx1ZSkpID09PSAtMSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZXhwZWN0ZWQgb25lIG9mIFsnICsgdmFsdWVTcGVjLnZhbHVlcy5qb2luKCcsICcpICsgJ10sICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnIGZvdW5kJykpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlU3BlYy52YWx1ZXMpLmluZGV4T2YodW5idW5kbGUodmFsdWUpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2V4cGVjdGVkIG9uZSBvZiBbJyArIE9iamVjdC5rZXlzKHZhbHVlU3BlYy52YWx1ZXMpLmpvaW4oJywgJykgKyAnXSwgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcgZm91bmQnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGaWx0ZXIob3B0aW9ucykge1xuICAgIGlmIChpc0V4cHJlc3Npb25GaWx0ZXIoZGVlcFVuYnVuZGxlKG9wdGlvbnMudmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVFeHByZXNzaW9uKGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6ICdmaWx0ZXInLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiB7IHZhbHVlOiAnYm9vbGVhbicgfVxuICAgICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlcihvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU5vbkV4cHJlc3Npb25GaWx0ZXIob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2FycmF5IGV4cGVjdGVkLCAnICsgZ2V0VHlwZSh2YWx1ZSkgKyAnIGZvdW5kJyldO1xuICAgIH1cbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIHR5cGU7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZmlsdGVyIGFycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCAxIGVsZW1lbnQnKV07XG4gICAgfVxuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbnVtKHtcbiAgICAgICAga2V5OiBrZXkgKyAnWzBdJyxcbiAgICAgICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5maWx0ZXJfb3BlcmF0b3IsXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgfSkpO1xuICAgIHN3aXRjaCAodW5idW5kbGUodmFsdWVbMF0pKSB7XG4gICAgY2FzZSAnPCc6XG4gICAgY2FzZSAnPD0nOlxuICAgIGNhc2UgJz4nOlxuICAgIGNhc2UgJz49JzpcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyICYmIHVuYnVuZGxlKHZhbHVlWzFdKSA9PT0gJyR0eXBlJykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCIkdHlwZVwiIGNhbm5vdCBiZSB1c2Ugd2l0aCBvcGVyYXRvciBcIicgKyB2YWx1ZVswXSArICdcIicpKTtcbiAgICAgICAgfVxuICAgIGNhc2UgJz09JzpcbiAgICBjYXNlICchPSc6XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2ZpbHRlciBhcnJheSBmb3Igb3BlcmF0b3IgXCInICsgdmFsdWVbMF0gKyAnXCIgbXVzdCBoYXZlIDMgZWxlbWVudHMnKSk7XG4gICAgICAgIH1cbiAgICBjYXNlICdpbic6XG4gICAgY2FzZSAnIWluJzpcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICB0eXBlID0gZ2V0VHlwZSh2YWx1ZVsxXSk7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbMV0nLCB2YWx1ZVsxXSwgJ3N0cmluZyBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlW2ldKTtcbiAgICAgICAgICAgIGlmICh1bmJ1bmRsZSh2YWx1ZVsxXSkgPT09ICckdHlwZScpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlRW51bSh7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1snICsgaSArICddJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5nZW9tZXRyeV90eXBlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gJ251bWJlcicgJiYgdHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWycgKyBpICsgJ10nLCB2YWx1ZVtpXSwgJ3N0cmluZywgbnVtYmVyLCBvciBib29sZWFuIGV4cGVjdGVkLCAnICsgdHlwZSArICcgZm91bmQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYW55JzpcbiAgICBjYXNlICdhbGwnOlxuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPCB2YWx1ZS5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlcih7XG4gICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnWycgKyBpJDEgKyAnXScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2kkMV0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2hhcyc6XG4gICAgY2FzZSAnIWhhcyc6XG4gICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzFdKTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZmlsdGVyIGFycmF5IGZvciBcIicgKyB2YWx1ZVswXSArICdcIiBvcGVyYXRvciBtdXN0IGhhdmUgMiBlbGVtZW50cycpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzFdJywgdmFsdWVbMV0sICdzdHJpbmcgZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eShvcHRpb25zLCBwcm9wZXJ0eVR5cGUpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgcHJvcGVydHlLZXkgPSBvcHRpb25zLm9iamVjdEtleTtcbiAgICB2YXIgbGF5ZXJTcGVjID0gc3R5bGVTcGVjW3Byb3BlcnR5VHlwZSArICdfJyArIG9wdGlvbnMubGF5ZXJUeXBlXTtcbiAgICBpZiAoIWxheWVyU3BlYykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciB0cmFuc2l0aW9uTWF0Y2ggPSBwcm9wZXJ0eUtleS5tYXRjaCgvXiguKiktdHJhbnNpdGlvbiQvKTtcbiAgICBpZiAocHJvcGVydHlUeXBlID09PSAncGFpbnQnICYmIHRyYW5zaXRpb25NYXRjaCAmJiBsYXllclNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiBsYXllclNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXS50cmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnRyYW5zaXRpb24sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjIHx8IGxheWVyU3BlY1twcm9wZXJ0eUtleV07XG4gICAgaWYgKCF2YWx1ZVNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICd1bmtub3duIHByb3BlcnR5IFwiJyArIHByb3BlcnR5S2V5ICsgJ1wiJyldO1xuICAgIH1cbiAgICB2YXIgdG9rZW5NYXRjaDtcbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnICYmIHN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKHZhbHVlU3BlYykgJiYgIXZhbHVlU3BlYy50b2tlbnMgJiYgKHRva2VuTWF0Y2ggPSAvXnsoW159XSspfSQvLmV4ZWModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1wiJyArIHByb3BlcnR5S2V5ICsgJ1wiIGRvZXMgbm90IHN1cHBvcnQgaW50ZXJwb2xhdGlvbiBzeW50YXhcXG4nICsgJ1VzZSBhbiBpZGVudGl0eSBwcm9wZXJ0eSBmdW5jdGlvbiBpbnN0ZWFkOiBgeyBcInR5cGVcIjogXCJpZGVudGl0eVwiLCBcInByb3BlcnR5XCI6ICcgKyBKU09OLnN0cmluZ2lmeSh0b2tlbk1hdGNoWzFdKSArICcgfWAuJyldO1xuICAgIH1cbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgaWYgKG9wdGlvbnMubGF5ZXJUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICBpZiAocHJvcGVydHlLZXkgPT09ICd0ZXh0LWZpZWxkJyAmJiBzdHlsZSAmJiAhc3R5bGUuZ2x5cGhzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICd1c2Ugb2YgXCJ0ZXh0LWZpZWxkXCIgcmVxdWlyZXMgYSBzdHlsZSBcImdseXBoc1wiIHByb3BlcnR5JykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUtleSA9PT0gJ3RleHQtZm9udCcgJiYgaXNGdW5jdGlvbiQxKGRlZXBVbmJ1bmRsZSh2YWx1ZSkpICYmIHVuYnVuZGxlKHZhbHVlLnR5cGUpID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcInRleHQtZm9udFwiIGRvZXMgbm90IHN1cHBvcnQgaWRlbnRpdHkgZnVuY3Rpb25zJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB2YWx1ZVNwZWM6IHZhbHVlU3BlYyxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6ICdwcm9wZXJ0eScsXG4gICAgICAgIHByb3BlcnR5VHlwZTogcHJvcGVydHlUeXBlLFxuICAgICAgICBwcm9wZXJ0eUtleTogcHJvcGVydHlLZXlcbiAgICB9KSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGFpbnRQcm9wZXJ0eShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlUHJvcGVydHkob3B0aW9ucywgJ3BhaW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGF5b3V0UHJvcGVydHkob3B0aW9ucykge1xuICAgIHJldHVybiB2YWxpZGF0ZVByb3BlcnR5KG9wdGlvbnMsICdsYXlvdXQnKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVMYXllcihvcHRpb25zKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciBsYXllciA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGlmICghbGF5ZXIudHlwZSAmJiAhbGF5ZXIucmVmKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ2VpdGhlciBcInR5cGVcIiBvciBcInJlZlwiIGlzIHJlcXVpcmVkJykpO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IHVuYnVuZGxlKGxheWVyLnR5cGUpO1xuICAgIHZhciByZWYgPSB1bmJ1bmRsZShsYXllci5yZWYpO1xuICAgIGlmIChsYXllci5pZCkge1xuICAgICAgICB2YXIgbGF5ZXJJZCA9IHVuYnVuZGxlKGxheWVyLmlkKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmFycmF5SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG90aGVyTGF5ZXIgPSBzdHlsZS5sYXllcnNbaV07XG4gICAgICAgICAgICBpZiAodW5idW5kbGUob3RoZXJMYXllci5pZCkgPT09IGxheWVySWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuaWQsICdkdXBsaWNhdGUgbGF5ZXIgaWQgXCInICsgbGF5ZXIuaWQgKyAnXCIsIHByZXZpb3VzbHkgdXNlZCBhdCBsaW5lICcgKyBvdGhlckxheWVyLmlkLl9fbGluZV9fKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdyZWYnIGluIGxheWVyKSB7XG4gICAgICAgIFtcbiAgICAgICAgICAgICd0eXBlJyxcbiAgICAgICAgICAgICdzb3VyY2UnLFxuICAgICAgICAgICAgJ3NvdXJjZS1sYXllcicsXG4gICAgICAgICAgICAnZmlsdGVyJyxcbiAgICAgICAgICAgICdsYXlvdXQnXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgaWYgKHAgaW4gbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXJbcF0sICdcIicgKyBwICsgJ1wiIGlzIHByb2hpYml0ZWQgZm9yIHJlZiBsYXllcnMnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcGFyZW50O1xuICAgICAgICBzdHlsZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGlmICh1bmJ1bmRsZShsYXllci5pZCkgPT09IHJlZikge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGxheWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5yZWYsICdyZWYgbGF5ZXIgXCInICsgcmVmICsgJ1wiIG5vdCBmb3VuZCcpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQucmVmKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIucmVmLCAncmVmIGNhbm5vdCByZWZlcmVuY2UgYW5vdGhlciByZWYgbGF5ZXInKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gdW5idW5kbGUocGFyZW50LnR5cGUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSAnYmFja2dyb3VuZCcpIHtcbiAgICAgICAgaWYgKCFsYXllci5zb3VyY2UpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJzb3VyY2VcIicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzdHlsZS5zb3VyY2VzICYmIHN0eWxlLnNvdXJjZXNbbGF5ZXIuc291cmNlXTtcbiAgICAgICAgICAgIHZhciBzb3VyY2VUeXBlID0gc291cmNlICYmIHVuYnVuZGxlKHNvdXJjZS50eXBlKTtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ3NvdXJjZSBcIicgKyBsYXllci5zb3VyY2UgKyAnXCIgbm90IGZvdW5kJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlID09PSAndmVjdG9yJyAmJiB0eXBlID09PSAncmFzdGVyJykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5zb3VyY2UsICdsYXllciBcIicgKyBsYXllci5pZCArICdcIiByZXF1aXJlcyBhIHJhc3RlciBzb3VyY2UnKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09ICdyYXN0ZXInICYmIHR5cGUgIT09ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ2xheWVyIFwiJyArIGxheWVyLmlkICsgJ1wiIHJlcXVpcmVzIGEgdmVjdG9yIHNvdXJjZScpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3ZlY3RvcicgJiYgIWxheWVyWydzb3VyY2UtbGF5ZXInXSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ2xheWVyIFwiJyArIGxheWVyLmlkICsgJ1wiIG11c3Qgc3BlY2lmeSBhIFwic291cmNlLWxheWVyXCInKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09ICdyYXN0ZXItZGVtJyAmJiB0eXBlICE9PSAnaGlsbHNoYWRlJykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5zb3VyY2UsICdyYXN0ZXItZGVtIHNvdXJjZSBjYW4gb25seSBiZSB1c2VkIHdpdGggbGF5ZXIgdHlwZSBcXCdoaWxsc2hhZGVcXCcuJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbGluZScgJiYgbGF5ZXIucGFpbnQgJiYgbGF5ZXIucGFpbnRbJ2xpbmUtZ3JhZGllbnQnXSAmJiAoc291cmNlVHlwZSAhPT0gJ2dlb2pzb24nIHx8ICFzb3VyY2UubGluZU1ldHJpY3MpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnbGF5ZXIgXCInICsgbGF5ZXIuaWQgKyAnXCIgc3BlY2lmaWVzIGEgbGluZS1ncmFkaWVudCwgd2hpY2ggcmVxdWlyZXMgYSBHZW9KU09OIHNvdXJjZSB3aXRoIGBsaW5lTWV0cmljc2AgZW5hYmxlZC4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogbGF5ZXIsXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmxheWVyLFxuICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgICcqJzogZnVuY3Rpb24gXygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogZnVuY3Rpb24gdHlwZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSArICcudHlwZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsYXllci50eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5sYXllci50eXBlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0S2V5OiAndHlwZSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWx0ZXI6IHZhbGlkYXRlRmlsdGVyLFxuICAgICAgICAgICAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllcixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyonOiBmdW5jdGlvbiBfKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVMYXlvdXRQcm9wZXJ0eShleHRlbmQoeyBsYXllclR5cGU6IHR5cGUgfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFpbnQ6IGZ1bmN0aW9uIHBhaW50KG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBsYXllcjogbGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICcqJzogZnVuY3Rpb24gXyhvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlUGFpbnRQcm9wZXJ0eShleHRlbmQoeyBsYXllclR5cGU6IHR5cGUgfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnc3RyaW5nIGV4cGVjdGVkLCAnICsgdHlwZSArICcgZm91bmQnKV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cblxudmFyIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzID0geyBwcm9tb3RlSWQ6IHZhbGlkYXRlUHJvbW90ZUlkIH07XG5mdW5jdGlvbiB2YWxpZGF0ZVNvdXJjZShvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgaWYgKCF2YWx1ZS50eXBlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCJ0eXBlXCIgaXMgcmVxdWlyZWQnKV07XG4gICAgfVxuICAgIHZhciB0eXBlID0gdW5idW5kbGUodmFsdWUudHlwZSk7XG4gICAgdmFyIGVycm9ycztcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd2ZWN0b3InOlxuICAgIGNhc2UgJ3Jhc3Rlcic6XG4gICAgY2FzZSAncmFzdGVyLWRlbSc6XG4gICAgICAgIGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWNbJ3NvdXJjZV8nICsgdHlwZS5yZXBsYWNlKCctJywgJ18nKV0sXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIGNhc2UgJ2dlb2pzb24nOlxuICAgICAgICBlcnJvcnMgPSB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnNvdXJjZV9nZW9qc29uLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczogb2JqZWN0RWxlbWVudFZhbGlkYXRvcnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWx1ZS5jbHVzdGVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbHVlLmNsdXN0ZXJQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZiA9IHZhbHVlLmNsdXN0ZXJQcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHJlZlswXTtcbiAgICAgICAgICAgICAgICB2YXIgbWFwRXhwciA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlRXhwciA9IHR5cGVvZiBvcGVyYXRvciA9PT0gJ3N0cmluZycgPyBbXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBbJ2FjY3VtdWxhdGVkJ10sXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgXSA6IG9wZXJhdG9yO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgdmFsaWRhdGVFeHByZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnLicgKyBwcm9wICsgJy5tYXAnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFwRXhwcixcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6ICdjbHVzdGVyLW1hcCdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCB2YWxpZGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSArICcuJyArIHByb3AgKyAnLnJlZHVjZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZWR1Y2VFeHByLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ2NsdXN0ZXItcmVkdWNlJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX3ZpZGVvLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSk7XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfaW1hZ2UsXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcbiAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBudWxsLCAnUGxlYXNlIHVzZSBydW50aW1lIEFQSXMgdG8gYWRkIGNhbnZhcyBzb3VyY2VzLCByYXRoZXIgdGhhbiBpbmNsdWRpbmcgdGhlbSBpbiBzdHlsZXNoZWV0cy4nLCAnc291cmNlLmNhbnZhcycpXTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVFbnVtKHtcbiAgICAgICAgICAgIGtleToga2V5ICsgJy50eXBlJyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICd2ZWN0b3InLFxuICAgICAgICAgICAgICAgICAgICAncmFzdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3Jhc3Rlci1kZW0nLFxuICAgICAgICAgICAgICAgICAgICAnZ2VvanNvbicsXG4gICAgICAgICAgICAgICAgICAgICd2aWRlbycsXG4gICAgICAgICAgICAgICAgICAgICdpbWFnZSdcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9tb3RlSWQocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlU3RyaW5nKHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCB2YWxpZGF0ZVN0cmluZyh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnLicgKyBwcm9wLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtwcm9wXVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUxpZ2h0KG9wdGlvbnMpIHtcbiAgICB2YXIgbGlnaHQgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgbGlnaHRTcGVjID0gc3R5bGVTcGVjLmxpZ2h0O1xuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciByb290VHlwZSA9IGdldFR5cGUobGlnaHQpO1xuICAgIGlmIChsaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfSBlbHNlIGlmIChyb290VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcignbGlnaHQnLCBsaWdodCwgJ29iamVjdCBleHBlY3RlZCwgJyArIHJvb3RUeXBlICsgJyBmb3VuZCcpXSk7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBsaWdodCkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbk1hdGNoID0ga2V5Lm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuICAgICAgICBpZiAodHJhbnNpdGlvbk1hdGNoICYmIGxpZ2h0U3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dICYmIGxpZ2h0U3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaWdodFtrZXldLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnRyYW5zaXRpb24sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGlnaHRTcGVjW2tleV0pIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaWdodFtrZXldLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogbGlnaHRTcGVjW2tleV0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGlnaHRba2V5XSwgJ3Vua25vd24gcHJvcGVydHkgXCInICsga2V5ICsgJ1wiJyldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdHRlZChvcHRpb25zKSB7XG4gICAgaWYgKHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24ob3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW1hZ2Uob3B0aW9ucykge1xuICAgIGlmICh2YWxpZGF0ZVN0cmluZyhvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVFeHByZXNzaW9uKG9wdGlvbnMpO1xufVxuXG52YXIgVkFMSURBVE9SUyA9IHtcbiAgICAnKic6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgICdhcnJheSc6IHZhbGlkYXRlQXJyYXksXG4gICAgJ2Jvb2xlYW4nOiB2YWxpZGF0ZUJvb2xlYW4sXG4gICAgJ251bWJlcic6IHZhbGlkYXRlTnVtYmVyLFxuICAgICdjb2xvcic6IHZhbGlkYXRlQ29sb3IsXG4gICAgJ2NvbnN0YW50cyc6IHZhbGlkYXRlQ29uc3RhbnRzLFxuICAgICdlbnVtJzogdmFsaWRhdGVFbnVtLFxuICAgICdmaWx0ZXInOiB2YWxpZGF0ZUZpbHRlcixcbiAgICAnZnVuY3Rpb24nOiB2YWxpZGF0ZUZ1bmN0aW9uLFxuICAgICdsYXllcic6IHZhbGlkYXRlTGF5ZXIsXG4gICAgJ29iamVjdCc6IHZhbGlkYXRlT2JqZWN0LFxuICAgICdzb3VyY2UnOiB2YWxpZGF0ZVNvdXJjZSxcbiAgICAnbGlnaHQnOiB2YWxpZGF0ZUxpZ2h0LFxuICAgICdzdHJpbmcnOiB2YWxpZGF0ZVN0cmluZyxcbiAgICAnZm9ybWF0dGVkJzogdmFsaWRhdGVGb3JtYXR0ZWQsXG4gICAgJ3Jlc29sdmVkSW1hZ2UnOiB2YWxpZGF0ZUltYWdlXG59O1xuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICBpZiAodmFsdWVTcGVjLmV4cHJlc3Npb24gJiYgaXNGdW5jdGlvbiQxKHVuYnVuZGxlKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRnVuY3Rpb24ob3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiBpc0V4cHJlc3Npb24oZGVlcFVuYnVuZGxlKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbihvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlU3BlYy50eXBlICYmIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKSB7XG4gICAgICAgIHJldHVybiBWQUxJREFUT1JTW3ZhbHVlU3BlYy50eXBlXShvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsaWQgPSB2YWxpZGF0ZU9iamVjdChleHRlbmQoe30sIG9wdGlvbnMsIHsgdmFsdWVTcGVjOiB2YWx1ZVNwZWMudHlwZSA/IHN0eWxlU3BlY1t2YWx1ZVNwZWMudHlwZV0gOiB2YWx1ZVNwZWMgfSkpO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUdseXBoc1VSTCAob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciBlcnJvcnMgPSB2YWxpZGF0ZVN0cmluZyhvcHRpb25zKTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbiAgICBpZiAodmFsdWUuaW5kZXhPZigne2ZvbnRzdGFja30nKSA9PT0gLTEpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCJnbHlwaHNcIiB1cmwgbXVzdCBpbmNsdWRlIGEgXCJ7Zm9udHN0YWNrfVwiIHRva2VuJykpO1xuICAgIH1cbiAgICBpZiAodmFsdWUuaW5kZXhPZigne3JhbmdlfScpID09PSAtMSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcImdseXBoc1wiIHVybCBtdXN0IGluY2x1ZGUgYSBcIntyYW5nZX1cIiB0b2tlbicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdHlsZU1pbihzdHlsZSwgc3R5bGVTcGVjKSB7XG4gICAgaWYgKHN0eWxlU3BlYyA9PT0gdm9pZCAwKVxuICAgICAgICBzdHlsZVNwZWMgPSB2ODtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgIGtleTogJycsXG4gICAgICAgIHZhbHVlOiBzdHlsZSxcbiAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuJHJvb3QsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICBnbHlwaHM6IHZhbGlkYXRlR2x5cGhzVVJMLFxuICAgICAgICAgICAgJyonOiBmdW5jdGlvbiBfKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICBpZiAoc3R5bGUuY29uc3RhbnRzKSB7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVDb25zdGFudHMoe1xuICAgICAgICAgICAga2V5OiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgIHZhbHVlOiBzdHlsZS5jb25zdGFudHMsXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBzb3J0RXJyb3JzKGVycm9ycyk7XG59XG52YWxpZGF0ZVN0eWxlTWluLnNvdXJjZSA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZVNvdXJjZSk7XG52YWxpZGF0ZVN0eWxlTWluLmxpZ2h0ID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGlnaHQpO1xudmFsaWRhdGVTdHlsZU1pbi5sYXllciA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZUxheWVyKTtcbnZhbGlkYXRlU3R5bGVNaW4uZmlsdGVyID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlRmlsdGVyKTtcbnZhbGlkYXRlU3R5bGVNaW4ucGFpbnRQcm9wZXJ0eSA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZVBhaW50UHJvcGVydHkpO1xudmFsaWRhdGVTdHlsZU1pbi5sYXlvdXRQcm9wZXJ0eSA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZUxheW91dFByb3BlcnR5KTtcbmZ1bmN0aW9uIHNvcnRFcnJvcnMoZXJyb3JzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChlcnJvcnMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEubGluZSAtIGIubGluZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHdyYXBDbGVhbkVycm9ycyhpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW4tLSlcbiAgICAgICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgICByZXR1cm4gc29ydEVycm9ycyhpbm5lci5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgfTtcbn1cblxudmFyIGpzb25saW50ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLyogcGFyc2VyIGdlbmVyYXRlZCBieSBqaXNvbiAwLjQuMTUgKi9cbi8qXG4gIFJldHVybnMgYSBQYXJzZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuXG4gIFBhcnNlcjoge1xuICAgIHl5OiB7fVxuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZToge1xuICAgIHl5OiB7fSxcbiAgICB0cmFjZTogZnVuY3Rpb24oKSxcbiAgICBzeW1ib2xzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IG51bWJlcn0sXG4gICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSwgJCQsIF8kKSxcbiAgICB0YWJsZTogWy4uLl0sXG4gICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0KSxcblxuICAgIGxleGVyOiB7XG4gICAgICAgIEVPRjogMSxcbiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0KSxcbiAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCksXG4gICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSxcbiAgICAgICAgbGV4OiBmdW5jdGlvbigpLFxuICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmFuZ2VzOiBib29sZWFuICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyKVxuICAgICAgICAgICAgZmxleDogYm9vbGVhbiAgICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IGZsZXgtbGlrZSBsZXhpbmcgYmVoYXZpb3VyIHdoZXJlIHRoZSBydWxlcyBhcmUgdGVzdGVkIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoKVxuICAgICAgICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuICAob3B0aW9uYWw6IHRydWUgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGVhY2ggbWF0Y2hpbmcgcmVnZXggdGhlIGFjdGlvbiBjb2RlIGlzIGludm9rZWQ7IHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUpXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpLFxuICAgICAgICBydWxlczogWy4uLl0sXG4gICAgICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICAgIH1cbiAgfVxuXG5cbiAgdG9rZW4gbG9jYXRpb24gaW5mbyAoQCQsIF8kLCBldGMuKToge1xuICAgIGZpcnN0X2xpbmU6IG4sXG4gICAgbGFzdF9saW5lOiBuLFxuICAgIGZpcnN0X2NvbHVtbjogbixcbiAgICBsYXN0X2NvbHVtbjogbixcbiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl0gICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgcmVndWxhciB6ZXJvLWJhc2VkKVxuICB9XG5cblxuICB0aGUgcGFyc2VFcnJvciBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmQgcGFyc2VyIGVycm9yczoge1xuICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpXG4gICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAgfVxuICB3aGlsZSBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBtZW1iZXJzLCBpLmUuIHBhcnNlciBlcnJvcnMgZGVsaXZlciBhIHN1cGVyc2V0IG9mIGF0dHJpYnV0ZXM6IHtcbiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAgICBleHBlY3RlZDogICAgKHN0cmluZyBkZXNjcmliaW5nIHRoZSBzZXQgb2YgZXhwZWN0ZWQgdG9rZW5zKVxuICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgaGFzIGEgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAgfVxuKi9cbnZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dil7IH1yZXR1cm4gb30sJFYwPVsxLDEyXSwkVjE9WzEsMTNdLCRWMj1bMSw5XSwkVjM9WzEsMTBdLCRWND1bMSwxMV0sJFY1PVsxLDE0XSwkVjY9WzEsMTVdLCRWNz1bMTQsMTgsMjIsMjRdLCRWOD1bMTgsMjJdLCRWOT1bMjIsMjRdO1xudmFyIHBhcnNlciA9IHt0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7IH0sXG55eToge30sXG5zeW1ib2xzXzoge1wiZXJyb3JcIjoyLFwiSlNPTlN0cmluZ1wiOjMsXCJTVFJJTkdcIjo0LFwiSlNPTk51bWJlclwiOjUsXCJOVU1CRVJcIjo2LFwiSlNPTk51bGxMaXRlcmFsXCI6NyxcIk5VTExcIjo4LFwiSlNPTkJvb2xlYW5MaXRlcmFsXCI6OSxcIlRSVUVcIjoxMCxcIkZBTFNFXCI6MTEsXCJKU09OVGV4dFwiOjEyLFwiSlNPTlZhbHVlXCI6MTMsXCJFT0ZcIjoxNCxcIkpTT05PYmplY3RcIjoxNSxcIkpTT05BcnJheVwiOjE2LFwie1wiOjE3LFwifVwiOjE4LFwiSlNPTk1lbWJlckxpc3RcIjoxOSxcIkpTT05NZW1iZXJcIjoyMCxcIjpcIjoyMSxcIixcIjoyMixcIltcIjoyMyxcIl1cIjoyNCxcIkpTT05FbGVtZW50TGlzdFwiOjI1LFwiJGFjY2VwdFwiOjAsXCIkZW5kXCI6MX0sXG50ZXJtaW5hbHNfOiB7MjpcImVycm9yXCIsNDpcIlNUUklOR1wiLDY6XCJOVU1CRVJcIiw4OlwiTlVMTFwiLDEwOlwiVFJVRVwiLDExOlwiRkFMU0VcIiwxNDpcIkVPRlwiLDE3Olwie1wiLDE4OlwifVwiLDIxOlwiOlwiLDIyOlwiLFwiLDIzOlwiW1wiLDI0OlwiXVwifSxcbnByb2R1Y3Rpb25zXzogWzAsWzMsMV0sWzUsMV0sWzcsMV0sWzksMV0sWzksMV0sWzEyLDJdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxNSwyXSxbMTUsM10sWzIwLDNdLFsxOSwxXSxbMTksM10sWzE2LDJdLFsxNiwzXSxbMjUsMV0sWzI1LDNdXSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlIC8qIGFjdGlvblsxXSAqLywgJCQgLyogdnN0YWNrICovLCBfJCAvKiBsc3RhY2sgKi8pIHtcbi8qIHRoaXMgPT0geXl2YWwgKi9cblxudmFyICQwID0gJCQubGVuZ3RoIC0gMTtcbnN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAxOlxuIC8vIHJlcGxhY2UgZXNjYXBlZCBjaGFyYWN0ZXJzIHdpdGggYWN0dWFsIGNoYXJhY3RlclxuICAgICAgICAgIHRoaXMuJCA9IG5ldyBTdHJpbmcoeXl0ZXh0LnJlcGxhY2UoL1xcXFwoXFxcXHxcIikvZywgXCIkXCIrXCIxXCIpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXG4vZywnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcci9nLCdcXHInKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx0L2csJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHYvZywnXFx2JylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcZi9nLCdcXGYnKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxiL2csJ1xcYicpKTtcbiAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSAgdGhpcy5fJC5maXJzdF9saW5lO1xuICAgICAgICBcbmJyZWFrO1xuY2FzZSAyOlxuXG4gICAgICAgICAgICB0aGlzLiQgPSBuZXcgTnVtYmVyKHl5dGV4dCk7XG4gICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSAgdGhpcy5fJC5maXJzdF9saW5lO1xuICAgICAgICBcbmJyZWFrO1xuY2FzZSAzOlxuXG4gICAgICAgICAgICB0aGlzLiQgPSBudWxsO1xuICAgICAgICBcbmJyZWFrO1xuY2FzZSA0OlxuXG4gICAgICAgICAgICB0aGlzLiQgPSBuZXcgQm9vbGVhbih0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9IHRoaXMuXyQuZmlyc3RfbGluZTtcbiAgICAgICAgXG5icmVhaztcbmNhc2UgNTpcblxuICAgICAgICAgICAgdGhpcy4kID0gbmV3IEJvb2xlYW4oZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4kLl9fbGluZV9fID0gdGhpcy5fJC5maXJzdF9saW5lO1xuICAgICAgICBcbmJyZWFrO1xuY2FzZSA2OlxucmV0dXJuIHRoaXMuJCA9ICQkWyQwLTFdO1xuY2FzZSAxMzpcbnRoaXMuJCA9IHt9OyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG5icmVhaztcbmNhc2UgMTQ6IGNhc2UgMTk6XG50aGlzLiQgPSAkJFskMC0xXTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuJCwgJ19fbGluZV9fJywge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuXyQuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuYnJlYWs7XG5jYXNlIDE1OlxudGhpcy4kID0gWyQkWyQwLTJdLCAkJFskMF1dO1xuYnJlYWs7XG5jYXNlIDE2OlxudGhpcy4kID0ge307IHRoaXMuJFskJFskMF1bMF1dID0gJCRbJDBdWzFdO1xuYnJlYWs7XG5jYXNlIDE3OlxudGhpcy4kID0gJCRbJDAtMl07ICQkWyQwLTJdWyQkWyQwXVswXV0gPSAkJFskMF1bMV07XG5icmVhaztcbmNhc2UgMTg6XG50aGlzLiQgPSBbXTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuJCwgJ19fbGluZV9fJywge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuXyQuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuYnJlYWs7XG5jYXNlIDIwOlxudGhpcy4kID0gWyQkWyQwXV07XG5icmVhaztcbmNhc2UgMjE6XG50aGlzLiQgPSAkJFskMC0yXTsgJCRbJDAtMl0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG59XG59LFxudGFibGU6IFt7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTI6MSwxMzoyLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2fSx7MTpbM119LHsxNDpbMSwxNl19LG8oJFY3LFsyLDddKSxvKCRWNyxbMiw4XSksbygkVjcsWzIsOV0pLG8oJFY3LFsyLDEwXSksbygkVjcsWzIsMTFdKSxvKCRWNyxbMiwxMl0pLG8oJFY3LFsyLDNdKSxvKCRWNyxbMiw0XSksbygkVjcsWzIsNV0pLG8oWzE0LDE4LDIxLDIyLDI0XSxbMiwxXSksbygkVjcsWzIsMl0pLHszOjIwLDQ6JFYwLDE4OlsxLDE3XSwxOToxOCwyMDoxOX0sezM6NSw0OiRWMCw1OjYsNjokVjEsNzozLDg6JFYyLDk6NCwxMDokVjMsMTE6JFY0LDEzOjIzLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2LDI0OlsxLDIxXSwyNToyMn0sezE6WzIsNl19LG8oJFY3LFsyLDEzXSksezE4OlsxLDI0XSwyMjpbMSwyNV19LG8oJFY4LFsyLDE2XSksezIxOlsxLDI2XX0sbygkVjcsWzIsMThdKSx7MjI6WzEsMjhdLDI0OlsxLDI3XX0sbygkVjksWzIsMjBdKSxvKCRWNyxbMiwxNF0pLHszOjIwLDQ6JFYwLDIwOjI5fSx7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTM6MzAsMTU6NywxNjo4LDE3OiRWNSwyMzokVjZ9LG8oJFY3LFsyLDE5XSksezM6NSw0OiRWMCw1OjYsNjokVjEsNzozLDg6JFYyLDk6NCwxMDokVjMsMTE6JFY0LDEzOjMxLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2fSxvKCRWOCxbMiwxN10pLG8oJFY4LFsyLDE1XSksbygkVjksWzIsMjFdKV0sXG5kZWZhdWx0QWN0aW9uczogezE2OlsyLDZdfSxcbnBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgaWYgKGhhc2gucmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHN0YWNrID0gWzBdLCB2c3RhY2sgPSBbbnVsbF0sIGxzdGFjayA9IFtdLCB0YWJsZSA9IHRoaXMudGFibGUsIHl5dGV4dCA9ICcnLCB5eWxpbmVubyA9IDAsIHl5bGVuZyA9IDAsIFRFUlJPUiA9IDIsIEVPRiA9IDE7XG4gICAgdmFyIGFyZ3MgPSBsc3RhY2suc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBsZXhlciA9IE9iamVjdC5jcmVhdGUodGhpcy5sZXhlcik7XG4gICAgdmFyIHNoYXJlZFN0YXRlID0geyB5eToge30gfTtcbiAgICBmb3IgKHZhciBrIGluIHRoaXMueXkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnl5LCBrKSkge1xuICAgICAgICAgICAgc2hhcmVkU3RhdGUueXlba10gPSB0aGlzLnl5W2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxleGVyLnNldElucHV0KGlucHV0LCBzaGFyZWRTdGF0ZS55eSk7XG4gICAgc2hhcmVkU3RhdGUueXkubGV4ZXIgPSBsZXhlcjtcbiAgICBzaGFyZWRTdGF0ZS55eS5wYXJzZXIgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgbGV4ZXIueXlsbG9jID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxleGVyLnl5bGxvYyA9IHt9O1xuICAgIH1cbiAgICB2YXIgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgbHN0YWNrLnB1c2goeXlsb2MpO1xuICAgIHZhciByYW5nZXMgPSBsZXhlci5vcHRpb25zICYmIGxleGVyLm9wdGlvbnMucmFuZ2VzO1xuICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZUVycm9yO1xuICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5sZXgoKSB8fCBFT0Y7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICB2YXIgc3ltYm9sLCBzdGF0ZSwgYWN0aW9uLCByLCB5eXZhbCA9IHt9LCBwLCBsZW4sIG5ld1N0YXRlLCBleHBlY3RlZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICd1bmRlZmluZWQnIHx8ICFhY3Rpb24ubGVuZ3RoIHx8ICFhY3Rpb25bMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyU3RyID0gJyc7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHAgaW4gdGFibGVbc3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IFRFUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQucHVzaCgnXFwnJyArIHRoaXMudGVybWluYWxzX1twXSArICdcXCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV4ZXIuc2hvd1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6XFxuJyArIGxleGVyLnNob3dQb3NpdGlvbigpICsgJ1xcbkV4cGVjdGluZyAnICsgZXhwZWN0ZWQuam9pbignLCAnKSArICcsIGdvdCBcXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXFwnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnICsgKHl5bGluZW5vICsgMSkgKyAnOiBVbmV4cGVjdGVkICcgKyAoc3ltYm9sID09IEVPRiA/ICdlbmQgb2YgaW5wdXQnIDogJ1xcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcXCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGV4ZXIueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgICAgIGxvYzogeXlsb2MsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6ICcgKyBzdGF0ZSArICcsIHRva2VuOiAnICsgc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaChsZXhlci55eXRleHQpO1xuICAgICAgICAgICAgbHN0YWNrLnB1c2gobGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTtcbiAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeXlsZW5nID0gbGV4ZXIueXlsZW5nO1xuICAgICAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgICAgICAgICB5eWxpbmVubyA9IGxleGVyLnl5bGluZW5vO1xuICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGxlbiA9IHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMV07XG4gICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGggLSBsZW5dO1xuICAgICAgICAgICAgeXl2YWwuXyQgPSB7XG4gICAgICAgICAgICAgICAgZmlyc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2NvbHVtblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5yYW5nZVswXSxcbiAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5yYW5nZVsxXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmFwcGx5KHl5dmFsLCBbXG4gICAgICAgICAgICAgICAgeXl0ZXh0LFxuICAgICAgICAgICAgICAgIHl5bGVuZyxcbiAgICAgICAgICAgICAgICB5eWxpbmVubyxcbiAgICAgICAgICAgICAgICBzaGFyZWRTdGF0ZS55eSxcbiAgICAgICAgICAgICAgICBhY3Rpb25bMV0sXG4gICAgICAgICAgICAgICAgdnN0YWNrLFxuICAgICAgICAgICAgICAgIGxzdGFja1xuICAgICAgICAgICAgXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4gKiAyKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sgPSB2c3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXVtzdGFja1tzdGFjay5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn19O1xuLyogZ2VuZXJhdGVkIGJ5IGppc29uLWxleCAwLjMuNCAqL1xudmFyIGxleGVyID0gKGZ1bmN0aW9uKCl7XG52YXIgbGV4ZXIgPSAoe1xuXG5FT0Y6MSxcblxucGFyc2VFcnJvcjpmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcbiAgICAgICAgICAgIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmVzZXRzIHRoZSBsZXhlciwgc2V0cyBuZXcgaW5wdXRcbnNldElucHV0OmZ1bmN0aW9uIChpbnB1dCwgeXkpIHtcbiAgICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0aGlzLl9iYWNrdHJhY2sgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiAwLFxuICAgICAgICAgICAgbGFzdF9saW5lOiAxLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gWzAsMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBjb25zdW1lcyBhbmQgcmV0dXJucyBvbmUgY2hhciBmcm9tIHRoZSBpbnB1dFxuaW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuXG4vLyB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYSBzdHJpbmcpIGludG8gdGhlIGlucHV0XG51bnB1dDpmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbik7XG4gICAgICAgIC8vdGhpcy55eWxlbmcgLT0gbGVuO1xuICAgICAgICB0aGlzLm9mZnNldCAtPSBsZW47XG4gICAgICAgIHZhciBvbGRMaW5lcyA9IHRoaXMubWF0Y2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guc3Vic3RyKDAsIHRoaXMubWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcblxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgIChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApXG4gICAgICAgICAgICAgICAgICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGggOlxuICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gLSBsZW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbclswXSwgclswXSArIHRoaXMueXlsZW5nIC0gbGVuXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIGNhY2hlcyBtYXRjaGVkIHRleHQgYW5kIGFwcGVuZHMgaXQgb24gbmV4dCBhY3Rpb25cbm1vcmU6ZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIHNpZ25hbHMgdGhlIGxleGVyIHRoYXQgdGhpcyBydWxlIGZhaWxzIHRvIG1hdGNoIHRoZSBpbnB1dCwgc28gdGhlIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbnJlamVjdDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gWW91IGNhbiBvbmx5IGludm9rZSByZWplY3QoKSBpbiB0aGUgbGV4ZXIgd2hlbiB0aGUgbGV4ZXIgaXMgb2YgdGhlIGJhY2t0cmFja2luZyBwZXJzdWFzaW9uIChvcHRpb25zLmJhY2t0cmFja19sZXhlciA9IHRydWUpLlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIHJldGFpbiBmaXJzdCBuIGNoYXJhY3RlcnMgb2YgdGhlIG1hdGNoXG5sZXNzOmZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgYWxyZWFkeSBtYXRjaGVkIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xucGFzdElucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nOicnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIHVwY29taW5nIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xudXBjb21pbmdJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDtcbiAgICAgICAgaWYgKG5leHQubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwLW5leHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5leHQuc3Vic3RyKDAsMjApICsgKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJyA6ICcnKSkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdGhlIGxleGluZyBlcnJvciBvY2N1cnJlZCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnNob3dQb3NpdGlvbjpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dCgpO1xuICAgICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbihcIi1cIik7XG4gICAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQoKSArIFwiXFxuXCIgKyBjICsgXCJeXCI7XG4gICAgfSxcblxuLy8gdGVzdCB0aGUgbGV4ZWQgdG9rZW46IHJldHVybiBGQUxTRSB3aGVuIG5vdCBhIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIHRva2VuXG50ZXN0X21hdGNoOmZ1bmN0aW9uIChtYXRjaCwgaW5kZXhlZF9ydWxlKSB7XG4gICAgICAgIHZhciB0b2tlbixcbiAgICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgICAgYmFja3VwO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGNvbnRleHRcbiAgICAgICAgICAgIGJhY2t1cCA9IHtcbiAgICAgICAgICAgICAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubyxcbiAgICAgICAgICAgICAgICB5eWxsb2M6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeXl0ZXh0OiB0aGlzLnl5dGV4dCxcbiAgICAgICAgICAgICAgICBtYXRjaDogdGhpcy5tYXRjaCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZDogdGhpcy5tYXRjaGVkLFxuICAgICAgICAgICAgICAgIHl5bGVuZzogdGhpcy55eWxlbmcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBfbW9yZTogdGhpcy5fbW9yZSxcbiAgICAgICAgICAgICAgICBfaW5wdXQ6IHRoaXMuX2lucHV0LFxuICAgICAgICAgICAgICAgIHl5OiB0aGlzLnl5LFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvblN0YWNrOiB0aGlzLmNvbmRpdGlvblN0YWNrLnNsaWNlKDApLFxuICAgICAgICAgICAgICAgIGRvbmU6IHRoaXMuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgYmFja3VwLnl5bGxvYy5yYW5nZSA9IHRoaXMueXlsbG9jLnJhbmdlLnNsaWNlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1xccj9cXG4/LylbMF0ubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaFswXTtcbiAgICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaFswXTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICs9IHRoaXMueXlsZW5nXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnl5LCB0aGlzLCBpbmRleGVkX3J1bGUsIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgLy8gcmVjb3ZlciBjb250ZXh0XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGJhY2t1cCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBiYWNrdXBba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyB0aGUgbmV4dCBydWxlIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggaW4gaW5wdXRcbm5leHQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tlbixcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgdGVtcE1hdGNoLFxuICAgICAgICAgICAgaW5kZXg7XG4gICAgICAgIGlmICghdGhpcy5fbW9yZSkge1xuICAgICAgICAgICAgdGhpcy55eXRleHQgPSAnJztcbiAgICAgICAgICAgIHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuICAgICAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKHRlbXBNYXRjaCwgcnVsZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyBhIHJ1bGUgTUlTbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZmxleCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaChtYXRjaCwgcnVsZXNbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBVbnJlY29nbml6ZWQgdGV4dC5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuXG5sZXg6ZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG5iZWdpbjpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb24gc3RhY2tcbnBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcHJvZHVjZSB0aGUgbGV4ZXIgcnVsZSBzZXQgd2hpY2ggaXMgYWN0aXZlIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGVcbl9jdXJyZW50UnVsZXM6ZnVuY3Rpb24gX2N1cnJlbnRSdWxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoICYmIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dLnJ1bGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1tcIklOSVRJQUxcIl0ucnVsZXM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlOyB3aGVuIGFuIGluZGV4IGFyZ3VtZW50IGlzIHByb3ZpZGVkIGl0IHByb2R1Y2VzIHRoZSBOLXRoIHByZXZpb3VzIGNvbmRpdGlvbiBzdGF0ZSwgaWYgYXZhaWxhYmxlXG50b3BTdGF0ZTpmdW5jdGlvbiB0b3BTdGF0ZShuKSB7XG4gICAgICAgIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDEgLSBNYXRoLmFicyhuIHx8IDApO1xuICAgICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIklOSVRJQUxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFsaWFzIGZvciBiZWdpbihjb25kaXRpb24pXG5wdXNoU3RhdGU6ZnVuY3Rpb24gcHVzaFN0YXRlKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmJlZ2luKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcmV0dXJuIHRoZSBudW1iZXIgb2Ygc3RhdGVzIGN1cnJlbnRseSBvbiB0aGUgc3RhY2tcbnN0YXRlU3RhY2tTaXplOmZ1bmN0aW9uIHN0YXRlU3RhY2tTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgfSxcbm9wdGlvbnM6IHt9LFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5LHl5XywkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLFlZX1NUQVJUKSB7XG5zd2l0Y2goJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucykge1xuY2FzZSAwOi8qIHNraXAgd2hpdGVzcGFjZSAqL1xuYnJlYWs7XG5jYXNlIDE6cmV0dXJuIDZcbmNhc2UgMjp5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5zdWJzdHIoMSx5eV8ueXlsZW5nLTIpOyByZXR1cm4gNFxuY2FzZSAzOnJldHVybiAxN1xuY2FzZSA0OnJldHVybiAxOFxuY2FzZSA1OnJldHVybiAyM1xuY2FzZSA2OnJldHVybiAyNFxuY2FzZSA3OnJldHVybiAyMlxuY2FzZSA4OnJldHVybiAyMVxuY2FzZSA5OnJldHVybiAxMFxuY2FzZSAxMDpyZXR1cm4gMTFcbmNhc2UgMTE6cmV0dXJuIDhcbmNhc2UgMTI6cmV0dXJuIDE0XG5jYXNlIDEzOnJldHVybiAnSU5WQUxJRCdcbn1cbn0sXG5ydWxlczogWy9eKD86XFxzKykvLC9eKD86KC0/KFswLTldfFsxLTldWzAtOV0rKSkoXFwuWzAtOV0rKT8oW2VFXVstK10/WzAtOV0rKT9cXGIpLywvXig/OlwiKD86XFxcXFtcXFxcXCJiZm5ydC9dfFxcXFx1W2EtZkEtRjAtOV17NH18W15cXFxcXFwwLVxceDA5XFx4MGEtXFx4MWZcIl0pKlwiKS8sL14oPzpcXHspLywvXig/OlxcfSkvLC9eKD86XFxbKS8sL14oPzpcXF0pLywvXig/OiwpLywvXig/OjopLywvXig/OnRydWVcXGIpLywvXig/OmZhbHNlXFxiKS8sL14oPzpudWxsXFxiKS8sL14oPzokKS8sL14oPzouKS9dLFxuY29uZGl0aW9uczoge1wiSU5JVElBTFwiOntcInJ1bGVzXCI6WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTNdLFwiaW5jbHVzaXZlXCI6dHJ1ZX19XG59KTtcbnJldHVybiBsZXhlcjtcbn0pKCk7XG5wYXJzZXIubGV4ZXIgPSBsZXhlcjtcbmZ1bmN0aW9uIFBhcnNlciAoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcbnJldHVybiBuZXcgUGFyc2VyO1xufSkoKTtcblxuXG5pZiAodHlwZW9mIGNvbW1vbmpzUmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29iamVjdCcgIT09ICd1bmRlZmluZWQnKSB7XG5leHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcbmV4cG9ydHMuUGFyc2VyID0gcGFyc2VyLlBhcnNlcjtcbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXIucGFyc2UuYXBwbHkocGFyc2VyLCBhcmd1bWVudHMpOyB9O1xufVxufSk7XG52YXIganNvbmxpbnRfMSA9IGpzb25saW50LnBhcnNlcjtcbnZhciBqc29ubGludF8yID0ganNvbmxpbnQuUGFyc2VyO1xudmFyIGpzb25saW50XzMgPSBqc29ubGludC5wYXJzZTtcblxuZnVuY3Rpb24gcmVhZFN0eWxlKHN0eWxlKSB7XG4gICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycgfHwgc3R5bGUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBqc29ubGludC5wYXJzZShzdHlsZS50b1N0cmluZygpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvciQxKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdHlsZShzdHlsZSwgc3R5bGVTcGVjKSB7XG4gICAgaWYgKHN0eWxlU3BlYyA9PT0gdm9pZCAwKVxuICAgICAgICBzdHlsZVNwZWMgPSB2ODtcbiAgICB2YXIgcyA9IHN0eWxlO1xuICAgIHRyeSB7XG4gICAgICAgIHMgPSByZWFkU3R5bGUocyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gW2VdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVTdHlsZU1pbihzLCBzdHlsZVNwZWMpO1xufVxuXG52YXIgU1VQUE9SVEVEX1NQRUNfVkVSU0lPTiA9IDg7XG52YXIgTUFYX1NPVVJDRVNfSU5fU1RZTEUgPSAxNTtcbmZ1bmN0aW9uIGlzVmFsaWQodmFsdWUsIHJlZ2V4KSB7XG4gICAgaWYgKCF2YWx1ZSB8fCBnZXRUeXBlKHZhbHVlKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhIXZhbHVlLm1hdGNoKHJlZ2V4KTtcbn1cbmZ1bmN0aW9uIGdldFNvdXJjZUNvdW50KHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UudXJsKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UudXJsLnNwbGl0KCcsJykubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFsbG93ZWRLZXlFcnJvcnMob2JqLCBrZXlzLCBwYXRoKSB7XG4gICAgdmFyIGFsbG93ZWQgPSBuZXcgU2V0KGtleXMpO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKCFhbGxvd2VkLmhhcyhrKSkge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwYXRoID8gcGF0aCArICcuJyArIGsgOiBudWxsO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihwcm9wLCBvYmpba10sICdVbnN1cHBvcnRlZCBwcm9wZXJ0eSBcIicgKyBrICsgJ1wiJykpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIGdldFNvdXJjZUVycm9ycyhzb3VyY2UsIGkpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHNvdXJjZUtleXMgPSBbXG4gICAgICAgICd0eXBlJyxcbiAgICAgICAgJ3VybCcsXG4gICAgICAgICd0aWxlU2l6ZSdcbiAgICBdO1xuICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZ2V0QWxsb3dlZEtleUVycm9ycyhzb3VyY2UsIHNvdXJjZUtleXMsICdzb3VyY2UnKSk7XG4gICAgdmFyIHNvdXJjZVVybFBhdHRlcm4gPSAvXm1hcGJveDpcXC9cXC8oW14vXSopJC87XG4gICAgaWYgKCFpc1ZhbGlkKHNvdXJjZS51cmwsIHNvdXJjZVVybFBhdHRlcm4pKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3NvdXJjZXNbJyArIGkgKyAnXScsIHNvdXJjZS51cmwsICdTb3VyY2UgdXJsIG11c3QgYmUgYSB2YWxpZCBNYXBib3ggdGlsZXNldCB1cmwnKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBnZXRTb3VyY2VzRXJyb3JzKHNvdXJjZXMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgIHZhciBzb3VyY2VFcnJvcnMgPSBnZXRTb3VyY2VFcnJvcnMoc291cmNlc1tzXSwgaSk7XG4gICAgICAgIGlmICghc291cmNlRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudCArIGdldFNvdXJjZUNvdW50KHNvdXJjZXNbc10pO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgc291cmNlRXJyb3JzKTtcbiAgICB9KTtcbiAgICBpZiAoY291bnQgPiBNQVhfU09VUkNFU19JTl9TVFlMRSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKCdzb3VyY2VzJywgbnVsbCwgJ1N0eWxlcyBtdXN0IGNvbnRhaW4gJyArIE1BWF9TT1VSQ0VTX0lOX1NUWUxFICsgJyBvciBmZXdlciBzb3VyY2VzJykpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gZ2V0Um9vdEVycm9ycyhzdHlsZSwgc3BlY0tleXMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIG9wdGlvbmFsUm9vdFByb3BlcnRpZXMgPSBbXG4gICAgICAgICdvd25lcicsXG4gICAgICAgICdpZCcsXG4gICAgICAgICdjYWNoZUNvbnRyb2wnLFxuICAgICAgICAnZHJhZnQnLFxuICAgICAgICAnY3JlYXRlZCcsXG4gICAgICAgICdtb2RpZmllZCcsXG4gICAgICAgICd2aXNpYmlsaXR5J1xuICAgIF07XG4gICAgdmFyIGFsbG93ZWRLZXlFcnJvcnMgPSBnZXRBbGxvd2VkS2V5RXJyb3JzKHN0eWxlLCBzcGVjS2V5cy5jb25jYXQob3B0aW9uYWxSb290UHJvcGVydGllcykpO1xuICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgYWxsb3dlZEtleUVycm9ycyk7XG4gICAgaWYgKHN0eWxlLnZlcnNpb24gPiBTVVBQT1JURURfU1BFQ19WRVJTSU9OIHx8IHN0eWxlLnZlcnNpb24gPCBTVVBQT1JURURfU1BFQ19WRVJTSU9OKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3ZlcnNpb24nLCBzdHlsZS52ZXJzaW9uLCAnU3R5bGUgdmVyc2lvbiBtdXN0IGJlICcgKyBTVVBQT1JURURfU1BFQ19WRVJTSU9OKSk7XG4gICAgfVxuICAgIHZhciBnbHlwaFVybFBhdHRlcm4gPSAvXm1hcGJveDpcXC9cXC9mb250c1xcLyhbXi9dKilcXC97Zm9udHN0YWNrfVxcL3tyYW5nZX0ucGJmJC87XG4gICAgaWYgKCFpc1ZhbGlkKHN0eWxlLmdseXBocywgZ2x5cGhVcmxQYXR0ZXJuKSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKCdnbHlwaHMnLCBzdHlsZS5nbHlwaHMsICdTdHlsZXMgbXVzdCByZWZlcmVuY2UgZ2x5cGhzIGhvc3RlZCBieSBNYXBib3gnKSk7XG4gICAgfVxuICAgIHZhciBzcHJpdGVVcmxQYXR0ZXJuID0gL15tYXBib3g6XFwvXFwvc3ByaXRlc1xcLyhbXi9dKilcXC8oW14vXSopXFwvPyhbXi9dKik/JC87XG4gICAgaWYgKCFpc1ZhbGlkKHN0eWxlLnNwcml0ZSwgc3ByaXRlVXJsUGF0dGVybikpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcignc3ByaXRlJywgc3R5bGUuc3ByaXRlLCAnU3R5bGVzIG11c3QgcmVmZXJlbmNlIHNwcml0ZXMgaG9zdGVkIGJ5IE1hcGJveCcpKTtcbiAgICB9XG4gICAgdmFyIHZpc2liaWxpdHlQYXR0ZXJuID0gL14ocHVibGljfHByaXZhdGUpJC87XG4gICAgaWYgKCFpc1ZhbGlkKHN0eWxlLnZpc2liaWxpdHksIHZpc2liaWxpdHlQYXR0ZXJuKSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKCd2aXNpYmlsaXR5Jywgc3R5bGUudmlzaWJpbGl0eSwgJ1N0eWxlIHZpc2liaWxpdHkgbXVzdCBiZSBwdWJsaWMgb3IgcHJpdmF0ZScpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWFwYm94QXBpU3VwcG9ydGVkKHN0eWxlKSB7XG4gICAgdmFyIHMgPSBzdHlsZTtcbiAgICB0cnkge1xuICAgICAgICBzID0gcmVhZFN0eWxlKHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFtlXTtcbiAgICB9XG4gICAgdmFyIGVycm9ycyA9IHZhbGlkYXRlU3R5bGVNaW4ocywgdjgpLmNvbmNhdChnZXRSb290RXJyb3JzKHMsIE9iamVjdC5rZXlzKHY4LiRyb290KSkpO1xuICAgIGlmIChzLnNvdXJjZXMpIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChnZXRTb3VyY2VzRXJyb3JzKHMuc291cmNlcykpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG52YXIgZXhwcmVzc2lvbiQxID0ge1xuICAgIFN0eWxlRXhwcmVzc2lvbjogU3R5bGVFeHByZXNzaW9uLFxuICAgIGlzRXhwcmVzc2lvbjogaXNFeHByZXNzaW9uLFxuICAgIGlzRXhwcmVzc2lvbkZpbHRlcjogaXNFeHByZXNzaW9uRmlsdGVyLFxuICAgIGNyZWF0ZUV4cHJlc3Npb246IGNyZWF0ZUV4cHJlc3Npb24sXG4gICAgY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uOiBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24sXG4gICAgbm9ybWFsaXplUHJvcGVydHlFeHByZXNzaW9uOiBub3JtYWxpemVQcm9wZXJ0eUV4cHJlc3Npb24sXG4gICAgWm9vbUNvbnN0YW50RXhwcmVzc2lvbjogWm9vbUNvbnN0YW50RXhwcmVzc2lvbixcbiAgICBab29tRGVwZW5kZW50RXhwcmVzc2lvbjogWm9vbURlcGVuZGVudEV4cHJlc3Npb24sXG4gICAgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uOiBTdHlsZVByb3BlcnR5RnVuY3Rpb25cbn07XG52YXIgc3R5bGVGdW5jdGlvbiA9IHtcbiAgICBjb252ZXJ0RnVuY3Rpb246IGNvbnZlcnRGdW5jdGlvbixcbiAgICBjcmVhdGVGdW5jdGlvbjogY3JlYXRlRnVuY3Rpb24sXG4gICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbiQxXG59O1xudmFyIHZpc2l0ID0ge1xuICAgIGVhY2hTb3VyY2U6IGVhY2hTb3VyY2UsXG4gICAgZWFjaExheWVyOiBlYWNoTGF5ZXIsXG4gICAgZWFjaFByb3BlcnR5OiBlYWNoUHJvcGVydHlcbn07XG52YWxpZGF0ZVN0eWxlLnBhcnNlZCA9IHZhbGlkYXRlU3R5bGU7XG52YWxpZGF0ZVN0eWxlLmxhdGVzdCA9IHZhbGlkYXRlU3R5bGU7XG5cbmV4cG9ydCB7IENvbG9yLCBQYXJzaW5nRXJyb3IkMSBhcyBQYXJzaW5nRXJyb3IsIFZhbGlkYXRpb25FcnJvciwgY29tcG9zaXRlLCBjb252ZXJ0RmlsdGVyJDEgYXMgY29udmVydEZpbHRlciwgZGVyZWZMYXllcnMsIGRpZmZTdHlsZXMgYXMgZGlmZiwgZXhwcmVzc2lvbiQxIGFzIGV4cHJlc3Npb24sIGNyZWF0ZUZpbHRlciBhcyBmZWF0dXJlRmlsdGVyLCBmb3JtYXQsIHN0eWxlRnVuY3Rpb24gYXMgZnVuY3Rpb24sIHY4IGFzIGxhdGVzdCwgbWlncmF0ZSwgdjgsIHZhbGlkYXRlU3R5bGUgYXMgdmFsaWRhdGUsIHZhbGlkYXRlTWFwYm94QXBpU3VwcG9ydGVkLCB2aXNpdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwidmFyIGZvbnRXZWlnaHRzID0ge1xuICB0aGluOiAxMDAsXG4gIGhhaXJsaW5lOiAxMDAsXG4gICd1bHRyYS1saWdodCc6IDEwMCxcbiAgJ2V4dHJhLWxpZ2h0JzogMTAwLFxuICBsaWdodDogMjAwLFxuICBib29rOiAzMDAsXG4gIHJlZ3VsYXI6IDQwMCxcbiAgbm9ybWFsOiA0MDAsXG4gIHBsYWluOiA0MDAsXG4gIHJvbWFuOiA0MDAsXG4gIHN0YW5kYXJkOiA0MDAsXG4gIG1lZGl1bTogNTAwLFxuICAnc2VtaS1ib2xkJzogNjAwLFxuICAnZGVtaS1ib2xkJzogNjAwLFxuICBib2xkOiA3MDAsXG4gIGhlYXZ5OiA4MDAsXG4gIGJsYWNrOiA4MDAsXG4gICdleHRyYS1ib2xkJzogODAwLFxuICAndWx0cmEtYmxhY2snOiA5MDAsXG4gICdleHRyYS1ibGFjayc6IDkwMCxcbiAgJ3VsdHJhLWJvbGQnOiA5MDAsXG4gICdoZWF2eS1ibGFjayc6IDkwMCxcbiAgZmF0OiA5MDAsXG4gIHBvc3RlcjogOTAwXG59O1xudmFyIHNwID0gJyAnO1xudmFyIGl0YWxpY1JFID0gLyhpdGFsaWN8b2JsaXF1ZSkkL2k7XG5cbnZhciBmb250Q2FjaGUgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmb250cywgc2l6ZSwgbGluZUhlaWdodCkge1xuICB2YXIgY3NzRGF0YSA9IGZvbnRDYWNoZVtmb250c107XG4gIGlmICghY3NzRGF0YSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmb250cykpIHtcbiAgICAgIGZvbnRzID0gW2ZvbnRzXTtcbiAgICB9XG4gICAgdmFyIHdlaWdodCA9IDQwMDtcbiAgICB2YXIgc3R5bGUgPSAnbm9ybWFsJztcbiAgICB2YXIgZm9udEZhbWlsaWVzID0gW107XG4gICAgdmFyIGhhdmVXZWlnaHQsIGhhdmVTdHlsZTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmb250cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZm9udCA9IGZvbnRzW2ldO1xuICAgICAgdmFyIHBhcnRzID0gZm9udC5zcGxpdCgnICcpO1xuICAgICAgdmFyIG1heWJlV2VpZ2h0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChtYXliZVdlaWdodCA9PSAnbm9ybWFsJyB8fCBtYXliZVdlaWdodCA9PSAnaXRhbGljJyB8fCBtYXliZVdlaWdodCA9PSAnb2JsaXF1ZScpIHtcbiAgICAgICAgc3R5bGUgPSBoYXZlU3R5bGUgPyBzdHlsZSA6IG1heWJlV2VpZ2h0O1xuICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgICAgbWF5YmVXZWlnaHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSBlbHNlIGlmIChpdGFsaWNSRS50ZXN0KG1heWJlV2VpZ2h0KSkge1xuICAgICAgICBtYXliZVdlaWdodCA9IG1heWJlV2VpZ2h0LnJlcGxhY2UoaXRhbGljUkUsICcnKTtcbiAgICAgICAgc3R5bGUgPSBoYXZlU3R5bGUgPyBzdHlsZSA6IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnJlcGxhY2UobWF5YmVXZWlnaHQsICcnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHcgaW4gZm9udFdlaWdodHMpIHtcbiAgICAgICAgaWYgKG1heWJlV2VpZ2h0ID09IHcgfHwgbWF5YmVXZWlnaHQgPT0gdy5yZXBsYWNlKCctJywgJycpIHx8IG1heWJlV2VpZ2h0ID09IHcucmVwbGFjZSgnLScsIHNwKSkge1xuICAgICAgICAgIHdlaWdodCA9IGhhdmVXZWlnaHQgPyB3ZWlnaHQgOiBmb250V2VpZ2h0c1t3XTtcbiAgICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXZlV2VpZ2h0ICYmIHR5cGVvZiBtYXliZVdlaWdodCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3ZWlnaHQgPSBtYXliZVdlaWdodDtcbiAgICAgIH1cbiAgICAgIHZhciBmb250RmFtaWx5ID0gcGFydHMuam9pbihzcClcbiAgICAgICAgLnJlcGxhY2UoJ0tsb2thbnRlY2ggTm90byBTYW5zJywgJ05vdG8gU2FucycpO1xuICAgICAgaWYgKGZvbnRGYW1pbHkuaW5kZXhPZihzcCkgIT09IC0xKSB7XG4gICAgICAgIGZvbnRGYW1pbHkgPSAnXCInICsgZm9udEZhbWlseSArICdcIic7XG4gICAgICB9XG4gICAgICBmb250RmFtaWxpZXMucHVzaChmb250RmFtaWx5KTtcbiAgICB9XG4gICAgLy8gQ1NTIGZvbnQgcHJvcGVydHk6IGZvbnQtc3R5bGUgZm9udC13ZWlnaHQgZm9udC1zaXplL2xpbmUtaGVpZ2h0IGZvbnQtZmFtaWx5XG4gICAgY3NzRGF0YSA9IGZvbnRDYWNoZVtmb250c10gPSBbc3R5bGUsIHdlaWdodCwgZm9udEZhbWlsaWVzXTtcbiAgfVxuICByZXR1cm4gY3NzRGF0YVswXSArIHNwICsgY3NzRGF0YVsxXSArIHNwICsgc2l6ZSArICdweCcgKyAobGluZUhlaWdodCA/ICcvJyArIGxpbmVIZWlnaHQgOiAnJykgKyBzcCArIGNzc0RhdGFbMl07XG59O1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEwLjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIGZhbWlsaWVzO1xuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGljb246ICdpY29ucy9nb29nbGUuc3ZnJyxcbiAgICBuYW1lOiAnZ29vZ2xlJyxcbiAgICB0aXRsZTogJ0dvb2dsZSBGb250cycsXG4gICAgbGluazogJ2dvb2dsZS5jb20vZm9udHMnLFxuICAgIGdldE5hbWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYW1pbGllcztcbiAgICB9LFxuICAgIGdldExpbms6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vZm9udHMuZ29vZ2xlLmNvbS9zcGVjaW1lbi9cIiArIChuYW1lLnJlcGxhY2UoLyggKS9nLCAnKycpKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfTtcblxuICBmYW1pbGllcyA9IFtcIkFCZWVaZWVcIiwgXCJBYmVsXCIsIFwiQWJyaWwgRmF0ZmFjZVwiLCBcIkFjbG9uaWNhXCIsIFwiQWNtZVwiLCBcIkFjdG9yXCIsIFwiQWRhbWluYVwiLCBcIkFkdmVudCBQcm9cIiwgXCJBZ3VhZmluYSBTY3JpcHRcIiwgXCJBa3JvbmltXCIsIFwiQWxhZGluXCIsIFwiQWxkcmljaFwiLCBcIkFsZWZcIiwgXCJBbGVncmV5YVwiLCBcIkFsZWdyZXlhIFNDXCIsIFwiQWxlZ3JleWEgU2Fuc1wiLCBcIkFsZWdyZXlhIFNhbnMgU0NcIiwgXCJBbGV4IEJydXNoXCIsIFwiQWxmYSBTbGFiIE9uZVwiLCBcIkFsaWNlXCIsIFwiQWxpa2VcIiwgXCJBbGlrZSBBbmd1bGFyXCIsIFwiQWxsYW5cIiwgXCJBbGxlcnRhXCIsIFwiQWxsZXJ0YSBTdGVuY2lsXCIsIFwiQWxsdXJhXCIsIFwiQWxtZW5kcmFcIiwgXCJBbG1lbmRyYSBEaXNwbGF5XCIsIFwiQWxtZW5kcmEgU0NcIiwgXCJBbWFyYW50ZVwiLCBcIkFtYXJhbnRoXCIsIFwiQW1hdGljIFNDXCIsIFwiQW1ldGh5c3RhXCIsIFwiQW1pcmlcIiwgXCJBbWl0YVwiLCBcIkFuYWhlaW1cIiwgXCJBbmRhZGFcIiwgXCJBbmRpa2FcIiwgXCJBbmdrb3JcIiwgXCJBbm5pZSBVc2UgWW91ciBUZWxlc2NvcGVcIiwgXCJBbm9ueW1vdXMgUHJvXCIsIFwiQW50aWNcIiwgXCJBbnRpYyBEaWRvbmVcIiwgXCJBbnRpYyBTbGFiXCIsIFwiQW50b25cIiwgXCJBcmFwZXlcIiwgXCJBcmJ1dHVzXCIsIFwiQXJidXR1cyBTbGFiXCIsIFwiQXJjaGl0ZWN0cyBEYXVnaHRlclwiLCBcIkFyY2hpdm8gQmxhY2tcIiwgXCJBcmNoaXZvIE5hcnJvd1wiLCBcIkFyaW1vXCIsIFwiQXJpem9uaWFcIiwgXCJBcm1hdGFcIiwgXCJBcnRpZmlrYVwiLCBcIkFydm9cIiwgXCJBcnlhXCIsIFwiQXNhcFwiLCBcIkFzYXJcIiwgXCJBc3NldFwiLCBcIkFzdGxvY2hcIiwgXCJBc3VsXCIsIFwiQXRvbWljIEFnZVwiLCBcIkF1YnJleVwiLCBcIkF1ZGlvd2lkZVwiLCBcIkF1dG91ciBPbmVcIiwgXCJBdmVyYWdlXCIsIFwiQXZlcmFnZSBTYW5zXCIsIFwiQXZlcmlhIEdydWVzYSBMaWJyZVwiLCBcIkF2ZXJpYSBMaWJyZVwiLCBcIkF2ZXJpYSBTYW5zIExpYnJlXCIsIFwiQXZlcmlhIFNlcmlmIExpYnJlXCIsIFwiQmFkIFNjcmlwdFwiLCBcIkJhbHRoYXphclwiLCBcIkJhbmdlcnNcIiwgXCJCYXNpY1wiLCBcIkJhdHRhbWJhbmdcIiwgXCJCYXVtYW5zXCIsIFwiQmF5b25cIiwgXCJCZWxncmFub1wiLCBcIkJlbGxlemFcIiwgXCJCZW5jaE5pbmVcIiwgXCJCZW50aGFtXCIsIFwiQmVya3NoaXJlIFN3YXNoXCIsIFwiQmV2YW5cIiwgXCJCaWdlbG93IFJ1bGVzXCIsIFwiQmlnc2hvdCBPbmVcIiwgXCJCaWxib1wiLCBcIkJpbGJvIFN3YXNoIENhcHNcIiwgXCJCaXJ5YW5pXCIsIFwiQml0dGVyXCIsIFwiQmxhY2sgT3BzIE9uZVwiLCBcIkJva29yXCIsIFwiQm9uYm9uXCIsIFwiQm9vZ2Fsb29cIiwgXCJCb3dsYnkgT25lXCIsIFwiQm93bGJ5IE9uZSBTQ1wiLCBcIkJyYXdsZXJcIiwgXCJCcmVlIFNlcmlmXCIsIFwiQnViYmxlZ3VtIFNhbnNcIiwgXCJCdWJibGVyIE9uZVwiLCBcIkJ1ZGFcIiwgXCJCdWVuYXJkXCIsIFwiQnV0Y2hlcm1hblwiLCBcIkJ1dHRlcmZseSBLaWRzXCIsIFwiQ2FiaW5cIiwgXCJDYWJpbiBDb25kZW5zZWRcIiwgXCJDYWJpbiBTa2V0Y2hcIiwgXCJDYWVzYXIgRHJlc3NpbmdcIiwgXCJDYWdsaW9zdHJvXCIsIFwiQ2FsbGlncmFmZml0dGlcIiwgXCJDYW1iYXlcIiwgXCJDYW1ib1wiLCBcIkNhbmRhbFwiLCBcIkNhbnRhcmVsbFwiLCBcIkNhbnRhdGEgT25lXCIsIFwiQ2FudG9yYSBPbmVcIiwgXCJDYXByaW9sYVwiLCBcIkNhcmRvXCIsIFwiQ2FybWVcIiwgXCJDYXJyb2lzIEdvdGhpY1wiLCBcIkNhcnJvaXMgR290aGljIFNDXCIsIFwiQ2FydGVyIE9uZVwiLCBcIkNhdGFtYXJhblwiLCBcIkNhdWRleFwiLCBcIkNhdmVhdFwiLCBcIkNhdmVhdCBCcnVzaFwiLCBcIkNlZGFydmlsbGUgQ3Vyc2l2ZVwiLCBcIkNldmljaGUgT25lXCIsIFwiQ2hhbmdhIE9uZVwiLCBcIkNoYW5nb1wiLCBcIkNoYXUgUGhpbG9tZW5lIE9uZVwiLCBcIkNoZWxhIE9uZVwiLCBcIkNoZWxzZWEgTWFya2V0XCIsIFwiQ2hlbmxhXCIsIFwiQ2hlcnJ5IENyZWFtIFNvZGFcIiwgXCJDaGVycnkgU3dhc2hcIiwgXCJDaGV3eVwiLCBcIkNoaWNsZVwiLCBcIkNoaXZvXCIsIFwiQ2hvbmJ1cmlcIiwgXCJDaW56ZWxcIiwgXCJDaW56ZWwgRGVjb3JhdGl2ZVwiLCBcIkNsaWNrZXIgU2NyaXB0XCIsIFwiQ29kYVwiLCBcIkNvZGEgQ2FwdGlvblwiLCBcIkNvZHlzdGFyXCIsIFwiQ29tYm9cIiwgXCJDb21mb3J0YWFcIiwgXCJDb21pbmcgU29vblwiLCBcIkNvbmNlcnQgT25lXCIsIFwiQ29uZGltZW50XCIsIFwiQ29udGVudFwiLCBcIkNvbnRyYWlsIE9uZVwiLCBcIkNvbnZlcmdlbmNlXCIsIFwiQ29va2llXCIsIFwiQ29wc2VcIiwgXCJDb3JiZW5cIiwgXCJDb3VyZ2V0dGVcIiwgXCJDb3VzaW5lXCIsIFwiQ291c3RhcmRcIiwgXCJDb3ZlcmVkIEJ5IFlvdXIgR3JhY2VcIiwgXCJDcmFmdHkgR2lybHNcIiwgXCJDcmVlcHN0ZXJcIiwgXCJDcmV0ZSBSb3VuZFwiLCBcIkNyaW1zb24gVGV4dFwiLCBcIkNyb2lzc2FudCBPbmVcIiwgXCJDcnVzaGVkXCIsIFwiQ3VwcnVtXCIsIFwiQ3V0aXZlXCIsIFwiQ3V0aXZlIE1vbm9cIiwgXCJEYW1pb25cIiwgXCJEYW5jaW5nIFNjcmlwdFwiLCBcIkRhbmdyZWtcIiwgXCJEYXduaW5nIG9mIGEgTmV3IERheVwiLCBcIkRheXMgT25lXCIsIFwiRGVra29cIiwgXCJEZWxpdXNcIiwgXCJEZWxpdXMgU3dhc2ggQ2Fwc1wiLCBcIkRlbGl1cyBVbmljYXNlXCIsIFwiRGVsbGEgUmVzcGlyYVwiLCBcIkRlbmsgT25lXCIsIFwiRGV2b25zaGlyZVwiLCBcIkRodXJqYXRpXCIsIFwiRGlkYWN0IEdvdGhpY1wiLCBcIkRpcGxvbWF0YVwiLCBcIkRpcGxvbWF0YSBTQ1wiLCBcIkRvbWluZVwiLCBcIkRvbmVnYWwgT25lXCIsIFwiRG9wcGlvIE9uZVwiLCBcIkRvcnNhXCIsIFwiRG9zaXNcIiwgXCJEciBTdWdpeWFtYVwiLCBcIkRyb2lkIFNhbnNcIiwgXCJEcm9pZCBTYW5zIE1vbm9cIiwgXCJEcm9pZCBTZXJpZlwiLCBcIkR1cnUgU2Fuc1wiLCBcIkR5bmFsaWdodFwiLCBcIkVCIEdhcmFtb25kXCIsIFwiRWFnbGUgTGFrZVwiLCBcIkVhdGVyXCIsIFwiRWNvbm9taWNhXCIsIFwiRWN6YXJcIiwgXCJFayBNdWt0YVwiLCBcIkVsZWN0cm9saXplXCIsIFwiRWxzaWVcIiwgXCJFbHNpZSBTd2FzaCBDYXBzXCIsIFwiRW1ibGVtYSBPbmVcIiwgXCJFbWlseXMgQ2FuZHlcIiwgXCJFbmdhZ2VtZW50XCIsIFwiRW5nbGViZXJ0XCIsIFwiRW5yaXF1ZXRhXCIsIFwiRXJpY2EgT25lXCIsIFwiRXN0ZWJhblwiLCBcIkV1cGhvcmlhIFNjcmlwdFwiLCBcIkV3ZXJ0XCIsIFwiRXhvXCIsIFwiRXhvIDJcIiwgXCJFeHBsZXR1cyBTYW5zXCIsIFwiRmFud29vZCBUZXh0XCIsIFwiRmFzY2luYXRlXCIsIFwiRmFzY2luYXRlIElubGluZVwiLCBcIkZhc3RlciBPbmVcIiwgXCJGYXN0aGFuZFwiLCBcIkZhdW5hIE9uZVwiLCBcIkZlZGVyYW50XCIsIFwiRmVkZXJvXCIsIFwiRmVsaXBhXCIsIFwiRmVuaXhcIiwgXCJGaW5nZXIgUGFpbnRcIiwgXCJGaXJhIE1vbm9cIiwgXCJGaXJhIFNhbnNcIiwgXCJGamFsbGEgT25lXCIsIFwiRmpvcmQgT25lXCIsIFwiRmxhbWVuY29cIiwgXCJGbGF2b3JzXCIsIFwiRm9uZGFtZW50b1wiLCBcIkZvbnRkaW5lciBTd2Fua3lcIiwgXCJGb3J1bVwiLCBcIkZyYW5jb2lzIE9uZVwiLCBcIkZyZWNrbGUgRmFjZVwiLCBcIkZyZWRlcmlja2EgdGhlIEdyZWF0XCIsIFwiRnJlZG9rYSBPbmVcIiwgXCJGcmVlaGFuZFwiLCBcIkZyZXNjYVwiLCBcIkZyaWpvbGVcIiwgXCJGcnVrdHVyXCIsIFwiRnVnYXogT25lXCIsIFwiR0ZTIERpZG90XCIsIFwiR0ZTIE5lb2hlbGxlbmljXCIsIFwiR2FicmllbGFcIiwgXCJHYWZhdGFcIiwgXCJHYWxkZWFub1wiLCBcIkdhbGluZG9cIiwgXCJHZW50aXVtIEJhc2ljXCIsIFwiR2VudGl1bSBCb29rIEJhc2ljXCIsIFwiR2VvXCIsIFwiR2Vvc3RhclwiLCBcIkdlb3N0YXIgRmlsbFwiLCBcIkdlcm1hbmlhIE9uZVwiLCBcIkdpZHVndVwiLCBcIkdpbGRhIERpc3BsYXlcIiwgXCJHaXZlIFlvdSBHbG9yeVwiLCBcIkdsYXNzIEFudGlxdWFcIiwgXCJHbGVnb29cIiwgXCJHbG9yaWEgSGFsbGVsdWphaFwiLCBcIkdvYmxpbiBPbmVcIiwgXCJHb2NoaSBIYW5kXCIsIFwiR29yZGl0YXNcIiwgXCJHb3VkeSBCb29rbGV0dGVyIDE5MTFcIiwgXCJHcmFkdWF0ZVwiLCBcIkdyYW5kIEhvdGVsXCIsIFwiR3Jhdml0YXMgT25lXCIsIFwiR3JlYXQgVmliZXNcIiwgXCJHcmlmZnlcIiwgXCJHcnVwcG9cIiwgXCJHdWRlYVwiLCBcIkd1cmFqYWRhXCIsIFwiSGFiaWJpXCIsIFwiSGFsYW50XCIsIFwiSGFtbWVyc21pdGggT25lXCIsIFwiSGFuYWxlaVwiLCBcIkhhbmFsZWkgRmlsbFwiLCBcIkhhbmRsZWVcIiwgXCJIYW51bWFuXCIsIFwiSGFwcHkgTW9ua2V5XCIsIFwiSGVhZGxhbmQgT25lXCIsIFwiSGVubnkgUGVubnlcIiwgXCJIZXJyIFZvbiBNdWVsbGVyaG9mZlwiLCBcIkhpbmRcIiwgXCJIaW5kIFNpbGlndXJpXCIsIFwiSGluZCBWYWRvZGFyYVwiLCBcIkhvbHR3b29kIE9uZSBTQ1wiLCBcIkhvbWVtYWRlIEFwcGxlXCIsIFwiSG9tZW5hamVcIiwgXCJJTSBGZWxsIERXIFBpY2FcIiwgXCJJTSBGZWxsIERXIFBpY2EgU0NcIiwgXCJJTSBGZWxsIERvdWJsZSBQaWNhXCIsIFwiSU0gRmVsbCBEb3VibGUgUGljYSBTQ1wiLCBcIklNIEZlbGwgRW5nbGlzaFwiLCBcIklNIEZlbGwgRW5nbGlzaCBTQ1wiLCBcIklNIEZlbGwgRnJlbmNoIENhbm9uXCIsIFwiSU0gRmVsbCBGcmVuY2ggQ2Fub24gU0NcIiwgXCJJTSBGZWxsIEdyZWF0IFByaW1lclwiLCBcIklNIEZlbGwgR3JlYXQgUHJpbWVyIFNDXCIsIFwiSWNlYmVyZ1wiLCBcIkljZWxhbmRcIiwgXCJJbXByaW1hXCIsIFwiSW5jb25zb2xhdGFcIiwgXCJJbmRlclwiLCBcIkluZGllIEZsb3dlclwiLCBcIkluaWthXCIsIFwiSW5rbnV0IEFudGlxdWFcIiwgXCJJcmlzaCBHcm92ZXJcIiwgXCJJc3RvayBXZWJcIiwgXCJJdGFsaWFuYVwiLCBcIkl0YWxpYW5ub1wiLCBcIkl0aW1cIiwgXCJKYWNxdWVzIEZyYW5jb2lzXCIsIFwiSmFjcXVlcyBGcmFuY29pcyBTaGFkb3dcIiwgXCJKYWxkaVwiLCBcIkppbSBOaWdodHNoYWRlXCIsIFwiSm9ja2V5IE9uZVwiLCBcIkpvbGx5IExvZGdlclwiLCBcIkpvc2VmaW4gU2Fuc1wiLCBcIkpvc2VmaW4gU2xhYlwiLCBcIkpvdGkgT25lXCIsIFwiSnVkc29uXCIsIFwiSnVsZWVcIiwgXCJKdWxpdXMgU2FucyBPbmVcIiwgXCJKdW5nZVwiLCBcIkp1cmFcIiwgXCJKdXN0IEFub3RoZXIgSGFuZFwiLCBcIkp1c3QgTWUgQWdhaW4gRG93biBIZXJlXCIsIFwiS2Fkd2FcIiwgXCJLYWxhbVwiLCBcIkthbWVyb25cIiwgXCJLYW50dW1ydXlcIiwgXCJLYXJsYVwiLCBcIkthcm1hXCIsIFwiS2F1c2hhbiBTY3JpcHRcIiwgXCJLYXZvb25cIiwgXCJLZGFtIFRobW9yXCIsIFwiS2VhbmlhIE9uZVwiLCBcIktlbGx5IFNsYWJcIiwgXCJLZW5pYVwiLCBcIktoYW5kXCIsIFwiS2htZXJcIiwgXCJLaHVsYVwiLCBcIktpdGUgT25lXCIsIFwiS25ld2F2ZVwiLCBcIktvdHRhIE9uZVwiLCBcIktvdWxlblwiLCBcIktyYW5reVwiLCBcIktyZW9uXCIsIFwiS3Jpc3RpXCIsIFwiS3JvbmEgT25lXCIsIFwiS3VyYWxlXCIsIFwiTGEgQmVsbGUgQXVyb3JlXCIsIFwiTGFpbGFcIiwgXCJMYWtraSBSZWRkeVwiLCBcIkxhbmNlbG90XCIsIFwiTGF0ZWVmXCIsIFwiTGF0b1wiLCBcIkxlYWd1ZSBTY3JpcHRcIiwgXCJMZWNrZXJsaSBPbmVcIiwgXCJMZWRnZXJcIiwgXCJMZWt0b25cIiwgXCJMZW1vblwiLCBcIkxpYnJlIEJhc2tlcnZpbGxlXCIsIFwiTGlmZSBTYXZlcnNcIiwgXCJMaWxpdGEgT25lXCIsIFwiTGlseSBTY3JpcHQgT25lXCIsIFwiTGltZWxpZ2h0XCIsIFwiTGluZGVuIEhpbGxcIiwgXCJMb2JzdGVyXCIsIFwiTG9ic3RlciBUd29cIiwgXCJMb25kcmluYSBPdXRsaW5lXCIsIFwiTG9uZHJpbmEgU2hhZG93XCIsIFwiTG9uZHJpbmEgU2tldGNoXCIsIFwiTG9uZHJpbmEgU29saWRcIiwgXCJMb3JhXCIsIFwiTG92ZSBZYSBMaWtlIEEgU2lzdGVyXCIsIFwiTG92ZWQgYnkgdGhlIEtpbmdcIiwgXCJMb3ZlcnMgUXVhcnJlbFwiLCBcIkx1Y2tpZXN0IEd1eVwiLCBcIkx1c2l0YW5hXCIsIFwiTHVzdHJpYVwiLCBcIk1hY29uZG9cIiwgXCJNYWNvbmRvIFN3YXNoIENhcHNcIiwgXCJNYWdyYVwiLCBcIk1haWRlbiBPcmFuZ2VcIiwgXCJNYWtvXCIsIFwiTWFsbGFubmFcIiwgXCJNYW5kYWxpXCIsIFwiTWFyY2VsbHVzXCIsIFwiTWFyY2VsbHVzIFNDXCIsIFwiTWFyY2sgU2NyaXB0XCIsIFwiTWFyZ2FyaW5lXCIsIFwiTWFya28gT25lXCIsIFwiTWFybWVsYWRcIiwgXCJNYXJ0ZWxcIiwgXCJNYXJ0ZWwgU2Fuc1wiLCBcIk1hcnZlbFwiLCBcIk1hdGVcIiwgXCJNYXRlIFNDXCIsIFwiTWF2ZW4gUHJvXCIsIFwiTWNMYXJlblwiLCBcIk1lZGRvblwiLCBcIk1lZGlldmFsU2hhcnBcIiwgXCJNZWR1bGEgT25lXCIsIFwiTWVncmltXCIsIFwiTWVpZSBTY3JpcHRcIiwgXCJNZXJpZW5kYVwiLCBcIk1lcmllbmRhIE9uZVwiLCBcIk1lcnJpd2VhdGhlclwiLCBcIk1lcnJpd2VhdGhlciBTYW5zXCIsIFwiTWV0YWxcIiwgXCJNZXRhbCBNYW5pYVwiLCBcIk1ldGFtb3JwaG91c1wiLCBcIk1ldHJvcGhvYmljXCIsIFwiTWljaHJvbWFcIiwgXCJNaWxvbmdhXCIsIFwiTWlsdG9uaWFuXCIsIFwiTWlsdG9uaWFuIFRhdHRvb1wiLCBcIk1pbml2ZXJcIiwgXCJNaXNzIEZhamFyZG9zZVwiLCBcIk1vZGFrXCIsIFwiTW9kZXJuIEFudGlxdWFcIiwgXCJNb2xlbmdvXCIsIFwiTW9sbGVcIiwgXCJNb25kYVwiLCBcIk1vbm9mZXR0XCIsIFwiTW9ub3RvblwiLCBcIk1vbnNpZXVyIExhIERvdWxhaXNlXCIsIFwiTW9udGFnYVwiLCBcIk1vbnRlelwiLCBcIk1vbnRzZXJyYXRcIiwgXCJNb250c2VycmF0IEFsdGVybmF0ZXNcIiwgXCJNb250c2VycmF0IFN1YnJheWFkYVwiLCBcIk1vdWxcIiwgXCJNb3VscGFsaVwiLCBcIk1vdW50YWlucyBvZiBDaHJpc3RtYXNcIiwgXCJNb3VzZSBNZW1vaXJzXCIsIFwiTXIgQmVkZm9ydFwiLCBcIk1yIERhZm9lXCIsIFwiTXIgRGUgSGF2aWxhbmRcIiwgXCJNcnMgU2FpbnQgRGVsYWZpZWxkXCIsIFwiTXJzIFNoZXBwYXJkc1wiLCBcIk11bGlcIiwgXCJNeXN0ZXJ5IFF1ZXN0XCIsIFwiTlRSXCIsIFwiTmV1Y2hhXCIsIFwiTmV1dG9uXCIsIFwiTmV3IFJvY2tlclwiLCBcIk5ld3MgQ3ljbGVcIiwgXCJOaWNvbm5lXCIsIFwiTml4aWUgT25lXCIsIFwiTm9iaWxlXCIsIFwiTm9rb3JhXCIsIFwiTm9yaWNhblwiLCBcIk5vc2lmZXJcIiwgXCJOb3RoaW5nIFlvdSBDb3VsZCBEb1wiLCBcIk5vdGljaWEgVGV4dFwiLCBcIk5vdG8gU2Fuc1wiLCBcIk5vdG8gU2VyaWZcIiwgXCJOb3ZhIEN1dFwiLCBcIk5vdmEgRmxhdFwiLCBcIk5vdmEgTW9ub1wiLCBcIk5vdmEgT3ZhbFwiLCBcIk5vdmEgUm91bmRcIiwgXCJOb3ZhIFNjcmlwdFwiLCBcIk5vdmEgU2xpbVwiLCBcIk5vdmEgU3F1YXJlXCIsIFwiTnVtYW5zXCIsIFwiTnVuaXRvXCIsIFwiT2RvciBNZWFuIENoZXlcIiwgXCJPZmZzaWRlXCIsIFwiT2xkIFN0YW5kYXJkIFRUXCIsIFwiT2xkZW5idXJnXCIsIFwiT2xlbyBTY3JpcHRcIiwgXCJPbGVvIFNjcmlwdCBTd2FzaCBDYXBzXCIsIFwiT3BlbiBTYW5zXCIsIFwiT3BlbiBTYW5zIENvbmRlbnNlZFwiLCBcIk9yYW5pZW5iYXVtXCIsIFwiT3JiaXRyb25cIiwgXCJPcmVnYW5vXCIsIFwiT3JpZW50YVwiLCBcIk9yaWdpbmFsIFN1cmZlclwiLCBcIk9zd2FsZFwiLCBcIk92ZXIgdGhlIFJhaW5ib3dcIiwgXCJPdmVybG9ja1wiLCBcIk92ZXJsb2NrIFNDXCIsIFwiT3ZvXCIsIFwiT3h5Z2VuXCIsIFwiT3h5Z2VuIE1vbm9cIiwgXCJQVCBNb25vXCIsIFwiUFQgU2Fuc1wiLCBcIlBUIFNhbnMgQ2FwdGlvblwiLCBcIlBUIFNhbnMgTmFycm93XCIsIFwiUFQgU2VyaWZcIiwgXCJQVCBTZXJpZiBDYXB0aW9uXCIsIFwiUGFjaWZpY29cIiwgXCJQYWxhbnF1aW5cIiwgXCJQYWxhbnF1aW4gRGFya1wiLCBcIlBhcHJpa2FcIiwgXCJQYXJpc2llbm5lXCIsIFwiUGFzc2VybyBPbmVcIiwgXCJQYXNzaW9uIE9uZVwiLCBcIlBhdGh3YXkgR290aGljIE9uZVwiLCBcIlBhdHJpY2sgSGFuZFwiLCBcIlBhdHJpY2sgSGFuZCBTQ1wiLCBcIlBhdHVhIE9uZVwiLCBcIlBheXRvbmUgT25lXCIsIFwiUGVkZGFuYVwiLCBcIlBlcmFsdGFcIiwgXCJQZXJtYW5lbnQgTWFya2VyXCIsIFwiUGV0aXQgRm9ybWFsIFNjcmlwdFwiLCBcIlBldHJvbmFcIiwgXCJQaGlsb3NvcGhlclwiLCBcIlBpZWRyYVwiLCBcIlBpbnlvbiBTY3JpcHRcIiwgXCJQaXJhdGEgT25lXCIsIFwiUGxhc3RlclwiLCBcIlBsYXlcIiwgXCJQbGF5YmFsbFwiLCBcIlBsYXlmYWlyIERpc3BsYXlcIiwgXCJQbGF5ZmFpciBEaXNwbGF5IFNDXCIsIFwiUG9ka292YVwiLCBcIlBvaXJldCBPbmVcIiwgXCJQb2xsZXIgT25lXCIsIFwiUG9seVwiLCBcIlBvbXBpZXJlXCIsIFwiUG9udGFubyBTYW5zXCIsIFwiUG9wcGluc1wiLCBcIlBvcnQgTGxpZ2F0IFNhbnNcIiwgXCJQb3J0IExsaWdhdCBTbGFiXCIsIFwiUHJhZ2F0aSBOYXJyb3dcIiwgXCJQcmF0YVwiLCBcIlByZWFodmloZWFyXCIsIFwiUHJlc3MgU3RhcnQgMlBcIiwgXCJQcmluY2VzcyBTb2ZpYVwiLCBcIlByb2Npb25vXCIsIFwiUHJvc3RvIE9uZVwiLCBcIlB1cml0YW5cIiwgXCJQdXJwbGUgUHVyc2VcIiwgXCJRdWFuZG9cIiwgXCJRdWFudGljb1wiLCBcIlF1YXR0cm9jZW50b1wiLCBcIlF1YXR0cm9jZW50byBTYW5zXCIsIFwiUXVlc3RyaWFsXCIsIFwiUXVpY2tzYW5kXCIsIFwiUXVpbnRlc3NlbnRpYWxcIiwgXCJRd2lnbGV5XCIsIFwiUmFjaW5nIFNhbnMgT25lXCIsIFwiUmFkbGV5XCIsIFwiUmFqZGhhbmlcIiwgXCJSYWxld2F5XCIsIFwiUmFsZXdheSBEb3RzXCIsIFwiUmFtYWJoYWRyYVwiLCBcIlJhbWFyYWphXCIsIFwiUmFtYmxhXCIsIFwiUmFtbWV0dG8gT25lXCIsIFwiUmFuY2hlcnNcIiwgXCJSYW5jaG9cIiwgXCJSYW5nYVwiLCBcIlJhdGlvbmFsZVwiLCBcIlJhdmkgUHJha2FzaFwiLCBcIlJlZHJlc3NlZFwiLCBcIlJlZW5pZSBCZWFuaWVcIiwgXCJSZXZhbGlhXCIsIFwiUmhvZGl1bSBMaWJyZVwiLCBcIlJpYmV5ZVwiLCBcIlJpYmV5ZSBNYXJyb3dcIiwgXCJSaWdodGVvdXNcIiwgXCJSaXNxdWVcIiwgXCJSb2JvdG9cIiwgXCJSb2JvdG8gQ29uZGVuc2VkXCIsIFwiUm9ib3RvIE1vbm9cIiwgXCJSb2JvdG8gU2xhYlwiLCBcIlJvY2hlc3RlclwiLCBcIlJvY2sgU2FsdFwiLCBcIlJva2tpdHRcIiwgXCJSb21hbmVzY29cIiwgXCJSb3BhIFNhbnNcIiwgXCJSb3NhcmlvXCIsIFwiUm9zYXJpdm9cIiwgXCJSb3VnZSBTY3JpcHRcIiwgXCJSb3poYSBPbmVcIiwgXCJSdWJpa1wiLCBcIlJ1YmlrIE1vbm8gT25lXCIsIFwiUnViaWsgT25lXCIsIFwiUnVkYVwiLCBcIlJ1ZmluYVwiLCBcIlJ1Z2UgQm9vZ2llXCIsIFwiUnVsdWtvXCIsIFwiUnVtIFJhaXNpblwiLCBcIlJ1c2xhbiBEaXNwbGF5XCIsIFwiUnVzc28gT25lXCIsIFwiUnV0aGllXCIsIFwiUnllXCIsIFwiU2FjcmFtZW50b1wiLCBcIlNhaGl0eWFcIiwgXCJTYWlsXCIsIFwiU2Fsc2FcIiwgXCJTYW5jaGV6XCIsIFwiU2FuY3JlZWtcIiwgXCJTYW5zaXRhIE9uZVwiLCBcIlNhcmFsYVwiLCBcIlNhcmluYVwiLCBcIlNhcnBhbmNoXCIsIFwiU2F0aXNmeVwiLCBcIlNjYWRhXCIsIFwiU2NoZWhlcmF6YWRlXCIsIFwiU2Nob29sYmVsbFwiLCBcIlNlYXdlZWQgU2NyaXB0XCIsIFwiU2V2aWxsYW5hXCIsIFwiU2V5bW91ciBPbmVcIiwgXCJTaGFkb3dzIEludG8gTGlnaHRcIiwgXCJTaGFkb3dzIEludG8gTGlnaHQgVHdvXCIsIFwiU2hhbnRpXCIsIFwiU2hhcmVcIiwgXCJTaGFyZSBUZWNoXCIsIFwiU2hhcmUgVGVjaCBNb25vXCIsIFwiU2hvanVtYXJ1XCIsIFwiU2hvcnQgU3RhY2tcIiwgXCJTaWVtcmVhcFwiLCBcIlNpZ21hciBPbmVcIiwgXCJTaWduaWthXCIsIFwiU2lnbmlrYSBOZWdhdGl2ZVwiLCBcIlNpbW9uZXR0YVwiLCBcIlNpbnRvbnlcIiwgXCJTaXJpbiBTdGVuY2lsXCIsIFwiU2l4IENhcHNcIiwgXCJTa3JhbmppXCIsIFwiU2xhYm8gMTNweFwiLCBcIlNsYWJvIDI3cHhcIiwgXCJTbGFja2V5XCIsIFwiU21va3VtXCIsIFwiU215dGhlXCIsIFwiU25pZ2xldFwiLCBcIlNuaXBwZXRcIiwgXCJTbm93YnVyc3QgT25lXCIsIFwiU29mYWRpIE9uZVwiLCBcIlNvZmlhXCIsIFwiU29uc2llIE9uZVwiLCBcIlNvcnRzIE1pbGwgR291ZHlcIiwgXCJTb3VyY2UgQ29kZSBQcm9cIiwgXCJTb3VyY2UgU2FucyBQcm9cIiwgXCJTb3VyY2UgU2VyaWYgUHJvXCIsIFwiU3BlY2lhbCBFbGl0ZVwiLCBcIlNwaWN5IFJpY2VcIiwgXCJTcGlubmFrZXJcIiwgXCJTcGlyYXhcIiwgXCJTcXVhZGEgT25lXCIsIFwiU3JlZSBLcnVzaG5hZGV2YXJheWFcIiwgXCJTdGFsZW1hdGVcIiwgXCJTdGFsaW5pc3QgT25lXCIsIFwiU3RhcmRvcyBTdGVuY2lsXCIsIFwiU3RpbnQgVWx0cmEgQ29uZGVuc2VkXCIsIFwiU3RpbnQgVWx0cmEgRXhwYW5kZWRcIiwgXCJTdG9rZVwiLCBcIlN0cmFpdFwiLCBcIlN1ZSBFbGxlbiBGcmFuY2lzY29cIiwgXCJTdW1hbmFcIiwgXCJTdW5zaGluZXlcIiwgXCJTdXBlcm1lcmNhZG8gT25lXCIsIFwiU3VyYVwiLCBcIlN1cmFubmFcIiwgXCJTdXJhdmFyYW1cIiwgXCJTdXdhbm5hcGh1bVwiLCBcIlN3YW5reSBhbmQgTW9vIE1vb1wiLCBcIlN5bmNvcGF0ZVwiLCBcIlRhbmdlcmluZVwiLCBcIlRhcHJvbVwiLCBcIlRhdXJpXCIsIFwiVGVrb1wiLCBcIlRlbGV4XCIsIFwiVGVuYWxpIFJhbWFrcmlzaG5hXCIsIFwiVGVub3IgU2Fuc1wiLCBcIlRleHQgTWUgT25lXCIsIFwiVGhlIEdpcmwgTmV4dCBEb29yXCIsIFwiVGllbm5lXCIsIFwiVGlsbGFuYVwiLCBcIlRpbW1hbmFcIiwgXCJUaW5vc1wiLCBcIlRpdGFuIE9uZVwiLCBcIlRpdGlsbGl1bSBXZWJcIiwgXCJUcmFkZSBXaW5kc1wiLCBcIlRyb2NjaGlcIiwgXCJUcm9jaHV0XCIsIFwiVHJ5a2tlclwiLCBcIlR1bHBlbiBPbmVcIiwgXCJVYnVudHVcIiwgXCJVYnVudHUgQ29uZGVuc2VkXCIsIFwiVWJ1bnR1IE1vbm9cIiwgXCJVbHRyYVwiLCBcIlVuY2lhbCBBbnRpcXVhXCIsIFwiVW5kZXJkb2dcIiwgXCJVbmljYSBPbmVcIiwgXCJVbmlmcmFrdHVyQ29va1wiLCBcIlVuaWZyYWt0dXJNYWd1bnRpYVwiLCBcIlVua2VtcHRcIiwgXCJVbmxvY2tcIiwgXCJVbm5hXCIsIFwiVlQzMjNcIiwgXCJWYW1waXJvIE9uZVwiLCBcIlZhcmVsYVwiLCBcIlZhcmVsYSBSb3VuZFwiLCBcIlZhc3QgU2hhZG93XCIsIFwiVmVzcGVyIExpYnJlXCIsIFwiVmlidXJcIiwgXCJWaWRhbG9rYVwiLCBcIlZpZ2FcIiwgXCJWb2Nlc1wiLCBcIlZvbGtob3ZcIiwgXCJWb2xsa29yblwiLCBcIlZvbHRhaXJlXCIsIFwiV2FpdGluZyBmb3IgdGhlIFN1bnJpc2VcIiwgXCJXYWxscG9ldFwiLCBcIldhbHRlciBUdXJuY29hdFwiLCBcIldhcm5lc1wiLCBcIldlbGxmbGVldFwiLCBcIldlbmR5IE9uZVwiLCBcIldpcmUgT25lXCIsIFwiV29yayBTYW5zXCIsIFwiWWFub25lIEthZmZlZXNhdHpcIiwgXCJZYW50cmFtYW5hdlwiLCBcIlllbGxvd3RhaWxcIiwgXCJZZXNldmEgT25lXCIsIFwiWWVzdGVyeWVhclwiLCBcIlpleWFkYVwiXTtcblxufSkuY2FsbCh0aGlzKTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsImltcG9ydCB7YXBwbHksIGFwcGx5QmFja2dyb3VuZCwgYXBwbHlTdHlsZX0gZnJvbSAnLi9pbmRleCc7XHJcbmltcG9ydCBzdHlsZWZ1bmN0aW9uIGZyb20gJy4vc3R5bGVmdW5jdGlvbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgYXBwbHk6IGFwcGx5LFxyXG4gIGFwcGx5QmFja2dyb3VuZDogYXBwbHlCYWNrZ3JvdW5kLFxyXG4gIGFwcGx5U3R5bGU6IGFwcGx5U3R5bGUsXHJcbiAgc3R5bGVmdW5jdGlvbjogc3R5bGVmdW5jdGlvblxyXG59O1xyXG4iLCIvKlxyXG5vbC1tYXBib3gtc3R5bGUgLSBVc2UgTWFwYm94IFN0eWxlIG9iamVjdHMgd2l0aCBPcGVuTGF5ZXJzXHJcbkNvcHlyaWdodCAyMDE2LXByZXNlbnQgQm91bmRsZXNzIFNwYXRpYWwsIEluYy5cclxuTGljZW5zZTogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2JvdW5kbGVzc2dlby9vbC1tYXBib3gtZ2wtc3R5bGUvbWFzdGVyL0xJQ0VOU0VcclxuKi9cclxuXHJcbmltcG9ydCBTdHlsZSBmcm9tICdvbC9zdHlsZS9TdHlsZSc7XHJcbmltcG9ydCBGaWxsIGZyb20gJ29sL3N0eWxlL0ZpbGwnO1xyXG5pbXBvcnQgU3Ryb2tlIGZyb20gJ29sL3N0eWxlL1N0cm9rZSc7XHJcbmltcG9ydCBJY29uIGZyb20gJ29sL3N0eWxlL0ljb24nO1xyXG5pbXBvcnQgVGV4dCBmcm9tICdvbC9zdHlsZS9UZXh0JztcclxuaW1wb3J0IENpcmNsZSBmcm9tICdvbC9zdHlsZS9DaXJjbGUnO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSAnb2wvZ2VvbS9Qb2ludCc7XHJcbmltcG9ydCB7ZGVyZWZMYXllcnN9IGZyb20gJ0BtYXBib3gvbWFwYm94LWdsLXN0eWxlLXNwZWMnO1xyXG5pbXBvcnQge1xyXG4gIGV4cHJlc3Npb24sIENvbG9yLFxyXG4gIGZ1bmN0aW9uIGFzIGZuLFxyXG4gIGxhdGVzdCBhcyBzcGVjLFxyXG4gIGZlYXR1cmVGaWx0ZXIgYXMgY3JlYXRlRmlsdGVyXHJcbn0gZnJvbSAnQG1hcGJveC9tYXBib3gtZ2wtc3R5bGUtc3BlYyc7XHJcbmltcG9ydCBtYjJjc3MgZnJvbSAnbWFwYm94LXRvLWNzcy1mb250JztcclxuaW1wb3J0IHtcclxuICBkZWcycmFkLFxyXG4gIGdldFpvb21Gb3JSZXNvbHV0aW9uXHJcbn0gZnJvbSAnLi91dGlsJztcclxuXHJcblxyXG5jb25zdCBpc0Z1bmN0aW9uID0gZm4uaXNGdW5jdGlvbjtcclxuY29uc3QgY29udmVydEZ1bmN0aW9uID0gZm4uY29udmVydEZ1bmN0aW9uO1xyXG5jb25zdCBpc0V4cHJlc3Npb24gPSBleHByZXNzaW9uLmlzRXhwcmVzc2lvbjtcclxuY29uc3QgY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uID0gZXhwcmVzc2lvbi5jcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb247XHJcblxyXG5jb25zdCB0eXBlcyA9IHtcclxuICAnUG9pbnQnOiAxLFxyXG4gICdNdWx0aVBvaW50JzogMSxcclxuICAnTGluZVN0cmluZyc6IDIsXHJcbiAgJ011bHRpTGluZVN0cmluZyc6IDIsXHJcbiAgJ1BvbHlnb24nOiAzLFxyXG4gICdNdWx0aVBvbHlnb24nOiAzXHJcbn07XHJcbmNvbnN0IGV4cHJlc3Npb25EYXRhID0gZnVuY3Rpb24ocmF3RXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKSB7XHJcbiAgY29uc3QgY29tcGlsZWRFeHByZXNzaW9uID0gY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uKHJhd0V4cHJlc3Npb24sIHByb3BlcnR5U3BlYyk7XHJcbiAgaWYgKGNvbXBpbGVkRXhwcmVzc2lvbi5yZXN1bHQgPT09ICdlcnJvcicpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihjb21waWxlZEV4cHJlc3Npb24udmFsdWUubWFwKGVyciA9PiBgJHtlcnIua2V5fTogJHtlcnIubWVzc2FnZX1gKS5qb2luKCcsICcpKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbXBpbGVkRXhwcmVzc2lvbi52YWx1ZTtcclxufTtcclxuXHJcbmNvbnN0IGVtcHR5T2JqID0ge307XHJcbmNvbnN0IHpvb21PYmogPSB7em9vbTogMH07XHJcbmNvbnN0IGZ1bmN0aW9uQ2FjaGUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgR2wgb2JqZWN0IGxheWVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbGF5b3V0T3JQYWludCAnbGF5b3V0JyBvciAncGFpbnQnLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgRmVhdHVyZSBwcm9wZXJ0eS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHpvb20gWm9vbS5cclxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUgR2wgZmVhdHVyZS5cclxuICogQHJldHVybiB7P30gVmFsdWUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWUobGF5ZXIsIGxheW91dE9yUGFpbnQsIHByb3BlcnR5LCB6b29tLCBmZWF0dXJlKSB7XHJcbiAgY29uc3QgbGF5ZXJJZCA9IGxheWVyLmlkO1xyXG4gIGlmICghZnVuY3Rpb25DYWNoZVtsYXllcklkXSkge1xyXG4gICAgZnVuY3Rpb25DYWNoZVtsYXllcklkXSA9IHt9O1xyXG4gIH1cclxuICBjb25zdCBmdW5jdGlvbnMgPSBmdW5jdGlvbkNhY2hlW2xheWVySWRdO1xyXG4gIGlmICghZnVuY3Rpb25zW3Byb3BlcnR5XSkge1xyXG4gICAgbGV0IHZhbHVlID0gKGxheWVyW2xheW91dE9yUGFpbnRdIHx8IGVtcHR5T2JqKVtwcm9wZXJ0eV07XHJcbiAgICBjb25zdCBwcm9wZXJ0eVNwZWMgPSBzcGVjW2Ake2xheW91dE9yUGFpbnR9XyR7bGF5ZXIudHlwZX1gXVtwcm9wZXJ0eV07XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YWx1ZSA9IHByb3BlcnR5U3BlYy5kZWZhdWx0O1xyXG4gICAgfVxyXG4gICAgbGV0IGlzRXhwciA9IGlzRXhwcmVzc2lvbigodmFsdWUpKTtcclxuICAgIGlmICghaXNFeHByICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgIHZhbHVlID0gY29udmVydEZ1bmN0aW9uKHZhbHVlLCBwcm9wZXJ0eVNwZWMpO1xyXG4gICAgICBpc0V4cHIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRXhwcikge1xyXG4gICAgICBjb25zdCBjb21waWxlZEV4cHJlc3Npb24gPSBleHByZXNzaW9uRGF0YSh2YWx1ZSwgcHJvcGVydHlTcGVjKTtcclxuICAgICAgZnVuY3Rpb25zW3Byb3BlcnR5XSA9IGNvbXBpbGVkRXhwcmVzc2lvbi5ldmFsdWF0ZS5iaW5kKGNvbXBpbGVkRXhwcmVzc2lvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT0gJ2NvbG9yJykge1xyXG4gICAgICAgIHZhbHVlID0gQ29sb3IucGFyc2UodmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uc1twcm9wZXJ0eV0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHpvb21PYmouem9vbSA9IHpvb207XHJcbiAgcmV0dXJuIGZ1bmN0aW9uc1twcm9wZXJ0eV0oem9vbU9iaiwgZmVhdHVyZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvdmVydEljb25BbmNob3IoaWNvbkFuY2hvcikge1xyXG4gIGxldCBhbmNob3JPZmZzZXQgPSBbMC41LCAwLjVdO1xyXG4gIGlmIChbJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnXS5pbmNsdWRlcyhpY29uQW5jaG9yKSkge1xyXG4gICAgYW5jaG9yT2Zmc2V0ID0gWzAsIDBdO1xyXG4gIH1cclxuICBpZiAoaWNvbkFuY2hvciA9PT0gJ2xlZnQnKSB7XHJcbiAgICBpY29uQW5jaG9yID0gJ3RvcC1sZWZ0JztcclxuICAgIGFuY2hvck9mZnNldCA9IFswLCAwLjVdO1xyXG4gIH1cclxuICBpZiAoaWNvbkFuY2hvciA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgaWNvbkFuY2hvciA9ICd0b3AtbGVmdCc7XHJcbiAgICBhbmNob3JPZmZzZXQgPSBbMSwgMC41XTtcclxuICB9XHJcbiAgaWYgKGljb25BbmNob3IgPT09ICdib3R0b20nKSB7XHJcbiAgICBpY29uQW5jaG9yID0gJ3RvcC1sZWZ0JztcclxuICAgIGFuY2hvck9mZnNldCA9IFswLjUsIDFdO1xyXG4gIH1cclxuICBpZiAoaWNvbkFuY2hvciA9PT0gJ3RvcCcpIHtcclxuICAgIGljb25BbmNob3IgPSAndG9wLWxlZnQnO1xyXG4gICAgYW5jaG9yT2Zmc2V0ID0gWzAuNSwgMF07XHJcbiAgfVxyXG4gIC8vY2VudGVyXHJcbiAgcmV0dXJuIHtcclxuICAgIGFuY2hvck9mZnNldDogYW5jaG9yT2Zmc2V0LFxyXG4gICAgaWNvbkFuY2hvcjogaWNvbkFuY2hvclxyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IGZvbnRNYXAgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGNob29zZUZvbnQoZm9udHMsIGF2YWlsYWJsZUZvbnRzKSB7XHJcbiAgaWYgKGZvbnRNYXBbZm9udHNdKSB7XHJcbiAgICByZXR1cm4gZm9udE1hcFtmb250c107XHJcbiAgfVxyXG4gIGlmIChhdmFpbGFibGVGb250cykge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZm9udHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICBjb25zdCBmb250ID0gZm9udHNbaV07XHJcbiAgICAgIGlmIChhdmFpbGFibGVGb250cy5pbmRleE9mKGZvbnQpICE9IC0xKSB7XHJcbiAgICAgICAgZm9udE1hcFtmb250c10gPSBmb250O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWZvbnRNYXBbZm9udHNdKSB7XHJcbiAgICAgIC8vIGZhbGxiYWNrIGZvbnRcclxuICAgICAgZm9udE1hcFtmb250c10gPSBmb250c1tmb250cy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgZm9udE1hcFtmb250c10gPSBmb250c1swXTtcclxuICB9XHJcbiAgcmV0dXJuIGZvbnRNYXBbZm9udHNdO1xyXG59XHJcblxyXG5jb25zdCBmaWx0ZXJDYWNoZSA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZXZhbHVhdGVGaWx0ZXIobGF5ZXJJZCwgZmlsdGVyLCBmZWF0dXJlLCB6b29tKSB7XHJcbiAgaWYgKCEobGF5ZXJJZCBpbiBmaWx0ZXJDYWNoZSkpIHtcclxuICAgIGZpbHRlckNhY2hlW2xheWVySWRdID0gY3JlYXRlRmlsdGVyKGZpbHRlcikuZmlsdGVyO1xyXG4gIH1cclxuICB6b29tT2JqLnpvb20gPSB6b29tO1xyXG4gIHJldHVybiBmaWx0ZXJDYWNoZVtsYXllcklkXSh6b29tT2JqLCBmZWF0dXJlKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbG9yV2l0aE9wYWNpdHkoY29sb3IsIG9wYWNpdHkpIHtcclxuICBpZiAoY29sb3IpIHtcclxuICAgIGlmIChjb2xvci5hID09PSAwIHx8IG9wYWNpdHkgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IGEgPSBjb2xvci5hO1xyXG4gICAgb3BhY2l0eSA9IG9wYWNpdHkgPT09IHVuZGVmaW5lZCA/IDEgOiBvcGFjaXR5O1xyXG4gICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKGNvbG9yLnIgKiAyNTUgLyBhKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuZyAqIDI1NSAvIGEpICtcclxuICAgICAgJywnICsgTWF0aC5yb3VuZChjb2xvci5iICogMjU1IC8gYSkgKyAnLCcgKyAoYSAqIG9wYWNpdHkpICsgJyknO1xyXG4gIH1cclxuICByZXR1cm4gY29sb3I7XHJcbn1cclxuXHJcbmNvbnN0IHRlbXBsYXRlUmVnRXggPSAvXihbXl0qKVxceyguKilcXH0oW15dKikkLztcclxuXHJcbmZ1bmN0aW9uIGZyb21UZW1wbGF0ZSh0ZXh0LCBwcm9wZXJ0aWVzKSB7XHJcbiAgbGV0IHBhcnRzO1xyXG4gIGRvIHtcclxuICAgIHBhcnRzID0gdGV4dC5tYXRjaCh0ZW1wbGF0ZVJlZ0V4KTtcclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbcGFydHNbMl1dIHx8ICcnO1xyXG4gICAgICB0ZXh0ID0gcGFydHNbMV0gKyB2YWx1ZSArIHBhcnRzWzNdO1xyXG4gICAgfVxyXG4gIH0gd2hpbGUgKHBhcnRzKTtcclxuICByZXR1cm4gdGV4dDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzdHlsZSBmdW5jdGlvbiBmcm9tIHRoZSBgZ2xTdHlsZWAgb2JqZWN0IGZvciBhbGwgbGF5ZXJzIHRoYXQgdXNlXHJcbiAqIHRoZSBzcGVjaWZpZWQgYHNvdXJjZWAsIHdoaWNoIG5lZWRzIHRvIGJlIGEgYFwidHlwZVwiOiBcInZlY3RvclwiYCBvclxyXG4gKiBgXCJ0eXBlXCI6IFwiZ2VvanNvblwiYCBzb3VyY2UgYW5kIGFwcGxpZXMgaXQgdG8gdGhlIHNwZWNpZmllZCBPcGVuTGF5ZXJzIGxheWVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29sLmxheWVyLlZlY3RvcnxvbC5sYXllci5WZWN0b3JUaWxlfSBvbExheWVyIE9wZW5MYXllcnMgbGF5ZXIgdG9cclxuICogYXBwbHkgdGhlIHN0eWxlIHRvLiBJbiBhZGRpdGlvbiB0byB0aGUgc3R5bGUsIHRoZSBsYXllciB3aWxsIGdldCB0d29cclxuICogcHJvcGVydGllczogYG1hcGJveC1zb3VyY2VgIHdpbGwgYmUgdGhlIGBpZGAgb2YgdGhlIGBnbFN0eWxlYCdzIHNvdXJjZSB1c2VkXHJcbiAqIGZvciB0aGUgbGF5ZXIsIGFuZCBgbWFwYm94LWxheWVyc2Agd2lsbCBiZSBhbiBhcnJheSBvZiB0aGUgYGlkYHMgb2YgdGhlXHJcbiAqIGBnbFN0eWxlYCdzIGxheWVycy5cclxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBnbFN0eWxlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHNvdXJjZSBgc291cmNlYCBrZXkgb3IgYW4gYXJyYXkgb2YgbGF5ZXIgYGlkYHNcclxuICogZnJvbSB0aGUgTWFwYm94IFN0eWxlIG9iamVjdC4gV2hlbiBhIGBzb3VyY2VgIGtleSBpcyBwcm92aWRlZCwgYWxsIGxheWVycyBmb3JcclxuICogdGhlIHNwZWNpZmllZCBzb3VyY2Ugd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgc3R5bGUgZnVuY3Rpb24uIFdoZW4gbGF5ZXIgYGlkYHNcclxuICogYXJlIHByb3ZpZGVkLCB0aGV5IG11c3QgYmUgZnJvbSBsYXllcnMgdGhhdCB1c2UgdGhlIHNhbWUgc291cmNlLlxyXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtyZXNvbHV0aW9ucz1bNzgyNzEuNTE2OTY0MDIwNDgsIDM5MTM1Ljc1ODQ4MjAxMDI0LFxyXG4gKiAxOTU2Ny44NzkyNDEwMDUxMiwgOTc4My45Mzk2MjA1MDI1NiwgNDg5MS45Njk4MTAyNTEyOCwgMjQ0NS45ODQ5MDUxMjU2NCxcclxuICogMTIyMi45OTI0NTI1NjI4MiwgNjExLjQ5NjIyNjI4MTQxLCAzMDUuNzQ4MTEzMTQwNzA1LCAxNTIuODc0MDU2NTcwMzUyNSxcclxuICogNzYuNDM3MDI4Mjg1MTc2MjUsIDM4LjIxODUxNDE0MjU4ODEzLCAxOS4xMDkyNTcwNzEyOTQwNjMsIDkuNTU0NjI4NTM1NjQ3MDMyLFxyXG4gKiA0Ljc3NzMxNDI2NzgyMzUxNiwgMi4zODg2NTcxMzM5MTE3NTgsIDEuMTk0MzI4NTY2OTU1ODc5LCAwLjU5NzE2NDI4MzQ3NzkzOTUsXHJcbiAqIDAuMjk4NTgyMTQxNzM4OTY5NzQsIDAuMTQ5MjkxMDcwODY5NDg0ODcsIDAuMDc0NjQ1NTM1NDM0NzQyNDRdXVxyXG4gKiBSZXNvbHV0aW9ucyBmb3IgbWFwcGluZyByZXNvbHV0aW9uIHRvIHpvb20gbGV2ZWwuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3ByaXRlRGF0YT11bmRlZmluZWRdIFNwcml0ZSBkYXRhIGZyb20gdGhlIHVybCBzcGVjaWZpZWQgaW5cclxuICogdGhlIE1hcGJveCBTdHlsZSBvYmplY3QncyBgc3ByaXRlYCBwcm9wZXJ0eS4gT25seSByZXF1aXJlZCBpZiBhIGBzcHJpdGVgXHJcbiAqIHByb3BlcnR5IGlzIHNwZWNpZmllZCBpbiB0aGUgTWFwYm94IFN0eWxlIG9iamVjdC5cclxuICogQHBhcmFtIHtPYmplY3R9IFtzcHJpdGVJbWFnZVVybD11bmRlZmluZWRdIFNwcml0ZSBpbWFnZSB1cmwgZm9yIHRoZSBzcHJpdGVcclxuICogc3BlY2lmaWVkIGluIHRoZSBNYXBib3ggU3R5bGUgb2JqZWN0J3MgYHNwcml0ZWAgcHJvcGVydHkuIE9ubHkgcmVxdWlyZWQgaWYgYVxyXG4gKiBgc3ByaXRlYCBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQgaW4gdGhlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW2ZvbnRzPXVuZGVmaW5lZF0gQXJyYXkgb2YgYXZhaWxhYmxlIGZvbnRzLCB1c2luZyB0aGVcclxuICogc2FtZSBmb250IG5hbWVzIGFzIHRoZSBNYXBib3ggU3R5bGUgb2JqZWN0LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBzdHlsZVxyXG4gKiBmdW5jdGlvbiB3aWxsIGFsd2F5cyB1c2UgdGhlIGZpcnN0IGZvbnQgZnJvbSB0aGUgZm9udCBhcnJheS5cclxuICogQHJldHVybiB7b2wuc3R5bGUuU3R5bGVGdW5jdGlvbn0gU3R5bGUgZnVuY3Rpb24gZm9yIHVzZSBpblxyXG4gKiBgb2wubGF5ZXIuVmVjdG9yYCBvciBgb2wubGF5ZXIuVmVjdG9yVGlsZWAuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvbExheWVyLCBnbFN0eWxlLCBzb3VyY2UsIHJlc29sdXRpb25zLCBzcHJpdGVEYXRhLCBzcHJpdGVJbWFnZVVybCxzcHJpdGVJbWFnZSwgZm9udHMpIHtcclxuICBpZiAoIXJlc29sdXRpb25zKSB7XHJcbiAgICByZXNvbHV0aW9ucyA9IFtdO1xyXG4gICAgZm9yIChsZXQgcmVzID0gNzgyNzEuNTE2OTY0MDIwNDg7IHJlc29sdXRpb25zLmxlbmd0aCA8IDIxOyByZXMgLz0gMikge1xyXG4gICAgICByZXNvbHV0aW9ucy5wdXNoKHJlcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgZ2xTdHlsZSA9PSAnc3RyaW5nJykge1xyXG4gICAgZ2xTdHlsZSA9IEpTT04ucGFyc2UoZ2xTdHlsZSk7XHJcbiAgfVxyXG4gIGlmIChnbFN0eWxlLnZlcnNpb24gIT0gOCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbFN0eWxlIHZlcnNpb24gOCByZXF1aXJlZC4nKTtcclxuICB9XHJcblxyXG4gIGxldCBzcHJpdGVJbWdTaXplO1xyXG4gIGlmIChzcHJpdGVJbWFnZVVybCAmJiAhc3ByaXRlSW1hZ2UpIHtcclxuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHNwcml0ZUltYWdlID0gaW1nO1xyXG4gICAgICBzcHJpdGVJbWdTaXplID0gW2ltZy53aWR0aCwgaW1nLmhlaWdodF07XHJcbiAgICAgIG9sTGF5ZXIuY2hhbmdlZCgpO1xyXG4gICAgfTtcclxuICAgIGltZy5zcmMgPSBzcHJpdGVJbWFnZVVybDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGN0eCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpLmdldENvbnRleHQoJzJkJyk7XHJcbiAgY29uc3QgbWVhc3VyZUNhY2hlID0ge307XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBUZXh0KHRleHQsIGZvbnQsIGVtKSB7XHJcbiAgICBjb25zdCBrZXkgPSBlbSArICcsJyArIGZvbnQgKyAnLCcgKyB0ZXh0O1xyXG4gICAgbGV0IHdyYXBwZWRUZXh0ID0gbWVhc3VyZUNhY2hlW2tleV07XHJcbiAgICBpZiAoIXdyYXBwZWRUZXh0KSB7XHJcbiAgICAgIGN0eC5mb250ID0gZm9udDtcclxuICAgICAgY29uc3Qgb25lRW0gPSBjdHgubWVhc3VyZVRleHQoJ00nKS53aWR0aDtcclxuICAgICAgY29uc3Qgd2lkdGggPSBvbmVFbSAqIGVtO1xyXG4gICAgICBjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQoJyAnKTtcclxuICAgICAgbGV0IGxpbmUgPSAnJztcclxuICAgICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gd29yZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHdvcmQgPSB3b3Jkc1tpXTtcclxuICAgICAgICBpZiAoKGN0eC5tZWFzdXJlVGV4dChsaW5lICsgd29yZCkud2lkdGggPD0gd2lkdGgpKSB7XHJcbiAgICAgICAgICBsaW5lICs9IChsaW5lID8gJyAnIDogJycpICsgd29yZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKGxpbmUpIHtcclxuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxpbmUgPSB3b3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobGluZSkge1xyXG4gICAgICAgIGxpbmVzLnB1c2gobGluZSk7XHJcbiAgICAgIH1cclxuICAgICAgbWVhc3VyZUNhY2hlW2tleV0gPSB3cmFwcGVkVGV4dCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdyYXBwZWRUZXh0O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYWxsTGF5ZXJzID0gZGVyZWZMYXllcnMoZ2xTdHlsZS5sYXllcnMpO1xyXG5cclxuICBjb25zdCBsYXllcnNCeVNvdXJjZUxheWVyID0ge307XHJcbiAgY29uc3QgbWFwYm94TGF5ZXJzID0gW107XHJcbiAgbGV0IG1hcGJveFNvdXJjZTtcclxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhbGxMYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSBhbGxMYXllcnNbaV07XHJcbiAgICBjb25zdCBsYXllcklkID0gbGF5ZXIuaWQ7XHJcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PSAnc3RyaW5nJyAmJiBsYXllci5zb3VyY2UgPT0gc291cmNlIHx8XHJcbiAgICAgIHNvdXJjZS5pbmRleE9mKGxheWVySWQpICE9PSAtMSkge1xyXG4gICAgICBjb25zdCBzb3VyY2VMYXllciA9IGxheWVyWydzb3VyY2UtbGF5ZXInXTtcclxuICAgICAgaWYgKCFtYXBib3hTb3VyY2UpIHtcclxuICAgICAgICBtYXBib3hTb3VyY2UgPSBsYXllci5zb3VyY2U7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGxheWVycyA9IGxheWVyc0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJdO1xyXG4gICAgICBpZiAoIWxheWVycykge1xyXG4gICAgICAgIGxheWVycyA9IGxheWVyc0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJdID0gW107XHJcbiAgICAgIH1cclxuICAgICAgbGF5ZXJzLnB1c2goe1xyXG4gICAgICAgIGxheWVyOiBsYXllcixcclxuICAgICAgICBpbmRleDogaVxyXG4gICAgICB9KTtcclxuICAgICAgbWFwYm94TGF5ZXJzLnB1c2gobGF5ZXJJZCk7XHJcbiAgICB9XHJcbiAgICAvLyAvLyBUT0RPIHJldmlzaXQgd2hlbiBkaWZmaW5nIGdldHMgYWRkZWRcclxuICAgIGRlbGV0ZSBmdW5jdGlvbkNhY2hlW2xheWVySWRdO1xyXG4gICAgZGVsZXRlIGZpbHRlckNhY2hlW2xheWVySWRdO1xyXG4gIH1cclxuICBjb25zdCBpY29uSW1hZ2VDYWNoZSA9IHt9O1xyXG5cclxuICBjb25zdCBzdHlsZXMgPSBbXTtcclxuICBjb25zdCBwYXR0ZXJuQ2FjaGUgPSB7fTtcclxuXHJcbiAgY29uc3Qgc3R5bGVGdW5jdGlvbiA9IGZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcclxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBmZWF0dXJlLmdldFByb3BlcnRpZXMoKTtcclxuICAgIGZlYXR1cmUuc3R5bGVJZHMgPSBmZWF0dXJlLnN0eWxlSWRzIHx8IHt9O1xyXG4gICAgY29uc3QgbGF5ZXJzID0gbGF5ZXJzQnlTb3VyY2VMYXllcltwcm9wZXJ0aWVzLmxheWVyXTtcclxuICAgIGlmICghbGF5ZXJzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCB6b29tID0gcmVzb2x1dGlvbnMuaW5kZXhPZihyZXNvbHV0aW9uKTtcclxuICAgIGlmICh6b29tID09IC0xKSB7XHJcbiAgICAgIHpvb20gPSBNYXRoLnJvdW5kKGdldFpvb21Gb3JSZXNvbHV0aW9uKHJlc29sdXRpb24sIHJlc29sdXRpb25zKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0eXBlID0gdHlwZXNbZmVhdHVyZS5nZXRHZW9tZXRyeSgpLmdldFR5cGUoKV07XHJcbiAgICBjb25zdCBmID0ge1xyXG4gICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxyXG4gICAgICB0eXBlOiB0eXBlXHJcbiAgICB9O1xyXG4gICAgbGV0IHN0eWxlc0xlbmd0aCA9IC0xO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgY29uc3QgbGF5ZXJEYXRhID0gbGF5ZXJzW2ldO1xyXG4gICAgICBjb25zdCBsYXllciA9IGxheWVyRGF0YS5sYXllcjtcclxuICAgICAgY29uc3QgbGF5ZXJJZCA9IGxheWVyLmlkO1xyXG5cclxuICAgICAgY29uc3QgbGF5b3V0ID0gbGF5ZXIubGF5b3V0IHx8IGVtcHR5T2JqO1xyXG4gICAgICBjb25zdCBwYWludCA9IGxheWVyLnBhaW50IHx8IGVtcHR5T2JqO1xyXG4gICAgICBpZiAobGF5b3V0LnZpc2liaWxpdHkgPT09ICdub25lJyB8fCAoJ21pbnpvb20nIGluIGxheWVyICYmIHpvb20gPCBsYXllci5taW56b29tKSB8fFxyXG4gICAgICAgICgnbWF4em9vbScgaW4gbGF5ZXIgJiYgem9vbSA+PSBsYXllci5tYXh6b29tKSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0gPSBmZWF0dXJlLnN0eWxlSWRzW3pvb21dIHx8IFtdO1xyXG4gICAgICBjb25zdCBmaWx0ZXIgPSBsYXllci5maWx0ZXI7XHJcbiAgICAgIGxldCBpY29uLCBpY29uSW1nO1xyXG4gICAgICBpZiAoIWZpbHRlciB8fCBldmFsdWF0ZUZpbHRlcihsYXllcklkLCBmaWx0ZXIsIGYsIHpvb20pKSB7XHJcbiAgICAgICAgbGV0IGNvbG9yLCBvcGFjaXR5LCBmaWxsLCBzdHJva2UsIHN0cm9rZUNvbG9yLCBzdHlsZTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGxheWVyRGF0YS5pbmRleDtcclxuICAgICAgICBpZiAodHlwZSA9PSAzICYmIGxheWVyLnR5cGUgPT0gJ2ZpbGwnKSB7XHJcbiAgICAgICAgICBvcGFjaXR5ID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdmaWxsLW9wYWNpdHknLCB6b29tLCBmKTtcclxuICAgICAgICAgIGlmICgnZmlsbC1wYXR0ZXJuJyBpbiBwYWludCkge1xyXG4gICAgICAgICAgICBjb25zdCBpY29uSW1hZ2UgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ZpbGwtcGF0dGVybicsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICBpZiAoaWNvbkltYWdlKSB7XHJcbiAgICAgICAgICAgICAgaWNvbiA9IHR5cGVvZiBpY29uSW1hZ2UgPT09ICdzdHJpbmcnID8gZnJvbVRlbXBsYXRlKGljb25JbWFnZSwgcHJvcGVydGllcykgOiBpY29uSW1hZ2UudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICBpZiAoc3ByaXRlSW1hZ2UgJiYgc3ByaXRlRGF0YSAmJiBzcHJpdGVEYXRhW2ljb25dKSB7XHJcbiAgICAgICAgICAgICAgICArK3N0eWxlc0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0ucHVzaChsYXllcklkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlIHx8ICFzdHlsZS5nZXRGaWxsKCkgfHwgc3R5bGUuZ2V0U3Ryb2tlKCkgfHwgc3R5bGUuZ2V0VGV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF0gPSBuZXcgU3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG5ldyBGaWxsKClcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWxsID0gc3R5bGUuZ2V0RmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0WkluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25fY2FjaGVfa2V5ID0gaWNvbiArICcuJyArIG9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IHBhdHRlcm5DYWNoZVtpY29uX2NhY2hlX2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgc3ByaXRlSW1hZ2VEYXRhID0gc3ByaXRlRGF0YVtpY29uXTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHNwcml0ZUltYWdlRGF0YS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHNwcml0ZUltYWdlRGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS54LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS55LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4oY2FudmFzLCAncmVwZWF0Jyk7XHJcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm5DYWNoZVtpY29uX2NhY2hlX2tleV0gPSBwYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmlsbC5zZXRDb2xvcihwYXR0ZXJuKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoJ2ZpbGwtY29sb3InIGluIHBhaW50KSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gY29sb3JXaXRoT3BhY2l0eShnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ZpbGwtY29sb3InLCB6b29tLCBmKSwgb3BhY2l0eSk7XHJcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpIHx8IHN0eWxlLmdldFRleHQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgIGZpbGw6IG5ldyBGaWxsKClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBmaWxsID0gc3R5bGUuZ2V0RmlsbCgpO1xyXG4gICAgICAgICAgICAgIGZpbGwuc2V0Q29sb3IoY29sb3IpO1xyXG4gICAgICAgICAgICAgIHN0eWxlLnNldFpJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCdmaWxsLW91dGxpbmUtY29sb3InIGluIHBhaW50KSB7XHJcbiAgICAgICAgICAgICAgc3Ryb2tlQ29sb3IgPSBjb2xvcldpdGhPcGFjaXR5KGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnZmlsbC1vdXRsaW5lLWNvbG9yJywgem9vbSwgcHJvcGVydGllcyksIG9wYWNpdHkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdmaWxsLWFudGlhbGlhcycgaW4gcGFpbnQpIHtcclxuICAgICAgICAgICAgICBzdHJva2VDb2xvciA9IGNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdHJva2VDb2xvcikge1xyXG4gICAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0U3Ryb2tlKCkgfHwgc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFRleHQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSgpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgc3Ryb2tlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgc3Ryb2tlLnNldENvbG9yKHN0cm9rZUNvbG9yKTtcclxuICAgICAgICAgICAgICBzdHJva2Uuc2V0V2lkdGgoMSk7XHJcbiAgICAgICAgICAgICAgc3R5bGUuc2V0WkluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSAhPSAxICYmIGxheWVyLnR5cGUgPT0gJ2xpbmUnKSB7XHJcbiAgICAgICAgICBjb2xvciA9ICEoJ2xpbmUtcGF0dGVybicgaW4gcGFpbnQpICYmICdsaW5lLWNvbG9yJyBpbiBwYWludCA/XHJcbiAgICAgICAgICAgIGNvbG9yV2l0aE9wYWNpdHkoZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdsaW5lLWNvbG9yJywgem9vbSwgZiksIGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnbGluZS1vcGFjaXR5Jywgem9vbSwgZikpIDpcclxuICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2xpbmUtd2lkdGgnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGlmIChjb2xvciAmJiB3aWR0aCA+IDApIHtcclxuICAgICAgICAgICAgKytzdHlsZXNMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5wdXNoKGxheWVySWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLmdldFN0cm9rZSgpIHx8IHN0eWxlLmdldEZpbGwoKSB8fCBzdHlsZS5nZXRUZXh0KCkpIHtcclxuICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdID0gbmV3IFN0eWxlKHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSgpXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3Ryb2tlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIHN0cm9rZS5zZXRMaW5lQ2FwKGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ2xpbmUtY2FwJywgem9vbSwgZikpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0TGluZUpvaW4oZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnbGluZS1qb2luJywgem9vbSwgZikpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0TWl0ZXJMaW1pdChnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdsaW5lLW1pdGVyLWxpbWl0Jywgem9vbSwgZikpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0Q29sb3IoY29sb3IpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0V2lkdGgod2lkdGgpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0TGluZURhc2gocGFpbnRbJ2xpbmUtZGFzaGFycmF5J10gP1xyXG4gICAgICAgICAgICAgIGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnbGluZS1kYXNoYXJyYXknLCB6b29tLCBmKS5tYXAoZnVuY3Rpb24oeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggKiB3aWR0aDtcclxuICAgICAgICAgICAgICB9KSA6IG51bGwpO1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRaSW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGhhc0ltYWdlID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHRleHQgPSBudWxsO1xyXG4gICAgICAgIGxldCBza2lwTGFiZWw7XHJcbiAgICAgICAgaWYgKCh0eXBlID09IDEgfHwgdHlwZSA9PSAyKSAmJiAnaWNvbi1pbWFnZScgaW4gbGF5b3V0KSB7XHJcbiAgICAgICAgICBjb25zdCBpY29uSW1hZ2UgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdpY29uLWltYWdlJywgem9vbSwgZik7XHJcbiAgICAgICAgICBpZiAoaWNvbkltYWdlKSB7XHJcbiAgICAgICAgICAgIGljb24gPSB0eXBlb2YgaWNvbkltYWdlID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgID8gZnJvbVRlbXBsYXRlKGljb25JbWFnZSwgcHJvcGVydGllcylcclxuICAgICAgICAgICAgICA6IGljb25JbWFnZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBsZXQgc3R5bGVHZW9tID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoc3ByaXRlSW1hZ2UgJiYgc3ByaXRlRGF0YSAmJiBzcHJpdGVEYXRhW2ljb25dKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gMikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcclxuICAgICAgICAgICAgICAgIC8vIG9sIHBhY2thZ2UgYW5kIG9sLWRlYnVnLmpzIG9ubHlcclxuICAgICAgICAgICAgICAgIGlmIChnZW9tLmdldEZsYXRNaWRwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSBnZW9tLmdldEV4dGVudCgpO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5zcXJ0KE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KChleHRlbnRbMl0gLSBleHRlbnRbMF0pIC8gcmVzb2x1dGlvbiwgMiksXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyByZXNvbHV0aW9uLCAyKSkpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDE1MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRklYTUUgRG8gbm90IGhhcmQtY29kZSBhIHNpemUgb2YgMTUwXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVHZW9tID0gbmV3IFBvaW50KGdlb20uZ2V0RmxhdE1pZHBvaW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICh0eXBlICE9PSAyIHx8IHN0eWxlR2VvbSkge1xyXG4gICAgICAgICAgICAgICAgKytzdHlsZXNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5pbmRleE9mKGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0SW1hZ2UoKSB8fCBzdHlsZS5nZXRGaWxsKCkgfHwgc3R5bGUuZ2V0U3Ryb2tlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0R2VvbWV0cnkoc3R5bGVHZW9tKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25TaXplID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnaWNvbi1zaXplJywgem9vbSwgZik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uQ29sb3IgPSBwYWludFsnaWNvbi1jb2xvciddICE9PSB1bmRlZmluZWQgPyBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ljb24tY29sb3InLCB6b29tLCBmKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uVHJhbnNsYXRlID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdpY29uLXRyYW5zbGF0ZScsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvblRyYW5zbGF0ZUFuY2hvciA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnaWNvbi10cmFuc2xhdGUtYW5jaG9yJywgem9vbSwgZik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uQW5jaG9yVmFsdWUgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdpY29uLWFuY2hvcicsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbk9mZnNldCA9IGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ2ljb24tb2Zmc2V0Jywgem9vbSwgZik7XHJcbiAgICAgICAgICAgICAgICBsZXQge1xyXG4gICAgICAgICAgICAgICAgICBhbmNob3JPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgIGljb25BbmNob3IgPSBpY29uQW5jaG9yVmFsdWVcclxuICAgICAgICAgICAgICAgIH0gPSBjb3ZlcnRJY29uQW5jaG9yKGljb25BbmNob3JWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaWNvbl9jYWNoZV9rZXkgPSBpY29uICsgJy4nICsgaWNvblNpemUgKyAnLicgKyBpY29uVHJhbnNsYXRlICsgJy4nICsgaWNvblRyYW5zbGF0ZUFuY2hvciArICcuJyArIGljb25BbmNob3IgKyAnLicgKyBpY29uT2Zmc2V0ICsgJy4nICsgYW5jaG9yT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGljb25Db2xvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICBpY29uX2NhY2hlX2tleSArPSAnLicgKyBpY29uQ29sb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpY29uSW1nID0gaWNvbkltYWdlQ2FjaGVbaWNvbl9jYWNoZV9rZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpY29uSW1nKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNwcml0ZUltYWdlRGF0YSA9IHNwcml0ZURhdGFbaWNvbl07XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBzcHJpdGVJbWFnZURhdGEud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzcHJpdGVJbWFnZURhdGEuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZSxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEueCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEueSxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGljb25Db2xvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1dCBvdXQgdGhlIHNwcml0ZSBhbmQgY29sb3IgaXRcclxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yV2l0aE9wYWNpdHkoaWNvbkNvbG9yLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gMCwgY2MgPSBkYXRhLmRhdGEubGVuZ3RoOyBjIDwgY2M7IGMgKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhW2NdID0gY29sb3JbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGFbYyArIDFdID0gY29sb3JbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGFbYyArIDJdID0gY29sb3JbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZU9mZnNldCA9IFtpY29uVHJhbnNsYXRlWzBdIC8gc3ByaXRlSW1hZ2VEYXRhLndpZHRoLCBpY29uVHJhbnNsYXRlWzFdIC8gc3ByaXRlSW1hZ2VEYXRhLmhlaWdodF07XHJcbiAgICAgICAgICAgICAgICAgIGljb25JbWcgPSBpY29uSW1hZ2VDYWNoZVtpY29uX2NhY2hlX2tleV0gPSBuZXcgSWNvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nOiBjYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yT3JpZ2luOiBpY29uQW5jaG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcjogW2ljb25PZmZzZXRbMF0gKyBhbmNob3JPZmZzZXRbMF0gKyB0cmFuc2xhdGVPZmZzZXRbMF0sIGljb25PZmZzZXRbMV0gKyBhbmNob3JPZmZzZXRbMV0gLSB0cmFuc2xhdGVPZmZzZXRbMV1dLFxyXG4gICAgICAgICAgICAgICAgICAgIGltZ1NpemU6IFtjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBpY29uU2l6ZSAvIHNwcml0ZUltYWdlRGF0YS5waXhlbFJhdGlvXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJvdGF0ZVZhbHVlID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnaWNvbi1yb3RhdGUnLCB6b29tLCBmKTtcclxuICAgICAgICAgICAgICAgIGlmIChyb3RhdGVWYWx1ZS5pbmRleE9mICYmIHJvdGF0ZVZhbHVlLmluZGV4T2YoJ3snKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICByb3RhdGVWYWx1ZSA9IDM2MCAtIGZyb21UZW1wbGF0ZShyb3RhdGVWYWx1ZSwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpY29uSW1nLnNldFJvdGF0aW9uKGRlZzJyYWQocm90YXRlVmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIGljb25JbWcuc2V0T3BhY2l0eShnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ljb24tb3BhY2l0eScsIHpvb20sIGYpKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldEltYWdlKGljb25JbWcpO1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHN0eWxlLmdldFRleHQoKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFRleHQodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFpJbmRleCg5OTk5OSAtIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGhhc0ltYWdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHNraXBMYWJlbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBza2lwTGFiZWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gMSAmJiAnY2lyY2xlLXJhZGl1cycgaW4gcGFpbnQpIHtcclxuICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgaWYgKGZlYXR1cmUuc3R5bGVJZHNbem9vbV0uaW5kZXhPZihsYXllcklkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5wdXNoKGxheWVySWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXTtcclxuICAgICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLmdldEltYWdlKCkgfHwgc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpKSB7XHJcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF0gPSBuZXcgU3R5bGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IGNpcmNsZVJhZGl1cyA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnY2lyY2xlLXJhZGl1cycsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgY2lyY2xlU3Ryb2tlQ29sb3IgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2NpcmNsZS1zdHJva2UtY29sb3InLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IGNpcmNsZUNvbG9yID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdjaXJjbGUtY29sb3InLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IGNpcmNsZU9wYWNpdHkgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2NpcmNsZS1vcGFjaXR5Jywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCBjaXJjbGVTdHJva2VXaWR0aCA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnY2lyY2xlLXN0cm9rZS13aWR0aCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgY2lyY2xlU3Ryb2tlT3BhY2l0eSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnY2lyY2xlLXN0cm9rZS1vcGFjaXR5Jywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCBjYWNoZV9rZXkgPSBjaXJjbGVSYWRpdXMgKyAnLicgKyBjaXJjbGVTdHJva2VDb2xvciArICcuJyArXHJcbiAgICAgICAgICAgIGNpcmNsZUNvbG9yICsgJy4nICsgY2lyY2xlT3BhY2l0eSArICcuJyArIGNpcmNsZVN0cm9rZVdpZHRoICsgJy4nICsgY2lyY2xlU3Ryb2tlT3BhY2l0eTtcclxuICAgICAgICAgIGljb25JbWcgPSBpY29uSW1hZ2VDYWNoZVtjYWNoZV9rZXldO1xyXG4gICAgICAgICAgaWYgKCFpY29uSW1nKSB7XHJcbiAgICAgICAgICAgIGljb25JbWcgPSBuZXcgQ2lyY2xlKHtcclxuICAgICAgICAgICAgICByYWRpdXM6IGNpcmNsZVJhZGl1cyxcclxuICAgICAgICAgICAgICBzdHJva2U6IGNpcmNsZVN0cm9rZVdpZHRoID09PSAwID8gdW5kZWZpbmVkIDogbmV3IFN0cm9rZSh7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogY2lyY2xlU3Ryb2tlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JXaXRoT3BhY2l0eShjaXJjbGVTdHJva2VDb2xvciwgY2lyY2xlU3Ryb2tlT3BhY2l0eSlcclxuICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JXaXRoT3BhY2l0eShjaXJjbGVDb2xvciwgY2lyY2xlT3BhY2l0eSlcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0eWxlLnNldEltYWdlKGljb25JbWcpO1xyXG4gICAgICAgICAgdGV4dCA9IHN0eWxlLmdldFRleHQoKTtcclxuICAgICAgICAgIHN0eWxlLnNldFRleHQodW5kZWZpbmVkKTtcclxuICAgICAgICAgIHN0eWxlLnNldEdlb21ldHJ5KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICBzdHlsZS5zZXRaSW5kZXgoOTk5OTkgLSBpbmRleCk7XHJcbiAgICAgICAgICBoYXNJbWFnZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGFiZWw7XHJcbiAgICAgICAgaWYgKCd0ZXh0LWZpZWxkJyBpbiBsYXlvdXQpIHtcclxuICAgICAgICAgIGNvbnN0IHRleHRGaWVsZCA9IGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3RleHQtZmllbGQnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGxhYmVsID0gZnJvbVRlbXBsYXRlKHRleHRGaWVsZCwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYWJlbCAmJiAhc2tpcExhYmVsKSB7XHJcbiAgICAgICAgICBpZiAoIWhhc0ltYWdlKSB7XHJcbiAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5pbmRleE9mKGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0ucHVzaChsYXllcklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdO1xyXG4gICAgICAgICAgICBpZiAoIXN0eWxlIHx8ICFzdHlsZS5nZXRUZXh0KCkgfHwgc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpKSB7XHJcbiAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlLnNldEltYWdlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHN0eWxlLnNldEdlb21ldHJ5KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIXN0eWxlLmdldFRleHQoKSkge1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRUZXh0KHRleHQgfHwgbmV3IFRleHQoKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0ZXh0ID0gc3R5bGUuZ2V0VGV4dCgpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dFNpemUgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LXNpemUnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRMaW5lSGVpZ2h0ID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAndGV4dC1saW5lLWhlaWdodCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgZm9udCA9IG1iMmNzcyhjaG9vc2VGb250KGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3RleHQtZm9udCcsIHpvb20sIGYpKSwgdGV4dFNpemUpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dFRyYW5zZm9ybSA9IGxheW91dFsndGV4dC10cmFuc2Zvcm0nXTtcclxuICAgICAgICAgIGlmICh0ZXh0VHJhbnNmb3JtID09ICd1cHBlcmNhc2UnKSB7XHJcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWwudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xyXG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCB3cmFwcGVkTGFiZWwgPSB0eXBlID09IDIgPyBsYWJlbCA6IHdyYXBUZXh0KGxhYmVsLCBmb250LCBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LW1heC13aWR0aCcsIHpvb20sIGYpKTtcclxuICAgICAgICAgIHRleHQuc2V0VGV4dCh3cmFwcGVkTGFiZWwpO1xyXG4gICAgICAgICAgdGV4dC5zZXRGb250KGZvbnQpO1xyXG4gICAgICAgICAgdGV4dC5zZXRSb3RhdGlvbihkZWcycmFkKGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3RleHQtcm90YXRlJywgem9vbSwgZikpKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRBbmNob3IgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LWFuY2hvcicsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKGhhc0ltYWdlIHx8IHR5cGUgPT0gMSkgPyAncG9pbnQnIDogZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnc3ltYm9sLXBsYWNlbWVudCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgdGV4dC5zZXRQbGFjZW1lbnQocGxhY2VtZW50KTtcclxuICAgICAgICAgIGxldCB0ZXh0SGFsb1dpZHRoID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICd0ZXh0LWhhbG8td2lkdGgnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRPZmZzZXQgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LW9mZnNldCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dFRyYW5zbGF0ZSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC10cmFuc2xhdGUnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGxldCB2T2Zmc2V0ID0gMDtcclxuICAgICAgICAgIGxldCBoT2Zmc2V0ID0gMDtcclxuICAgICAgICAgIGxldCB0ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgIGlmICh0ZXh0QW5jaG9yLmluZGV4T2YoJ2xlZnQnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgICAgICAgICBoT2Zmc2V0ID0gdGV4dEhhbG9XaWR0aDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFuY2hvci5pbmRleE9mKCdyaWdodCcpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xyXG4gICAgICAgICAgICBoT2Zmc2V0ID0gLXRleHRIYWxvV2lkdGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocGxhY2VtZW50ID09ICdwb2ludCcpIHtcclxuICAgICAgICAgICAgdGV4dC5zZXRUZXh0QWxpZ24odGV4dEFsaWduKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHQuc2V0TWF4QW5nbGUoZGVnMnJhZChnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LW1heC1hbmdsZScsIHpvb20sIGYpKSAqIGxhYmVsLmxlbmd0aCAvIHdyYXBwZWRMYWJlbC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB0ZXh0LnNldFRleHRBbGlnbigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgaWYgKHRleHRBbmNob3IuaW5kZXhPZignYm90dG9tJykgPT0gMCkge1xyXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcclxuICAgICAgICAgICAgdk9mZnNldCA9IC10ZXh0SGFsb1dpZHRoIC0gKDAuNSAqICh0ZXh0TGluZUhlaWdodCAtIDEpKSAqIHRleHRTaXplO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0ZXh0QW5jaG9yLmluZGV4T2YoJ3RvcCcpID09IDApIHtcclxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XHJcbiAgICAgICAgICAgIHZPZmZzZXQgPSB0ZXh0SGFsb1dpZHRoICsgKDAuNSAqICh0ZXh0TGluZUhlaWdodCAtIDEpKSAqIHRleHRTaXplO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGV4dC5zZXRUZXh0QmFzZWxpbmUodGV4dEJhc2VsaW5lKTtcclxuICAgICAgICAgIHRleHQuc2V0T2Zmc2V0WCh0ZXh0T2Zmc2V0WzBdICogdGV4dFNpemUgKyBoT2Zmc2V0ICsgdGV4dFRyYW5zbGF0ZVswXSk7XHJcbiAgICAgICAgICB0ZXh0LnNldE9mZnNldFkodGV4dE9mZnNldFsxXSAqIHRleHRTaXplICsgdk9mZnNldCArIHRleHRUcmFuc2xhdGVbMV0pO1xyXG4gICAgICAgICAgb3BhY2l0eSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC1vcGFjaXR5Jywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0Q29sb3IgPSBuZXcgRmlsbCgpO1xyXG5cclxuICAgICAgICAgIHRleHRDb2xvci5zZXRDb2xvcihjb2xvcldpdGhPcGFjaXR5KGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC1jb2xvcicsIHpvb20sIGYpLCBvcGFjaXR5KSk7XHJcbiAgICAgICAgICB0ZXh0LnNldEZpbGwodGV4dENvbG9yKTtcclxuICAgICAgICAgIGNvbnN0IGhhbG9Db2xvciA9IGNvbG9yV2l0aE9wYWNpdHkoZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICd0ZXh0LWhhbG8tY29sb3InLCB6b29tLCBmKSwgb3BhY2l0eSk7XHJcbiAgICAgICAgICBpZiAoaGFsb0NvbG9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRIYWxvID0gbmV3IFN0cm9rZSgpO1xyXG4gICAgICAgICAgICB0ZXh0SGFsby5zZXRDb2xvcihoYWxvQ29sb3IpO1xyXG4gICAgICAgICAgICB0ZXh0SGFsby5zZXRXaWR0aChnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ3RleHQtaGFsby13aWR0aCcsIHpvb20sIGYpKTtcclxuICAgICAgICAgICAgdGV4dC5zZXRTdHJva2UodGV4dEhhbG8pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dC5zZXRTdHJva2UodW5kZWZpbmVkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0eWxlLnNldFpJbmRleCg5OTk5OSAtIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3R5bGVzTGVuZ3RoID4gLTEpIHtcclxuICAgICAgc3R5bGVzLmxlbmd0aCA9IHN0eWxlc0xlbmd0aCArIDE7XHJcbiAgICAgIHJldHVybiBzdHlsZXM7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgb2xMYXllci5zZXRTdHlsZShzdHlsZUZ1bmN0aW9uKTtcclxuICBvbExheWVyLnNldCgnbWFwYm94LXNvdXJjZScsIG1hcGJveFNvdXJjZSk7XHJcbiAgb2xMYXllci5zZXQoJ21hcGJveC1sYXllcnMnLCBtYXBib3hMYXllcnMpO1xyXG4gIHJldHVybiBzdHlsZUZ1bmN0aW9uO1xyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiBkZWcycmFkKGRlZ3JlZXMpIHtcclxuICByZXR1cm4gZGVncmVlcyAqIE1hdGguUEkgLyAxODA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRab29tRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uLCByZXNvbHV0aW9ucykge1xyXG4gIGxldCBpID0gMDtcclxuICBjb25zdCBpaSA9IHJlc29sdXRpb25zLmxlbmd0aDtcclxuICBmb3IgKDsgaSA8IGlpOyArK2kpIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHJlc29sdXRpb25zW2ldO1xyXG4gICAgaWYgKGNhbmRpZGF0ZSA8IHJlc29sdXRpb24gJiYgaSArIDEgPCBpaSkge1xyXG4gICAgICBjb25zdCB6b29tRmFjdG9yID0gcmVzb2x1dGlvbnNbaV0gLyByZXNvbHV0aW9uc1tpICsgMV07XHJcbiAgICAgIHJldHVybiBpICsgTWF0aC5sb2cocmVzb2x1dGlvbnNbaV0gLyByZXNvbHV0aW9uKSAvIE1hdGgubG9nKHpvb21GYWN0b3IpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gaWkgLSAxO1xyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gb2wuTWFwOyIsIm1vZHVsZS5leHBvcnRzID0gb2wuT2JzZXJ2YWJsZTsiLCJtb2R1bGUuZXhwb3J0cyA9IG9sLmZvcm1hdC5HZW9KU09OOyIsIm1vZHVsZS5leHBvcnRzID0gb2wuZm9ybWF0Lk1WVDsiLCJtb2R1bGUuZXhwb3J0cyA9IG9sLmdlb20uUG9pbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5sYXllci5UaWxlOyIsIm1vZHVsZS5leHBvcnRzID0gb2wubGF5ZXIuVmVjdG9yOyIsIm1vZHVsZS5leHBvcnRzID0gb2wubGF5ZXIuVmVjdG9yVGlsZTsiLCJtb2R1bGUuZXhwb3J0cyA9IG9sLnByb2o7IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5zb3VyY2UuVGlsZUpTT047IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5zb3VyY2UuVmVjdG9yOyIsIm1vZHVsZS5leHBvcnRzID0gb2wuc291cmNlLlZlY3RvclRpbGU7IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5zb3VyY2UuWFlaOyIsIm1vZHVsZS5leHBvcnRzID0gb2wuc3R5bGUuQ2lyY2xlOyIsIm1vZHVsZS5leHBvcnRzID0gb2wuc3R5bGUuRmlsbDsiLCJtb2R1bGUuZXhwb3J0cyA9IG9sLnN0eWxlLkljb247IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5zdHlsZS5TdHJva2U7IiwibW9kdWxlLmV4cG9ydHMgPSBvbC5zdHlsZS5TdHlsZTsiLCJtb2R1bGUuZXhwb3J0cyA9IG9sLnN0eWxlLlRleHQ7IiwibW9kdWxlLmV4cG9ydHMgPSBvbC50aWxlZ3JpZDsiXSwic291cmNlUm9vdCI6IiJ9