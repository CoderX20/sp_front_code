/*!
 * 
 *     ol-mapbox-style
 *     Copyright 2016-present Boundless Spatial
 *     Copyright© 2000-2018 SuperMap Software Co. Ltd
 *     github: https://github.com/boundlessgeo/ol-mapbox-style
 *     github: https://github.com/SuperMap/ol-mapbox-style
 *     license: BSD 2-Clause "Simplified" License
 *     version: v2.11.2-3
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("ol/Map"), require("ol/Observable"), require("ol/format/GeoJSON"), require("ol/format/MVT"), require("ol/geom/Point"), require("ol/layer/Tile"), require("ol/layer/Vector"), require("ol/layer/VectorTile"), require("ol/proj"), require("ol/source/TileJSON"), require("ol/source/Vector"), require("ol/source/VectorTile"), require("ol/style/Circle"), require("ol/style/Fill"), require("ol/style/Icon"), require("ol/style/Stroke"), require("ol/style/Style"), require("ol/style/Text"), require("ol/tilegrid"));
	else if(typeof define === 'function' && define.amd)
		define(["ol/Map", "ol/Observable", "ol/format/GeoJSON", "ol/format/MVT", "ol/geom/Point", "ol/layer/Tile", "ol/layer/Vector", "ol/layer/VectorTile", "ol/proj", "ol/source/TileJSON", "ol/source/Vector", "ol/source/VectorTile", "ol/style/Circle", "ol/style/Fill", "ol/style/Icon", "ol/style/Stroke", "ol/style/Style", "ol/style/Text", "ol/tilegrid"], factory);
	else if(typeof exports === 'object')
		exports["olms"] = factory(require("ol/Map"), require("ol/Observable"), require("ol/format/GeoJSON"), require("ol/format/MVT"), require("ol/geom/Point"), require("ol/layer/Tile"), require("ol/layer/Vector"), require("ol/layer/VectorTile"), require("ol/proj"), require("ol/source/TileJSON"), require("ol/source/Vector"), require("ol/source/VectorTile"), require("ol/style/Circle"), require("ol/style/Fill"), require("ol/style/Icon"), require("ol/style/Stroke"), require("ol/style/Style"), require("ol/style/Text"), require("ol/tilegrid"));
	else
		root["olms"] = factory(root["ol"]["Map"], root["ol"]["Observable"], root["ol"]["format"]["GeoJSON"], root["ol"]["format"]["MVT"], root["ol"]["geom"]["Point"], root["ol"]["layer"]["Tile"], root["ol"]["layer"]["Vector"], root["ol"]["layer"]["VectorTile"], root["ol"]["proj"], root["ol"]["source"]["TileJSON"], root["ol"]["source"]["Vector"], root["ol"]["source"]["VectorTile"], root["ol"]["style"]["Circle"], root["ol"]["style"]["Fill"], root["ol"]["style"]["Icon"], root["ol"]["style"]["Stroke"], root["ol"]["style"]["Style"], root["ol"]["style"]["Text"], root["ol"]["tilegrid"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_ol_Map__, __WEBPACK_EXTERNAL_MODULE_ol_Observable__, __WEBPACK_EXTERNAL_MODULE_ol_format_GeoJSON__, __WEBPACK_EXTERNAL_MODULE_ol_format_MVT__, __WEBPACK_EXTERNAL_MODULE_ol_geom_Point__, __WEBPACK_EXTERNAL_MODULE_ol_layer_Tile__, __WEBPACK_EXTERNAL_MODULE_ol_layer_Vector__, __WEBPACK_EXTERNAL_MODULE_ol_layer_VectorTile__, __WEBPACK_EXTERNAL_MODULE_ol_proj__, __WEBPACK_EXTERNAL_MODULE_ol_source_TileJSON__, __WEBPACK_EXTERNAL_MODULE_ol_source_Vector__, __WEBPACK_EXTERNAL_MODULE_ol_source_VectorTile__, __WEBPACK_EXTERNAL_MODULE_ol_style_Circle__, __WEBPACK_EXTERNAL_MODULE_ol_style_Fill__, __WEBPACK_EXTERNAL_MODULE_ol_style_Icon__, __WEBPACK_EXTERNAL_MODULE_ol_style_Stroke__, __WEBPACK_EXTERNAL_MODULE_ol_style_Style__, __WEBPACK_EXTERNAL_MODULE_ol_style_Text__, __WEBPACK_EXTERNAL_MODULE_ol_tilegrid__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./olms.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                                              ol-mapbox-style - Use Mapbox Style objects with OpenLayers
                                                                                                                                                                                                                                                                              Copyright 2016-present Boundless Spatial, Inc.
                                                                                                                                                                                                                                                                              License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE
                                                                                                                                                                                                                                                                              */

exports.applyStyle = applyStyle;
exports.applyBackground = applyBackground;
exports.apply = apply;
exports.getLayer = getLayer;
exports.getSource = getSource;

var _mapboxGlStyleSpec = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec */ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js");

var _mapboxToCssFont = __webpack_require__(/*! mapbox-to-css-font */ "./node_modules/mapbox-to-css-font/index.js");

var _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);

var _stylefunction = __webpack_require__(/*! ./stylefunction */ "./stylefunction.js");

var _stylefunction2 = _interopRequireDefault(_stylefunction);

var _google = __webpack_require__(/*! webfont-matcher/lib/fonts/google */ "./node_modules/webfont-matcher/lib/fonts/google.js");

var _google2 = _interopRequireDefault(_google);

var _proj = __webpack_require__(/*! ol/proj */ "ol/proj");

var _tilegrid = __webpack_require__(/*! ol/tilegrid */ "ol/tilegrid");

var _Map = __webpack_require__(/*! ol/Map */ "ol/Map");

var _Map2 = _interopRequireDefault(_Map);

var _GeoJSON = __webpack_require__(/*! ol/format/GeoJSON */ "ol/format/GeoJSON");

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

var _MVT = __webpack_require__(/*! ol/format/MVT */ "ol/format/MVT");

var _MVT2 = _interopRequireDefault(_MVT);

var _Observable = __webpack_require__(/*! ol/Observable */ "ol/Observable");

var _Tile = __webpack_require__(/*! ol/layer/Tile */ "ol/layer/Tile");

var _Tile2 = _interopRequireDefault(_Tile);

var _Vector = __webpack_require__(/*! ol/layer/Vector */ "ol/layer/Vector");

var _Vector2 = _interopRequireDefault(_Vector);

var _VectorTile = __webpack_require__(/*! ol/layer/VectorTile */ "ol/layer/VectorTile");

var _VectorTile2 = _interopRequireDefault(_VectorTile);

var _TileJSON = __webpack_require__(/*! ol/source/TileJSON */ "ol/source/TileJSON");

var _TileJSON2 = _interopRequireDefault(_TileJSON);

var _Vector3 = __webpack_require__(/*! ol/source/Vector */ "ol/source/Vector");

var _Vector4 = _interopRequireDefault(_Vector3);

var _VectorTile3 = __webpack_require__(/*! ol/source/VectorTile */ "ol/source/VectorTile");

var _VectorTile4 = _interopRequireDefault(_VectorTile3);

var _XYZ = __webpack_require__(/*! ol/source/XYZ */ "./node_modules/ol/source/XYZ.js");

var _XYZ2 = _interopRequireDefault(_XYZ);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var availableFonts;

function loadFont(fonts) {
  var i, ii;
  if (!Array.isArray(fonts)) {
    var stops = fonts.stops;
    if (stops) {
      for (i = 0, ii = stops.length; i < ii; ++i) {
        loadFont(stops[i][1]);
      }
    }
    return;
  }
  var googleFamilies = _google2.default.getNames();
  var families = fonts.map(function (font) {
    return (0, _mapboxToCssFont2.default)(font, 1).split(' 1px ')[1].replace(/"/g, '');
  });
  for (i = 0, ii = families.length; i < ii; ++i) {
    var family = families[i];
    var font = fonts[i];
    if (googleFamilies.indexOf(family) !== -1) {
      if (!availableFonts) {
        availableFonts = [];
      }
      if (availableFonts.indexOf(font) == -1) {
        availableFonts.push(font);
        var fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+');
        if (!document.querySelector('link[href="' + fontUrl + '"]')) {
          var markup = document.createElement('link');
          markup.href = fontUrl;
          markup.rel = 'stylesheet';
          document.getElementsByTagName('head')[0].appendChild(markup);
        }
      }
      break;
    }
  }
}

var defaultFont = ['Open Sans Regular', 'Arial Regular'];

function preprocess(layer) {
  if ('layout' in layer && 'text-field' in layer.layout) {
    loadFont(layer.layout['text-font'] || defaultFont);
  }
}

var spriteRegEx = /^(.*)(\?.*)$/;

function withPath(url, path) {
  if (path && url.indexOf('http') != 0) {
    url = path + url;
  }
  return url;
}

function toSpriteUrl(url, path, extension) {
  url = withPath(url, path);
  var parts = url.match(spriteRegEx);
  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;
}

/**
 * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`
 * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function
 * will render all layers from the `glStyle` object that use the specified
 * `source`, or a subset of layers from the same source. The source needs to be
 * a `"type": "vector"`, `"type": "geojson"` or `"type": "raster"` source.
 *
 * @param {ol.layer.VectorTile} layer OpenLayers layer.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string} source `source` key or an array of layer `id`s from the
 * Mapbox Style object. When a `source` key is provided, all layers for the
 * specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {string} [path=undefined] Path of the style file. Only required when
 * a relative path is used with the `"sprite"` property of the style.
 * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.
 * @return {Promise} Promise which will be resolved when the style can be used
 * for rendering.
 */
function applyStyle(layer, glStyle, source, path, resolutions) {
  return new Promise(function (resolve, reject) {

    if ((typeof glStyle === 'undefined' ? 'undefined' : _typeof(glStyle)) != 'object') {
      glStyle = JSON.parse(glStyle);
    }
    if (glStyle.version != 8) {
      reject(new Error('glStyle version 8 required.'));
    }
    var spriteScale, spriteData, spriteImageUrl;
    if (glStyle.sprite) {
      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;
      var sizeFactor = spriteScale == 0.5 ? '@2x' : '';
      var spriteUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.json');

      fetch(spriteUrl, { credentials: 'same-origin' }).then(function (response) {
        // if the response is ready return the JSON promise
        if (response.status === 200) {
          return response.json();
        } else if (sizeFactor !== '') {
          // return the JSON promise for the low-resolution sprites.
          sizeFactor = '';
          spriteUrl = toSpriteUrl(glStyle.sprite, path, '.json');
          return fetch(spriteUrl, { credentials: 'same-origin' }).then(function (r) {
            return r.json();
          });
        }
      }).then(function (spritesJson) {
        if (spritesJson === undefined) {
          throw 'No sprites found.';
        }
        spriteData = spritesJson;
        spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.png');
        onChange();
      }).catch(function (err) {
        console.error(err);
        reject(new Error('Sprites cannot be loaded from ' + spriteUrl));
      });
    }

    var style;
    function onChange() {
      if (!style && (!glStyle.sprite || spriteData) && (!availableFonts || availableFonts.length > 0)) {
        style = (0, _stylefunction2.default)(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, availableFonts);
        resolve();
      } else if (style) {
        layer.setStyle(style);
      }
    }

    if (layer instanceof _VectorTile2.default || layer instanceof _Vector2.default) {
      try {
        var layers = glStyle.layers;
        for (var i = 0, ii = layers.length; i < ii; ++i) {
          if (typeof source == 'string' && layers[i].source == source || source.indexOf(layers[i].id) >= 0) {
            preprocess(layers[i]);
          }
        }
        onChange();
      } catch (e) {
        setTimeout(function () {
          reject(e);
        }, 0);
      }
    }
  });
}

function setBackground(map, layer) {
  var background = {
    type: layer.type
  };
  function updateStyle() {
    var element = map.getTargetElement();
    if (!element) {
      return;
    }
    var layout = layer.layout || {};
    var paint = layer.paint || {};
    background['paint'] = paint;
    background.id = 'olms-bg-' + paint['background-opacity'] + paint['background-color'];
    var zoom = map.getView().getZoom();
    if (paint['background-color'] !== undefined) {
      var bg = (0, _stylefunction.getValue)(background, 'paint', 'background-color', zoom, {});
      element.style.background = _mapboxGlStyleSpec.Color.parse(bg).toString();
    }
    if (paint['background-opacity'] !== undefined) {
      element.style.opacity = (0, _stylefunction.getValue)(background, 'paint', 'background-opacity', zoom, {});
    }
    if (layout.visibility == 'none') {
      element.style.backgroundColor = '';
      element.style.opacity = '';
    }
  }
  if (map.getTargetElement()) {
    updateStyle();
  }
  map.on(['change:resolution', 'change:target'], updateStyle);
}

/**
 * Applies properties of the Mapbox Style's first `background` layer to the map.
 * @param {ol.Map} map OpenLayers Map.
 * @param {Object} glStyle Mapbox Style object.
 */
function applyBackground(map, glStyle) {
  glStyle.layers.some(function (l) {
    if (l.type == 'background') {
      setBackground(map, l);
      return true;
    }
  });
}

function getSourceIdByRef(layers, ref) {
  var sourceId;
  layers.some(function (layer) {
    if (layer.id == ref) {
      sourceId = layer.source;
      return true;
    }
  });
  return sourceId;
}

function processStyle(glStyle, map, baseUrl, host, path, accessToken) {
  var view = map.getView();
  if ('center' in glStyle && !view.getCenter()) {
    view.setCenter((0, _proj.fromLonLat)(glStyle.center));
  }
  if ('zoom' in glStyle && view.getZoom() === undefined) {
    view.setZoom(glStyle.zoom);
  }
  if (!view.getCenter() || view.getZoom() === undefined) {
    view.fit(view.getProjection().getExtent(), {
      nearest: true,
      size: map.getSize()
    });
  }
  if (glStyle.sprite) {
    if (glStyle.sprite.indexOf('mapbox://') == 0) {
      glStyle.sprite = baseUrl + '/sprite' + accessToken;
    } else if (glStyle.sprite.indexOf('http') != 0) {
      glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;
    }
  }

  var glLayers = glStyle.layers;
  var geoJsonFormat = new _GeoJSON2.default();
  var layerIds = [];

  function finalizeLayer(layer) {
    if (layerIds.length > 0) {
      map.addLayer(layer);
      var setStyle = function setStyle() {
        applyStyle(layer, glStyle, layerIds, path).then(function () {
          layer.setVisible(true);
        }, function (e) {
          /*eslint no-console: ["error", { allow: ["error"] }] */
          console.error(e);
        });
      };
      if (layer.getSource()) {
        setStyle();
      } else {
        layer.once('change:source', setStyle);
      }
    }
  }

  var glLayer, glSource, glSourceId, id, layer, mapid, url;
  for (var i = 0, ii = glLayers.length; i < ii; ++i) {
    glLayer = glLayers[i];
    if (glLayer.type == 'background') {
      setBackground(map, glLayer);
    } else {
      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);
      if (id != glSourceId) {
        finalizeLayer(layer);
        layerIds = [];
        glSource = glStyle.sources[id];
        url = glSource.url;
        var tiles = glSource.tiles;
        if (url) {
          if (url.indexOf('mapbox://') == 0) {
            mapid = url.replace('mapbox://', '');
            tiles = ['a', 'b', 'c', 'd'].map(function (host) {
              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;
            });
          }
        }

        if (glSource.type == 'vector') {
          layer = tiles ? function () {
            var tileGrid = (0, _tilegrid.createXYZ)({
              tileSize: 512,
              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,
              minZoom: glSource.minzoom
            });
            return new _VectorTile2.default({
              declutter: true,
              maxResolution: tileGrid.getMinZoom() > 0 ? tileGrid.getResolution(tileGrid.getMinZoom()) : undefined,
              source: new _VectorTile4.default({
                attributions: glSource.attribution,
                format: new _MVT2.default(),
                tileGrid: tileGrid,
                urls: tiles
              }),
              visible: false,
              zIndex: i
            });
          }() : function () {
            var layer = new _VectorTile2.default({
              declutter: true,
              visible: false,
              zIndex: i
            });
            var tilejson = new _TileJSON2.default({
              url: url
            });
            var key = tilejson.on('change', function () {
              if (tilejson.getState() == 'ready') {
                var tileJSONDoc = tilejson.getTileJSON();
                var tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];
                for (var i = 0, ii = tiles.length; i < ii; ++i) {
                  var tile = tiles[i];
                  if (tile.indexOf('http') != 0) {
                    tiles[i] = glSource.url + tile;
                  }
                }
                var tileGrid = tilejson.getTileGrid();
                layer.setSource(new _VectorTile4.default({
                  attributions: tilejson.getAttributions() || tileJSONDoc.attribution,
                  format: new _MVT2.default(),
                  tileGrid: (0, _tilegrid.createXYZ)({
                    minZoom: tileGrid.getMinZoom(),
                    maxZoom: tileGrid.getMaxZoom(),
                    tileSize: 512
                  }),
                  urls: tiles
                }));
                if (tileGrid.getMinZoom() > 0) {
                  layer.setMaxResolution(tileGrid.getResolution(tileGrid.getMinZoom()));
                }
                (0, _Observable.unByKey)(key);
              }
            });
            return layer;
          }();
        } else if (glSource.type == 'raster') {
          var source;
          if (!glSource.tiles) {
            source = function () {
              return new _TileJSON2.default({
                url: url,
                crossOrigin: 'anonymous'
              });
            }();
          } else {
            source = new _XYZ2.default({
              attributions: glSource.attribution,
              minZoom: glSource.minzoom,
              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,
              tileSize: glSource.tileSize || 512,
              url: url,
              urls: glSource.tiles,
              crossOrigin: 'anonymous'
            });
          }
          source.setTileLoadFunction(function (tile, src) {
            if (src.indexOf('{bbox-epsg-3857}') != -1) {
              var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());
              src = src.replace('{bbox-epsg-3857}', bbox.toString());
            }
            tile.getImage().src = src;
          });
          layer = new _Tile2.default({
            source: source,
            visible: glLayer.layout ? glLayer.layout.visibility !== 'none' : true
          });
        } else if (glSource.type == 'geojson') {
          var data = glSource.data;
          var features, geoJsonUrl;
          if (typeof data == 'string') {
            geoJsonUrl = withPath(data, path);
          } else {
            features = geoJsonFormat.readFeatures(data, { featureProjection: 'EPSG:3857' });
          }
          layer = new _Vector2.default({
            source: new _Vector4.default({
              attributions: glSource.attribution,
              features: features,
              format: geoJsonFormat,
              url: geoJsonUrl
            }),
            visible: false,
            zIndex: i
          });
        }
        glSourceId = id;
      }
      layerIds.push(glLayer.id);
    }
  }
  finalizeLayer(layer);
  map.set('mapbox-style', glStyle);
}

/**
 * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes
 * the map background, the layers, the center and the zoom.
 *
 * The center and zoom will only be set if present in the Mapbox Style document,
 * and if not already set on the OpenLayers map.
 *
 * Layers will be added to the OpenLayers map, without affecting any layers that
 * might already be set on the map.
 *
 * Layers added by `apply()` will have two additional properties:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * The map returned by this function will have an additional `mapbox-style`
 * property which holds the Mapbox Style object.
 *
 * @param {ol.Map|HTMLElement|string} map Either an existing OpenLayers Map
 * instance, or a HTML element, or the id of a HTML element that will be the
 * target of a new OpenLayers Map.
 * @param {string|Object} style JSON style object or style url pointing to a
 * Mapbox Style object. When using Mapbox APIs, the url must contain an access
 * token and look like
 * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.
 * When passed as JSON style object, all OpenLayers layers created by `apply()`
 * will be immediately available, but they may not have a source yet (i.e. when
 * they are defined by a TileJSON url in the Mapbox Style document). When passed
 * as style url, layers will be added to the map when the Mapbox Style document
 * is loaded and parsed.
 * @return {ol.Map} The OpenLayers Map instance that will be populated with the
 * contents described in the Mapbox Style object.
 */
function apply(map, style) {

  var accessToken, baseUrl, host, path;
  accessToken = baseUrl = host = path = '';

  if (!(map instanceof _Map2.default)) {
    map = new _Map2.default({
      target: map
    });
  }

  if (typeof style === 'string') {
    var parts = style.match(spriteRegEx);
    if (parts) {
      baseUrl = parts[1];
      accessToken = parts.length > 2 ? parts[2] : '';
    }

    fetch(style, {
      credentials: 'same-origin'
    }).then(function (response) {
      return response.json();
    }).then(function (glStyle) {
      var a = document.createElement('A');
      a.href = style;
      path = a.pathname.split('/').slice(0, -1).join('/') + '/';
      host = style.substr(0, style.indexOf(path));

      processStyle(glStyle, map, baseUrl, host, path, accessToken);
    }).catch(function (err) {
      console.error(err);
      throw new Error('Could not load ' + style);
    });
  } else {
    setTimeout(function () {
      processStyle(style, map);
    }, 0);
  }
  return map;
}

/**
 * Get the OpenLayers layer instance that contains the provided Mapbox Style
 * `layer`. Note that multiple Mapbox Style layers are combined in a single
 * OpenLayers layer instance when they use the same Mapbox Style `source`.
 * @param {ol.Map} map OpenLayers Map.
 * @param {string} layerId Mapbox Style layer id.
 * @return {ol.layer.Layer} layer OpenLayers layer instance.
 */
function getLayer(map, layerId) {
  var layers = map.getLayers().getArray();
  for (var i = 0, ii = layers.length; i < ii; ++i) {
    if (layers[i].get('mapbox-layers').indexOf(layerId) !== -1) {
      return layers[i];
    }
  }
}

/**
 * Get the OpenLayers source instance for the provided Mapbox Style `source`.
 * @param {ol.Map} map OpenLayers Map.
 * @param {string} sourceId Mapbox Style source id.
 * @return {ol.layer.Layer} layer OpenLayers layer instance.
 */
function getSource(map, sourceId) {
  var layers = map.getLayers().getArray();
  for (var i = 0, ii = layers.length; i < ii; ++i) {
    var source = layers[i].getSource();
    if (layers[i].get('mapbox-source').indexOf(sourceId) !== -1) {
      return source;
    }
  }
}

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var $version = 8;
var $root = {
    version: {
        required: true,
        type: "enum",
        values: [8],
        doc: "Style specification version number. Must be 8.",
        example: 8
    },
    name: {
        type: "string",
        doc: "A human-readable name for the style.",
        example: "Bright"
    },
    metadata: {
        type: "*",
        doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    center: {
        type: "array",
        value: "number",
        doc: "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: [-73.9749, 40.7736]
    },
    zoom: {
        type: "number",
        doc: "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 12.5
    },
    bearing: {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Default bearing, in degrees. The bearing is the compass direction that is \"up\"; for example, a bearing of 90° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 29
    },
    pitch: {
        type: "number",
        "default": 0,
        units: "degrees",
        doc: "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 50
    },
    light: {
        type: "light",
        doc: "The global light source.",
        example: {
            anchor: "viewport",
            color: "white",
            intensity: 0.4
        }
    },
    sources: {
        required: true,
        type: "sources",
        doc: "Data source specifications.",
        example: {
            "mapbox-streets": {
                type: "vector",
                url: "mapbox://mapbox.mapbox-streets-v6"
            }
        }
    },
    sprite: {
        type: "string",
        doc: "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
        example: "mapbox://sprites/mapbox/bright-v8"
    },
    glyphs: {
        type: "string",
        doc: "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
        example: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
    },
    transition: {
        type: "transition",
        doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.",
        example: {
            duration: 300,
            delay: 0
        }
    },
    layers: {
        required: true,
        type: "array",
        value: "layer",
        doc: "Layers will be drawn in the order of this array.",
        example: [{
            id: "water",
            source: "mapbox-streets",
            "source-layer": "water",
            type: "fill",
            paint: {
                "fill-color": "#00ffff"
            }
        }]
    }
};
var sources = {
    "*": {
        type: "source",
        doc: "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."
    }
};
var source = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];
var source_vector = {
    type: {
        required: true,
        type: "enum",
        values: {
            vector: {
                doc: "A vector tile source."
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    scheme: {
        type: "enum",
        values: {
            xyz: {
                doc: "Slippy map tilenames scheme."
            },
            tms: {
                doc: "OSGeo spec scheme."
            }
        },
        "default": "xyz",
        doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    promoteId: {
        type: "promoteId",
        doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers."
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_raster = {
    type: {
        required: true,
        type: "enum",
        values: {
            raster: {
                doc: "A raster tile source."
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    tileSize: {
        type: "number",
        "default": 512,
        units: "pixels",
        doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    scheme: {
        type: "enum",
        values: {
            xyz: {
                doc: "Slippy map tilenames scheme."
            },
            tms: {
                doc: "OSGeo spec scheme."
            }
        },
        "default": "xyz",
        doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_raster_dem = {
    type: {
        required: true,
        type: "enum",
        values: {
            "raster-dem": {
                doc: "A RGB-encoded raster DEM source"
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    tileSize: {
        type: "number",
        "default": 512,
        units: "pixels",
        doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    encoding: {
        type: "enum",
        values: {
            terrarium: {
                doc: "Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info."
            },
            mapbox: {
                doc: "Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info."
            }
        },
        "default": "mapbox",
        doc: "The encoding used by this source. Mapbox Terrain RGB is used by default"
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_geojson = {
    type: {
        required: true,
        type: "enum",
        values: {
            geojson: {
                doc: "A GeoJSON data source."
            }
        },
        doc: "The data type of the GeoJSON source."
    },
    data: {
        type: "*",
        doc: "A URL to a GeoJSON file, or inline GeoJSON."
    },
    maxzoom: {
        type: "number",
        "default": 18,
        doc: "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    buffer: {
        type: "number",
        "default": 128,
        maximum: 512,
        minimum: 0,
        doc: "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."
    },
    tolerance: {
        type: "number",
        "default": 0.375,
        doc: "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
    },
    cluster: {
        type: "boolean",
        "default": false,
        doc: "If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\n * `cluster` Is `true` if the point is a cluster \n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\n * `point_count` Number of original points grouped into this cluster\n * `point_count_abbreviated` An abbreviated point count"
    },
    clusterRadius: {
        type: "number",
        "default": 50,
        minimum: 0,
        doc: "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."
    },
    clusterMaxZoom: {
        type: "number",
        doc: "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered)."
    },
    clusterProperties: {
        type: "*",
        doc: "An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{\"property_name\": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `\"+\"` or `\"max\"`) — it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\n\nExample: `{\"sum\": [\"+\", [\"get\", \"scalerank\"]]}`.\n\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `[\"accumulated\"]` value, e.g.:\n`{\"sum\": [[\"+\", [\"accumulated\"], [\"get\", \"sum\"]], [\"get\", \"scalerank\"]]}`"
    },
    lineMetrics: {
        type: "boolean",
        "default": false,
        doc: "Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values."
    },
    generateId: {
        type: "boolean",
        "default": false,
        doc: "Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values."
    },
    promoteId: {
        type: "promoteId",
        doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`."
    }
};
var source_video = {
    type: {
        required: true,
        type: "enum",
        values: {
            video: {
                doc: "A video data source."
            }
        },
        doc: "The data type of the video source."
    },
    urls: {
        required: true,
        type: "array",
        value: "string",
        doc: "URLs to video content in order of preferred format."
    },
    coordinates: {
        required: true,
        doc: "Corners of video specified in longitude, latitude pairs.",
        type: "array",
        length: 4,
        value: {
            type: "array",
            length: 2,
            value: "number",
            doc: "A single longitude, latitude pair."
        }
    }
};
var source_image = {
    type: {
        required: true,
        type: "enum",
        values: {
            image: {
                doc: "An image data source."
            }
        },
        doc: "The data type of the image source."
    },
    url: {
        required: true,
        type: "string",
        doc: "URL that points to an image."
    },
    coordinates: {
        required: true,
        doc: "Corners of image specified in longitude, latitude pairs.",
        type: "array",
        length: 4,
        value: {
            type: "array",
            length: 2,
            value: "number",
            doc: "A single longitude, latitude pair."
        }
    }
};
var layer = {
    id: {
        type: "string",
        doc: "Unique layer name.",
        required: true
    },
    type: {
        type: "enum",
        values: {
            fill: {
                doc: "A filled polygon with an optional stroked border.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            line: {
                doc: "A stroked line.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            symbol: {
                doc: "An icon or a text label.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            circle: {
                doc: "A filled circle.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            heatmap: {
                doc: "A heatmap.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.41.0",
                        android: "6.0.0",
                        ios: "4.0.0",
                        macos: "0.7.0"
                    }
                }
            },
            "fill-extrusion": {
                doc: "An extruded (3D) polygon.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.27.0",
                        android: "5.1.0",
                        ios: "3.6.0",
                        macos: "0.5.0"
                    }
                }
            },
            raster: {
                doc: "Raster map textures such as satellite imagery.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            hillshade: {
                doc: "Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.43.0",
                        android: "6.0.0",
                        ios: "4.0.0",
                        macos: "0.7.0"
                    }
                }
            },
            background: {
                doc: "The background color or pattern of the map.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            }
        },
        doc: "Rendering type of this layer.",
        required: true
    },
    metadata: {
        type: "*",
        doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    source: {
        type: "string",
        doc: "Name of a source description to be used for this layer. Required for all layer types except `background`."
    },
    "source-layer": {
        type: "string",
        doc: "Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources."
    },
    minzoom: {
        type: "number",
        minimum: 0,
        maximum: 24,
        doc: "The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden."
    },
    maxzoom: {
        type: "number",
        minimum: 0,
        maximum: 24,
        doc: "The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden."
    },
    filter: {
        type: "filter",
        doc: "A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `feature-state` expression is not supported in filter expressions."
    },
    layout: {
        type: "layout",
        doc: "Layout properties for the layer."
    },
    paint: {
        type: "paint",
        doc: "Default paint properties for this layer."
    }
};
var layout = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"];
var layout_background = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_fill = {
    "fill-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0"
            },
            "data-driven styling": {
                js: "1.2.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_circle = {
    "circle-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0"
            },
            "data-driven styling": {
                js: "1.2.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_heatmap = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_line = {
    "line-cap": {
        type: "enum",
        values: {
            butt: {
                doc: "A cap with a squared-off end which is drawn to the exact endpoint of the line."
            },
            round: {
                doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
            },
            square: {
                doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
            }
        },
        "default": "butt",
        doc: "The display of line endings.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-join": {
        type: "enum",
        values: {
            bevel: {
                doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
            },
            round: {
                doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
            },
            miter: {
                doc: "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."
            }
        },
        "default": "miter",
        doc: "The display of lines when joining.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "line-miter-limit": {
        type: "number",
        "default": 2,
        doc: "Used to automatically convert miter joins to bevel joins for sharp angles.",
        requires: [{
            "line-join": "miter"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-round-limit": {
        type: "number",
        "default": 1.05,
        doc: "Used to automatically convert round joins to miter joins for shallow angles.",
        requires: [{
            "line-join": "round"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0"
            },
            "data-driven styling": {
                js: "1.2.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_symbol = {
    "symbol-placement": {
        type: "enum",
        values: {
            point: {
                doc: "The label is placed at the point where the geometry is located."
            },
            line: {
                doc: "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."
            },
            "line-center": {
                doc: "The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries."
            }
        },
        "default": "point",
        doc: "Label placement relative to its geometry.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`line-center` value": {
                js: "0.47.0",
                android: "6.4.0",
                ios: "4.3.0",
                macos: "0.10.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-spacing": {
        type: "number",
        "default": 250,
        minimum: 1,
        units: "pixels",
        doc: "Distance between two symbol anchors.",
        requires: [{
            "symbol-placement": "line"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-avoid-edges": {
        type: "boolean",
        "default": false,
        doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "0.53.0",
                android: "7.4.0",
                ios: "4.11.0",
                macos: "0.14.0"
            },
            "data-driven styling": {
                js: "0.53.0",
                android: "7.4.0",
                ios: "4.11.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "symbol-z-order": {
        type: "enum",
        values: {
            auto: {
                doc: "If `symbol-sort-key` is set, sort based on that. Otherwise sort symbols by their y-position relative to the viewport."
            },
            "viewport-y": {
                doc: "Symbols will be sorted by their y-position relative to the viewport."
            },
            source: {
                doc: "Symbols will be rendered in the same order as the source data with no sorting applied."
            }
        },
        "default": "auto",
        doc: "Controls the order in which overlapping symbols in the same layer are rendered",
        "sdk-support": {
            "basic functionality": {
                js: "0.49.0",
                android: "6.6.0",
                ios: "4.5.0",
                macos: "0.12.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-allow-overlap": {
        type: "boolean",
        "default": false,
        doc: "If true, the icon will be visible even if it collides with other previously drawn symbols.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-ignore-placement": {
        type: "boolean",
        "default": false,
        doc: "If true, other symbols can be visible even if they collide with the icon.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-optional": {
        type: "boolean",
        "default": false,
        doc: "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
        requires: ["icon-image", "text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-rotation-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line."
            },
            viewport: {
                doc: "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
            },
            auto: {
                doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
            }
        },
        "default": "auto",
        doc: "In combination with `symbol-placement`, determines the rotation behavior of icons.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-size": {
        type: "number",
        "default": 1,
        minimum: 0,
        units: "factor of the original icon size",
        doc: "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-text-fit": {
        type: "enum",
        values: {
            none: {
                doc: "The icon is displayed at its intrinsic aspect ratio."
            },
            width: {
                doc: "The icon is scaled in the x-dimension to fit the width of the text."
            },
            height: {
                doc: "The icon is scaled in the y-dimension to fit the height of the text."
            },
            both: {
                doc: "The icon is scaled in both x- and y-dimensions."
            }
        },
        "default": "none",
        doc: "Scales the icon to fit around the associated text.",
        requires: ["icon-image", "text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-text-fit-padding": {
        type: "array",
        value: "number",
        length: 4,
        "default": [0, 0, 0, 0],
        units: "pixels",
        doc: "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",
        requires: ["icon-image", "text-field", {
            "icon-text-fit": ["both", "width", "height"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-image": {
        type: "resolvedImage",
        doc: "Name of image in sprite to use for drawing an image background.",
        tokens: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Rotates the icon clockwise.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.21.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-padding": {
        type: "number",
        "default": 2,
        minimum: 0,
        units: "pixels",
        doc: "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-keep-upright": {
        type: "boolean",
        "default": false,
        doc: "If true, the icon may be flipped to prevent it from being rendered upside-down.",
        requires: ["icon-image", {
            "icon-rotation-alignment": "map"
        }, {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-offset": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        doc: "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-anchor": {
        type: "enum",
        values: {
            center: {
                doc: "The center of the icon is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the icon is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the icon is placed closest to the anchor."
            },
            top: {
                doc: "The top of the icon is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the icon is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the icon is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the icon is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the icon is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the icon is placed closest to the anchor."
            }
        },
        "default": "center",
        doc: "Part of the icon placed closest to the anchor.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The icon is aligned to the plane of the map."
            },
            viewport: {
                doc: "The icon is aligned to the plane of the viewport."
            },
            auto: {
                doc: "Automatically matches the value of `icon-rotation-alignment`."
            }
        },
        "default": "auto",
        doc: "Orientation of icon when map is pitched.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The text is aligned to the plane of the map."
            },
            viewport: {
                doc: "The text is aligned to the plane of the viewport."
            },
            auto: {
                doc: "Automatically matches the value of `text-rotation-alignment`."
            }
        },
        "default": "auto",
        doc: "Orientation of text when map is pitched.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-rotation-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line."
            },
            viewport: {
                doc: "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
            },
            auto: {
                doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
            }
        },
        "default": "auto",
        doc: "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-field": {
        type: "formatted",
        "default": "",
        tokens: true,
        doc: "Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-font": {
        type: "array",
        value: "string",
        "default": ["Open Sans Regular", "Arial Unicode MS Regular"],
        doc: "Font stack to use for displaying text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-size": {
        type: "number",
        "default": 16,
        minimum: 0,
        units: "pixels",
        doc: "Font size.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-max-width": {
        type: "number",
        "default": 10,
        minimum: 0,
        units: "ems",
        doc: "The maximum line width for text wrapping.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-line-height": {
        type: "number",
        "default": 1.2,
        units: "ems",
        doc: "Text leading value for multi-line text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-letter-spacing": {
        type: "number",
        "default": 0,
        units: "ems",
        doc: "Text tracking amount.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-justify": {
        type: "enum",
        values: {
            auto: {
                doc: "The text is aligned towards the anchor position."
            },
            left: {
                doc: "The text is aligned to the left."
            },
            center: {
                doc: "The text is centered."
            },
            right: {
                doc: "The text is aligned to the right."
            }
        },
        "default": "center",
        doc: "Text justification options.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            },
            auto: {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-radial-offset": {
        type: "number",
        units: "ems",
        "default": 0,
        doc: "Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",
        "sdk-support": {
            "basic functionality": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            },
            "data-driven styling": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        requires: ["text-field"],
        "property-type": "data-driven",
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        }
    },
    "text-variable-anchor": {
        type: "array",
        value: "enum",
        values: {
            center: {
                doc: "The center of the text is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the text is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the text is placed closest to the anchor."
            },
            top: {
                doc: "The top of the text is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the text is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the text is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the text is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the text is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the text is placed closest to the anchor."
            }
        },
        requires: ["text-field", {
            "symbol-placement": ["point"]
        }],
        doc: "To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.",
        "sdk-support": {
            "basic functionality": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-anchor": {
        type: "enum",
        values: {
            center: {
                doc: "The center of the text is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the text is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the text is placed closest to the anchor."
            },
            top: {
                doc: "The top of the text is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the text is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the text is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the text is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the text is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the text is placed closest to the anchor."
            }
        },
        "default": "center",
        doc: "Part of the text placed closest to the anchor.",
        requires: ["text-field", {
            "!": "text-variable-anchor"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-max-angle": {
        type: "number",
        "default": 45,
        units: "degrees",
        doc: "Maximum angle change between adjacent characters.",
        requires: ["text-field", {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-writing-mode": {
        type: "array",
        value: "enum",
        values: {
            horizontal: {
                doc: "If a text's language supports horizontal writing mode, symbols with point placement would be laid out horizontally."
            },
            vertical: {
                doc: "If a text's language supports vertical writing mode, symbols with point placement would be laid out vertically."
            }
        },
        doc: "The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesn’t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. The order of elements in an array define priority order for the placement of an orientation variant.",
        requires: ["text-field", {
            "symbol-placement": ["point"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "1.3.0",
                android: "8.3.0",
                ios: "5.3.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Rotates the text clockwise.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-padding": {
        type: "number",
        "default": 2,
        minimum: 0,
        units: "pixels",
        doc: "Size of the additional area around the text bounding box used for detecting symbol collisions.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-keep-upright": {
        type: "boolean",
        "default": true,
        doc: "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
        requires: ["text-field", {
            "text-rotation-alignment": "map"
        }, {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-transform": {
        type: "enum",
        values: {
            none: {
                doc: "The text is not altered."
            },
            uppercase: {
                doc: "Forces all letters to be displayed in uppercase."
            },
            lowercase: {
                doc: "Forces all letters to be displayed in lowercase."
            }
        },
        "default": "none",
        doc: "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-offset": {
        type: "array",
        doc: "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.",
        value: "number",
        units: "ems",
        length: 2,
        "default": [0, 0],
        requires: ["text-field", {
            "!": "text-radial-offset"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-allow-overlap": {
        type: "boolean",
        "default": false,
        doc: "If true, the text will be visible even if it collides with other previously drawn symbols.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-ignore-placement": {
        type: "boolean",
        "default": false,
        doc: "If true, other symbols can be visible even if they collide with the text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-optional": {
        type: "boolean",
        "default": false,
        doc: "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
        requires: ["text-field", "icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_raster = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_hillshade = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        "property-type": "constant"
    }
};
var filter = {
    type: "array",
    value: "*",
    doc: "A filter selects specific features from a layer."
};
var filter_operator = {
    type: "enum",
    values: {
        "==": {
            doc: "`[\"==\", key, value]` equality: `feature[key] = value`"
        },
        "!=": {
            doc: "`[\"!=\", key, value]` inequality: `feature[key] ≠ value`"
        },
        ">": {
            doc: "`[\">\", key, value]` greater than: `feature[key] > value`"
        },
        ">=": {
            doc: "`[\">=\", key, value]` greater than or equal: `feature[key] ≥ value`"
        },
        "<": {
            doc: "`[\"<\", key, value]` less than: `feature[key] < value`"
        },
        "<=": {
            doc: "`[\"<=\", key, value]` less than or equal: `feature[key] ≤ value`"
        },
        "in": {
            doc: "`[\"in\", key, v0, ..., vn]` set inclusion: `feature[key] ∈ {v0, ..., vn}`"
        },
        "!in": {
            doc: "`[\"!in\", key, v0, ..., vn]` set exclusion: `feature[key] ∉ {v0, ..., vn}`"
        },
        all: {
            doc: "`[\"all\", f0, ..., fn]` logical `AND`: `f0 ∧ ... ∧ fn`"
        },
        any: {
            doc: "`[\"any\", f0, ..., fn]` logical `OR`: `f0 ∨ ... ∨ fn`"
        },
        none: {
            doc: "`[\"none\", f0, ..., fn]` logical `NOR`: `¬f0 ∧ ... ∧ ¬fn`"
        },
        has: {
            doc: "`[\"has\", key]` `feature[key]` exists"
        },
        "!has": {
            doc: "`[\"!has\", key]` `feature[key]` does not exist"
        }
    },
    doc: "The filter operator."
};
var geometry_type = {
    type: "enum",
    values: {
        Point: {
            doc: "Filter to point geometries."
        },
        LineString: {
            doc: "Filter to line geometries."
        },
        Polygon: {
            doc: "Filter to polygon geometries."
        }
    },
    doc: "The geometry type for the filter to select."
};
var function_stop = {
    type: "array",
    minimum: 0,
    maximum: 24,
    value: ["number", "color"],
    length: 2,
    doc: "Zoom level and value pair."
};
var expression = {
    type: "array",
    value: "*",
    minimum: 1,
    doc: "An expression defines a function that can be used for data-driven style properties or feature filters."
};
var expression_name = {
    doc: "",
    type: "enum",
    values: {
        "let": {
            doc: "Binds expressions to named variables, which can then be referenced in the result expression using [\"var\", \"variable_name\"].",
            group: "Variable binding",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "var": {
            doc: "References variable bound using \"let\".",
            group: "Variable binding",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        literal: {
            doc: "Provides a literal array or object value.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        array: {
            doc: "Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        at: {
            doc: "Retrieves an item from an array.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "in": {
            doc: "Determines whether an item exists in an array or a substring exists in a string.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "1.6.0"
                }
            }
        },
        "index-of": {
            doc: "Returns the first index at which a given element can be found in an array, or for a string, the first occurrence of the specified value. If a second argument is provided, then the search is started from that position. Returns -1 if the value is not found.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "1.10.0"
                }
            }
        },
        "case": {
            doc: "Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        match: {
            doc: "Selects the output whose label value matches the input value, or the fallback value if no match is found. The input can be any expression (e.g. `[\"get\", \"building_type\"]`). Each label must be either:\n * a single literal value; or\n * an array of literal values, whose values must be all strings or all numbers (e.g. `[100, 101]` or `[\"c\", \"b\"]`). The input matches if any of the values in the array matches, similar to the `\"in\"` operator.\n\nEach label must be unique. If the input type does not match the type of the labels, the result will be the fallback value.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        coalesce: {
            doc: "Evaluates each expression in turn until the first non-null value is obtained, and returns that value.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        step: {
            doc: "Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        interpolate: {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\n\nInterpolation types:\n- `[\"linear\"]`: interpolates linearly between the pair of stops just less than and just greater than the input.\n- `[\"exponential\", base]`: interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\n- `[\"cubic-bezier\", x1, y1, x2, y2]`: interpolates using the cubic bezier curve defined by the given control points.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "interpolate-hcl": {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.49.0"
                }
            }
        },
        "interpolate-lab": {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.49.0"
                }
            }
        },
        ln2: {
            doc: "Returns mathematical constant ln(2).",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        pi: {
            doc: "Returns the mathematical constant pi.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        e: {
            doc: "Returns the mathematical constant e.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "typeof": {
            doc: "Returns a string describing the type of the given value.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        string: {
            doc: "Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        number: {
            doc: "Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        boolean: {
            doc: "Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        object: {
            doc: "Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        collator: {
            doc: "Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        format: {
            doc: "Returns `formatted` text containing annotations for use in mixed-format `text-field` entries. For a `text-field` entries of a string type, following option object's properties are supported: If set, the `text-font` value overrides the font specified by the root layout properties. If set, the `font-scale` value specifies a scaling factor relative to the `text-size` specified in the root layout properties. If set, the `text-color` value overrides the color specified by the root paint properties for this layer.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "text-font": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "font-scale": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "text-color": {
                    js: "1.3.0",
                    android: "7.3.0",
                    ios: "4.10.0",
                    macos: "0.14.0"
                },
                image: {
                    js: "1.6.0"
                }
            }
        },
        image: {
            doc: "Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "1.4.0",
                    android: "8.6.0",
                    ios: "5.6.0"
                }
            }
        },
        "number-format": {
            doc: "Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.54.0"
                }
            }
        },
        "to-string": {
            doc: "Converts the input value to a string. If the input is `null`, the result is `\"\"`. If the input is a boolean, the result is `\"true\"` or `\"false\"`. If the input is a number, it is converted to a string as specified by the [\"NumberToString\" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `\"rgba(r,g,b,a)\"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-number": {
            doc: "Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the [\"ToNumber Applied to the String Type\" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-boolean": {
            doc: "Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-rgba": {
            doc: "Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-color": {
            doc: "Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        rgb: {
            doc: "Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        rgba: {
            doc: "Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        get: {
            doc: "Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns null if the requested property is missing.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        has: {
            doc: "Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        length: {
            doc: "Gets the length of an array or string.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        properties: {
            doc: "Gets the feature properties object.  Note that in some cases, it may be more efficient to use [\"get\", \"property_name\"] directly.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "feature-state": {
            doc: "Retrieves a property value from the current feature's state. Returns null if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\"feature-state\"] can only be used with paint properties that support data-driven styling.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.46.0"
                }
            }
        },
        "geometry-type": {
            doc: "Gets the feature's geometry type: Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        id: {
            doc: "Gets the feature's id, if it has one.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        zoom: {
            doc: "Gets the current zoom level.  Note that in style layout and paint properties, [\"zoom\"] may only appear as the input to a top-level \"step\" or \"interpolate\" expression.",
            group: "Zoom",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "heatmap-density": {
            doc: "Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",
            group: "Heatmap",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "line-progress": {
            doc: "Gets the progress along a gradient line. Can only be used in the `line-gradient` property.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                }
            }
        },
        accumulated: {
            doc: "Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.53.0"
                }
            }
        },
        "+": {
            doc: "Returns the sum of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "*": {
            doc: "Returns the product of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "-": {
            doc: "For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "/": {
            doc: "Returns the result of floating point division of the first input by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "%": {
            doc: "Returns the remainder after integer division of the first input by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "^": {
            doc: "Returns the result of raising the first input to the power specified by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        sqrt: {
            doc: "Returns the square root of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        log10: {
            doc: "Returns the base-ten logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        ln: {
            doc: "Returns the natural logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        log2: {
            doc: "Returns the base-two logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        sin: {
            doc: "Returns the sine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        cos: {
            doc: "Returns the cosine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        tan: {
            doc: "Returns the tangent of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        asin: {
            doc: "Returns the arcsine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        acos: {
            doc: "Returns the arccosine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        atan: {
            doc: "Returns the arctangent of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        min: {
            doc: "Returns the minimum value of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        max: {
            doc: "Returns the maximum value of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        round: {
            doc: "Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `[\"round\", -1.5]` evaluates to -2.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        abs: {
            doc: "Returns the absolute value of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        ceil: {
            doc: "Returns the smallest integer that is greater than or equal to the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        floor: {
            doc: "Returns the largest integer that is less than or equal to the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "==": {
            doc: "Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "!=": {
            doc: "Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        ">": {
            doc: "Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "<": {
            doc: "Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        ">=": {
            doc: "Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "<=": {
            doc: "Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        all: {
            doc: "Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        any: {
            doc: "Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "!": {
            doc: "Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        within: {
            doc: "Returns `true` if the feature being evaluated is inside the pre-defined geometry boundary, `false` otherwise. The expression has one argument which must be a valid GeoJSON Polygon/Multi-Polygon object. The expression only evaluates on `Point` or `LineString` feature. For `Point` feature, The expression will return false if any point of the feature is on the boundary or outside the boundary. For `LineString` feature, the expression will return false if the line is fully outside the boundary, or the line is partially intersecting the boundary, which means either part of the line is outside of the boundary, or end point of the line lies on the boundary.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "1.9.0"
                }
            }
        },
        "is-supported-script": {
            doc: "Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.6.0"
                }
            }
        },
        upcase: {
            doc: "Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        downcase: {
            doc: "Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        concat: {
            doc: "Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "resolved-locale": {
            doc: "Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        slice: {
            doc: "Returns a portion of a string or an array starting from the provided beginning index. If a second argument is provided, then the return portion will run to, but not include, the end index.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "1.10.0"
                }
            }
        }
    }
};
var light = {
    anchor: {
        type: "enum",
        "default": "viewport",
        values: {
            map: {
                doc: "The position of the light source is aligned to the rotation of the map."
            },
            viewport: {
                doc: "The position of the light source is aligned to the rotation of the viewport."
            }
        },
        "property-type": "data-constant",
        transition: false,
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        doc: "Whether extruded geometries are lit relative to the map or viewport.",
        example: "map",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    position: {
        type: "array",
        "default": [1.15, 210, 30],
        length: 3,
        value: "number",
        "property-type": "data-constant",
        transition: true,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        doc: "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0° (0° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0°, directly above, to 180°, directly below).",
        example: [1.5, 90, 80],
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    color: {
        type: "color",
        "property-type": "data-constant",
        "default": "#ffffff",
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "Color tint for lighting extruded geometries.",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    intensity: {
        type: "number",
        "property-type": "data-constant",
        "default": 0.5,
        minimum: 0,
        maximum: 1,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    }
};
var paint = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"];
var paint_fill = {
    "fill-antialias": {
        type: "boolean",
        "default": true,
        doc: "Whether or not the fill should be antialiased.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-opacity": {
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        doc: "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.21.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-color": {
        type: "color",
        "default": "#000000",
        doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
        transition: true,
        requires: [{
            "!": "fill-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.19.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-outline-color": {
        type: "color",
        doc: "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
        transition: true,
        requires: [{
            "!": "fill-pattern"
        }, {
            "fill-antialias": true
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.19.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The fill is translated relative to the map."
            },
            viewport: {
                doc: "The fill is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `fill-translate`.",
        "default": "map",
        requires: ["fill-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.49.0",
                android: "6.5.0",
                macos: "0.11.0",
                ios: "4.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "cross-faded-data-driven"
    }
};
var paint_line = {
    "line-opacity": {
        type: "number",
        doc: "The opacity at which the line will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-color": {
        type: "color",
        doc: "The color with which the line will be drawn.",
        "default": "#000000",
        transition: true,
        requires: [{
            "!": "line-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.23.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The line is translated relative to the map."
            },
            viewport: {
                doc: "The line is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `line-translate`.",
        "default": "map",
        requires: ["line-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-width": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Stroke thickness.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-gap-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        doc: "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
        transition: true,
        units: "pixels",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-offset": {
        type: "number",
        "default": 0,
        doc: "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
        transition: true,
        units: "pixels",
        "sdk-support": {
            "basic functionality": {
                js: "0.12.1",
                android: "3.0.0",
                ios: "3.1.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Blur applied to the line, in pixels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-dasharray": {
        type: "array",
        value: "number",
        doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        minimum: 0,
        transition: true,
        units: "line widths",
        requires: [{
            "!": "line-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "cross-faded"
    },
    "line-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.49.0",
                android: "6.5.0",
                macos: "0.11.0",
                ios: "4.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "cross-faded-data-driven"
    },
    "line-gradient": {
        type: "color",
        doc: "Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `\"lineMetrics\": true`.",
        transition: false,
        requires: [{
            "!": "line-dasharray"
        }, {
            "!": "line-pattern"
        }, {
            source: "geojson",
            has: {
                lineMetrics: true
            }
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.45.0",
                android: "6.5.0",
                ios: "4.4.0",
                macos: "0.11.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: true,
            parameters: ["line-progress"]
        },
        "property-type": "color-ramp"
    }
};
var paint_circle = {
    "circle-radius": {
        type: "number",
        "default": 5,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Circle radius.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.18.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-color": {
        type: "color",
        "default": "#000000",
        doc: "The fill color of the circle.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.18.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-blur": {
        type: "number",
        "default": 0,
        doc: "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.20.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-opacity": {
        type: "number",
        doc: "The opacity at which the circle will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.20.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The circle is translated relative to the map."
            },
            viewport: {
                doc: "The circle is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `circle-translate`.",
        "default": "map",
        requires: ["circle-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-pitch-scale": {
        type: "enum",
        values: {
            map: {
                doc: "Circles are scaled according to their apparent distance to the camera."
            },
            viewport: {
                doc: "Circles are not scaled."
            }
        },
        "default": "map",
        doc: "Controls the scaling behavior of the circle when the map is pitched.",
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The circle is aligned to the plane of the map."
            },
            viewport: {
                doc: "The circle is aligned to the plane of the viewport."
            }
        },
        "default": "viewport",
        doc: "Orientation of circle when map is pitched.",
        "sdk-support": {
            "basic functionality": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-stroke-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-stroke-color": {
        type: "color",
        "default": "#000000",
        doc: "The stroke color of the circle.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-stroke-opacity": {
        type: "number",
        doc: "The opacity of the circle's stroke.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    }
};
var paint_heatmap = {
    "heatmap-radius": {
        type: "number",
        "default": 30,
        minimum: 1,
        transition: true,
        units: "pixels",
        doc: "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "heatmap-weight": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: false,
        doc: "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "heatmap-intensity": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: true,
        doc: "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "heatmap-color": {
        type: "color",
        "default": ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"],
        doc: "Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `[\"heatmap-density\"]` as input.",
        transition: false,
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: true,
            parameters: ["heatmap-density"]
        },
        "property-type": "color-ramp"
    },
    "heatmap-opacity": {
        type: "number",
        doc: "The global opacity at which the heatmap layer will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_symbol = {
    "icon-opacity": {
        doc: "The opacity at which the icon will be drawn.",
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-color": {
        type: "color",
        "default": "#000000",
        transition: true,
        doc: "The color of the icon. This can only be used with sdf icons.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-color": {
        type: "color",
        "default": "rgba(0, 0, 0, 0)",
        transition: true,
        doc: "The color of the icon's halo. Icon halos can only be used with SDF icons.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Distance of halo to the icon outline.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Fade out the halo towards the outside.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "Icons are translated relative to the map."
            },
            viewport: {
                doc: "Icons are translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `icon-translate`.",
        "default": "map",
        requires: ["icon-image", "icon-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-opacity": {
        type: "number",
        doc: "The opacity at which the text will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-color": {
        type: "color",
        doc: "The color with which the text will be drawn.",
        "default": "#000000",
        transition: true,
        overridable: true,
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-color": {
        type: "color",
        "default": "rgba(0, 0, 0, 0)",
        transition: true,
        doc: "The color of the text's halo, which helps it stand out from backgrounds.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "The halo's fadeout distance towards the outside.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The text is translated relative to the map."
            },
            viewport: {
                doc: "The text is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `text-translate`.",
        "default": "map",
        requires: ["text-field", "text-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_raster = {
    "raster-opacity": {
        type: "number",
        doc: "The opacity at which the image will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-hue-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        transition: true,
        units: "degrees",
        doc: "Rotates hues around the color wheel.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-brightness-min": {
        type: "number",
        doc: "Increase or reduce the brightness of the image. The value is the minimum brightness.",
        "default": 0,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-brightness-max": {
        type: "number",
        doc: "Increase or reduce the brightness of the image. The value is the maximum brightness.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-saturation": {
        type: "number",
        doc: "Increase or reduce the saturation of the image.",
        "default": 0,
        minimum: -1,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-contrast": {
        type: "number",
        doc: "Increase or reduce the contrast of the image.",
        "default": 0,
        minimum: -1,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-resampling": {
        type: "enum",
        doc: "The resampling/interpolation method to use for overscaling, also known as texture magnification filter",
        values: {
            linear: {
                doc: "(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled"
            },
            nearest: {
                doc: "Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled"
            }
        },
        "default": "linear",
        "sdk-support": {
            "basic functionality": {
                js: "0.47.0",
                android: "6.3.0",
                ios: "4.2.0",
                macos: "0.9.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-fade-duration": {
        type: "number",
        "default": 300,
        minimum: 0,
        transition: false,
        units: "milliseconds",
        doc: "Fade duration when a new tile is added.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_hillshade = {
    "hillshade-illumination-direction": {
        type: "number",
        "default": 335,
        minimum: 0,
        maximum: 359,
        doc: "The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.",
        transition: false,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-illumination-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The hillshade illumination is relative to the north direction."
            },
            viewport: {
                doc: "The hillshade illumination is relative to the top of the viewport."
            }
        },
        "default": "viewport",
        doc: "Direction of light source when map is rotated.",
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-exaggeration": {
        type: "number",
        doc: "Intensity of the hillshade",
        "default": 0.5,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-shadow-color": {
        type: "color",
        "default": "#000000",
        doc: "The shading color of areas that face away from the light source.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-highlight-color": {
        type: "color",
        "default": "#FFFFFF",
        doc: "The shading color of areas that faces towards the light source.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-accent-color": {
        type: "color",
        "default": "#000000",
        doc: "The shading color used to accentuate rugged terrain like sharp cliffs and gorges.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_background = {
    "background-color": {
        type: "color",
        "default": "#000000",
        doc: "The color with which the background will be drawn.",
        transition: true,
        requires: [{
            "!": "background-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "background-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "cross-faded"
    },
    "background-opacity": {
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        doc: "The opacity at which the background will be drawn.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var transition = {
    duration: {
        type: "number",
        "default": 300,
        minimum: 0,
        units: "milliseconds",
        doc: "Time allotted for transitions to complete."
    },
    delay: {
        type: "number",
        "default": 0,
        minimum: 0,
        units: "milliseconds",
        doc: "Length of time before a transition begins."
    }
};
var promoteId = {
    "*": {
        type: "string",
        doc: "A name of a feature property to use as ID for feature state."
    }
};
var v8 = {
    $version: $version,
    $root: $root,
    sources: sources,
    source: source,
    source_vector: source_vector,
    source_raster: source_raster,
    source_raster_dem: source_raster_dem,
    source_geojson: source_geojson,
    source_video: source_video,
    source_image: source_image,
    layer: layer,
    layout: layout,
    layout_background: layout_background,
    layout_fill: layout_fill,
    layout_circle: layout_circle,
    layout_heatmap: layout_heatmap,
    "layout_fill-extrusion": {
        visibility: {
            type: "enum",
            values: {
                visible: {
                    doc: "The layer is shown."
                },
                none: {
                    doc: "The layer is not shown."
                }
            },
            "default": "visible",
            doc: "Whether this layer is displayed.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            "property-type": "constant"
        }
    },
    layout_line: layout_line,
    layout_symbol: layout_symbol,
    layout_raster: layout_raster,
    layout_hillshade: layout_hillshade,
    filter: filter,
    filter_operator: filter_operator,
    geometry_type: geometry_type,
    "function": {
        expression: {
            type: "expression",
            doc: "An expression."
        },
        stops: {
            type: "array",
            doc: "An array of stops.",
            value: "function_stop"
        },
        base: {
            type: "number",
            "default": 1,
            minimum: 0,
            doc: "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
        },
        property: {
            type: "string",
            doc: "The name of a feature property to use as the function input.",
            "default": "$zoom"
        },
        type: {
            type: "enum",
            values: {
                identity: {
                    doc: "Return the input value as the output value."
                },
                exponential: {
                    doc: "Generate an output by interpolating between stops just less than and just greater than the function input."
                },
                interval: {
                    doc: "Return the output value of the stop just less than the function input."
                },
                categorical: {
                    doc: "Return the output value of the stop equal to the function input."
                }
            },
            doc: "The interpolation strategy to use in function evaluation.",
            "default": "exponential"
        },
        colorSpace: {
            type: "enum",
            values: {
                rgb: {
                    doc: "Use the RGB color space to interpolate color values"
                },
                lab: {
                    doc: "Use the LAB color space to interpolate color values."
                },
                hcl: {
                    doc: "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."
                }
            },
            doc: "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",
            "default": "rgb"
        },
        "default": {
            type: "*",
            required: false,
            doc: "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances."
        }
    },
    function_stop: function_stop,
    expression: expression,
    expression_name: expression_name,
    light: light,
    paint: paint,
    paint_fill: paint_fill,
    "paint_fill-extrusion": {
        "fill-extrusion-opacity": {
            type: "number",
            "default": 1,
            minimum: 0,
            maximum: 1,
            doc: "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",
            transition: true,
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-color": {
            type: "color",
            "default": "#000000",
            doc: "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",
            transition: true,
            requires: [{
                "!": "fill-extrusion-pattern"
            }],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-translate": {
            type: "array",
            value: "number",
            length: 2,
            "default": [0, 0],
            transition: true,
            units: "pixels",
            doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-translate-anchor": {
            type: "enum",
            values: {
                map: {
                    doc: "The fill extrusion is translated relative to the map."
                },
                viewport: {
                    doc: "The fill extrusion is translated relative to the viewport."
                }
            },
            doc: "Controls the frame of reference for `fill-extrusion-translate`.",
            "default": "map",
            requires: ["fill-extrusion-translate"],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-pattern": {
            type: "resolvedImage",
            transition: true,
            doc: "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.49.0",
                    android: "6.5.0",
                    macos: "0.11.0",
                    ios: "4.4.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom", "feature"]
            },
            "property-type": "cross-faded-data-driven"
        },
        "fill-extrusion-height": {
            type: "number",
            "default": 0,
            minimum: 0,
            units: "meters",
            doc: "The height with which to extrude this layer.",
            transition: true,
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-base": {
            type: "number",
            "default": 0,
            minimum: 0,
            units: "meters",
            doc: "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",
            transition: true,
            requires: ["fill-extrusion-height"],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-vertical-gradient": {
            type: "boolean",
            "default": true,
            doc: "Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.",
            transition: false,
            "sdk-support": {
                "basic functionality": {
                    js: "0.50.0",
                    ios: "4.7.0",
                    macos: "0.13.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        }
    },
    paint_line: paint_line,
    paint_circle: paint_circle,
    paint_heatmap: paint_heatmap,
    paint_symbol: paint_symbol,
    paint_raster: paint_raster,
    paint_hillshade: paint_hillshade,
    paint_background: paint_background,
    transition: transition,
    "property-type": {
        "data-driven": {
            type: "property-type",
            doc: "Property is interpolable and can be represented using a property expression."
        },
        "cross-faded": {
            type: "property-type",
            doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms."
        },
        "cross-faded-data-driven": {
            type: "property-type",
            doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression."
        },
        "color-ramp": {
            type: "property-type",
            doc: "Property should be specified using a color ramp from which the output color can be sampled based on a property calculation."
        },
        "data-constant": {
            type: "property-type",
            doc: "Property is interpolable but cannot be represented using a property expression."
        },
        constant: {
            type: "property-type",
            doc: "Property is constant across all zoom levels and property values."
        }
    },
    promoteId: promoteId
};

// Note: This regex matches even invalid JSON strings, but since we’re
// working on the output of `JSON.stringify` we know that only valid strings
// are present (unless the user supplied a weird `options.indent` but in
// that case we don’t care since the output would be invalid anyway).
var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;

var jsonStringifyPrettyCompact = function stringify(passedObj, options) {
    var indent, maxLength, replacer;

    options = options || {};
    indent = JSON.stringify([1], undefined, options.indent === undefined ? 2 : options.indent).slice(2, -3);
    maxLength = indent === "" ? Infinity : options.maxLength === undefined ? 80 : options.maxLength;
    replacer = options.replacer;

    return function _stringify(obj, currentIndent, reserved) {
        // prettier-ignore
        var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;

        if (obj && typeof obj.toJSON === "function") {
            obj = obj.toJSON();
        }

        string = JSON.stringify(obj, replacer);

        if (string === undefined) {
            return string;
        }

        length = maxLength - currentIndent.length - reserved;

        if (string.length <= length) {
            prettified = string.replace(stringOrChar, function (match, stringLiteral) {
                return stringLiteral || match + " ";
            });
            if (prettified.length <= length) {
                return prettified;
            }
        }

        if (replacer != null) {
            obj = JSON.parse(string);
            replacer = undefined;
        }

        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && obj !== null) {
            nextIndent = currentIndent + indent;
            items = [];
            index = 0;

            if (Array.isArray(obj)) {
                start = "[";
                end = "]";
                length = obj.length;
                for (; index < length; index++) {
                    items.push(_stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || "null");
                }
            } else {
                start = "{";
                end = "}";
                keys = Object.keys(obj);
                length = keys.length;
                for (; index < length; index++) {
                    key = keys[index];
                    keyPart = JSON.stringify(key) + ": ";
                    value = _stringify(obj[key], nextIndent, keyPart.length + (index === length - 1 ? 0 : 1));
                    if (value !== undefined) {
                        items.push(keyPart + value);
                    }
                }
            }

            if (items.length > 0) {
                return [start, indent + items.join(",\n" + nextIndent), end].join("\n" + currentIndent);
            }
        }

        return string;
    }(passedObj, "", 0);
};

function sortKeysBy(obj, reference) {
    var result = {};
    for (var key in reference) {
        if (obj[key] !== undefined) {
            result[key] = obj[key];
        }
    }
    for (var key$1 in obj) {
        if (result[key$1] === undefined) {
            result[key$1] = obj[key$1];
        }
    }
    return result;
}
function format(style, space) {
    if (space === void 0) space = 2;
    style = sortKeysBy(style, v8.$root);
    if (style.layers) {
        style.layers = style.layers.map(function (layer) {
            return sortKeysBy(layer, v8.layer);
        });
    }
    return jsonStringifyPrettyCompact(style, { indent: space });
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire() {
    throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
    return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var punycode = createCommonjsModule(function (module, exports) {
    (function (root) {

        /** Detect free variables */
        var freeExports = exports && !exports.nodeType && exports;
        var freeModule = module && !module.nodeType && module;
        var freeGlobal = (typeof commonjsGlobal === "undefined" ? "undefined" : _typeof(commonjsGlobal)) == 'object' && commonjsGlobal;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
            root = freeGlobal;
        }

        /**
         * The `punycode` object.
         * @name punycode
         * @type Object
         */
        var punycode,


        /** Highest positive signed 32-bit float value */
        maxInt = 2147483647,
            // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128,
            // 0x80
        delimiter = '-',
            // '\x2D'

        /** Regular expressions */
        regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/,
            // unprintable ASCII chars + non-ASCII chars
        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
            // RFC 3490 separators

        /** Error messages */
        errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
        },


        /** Convenience shortcuts */
        baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,


        /** Temporary variable */
        key;

        /*--------------------------------------------------------------------------*/

        /**
         * A generic error utility function.
         * @private
         * @param {String} type The error type.
         * @returns {Error} Throws a `RangeError` with the applicable error message.
         */
        function error(type) {
            throw RangeError(errors[type]);
        }

        /**
         * A generic `Array#map` utility function.
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function that gets called for every array
         * item.
         * @returns {Array} A new array of values returned by the callback function.
         */
        function map(array, fn) {
            var length = array.length;
            var result = [];
            while (length--) {
                result[length] = fn(array[length]);
            }
            return result;
        }

        /**
         * A simple `Array#map`-like wrapper to work with domain name strings or email
         * addresses.
         * @private
         * @param {String} domain The domain name or email address.
         * @param {Function} callback The function that gets called for every
         * character.
         * @returns {Array} A new string of characters returned by the callback
         * function.
         */
        function mapDomain(string, fn) {
            var parts = string.split('@');
            var result = '';
            if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@';
                string = parts[1];
            }
            // Avoid `split(regex)` for IE8 compatibility. See #17.
            string = string.replace(regexSeparators, '\x2E');
            var labels = string.split('.');
            var encoded = map(labels, fn).join('.');
            return result + encoded;
        }

        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         * @see `punycode.ucs2.encode`
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode.ucs2
         * @name decode
         * @param {String} string The Unicode input string (UCS-2).
         * @returns {Array} The new array of code points.
         */
        function ucs2decode(string) {
            var output = [],
                counter = 0,
                length = string.length,
                value,
                extra;
            while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                    // high surrogate, and there is a next character
                    extra = string.charCodeAt(counter++);
                    if ((extra & 0xFC00) == 0xDC00) {
                        // low surrogate
                        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                    } else {
                        // unmatched surrogate; only append this code unit, in case the next
                        // code unit is the high surrogate of a surrogate pair
                        output.push(value);
                        counter--;
                    }
                } else {
                    output.push(value);
                }
            }
            return output;
        }

        /**
         * Creates a string based on an array of numeric code points.
         * @see `punycode.ucs2.decode`
         * @memberOf punycode.ucs2
         * @name encode
         * @param {Array} codePoints The array of numeric code points.
         * @returns {String} The new Unicode string (UCS-2).
         */
        function ucs2encode(array) {
            return map(array, function (value) {
                var output = '';
                if (value > 0xFFFF) {
                    value -= 0x10000;
                    output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                    value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
            }).join('');
        }

        /**
         * Converts a basic code point into a digit/integer.
         * @see `digitToBasic()`
         * @private
         * @param {Number} codePoint The basic numeric code point value.
         * @returns {Number} The numeric value of a basic code point (for use in
         * representing integers) in the range `0` to `base - 1`, or `base` if
         * the code point does not represent a value.
         */
        function basicToDigit(codePoint) {
            if (codePoint - 48 < 10) {
                return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
                return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
                return codePoint - 97;
            }
            return base;
        }

        /**
         * Converts a digit/integer into a basic code point.
         * @see `basicToDigit()`
         * @private
         * @param {Number} digit The numeric value of a basic code point.
         * @returns {Number} The basic code point whose value (when used for
         * representing integers) is `digit`, which needs to be in the range
         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
         * used; else, the lowercase form is used. The behavior is undefined
         * if `flag` is non-zero and `digit` has no uppercase form.
         */
        function digitToBasic(digit, flag) {
            //  0..25 map to ASCII a..z or A..Z
            // 26..35 map to ASCII 0..9
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }

        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * http://tools.ietf.org/html/rfc3492#section-3.4
         * @private
         */
        function adapt(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }

        /**
         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
         * symbols.
         * @memberOf punycode
         * @param {String} input The Punycode string of ASCII-only symbols.
         * @returns {String} The resulting string of Unicode symbols.
         */
        function decode(input) {
            // Don't use UCS-2
            var output = [],
                inputLength = input.length,
                out,
                i = 0,
                n = initialN,
                bias = initialBias,
                basic,
                j,
                index,
                oldi,
                w,
                k,
                digit,
                t,

            /** Cached calculation results */
            baseMinusT;

            // Handle the basic code points: let `basic` be the number of input code
            // points before the last delimiter, or `0` if there is none, then copy
            // the first basic code points to the output.

            basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
                basic = 0;
            }

            for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                    error('not-basic');
                }
                output.push(input.charCodeAt(j));
            }

            // Main decoding loop: start just after the last delimiter if any basic code
            // points were copied; start at the beginning otherwise.

            for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

                    if (index >= inputLength) {
                        error('invalid-input');
                    }

                    digit = basicToDigit(input.charCodeAt(index++));

                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error('overflow');
                    }

                    i += digit * w;
                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                    if (digit < t) {
                        break;
                    }

                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                        error('overflow');
                    }

                    w *= baseMinusT;
                }

                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);

                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                    error('overflow');
                }

                n += floor(i / out);
                i %= out;

                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n);
            }

            return ucs2encode(output);
        }

        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         * @memberOf punycode
         * @param {String} input The string of Unicode symbols.
         * @returns {String} The resulting Punycode string of ASCII-only symbols.
         */
        function encode(input) {
            var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],

            /** `inputLength` will hold the number of code points in `input`. */
            inputLength,

            /** Cached calculation results */
            handledCPCountPlusOne,
                baseMinusT,
                qMinusT;

            // Convert the input in UCS-2 to Unicode
            input = ucs2decode(input);

            // Cache the length
            inputLength = input.length;

            // Initialize the state
            n = initialN;
            delta = 0;
            bias = initialBias;

            // Handle the basic code points
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue));
                }
            }

            handledCPCount = basicLength = output.length;

            // `handledCPCount` is the number of code points that have been handled;
            // `basicLength` is the number of basic code points.

            // Finish the basic string - if it is not empty - with a delimiter
            if (basicLength) {
                output.push(delimiter);
            }

            // Main encoding loop:
            while (handledCPCount < inputLength) {

                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                    }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error('overflow');
                }

                delta += (m - n) * handledCPCountPlusOne;
                n = m;

                for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];

                    if (currentValue < n && ++delta > maxInt) {
                        error('overflow');
                    }

                    if (currentValue == n) {
                        // Represent delta as a generalized variable-length integer
                        for (q = delta, k = base;; /* no condition */k += base) {
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (q < t) {
                                break;
                            }
                            qMinusT = q - t;
                            baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }

                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }

                ++delta;
                ++n;
            }
            return output.join('');
        }

        /**
         * Converts a Punycode string representing a domain name or an email address
         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
         * it doesn't matter if you call it on a string that has already been
         * converted to Unicode.
         * @memberOf punycode
         * @param {String} input The Punycoded domain name or email address to
         * convert to Unicode.
         * @returns {String} The Unicode representation of the given Punycode
         * string.
         */
        function toUnicode(input) {
            return mapDomain(input, function (string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
        }

        /**
         * Converts a Unicode string representing a domain name or an email address to
         * Punycode. Only the non-ASCII parts of the domain name will be converted,
         * i.e. it doesn't matter if you call it with a domain that's already in
         * ASCII.
         * @memberOf punycode
         * @param {String} input The domain name or email address to convert, as a
         * Unicode string.
         * @returns {String} The Punycode representation of the given domain name or
         * email address.
         */
        function toASCII(input) {
            return mapDomain(input, function (string) {
                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
            });
        }

        /*--------------------------------------------------------------------------*/

        /** Define the public API */
        punycode = {
            /**
             * A string representing the current Punycode.js version number.
             * @memberOf punycode
             * @type String
             */
            'version': '1.3.2',
            /**
             * An object of methods to convert from JavaScript's internal character
             * representation (UCS-2) to Unicode code points, and back.
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode
             * @type Object
             */
            'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
            },
            'decode': decode,
            'encode': encode,
            'toASCII': toASCII,
            'toUnicode': toUnicode
        };

        /** Expose `punycode` */
        // Some AMD build optimizers, like r.js, check for specific condition patterns
        // like the following:
        if (freeExports && freeModule) {
            if (module.exports == freeExports) {
                // in Node.js or RingoJS v0.8.0+
                freeModule.exports = punycode;
            } else {
                // in Narwhal or RingoJS v0.7.0-
                for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
            }
        } else {
            // in Rhino or a web browser
            root.punycode = punycode;
        }
    })(commonjsGlobal);
});

var util = {
    isString: function isString(arg) {
        return typeof arg === 'string';
    },
    isObject: function isObject(arg) {
        return (typeof arg === "undefined" ? "undefined" : _typeof(arg)) === 'object' && arg !== null;
    },
    isNull: function isNull(arg) {
        return arg === null;
    },
    isNullOrUndefined: function isNullOrUndefined(arg) {
        return arg == null;
    }
};

// Copyright Joyent, Inc. and other Node contributors.

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

var decode = function decode(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr,
            vstr,
            k,
            v;

        if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
        } else {
            kstr = x;
            vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
        } else if (Array.isArray(obj[k])) {
            obj[k].push(v);
        } else {
            obj[k] = [obj[k], v];
        }
    }

    return obj;
};

// Copyright Joyent, Inc. and other Node contributors.

var stringifyPrimitive = function stringifyPrimitive(v) {
    switch (typeof v === "undefined" ? "undefined" : _typeof(v)) {
        case 'string':
            return v;

        case 'boolean':
            return v ? 'true' : 'false';

        case 'number':
            return isFinite(v) ? v : '';

        default:
            return '';
    }
};

var encode = function encode(obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
        obj = undefined;
    }

    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === 'object') {
        return Object.keys(obj).map(function (k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (Array.isArray(obj[k])) {
                return obj[k].map(function (v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
            } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
        }).join(sep);
    }

    if (!name) {
        return '';
    }
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var querystring = createCommonjsModule(function (module, exports) {

    exports.decode = exports.parse = decode;
    exports.encode = exports.stringify = encode;
});
var querystring_1 = querystring.decode;
var querystring_2 = querystring.parse;
var querystring_3 = querystring.encode;
var querystring_4 = querystring.stringify;

var parse = urlParse;
var resolve = urlResolve;
var resolveObject = urlResolveObject;
var format$1 = urlFormat;

var Url_1 = Url;

function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
    'javascript': true,
    'javascript:': true
},

// protocols that never have a hostname.
hostlessProtocol = {
    'javascript': true,
    'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
};

function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && util.isObject(url) && url instanceof Url) {
        return url;
    }

    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
    if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === "undefined" ? "undefined" : _typeof(url)));
    }

    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    var queryIndex = url.indexOf('?'),
        splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
        uSplit = url.split(splitter),
        slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, '/');
    url = uSplit.join(splitter);

    var rest = url;

    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();

    if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                    this.query = querystring.parse(this.search.substr(1));
                } else {
                    this.query = this.search.substr(1);
                }
            } else if (parseQueryString) {
                this.search = '';
                this.query = {};
            }
            return this;
        }
    }

    var proto = protocolPattern.exec(rest);
    if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
    }

    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
        }
    }

    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                hostEnd = hec;
            }
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
            // atSign can be anywhere.
            atSign = rest.lastIndexOf('@');
        } else {
            // atSign must be in auth portion.
            // http://a@b/c@d => host:b auth:a path:/c@d
            atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                hostEnd = hec;
            }
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1) {
            hostEnd = rest.length;
        }

        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        this.parseHost();

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part) {
                    continue;
                }
                if (!part.match(hostnamePartPattern)) {
                    var newpart = '';
                    for (var j = 0, k = part.length; j < k; j++) {
                        if (part.charCodeAt(j) > 127) {
                            // we replace non-ASCII char with a temporary placeholder
                            // we need this to make sure size of hostname is not
                            // broken by replacing non-ASCII by nothing
                            newpart += 'x';
                        } else {
                            newpart += part[j];
                        }
                    }
                    // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                        var validParts = hostparts.slice(0, i);
                        var notHost = hostparts.slice(i + 1);
                        var bit = part.match(hostnamePartStart);
                        if (bit) {
                            validParts.push(bit[1]);
                            notHost.unshift(bit[2]);
                        }
                        if (notHost.length) {
                            rest = '/' + notHost.join('.') + rest;
                        }
                        this.hostname = validParts.join('.');
                        break;
                    }
                }
            }
        }

        if (this.hostname.length > hostnameMaxLen) {
            this.hostname = '';
        } else {
            // hostnames are always lower case.
            this.hostname = this.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
            // IDNA Support: Returns a punycoded representation of "domain".
            // It only converts parts of the domain name that
            // have non-ASCII characters, i.e. it doesn't matter if
            // you call it with a domain that already is ASCII-only.
            this.hostname = punycode.toASCII(this.hostname);
        }

        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host;

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== '/') {
                rest = '/' + rest;
            }
        }
    }

    // now rest is set to the post-host stuff.
    // chop off any delim chars.
    if (!unsafeProtocol[lowerProto]) {

        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
            var ae = autoEscape[i];
            if (rest.indexOf(ae) === -1) {
                continue;
            }
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
                esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
        }
    }

    // chop off from the tail first.
    var hash = rest.indexOf('#');
    if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
            this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
    } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
    }
    if (rest) {
        this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = '/';
    }

    //to support http.request
    if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
    }

    // finally, reconstruct the href based on what has been validated.
    this.href = this.format();
    return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
    // ensure it's an object, and not a string url.
    // If it's an obj, this is a no-op.
    // this way, you can call url_format() on strings
    // to clean up potentially wonky urls.
    if (util.isString(obj)) {
        obj = urlParse(obj);
    }
    if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
    }
    return obj.format();
}

Url.prototype.format = function () {
    var auth = this.auth || '';
    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
    }

    var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';

    if (this.host) {
        host = auth + this.host;
    } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
        if (this.port) {
            host += ':' + this.port;
        }
    }

    if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
    }

    var search = this.search || query && '?' + query || '';

    if (protocol && protocol.substr(-1) !== ':') {
        protocol += ':';
    }

    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
    // unless they had them to begin with.
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') {
            pathname = '/' + pathname;
        }
    } else if (!host) {
        host = '';
    }

    if (hash && hash.charAt(0) !== '#') {
        hash = '#' + hash;
    }
    if (search && search.charAt(0) !== '?') {
        search = '?' + search;
    }

    pathname = pathname.replace(/[?#]/g, function (match) {
        return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');

    return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
    if (!source) {
        return relative;
    }
    return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
    if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
    }

    var result = new Url();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
    }

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === '') {
        result.href = result.format();
        return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== 'protocol') {
                result[rkey] = relative[rkey];
            }
        }

        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
    }

    if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
            }
            result.href = result.format();
            return result;
        }

        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || '').split('/');
            while (relPath.length && !(relative.host = relPath.shift())) {}
            if (!relative.host) {
                relative.host = '';
            }
            if (!relative.hostname) {
                relative.hostname = '';
            }
            if (relPath[0] !== '') {
                relPath.unshift('');
            }
            if (relPath.length < 2) {
                relPath.unshift('');
            }
            result.pathname = relPath.join('/');
        } else {
            result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
            var p = result.pathname || '';
            var s = result.search || '';
            result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }

    var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
        isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
        mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
            if (srcPath[0] === '') {
                srcPath[0] = result.host;
            } else {
                srcPath.unshift(result.host);
            }
        }
        result.host = '';
        if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
                if (relPath[0] === '') {
                    relPath[0] = relative.host;
                } else {
                    relPath.unshift(relative.host);
                }
            }
            relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }

    if (isRelAbs) {
        // it's absolute.
        result.host = relative.host || relative.host === '' ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) {
            srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
    } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
    }

    if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
            result.path = '/' + result.search;
        } else {
            result.path = null;
        }
        result.href = result.format();
        return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
            srcPath.splice(i, 1);
        } else if (last === '..') {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
            srcPath.unshift('..');
        }
    }

    if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
    }

    if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
        srcPath.push('');
    }

    var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }

    mustEndAbs = mustEndAbs || result.host && srcPath.length;

    if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
    }

    if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
    } else {
        result.pathname = srcPath.join('/');
    }

    //to support request.http
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
};

Url.prototype.parseHost = function () {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
        port = port[0];
        if (port !== ':') {
            this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
    }
    if (host) {
        this.hostname = host;
    }
};

var url = {
    parse: parse,
    resolve: resolve,
    resolveObject: resolveObject,
    format: format$1,
    Url: Url_1
};

function getPropertyReference(propertyName) {
    for (var i = 0; i < v8.layout.length; i++) {
        for (var key in v8[v8.layout[i]]) {
            if (key === propertyName) {
                return v8[v8.layout[i]][key];
            }
        }
    }
    for (var i$1 = 0; i$1 < v8.paint.length; i$1++) {
        for (var key$1 in v8[v8.paint[i$1]]) {
            if (key$1 === propertyName) {
                return v8[v8.paint[i$1]][key$1];
            }
        }
    }
    return null;
}
function eachSource(style, callback) {
    for (var k in style.sources) {
        callback(style.sources[k]);
    }
}
function eachLayer(style, callback) {
    for (var i = 0, list = style.layers; i < list.length; i += 1) {
        var layer = list[i];
        callback(layer);
    }
}
function eachProperty(style, options, callback) {
    function inner(layer, propertyType) {
        var properties = layer[propertyType];
        if (!properties) {
            return;
        }
        Object.keys(properties).forEach(function (key) {
            callback({
                path: [layer.id, propertyType, key],
                key: key,
                value: properties[key],
                reference: getPropertyReference(key),
                set: function set(x) {
                    properties[key] = x;
                }
            });
        });
    }
    eachLayer(style, function (layer) {
        if (options.paint) {
            inner(layer, 'paint');
        }
        if (options.layout) {
            inner(layer, 'layout');
        }
    });
}

function eachLayout(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('layout') === 0) {
            callback(layer[k], k);
        }
    }
}
function eachPaint(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('paint') === 0) {
            callback(layer[k], k);
        }
    }
}
function resolveConstant(style, value) {
    if (typeof value === 'string' && value[0] === '@') {
        return resolveConstant(style, style.constants[value]);
    } else {
        return value;
    }
}
function isFunction(value) {
    return Array.isArray(value.stops);
}
function renameProperty(obj, from, to) {
    obj[to] = obj[from];
    delete obj[from];
}
function migrateToV8(style) {
    style.version = 8;
    eachSource(style, function (source) {
        if (source.type === 'video' && source.url !== undefined) {
            renameProperty(source, 'url', 'urls');
        }
        if (source.type === 'video') {
            source.coordinates.forEach(function (coord) {
                return coord.reverse();
            });
        }
    });
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            if (layout['symbol-min-distance'] !== undefined) {
                renameProperty(layout, 'symbol-min-distance', 'symbol-spacing');
            }
        });
        eachPaint(layer, function (paint) {
            if (paint['background-image'] !== undefined) {
                renameProperty(paint, 'background-image', 'background-pattern');
            }
            if (paint['line-image'] !== undefined) {
                renameProperty(paint, 'line-image', 'line-pattern');
            }
            if (paint['fill-image'] !== undefined) {
                renameProperty(paint, 'fill-image', 'fill-pattern');
            }
        });
    });
    eachProperty(style, {
        paint: true,
        layout: true
    }, function (property) {
        var value = resolveConstant(style, property.value);
        if (isFunction(value)) {
            value.stops.forEach(function (stop) {
                stop[1] = resolveConstant(style, stop[1]);
            });
        }
        property.set(value);
    });
    delete style.constants;
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            delete layout['text-max-size'];
            delete layout['icon-max-size'];
        });
        eachPaint(layer, function (paint) {
            if (paint['text-size']) {
                if (!layer.layout) {
                    layer.layout = {};
                }
                layer.layout['text-size'] = paint['text-size'];
                delete paint['text-size'];
            }
            if (paint['icon-size']) {
                if (!layer.layout) {
                    layer.layout = {};
                }
                layer.layout['icon-size'] = paint['icon-size'];
                delete paint['icon-size'];
            }
        });
    });
    function migrateFontstackURL(input) {
        var inputParsed = url.parse(input);
        var inputPathnameParts = inputParsed.pathname.split('/');
        if (inputParsed.protocol !== 'mapbox:') {
            return input;
        } else if (inputParsed.hostname === 'fontstack') {
            return 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf';
        } else if (inputParsed.hostname === 'fonts') {
            return 'mapbox://fonts/' + inputPathnameParts[2] + '/{fontstack}/{range}.pbf';
        }
    }
    if (style.glyphs) {
        style.glyphs = migrateFontstackURL(style.glyphs);
    }
    function migrateFontStack(font) {
        function splitAndTrim(string) {
            return string.split(',').map(function (s) {
                return s.trim();
            });
        }
        if (Array.isArray(font)) {
            return font;
        } else if (typeof font === 'string') {
            return splitAndTrim(font);
        } else if ((typeof font === "undefined" ? "undefined" : _typeof(font)) === 'object') {
            font.stops.forEach(function (stop) {
                stop[1] = splitAndTrim(stop[1]);
            });
            return font;
        } else {
            throw new Error('unexpected font value');
        }
    }
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            if (layout['text-font']) {
                layout['text-font'] = migrateFontStack(layout['text-font']);
            }
        });
    });
    var firstSymbolLayer = 0;
    for (var i = style.layers.length - 1; i >= 0; i--) {
        var layer = style.layers[i];
        if (layer.type !== 'symbol') {
            firstSymbolLayer = i + 1;
            break;
        }
    }
    var symbolLayers = style.layers.splice(firstSymbolLayer);
    symbolLayers.reverse();
    style.layers = style.layers.concat(symbolLayers);
    return style;
}

function extend(output) {
    var inputs = [],
        len = arguments.length - 1;
    while (len-- > 0) {
        inputs[len] = arguments[len + 1];
    }for (var i = 0, list = inputs; i < list.length; i += 1) {
        var input = list[i];
        for (var k in input) {
            output[k] = input[k];
        }
    }
    return output;
}

var ParsingError = function (Error) {
    function ParsingError(key, message) {
        Error.call(this, message);
        this.message = message;
        this.key = key;
    }
    if (Error) ParsingError.__proto__ = Error;
    ParsingError.prototype = Object.create(Error && Error.prototype);
    ParsingError.prototype.constructor = ParsingError;
    return ParsingError;
}(Error);

var Scope = function Scope(parent, bindings) {
    if (bindings === void 0) bindings = [];
    this.parent = parent;
    this.bindings = {};
    for (var i = 0, list = bindings; i < list.length; i += 1) {
        var ref = list[i];
        var name = ref[0];
        var expression = ref[1];
        this.bindings[name] = expression;
    }
};
Scope.prototype.concat = function concat(bindings) {
    return new Scope(this, bindings);
};
Scope.prototype.get = function get(name) {
    if (this.bindings[name]) {
        return this.bindings[name];
    }
    if (this.parent) {
        return this.parent.get(name);
    }
    throw new Error(name + ' not found in scope.');
};
Scope.prototype.has = function has(name) {
    if (this.bindings[name]) {
        return true;
    }
    return this.parent ? this.parent.has(name) : false;
};

var NullType = { kind: 'null' };
var NumberType = { kind: 'number' };
var StringType = { kind: 'string' };
var BooleanType = { kind: 'boolean' };
var ColorType = { kind: 'color' };
var ObjectType = { kind: 'object' };
var ValueType = { kind: 'value' };
var ErrorType = { kind: 'error' };
var CollatorType = { kind: 'collator' };
var FormattedType = { kind: 'formatted' };
var ResolvedImageType = { kind: 'resolvedImage' };
function array(itemType, N) {
    return {
        kind: 'array',
        itemType: itemType,
        N: N
    };
}
function toString(type) {
    if (type.kind === 'array') {
        var itemType = toString(type.itemType);
        return typeof type.N === 'number' ? 'array<' + itemType + ', ' + type.N + '>' : type.itemType.kind === 'value' ? 'array' : 'array<' + itemType + '>';
    } else {
        return type.kind;
    }
}
var valueMemberTypes = [NullType, NumberType, StringType, BooleanType, ColorType, FormattedType, ObjectType, array(ValueType), ResolvedImageType];
function checkSubtype(expected, t) {
    if (t.kind === 'error') {
        return null;
    } else if (expected.kind === 'array') {
        if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {
            return null;
        }
    } else if (expected.kind === t.kind) {
        return null;
    } else if (expected.kind === 'value') {
        for (var i = 0, list = valueMemberTypes; i < list.length; i += 1) {
            var memberType = list[i];
            if (!checkSubtype(memberType, t)) {
                return null;
            }
        }
    }
    return 'Expected ' + toString(expected) + ' but found ' + toString(t) + ' instead.';
}
function isValidType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
        return t.kind === provided.kind;
    });
}
function isValidNativeType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
        if (t === 'null') {
            return provided === null;
        } else if (t === 'array') {
            return Array.isArray(provided);
        } else if (t === 'object') {
            return provided && !Array.isArray(provided) && (typeof provided === "undefined" ? "undefined" : _typeof(provided)) === 'object';
        } else {
            return t === (typeof provided === "undefined" ? "undefined" : _typeof(provided));
        }
    });
}

var csscolorparser = createCommonjsModule(function (module, exports) {
    // (c) Dean McNamee <dean@gmail.com>, 2012.
    //
    // https://github.com/deanm/css-color-parser-js
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to
    // deal in the Software without restriction, including without limitation the
    // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    // sell copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    // IN THE SOFTWARE.

    // http://www.w3.org/TR/css3-color/
    var kCSSColorTable = {
        "transparent": [0, 0, 0, 0], "aliceblue": [240, 248, 255, 1],
        "antiquewhite": [250, 235, 215, 1], "aqua": [0, 255, 255, 1],
        "aquamarine": [127, 255, 212, 1], "azure": [240, 255, 255, 1],
        "beige": [245, 245, 220, 1], "bisque": [255, 228, 196, 1],
        "black": [0, 0, 0, 1], "blanchedalmond": [255, 235, 205, 1],
        "blue": [0, 0, 255, 1], "blueviolet": [138, 43, 226, 1],
        "brown": [165, 42, 42, 1], "burlywood": [222, 184, 135, 1],
        "cadetblue": [95, 158, 160, 1], "chartreuse": [127, 255, 0, 1],
        "chocolate": [210, 105, 30, 1], "coral": [255, 127, 80, 1],
        "cornflowerblue": [100, 149, 237, 1], "cornsilk": [255, 248, 220, 1],
        "crimson": [220, 20, 60, 1], "cyan": [0, 255, 255, 1],
        "darkblue": [0, 0, 139, 1], "darkcyan": [0, 139, 139, 1],
        "darkgoldenrod": [184, 134, 11, 1], "darkgray": [169, 169, 169, 1],
        "darkgreen": [0, 100, 0, 1], "darkgrey": [169, 169, 169, 1],
        "darkkhaki": [189, 183, 107, 1], "darkmagenta": [139, 0, 139, 1],
        "darkolivegreen": [85, 107, 47, 1], "darkorange": [255, 140, 0, 1],
        "darkorchid": [153, 50, 204, 1], "darkred": [139, 0, 0, 1],
        "darksalmon": [233, 150, 122, 1], "darkseagreen": [143, 188, 143, 1],
        "darkslateblue": [72, 61, 139, 1], "darkslategray": [47, 79, 79, 1],
        "darkslategrey": [47, 79, 79, 1], "darkturquoise": [0, 206, 209, 1],
        "darkviolet": [148, 0, 211, 1], "deeppink": [255, 20, 147, 1],
        "deepskyblue": [0, 191, 255, 1], "dimgray": [105, 105, 105, 1],
        "dimgrey": [105, 105, 105, 1], "dodgerblue": [30, 144, 255, 1],
        "firebrick": [178, 34, 34, 1], "floralwhite": [255, 250, 240, 1],
        "forestgreen": [34, 139, 34, 1], "fuchsia": [255, 0, 255, 1],
        "gainsboro": [220, 220, 220, 1], "ghostwhite": [248, 248, 255, 1],
        "gold": [255, 215, 0, 1], "goldenrod": [218, 165, 32, 1],
        "gray": [128, 128, 128, 1], "green": [0, 128, 0, 1],
        "greenyellow": [173, 255, 47, 1], "grey": [128, 128, 128, 1],
        "honeydew": [240, 255, 240, 1], "hotpink": [255, 105, 180, 1],
        "indianred": [205, 92, 92, 1], "indigo": [75, 0, 130, 1],
        "ivory": [255, 255, 240, 1], "khaki": [240, 230, 140, 1],
        "lavender": [230, 230, 250, 1], "lavenderblush": [255, 240, 245, 1],
        "lawngreen": [124, 252, 0, 1], "lemonchiffon": [255, 250, 205, 1],
        "lightblue": [173, 216, 230, 1], "lightcoral": [240, 128, 128, 1],
        "lightcyan": [224, 255, 255, 1], "lightgoldenrodyellow": [250, 250, 210, 1],
        "lightgray": [211, 211, 211, 1], "lightgreen": [144, 238, 144, 1],
        "lightgrey": [211, 211, 211, 1], "lightpink": [255, 182, 193, 1],
        "lightsalmon": [255, 160, 122, 1], "lightseagreen": [32, 178, 170, 1],
        "lightskyblue": [135, 206, 250, 1], "lightslategray": [119, 136, 153, 1],
        "lightslategrey": [119, 136, 153, 1], "lightsteelblue": [176, 196, 222, 1],
        "lightyellow": [255, 255, 224, 1], "lime": [0, 255, 0, 1],
        "limegreen": [50, 205, 50, 1], "linen": [250, 240, 230, 1],
        "magenta": [255, 0, 255, 1], "maroon": [128, 0, 0, 1],
        "mediumaquamarine": [102, 205, 170, 1], "mediumblue": [0, 0, 205, 1],
        "mediumorchid": [186, 85, 211, 1], "mediumpurple": [147, 112, 219, 1],
        "mediumseagreen": [60, 179, 113, 1], "mediumslateblue": [123, 104, 238, 1],
        "mediumspringgreen": [0, 250, 154, 1], "mediumturquoise": [72, 209, 204, 1],
        "mediumvioletred": [199, 21, 133, 1], "midnightblue": [25, 25, 112, 1],
        "mintcream": [245, 255, 250, 1], "mistyrose": [255, 228, 225, 1],
        "moccasin": [255, 228, 181, 1], "navajowhite": [255, 222, 173, 1],
        "navy": [0, 0, 128, 1], "oldlace": [253, 245, 230, 1],
        "olive": [128, 128, 0, 1], "olivedrab": [107, 142, 35, 1],
        "orange": [255, 165, 0, 1], "orangered": [255, 69, 0, 1],
        "orchid": [218, 112, 214, 1], "palegoldenrod": [238, 232, 170, 1],
        "palegreen": [152, 251, 152, 1], "paleturquoise": [175, 238, 238, 1],
        "palevioletred": [219, 112, 147, 1], "papayawhip": [255, 239, 213, 1],
        "peachpuff": [255, 218, 185, 1], "peru": [205, 133, 63, 1],
        "pink": [255, 192, 203, 1], "plum": [221, 160, 221, 1],
        "powderblue": [176, 224, 230, 1], "purple": [128, 0, 128, 1],
        "rebeccapurple": [102, 51, 153, 1],
        "red": [255, 0, 0, 1], "rosybrown": [188, 143, 143, 1],
        "royalblue": [65, 105, 225, 1], "saddlebrown": [139, 69, 19, 1],
        "salmon": [250, 128, 114, 1], "sandybrown": [244, 164, 96, 1],
        "seagreen": [46, 139, 87, 1], "seashell": [255, 245, 238, 1],
        "sienna": [160, 82, 45, 1], "silver": [192, 192, 192, 1],
        "skyblue": [135, 206, 235, 1], "slateblue": [106, 90, 205, 1],
        "slategray": [112, 128, 144, 1], "slategrey": [112, 128, 144, 1],
        "snow": [255, 250, 250, 1], "springgreen": [0, 255, 127, 1],
        "steelblue": [70, 130, 180, 1], "tan": [210, 180, 140, 1],
        "teal": [0, 128, 128, 1], "thistle": [216, 191, 216, 1],
        "tomato": [255, 99, 71, 1], "turquoise": [64, 224, 208, 1],
        "violet": [238, 130, 238, 1], "wheat": [245, 222, 179, 1],
        "white": [255, 255, 255, 1], "whitesmoke": [245, 245, 245, 1],
        "yellow": [255, 255, 0, 1], "yellowgreen": [154, 205, 50, 1] };

    function clamp_css_byte(i) {
        // Clamp to integer 0 .. 255.
        i = Math.round(i); // Seems to be what Chrome does (vs truncation).
        return i < 0 ? 0 : i > 255 ? 255 : i;
    }

    function clamp_css_float(f) {
        // Clamp to float 0.0 .. 1.0.
        return f < 0 ? 0 : f > 1 ? 1 : f;
    }

    function parse_css_int(str) {
        // int or percentage.
        if (str[str.length - 1] === '%') {
            return clamp_css_byte(parseFloat(str) / 100 * 255);
        }
        return clamp_css_byte(parseInt(str));
    }

    function parse_css_float(str) {
        // float or percentage.
        if (str[str.length - 1] === '%') {
            return clamp_css_float(parseFloat(str) / 100);
        }
        return clamp_css_float(parseFloat(str));
    }

    function css_hue_to_rgb(m1, m2, h) {
        if (h < 0) {
            h += 1;
        } else if (h > 1) {
            h -= 1;
        }

        if (h * 6 < 1) {
            return m1 + (m2 - m1) * h * 6;
        }
        if (h * 2 < 1) {
            return m2;
        }
        if (h * 3 < 2) {
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        }
        return m1;
    }

    function parseCSSColor(css_str) {
        // Remove all whitespace, not compliant, but should just be more accepting.
        var str = css_str.replace(/ /g, '').toLowerCase();

        // Color keywords (and transparent) lookup.
        if (str in kCSSColorTable) {
            return kCSSColorTable[str].slice();
        } // dup.

        // #abc and #abc123 syntax.
        if (str[0] === '#') {
            if (str.length === 4) {
                var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xfff)) {
                    return null;
                } // Covers NaN.
                return [(iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1];
            } else if (str.length === 7) {
                var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xffffff)) {
                    return null;
                } // Covers NaN.
                return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];
            }

            return null;
        }

        var op = str.indexOf('('),
            ep = str.indexOf(')');
        if (op !== -1 && ep + 1 === str.length) {
            var fname = str.substr(0, op);
            var params = str.substr(op + 1, ep - (op + 1)).split(',');
            var alpha = 1; // To allow case fallthrough.
            switch (fname) {
                case 'rgba':
                    if (params.length !== 4) {
                        return null;
                    }
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'rgb':
                    if (params.length !== 3) {
                        return null;
                    }
                    return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];
                case 'hsla':
                    if (params.length !== 4) {
                        return null;
                    }
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'hsl':
                    if (params.length !== 3) {
                        return null;
                    }
                    var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1
                    // NOTE(deanm): According to the CSS spec s/l should only be
                    // percentages, but we don't bother and let float or percentage.
                    var s = parse_css_float(params[1]);
                    var l = parse_css_float(params[2]);
                    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                    var m1 = l * 2 - m2;
                    return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];
                default:
                    return null;
            }
        }

        return null;
    }

    try {
        exports.parseCSSColor = parseCSSColor;
    } catch (e) {}
});
var csscolorparser_1 = csscolorparser.parseCSSColor;

var Color = function Color(r, g, b, a) {
    if (a === void 0) a = 1;
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
};
Color.parse = function parse(input) {
    if (!input) {
        return undefined;
    }
    if (input instanceof Color) {
        return input;
    }
    if (typeof input !== 'string') {
        return undefined;
    }
    var rgba = csscolorparser_1(input);
    if (!rgba) {
        return undefined;
    }
    return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
};
Color.prototype.toString = function toString() {
    var ref = this.toArray();
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    return 'rgba(' + Math.round(r) + ',' + Math.round(g) + ',' + Math.round(b) + ',' + a + ')';
};
Color.prototype.toArray = function toArray() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var a = ref.a;
    return a === 0 ? [0, 0, 0, 0] : [r * 255 / a, g * 255 / a, b * 255 / a, a];
};
Color.black = new Color(0, 0, 0, 1);
Color.white = new Color(1, 1, 1, 1);
Color.transparent = new Color(0, 0, 0, 0);
Color.red = new Color(1, 0, 0, 1);

var Collator = function Collator(caseSensitive, diacriticSensitive, locale) {
    if (caseSensitive) {
        this.sensitivity = diacriticSensitive ? 'variant' : 'case';
    } else {
        this.sensitivity = diacriticSensitive ? 'accent' : 'base';
    }
    this.locale = locale;
    this.collator = new Intl.Collator(this.locale ? this.locale : [], {
        sensitivity: this.sensitivity,
        usage: 'search'
    });
};
Collator.prototype.compare = function compare(lhs, rhs) {
    return this.collator.compare(lhs, rhs);
};
Collator.prototype.resolvedLocale = function resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
};

var FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {
    this.text = text;
    this.image = image;
    this.scale = scale;
    this.fontStack = fontStack;
    this.textColor = textColor;
};
var Formatted = function Formatted(sections) {
    this.sections = sections;
};
Formatted.fromString = function fromString(unformatted) {
    return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);
};
Formatted.prototype.isEmpty = function isEmpty() {
    if (this.sections.length === 0) {
        return true;
    }
    return !this.sections.some(function (section) {
        return section.text.length !== 0 || section.image && section.image.name.length !== 0;
    });
};
Formatted.factory = function factory(text) {
    if (text instanceof Formatted) {
        return text;
    } else {
        return Formatted.fromString(text);
    }
};
Formatted.prototype.toString = function toString() {
    if (this.sections.length === 0) {
        return '';
    }
    return this.sections.map(function (section) {
        return section.text;
    }).join('');
};
Formatted.prototype.serialize = function serialize() {
    var serialized = ['format'];
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        if (section.image) {
            serialized.push(['image', section.image.name]);
            continue;
        }
        serialized.push(section.text);
        var options = {};
        if (section.fontStack) {
            options['text-font'] = ['literal', section.fontStack.split(',')];
        }
        if (section.scale) {
            options['font-scale'] = section.scale;
        }
        if (section.textColor) {
            options['text-color'] = ['rgba'].concat(section.textColor.toArray());
        }
        serialized.push(options);
    }
    return serialized;
};

var ResolvedImage = function ResolvedImage(options) {
    this.name = options.name;
    this.available = options.available;
};
ResolvedImage.prototype.toString = function toString() {
    return this.name;
};
ResolvedImage.fromString = function fromString(name) {
    if (!name) {
        return null;
    }
    return new ResolvedImage({
        name: name,
        available: false
    });
};
ResolvedImage.prototype.serialize = function serialize() {
    return ['image', this.name];
};

function validateRGBA(r, g, b, a) {
    if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {
        var value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];
        return 'Invalid rgba value [' + value.join(', ') + ']: \'r\', \'g\', and \'b\' must be between 0 and 255.';
    }
    if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {
        return 'Invalid rgba value [' + [r, g, b, a].join(', ') + ']: \'a\' must be between 0 and 1.';
    }
    return null;
}
function isValue(mixed) {
    if (mixed === null) {
        return true;
    } else if (typeof mixed === 'string') {
        return true;
    } else if (typeof mixed === 'boolean') {
        return true;
    } else if (typeof mixed === 'number') {
        return true;
    } else if (mixed instanceof Color) {
        return true;
    } else if (mixed instanceof Collator) {
        return true;
    } else if (mixed instanceof Formatted) {
        return true;
    } else if (mixed instanceof ResolvedImage) {
        return true;
    } else if (Array.isArray(mixed)) {
        for (var i = 0, list = mixed; i < list.length; i += 1) {
            var item = list[i];
            if (!isValue(item)) {
                return false;
            }
        }
        return true;
    } else if ((typeof mixed === "undefined" ? "undefined" : _typeof(mixed)) === 'object') {
        for (var key in mixed) {
            if (!isValue(mixed[key])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
function typeOf(value) {
    if (value === null) {
        return NullType;
    } else if (typeof value === 'string') {
        return StringType;
    } else if (typeof value === 'boolean') {
        return BooleanType;
    } else if (typeof value === 'number') {
        return NumberType;
    } else if (value instanceof Color) {
        return ColorType;
    } else if (value instanceof Collator) {
        return CollatorType;
    } else if (value instanceof Formatted) {
        return FormattedType;
    } else if (value instanceof ResolvedImage) {
        return ResolvedImageType;
    } else if (Array.isArray(value)) {
        var length = value.length;
        var itemType;
        for (var i = 0, list = value; i < list.length; i += 1) {
            var item = list[i];
            var t = typeOf(item);
            if (!itemType) {
                itemType = t;
            } else if (itemType === t) {
                continue;
            } else {
                itemType = ValueType;
                break;
            }
        }
        return array(itemType || ValueType, length);
    } else {
        return ObjectType;
    }
}
function toString$1(value) {
    var type = typeof value === "undefined" ? "undefined" : _typeof(value);
    if (value === null) {
        return '';
    } else if (type === 'string' || type === 'number' || type === 'boolean') {
        return String(value);
    } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {
        return value.toString();
    } else {
        return JSON.stringify(value);
    }
}

var Literal = function Literal(type, value) {
    this.type = type;
    this.value = value;
};
Literal.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('\'literal\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');
    }
    if (!isValue(args[1])) {
        return context.error('invalid value');
    }
    var value = args[1];
    var type = typeOf(value);
    var expected = context.expectedType;
    if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {
        type = expected;
    }
    return new Literal(type, value);
};
Literal.prototype.evaluate = function evaluate() {
    return this.value;
};
Literal.prototype.eachChild = function eachChild() {};
Literal.prototype.outputDefined = function outputDefined() {
    return true;
};
Literal.prototype.serialize = function serialize() {
    if (this.type.kind === 'array' || this.type.kind === 'object') {
        return ['literal', this.value];
    } else if (this.value instanceof Color) {
        return ['rgba'].concat(this.value.toArray());
    } else if (this.value instanceof Formatted) {
        return this.value.serialize();
    } else {
        return this.value;
    }
};

var RuntimeError = function RuntimeError(message) {
    this.name = 'ExpressionEvaluationError';
    this.message = message;
};
RuntimeError.prototype.toJSON = function toJSON() {
    return this.message;
};

var types = {
    string: StringType,
    number: NumberType,
    boolean: BooleanType,
    object: ObjectType
};
var Assertion = function Assertion(type, args) {
    this.type = type;
    this.args = args;
};
Assertion.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var i = 1;
    var type;
    var name = args[0];
    if (name === 'array') {
        var itemType;
        if (args.length > 2) {
            var type$1 = args[1];
            if (typeof type$1 !== 'string' || !(type$1 in types) || type$1 === 'object') {
                return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
            }
            itemType = types[type$1];
            i++;
        } else {
            itemType = ValueType;
        }
        var N;
        if (args.length > 3) {
            if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
                return context.error('The length argument to "array" must be a positive integer literal', 2);
            }
            N = args[2];
            i++;
        }
        type = array(itemType, N);
    } else {
        type = types[name];
    }
    var parsed = [];
    for (; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) {
            return null;
        }
        parsed.push(input);
    }
    return new Assertion(type, parsed);
};
Assertion.prototype.evaluate = function evaluate(ctx) {
    for (var i = 0; i < this.args.length; i++) {
        var value = this.args[i].evaluate(ctx);
        var error = checkSubtype(this.type, typeOf(value));
        if (!error) {
            return value;
        } else if (i === this.args.length - 1) {
            throw new RuntimeError('Expected value to be of type ' + toString(this.type) + ', but found ' + toString(typeOf(value)) + ' instead.');
        }
    }
    return null;
};
Assertion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Assertion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Assertion.prototype.serialize = function serialize() {
    var type = this.type;
    var serialized = [type.kind];
    if (type.kind === 'array') {
        var itemType = type.itemType;
        if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {
            serialized.push(itemType.kind);
            var N = type.N;
            if (typeof N === 'number' || this.args.length > 1) {
                serialized.push(N);
            }
        }
    }
    return serialized.concat(this.args.map(function (arg) {
        return arg.serialize();
    }));
};

var FormatExpression = function FormatExpression(sections) {
    this.type = FormattedType;
    this.sections = sections;
};
FormatExpression.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var firstArg = args[1];
    if (!Array.isArray(firstArg) && (typeof firstArg === "undefined" ? "undefined" : _typeof(firstArg)) === 'object') {
        return context.error('First argument must be an image or text section.');
    }
    var sections = [];
    var nextTokenMayBeObject = false;
    for (var i = 1; i <= args.length - 1; ++i) {
        var arg = args[i];
        if (nextTokenMayBeObject && (typeof arg === "undefined" ? "undefined" : _typeof(arg)) === 'object' && !Array.isArray(arg)) {
            nextTokenMayBeObject = false;
            var scale = null;
            if (arg['font-scale']) {
                scale = context.parse(arg['font-scale'], 1, NumberType);
                if (!scale) {
                    return null;
                }
            }
            var font = null;
            if (arg['text-font']) {
                font = context.parse(arg['text-font'], 1, array(StringType));
                if (!font) {
                    return null;
                }
            }
            var textColor = null;
            if (arg['text-color']) {
                textColor = context.parse(arg['text-color'], 1, ColorType);
                if (!textColor) {
                    return null;
                }
            }
            var lastExpression = sections[sections.length - 1];
            lastExpression.scale = scale;
            lastExpression.font = font;
            lastExpression.textColor = textColor;
        } else {
            var content = context.parse(args[i], 1, ValueType);
            if (!content) {
                return null;
            }
            var kind = content.type.kind;
            if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage') {
                return context.error('Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.');
            }
            nextTokenMayBeObject = true;
            sections.push({
                content: content,
                scale: null,
                font: null,
                textColor: null
            });
        }
    }
    return new FormatExpression(sections);
};
FormatExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluateSection = function evaluateSection(section) {
        var evaluatedContent = section.content.evaluate(ctx);
        if (typeOf(evaluatedContent) === ResolvedImageType) {
            return new FormattedSection('', evaluatedContent, null, null, null);
        }
        return new FormattedSection(toString$1(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);
    };
    return new Formatted(this.sections.map(evaluateSection));
};
FormatExpression.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        fn(section.content);
        if (section.scale) {
            fn(section.scale);
        }
        if (section.font) {
            fn(section.font);
        }
        if (section.textColor) {
            fn(section.textColor);
        }
    }
};
FormatExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
FormatExpression.prototype.serialize = function serialize() {
    var serialized = ['format'];
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
        var section = list[i];
        serialized.push(section.content.serialize());
        var options = {};
        if (section.scale) {
            options['font-scale'] = section.scale.serialize();
        }
        if (section.font) {
            options['text-font'] = section.font.serialize();
        }
        if (section.textColor) {
            options['text-color'] = section.textColor.serialize();
        }
        serialized.push(options);
    }
    return serialized;
};

var ImageExpression = function ImageExpression(input) {
    this.type = ResolvedImageType;
    this.input = input;
};
ImageExpression.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected two arguments.');
    }
    var name = context.parse(args[1], 1, StringType);
    if (!name) {
        return context.error('No image name provided.');
    }
    return new ImageExpression(name);
};
ImageExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluatedImageName = this.input.evaluate(ctx);
    var value = ResolvedImage.fromString(evaluatedImageName);
    if (value && ctx.availableImages) {
        value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
    }
    return value;
};
ImageExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
};
ImageExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
ImageExpression.prototype.serialize = function serialize() {
    return ['image', this.input.serialize()];
};

var types$1 = {
    'to-boolean': BooleanType,
    'to-color': ColorType,
    'to-number': NumberType,
    'to-string': StringType
};
var Coercion = function Coercion(type, args) {
    this.type = type;
    this.args = args;
};
Coercion.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expected at least one argument.');
    }
    var name = args[0];
    if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2) {
        return context.error('Expected one argument.');
    }
    var type = types$1[name];
    var parsed = [];
    for (var i = 1; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) {
            return null;
        }
        parsed.push(input);
    }
    return new Coercion(type, parsed);
};
Coercion.prototype.evaluate = function evaluate(ctx) {
    if (this.type.kind === 'boolean') {
        return Boolean(this.args[0].evaluate(ctx));
    } else if (this.type.kind === 'color') {
        var input;
        var error;
        for (var i = 0, list = this.args; i < list.length; i += 1) {
            var arg = list[i];
            input = arg.evaluate(ctx);
            error = null;
            if (input instanceof Color) {
                return input;
            } else if (typeof input === 'string') {
                var c = ctx.parseColor(input);
                if (c) {
                    return c;
                }
            } else if (Array.isArray(input)) {
                if (input.length < 3 || input.length > 4) {
                    error = 'Invalid rbga value ' + JSON.stringify(input) + ': expected an array containing either three or four numeric values.';
                } else {
                    error = validateRGBA(input[0], input[1], input[2], input[3]);
                }
                if (!error) {
                    return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
                }
            }
        }
        throw new RuntimeError(error || 'Could not parse color from value \'' + (typeof input === 'string' ? input : String(JSON.stringify(input))) + '\'');
    } else if (this.type.kind === 'number') {
        var value = null;
        for (var i$1 = 0, list$1 = this.args; i$1 < list$1.length; i$1 += 1) {
            var arg$1 = list$1[i$1];
            value = arg$1.evaluate(ctx);
            if (value === null) {
                return 0;
            }
            var num = Number(value);
            if (isNaN(num)) {
                continue;
            }
            return num;
        }
        throw new RuntimeError('Could not convert ' + JSON.stringify(value) + ' to number.');
    } else if (this.type.kind === 'formatted') {
        return Formatted.fromString(toString$1(this.args[0].evaluate(ctx)));
    } else if (this.type.kind === 'resolvedImage') {
        return ResolvedImage.fromString(toString$1(this.args[0].evaluate(ctx)));
    } else {
        return toString$1(this.args[0].evaluate(ctx));
    }
};
Coercion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Coercion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Coercion.prototype.serialize = function serialize() {
    if (this.type.kind === 'formatted') {
        return new FormatExpression([{
            content: this.args[0],
            scale: null,
            font: null,
            textColor: null
        }]).serialize();
    }
    if (this.type.kind === 'resolvedImage') {
        return new ImageExpression(this.args[0]).serialize();
    }
    var serialized = ['to-' + this.type.kind];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];
var EvaluationContext = function EvaluationContext() {
    this.globals = null;
    this.feature = null;
    this.featureState = null;
    this.formattedSection = null;
    this._parseColorCache = {};
    this.availableImages = null;
    this.canonical = null;
};
EvaluationContext.prototype.id = function id() {
    return this.feature && 'id' in this.feature ? this.feature.id : null;
};
EvaluationContext.prototype.geometryType = function geometryType() {
    return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
};
EvaluationContext.prototype.geometry = function geometry() {
    return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
};
EvaluationContext.prototype.canonicalID = function canonicalID() {
    return this.canonical;
};
EvaluationContext.prototype.properties = function properties() {
    return this.feature && this.feature.properties || {};
};
EvaluationContext.prototype.parseColor = function parseColor(input) {
    var cached = this._parseColorCache[input];
    if (!cached) {
        cached = this._parseColorCache[input] = Color.parse(input);
    }
    return cached;
};

var CompoundExpression = function CompoundExpression(name, type, evaluate, args) {
    this.name = name;
    this.type = type;
    this._evaluate = evaluate;
    this.args = args;
};
CompoundExpression.prototype.evaluate = function evaluate(ctx) {
    return this._evaluate(ctx, this.args);
};
CompoundExpression.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
CompoundExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
CompoundExpression.prototype.serialize = function serialize() {
    return [this.name].concat(this.args.map(function (arg) {
        return arg.serialize();
    }));
};
CompoundExpression.parse = function parse(args, context) {
    var ref$1;
    var op = args[0];
    var definition = CompoundExpression.definitions[op];
    if (!definition) {
        return context.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
    }
    var type = Array.isArray(definition) ? definition[0] : definition.type;
    var availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;
    var overloads = availableOverloads.filter(function (ref) {
        var signature = ref[0];
        return !Array.isArray(signature) || signature.length === args.length - 1;
    });
    var signatureContext = null;
    for (var i$3 = 0, list = overloads; i$3 < list.length; i$3 += 1) {
        var ref = list[i$3];
        var params = ref[0];
        var evaluate = ref[1];
        signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);
        var parsedArgs = [];
        var argParseFailed = false;
        for (var i = 1; i < args.length; i++) {
            var arg = args[i];
            var expectedType = Array.isArray(params) ? params[i - 1] : params.type;
            var parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
            if (!parsed) {
                argParseFailed = true;
                break;
            }
            parsedArgs.push(parsed);
        }
        if (argParseFailed) {
            continue;
        }
        if (Array.isArray(params)) {
            if (params.length !== parsedArgs.length) {
                signatureContext.error('Expected ' + params.length + ' arguments, but found ' + parsedArgs.length + ' instead.');
                continue;
            }
        }
        for (var i$1 = 0; i$1 < parsedArgs.length; i$1++) {
            var expected = Array.isArray(params) ? params[i$1] : params.type;
            var arg$1 = parsedArgs[i$1];
            signatureContext.concat(i$1 + 1).checkSubtype(expected, arg$1.type);
        }
        if (signatureContext.errors.length === 0) {
            return new CompoundExpression(op, type, evaluate, parsedArgs);
        }
    }
    if (overloads.length === 1) {
        (ref$1 = context.errors).push.apply(ref$1, signatureContext.errors);
    } else {
        var expected$1 = overloads.length ? overloads : availableOverloads;
        var signatures = expected$1.map(function (ref) {
            var params = ref[0];
            return stringifySignature(params);
        }).join(' | ');
        var actualTypes = [];
        for (var i$2 = 1; i$2 < args.length; i$2++) {
            var parsed$1 = context.parse(args[i$2], 1 + actualTypes.length);
            if (!parsed$1) {
                return null;
            }
            actualTypes.push(toString(parsed$1.type));
        }
        context.error('Expected arguments of type ' + signatures + ', but found (' + actualTypes.join(', ') + ') instead.');
    }
    return null;
};
CompoundExpression.register = function register(registry, definitions) {
    CompoundExpression.definitions = definitions;
    for (var name in definitions) {
        registry[name] = CompoundExpression;
    }
};
function stringifySignature(signature) {
    if (Array.isArray(signature)) {
        return '(' + signature.map(toString).join(', ') + ')';
    } else {
        return '(' + toString(signature.type) + '...)';
    }
}

var CollatorExpression = function CollatorExpression(caseSensitive, diacriticSensitive, locale) {
    this.type = CollatorType;
    this.locale = locale;
    this.caseSensitive = caseSensitive;
    this.diacriticSensitive = diacriticSensitive;
};
CollatorExpression.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected one argument.');
    }
    var options = args[1];
    if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== 'object' || Array.isArray(options)) {
        return context.error('Collator options argument must be an object.');
    }
    var caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);
    if (!caseSensitive) {
        return null;
    }
    var diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);
    if (!diacriticSensitive) {
        return null;
    }
    var locale = null;
    if (options['locale']) {
        locale = context.parse(options['locale'], 1, StringType);
        if (!locale) {
            return null;
        }
    }
    return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
};
CollatorExpression.prototype.evaluate = function evaluate(ctx) {
    return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
};
CollatorExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.caseSensitive);
    fn(this.diacriticSensitive);
    if (this.locale) {
        fn(this.locale);
    }
};
CollatorExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
CollatorExpression.prototype.serialize = function serialize() {
    var options = {};
    options['case-sensitive'] = this.caseSensitive.serialize();
    options['diacritic-sensitive'] = this.diacriticSensitive.serialize();
    if (this.locale) {
        options['locale'] = this.locale.serialize();
    }
    return ['collator', options];
};

var EXTENT = 8192;
function updateBBox(bbox, coord) {
    bbox[0] = Math.min(bbox[0], coord[0]);
    bbox[1] = Math.min(bbox[1], coord[1]);
    bbox[2] = Math.max(bbox[2], coord[0]);
    bbox[3] = Math.max(bbox[3], coord[1]);
}
function mercatorXfromLng(lng) {
    return (180 + lng) / 360;
}
function mercatorYfromLat(lat) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function boxWithinBox(bbox1, bbox2) {
    if (bbox1[0] <= bbox2[0]) {
        return false;
    }
    if (bbox1[2] >= bbox2[2]) {
        return false;
    }
    if (bbox1[1] <= bbox2[1]) {
        return false;
    }
    if (bbox1[3] >= bbox2[3]) {
        return false;
    }
    return true;
}
function getTileCoordinates(p, canonical) {
    var x = mercatorXfromLng(p[0]);
    var y = mercatorYfromLat(p[1]);
    var tilesAtZoom = Math.pow(2, canonical.z);
    return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];
}
function onBoundary(p, p1, p2) {
    var x1 = p[0] - p1[0];
    var y1 = p[1] - p1[1];
    var x2 = p[0] - p2[0];
    var y2 = p[1] - p2[1];
    return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
}
function rayIntersect(p, p1, p2) {
    return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
}
function pointWithinPolygon(point, rings) {
    var inside = false;
    for (var i = 0, len = rings.length; i < len; i++) {
        var ring = rings[i];
        for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {
            if (onBoundary(point, ring[j], ring[j + 1])) {
                return false;
            }
            if (rayIntersect(point, ring[j], ring[j + 1])) {
                inside = !inside;
            }
        }
    }
    return inside;
}
function pointWithinPolygons(point, polygons) {
    for (var i = 0; i < polygons.length; i++) {
        if (pointWithinPolygon(point, polygons[i])) {
            return true;
        }
    }
    return false;
}
function perp(v1, v2) {
    return v1[0] * v2[1] - v1[1] * v2[0];
}
function twoSided(p1, p2, q1, q2) {
    var x1 = p1[0] - q1[0];
    var y1 = p1[1] - q1[1];
    var x2 = p2[0] - q1[0];
    var y2 = p2[1] - q1[1];
    var x3 = q2[0] - q1[0];
    var y3 = q2[1] - q1[1];
    var det1 = x1 * y3 - x3 * y1;
    var det2 = x2 * y3 - x3 * y2;
    if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) {
        return true;
    }
    return false;
}
function lineIntersectLine(a, b, c, d) {
    var vectorP = [b[0] - a[0], b[1] - a[1]];
    var vectorQ = [d[0] - c[0], d[1] - c[1]];
    if (perp(vectorQ, vectorP) === 0) {
        return false;
    }
    if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) {
        return true;
    }
    return false;
}
function lineIntersectPolygon(p1, p2, polygon) {
    for (var i = 0, list = polygon; i < list.length; i += 1) {
        var ring = list[i];
        for (var j = 0; j < ring.length - 1; ++j) {
            if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {
                return true;
            }
        }
    }
    return false;
}
function lineStringWithinPolygon(line, polygon) {
    for (var i = 0; i < line.length; ++i) {
        if (!pointWithinPolygon(line[i], polygon)) {
            return false;
        }
    }
    for (var i$1 = 0; i$1 < line.length - 1; ++i$1) {
        if (lineIntersectPolygon(line[i$1], line[i$1 + 1], polygon)) {
            return false;
        }
    }
    return true;
}
function lineStringWithinPolygons(line, polygons) {
    for (var i = 0; i < polygons.length; i++) {
        if (lineStringWithinPolygon(line, polygons[i])) {
            return true;
        }
    }
    return false;
}
function getTilePolygon(coordinates, bbox, canonical) {
    var polygon = [];
    for (var i = 0; i < coordinates.length; i++) {
        var ring = [];
        for (var j = 0; j < coordinates[i].length; j++) {
            var coord = getTileCoordinates(coordinates[i][j], canonical);
            updateBBox(bbox, coord);
            ring.push(coord);
        }
        polygon.push(ring);
    }
    return polygon;
}
function getTilePolygons(coordinates, bbox, canonical) {
    var polygons = [];
    for (var i = 0; i < coordinates.length; i++) {
        var polygon = getTilePolygon(coordinates[i], bbox, canonical);
        polygons.push(polygon);
    }
    return polygons;
}
function updatePoint(p, bbox, polyBBox, worldSize) {
    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
        var halfWorldSize = worldSize * 0.5;
        var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;
        if (shift === 0) {
            shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
        }
        p[0] += shift;
    }
    updateBBox(bbox, p);
}
function resetBBox(bbox) {
    bbox[0] = bbox[1] = Infinity;
    bbox[2] = bbox[3] = -Infinity;
}
function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
    var tilePoints = [];
    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
        var points = list$1[i$1];
        for (var i = 0, list = points; i < list.length; i += 1) {
            var point = list[i];
            var p = [point.x + shifts[0], point.y + shifts[1]];
            updatePoint(p, pointBBox, polyBBox, worldSize);
            tilePoints.push(p);
        }
    }
    return tilePoints;
}
function getTileLines(geometry, lineBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
    var tileLines = [];
    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
        var line = list$1[i$1];
        var tileLine = [];
        for (var i = 0, list = line; i < list.length; i += 1) {
            var point = list[i];
            var p = [point.x + shifts[0], point.y + shifts[1]];
            updateBBox(lineBBox, p);
            tileLine.push(p);
        }
        tileLines.push(tileLine);
    }
    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
        resetBBox(lineBBox);
        for (var i$3 = 0, list$3 = tileLines; i$3 < list$3.length; i$3 += 1) {
            var line$1 = list$3[i$3];
            for (var i$2 = 0, list$2 = line$1; i$2 < list$2.length; i$2 += 1) {
                var p$1 = list$2[i$2];
                updatePoint(p$1, lineBBox, polyBBox, worldSize);
            }
        }
    }
    return tileLines;
}
function pointsWithinPolygons(ctx, polygonGeometry) {
    var pointBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var canonical = ctx.canonicalID();
    if (polygonGeometry.type === 'Polygon') {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) {
            return false;
        }
        for (var i = 0, list = tilePoints; i < list.length; i += 1) {
            var point = list[i];
            if (!pointWithinPolygon(point, tilePolygon)) {
                return false;
            }
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints$1 = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) {
            return false;
        }
        for (var i$1 = 0, list$1 = tilePoints$1; i$1 < list$1.length; i$1 += 1) {
            var point$1 = list$1[i$1];
            if (!pointWithinPolygons(point$1, tilePolygons)) {
                return false;
            }
        }
    }
    return true;
}
function linesWithinPolygons(ctx, polygonGeometry) {
    var lineBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var canonical = ctx.canonicalID();
    if (polygonGeometry.type === 'Polygon') {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) {
            return false;
        }
        for (var i = 0, list = tileLines; i < list.length; i += 1) {
            var line = list[i];
            if (!lineStringWithinPolygon(line, tilePolygon)) {
                return false;
            }
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines$1 = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) {
            return false;
        }
        for (var i$1 = 0, list$1 = tileLines$1; i$1 < list$1.length; i$1 += 1) {
            var line$1 = list$1[i$1];
            if (!lineStringWithinPolygons(line$1, tilePolygons)) {
                return false;
            }
        }
    }
    return true;
}
var Within = function Within(geojson, geometries) {
    this.type = BooleanType;
    this.geojson = geojson;
    this.geometries = geometries;
};
Within.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('\'within\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');
    }
    if (isValue(args[1])) {
        var geojson = args[1];
        if (geojson.type === 'FeatureCollection') {
            for (var i = 0; i < geojson.features.length; ++i) {
                var type = geojson.features[i].geometry.type;
                if (type === 'Polygon' || type === 'MultiPolygon') {
                    return new Within(geojson, geojson.features[i].geometry);
                }
            }
        } else if (geojson.type === 'Feature') {
            var type$1 = geojson.geometry.type;
            if (type$1 === 'Polygon' || type$1 === 'MultiPolygon') {
                return new Within(geojson, geojson.geometry);
            }
        } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {
            return new Within(geojson, geojson);
        }
    }
    return context.error('\'within\' expression requires valid geojson object that contains polygon geometry type.');
};
Within.prototype.evaluate = function evaluate(ctx) {
    if (ctx.geometry() != null && ctx.canonicalID() != null) {
        if (ctx.geometryType() === 'Point') {
            return pointsWithinPolygons(ctx, this.geometries);
        } else if (ctx.geometryType() === 'LineString') {
            return linesWithinPolygons(ctx, this.geometries);
        }
    }
    return false;
};
Within.prototype.eachChild = function eachChild() {};
Within.prototype.outputDefined = function outputDefined() {
    return true;
};
Within.prototype.serialize = function serialize() {
    return ['within', this.geojson];
};

function isFeatureConstant(e) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'get' && e.args.length === 1) {
            return false;
        } else if (e.name === 'feature-state') {
            return false;
        } else if (e.name === 'has' && e.args.length === 1) {
            return false;
        } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {
            return false;
        } else if (/^filter-/.test(e.name)) {
            return false;
        }
    }
    if (e instanceof Within) {
        return false;
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isFeatureConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isStateConstant(e) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'feature-state') {
            return false;
        }
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isStateConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isGlobalPropertyConstant(e, properties) {
    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {
        return false;
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isGlobalPropertyConstant(arg, properties)) {
            result = false;
        }
    });
    return result;
}

var Var = function Var(name, boundExpression) {
    this.type = boundExpression.type;
    this.name = name;
    this.boundExpression = boundExpression;
};
Var.parse = function parse(args, context) {
    if (args.length !== 2 || typeof args[1] !== 'string') {
        return context.error('\'var\' expression requires exactly one string literal argument.');
    }
    var name = args[1];
    if (!context.scope.has(name)) {
        return context.error('Unknown variable "' + name + '". Make sure "' + name + '" has been bound in an enclosing "let" expression before using it.', 1);
    }
    return new Var(name, context.scope.get(name));
};
Var.prototype.evaluate = function evaluate(ctx) {
    return this.boundExpression.evaluate(ctx);
};
Var.prototype.eachChild = function eachChild() {};
Var.prototype.outputDefined = function outputDefined() {
    return false;
};
Var.prototype.serialize = function serialize() {
    return ['var', this.name];
};

var ParsingContext = function ParsingContext(registry, path, expectedType, scope, errors) {
    if (path === void 0) path = [];
    if (scope === void 0) scope = new Scope();
    if (errors === void 0) errors = [];
    this.registry = registry;
    this.path = path;
    this.key = path.map(function (part) {
        return '[' + part + ']';
    }).join('');
    this.scope = scope;
    this.errors = errors;
    this.expectedType = expectedType;
};
ParsingContext.prototype.parse = function parse(expr, index, expectedType, bindings, options) {
    if (options === void 0) options = {};
    if (index) {
        return this.concat(index, expectedType, bindings)._parse(expr, options);
    }
    return this._parse(expr, options);
};
ParsingContext.prototype._parse = function _parse(expr, options) {
    if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
        expr = ['literal', expr];
    }
    function annotate(parsed, type, typeAnnotation) {
        if (typeAnnotation === 'assert') {
            return new Assertion(type, [parsed]);
        } else if (typeAnnotation === 'coerce') {
            return new Coercion(type, [parsed]);
        } else {
            return parsed;
        }
    }
    if (Array.isArray(expr)) {
        if (expr.length === 0) {
            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
        }
        var op = expr[0];
        if (typeof op !== 'string') {
            this.error('Expression name must be a string, but found ' + (typeof op === "undefined" ? "undefined" : _typeof(op)) + ' instead. If you wanted a literal array, use ["literal", [...]].', 0);
            return null;
        }
        var Expr = this.registry[op];
        if (Expr) {
            var parsed = Expr.parse(expr, this);
            if (!parsed) {
                return null;
            }
            if (this.expectedType) {
                var expected = this.expectedType;
                var actual = parsed.type;
                if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {
                    parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');
                } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {
                    parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');
                } else if (this.checkSubtype(expected, actual)) {
                    return null;
                }
            }
            if (!(parsed instanceof Literal) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {
                var ec = new EvaluationContext();
                try {
                    parsed = new Literal(parsed.type, parsed.evaluate(ec));
                } catch (e) {
                    this.error(e.message);
                    return null;
                }
            }
            return parsed;
        }
        return this.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
    } else if (typeof expr === 'undefined') {
        return this.error('\'undefined\' value invalid. Use null instead.');
    } else if ((typeof expr === "undefined" ? "undefined" : _typeof(expr)) === 'object') {
        return this.error('Bare objects invalid. Use ["literal", {...}] instead.');
    } else {
        return this.error('Expected an array, but found ' + (typeof expr === "undefined" ? "undefined" : _typeof(expr)) + ' instead.');
    }
};
ParsingContext.prototype.concat = function concat(index, expectedType, bindings) {
    var path = typeof index === 'number' ? this.path.concat(index) : this.path;
    var scope = bindings ? this.scope.concat(bindings) : this.scope;
    return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
};
ParsingContext.prototype.error = function error(error$1) {
    var keys = [],
        len = arguments.length - 1;
    while (len-- > 0) {
        keys[len] = arguments[len + 1];
    }var key = '' + this.key + keys.map(function (k) {
        return '[' + k + ']';
    }).join('');
    this.errors.push(new ParsingError(key, error$1));
};
ParsingContext.prototype.checkSubtype = function checkSubtype$1(expected, t) {
    var error = checkSubtype(expected, t);
    if (error) {
        this.error(error);
    }
    return error;
};
function isConstant(expression) {
    if (expression instanceof Var) {
        return isConstant(expression.boundExpression);
    } else if (expression instanceof CompoundExpression && expression.name === 'error') {
        return false;
    } else if (expression instanceof CollatorExpression) {
        return false;
    } else if (expression instanceof Within) {
        return false;
    }
    var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;
    var childrenConstant = true;
    expression.eachChild(function (child) {
        if (isTypeAnnotation) {
            childrenConstant = childrenConstant && isConstant(child);
        } else {
            childrenConstant = childrenConstant && child instanceof Literal;
        }
    });
    if (!childrenConstant) {
        return false;
    }
    return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, ['zoom', 'heatmap-density', 'line-progress', 'accumulated', 'is-supported-script']);
}

function findStopLessThanOrEqualTo(stops, input) {
    var lastIndex = stops.length - 1;
    var lowerIndex = 0;
    var upperIndex = lastIndex;
    var currentIndex = 0;
    var currentValue, nextValue;
    while (lowerIndex <= upperIndex) {
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex];
        nextValue = stops[currentIndex + 1];
        if (currentValue <= input) {
            if (currentIndex === lastIndex || input < nextValue) {
                return currentIndex;
            }
            lowerIndex = currentIndex + 1;
        } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
        } else {
            throw new RuntimeError('Input is not a number.');
        }
    }
    return 0;
}

var Step = function Step(type, input, stops) {
    this.type = type;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];
        this.labels.push(label);
        this.outputs.push(expression);
    }
};
Step.parse = function parse(args, context) {
    if (args.length - 1 < 4) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if ((args.length - 1) % 2 !== 0) {
        return context.error('Expected an even number of arguments.');
    }
    var input = context.parse(args[1], 1, NumberType);
    if (!input) {
        return null;
    }
    var stops = [];
    var outputType = null;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    for (var i = 1; i < args.length; i += 2) {
        var label = i === 1 ? -Infinity : args[i];
        var value = args[i + 1];
        var labelKey = i;
        var valueKey = i + 1;
        if (typeof label !== 'number') {
            return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }
        if (stops.length && stops[stops.length - 1][0] >= label) {
            return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }
        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        stops.push([label, parsed]);
    }
    return new Step(outputType, input, stops);
};
Step.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;
    if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
    }
    var value = this.input.evaluate(ctx);
    if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
    }
    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
    }
    var index = findStopLessThanOrEqualTo(labels, value);
    return outputs[index].evaluate(ctx);
};
Step.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
        var expression = list[i];
        fn(expression);
    }
};
Step.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    });
};
Step.prototype.serialize = function serialize() {
    var serialized = ['step', this.input.serialize()];
    for (var i = 0; i < this.labels.length; i++) {
        if (i > 0) {
            serialized.push(this.labels[i]);
        }
        serialized.push(this.outputs[i].serialize());
    }
    return serialized;
};

/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

var unitbezier = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function (t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function (t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function (t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function (x, epsilon) {
    if (typeof epsilon === 'undefined') {
        epsilon = 1e-6;
    }

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) {
            return t2;
        }

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) {
            break;
        }

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) {
        return t0;
    }
    if (t2 > t1) {
        return t1;
    }

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) {
            return t2;
        }

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function (x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

function number(a, b, t) {
    return a * (1 - t) + b * t;
}
function color(from, to, t) {
    return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
}
function array$1(from, to, t) {
    return from.map(function (d, i) {
        return number(d, to[i], t);
    });
}

var interpolate = /*#__PURE__*/Object.freeze({
    __proto__: null,
    number: number,
    color: color,
    array: array$1
});

var Xn = 0.95047,
    Yn = 1,
    Zn = 1.08883,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1,
    deg2rad = Math.PI / 180,
    rad2deg = 180 / Math.PI;
function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
}
function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2xyz(x) {
    x /= 255;
    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function rgbToLab(rgbColor) {
    var b = rgb2xyz(rgbColor.r),
        a = rgb2xyz(rgbColor.g),
        l = rgb2xyz(rgbColor.b),
        x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
        y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn),
        z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
    return {
        l: 116 * y - 16,
        a: 500 * (x - y),
        b: 200 * (y - z),
        alpha: rgbColor.a
    };
}
function labToRgb(labColor) {
    var y = (labColor.l + 16) / 116,
        x = isNaN(labColor.a) ? y : y + labColor.a / 500,
        z = isNaN(labColor.b) ? y : y - labColor.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
}
function interpolateLab(from, to, t) {
    return {
        l: number(from.l, to.l, t),
        a: number(from.a, to.a, t),
        b: number(from.b, to.b, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
function rgbToHcl(rgbColor) {
    var ref = rgbToLab(rgbColor);
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var h = Math.atan2(b, a) * rad2deg;
    return {
        h: h < 0 ? h + 360 : h,
        c: Math.sqrt(a * a + b * b),
        l: l,
        alpha: rgbColor.a
    };
}
function hclToRgb(hclColor) {
    var h = hclColor.h * deg2rad,
        c = hclColor.c,
        l = hclColor.l;
    return labToRgb({
        l: l,
        a: Math.cos(h) * c,
        b: Math.sin(h) * c,
        alpha: hclColor.alpha
    });
}
function interpolateHue(a, b, t) {
    var d = b - a;
    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
}
function interpolateHcl(from, to, t) {
    return {
        h: interpolateHue(from.h, to.h, t),
        c: number(from.c, to.c, t),
        l: number(from.l, to.l, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
var lab = {
    forward: rgbToLab,
    reverse: labToRgb,
    interpolate: interpolateLab
};
var hcl = {
    forward: rgbToHcl,
    reverse: hclToRgb,
    interpolate: interpolateHcl
};

var colorSpaces = /*#__PURE__*/Object.freeze({
    __proto__: null,
    lab: lab,
    hcl: hcl
});

var Interpolate = function Interpolate(type, operator, interpolation, input, stops) {
    this.type = type;
    this.operator = operator;
    this.interpolation = interpolation;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];
        this.labels.push(label);
        this.outputs.push(expression);
    }
};
Interpolate.interpolationFactor = function interpolationFactor(interpolation, input, lower, upper) {
    var t = 0;
    if (interpolation.name === 'exponential') {
        t = exponentialInterpolation(input, interpolation.base, lower, upper);
    } else if (interpolation.name === 'linear') {
        t = exponentialInterpolation(input, 1, lower, upper);
    } else if (interpolation.name === 'cubic-bezier') {
        var c = interpolation.controlPoints;
        var ub = new unitbezier(c[0], c[1], c[2], c[3]);
        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
    }
    return t;
};
Interpolate.parse = function parse(args, context) {
    var operator = args[0];
    var interpolation = args[1];
    var input = args[2];
    var rest = args.slice(3);
    if (!Array.isArray(interpolation) || interpolation.length === 0) {
        return context.error('Expected an interpolation type expression.', 1);
    }
    if (interpolation[0] === 'linear') {
        interpolation = { name: 'linear' };
    } else if (interpolation[0] === 'exponential') {
        var base = interpolation[1];
        if (typeof base !== 'number') {
            return context.error('Exponential interpolation requires a numeric base.', 1, 1);
        }
        interpolation = {
            name: 'exponential',
            base: base
        };
    } else if (interpolation[0] === 'cubic-bezier') {
        var controlPoints = interpolation.slice(1);
        if (controlPoints.length !== 4 || controlPoints.some(function (t) {
            return typeof t !== 'number' || t < 0 || t > 1;
        })) {
            return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
        }
        interpolation = {
            name: 'cubic-bezier',
            controlPoints: controlPoints
        };
    } else {
        return context.error('Unknown interpolation type ' + String(interpolation[0]), 1, 0);
    }
    if (args.length - 1 < 4) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if ((args.length - 1) % 2 !== 0) {
        return context.error('Expected an even number of arguments.');
    }
    input = context.parse(input, 2, NumberType);
    if (!input) {
        return null;
    }
    var stops = [];
    var outputType = null;
    if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {
        outputType = ColorType;
    } else if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    for (var i = 0; i < rest.length; i += 2) {
        var label = rest[i];
        var value = rest[i + 1];
        var labelKey = i + 3;
        var valueKey = i + 4;
        if (typeof label !== 'number') {
            return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }
        if (stops.length && stops[stops.length - 1][0] >= label) {
            return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }
        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        stops.push([label, parsed]);
    }
    if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
        return context.error('Type ' + toString(outputType) + ' is not interpolatable.');
    }
    return new Interpolate(outputType, operator, interpolation, input, stops);
};
Interpolate.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;
    if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
    }
    var value = this.input.evaluate(ctx);
    if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
    }
    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
    }
    var index = findStopLessThanOrEqualTo(labels, value);
    var lower = labels[index];
    var upper = labels[index + 1];
    var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
    var outputLower = outputs[index].evaluate(ctx);
    var outputUpper = outputs[index + 1].evaluate(ctx);
    if (this.operator === 'interpolate') {
        return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);
    } else if (this.operator === 'interpolate-hcl') {
        return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
    } else {
        return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
    }
};
Interpolate.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
        var expression = list[i];
        fn(expression);
    }
};
Interpolate.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    });
};
Interpolate.prototype.serialize = function serialize() {
    var interpolation;
    if (this.interpolation.name === 'linear') {
        interpolation = ['linear'];
    } else if (this.interpolation.name === 'exponential') {
        if (this.interpolation.base === 1) {
            interpolation = ['linear'];
        } else {
            interpolation = ['exponential', this.interpolation.base];
        }
    } else {
        interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);
    }
    var serialized = [this.operator, interpolation, this.input.serialize()];
    for (var i = 0; i < this.labels.length; i++) {
        serialized.push(this.labels[i], this.outputs[i].serialize());
    }
    return serialized;
};
function exponentialInterpolation(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

var Coalesce = function Coalesce(type, args) {
    this.type = type;
    this.args = args;
};
Coalesce.parse = function parse(args, context) {
    if (args.length < 2) {
        return context.error('Expectected at least one argument.');
    }
    var outputType = null;
    var expectedType = context.expectedType;
    if (expectedType && expectedType.kind !== 'value') {
        outputType = expectedType;
    }
    var parsedArgs = [];
    for (var i = 0, list = args.slice(1); i < list.length; i += 1) {
        var arg = list[i];
        var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, { typeAnnotation: 'omit' });
        if (!parsed) {
            return null;
        }
        outputType = outputType || parsed.type;
        parsedArgs.push(parsed);
    }
    var needsAnnotation = expectedType && parsedArgs.some(function (arg) {
        return checkSubtype(expectedType, arg.type);
    });
    return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
};
Coalesce.prototype.evaluate = function evaluate(ctx) {
    var result = null;
    var argCount = 0;
    var requestedImageName;
    for (var i = 0, list = this.args; i < list.length; i += 1) {
        var arg = list[i];
        argCount++;
        result = arg.evaluate(ctx);
        if (result && result instanceof ResolvedImage && !result.available) {
            if (!requestedImageName) {
                requestedImageName = result.name;
            }
            result = null;
            if (argCount === this.args.length) {
                result = requestedImageName;
            }
        }
        if (result !== null) {
            break;
        }
    }
    return result;
};
Coalesce.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Coalesce.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
        return arg.outputDefined();
    });
};
Coalesce.prototype.serialize = function serialize() {
    var serialized = ['coalesce'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var Let = function Let(bindings, result) {
    this.type = result.type;
    this.bindings = [].concat(bindings);
    this.result = result;
};
Let.prototype.evaluate = function evaluate(ctx) {
    return this.result.evaluate(ctx);
};
Let.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
        var binding = list[i];
        fn(binding[1]);
    }
    fn(this.result);
};
Let.parse = function parse(args, context) {
    if (args.length < 4) {
        return context.error('Expected at least 3 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var bindings = [];
    for (var i = 1; i < args.length - 1; i += 2) {
        var name = args[i];
        if (typeof name !== 'string') {
            return context.error('Expected string, but found ' + (typeof name === "undefined" ? "undefined" : _typeof(name)) + ' instead.', i);
        }
        if (/[^a-zA-Z0-9_]/.test(name)) {
            return context.error('Variable names must contain only alphanumeric characters or \'_\'.', i);
        }
        var value = context.parse(args[i + 1], i + 1);
        if (!value) {
            return null;
        }
        bindings.push([name, value]);
    }
    var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
    if (!result) {
        return null;
    }
    return new Let(bindings, result);
};
Let.prototype.outputDefined = function outputDefined() {
    return this.result.outputDefined();
};
Let.prototype.serialize = function serialize() {
    var serialized = ['let'];
    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
        var ref = list[i];
        var name = ref[0];
        var expr = ref[1];
        serialized.push(name, expr.serialize());
    }
    serialized.push(this.result.serialize());
    return serialized;
};

var At = function At(type, index, input) {
    this.type = type;
    this.index = index;
    this.input = input;
};
At.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var index = context.parse(args[1], 1, NumberType);
    var input = context.parse(args[2], 2, array(context.expectedType || ValueType));
    if (!index || !input) {
        return null;
    }
    var t = input.type;
    return new At(t.itemType, index, input);
};
At.prototype.evaluate = function evaluate(ctx) {
    var index = this.index.evaluate(ctx);
    var array = this.input.evaluate(ctx);
    if (index < 0) {
        throw new RuntimeError('Array index out of bounds: ' + index + ' < 0.');
    }
    if (index >= array.length) {
        throw new RuntimeError('Array index out of bounds: ' + index + ' > ' + (array.length - 1) + '.');
    }
    if (index !== Math.floor(index)) {
        throw new RuntimeError('Array index must be an integer, but found ' + index + ' instead.');
    }
    return array[index];
};
At.prototype.eachChild = function eachChild(fn) {
    fn(this.index);
    fn(this.input);
};
At.prototype.outputDefined = function outputDefined() {
    return false;
};
At.prototype.serialize = function serialize() {
    return ['at', this.index.serialize(), this.input.serialize()];
};

var In = function In(needle, haystack) {
    this.type = BooleanType;
    this.needle = needle;
    this.haystack = haystack;
};
In.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack) {
        return null;
    }
    if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');
    }
    return new In(needle, haystack);
};
In.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);
    if (!haystack) {
        return false;
    }
    if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
        throw new RuntimeError('Expected first argument to be of type boolean, string, number or null, but found ' + toString(typeOf(needle)) + ' instead.');
    }
    if (!isValidNativeType(haystack, ['string', 'array'])) {
        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');
    }
    return haystack.indexOf(needle) >= 0;
};
In.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
};
In.prototype.outputDefined = function outputDefined() {
    return true;
};
In.prototype.serialize = function serialize() {
    return ['in', this.needle.serialize(), this.haystack.serialize()];
};

var IndexOf = function IndexOf(needle, haystack, fromIndex) {
    this.type = NumberType;
    this.needle = needle;
    this.haystack = haystack;
    this.fromIndex = fromIndex;
};
IndexOf.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
        return context.error('Expected 3 or 4 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack) {
        return null;
    }
    if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');
    }
    if (args.length === 4) {
        var fromIndex = context.parse(args[3], 3, NumberType);
        if (!fromIndex) {
            return null;
        }
        return new IndexOf(needle, haystack, fromIndex);
    } else {
        return new IndexOf(needle, haystack);
    }
};
IndexOf.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);
    if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
        throw new RuntimeError('Expected first argument to be of type boolean, string, number or null, but found ' + toString(typeOf(needle)) + ' instead.');
    }
    if (!isValidNativeType(haystack, ['string', 'array'])) {
        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');
    }
    if (this.fromIndex) {
        var fromIndex = this.fromIndex.evaluate(ctx);
        return haystack.indexOf(needle, fromIndex);
    }
    return haystack.indexOf(needle);
};
IndexOf.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
    if (this.fromIndex) {
        fn(this.fromIndex);
    }
};
IndexOf.prototype.outputDefined = function outputDefined() {
    return false;
};
IndexOf.prototype.serialize = function serialize() {
    if (this.fromIndex != null && this.fromIndex !== undefined) {
        var fromIndex = this.fromIndex.serialize();
        return ['index-of', this.needle.serialize(), this.haystack.serialize(), fromIndex];
    }
    return ['index-of', this.needle.serialize(), this.haystack.serialize()];
};

var Match = function Match(inputType, outputType, input, cases, outputs, otherwise) {
    this.inputType = inputType;
    this.type = outputType;
    this.input = input;
    this.cases = cases;
    this.outputs = outputs;
    this.otherwise = otherwise;
};
Match.parse = function parse(args, context) {
    if (args.length < 5) {
        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');
    }
    if (args.length % 2 !== 1) {
        return context.error('Expected an even number of arguments.');
    }
    var inputType;
    var outputType;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    var cases = {};
    var outputs = [];
    for (var i = 2; i < args.length - 1; i += 2) {
        var labels = args[i];
        var value = args[i + 1];
        if (!Array.isArray(labels)) {
            labels = [labels];
        }
        var labelContext = context.concat(i);
        if (labels.length === 0) {
            return labelContext.error('Expected at least one branch label.');
        }
        for (var i$1 = 0, list = labels; i$1 < list.length; i$1 += 1) {
            var label = list[i$1];
            if (typeof label !== 'number' && typeof label !== 'string') {
                return labelContext.error('Branch labels must be numbers or strings.');
            } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
                return labelContext.error('Branch labels must be integers no larger than ' + Number.MAX_SAFE_INTEGER + '.');
            } else if (typeof label === 'number' && Math.floor(label) !== label) {
                return labelContext.error('Numeric branch labels must be integer values.');
            } else if (!inputType) {
                inputType = typeOf(label);
            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
                return null;
            }
            if (typeof cases[String(label)] !== 'undefined') {
                return labelContext.error('Branch labels must be unique.');
            }
            cases[String(label)] = outputs.length;
        }
        var result = context.parse(value, i, outputType);
        if (!result) {
            return null;
        }
        outputType = outputType || result.type;
        outputs.push(result);
    }
    var input = context.parse(args[1], 1, ValueType);
    if (!input) {
        return null;
    }
    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) {
        return null;
    }
    if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {
        return null;
    }
    return new Match(inputType, outputType, input, cases, outputs, otherwise);
};
Match.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
    return output.evaluate(ctx);
};
Match.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    this.outputs.forEach(fn);
    fn(this.otherwise);
};
Match.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
        return out.outputDefined();
    }) && this.otherwise.outputDefined();
};
Match.prototype.serialize = function serialize() {
    var this$1 = this;
    var serialized = ['match', this.input.serialize()];
    var sortedLabels = Object.keys(this.cases).sort();
    var groupedByOutput = [];
    var outputLookup = {};
    for (var i = 0, list = sortedLabels; i < list.length; i += 1) {
        var label = list[i];
        var outputIndex = outputLookup[this.cases[label]];
        if (outputIndex === undefined) {
            outputLookup[this.cases[label]] = groupedByOutput.length;
            groupedByOutput.push([this.cases[label], [label]]);
        } else {
            groupedByOutput[outputIndex][1].push(label);
        }
    }
    var coerceLabel = function coerceLabel(label) {
        return this$1.inputType.kind === 'number' ? Number(label) : label;
    };
    for (var i$1 = 0, list$1 = groupedByOutput; i$1 < list$1.length; i$1 += 1) {
        var ref = list$1[i$1];
        var outputIndex = ref[0];
        var labels = ref[1];
        if (labels.length === 1) {
            serialized.push(coerceLabel(labels[0]));
        } else {
            serialized.push(labels.map(coerceLabel));
        }
        serialized.push(this.outputs[outputIndex$1].serialize());
    }
    serialized.push(this.otherwise.serialize());
    return serialized;
};

var Case = function Case(type, branches, otherwise) {
    this.type = type;
    this.branches = branches;
    this.otherwise = otherwise;
};
Case.parse = function parse(args, context) {
    if (args.length < 4) {
        return context.error('Expected at least 3 arguments, but found only ' + (args.length - 1) + '.');
    }
    if (args.length % 2 !== 0) {
        return context.error('Expected an odd number of arguments.');
    }
    var outputType;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    var branches = [];
    for (var i = 1; i < args.length - 1; i += 2) {
        var test = context.parse(args[i], i, BooleanType);
        if (!test) {
            return null;
        }
        var result = context.parse(args[i + 1], i + 1, outputType);
        if (!result) {
            return null;
        }
        branches.push([test, result]);
        outputType = outputType || result.type;
    }
    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) {
        return null;
    }
    return new Case(outputType, branches, otherwise);
};
Case.prototype.evaluate = function evaluate(ctx) {
    for (var i = 0, list = this.branches; i < list.length; i += 1) {
        var ref = list[i];
        var test = ref[0];
        var expression = ref[1];
        if (test.evaluate(ctx)) {
            return expression.evaluate(ctx);
        }
    }
    return this.otherwise.evaluate(ctx);
};
Case.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.branches; i < list.length; i += 1) {
        var ref = list[i];
        var test = ref[0];
        var expression = ref[1];
        fn(test);
        fn(expression);
    }
    fn(this.otherwise);
};
Case.prototype.outputDefined = function outputDefined() {
    return this.branches.every(function (ref) {
        var _ = ref[0];
        var out = ref[1];
        return out.outputDefined();
    }) && this.otherwise.outputDefined();
};
Case.prototype.serialize = function serialize() {
    var serialized = ['case'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var Slice = function Slice(type, input, beginIndex, endIndex) {
    this.type = type;
    this.input = input;
    this.beginIndex = beginIndex;
    this.endIndex = endIndex;
};
Slice.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
        return context.error('Expected 3 or 4 arguments, but found ' + (args.length - 1) + ' instead.');
    }
    var input = context.parse(args[1], 1, ValueType);
    var beginIndex = context.parse(args[2], 2, NumberType);
    if (!input || !beginIndex) {
        return null;
    }
    if (!isValidType(input.type, [array(ValueType), StringType, ValueType])) {
        return context.error('Expected first argument to be of type array or string, but found ' + toString(input.type) + ' instead');
    }
    if (args.length === 4) {
        var endIndex = context.parse(args[3], 3, NumberType);
        if (!endIndex) {
            return null;
        }
        return new Slice(input.type, input, beginIndex, endIndex);
    } else {
        return new Slice(input.type, input, beginIndex);
    }
};
Slice.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var beginIndex = this.beginIndex.evaluate(ctx);
    if (!isValidNativeType(input, ['string', 'array'])) {
        throw new RuntimeError('Expected first argument to be of type array or string, but found ' + toString(typeOf(input)) + ' instead.');
    }
    if (this.endIndex) {
        var endIndex = this.endIndex.evaluate(ctx);
        return input.slice(beginIndex, endIndex);
    }
    return input.slice(beginIndex);
};
Slice.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    fn(this.beginIndex);
    if (this.endIndex) {
        fn(this.endIndex);
    }
};
Slice.prototype.outputDefined = function outputDefined() {
    return false;
};
Slice.prototype.serialize = function serialize() {
    if (this.endIndex != null && this.endIndex !== undefined) {
        var endIndex = this.endIndex.serialize();
        return ['slice', this.input.serialize(), this.beginIndex.serialize(), endIndex];
    }
    return ['slice', this.input.serialize(), this.beginIndex.serialize()];
};

function isComparableType(op, type) {
    if (op === '==' || op === '!=') {
        return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';
    } else {
        return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';
    }
}
function eq(ctx, a, b) {
    return a === b;
}
function neq(ctx, a, b) {
    return a !== b;
}
function lt(ctx, a, b) {
    return a < b;
}
function gt(ctx, a, b) {
    return a > b;
}
function lteq(ctx, a, b) {
    return a <= b;
}
function gteq(ctx, a, b) {
    return a >= b;
}
function eqCollate(ctx, a, b, c) {
    return c.compare(a, b) === 0;
}
function neqCollate(ctx, a, b, c) {
    return !eqCollate(ctx, a, b, c);
}
function ltCollate(ctx, a, b, c) {
    return c.compare(a, b) < 0;
}
function gtCollate(ctx, a, b, c) {
    return c.compare(a, b) > 0;
}
function lteqCollate(ctx, a, b, c) {
    return c.compare(a, b) <= 0;
}
function gteqCollate(ctx, a, b, c) {
    return c.compare(a, b) >= 0;
}
function makeComparison(op, compareBasic, compareWithCollator) {
    var isOrderComparison = op !== '==' && op !== '!=';
    return function () {
        function Comparison(lhs, rhs, collator) {
            this.type = BooleanType;
            this.lhs = lhs;
            this.rhs = rhs;
            this.collator = collator;
            this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';
        }
        Comparison.parse = function parse(args, context) {
            if (args.length !== 3 && args.length !== 4) {
                return context.error('Expected two or three arguments.');
            }
            var op = args[0];
            var lhs = context.parse(args[1], 1, ValueType);
            if (!lhs) {
                return null;
            }
            if (!isComparableType(op, lhs.type)) {
                return context.concat(1).error('"' + op + '" comparisons are not supported for type \'' + toString(lhs.type) + '\'.');
            }
            var rhs = context.parse(args[2], 2, ValueType);
            if (!rhs) {
                return null;
            }
            if (!isComparableType(op, rhs.type)) {
                return context.concat(2).error('"' + op + '" comparisons are not supported for type \'' + toString(rhs.type) + '\'.');
            }
            if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                return context.error('Cannot compare types \'' + toString(lhs.type) + '\' and \'' + toString(rhs.type) + '\'.');
            }
            if (isOrderComparison) {
                if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {
                    lhs = new Assertion(rhs.type, [lhs]);
                } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {
                    rhs = new Assertion(lhs.type, [rhs]);
                }
            }
            var collator = null;
            if (args.length === 4) {
                if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                    return context.error('Cannot use collator to compare non-string types.');
                }
                collator = context.parse(args[3], 3, CollatorType);
                if (!collator) {
                    return null;
                }
            }
            return new Comparison(lhs, rhs, collator);
        };
        Comparison.prototype.evaluate = function evaluate(ctx) {
            var lhs = this.lhs.evaluate(ctx);
            var rhs = this.rhs.evaluate(ctx);
            if (isOrderComparison && this.hasUntypedArgument) {
                var lt = typeOf(lhs);
                var rt = typeOf(rhs);
                if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {
                    throw new RuntimeError('Expected arguments for "' + op + '" to be (string, string) or (number, number), but found (' + lt.kind + ', ' + rt.kind + ') instead.');
                }
            }
            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
                var lt$1 = typeOf(lhs);
                var rt$1 = typeOf(rhs);
                if (lt$1.kind !== 'string' || rt$1.kind !== 'string') {
                    return compareBasic(ctx, lhs, rhs);
                }
            }
            return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
        };
        Comparison.prototype.eachChild = function eachChild(fn) {
            fn(this.lhs);
            fn(this.rhs);
            if (this.collator) {
                fn(this.collator);
            }
        };
        Comparison.prototype.outputDefined = function outputDefined() {
            return true;
        };
        Comparison.prototype.serialize = function serialize() {
            var serialized = [op];
            this.eachChild(function (child) {
                serialized.push(child.serialize());
            });
            return serialized;
        };
        return Comparison;
    }();
}
var Equals = makeComparison('==', eq, eqCollate);
var NotEquals = makeComparison('!=', neq, neqCollate);
var LessThan = makeComparison('<', lt, ltCollate);
var GreaterThan = makeComparison('>', gt, gtCollate);
var LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);
var GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);

var NumberFormat = function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {
    this.type = StringType;
    this.number = number;
    this.locale = locale;
    this.currency = currency;
    this.minFractionDigits = minFractionDigits;
    this.maxFractionDigits = maxFractionDigits;
};
NumberFormat.parse = function parse(args, context) {
    if (args.length !== 3) {
        return context.error('Expected two arguments.');
    }
    var number = context.parse(args[1], 1, NumberType);
    if (!number) {
        return null;
    }
    var options = args[2];
    if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== 'object' || Array.isArray(options)) {
        return context.error('NumberFormat options argument must be an object.');
    }
    var locale = null;
    if (options['locale']) {
        locale = context.parse(options['locale'], 1, StringType);
        if (!locale) {
            return null;
        }
    }
    var currency = null;
    if (options['currency']) {
        currency = context.parse(options['currency'], 1, StringType);
        if (!currency) {
            return null;
        }
    }
    var minFractionDigits = null;
    if (options['min-fraction-digits']) {
        minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);
        if (!minFractionDigits) {
            return null;
        }
    }
    var maxFractionDigits = null;
    if (options['max-fraction-digits']) {
        maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);
        if (!maxFractionDigits) {
            return null;
        }
    }
    return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);
};
NumberFormat.prototype.evaluate = function evaluate(ctx) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
        style: this.currency ? 'currency' : 'decimal',
        currency: this.currency ? this.currency.evaluate(ctx) : undefined,
        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
    }).format(this.number.evaluate(ctx));
};
NumberFormat.prototype.eachChild = function eachChild(fn) {
    fn(this.number);
    if (this.locale) {
        fn(this.locale);
    }
    if (this.currency) {
        fn(this.currency);
    }
    if (this.minFractionDigits) {
        fn(this.minFractionDigits);
    }
    if (this.maxFractionDigits) {
        fn(this.maxFractionDigits);
    }
};
NumberFormat.prototype.outputDefined = function outputDefined() {
    return false;
};
NumberFormat.prototype.serialize = function serialize() {
    var options = {};
    if (this.locale) {
        options['locale'] = this.locale.serialize();
    }
    if (this.currency) {
        options['currency'] = this.currency.serialize();
    }
    if (this.minFractionDigits) {
        options['min-fraction-digits'] = this.minFractionDigits.serialize();
    }
    if (this.maxFractionDigits) {
        options['max-fraction-digits'] = this.maxFractionDigits.serialize();
    }
    return ['number-format', this.number.serialize(), options];
};

var Length = function Length(input) {
    this.type = NumberType;
    this.input = input;
};
Length.parse = function parse(args, context) {
    if (args.length !== 2) {
        return context.error('Expected 1 argument, but found ' + (args.length - 1) + ' instead.');
    }
    var input = context.parse(args[1], 1);
    if (!input) {
        return null;
    }
    if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value') {
        return context.error('Expected argument of type string or array, but found ' + toString(input.type) + ' instead.');
    }
    return new Length(input);
};
Length.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    if (typeof input === 'string') {
        return input.length;
    } else if (Array.isArray(input)) {
        return input.length;
    } else {
        throw new RuntimeError('Expected value to be of type string or array, but found ' + toString(typeOf(input)) + ' instead.');
    }
};
Length.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
};
Length.prototype.outputDefined = function outputDefined() {
    return false;
};
Length.prototype.serialize = function serialize() {
    var serialized = ['length'];
    this.eachChild(function (child) {
        serialized.push(child.serialize());
    });
    return serialized;
};

var expressions = {
    '==': Equals,
    '!=': NotEquals,
    '>': GreaterThan,
    '<': LessThan,
    '>=': GreaterThanOrEqual,
    '<=': LessThanOrEqual,
    'array': Assertion,
    'at': At,
    'boolean': Assertion,
    'case': Case,
    'coalesce': Coalesce,
    'collator': CollatorExpression,
    'format': FormatExpression,
    'image': ImageExpression,
    'in': In,
    'index-of': IndexOf,
    'interpolate': Interpolate,
    'interpolate-hcl': Interpolate,
    'interpolate-lab': Interpolate,
    'length': Length,
    'let': Let,
    'literal': Literal,
    'match': Match,
    'number': Assertion,
    'number-format': NumberFormat,
    'object': Assertion,
    'slice': Slice,
    'step': Step,
    'string': Assertion,
    'to-boolean': Coercion,
    'to-color': Coercion,
    'to-number': Coercion,
    'to-string': Coercion,
    'var': Var,
    'within': Within
};
function rgba(ctx, ref) {
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    r = r.evaluate(ctx);
    g = g.evaluate(ctx);
    b = b.evaluate(ctx);
    var alpha = a ? a.evaluate(ctx) : 1;
    var error = validateRGBA(r, g, b, alpha);
    if (error) {
        throw new RuntimeError(error);
    }
    return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
}
function has(key, obj) {
    return key in obj;
}
function get(key, obj) {
    var v = obj[key];
    return typeof v === 'undefined' ? null : v;
}
function binarySearch(v, a, i, j) {
    while (i <= j) {
        var m = i + j >> 1;
        if (a[m] === v) {
            return true;
        }
        if (a[m] > v) {
            j = m - 1;
        } else {
            i = m + 1;
        }
    }
    return false;
}
function varargs(type) {
    return { type: type };
}
CompoundExpression.register(expressions, {
    'error': [ErrorType, [StringType], function (ctx, ref) {
        var v = ref[0];
        throw new RuntimeError(v.evaluate(ctx));
    }],
    'typeof': [StringType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        return toString(typeOf(v.evaluate(ctx)));
    }],
    'to-rgba': [array(NumberType, 4), [ColorType], function (ctx, ref) {
        var v = ref[0];
        return v.evaluate(ctx).toArray();
    }],
    'rgb': [ColorType, [NumberType, NumberType, NumberType], rgba],
    'rgba': [ColorType, [NumberType, NumberType, NumberType, NumberType], rgba],
    'has': {
        type: BooleanType,
        overloads: [[[StringType], function (ctx, ref) {
            var key = ref[0];
            return has(key.evaluate(ctx), ctx.properties());
        }], [[StringType, ObjectType], function (ctx, ref) {
            var key = ref[0];
            var obj = ref[1];
            return has(key.evaluate(ctx), obj.evaluate(ctx));
        }]]
    },
    'get': {
        type: ValueType,
        overloads: [[[StringType], function (ctx, ref) {
            var key = ref[0];
            return get(key.evaluate(ctx), ctx.properties());
        }], [[StringType, ObjectType], function (ctx, ref) {
            var key = ref[0];
            var obj = ref[1];
            return get(key.evaluate(ctx), obj.evaluate(ctx));
        }]]
    },
    'feature-state': [ValueType, [StringType], function (ctx, ref) {
        var key = ref[0];
        return get(key.evaluate(ctx), ctx.featureState || {});
    }],
    'properties': [ObjectType, [], function (ctx) {
        return ctx.properties();
    }],
    'geometry-type': [StringType, [], function (ctx) {
        return ctx.geometryType();
    }],
    'id': [ValueType, [], function (ctx) {
        return ctx.id();
    }],
    'zoom': [NumberType, [], function (ctx) {
        return ctx.globals.zoom;
    }],
    'heatmap-density': [NumberType, [], function (ctx) {
        return ctx.globals.heatmapDensity || 0;
    }],
    'line-progress': [NumberType, [], function (ctx) {
        return ctx.globals.lineProgress || 0;
    }],
    'accumulated': [ValueType, [], function (ctx) {
        return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;
    }],
    '+': [NumberType, varargs(NumberType), function (ctx, args) {
        var result = 0;
        for (var i = 0, list = args; i < list.length; i += 1) {
            var arg = list[i];
            result += arg.evaluate(ctx);
        }
        return result;
    }],
    '*': [NumberType, varargs(NumberType), function (ctx, args) {
        var result = 1;
        for (var i = 0, list = args; i < list.length; i += 1) {
            var arg = list[i];
            result *= arg.evaluate(ctx);
        }
        return result;
    }],
    '-': {
        type: NumberType,
        overloads: [[[NumberType, NumberType], function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) - b.evaluate(ctx);
        }], [[NumberType], function (ctx, ref) {
            var a = ref[0];
            return -a.evaluate(ctx);
        }]]
    },
    '/': [NumberType, [NumberType, NumberType], function (ctx, ref) {
        var a = ref[0];
        var b = ref[1];
        return a.evaluate(ctx) / b.evaluate(ctx);
    }],
    '%': [NumberType, [NumberType, NumberType], function (ctx, ref) {
        var a = ref[0];
        var b = ref[1];
        return a.evaluate(ctx) % b.evaluate(ctx);
    }],
    'ln2': [NumberType, [], function () {
        return Math.LN2;
    }],
    'pi': [NumberType, [], function () {
        return Math.PI;
    }],
    'e': [NumberType, [], function () {
        return Math.E;
    }],
    '^': [NumberType, [NumberType, NumberType], function (ctx, ref) {
        var b = ref[0];
        var e = ref[1];
        return Math.pow(b.evaluate(ctx), e.evaluate(ctx));
    }],
    'sqrt': [NumberType, [NumberType], function (ctx, ref) {
        var x = ref[0];
        return Math.sqrt(x.evaluate(ctx));
    }],
    'log10': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.log(n.evaluate(ctx)) / Math.LN10;
    }],
    'ln': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.log(n.evaluate(ctx));
    }],
    'log2': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.log(n.evaluate(ctx)) / Math.LN2;
    }],
    'sin': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.sin(n.evaluate(ctx));
    }],
    'cos': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.cos(n.evaluate(ctx));
    }],
    'tan': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.tan(n.evaluate(ctx));
    }],
    'asin': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.asin(n.evaluate(ctx));
    }],
    'acos': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.acos(n.evaluate(ctx));
    }],
    'atan': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.atan(n.evaluate(ctx));
    }],
    'min': [NumberType, varargs(NumberType), function (ctx, args) {
        return Math.min.apply(Math, args.map(function (arg) {
            return arg.evaluate(ctx);
        }));
    }],
    'max': [NumberType, varargs(NumberType), function (ctx, args) {
        return Math.max.apply(Math, args.map(function (arg) {
            return arg.evaluate(ctx);
        }));
    }],
    'abs': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.abs(n.evaluate(ctx));
    }],
    'round': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        var v = n.evaluate(ctx);
        return v < 0 ? -Math.round(-v) : Math.round(v);
    }],
    'floor': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.floor(n.evaluate(ctx));
    }],
    'ceil': [NumberType, [NumberType], function (ctx, ref) {
        var n = ref[0];
        return Math.ceil(n.evaluate(ctx));
    }],
    'filter-==': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        return ctx.properties()[k.value] === v.value;
    }],
    'filter-id-==': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        return ctx.id() === v.value;
    }],
    'filter-type-==': [BooleanType, [StringType], function (ctx, ref) {
        var v = ref[0];
        return ctx.geometryType() === v.value;
    }],
    'filter-<': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a < b;
    }],
    'filter-id-<': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a < b;
    }],
    'filter->': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a > b;
    }],
    'filter-id->': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a > b;
    }],
    'filter-<=': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a <= b;
    }],
    'filter-id-<=': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a <= b;
    }],
    'filter->=': [BooleanType, [StringType, ValueType], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a >= b;
    }],
    'filter-id->=': [BooleanType, [ValueType], function (ctx, ref) {
        var v = ref[0];
        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a >= b;
    }],
    'filter-has': [BooleanType, [ValueType], function (ctx, ref) {
        var k = ref[0];
        return k.value in ctx.properties();
    }],
    'filter-has-id': [BooleanType, [], function (ctx) {
        return ctx.id() !== null && ctx.id() !== undefined;
    }],
    'filter-type-in': [BooleanType, [array(StringType)], function (ctx, ref) {
        var v = ref[0];
        return v.value.indexOf(ctx.geometryType()) >= 0;
    }],
    'filter-id-in': [BooleanType, [array(ValueType)], function (ctx, ref) {
        var v = ref[0];
        return v.value.indexOf(ctx.id()) >= 0;
    }],
    'filter-in-small': [BooleanType, [StringType, array(ValueType)], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        return v.value.indexOf(ctx.properties()[k.value]) >= 0;
    }],
    'filter-in-large': [BooleanType, [StringType, array(ValueType)], function (ctx, ref) {
        var k = ref[0];
        var v = ref[1];
        return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);
    }],
    'all': {
        type: BooleanType,
        overloads: [[[BooleanType, BooleanType], function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) && b.evaluate(ctx);
        }], [varargs(BooleanType), function (ctx, args) {
            for (var i = 0, list = args; i < list.length; i += 1) {
                var arg = list[i];
                if (!arg.evaluate(ctx)) {
                    return false;
                }
            }
            return true;
        }]]
    },
    'any': {
        type: BooleanType,
        overloads: [[[BooleanType, BooleanType], function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) || b.evaluate(ctx);
        }], [varargs(BooleanType), function (ctx, args) {
            for (var i = 0, list = args; i < list.length; i += 1) {
                var arg = list[i];
                if (arg.evaluate(ctx)) {
                    return true;
                }
            }
            return false;
        }]]
    },
    '!': [BooleanType, [BooleanType], function (ctx, ref) {
        var b = ref[0];
        return !b.evaluate(ctx);
    }],
    'is-supported-script': [BooleanType, [StringType], function (ctx, ref) {
        var s = ref[0];
        var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;
        if (isSupportedScript) {
            return isSupportedScript(s.evaluate(ctx));
        }
        return true;
    }],
    'upcase': [StringType, [StringType], function (ctx, ref) {
        var s = ref[0];
        return s.evaluate(ctx).toUpperCase();
    }],
    'downcase': [StringType, [StringType], function (ctx, ref) {
        var s = ref[0];
        return s.evaluate(ctx).toLowerCase();
    }],
    'concat': [StringType, varargs(ValueType), function (ctx, args) {
        return args.map(function (arg) {
            return toString$1(arg.evaluate(ctx));
        }).join('');
    }],
    'resolved-locale': [StringType, [CollatorType], function (ctx, ref) {
        var collator = ref[0];
        return collator.evaluate(ctx).resolvedLocale();
    }]
});

function success(value) {
    return {
        result: 'success',
        value: value
    };
}
function error(value) {
    return {
        result: 'error',
        value: value
    };
}

function supportsPropertyExpression(spec) {
    return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';
}
function supportsZoomExpression(spec) {
    return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;
}
function supportsInterpolation(spec) {
    return !!spec.expression && spec.expression.interpolated;
}

function getType(val) {
    if (val instanceof Number) {
        return 'number';
    } else if (val instanceof String) {
        return 'string';
    } else if (val instanceof Boolean) {
        return 'boolean';
    } else if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val === "undefined" ? "undefined" : _typeof(val);
    }
}

function isFunction$1(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && value !== null && !Array.isArray(value);
}
function identityFunction(x) {
    return x;
}
function createFunction(parameters, propertySpec) {
    var isColor = propertySpec.type === 'color';
    var zoomAndFeatureDependent = parameters.stops && _typeof(parameters.stops[0][0]) === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    var type = parameters.type || (supportsInterpolation(propertySpec) ? 'exponential' : 'interval');
    if (isColor) {
        parameters = extend({}, parameters);
        if (parameters.stops) {
            parameters.stops = parameters.stops.map(function (stop) {
                return [stop[0], Color.parse(stop[1])];
            });
        }
        if (parameters.default) {
            parameters.default = Color.parse(parameters.default);
        } else {
            parameters.default = Color.parse(propertySpec.default);
        }
    }
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb' && !colorSpaces[parameters.colorSpace]) {
        throw new Error('Unknown color space: ' + parameters.colorSpace);
    }
    var innerFun;
    var hashedStops;
    var categoricalKeyType;
    if (type === 'exponential') {
        innerFun = evaluateExponentialFunction;
    } else if (type === 'interval') {
        innerFun = evaluateIntervalFunction;
    } else if (type === 'categorical') {
        innerFun = evaluateCategoricalFunction;
        hashedStops = Object.create(null);
        for (var i = 0, list = parameters.stops; i < list.length; i += 1) {
            var stop = list[i];
            hashedStops[stop[0]] = stop[1];
        }
        categoricalKeyType = _typeof(parameters.stops[0][0]);
    } else if (type === 'identity') {
        innerFun = evaluateIdentityFunction;
    } else {
        throw new Error('Unknown function type "' + type + '"');
    }
    if (zoomAndFeatureDependent) {
        var featureFunctions = {};
        var zoomStops = [];
        for (var s = 0; s < parameters.stops.length; s++) {
            var stop$1 = parameters.stops[s];
            var zoom = stop$1[0].zoom;
            if (featureFunctions[zoom] === undefined) {
                featureFunctions[zoom] = {
                    zoom: zoom,
                    type: parameters.type,
                    property: parameters.property,
                    default: parameters.default,
                    stops: []
                };
                zoomStops.push(zoom);
            }
            featureFunctions[zoom].stops.push([stop$1[0].value, stop$1[1]]);
        }
        var featureFunctionStops = [];
        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {
            var z = list$1[i$1];
            featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);
        }
        var interpolationType = { name: 'linear' };
        return {
            kind: 'composite',
            interpolationType: interpolationType,
            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),
            zoomStops: featureFunctionStops.map(function (s) {
                return s[0];
            }),
            evaluate: function evaluate(ref, properties) {
                var zoom = ref.zoom;
                return evaluateExponentialFunction({
                    stops: featureFunctionStops,
                    base: parameters.base
                }, propertySpec, zoom).evaluate(zoom, properties);
            }
        };
    } else if (zoomDependent) {
        var interpolationType$1 = type === 'exponential' ? {
            name: 'exponential',
            base: parameters.base !== undefined ? parameters.base : 1
        } : null;
        return {
            kind: 'camera',
            interpolationType: interpolationType$1,
            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType$1),
            zoomStops: parameters.stops.map(function (s) {
                return s[0];
            }),
            evaluate: function evaluate(ref) {
                var zoom = ref.zoom;
                return innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType);
            }
        };
    } else {
        return {
            kind: 'source',
            evaluate: function evaluate(_, feature) {
                var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;
                if (value === undefined) {
                    return coalesce(parameters.default, propertySpec.default);
                }
                return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);
            }
        };
    }
}
function coalesce(a, b, c) {
    if (a !== undefined) {
        return a;
    }
    if (b !== undefined) {
        return b;
    }
    if (c !== undefined) {
        return c;
    }
}
function evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {
    var evaluated = (typeof input === "undefined" ? "undefined" : _typeof(input)) === keyType ? hashedStops[input] : undefined;
    return coalesce(evaluated, parameters.default, propertySpec.default);
}
function evaluateIntervalFunction(parameters, propertySpec, input) {
    if (getType(input) !== 'number') {
        return coalesce(parameters.default, propertySpec.default);
    }
    var n = parameters.stops.length;
    if (n === 1) {
        return parameters.stops[0][1];
    }
    if (input <= parameters.stops[0][0]) {
        return parameters.stops[0][1];
    }
    if (input >= parameters.stops[n - 1][0]) {
        return parameters.stops[n - 1][1];
    }
    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
        return stop[0];
    }), input);
    return parameters.stops[index][1];
}
function evaluateExponentialFunction(parameters, propertySpec, input) {
    var base = parameters.base !== undefined ? parameters.base : 1;
    if (getType(input) !== 'number') {
        return coalesce(parameters.default, propertySpec.default);
    }
    var n = parameters.stops.length;
    if (n === 1) {
        return parameters.stops[0][1];
    }
    if (input <= parameters.stops[0][0]) {
        return parameters.stops[0][1];
    }
    if (input >= parameters.stops[n - 1][0]) {
        return parameters.stops[n - 1][1];
    }
    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
        return stop[0];
    }), input);
    var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);
    var outputLower = parameters.stops[index][1];
    var outputUpper = parameters.stops[index + 1][1];
    var interp = interpolate[propertySpec.type] || identityFunction;
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {
        var colorspace = colorSpaces[parameters.colorSpace];
        interp = function interp(a, b) {
            return colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));
        };
    }
    if (typeof outputLower.evaluate === 'function') {
        return {
            evaluate: function evaluate() {
                var args = [],
                    len = arguments.length;
                while (len--) {
                    args[len] = arguments[len];
                }var evaluatedLower = outputLower.evaluate.apply(undefined, args);
                var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);
                if (evaluatedLower === undefined || evaluatedUpper === undefined) {
                    return undefined;
                }
                return interp(evaluatedLower, evaluatedUpper, t);
            }
        };
    }
    return interp(outputLower, outputUpper, t);
}
function evaluateIdentityFunction(parameters, propertySpec, input) {
    if (propertySpec.type === 'color') {
        input = Color.parse(input);
    } else if (propertySpec.type === 'formatted') {
        input = Formatted.fromString(input.toString());
    } else if (propertySpec.type === 'resolvedImage') {
        input = ResolvedImage.fromString(input.toString());
    } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {
        input = undefined;
    }
    return coalesce(input, parameters.default, propertySpec.default);
}
function interpolationFactor(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

var StyleExpression = function StyleExpression(expression, propertySpec) {
    this.expression = expression;
    this._warningHistory = {};
    this._evaluator = new EvaluationContext();
    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;
    this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;
};
StyleExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature;
    this._evaluator.featureState = featureState;
    this._evaluator.canonical = canonical;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection;
    return this.expression.evaluate(this._evaluator);
};
StyleExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature || null;
    this._evaluator.featureState = featureState || null;
    this._evaluator.canonical = canonical;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection || null;
    try {
        var val = this.expression.evaluate(this._evaluator);
        if (val === null || val === undefined || typeof val === 'number' && val !== val) {
            return this._defaultValue;
        }
        if (this._enumValues && !(val in this._enumValues)) {
            throw new RuntimeError('Expected value to be one of ' + Object.keys(this._enumValues).map(function (v) {
                return JSON.stringify(v);
            }).join(', ') + ', but found ' + JSON.stringify(val) + ' instead.');
        }
        return val;
    } catch (e) {
        if (!this._warningHistory[e.message]) {
            this._warningHistory[e.message] = true;
            if (typeof console !== 'undefined') {
                console.warn(e.message);
            }
        }
        return this._defaultValue;
    }
};
function isExpression(expression) {
    return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in expressions;
}
function createExpression(expression, propertySpec) {
    var parser = new ParsingContext(expressions, [], propertySpec ? getExpectedType(propertySpec) : undefined);
    var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? { typeAnnotation: 'coerce' } : undefined);
    if (!parsed) {
        return error(parser.errors);
    }
    return success(new StyleExpression(parsed, propertySpec));
}
var ZoomConstantExpression = function ZoomConstantExpression(kind, expression) {
    this.kind = kind;
    this._styleExpression = expression;
    this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);
};
ZoomConstantExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomConstantExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
};
var ZoomDependentExpression = function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {
    this.kind = kind;
    this.zoomStops = zoomStops;
    this._styleExpression = expression;
    this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);
    this.interpolationType = interpolationType;
};
ZoomDependentExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomDependentExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomDependentExpression.prototype.interpolationFactor = function interpolationFactor(input, lower, upper) {
    if (this.interpolationType) {
        return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);
    } else {
        return 0;
    }
};
function createPropertyExpression(expression, propertySpec) {
    expression = createExpression(expression, propertySpec);
    if (expression.result === 'error') {
        return expression;
    }
    var parsed = expression.value.expression;
    var isFeatureConstant$1 = isFeatureConstant(parsed);
    if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {
        return error([new ParsingError('', 'data expressions not supported')]);
    }
    var isZoomConstant = isGlobalPropertyConstant(parsed, ['zoom']);
    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
        return error([new ParsingError('', 'zoom expressions not supported')]);
    }
    var zoomCurve = findZoomCurve(parsed);
    if (!zoomCurve && !isZoomConstant) {
        return error([new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
    } else if (zoomCurve instanceof ParsingError) {
        return error([zoomCurve]);
    } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {
        return error([new ParsingError('', '"interpolate" expressions cannot be used with this property')]);
    }
    if (!zoomCurve) {
        return success(isFeatureConstant$1 ? new ZoomConstantExpression('constant', expression.value) : new ZoomConstantExpression('source', expression.value));
    }
    var interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;
    return success(isFeatureConstant$1 ? new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));
}
var StylePropertyFunction = function StylePropertyFunction(parameters, specification) {
    this._parameters = parameters;
    this._specification = specification;
    extend(this, createFunction(this._parameters, this._specification));
};
StylePropertyFunction.deserialize = function deserialize(serialized) {
    return new StylePropertyFunction(serialized._parameters, serialized._specification);
};
StylePropertyFunction.serialize = function serialize(input) {
    return {
        _parameters: input._parameters,
        _specification: input._specification
    };
};
function normalizePropertyExpression(value, specification) {
    if (isFunction$1(value)) {
        return new StylePropertyFunction(value, specification);
    } else if (isExpression(value)) {
        var expression = createPropertyExpression(value, specification);
        if (expression.result === 'error') {
            throw new Error(expression.value.map(function (err) {
                return err.key + ': ' + err.message;
            }).join(', '));
        }
        return expression.value;
    } else {
        var constant = value;
        if (typeof value === 'string' && specification.type === 'color') {
            constant = Color.parse(value);
        }
        return {
            kind: 'constant',
            evaluate: function evaluate() {
                return constant;
            }
        };
    }
}
function findZoomCurve(expression) {
    var result = null;
    if (expression instanceof Let) {
        result = findZoomCurve(expression.result);
    } else if (expression instanceof Coalesce) {
        for (var i = 0, list = expression.args; i < list.length; i += 1) {
            var arg = list[i];
            result = findZoomCurve(arg);
            if (result) {
                break;
            }
        }
    } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === 'zoom') {
        result = expression;
    }
    if (result instanceof ParsingError) {
        return result;
    }
    expression.eachChild(function (child) {
        var childResult = findZoomCurve(child);
        if (childResult instanceof ParsingError) {
            result = childResult;
        } else if (!result && childResult) {
            result = new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
        } else if (result && childResult && result !== childResult) {
            result = new ParsingError('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
        }
    });
    return result;
}
function getExpectedType(spec) {
    var types = {
        color: ColorType,
        string: StringType,
        number: NumberType,
        enum: StringType,
        boolean: BooleanType,
        formatted: FormattedType,
        resolvedImage: ResolvedImageType
    };
    if (spec.type === 'array') {
        return array(types[spec.value] || ValueType, spec.length);
    }
    return types[spec.type];
}
function getDefaultValue(spec) {
    if (spec.type === 'color' && isFunction$1(spec.default)) {
        return new Color(0, 0, 0, 0);
    } else if (spec.type === 'color') {
        return Color.parse(spec.default) || null;
    } else if (spec.default === undefined) {
        return null;
    } else {
        return spec.default;
    }
}

function convertLiteral(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' ? ['literal', value] : value;
}
function convertFunction(parameters, propertySpec) {
    var stops = parameters.stops;
    if (!stops) {
        return convertIdentityFunction(parameters, propertySpec);
    }
    var zoomAndFeatureDependent = stops && _typeof(stops[0][0]) === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    stops = stops.map(function (stop) {
        if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {
            return [stop[0], convertTokenString(stop[1])];
        }
        return [stop[0], convertLiteral(stop[1])];
    });
    if (zoomAndFeatureDependent) {
        return convertZoomAndPropertyFunction(parameters, propertySpec, stops);
    } else if (zoomDependent) {
        return convertZoomFunction(parameters, propertySpec, stops);
    } else {
        return convertPropertyFunction(parameters, propertySpec, stops);
    }
}
function convertIdentityFunction(parameters, propertySpec) {
    var get = ['get', parameters.property];
    if (parameters.default === undefined) {
        return propertySpec.type === 'string' ? ['string', get] : get;
    } else if (propertySpec.type === 'enum') {
        return ['match', get, Object.keys(propertySpec.values), get, parameters.default];
    } else {
        var expression = [propertySpec.type === 'color' ? 'to-color' : propertySpec.type, get, convertLiteral(parameters.default)];
        if (propertySpec.type === 'array') {
            expression.splice(1, 0, propertySpec.value, propertySpec.length || null);
        }
        return expression;
    }
}
function getInterpolateOperator(parameters) {
    switch (parameters.colorSpace) {
        case 'hcl':
            return 'interpolate-hcl';
        case 'lab':
            return 'interpolate-lab';
        default:
            return 'interpolate';
    }
}
function convertZoomAndPropertyFunction(parameters, propertySpec, stops) {
    var featureFunctionParameters = {};
    var featureFunctionStops = {};
    var zoomStops = [];
    for (var s = 0; s < stops.length; s++) {
        var stop = stops[s];
        var zoom = stop[0].zoom;
        if (featureFunctionParameters[zoom] === undefined) {
            featureFunctionParameters[zoom] = {
                zoom: zoom,
                type: parameters.type,
                property: parameters.property,
                default: parameters.default
            };
            featureFunctionStops[zoom] = [];
            zoomStops.push(zoom);
        }
        featureFunctionStops[zoom].push([stop[0].value, stop[1]]);
    }
    var functionType = getFunctionType({}, propertySpec);
    if (functionType === 'exponential') {
        var expression = [getInterpolateOperator(parameters), ['linear'], ['zoom']];
        for (var i = 0, list = zoomStops; i < list.length; i += 1) {
            var z = list[i];
            var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
            appendStopPair(expression, z, output, false);
        }
        return expression;
    } else {
        var expression$1 = ['step', ['zoom']];
        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {
            var z$1 = list$1[i$1];
            var output$1 = convertPropertyFunction(featureFunctionParameters[z$1], propertySpec, featureFunctionStops[z$1]);
            appendStopPair(expression$1, z$1, output$1, true);
        }
        fixupDegenerateStepCurve(expression$1);
        return expression$1;
    }
}
function coalesce$1(a, b) {
    if (a !== undefined) {
        return a;
    }
    if (b !== undefined) {
        return b;
    }
}
function convertPropertyFunction(parameters, propertySpec, stops) {
    var type = getFunctionType(parameters, propertySpec);
    var get = ['get', parameters.property];
    if (type === 'categorical' && typeof stops[0][0] === 'boolean') {
        var expression = ['case'];
        for (var i = 0, list = stops; i < list.length; i += 1) {
            var stop = list[i];
            expression.push(['==', get, stop[0]], stop[1]);
        }
        expression.push(convertLiteral(coalesce$1(parameters.default, propertySpec.default)));
        return expression;
    } else if (type === 'categorical') {
        var expression$1 = ['match', get];
        for (var i$1 = 0, list$1 = stops; i$1 < list$1.length; i$1 += 1) {
            var stop$1 = list$1[i$1];
            appendStopPair(expression$1, stop$1[0], stop$1[1], false);
        }
        expression$1.push(convertLiteral(coalesce$1(parameters.default, propertySpec.default)));
        return expression$1;
    } else if (type === 'interval') {
        var expression$2 = ['step', ['number', get]];
        for (var i$2 = 0, list$2 = stops; i$2 < list$2.length; i$2 += 1) {
            var stop$2 = list$2[i$2];
            appendStopPair(expression$2, stop$2[0], stop$2[1], true);
        }
        fixupDegenerateStepCurve(expression$2);
        return parameters.default === undefined ? expression$2 : ['case', ['==', ['typeof', get], 'number'], expression$2, convertLiteral(parameters.default)];
    } else if (type === 'exponential') {
        var base = parameters.base !== undefined ? parameters.base : 1;
        var expression$3 = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], ['number', get]];
        for (var i$3 = 0, list$3 = stops; i$3 < list$3.length; i$3 += 1) {
            var stop$3 = list$3[i$3];
            appendStopPair(expression$3, stop$3[0], stop$3[1], false);
        }
        return parameters.default === undefined ? expression$3 : ['case', ['==', ['typeof', get], 'number'], expression$3, convertLiteral(parameters.default)];
    } else {
        throw new Error('Unknown property function type ' + type);
    }
}
function convertZoomFunction(parameters, propertySpec, stops, input) {
    if (input === void 0) input = ['zoom'];
    var type = getFunctionType(parameters, propertySpec);
    var expression;
    var isStep = false;
    if (type === 'interval') {
        expression = ['step', input];
        isStep = true;
    } else if (type === 'exponential') {
        var base = parameters.base !== undefined ? parameters.base : 1;
        expression = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], input];
    } else {
        throw new Error('Unknown zoom function type "' + type + '"');
    }
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var stop = list[i];
        appendStopPair(expression, stop[0], stop[1], isStep);
    }
    fixupDegenerateStepCurve(expression);
    return expression;
}
function fixupDegenerateStepCurve(expression) {
    if (expression[0] === 'step' && expression.length === 3) {
        expression.push(0);
        expression.push(expression[3]);
    }
}
function appendStopPair(curve, input, output, isStep) {
    if (curve.length > 3 && input === curve[curve.length - 2]) {
        return;
    }
    if (!(isStep && curve.length === 2)) {
        curve.push(input);
    }
    curve.push(output);
}
function getFunctionType(parameters, propertySpec) {
    if (parameters.type) {
        return parameters.type;
    } else {
        return propertySpec.expression.interpolated ? 'exponential' : 'interval';
    }
}
function convertTokenString(s) {
    var result = ['concat'];
    var re = /{([^{}]+)}/g;
    var pos = 0;
    for (var match = re.exec(s); match !== null; match = re.exec(s)) {
        var literal = s.slice(pos, re.lastIndex - match[0].length);
        pos = re.lastIndex;
        if (literal.length > 0) {
            result.push(literal);
        }
        result.push(['get', match[1]]);
    }
    if (result.length === 1) {
        return s;
    }
    if (pos < s.length) {
        result.push(s.slice(pos));
    } else if (result.length === 2) {
        return ['to-string', result[1]];
    }
    return result;
}

function isExpressionFilter(filter) {
    if (filter === true || filter === false) {
        return true;
    }
    if (!Array.isArray(filter) || filter.length === 0) {
        return false;
    }
    switch (filter[0]) {
        case 'has':
            return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';
        case 'in':
            return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));
        case '!in':
        case '!has':
        case 'none':
            return false;
        case '==':
        case '!=':
        case '>':
        case '>=':
        case '<':
        case '<=':
            return filter.length !== 3 || Array.isArray(filter[1]) || Array.isArray(filter[2]);
        case 'any':
        case 'all':
            for (var i = 0, list = filter.slice(1); i < list.length; i += 1) {
                var f = list[i];
                if (!isExpressionFilter(f) && typeof f !== 'boolean') {
                    return false;
                }
            }
            return true;
        default:
            return true;
    }
}
var filterSpec = {
    'type': 'boolean',
    'default': false,
    'transition': false,
    'property-type': 'data-driven',
    'expression': {
        'interpolated': false,
        'parameters': ['zoom', 'feature']
    }
};
function createFilter(filter) {
    if (filter === null || filter === undefined) {
        return {
            filter: function filter() {
                return true;
            },
            needGeometry: false
        };
    }
    if (!isExpressionFilter(filter)) {
        filter = convertFilter(filter);
    }
    var compiled = createExpression(filter, filterSpec);
    if (compiled.result === 'error') {
        throw new Error(compiled.value.map(function (err) {
            return err.key + ': ' + err.message;
        }).join(', '));
    } else {
        var needGeometry = Array.isArray(filter) && filter.length !== 0 && filter[0] === 'within';
        return {
            filter: function filter(globalProperties, feature, canonical) {
                return compiled.value.evaluate(globalProperties, feature, {}, canonical);
            },
            needGeometry: needGeometry
        };
    }
}
function compare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
function convertFilter(filter) {
    if (!filter) {
        return true;
    }
    var op = filter[0];
    if (filter.length <= 1) {
        return op !== 'any';
    }
    var converted = op === '==' ? convertComparisonOp(filter[1], filter[2], '==') : op === '!=' ? convertNegation(convertComparisonOp(filter[1], filter[2], '==')) : op === '<' || op === '>' || op === '<=' || op === '>=' ? convertComparisonOp(filter[1], filter[2], op) : op === 'any' ? convertDisjunctionOp(filter.slice(1)) : op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter)) : op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === 'in' ? convertInOp(filter[1], filter.slice(2)) : op === '!in' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === 'has' ? convertHasOp(filter[1]) : op === '!has' ? convertNegation(convertHasOp(filter[1])) : true;
    return converted;
}
function convertComparisonOp(property, value, op) {
    switch (property) {
        case '$type':
            return ['filter-type-' + op, value];
        case '$id':
            return ['filter-id-' + op, value];
        default:
            return ['filter-' + op, property, value];
    }
}
function convertDisjunctionOp(filters) {
    return ['any'].concat(filters.map(convertFilter));
}
function convertInOp(property, values) {
    if (values.length === 0) {
        return false;
    }
    switch (property) {
        case '$type':
            return ['filter-type-in', ['literal', values]];
        case '$id':
            return ['filter-id-in', ['literal', values]];
        default:
            if (values.length > 200 && !values.some(function (v) {
                return (typeof v === "undefined" ? "undefined" : _typeof(v)) !== _typeof(values[0]);
            })) {
                return ['filter-in-large', property, ['literal', values.sort(compare)]];
            } else {
                return ['filter-in-small', property, ['literal', values]];
            }
    }
}
function convertHasOp(property) {
    switch (property) {
        case '$type':
            return true;
        case '$id':
            return ['filter-has-id'];
        default:
            return ['filter-has', property];
    }
}
function convertNegation(filter) {
    return ['!', filter];
}

function convertFilter$1(filter) {
    return _convertFilter(filter, {});
}
function _convertFilter(filter, expectedTypes) {
    var ref$1;
    if (isExpressionFilter(filter)) {
        return filter;
    }
    if (!filter) {
        return true;
    }
    var op = filter[0];
    if (filter.length <= 1) {
        return op !== 'any';
    }
    var converted;
    if (op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=') {
        var ref = filter;
        var property = ref[1];
        var value = ref[2];
        converted = convertComparisonOp$1(property, value, op, expectedTypes);
    } else if (op === 'any') {
        var children = filter.slice(1).map(function (f) {
            var types = {};
            var child = _convertFilter(f, types);
            var typechecks = runtimeTypeChecks(types);
            return typechecks === true ? child : ['case', typechecks, child, false];
        });
        return ['any'].concat(children);
    } else if (op === 'all') {
        var children$1 = filter.slice(1).map(function (f) {
            return _convertFilter(f, expectedTypes);
        });
        return children$1.length > 1 ? ['all'].concat(children$1) : (ref$1 = []).concat.apply(ref$1, children$1);
    } else if (op === 'none') {
        return ['!', _convertFilter(['any'].concat(filter.slice(1)), {})];
    } else if (op === 'in') {
        converted = convertInOp$1(filter[1], filter.slice(2));
    } else if (op === '!in') {
        converted = convertInOp$1(filter[1], filter.slice(2), true);
    } else if (op === 'has') {
        converted = convertHasOp$1(filter[1]);
    } else if (op === '!has') {
        converted = ['!', convertHasOp$1(filter[1])];
    } else {
        converted = true;
    }
    return converted;
}
function runtimeTypeChecks(expectedTypes) {
    var conditions = [];
    for (var property in expectedTypes) {
        var get = property === '$id' ? ['id'] : ['get', property];
        conditions.push(['==', ['typeof', get], expectedTypes[property]]);
    }
    if (conditions.length === 0) {
        return true;
    }
    if (conditions.length === 1) {
        return conditions[0];
    }
    return ['all'].concat(conditions);
}
function convertComparisonOp$1(property, value, op, expectedTypes) {
    var get;
    if (property === '$type') {
        return [op, ['geometry-type'], value];
    } else if (property === '$id') {
        get = ['id'];
    } else {
        get = ['get', property];
    }
    if (expectedTypes && value !== null) {
        var type = typeof value === "undefined" ? "undefined" : _typeof(value);
        expectedTypes[property] = type;
    }
    if (op === '==' && property !== '$id' && value === null) {
        return ['all', ['has', property], ['==', get, null]];
    } else if (op === '!=' && property !== '$id' && value === null) {
        return ['any', ['!', ['has', property]], ['!=', get, null]];
    }
    return [op, get, value];
}
function convertInOp$1(property, values, negate) {
    if (negate === void 0) negate = false;
    if (values.length === 0) {
        return negate;
    }
    var get;
    if (property === '$type') {
        get = ['geometry-type'];
    } else if (property === '$id') {
        get = ['id'];
    } else {
        get = ['get', property];
    }
    var uniformTypes = true;
    var type = _typeof(values[0]);
    for (var i = 0, list = values; i < list.length; i += 1) {
        var value = list[i];
        if ((typeof value === "undefined" ? "undefined" : _typeof(value)) !== type) {
            uniformTypes = false;
            break;
        }
    }
    if (uniformTypes && (type === 'string' || type === 'number')) {
        var uniqueValues = values.sort().filter(function (v, i) {
            return i === 0 || values[i - 1] !== v;
        });
        return ['match', get, uniqueValues, !negate, negate];
    }
    return [negate ? 'all' : 'any'].concat(values.map(function (v) {
        return [negate ? '!=' : '==', get, v];
    }));
}
function convertHasOp$1(property) {
    if (property === '$type') {
        return true;
    } else if (property === '$id') {
        return ['!=', ['id'], null];
    } else {
        return ['has', property];
    }
}

function migrateToExpressions(style) {
    var converted = [];
    eachLayer(style, function (layer) {
        if (layer.filter) {
            layer.filter = convertFilter$1(layer.filter);
        }
    });
    eachProperty(style, {
        paint: true,
        layout: true
    }, function (ref) {
        var path = ref.path;
        var value = ref.value;
        var reference = ref.reference;
        var set = ref.set;
        if (isExpression(value)) {
            return;
        }
        if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && !Array.isArray(value)) {
            set(convertFunction(value, reference));
            converted.push(path.join('.'));
        } else if (reference.tokens && typeof value === 'string') {
            set(convertTokenString(value));
        }
    });
    return style;
}

function migrate(style) {
    var migrated = false;
    if (style.version === 7) {
        style = migrateToV8(style);
        migrated = true;
    }
    if (style.version === 8) {
        migrated = migrateToExpressions(style);
        migrated = true;
    }
    if (!migrated) {
        throw new Error('cannot migrate from', style.version);
    }
    return style;
}

function composite(style) {
    var styleIDs = [];
    var sourceIDs = [];
    var compositedSourceLayers = [];
    for (var id in style.sources) {
        var source = style.sources[id];
        if (source.type !== 'vector') {
            continue;
        }
        var match = /^mapbox:\/\/(.*)/.exec(source.url);
        if (!match) {
            continue;
        }
        styleIDs.push(id);
        sourceIDs.push(match[1]);
    }
    if (styleIDs.length < 2) {
        return style;
    }
    styleIDs.forEach(function (id) {
        delete style.sources[id];
    });
    var compositeID = sourceIDs.join(',');
    style.sources[compositeID] = {
        'type': 'vector',
        'url': 'mapbox://' + compositeID
    };
    style.layers.forEach(function (layer) {
        if (styleIDs.indexOf(layer.source) >= 0) {
            layer.source = compositeID;
            if ('source-layer' in layer) {
                if (compositedSourceLayers.indexOf(layer['source-layer']) >= 0) {
                    throw new Error('Conflicting source layer names');
                } else {
                    compositedSourceLayers.push(layer['source-layer']);
                }
            }
        }
    });
    return style;
}

var refProperties = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];

function deref(layer, parent) {
    var result = {};
    for (var k in layer) {
        if (k !== 'ref') {
            result[k] = layer[k];
        }
    }
    refProperties.forEach(function (k) {
        if (k in parent) {
            result[k] = parent[k];
        }
    });
    return result;
}
function derefLayers(layers) {
    layers = layers.slice();
    var map = Object.create(null);
    for (var i = 0; i < layers.length; i++) {
        map[layers[i].id] = layers[i];
    }
    for (var i$1 = 0; i$1 < layers.length; i$1++) {
        if ('ref' in layers[i$1]) {
            layers[i$1] = deref(layers[i$1], map[layers[i$1].ref]);
        }
    }
    return layers;
}

function deepEqual(a, b) {
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    if ((typeof a === "undefined" ? "undefined" : _typeof(a)) === 'object' && a !== null && b !== null) {
        if (!((typeof b === "undefined" ? "undefined" : _typeof(b)) === 'object')) {
            return false;
        }
        var keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) {
            return false;
        }
        for (var key in a) {
            if (!deepEqual(a[key], b[key])) {
                return false;
            }
        }
        return true;
    }
    return a === b;
}

var operations = {
    setStyle: 'setStyle',
    addLayer: 'addLayer',
    removeLayer: 'removeLayer',
    setPaintProperty: 'setPaintProperty',
    setLayoutProperty: 'setLayoutProperty',
    setFilter: 'setFilter',
    addSource: 'addSource',
    removeSource: 'removeSource',
    setGeoJSONSourceData: 'setGeoJSONSourceData',
    setLayerZoomRange: 'setLayerZoomRange',
    setLayerProperty: 'setLayerProperty',
    setCenter: 'setCenter',
    setZoom: 'setZoom',
    setBearing: 'setBearing',
    setPitch: 'setPitch',
    setSprite: 'setSprite',
    setGlyphs: 'setGlyphs',
    setTransition: 'setTransition',
    setLight: 'setLight'
};
function addSource(sourceId, after, commands) {
    commands.push({
        command: operations.addSource,
        args: [sourceId, after[sourceId]]
    });
}
function removeSource(sourceId, commands, sourcesRemoved) {
    commands.push({
        command: operations.removeSource,
        args: [sourceId]
    });
    sourcesRemoved[sourceId] = true;
}
function updateSource(sourceId, after, commands, sourcesRemoved) {
    removeSource(sourceId, commands, sourcesRemoved);
    addSource(sourceId, after, commands);
}
function canUpdateGeoJSON(before, after, sourceId) {
    var prop;
    for (prop in before[sourceId]) {
        if (!before[sourceId].hasOwnProperty(prop)) {
            continue;
        }
        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {
            return false;
        }
    }
    for (prop in after[sourceId]) {
        if (!after[sourceId].hasOwnProperty(prop)) {
            continue;
        }
        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {
            return false;
        }
    }
    return true;
}
function diffSources(before, after, commands, sourcesRemoved) {
    before = before || {};
    after = after || {};
    var sourceId;
    for (sourceId in before) {
        if (!before.hasOwnProperty(sourceId)) {
            continue;
        }
        if (!after.hasOwnProperty(sourceId)) {
            removeSource(sourceId, commands, sourcesRemoved);
        }
    }
    for (sourceId in after) {
        if (!after.hasOwnProperty(sourceId)) {
            continue;
        }
        if (!before.hasOwnProperty(sourceId)) {
            addSource(sourceId, after, commands);
        } else if (!deepEqual(before[sourceId], after[sourceId])) {
            if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson' && canUpdateGeoJSON(before, after, sourceId)) {
                commands.push({
                    command: operations.setGeoJSONSourceData,
                    args: [sourceId, after[sourceId].data]
                });
            } else {
                updateSource(sourceId, after, commands, sourcesRemoved);
            }
        }
    }
}
function diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {
    before = before || {};
    after = after || {};
    var prop;
    for (prop in before) {
        if (!before.hasOwnProperty(prop)) {
            continue;
        }
        if (!deepEqual(before[prop], after[prop])) {
            commands.push({
                command: command,
                args: [layerId, prop, after[prop], klass]
            });
        }
    }
    for (prop in after) {
        if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) {
            continue;
        }
        if (!deepEqual(before[prop], after[prop])) {
            commands.push({
                command: command,
                args: [layerId, prop, after[prop], klass]
            });
        }
    }
}
function pluckId(layer) {
    return layer.id;
}
function indexById(group, layer) {
    group[layer.id] = layer;
    return group;
}
function diffLayers(before, after, commands) {
    before = before || [];
    after = after || [];
    var beforeOrder = before.map(pluckId);
    var afterOrder = after.map(pluckId);
    var beforeIndex = before.reduce(indexById, {});
    var afterIndex = after.reduce(indexById, {});
    var tracker = beforeOrder.slice();
    var clean = Object.create(null);
    var i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;
    for (i = 0, d = 0; i < beforeOrder.length; i++) {
        layerId = beforeOrder[i];
        if (!afterIndex.hasOwnProperty(layerId)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            tracker.splice(tracker.indexOf(layerId, d), 1);
        } else {
            d++;
        }
    }
    for (i = 0, d = 0; i < afterOrder.length; i++) {
        layerId = afterOrder[afterOrder.length - 1 - i];
        if (tracker[tracker.length - 1 - i] === layerId) {
            continue;
        }
        if (beforeIndex.hasOwnProperty(layerId)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);
        } else {
            d++;
        }
        insertBeforeLayerId = tracker[tracker.length - i];
        commands.push({
            command: operations.addLayer,
            args: [afterIndex[layerId], insertBeforeLayerId]
        });
        tracker.splice(tracker.length - i, 0, layerId);
        clean[layerId] = true;
    }
    for (i = 0; i < afterOrder.length; i++) {
        layerId = afterOrder[i];
        beforeLayer = beforeIndex[layerId];
        afterLayer = afterIndex[layerId];
        if (clean[layerId] || deepEqual(beforeLayer, afterLayer)) {
            continue;
        }
        if (!deepEqual(beforeLayer.source, afterLayer.source) || !deepEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !deepEqual(beforeLayer.type, afterLayer.type)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];
            commands.push({
                command: operations.addLayer,
                args: [afterLayer, insertBeforeLayerId]
            });
            continue;
        }
        diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);
        diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);
        if (!deepEqual(beforeLayer.filter, afterLayer.filter)) {
            commands.push({
                command: operations.setFilter,
                args: [layerId, afterLayer.filter]
            });
        }
        if (!deepEqual(beforeLayer.minzoom, afterLayer.minzoom) || !deepEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {
            commands.push({
                command: operations.setLayerZoomRange,
                args: [layerId, afterLayer.minzoom, afterLayer.maxzoom]
            });
        }
        for (prop in beforeLayer) {
            if (!beforeLayer.hasOwnProperty(prop)) {
                continue;
            }
            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') {
                continue;
            }
            if (prop.indexOf('paint.') === 0) {
                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
            } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {
                commands.push({
                    command: operations.setLayerProperty,
                    args: [layerId, prop, afterLayer[prop]]
                });
            }
        }
        for (prop in afterLayer) {
            if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) {
                continue;
            }
            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') {
                continue;
            }
            if (prop.indexOf('paint.') === 0) {
                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
            } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {
                commands.push({
                    command: operations.setLayerProperty,
                    args: [layerId, prop, afterLayer[prop]]
                });
            }
        }
    }
}
function diffStyles(before, after) {
    if (!before) {
        return [{
            command: operations.setStyle,
            args: [after]
        }];
    }
    var commands = [];
    try {
        if (!deepEqual(before.version, after.version)) {
            return [{
                command: operations.setStyle,
                args: [after]
            }];
        }
        if (!deepEqual(before.center, after.center)) {
            commands.push({
                command: operations.setCenter,
                args: [after.center]
            });
        }
        if (!deepEqual(before.zoom, after.zoom)) {
            commands.push({
                command: operations.setZoom,
                args: [after.zoom]
            });
        }
        if (!deepEqual(before.bearing, after.bearing)) {
            commands.push({
                command: operations.setBearing,
                args: [after.bearing]
            });
        }
        if (!deepEqual(before.pitch, after.pitch)) {
            commands.push({
                command: operations.setPitch,
                args: [after.pitch]
            });
        }
        if (!deepEqual(before.sprite, after.sprite)) {
            commands.push({
                command: operations.setSprite,
                args: [after.sprite]
            });
        }
        if (!deepEqual(before.glyphs, after.glyphs)) {
            commands.push({
                command: operations.setGlyphs,
                args: [after.glyphs]
            });
        }
        if (!deepEqual(before.transition, after.transition)) {
            commands.push({
                command: operations.setTransition,
                args: [after.transition]
            });
        }
        if (!deepEqual(before.light, after.light)) {
            commands.push({
                command: operations.setLight,
                args: [after.light]
            });
        }
        var sourcesRemoved = {};
        var removeOrAddSourceCommands = [];
        diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);
        var beforeLayers = [];
        if (before.layers) {
            before.layers.forEach(function (layer) {
                if (sourcesRemoved[layer.source]) {
                    commands.push({
                        command: operations.removeLayer,
                        args: [layer.id]
                    });
                } else {
                    beforeLayers.push(layer);
                }
            });
        }
        commands = commands.concat(removeOrAddSourceCommands);
        diffLayers(beforeLayers, after.layers, commands);
    } catch (e) {
        console.warn('Unable to compute style diff:', e);
        commands = [{
            command: operations.setStyle,
            args: [after]
        }];
    }
    return commands;
}

var ValidationError = function ValidationError(key, value, message, identifier) {
    this.message = (key ? key + ': ' : '') + message;
    if (identifier) {
        this.identifier = identifier;
    }
    if (value !== null && value !== undefined && value.__line__) {
        this.line = value.__line__;
    }
};

var ParsingError$1 = function ParsingError(error) {
    this.error = error;
    this.message = error.message;
    var match = error.message.match(/line (\d+)/);
    this.line = match ? parseInt(match[1], 10) : 0;
};

function validateConstants(options) {
    var key = options.key;
    var constants = options.value;
    if (constants) {
        return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
    } else {
        return [];
    }
}

function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
        return value.valueOf();
    } else {
        return value;
    }
}
function deepUnbundle(value) {
    if (Array.isArray(value)) {
        return value.map(deepUnbundle);
    } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {
        var unbundledValue = {};
        for (var key in value) {
            unbundledValue[key] = deepUnbundle(value[key]);
        }
        return unbundledValue;
    }
    return unbundle(value);
}

function validateObject(options) {
    var key = options.key;
    var object = options.value;
    var elementSpecs = options.valueSpec || {};
    var elementValidators = options.objectElementValidators || {};
    var style = options.style;
    var styleSpec = options.styleSpec;
    var errors = [];
    var type = getType(object);
    if (type !== 'object') {
        return [new ValidationError(key, object, 'object expected, ' + type + ' found')];
    }
    for (var objectKey in object) {
        var elementSpecKey = objectKey.split('.')[0];
        var elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];
        var validateElement = void 0;
        if (elementValidators[elementSpecKey]) {
            validateElement = elementValidators[elementSpecKey];
        } else if (elementSpecs[elementSpecKey]) {
            validateElement = validate;
        } else if (elementValidators['*']) {
            validateElement = elementValidators['*'];
        } else if (elementSpecs['*']) {
            validateElement = validate;
        } else {
            errors.push(new ValidationError(key, object[objectKey], 'unknown property "' + objectKey + '"'));
            continue;
        }
        errors = errors.concat(validateElement({
            key: (key ? key + '.' : key) + objectKey,
            value: object[objectKey],
            valueSpec: elementSpec,
            style: style,
            styleSpec: styleSpec,
            object: object,
            objectKey: objectKey
        }, object));
    }
    for (var elementSpecKey$1 in elementSpecs) {
        if (elementValidators[elementSpecKey$1]) {
            continue;
        }
        if (elementSpecs[elementSpecKey$1].required && elementSpecs[elementSpecKey$1]['default'] === undefined && object[elementSpecKey$1] === undefined) {
            errors.push(new ValidationError(key, object, 'missing required property "' + elementSpecKey$1 + '"'));
        }
    }
    return errors;
}

function validateArray(options) {
    var array = options.value;
    var arraySpec = options.valueSpec;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var key = options.key;
    var validateArrayElement = options.arrayElementValidator || validate;
    if (getType(array) !== 'array') {
        return [new ValidationError(key, array, 'array expected, ' + getType(array) + ' found')];
    }
    if (arraySpec.length && array.length !== arraySpec.length) {
        return [new ValidationError(key, array, 'array length ' + arraySpec.length + ' expected, length ' + array.length + ' found')];
    }
    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
        return [new ValidationError(key, array, 'array length at least ' + arraySpec['min-length'] + ' expected, length ' + array.length + ' found')];
    }
    var arrayElementSpec = {
        'type': arraySpec.value,
        'values': arraySpec.values
    };
    if (styleSpec.$version < 7) {
        arrayElementSpec.function = arraySpec.function;
    }
    if (getType(arraySpec.value) === 'object') {
        arrayElementSpec = arraySpec.value;
    }
    var errors = [];
    for (var i = 0; i < array.length; i++) {
        errors = errors.concat(validateArrayElement({
            array: array,
            arrayIndex: i,
            value: array[i],
            valueSpec: arrayElementSpec,
            style: style,
            styleSpec: styleSpec,
            key: key + '[' + i + ']'
        }));
    }
    return errors;
}

function validateNumber(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var type = getType(value);
    if (type === 'number' && value !== value) {
        type = 'NaN';
    }
    if (type !== 'number') {
        return [new ValidationError(key, value, 'number expected, ' + type + ' found')];
    }
    if ('minimum' in valueSpec && value < valueSpec.minimum) {
        return [new ValidationError(key, value, value + ' is less than the minimum value ' + valueSpec.minimum)];
    }
    if ('maximum' in valueSpec && value > valueSpec.maximum) {
        return [new ValidationError(key, value, value + ' is greater than the maximum value ' + valueSpec.maximum)];
    }
    return [];
}

function validateFunction(options) {
    var functionValueSpec = options.valueSpec;
    var functionType = unbundle(options.value.type);
    var stopKeyType;
    var stopDomainValues = {};
    var previousStopDomainValue;
    var previousStopDomainZoom;
    var isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;
    var isPropertyFunction = !isZoomFunction;
    var isZoomAndPropertyFunction = getType(options.value.stops) === 'array' && getType(options.value.stops[0]) === 'array' && getType(options.value.stops[0][0]) === 'object';
    var errors = validateObject({
        key: options.key,
        value: options.value,
        valueSpec: options.styleSpec.function,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            stops: validateFunctionStops,
            default: validateFunctionDefault
        }
    });
    if (functionType === 'identity' && isZoomFunction) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "property"'));
    }
    if (functionType !== 'identity' && !options.value.stops) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "stops"'));
    }
    if (functionType === 'exponential' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {
        errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));
    }
    if (options.styleSpec.$version >= 8) {
        if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {
            errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));
        } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {
            errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));
        }
    }
    if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {
        errors.push(new ValidationError(options.key, options.value, '"property" property is required'));
    }
    return errors;
    function validateFunctionStops(options) {
        if (functionType === 'identity') {
            return [new ValidationError(options.key, options.value, 'identity function may not have a "stops" property')];
        }
        var errors = [];
        var value = options.value;
        errors = errors.concat(validateArray({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec,
            style: options.style,
            styleSpec: options.styleSpec,
            arrayElementValidator: validateFunctionStop
        }));
        if (getType(value) === 'array' && value.length === 0) {
            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
        }
        return errors;
    }
    function validateFunctionStop(options) {
        var errors = [];
        var value = options.value;
        var key = options.key;
        if (getType(value) !== 'array') {
            return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];
        }
        if (value.length !== 2) {
            return [new ValidationError(key, value, 'array length 2 expected, length ' + value.length + ' found')];
        }
        if (isZoomAndPropertyFunction) {
            if (getType(value[0]) !== 'object') {
                return [new ValidationError(key, value, 'object expected, ' + getType(value[0]) + ' found')];
            }
            if (value[0].zoom === undefined) {
                return [new ValidationError(key, value, 'object stop key must have zoom')];
            }
            if (value[0].value === undefined) {
                return [new ValidationError(key, value, 'object stop key must have value')];
            }
            if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {
                return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];
            }
            if (unbundle(value[0].zoom) !== previousStopDomainZoom) {
                previousStopDomainZoom = unbundle(value[0].zoom);
                previousStopDomainValue = undefined;
                stopDomainValues = {};
            }
            errors = errors.concat(validateObject({
                key: key + '[0]',
                value: value[0],
                valueSpec: { zoom: {} },
                style: options.style,
                styleSpec: options.styleSpec,
                objectElementValidators: {
                    zoom: validateNumber,
                    value: validateStopDomainValue
                }
            }));
        } else {
            errors = errors.concat(validateStopDomainValue({
                key: key + '[0]',
                value: value[0],
                valueSpec: {},
                style: options.style,
                styleSpec: options.styleSpec
            }, value));
        }
        if (isExpression(deepUnbundle(value[1]))) {
            return errors.concat([new ValidationError(key + '[1]', value[1], 'expressions are not allowed in function stops.')]);
        }
        return errors.concat(validate({
            key: key + '[1]',
            value: value[1],
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        }));
    }
    function validateStopDomainValue(options, stop) {
        var type = getType(options.value);
        var value = unbundle(options.value);
        var reportValue = options.value !== null ? options.value : stop;
        if (!stopKeyType) {
            stopKeyType = type;
        } else if (type !== stopKeyType) {
            return [new ValidationError(options.key, reportValue, type + ' stop domain type must match previous stop domain type ' + stopKeyType)];
        }
        if (type !== 'number' && type !== 'string' && type !== 'boolean') {
            return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];
        }
        if (type !== 'number' && functionType !== 'categorical') {
            var message = 'number expected, ' + type + ' found';
            if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {
                message += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.';
            }
            return [new ValidationError(options.key, reportValue, message)];
        }
        if (functionType === 'categorical' && type === 'number' && (!isFinite(value) || Math.floor(value) !== value)) {
            return [new ValidationError(options.key, reportValue, 'integer expected, found ' + value)];
        }
        if (functionType !== 'categorical' && type === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];
        } else {
            previousStopDomainValue = value;
        }
        if (functionType === 'categorical' && value in stopDomainValues) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];
        } else {
            stopDomainValues[value] = true;
        }
        return [];
    }
    function validateFunctionDefault(options) {
        return validate({
            key: options.key,
            value: options.value,
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        });
    }
}

function validateExpression(options) {
    var expression = (options.expressionContext === 'property' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);
    if (expression.result === 'error') {
        return expression.value.map(function (error) {
            return new ValidationError('' + options.key + error.key, options.value, error.message);
        });
    }
    var expressionObj = expression.value.expression || expression.value._styleExpression.expression;
    if (options.expressionContext === 'property' && options.propertyKey === 'text-font' && !expressionObj.outputDefined()) {
        return [new ValidationError(options.key, options.value, 'Invalid data expression for "' + options.propertyKey + '". Output values must be contained as literals within the expression.')];
    }
    if (options.expressionContext === 'property' && options.propertyType === 'layout' && !isStateConstant(expressionObj)) {
        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with layout properties.')];
    }
    if (options.expressionContext === 'filter' && !isStateConstant(expressionObj)) {
        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with filters.')];
    }
    if (options.expressionContext && options.expressionContext.indexOf('cluster') === 0) {
        if (!isGlobalPropertyConstant(expressionObj, ['zoom', 'feature-state'])) {
            return [new ValidationError(options.key, options.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
        }
        if (options.expressionContext === 'cluster-initial' && !isFeatureConstant(expressionObj)) {
            return [new ValidationError(options.key, options.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];
        }
    }
    return [];
}

function validateBoolean(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);
    if (type !== 'boolean') {
        return [new ValidationError(key, value, 'boolean expected, ' + type + ' found')];
    }
    return [];
}

function validateColor(options) {
    var key = options.key;
    var value = options.value;
    var type = getType(value);
    if (type !== 'string') {
        return [new ValidationError(key, value, 'color expected, ' + type + ' found')];
    }
    if (csscolorparser_1(value) === null) {
        return [new ValidationError(key, value, 'color expected, "' + value + '" found')];
    }
    return [];
}

function validateEnum(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var errors = [];
    if (Array.isArray(valueSpec.values)) {
        if (valueSpec.values.indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, 'expected one of [' + valueSpec.values.join(', ') + '], ' + JSON.stringify(value) + ' found'));
        }
    } else {
        if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, 'expected one of [' + Object.keys(valueSpec.values).join(', ') + '], ' + JSON.stringify(value) + ' found'));
        }
    }
    return errors;
}

function validateFilter(options) {
    if (isExpressionFilter(deepUnbundle(options.value))) {
        return validateExpression(extend({}, options, {
            expressionContext: 'filter',
            valueSpec: { value: 'boolean' }
        }));
    } else {
        return validateNonExpressionFilter(options);
    }
}
function validateNonExpressionFilter(options) {
    var value = options.value;
    var key = options.key;
    if (getType(value) !== 'array') {
        return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];
    }
    var styleSpec = options.styleSpec;
    var type;
    var errors = [];
    if (value.length < 1) {
        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
    }
    errors = errors.concat(validateEnum({
        key: key + '[0]',
        value: value[0],
        valueSpec: styleSpec.filter_operator,
        style: options.style,
        styleSpec: options.styleSpec
    }));
    switch (unbundle(value[0])) {
        case '<':
        case '<=':
        case '>':
        case '>=':
            if (value.length >= 2 && unbundle(value[1]) === '$type') {
                errors.push(new ValidationError(key, value, '"$type" cannot be use with operator "' + value[0] + '"'));
            }
        case '==':
        case '!=':
            if (value.length !== 3) {
                errors.push(new ValidationError(key, value, 'filter array for operator "' + value[0] + '" must have 3 elements'));
            }
        case 'in':
        case '!in':
            if (value.length >= 2) {
                type = getType(value[1]);
                if (type !== 'string') {
                    errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));
                }
            }
            for (var i = 2; i < value.length; i++) {
                type = getType(value[i]);
                if (unbundle(value[1]) === '$type') {
                    errors = errors.concat(validateEnum({
                        key: key + '[' + i + ']',
                        value: value[i],
                        valueSpec: styleSpec.geometry_type,
                        style: options.style,
                        styleSpec: options.styleSpec
                    }));
                } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'string, number, or boolean expected, ' + type + ' found'));
                }
            }
            break;
        case 'any':
        case 'all':
        case 'none':
            for (var i$1 = 1; i$1 < value.length; i$1++) {
                errors = errors.concat(validateNonExpressionFilter({
                    key: key + '[' + i$1 + ']',
                    value: value[i$1],
                    style: options.style,
                    styleSpec: options.styleSpec
                }));
            }
            break;
        case 'has':
        case '!has':
            type = getType(value[1]);
            if (value.length !== 2) {
                errors.push(new ValidationError(key, value, 'filter array for "' + value[0] + '" operator must have 2 elements'));
            } else if (type !== 'string') {
                errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));
            }
            break;
    }
    return errors;
}

function validateProperty(options, propertyType) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec[propertyType + '_' + options.layerType];
    if (!layerSpec) {
        return [];
    }
    var transitionMatch = propertyKey.match(/^(.*)-transition$/);
    if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
        return validate({
            key: key,
            value: value,
            valueSpec: styleSpec.transition,
            style: style,
            styleSpec: styleSpec
        });
    }
    var valueSpec = options.valueSpec || layerSpec[propertyKey];
    if (!valueSpec) {
        return [new ValidationError(key, value, 'unknown property "' + propertyKey + '"')];
    }
    var tokenMatch;
    if (getType(value) === 'string' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {
        return [new ValidationError(key, value, '"' + propertyKey + '" does not support interpolation syntax\n' + 'Use an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(tokenMatch[1]) + ' }`.')];
    }
    var errors = [];
    if (options.layerType === 'symbol') {
        if (propertyKey === 'text-field' && style && !style.glyphs) {
            errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
        }
        if (propertyKey === 'text-font' && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === 'identity') {
            errors.push(new ValidationError(key, value, '"text-font" does not support identity functions'));
        }
    }
    return errors.concat(validate({
        key: options.key,
        value: value,
        valueSpec: valueSpec,
        style: style,
        styleSpec: styleSpec,
        expressionContext: 'property',
        propertyType: propertyType,
        propertyKey: propertyKey
    }));
}

function validatePaintProperty(options) {
    return validateProperty(options, 'paint');
}

function validateLayoutProperty(options) {
    return validateProperty(options, 'layout');
}

function validateLayer(options) {
    var errors = [];
    var layer = options.value;
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    if (!layer.type && !layer.ref) {
        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
    }
    var type = unbundle(layer.type);
    var ref = unbundle(layer.ref);
    if (layer.id) {
        var layerId = unbundle(layer.id);
        for (var i = 0; i < options.arrayIndex; i++) {
            var otherLayer = style.layers[i];
            if (unbundle(otherLayer.id) === layerId) {
                errors.push(new ValidationError(key, layer.id, 'duplicate layer id "' + layer.id + '", previously used at line ' + otherLayer.id.__line__));
            }
        }
    }
    if ('ref' in layer) {
        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
            if (p in layer) {
                errors.push(new ValidationError(key, layer[p], '"' + p + '" is prohibited for ref layers'));
            }
        });
        var parent;
        style.layers.forEach(function (layer) {
            if (unbundle(layer.id) === ref) {
                parent = layer;
            }
        });
        if (!parent) {
            errors.push(new ValidationError(key, layer.ref, 'ref layer "' + ref + '" not found'));
        } else if (parent.ref) {
            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
        } else {
            type = unbundle(parent.type);
        }
    } else if (type !== 'background') {
        if (!layer.source) {
            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
        } else {
            var source = style.sources && style.sources[layer.source];
            var sourceType = source && unbundle(source.type);
            if (!source) {
                errors.push(new ValidationError(key, layer.source, 'source "' + layer.source + '" not found'));
            } else if (sourceType === 'vector' && type === 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "' + layer.id + '" requires a raster source'));
            } else if (sourceType === 'raster' && type !== 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "' + layer.id + '" requires a vector source'));
            } else if (sourceType === 'vector' && !layer['source-layer']) {
                errors.push(new ValidationError(key, layer, 'layer "' + layer.id + '" must specify a "source-layer"'));
            } else if (sourceType === 'raster-dem' && type !== 'hillshade') {
                errors.push(new ValidationError(key, layer.source, 'raster-dem source can only be used with layer type \'hillshade\'.'));
            } else if (type === 'line' && layer.paint && layer.paint['line-gradient'] && (sourceType !== 'geojson' || !source.lineMetrics)) {
                errors.push(new ValidationError(key, layer, 'layer "' + layer.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'));
            }
        }
    }
    errors = errors.concat(validateObject({
        key: key,
        value: layer,
        valueSpec: styleSpec.layer,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            '*': function _() {
                return [];
            },
            type: function type() {
                return validate({
                    key: key + '.type',
                    value: layer.type,
                    valueSpec: styleSpec.layer.type,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    object: layer,
                    objectKey: 'type'
                });
            },
            filter: validateFilter,
            layout: function layout(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function _(options) {
                            return validateLayoutProperty(extend({ layerType: type }, options));
                        }
                    }
                });
            },
            paint: function paint(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function _(options) {
                            return validatePaintProperty(extend({ layerType: type }, options));
                        }
                    }
                });
            }
        }
    }));
    return errors;
}

function validateString(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);
    if (type !== 'string') {
        return [new ValidationError(key, value, 'string expected, ' + type + ' found')];
    }
    return [];
}

var objectElementValidators = { promoteId: validatePromoteId };
function validateSource(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;
    if (!value.type) {
        return [new ValidationError(key, value, '"type" is required')];
    }
    var type = unbundle(value.type);
    var errors;
    switch (type) {
        case 'vector':
        case 'raster':
        case 'raster-dem':
            errors = validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec['source_' + type.replace('-', '_')],
                style: options.style,
                styleSpec: styleSpec,
                objectElementValidators: objectElementValidators
            });
            return errors;
        case 'geojson':
            errors = validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_geojson,
                style: style,
                styleSpec: styleSpec,
                objectElementValidators: objectElementValidators
            });
            if (value.cluster) {
                for (var prop in value.clusterProperties) {
                    var ref = value.clusterProperties[prop];
                    var operator = ref[0];
                    var mapExpr = ref[1];
                    var reduceExpr = typeof operator === 'string' ? [operator, ['accumulated'], ['get', prop]] : operator;
                    errors.push.apply(errors, validateExpression({
                        key: key + '.' + prop + '.map',
                        value: mapExpr,
                        expressionContext: 'cluster-map'
                    }));
                    errors.push.apply(errors, validateExpression({
                        key: key + '.' + prop + '.reduce',
                        value: reduceExpr,
                        expressionContext: 'cluster-reduce'
                    }));
                }
            }
            return errors;
        case 'video':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_video,
                style: style,
                styleSpec: styleSpec
            });
        case 'image':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_image,
                style: style,
                styleSpec: styleSpec
            });
        case 'canvas':
            return [new ValidationError(key, null, 'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.', 'source.canvas')];
        default:
            return validateEnum({
                key: key + '.type',
                value: value.type,
                valueSpec: {
                    values: ['vector', 'raster', 'raster-dem', 'geojson', 'video', 'image']
                },
                style: style,
                styleSpec: styleSpec
            });
    }
}
function validatePromoteId(ref) {
    var key = ref.key;
    var value = ref.value;
    if (getType(value) === 'string') {
        return validateString({
            key: key,
            value: value
        });
    } else {
        var errors = [];
        for (var prop in value) {
            errors.push.apply(errors, validateString({
                key: key + '.' + prop,
                value: value[prop]
            }));
        }
        return errors;
    }
}

function validateLight(options) {
    var light = options.value;
    var styleSpec = options.styleSpec;
    var lightSpec = styleSpec.light;
    var style = options.style;
    var errors = [];
    var rootType = getType(light);
    if (light === undefined) {
        return errors;
    } else if (rootType !== 'object') {
        errors = errors.concat([new ValidationError('light', light, 'object expected, ' + rootType + ' found')]);
        return errors;
    }
    for (var key in light) {
        var transitionMatch = key.match(/^(.*)-transition$/);
        if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: styleSpec.transition,
                style: style,
                styleSpec: styleSpec
            }));
        } else if (lightSpec[key]) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: lightSpec[key],
                style: style,
                styleSpec: styleSpec
            }));
        } else {
            errors = errors.concat([new ValidationError(key, light[key], 'unknown property "' + key + '"')]);
        }
    }
    return errors;
}

function validateFormatted(options) {
    if (validateString(options).length === 0) {
        return [];
    }
    return validateExpression(options);
}

function validateImage(options) {
    if (validateString(options).length === 0) {
        return [];
    }
    return validateExpression(options);
}

var VALIDATORS = {
    '*': function _() {
        return [];
    },
    'array': validateArray,
    'boolean': validateBoolean,
    'number': validateNumber,
    'color': validateColor,
    'constants': validateConstants,
    'enum': validateEnum,
    'filter': validateFilter,
    'function': validateFunction,
    'layer': validateLayer,
    'object': validateObject,
    'source': validateSource,
    'light': validateLight,
    'string': validateString,
    'formatted': validateFormatted,
    'resolvedImage': validateImage
};
function validate(options) {
    var value = options.value;
    var valueSpec = options.valueSpec;
    var styleSpec = options.styleSpec;
    if (valueSpec.expression && isFunction$1(unbundle(value))) {
        return validateFunction(options);
    } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {
        return validateExpression(options);
    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
        return VALIDATORS[valueSpec.type](options);
    } else {
        var valid = validateObject(extend({}, options, { valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec }));
        return valid;
    }
}

function validateGlyphsURL(options) {
    var value = options.value;
    var key = options.key;
    var errors = validateString(options);
    if (errors.length) {
        return errors;
    }
    if (value.indexOf('{fontstack}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
    }
    if (value.indexOf('{range}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
    }
    return errors;
}

function validateStyleMin(style, styleSpec) {
    if (styleSpec === void 0) styleSpec = v8;
    var errors = [];
    errors = errors.concat(validate({
        key: '',
        value: style,
        valueSpec: styleSpec.$root,
        styleSpec: styleSpec,
        style: style,
        objectElementValidators: {
            glyphs: validateGlyphsURL,
            '*': function _() {
                return [];
            }
        }
    }));
    if (style.constants) {
        errors = errors.concat(validateConstants({
            key: 'constants',
            value: style.constants,
            style: style,
            styleSpec: styleSpec
        }));
    }
    return sortErrors(errors);
}
validateStyleMin.source = wrapCleanErrors(validateSource);
validateStyleMin.light = wrapCleanErrors(validateLight);
validateStyleMin.layer = wrapCleanErrors(validateLayer);
validateStyleMin.filter = wrapCleanErrors(validateFilter);
validateStyleMin.paintProperty = wrapCleanErrors(validatePaintProperty);
validateStyleMin.layoutProperty = wrapCleanErrors(validateLayoutProperty);
function sortErrors(errors) {
    return [].concat(errors).sort(function (a, b) {
        return a.line - b.line;
    });
}
function wrapCleanErrors(inner) {
    return function () {
        var args = [],
            len = arguments.length;
        while (len--) {
            args[len] = arguments[len];
        }return sortErrors(inner.apply(this, args));
    };
}

var jsonlint = createCommonjsModule(function (module, exports) {
    /* parser generated by jison 0.4.15 */
    /*
      Returns a Parser object of the following structure:
    
      Parser: {
        yy: {}
      }
    
      Parser.prototype: {
        yy: {},
        trace: function(),
        symbols_: {associative list: name ==> number},
        terminals_: {associative list: number ==> name},
        productions_: [...],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
        table: [...],
        defaultActions: {...},
        parseError: function(str, hash),
        parse: function(input),
    
        lexer: {
            EOF: 1,
            parseError: function(str, hash),
            setInput: function(input),
            input: function(),
            unput: function(str),
            more: function(),
            less: function(n),
            pastInput: function(),
            upcomingInput: function(),
            showPosition: function(),
            test_match: function(regex_match_array, rule_index),
            next: function(),
            lex: function(),
            begin: function(condition),
            popState: function(),
            _currentRules: function(),
            topState: function(),
            pushState: function(condition),
    
            options: {
                ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
            },
    
            performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
            rules: [...],
            conditions: {associative list: name ==> set},
        }
      }
    
    
      token location info (@$, _$, etc.): {
        first_line: n,
        last_line: n,
        first_column: n,
        last_column: n,
        range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
      }
    
    
      the parseError function receives a 'hash' object with these members for lexer and parser errors: {
        text:        (matched text)
        token:       (the produced terminal token, if any)
        line:        (yylineno)
      }
      while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
        loc:         (yylloc)
        expected:    (string describing the set of expected tokens)
        recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
      }
    */
    var parser = function () {
        var o = function o(k, v, _o, l) {
            for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {}return _o;
        },
            $V0 = [1, 12],
            $V1 = [1, 13],
            $V2 = [1, 9],
            $V3 = [1, 10],
            $V4 = [1, 11],
            $V5 = [1, 14],
            $V6 = [1, 15],
            $V7 = [14, 18, 22, 24],
            $V8 = [18, 22],
            $V9 = [22, 24];
        var parser = { trace: function trace() {},
            yy: {},
            symbols_: { "error": 2, "JSONString": 3, "STRING": 4, "JSONNumber": 5, "NUMBER": 6, "JSONNullLiteral": 7, "NULL": 8, "JSONBooleanLiteral": 9, "TRUE": 10, "FALSE": 11, "JSONText": 12, "JSONValue": 13, "EOF": 14, "JSONObject": 15, "JSONArray": 16, "{": 17, "}": 18, "JSONMemberList": 19, "JSONMember": 20, ":": 21, ",": 22, "[": 23, "]": 24, "JSONElementList": 25, "$accept": 0, "$end": 1 },
            terminals_: { 2: "error", 4: "STRING", 6: "NUMBER", 8: "NULL", 10: "TRUE", 11: "FALSE", 14: "EOF", 17: "{", 18: "}", 21: ":", 22: ",", 23: "[", 24: "]" },
            productions_: [0, [3, 1], [5, 1], [7, 1], [9, 1], [9, 1], [12, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [15, 2], [15, 3], [20, 3], [19, 1], [19, 3], [16, 2], [16, 3], [25, 1], [25, 3]],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
                /* this == yyval */

                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1:
                        // replace escaped characters with actual character
                        this.$ = new String(yytext.replace(/\\(\\|")/g, "$" + "1").replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\v/g, '\v').replace(/\\f/g, '\f').replace(/\\b/g, '\b'));
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 2:

                        this.$ = new Number(yytext);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 3:

                        this.$ = null;

                        break;
                    case 4:

                        this.$ = new Boolean(true);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 5:

                        this.$ = new Boolean(false);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 6:
                        return this.$ = $$[$0 - 1];
                    case 13:
                        this.$ = {};Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 14:case 19:
                        this.$ = $$[$0 - 1];Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 15:
                        this.$ = [$$[$0 - 2], $$[$0]];
                        break;
                    case 16:
                        this.$ = {};this.$[$$[$0][0]] = $$[$0][1];
                        break;
                    case 17:
                        this.$ = $$[$0 - 2];$$[$0 - 2][$$[$0][0]] = $$[$0][1];
                        break;
                    case 18:
                        this.$ = [];Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 20:
                        this.$ = [$$[$0]];
                        break;
                    case 21:
                        this.$ = $$[$0 - 2];$$[$0 - 2].push($$[$0]);
                        break;
                }
            },
            table: [{ 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 12: 1, 13: 2, 15: 7, 16: 8, 17: $V5, 23: $V6 }, { 1: [3] }, { 14: [1, 16] }, o($V7, [2, 7]), o($V7, [2, 8]), o($V7, [2, 9]), o($V7, [2, 10]), o($V7, [2, 11]), o($V7, [2, 12]), o($V7, [2, 3]), o($V7, [2, 4]), o($V7, [2, 5]), o([14, 18, 21, 22, 24], [2, 1]), o($V7, [2, 2]), { 3: 20, 4: $V0, 18: [1, 17], 19: 18, 20: 19 }, { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 23, 15: 7, 16: 8, 17: $V5, 23: $V6, 24: [1, 21], 25: 22 }, { 1: [2, 6] }, o($V7, [2, 13]), { 18: [1, 24], 22: [1, 25] }, o($V8, [2, 16]), { 21: [1, 26] }, o($V7, [2, 18]), { 22: [1, 28], 24: [1, 27] }, o($V9, [2, 20]), o($V7, [2, 14]), { 3: 20, 4: $V0, 20: 29 }, { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 30, 15: 7, 16: 8, 17: $V5, 23: $V6 }, o($V7, [2, 19]), { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 31, 15: 7, 16: 8, 17: $V5, 23: $V6 }, o($V8, [2, 17]), o($V8, [2, 15]), o($V9, [2, 21])],
            defaultActions: { 16: [2, 6] },
            parseError: function parseError(str, hash) {
                if (hash.recoverable) {
                    this.trace(str);
                } else {
                    throw new Error(str);
                }
            },
            parse: function parse(input) {
                var self = this,
                    stack = [0],
                    vstack = [null],
                    lstack = [],
                    table = this.table,
                    yytext = '',
                    yylineno = 0,
                    yyleng = 0,
                    TERROR = 2,
                    EOF = 1;
                var args = lstack.slice.call(arguments, 1);
                var lexer = Object.create(this.lexer);
                var sharedState = { yy: {} };
                for (var k in this.yy) {
                    if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                        sharedState.yy[k] = this.yy[k];
                    }
                }
                lexer.setInput(input, sharedState.yy);
                sharedState.yy.lexer = lexer;
                sharedState.yy.parser = this;
                if (typeof lexer.yylloc == 'undefined') {
                    lexer.yylloc = {};
                }
                var yyloc = lexer.yylloc;
                lstack.push(yyloc);
                var ranges = lexer.options && lexer.options.ranges;
                if (typeof sharedState.yy.parseError === 'function') {
                    this.parseError = sharedState.yy.parseError;
                } else {
                    this.parseError = Object.getPrototypeOf(this).parseError;
                }

                function lex() {
                    var token;
                    token = lexer.lex() || EOF;
                    if (typeof token !== 'number') {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                }
                var symbol,
                    state,
                    action,
                    r,
                    yyval = {},
                    p,
                    len,
                    newState,
                    expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    } else {
                        if (symbol === null || typeof symbol == 'undefined') {
                            symbol = lex();
                        }
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                        var errStr = '';
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push('\'' + this.terminals_[p] + '\'');
                            }
                        }
                        if (lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                        } else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                        }
                        this.parseError(errStr, {
                            text: lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: lexer.yylineno,
                            loc: yyloc,
                            expected: expected
                        });
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(lexer.yytext);
                            lstack.push(lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            {
                                yyleng = lexer.yyleng;
                                yytext = lexer.yytext;
                                yylineno = lexer.yylineno;
                                yyloc = lexer.yylloc;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = {
                                first_line: lstack[lstack.length - (len || 1)].first_line,
                                last_line: lstack[lstack.length - 1].last_line,
                                first_column: lstack[lstack.length - (len || 1)].first_column,
                                last_column: lstack[lstack.length - 1].last_column
                            };
                            if (ranges) {
                                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                            }
                            r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
                            if (typeof r !== 'undefined') {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            } };
        /* generated by jison-lex 0.3.4 */
        var lexer = function () {
            var lexer = {

                EOF: 1,

                parseError: function parseError(str, hash) {
                    if (this.yy.parser) {
                        this.yy.parser.parseError(str, hash);
                    } else {
                        throw new Error(str);
                    }
                },

                // resets the lexer, sets new input
                setInput: function setInput(input, yy) {
                    this.yy = yy || this.yy || {};
                    this._input = input;
                    this._more = this._backtrack = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = '';
                    this.conditionStack = ['INITIAL'];
                    this.yylloc = {
                        first_line: 1,
                        first_column: 0,
                        last_line: 1,
                        last_column: 0
                    };
                    if (this.options.ranges) {
                        this.yylloc.range = [0, 0];
                    }
                    this.offset = 0;
                    return this;
                },

                // consumes and returns one char from the input
                input: function input() {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno++;
                        this.yylloc.last_line++;
                    } else {
                        this.yylloc.last_column++;
                    }
                    if (this.options.ranges) {
                        this.yylloc.range[1]++;
                    }

                    this._input = this._input.slice(1);
                    return ch;
                },

                // unshifts one char (or a string) into the input
                unput: function unput(ch) {
                    var len = ch.length;
                    var lines = ch.split(/(?:\r\n?|\n)/g);

                    this._input = ch + this._input;
                    this.yytext = this.yytext.substr(0, this.yytext.length - len);
                    //this.yyleng -= len;
                    this.offset -= len;
                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                    this.match = this.match.substr(0, this.match.length - 1);
                    this.matched = this.matched.substr(0, this.matched.length - 1);

                    if (lines.length - 1) {
                        this.yylineno -= lines.length - 1;
                    }
                    var r = this.yylloc.range;

                    this.yylloc = {
                        first_line: this.yylloc.first_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.first_column,
                        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                    };

                    if (this.options.ranges) {
                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                    }
                    this.yyleng = this.yytext.length;
                    return this;
                },

                // When called from action, caches matched text and appends it on next action
                more: function more() {
                    this._more = true;
                    return this;
                },

                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function reject() {
                    if (this.options.backtrack_lexer) {
                        this._backtrack = true;
                    } else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                    return this;
                },

                // retain first n characters of the match
                less: function less(n) {
                    this.unput(this.match.slice(n));
                },

                // displays already matched input, i.e. for error messages
                pastInput: function pastInput() {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                },

                // displays upcoming input, i.e. for error messages
                upcomingInput: function upcomingInput() {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length);
                    }
                    return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                },

                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function showPosition() {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^";
                },

                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function test_match(match, indexed_rule) {
                    var token, lines, backup;

                    if (this.options.backtrack_lexer) {
                        // save context
                        backup = {
                            yylineno: this.yylineno,
                            yylloc: {
                                first_line: this.yylloc.first_line,
                                last_line: this.last_line,
                                first_column: this.yylloc.first_column,
                                last_column: this.yylloc.last_column
                            },
                            yytext: this.yytext,
                            match: this.match,
                            matches: this.matches,
                            matched: this.matched,
                            yyleng: this.yyleng,
                            offset: this.offset,
                            _more: this._more,
                            _input: this._input,
                            yy: this.yy,
                            conditionStack: this.conditionStack.slice(0),
                            done: this.done
                        };
                        if (this.options.ranges) {
                            backup.yylloc.range = this.yylloc.range.slice(0);
                        }
                    }

                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno += lines.length;
                    }
                    this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                    };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._backtrack = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                    if (this.done && this._input) {
                        this.done = false;
                    }
                    if (token) {
                        return token;
                    } else if (this._backtrack) {
                        // recover context
                        for (var k in backup) {
                            this[k] = backup[k];
                        }
                        return false; // rule action called reject() implying the next rule should be tested instead.
                    }
                    return false;
                },

                // return next match in input
                next: function next() {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input) {
                        this.done = true;
                    }

                    var token, match, tempMatch, index;
                    if (!this._more) {
                        this.yytext = '';
                        this.match = '';
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        tempMatch = this._input.match(this.rules[rules[i]]);
                        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                            match = tempMatch;
                            index = i;
                            if (this.options.backtrack_lexer) {
                                token = this.test_match(tempMatch, rules[i]);
                                if (token !== false) {
                                    return token;
                                } else if (this._backtrack) {
                                    match = false;
                                    continue; // rule action called reject() implying a rule MISmatch.
                                } else {
                                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                    return false;
                                }
                            } else if (!this.options.flex) {
                                break;
                            }
                        }
                    }
                    if (match) {
                        token = this.test_match(match, rules[index]);
                        if (token !== false) {
                            return token;
                        }
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                    if (this._input === "") {
                        return this.EOF;
                    } else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                },

                // return next match that has a token
                lex: function lex() {
                    var r = this.next();
                    if (r) {
                        return r;
                    } else {
                        return this.lex();
                    }
                },

                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function begin(condition) {
                    this.conditionStack.push(condition);
                },

                // pop the previously active lexer condition state off the condition stack
                popState: function popState() {
                    var n = this.conditionStack.length - 1;
                    if (n > 0) {
                        return this.conditionStack.pop();
                    } else {
                        return this.conditionStack[0];
                    }
                },

                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function _currentRules() {
                    if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                    } else {
                        return this.conditions["INITIAL"].rules;
                    }
                },

                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function topState(n) {
                    n = this.conditionStack.length - 1 - Math.abs(n || 0);
                    if (n >= 0) {
                        return this.conditionStack[n];
                    } else {
                        return "INITIAL";
                    }
                },

                // alias for begin(condition)
                pushState: function pushState(condition) {
                    this.begin(condition);
                },

                // return the number of states currently on the stack
                stateStackSize: function stateStackSize() {
                    return this.conditionStack.length;
                },
                options: {},
                performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                    switch ($avoiding_name_collisions) {
                        case 0:
                            /* skip whitespace */
                            break;
                        case 1:
                            return 6;
                        case 2:
                            yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);return 4;
                        case 3:
                            return 17;
                        case 4:
                            return 18;
                        case 5:
                            return 23;
                        case 6:
                            return 24;
                        case 7:
                            return 22;
                        case 8:
                            return 21;
                        case 9:
                            return 10;
                        case 10:
                            return 11;
                        case 11:
                            return 8;
                        case 12:
                            return 14;
                        case 13:
                            return 'INVALID';
                    }
                },
                rules: [/^(?:\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/, /^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/, /^(?:\{)/, /^(?:\})/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?::)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:$)/, /^(?:.)/],
                conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "inclusive": true } }
            };
            return lexer;
        }();
        parser.lexer = lexer;
        function Parser() {
            this.yy = {};
        }
        Parser.prototype = parser;parser.Parser = Parser;
        return new Parser();
    }();

    if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
        exports.parser = parser;
        exports.Parser = parser.Parser;
        exports.parse = function () {
            return parser.parse.apply(parser, arguments);
        };
    }
});
var jsonlint_1 = jsonlint.parser;
var jsonlint_2 = jsonlint.Parser;
var jsonlint_3 = jsonlint.parse;

function readStyle(style) {
    if (style instanceof String || typeof style === 'string' || style instanceof Buffer) {
        try {
            return jsonlint.parse(style.toString());
        } catch (e) {
            throw new ParsingError$1(e);
        }
    }
    return style;
}

function validateStyle(style, styleSpec) {
    if (styleSpec === void 0) styleSpec = v8;
    var s = style;
    try {
        s = readStyle(s);
    } catch (e) {
        return [e];
    }
    return validateStyleMin(s, styleSpec);
}

var SUPPORTED_SPEC_VERSION = 8;
var MAX_SOURCES_IN_STYLE = 15;
function isValid(value, regex) {
    if (!value || getType(value) !== 'string') {
        return true;
    }
    return !!value.match(regex);
}
function getSourceCount(source) {
    if (source.url) {
        return source.url.split(',').length;
    } else {
        return 0;
    }
}
function getAllowedKeyErrors(obj, keys, path) {
    var allowed = new Set(keys);
    var errors = [];
    Object.keys(obj).forEach(function (k) {
        if (!allowed.has(k)) {
            var prop = path ? path + '.' + k : null;
            errors.push(new ValidationError(prop, obj[k], 'Unsupported property "' + k + '"'));
        }
    });
    return errors;
}
function getSourceErrors(source, i) {
    var errors = [];
    var sourceKeys = ['type', 'url', 'tileSize'];
    errors.push.apply(errors, getAllowedKeyErrors(source, sourceKeys, 'source'));
    var sourceUrlPattern = /^mapbox:\/\/([^/]*)$/;
    if (!isValid(source.url, sourceUrlPattern)) {
        errors.push(new ValidationError('sources[' + i + ']', source.url, 'Source url must be a valid Mapbox tileset url'));
    }
    return errors;
}
function getSourcesErrors(sources) {
    var errors = [];
    var count = 0;
    Object.keys(sources).forEach(function (s, i) {
        var sourceErrors = getSourceErrors(sources[s], i);
        if (!sourceErrors.length) {
            count = count + getSourceCount(sources[s]);
        }
        errors.push.apply(errors, sourceErrors);
    });
    if (count > MAX_SOURCES_IN_STYLE) {
        errors.push(new ValidationError('sources', null, 'Styles must contain ' + MAX_SOURCES_IN_STYLE + ' or fewer sources'));
    }
    return errors;
}
function getRootErrors(style, specKeys) {
    var errors = [];
    var optionalRootProperties = ['owner', 'id', 'cacheControl', 'draft', 'created', 'modified', 'visibility'];
    var allowedKeyErrors = getAllowedKeyErrors(style, specKeys.concat(optionalRootProperties));
    errors.push.apply(errors, allowedKeyErrors);
    if (style.version > SUPPORTED_SPEC_VERSION || style.version < SUPPORTED_SPEC_VERSION) {
        errors.push(new ValidationError('version', style.version, 'Style version must be ' + SUPPORTED_SPEC_VERSION));
    }
    var glyphUrlPattern = /^mapbox:\/\/fonts\/([^/]*)\/{fontstack}\/{range}.pbf$/;
    if (!isValid(style.glyphs, glyphUrlPattern)) {
        errors.push(new ValidationError('glyphs', style.glyphs, 'Styles must reference glyphs hosted by Mapbox'));
    }
    var spriteUrlPattern = /^mapbox:\/\/sprites\/([^/]*)\/([^/]*)\/?([^/]*)?$/;
    if (!isValid(style.sprite, spriteUrlPattern)) {
        errors.push(new ValidationError('sprite', style.sprite, 'Styles must reference sprites hosted by Mapbox'));
    }
    var visibilityPattern = /^(public|private)$/;
    if (!isValid(style.visibility, visibilityPattern)) {
        errors.push(new ValidationError('visibility', style.visibility, 'Style visibility must be public or private'));
    }
    return errors;
}
function validateMapboxApiSupported(style) {
    var s = style;
    try {
        s = readStyle(s);
    } catch (e) {
        return [e];
    }
    var errors = validateStyleMin(s, v8).concat(getRootErrors(s, Object.keys(v8.$root)));
    if (s.sources) {
        errors = errors.concat(getSourcesErrors(s.sources));
    }
    return errors;
}

var expression$1 = {
    StyleExpression: StyleExpression,
    isExpression: isExpression,
    isExpressionFilter: isExpressionFilter,
    createExpression: createExpression,
    createPropertyExpression: createPropertyExpression,
    normalizePropertyExpression: normalizePropertyExpression,
    ZoomConstantExpression: ZoomConstantExpression,
    ZoomDependentExpression: ZoomDependentExpression,
    StylePropertyFunction: StylePropertyFunction
};
var styleFunction = {
    convertFunction: convertFunction,
    createFunction: createFunction,
    isFunction: isFunction$1
};
var visit = {
    eachSource: eachSource,
    eachLayer: eachLayer,
    eachProperty: eachProperty
};
validateStyle.parsed = validateStyle;
validateStyle.latest = validateStyle;

exports.Color = Color;
exports.ParsingError = ParsingError$1;
exports.ValidationError = ValidationError;
exports.composite = composite;
exports.convertFilter = convertFilter$1;
exports.derefLayers = derefLayers;
exports.diff = diffStyles;
exports.expression = expression$1;
exports.featureFilter = createFilter;
exports.format = format;
exports.function = styleFunction;
exports.latest = v8;
exports.migrate = migrate;
exports.v8 = v8;
exports.validate = validateStyle;
exports.validateMapboxApiSupported = validateMapboxApiSupported;
exports.visit = visit;
//# sourceMappingURL=index.es.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "./node_modules/mapbox-to-css-font/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mapbox-to-css-font/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fontWeights = {
  thin: 100,
  hairline: 100,
  'ultra-light': 100,
  'extra-light': 100,
  light: 200,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  'semi-bold': 600,
  'demi-bold': 600,
  bold: 700,
  heavy: 800,
  black: 800,
  'extra-bold': 800,
  'ultra-black': 900,
  'extra-black': 900,
  'ultra-bold': 900,
  'heavy-black': 900,
  fat: 900,
  poster: 900
};
var sp = ' ';
var italicRE = /(italic|oblique)$/i;

var fontCache = {};

module.exports = function (fonts, size, lineHeight) {
  var cssData = fontCache[fonts];
  if (!cssData) {
    if (!Array.isArray(fonts)) {
      fonts = [fonts];
    }
    var weight = 400;
    var style = 'normal';
    var fontFamilies = [];
    var haveWeight, haveStyle;
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      var parts = font.split(' ');
      var maybeWeight = parts[parts.length - 1].toLowerCase();
      if (maybeWeight == 'normal' || maybeWeight == 'italic' || maybeWeight == 'oblique') {
        style = haveStyle ? style : maybeWeight;
        parts.pop();
        maybeWeight = parts[parts.length - 1].toLowerCase();
      } else if (italicRE.test(maybeWeight)) {
        maybeWeight = maybeWeight.replace(italicRE, '');
        style = haveStyle ? style : parts[parts.length - 1].replace(maybeWeight, '');
      }
      for (var w in fontWeights) {
        if (maybeWeight == w || maybeWeight == w.replace('-', '') || maybeWeight == w.replace('-', sp)) {
          weight = haveWeight ? weight : fontWeights[w];
          parts.pop();
          break;
        }
      }
      if (!haveWeight && typeof maybeWeight == 'number') {
        weight = maybeWeight;
      }
      var fontFamily = parts.join(sp).replace('Klokantech Noto Sans', 'Noto Sans');
      if (fontFamily.indexOf(sp) !== -1) {
        fontFamily = '"' + fontFamily + '"';
      }
      fontFamilies.push(fontFamily);
    }
    // CSS font property: font-style font-weight font-size/line-height font-family
    cssData = fontCache[fonts] = [style, weight, fontFamilies];
  }
  return cssData[0] + sp + cssData[1] + sp + size + 'px' + (lineHeight ? '/' + lineHeight : '') + sp + cssData[2];
};

/***/ }),

/***/ "./node_modules/ol/AssertionError.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/AssertionError.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
 * @constructor
 * @extends {Error}
 * @param {number} code Error code.
 */
var AssertionError = function AssertionError(code) {

  var path = _index.VERSION ? _index.VERSION.split('-')[0] : 'latest';

  /**
   * @type {string}
   */
  this.message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';

  /**
   * Error code. The meaning of the code can be found on
   * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with
   * the version found in the OpenLayers script's header comment if a version
   * other than the latest is used).
   * @type {number}
   * @api
   */
  this.code = code;

  this.name = 'AssertionError';
}; /**
    * @module ol/AssertionError
    */


(0, _index.inherits)(AssertionError, Error);

exports.default = AssertionError;

/***/ }),

/***/ "./node_modules/ol/Disposable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Disposable.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _functions = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");

/**
 * Objects that need to clean up after themselves.
 * @constructor
 */
var Disposable = function Disposable() {};

/**
 * The object has already been disposed.
 * @type {boolean}
 * @private
 */
/**
 * @module ol/Disposable
 */
Disposable.prototype.disposed_ = false;

/**
 * Clean up.
 */
Disposable.prototype.dispose = function () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};

/**
 * Extension point for disposable objects.
 * @protected
 */
Disposable.prototype.disposeInternal = _functions.UNDEFINED;
exports.default = Disposable;

/***/ }),

/***/ "./node_modules/ol/ImageTile.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageTile.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _Tile = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");

var _Tile2 = _interopRequireDefault(_Tile);

var _TileState = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _dom = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");

var _events = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");

var _EventType = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {function(new: module:ol/ImageTile, module:ol/tilecoord~TileCoord,
 * module:ol/TileState, string, ?string, module:ol/Tile~LoadFunction)} TileClass
 * @api
 */

/**
 * @constructor
 * @extends {module:ol/Tile}
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/TileState} state State.
 * @param {string} src Image source URI.
 * @param {?string} crossOrigin Cross origin.
 * @param {module:ol/Tile~LoadFunction} tileLoadFunction Tile load function.
 * @param {module:ol/Tile~Options=} opt_options Tile options.
 */
/**
 * @module ol/ImageTile
 */
var ImageTile = function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {

  _Tile2.default.call(this, tileCoord, state, opt_options);

  /**
   * @private
   * @type {?string}
   */
  this.crossOrigin_ = crossOrigin;

  /**
   * Image URI
   *
   * @private
   * @type {string}
   */
  this.src_ = src;

  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */
  this.image_ = new Image();
  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }

  /**
   * @private
   * @type {Array.<module:ol/events~EventsKey>}
   */
  this.imageListenerKeys_ = null;

  /**
   * @private
   * @type {module:ol/Tile~LoadFunction}
   */
  this.tileLoadFunction_ = tileLoadFunction;
};

(0, _index.inherits)(ImageTile, _Tile2.default);

/**
 * @inheritDoc
 */
ImageTile.prototype.disposeInternal = function () {
  if (this.state == _TileState2.default.LOADING) {
    this.unlistenImage_();
    this.image_ = getBlankImage();
  }
  if (this.interimTile) {
    this.interimTile.dispose();
  }
  this.state = _TileState2.default.ABORT;
  this.changed();
  _Tile2.default.prototype.disposeInternal.call(this);
};

/**
 * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
 * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
 * @api
 */
ImageTile.prototype.getImage = function () {
  return this.image_;
};

/**
 * @inheritDoc
 */
ImageTile.prototype.getKey = function () {
  return this.src_;
};

/**
 * Tracks loading or read errors.
 *
 * @private
 */
ImageTile.prototype.handleImageError_ = function () {
  this.state = _TileState2.default.ERROR;
  this.unlistenImage_();
  this.image_ = getBlankImage();
  this.changed();
};

/**
 * Tracks successful image load.
 *
 * @private
 */
ImageTile.prototype.handleImageLoad_ = function () {
  if (this.image_.naturalWidth && this.image_.naturalHeight) {
    this.state = _TileState2.default.LOADED;
  } else {
    this.state = _TileState2.default.EMPTY;
  }
  this.unlistenImage_();
  this.changed();
};

/**
 * @inheritDoc
 * @api
 */
ImageTile.prototype.load = function () {
  if (this.state == _TileState2.default.ERROR) {
    this.state = _TileState2.default.IDLE;
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }
  if (this.state == _TileState2.default.IDLE) {
    this.state = _TileState2.default.LOADING;
    this.changed();
    this.imageListenerKeys_ = [(0, _events.listenOnce)(this.image_, _EventType2.default.ERROR, this.handleImageError_, this), (0, _events.listenOnce)(this.image_, _EventType2.default.LOAD, this.handleImageLoad_, this)];
    this.tileLoadFunction_(this, this.src_);
  }
};

/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */
ImageTile.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(_events.unlistenByKey);
  this.imageListenerKeys_ = null;
};

/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
  var ctx = (0, _dom.createCanvasContext2D)(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

exports.default = ImageTile;

/***/ }),

/***/ "./node_modules/ol/Object.js":
/*!***********************************!*\
  !*** ./node_modules/ol/Object.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getChangeEventType = getChangeEventType;

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _ObjectEventType = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");

var _ObjectEventType2 = _interopRequireDefault(_ObjectEventType);

var _Observable = __webpack_require__(/*! ./Observable.js */ "./node_modules/ol/Observable.js");

var _Observable2 = _interopRequireDefault(_Observable);

var _Event = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");

var _Event2 = _interopRequireDefault(_Event);

var _obj = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of
 * this type.
 *
 * @param {string} type The event type.
 * @param {string} key The property name.
 * @param {*} oldValue The old value for `key`.
 * @extends {module:ol/events/Event}
 * @constructor
 */
var ObjectEvent = function ObjectEvent(type, key, oldValue) {
  _Event2.default.call(this, type);

  /**
   * The name of the property whose value is changing.
   * @type {string}
   * @api
   */
  this.key = key;

  /**
   * The old value. To get the new value use `e.target.get(e.key)` where
   * `e` is the event object.
   * @type {*}
   * @api
   */
  this.oldValue = oldValue;
}; /**
    * @module ol/Object
    */

(0, _index.inherits)(ObjectEvent, _Event2.default);

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @constructor
 * @extends {module:ol/Observable}
 * @param {Object.<string, *>=} opt_values An object with key-value pairs.
 * @fires module:ol/Object~ObjectEvent
 * @api
 */
var BaseObject = function BaseObject(opt_values) {
  _Observable2.default.call(this);

  // Call {@link module:ol~getUid} to ensure that the order of objects' ids is
  // the same as the order in which they were created.  This also helps to
  // ensure that object properties are always added in the same order, which
  // helps many JavaScript engines generate faster code.
  (0, _index.getUid)(this);

  /**
   * @private
   * @type {!Object.<string, *>}
   */
  this.values_ = {};

  if (opt_values !== undefined) {
    this.setProperties(opt_values);
  }
};

(0, _index.inherits)(BaseObject, _Observable2.default);

/**
 * @type {Object.<string, string>}
 */
var changeEventTypeCache = {};

/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */
function getChangeEventType(key) {
  return changeEventTypeCache.hasOwnProperty(key) ? changeEventTypeCache[key] : changeEventTypeCache[key] = 'change:' + key;
}

/**
 * Gets a value.
 * @param {string} key Key name.
 * @return {*} Value.
 * @api
 */
BaseObject.prototype.get = function (key) {
  var value = void 0;
  if (this.values_.hasOwnProperty(key)) {
    value = this.values_[key];
  }
  return value;
};

/**
 * Get a list of object property names.
 * @return {Array.<string>} List of property names.
 * @api
 */
BaseObject.prototype.getKeys = function () {
  return Object.keys(this.values_);
};

/**
 * Get an object of all property names and values.
 * @return {Object.<string, *>} Object.
 * @api
 */
BaseObject.prototype.getProperties = function () {
  return (0, _obj.assign)({}, this.values_);
};

/**
 * @param {string} key Key name.
 * @param {*} oldValue Old value.
 */
BaseObject.prototype.notify = function (key, oldValue) {
  var eventType = void 0;
  eventType = getChangeEventType(key);
  this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
  eventType = _ObjectEventType2.default.PROPERTYCHANGE;
  this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
};

/**
 * Sets a value.
 * @param {string} key Key name.
 * @param {*} value Value.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */
BaseObject.prototype.set = function (key, value, opt_silent) {
  if (opt_silent) {
    this.values_[key] = value;
  } else {
    var oldValue = this.values_[key];
    this.values_[key] = value;
    if (oldValue !== value) {
      this.notify(key, oldValue);
    }
  }
};

/**
 * Sets a collection of key-value pairs.  Note that this changes any existing
 * properties and adds new ones (it does not remove any existing properties).
 * @param {Object.<string, *>} values Values.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */
BaseObject.prototype.setProperties = function (values, opt_silent) {
  for (var key in values) {
    this.set(key, values[key], opt_silent);
  }
};

/**
 * Unsets a property.
 * @param {string} key Key name.
 * @param {boolean=} opt_silent Unset without triggering an event.
 * @api
 */
BaseObject.prototype.unset = function (key, opt_silent) {
  if (key in this.values_) {
    var oldValue = this.values_[key];
    delete this.values_[key];
    if (!opt_silent) {
      this.notify(key, oldValue);
    }
  }
};

exports.default = BaseObject;

/***/ }),

/***/ "./node_modules/ol/ObjectEventType.js":
/*!********************************************!*\
  !*** ./node_modules/ol/ObjectEventType.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
exports.default = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object~ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
};

/***/ }),

/***/ "./node_modules/ol/Observable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Observable.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unByKey = unByKey;

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _events = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");

var _EventTarget = __webpack_require__(/*! ./events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");

var _EventTarget2 = _interopRequireDefault(_EventTarget);

var _EventType = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @constructor
 * @extends {module:ol/events/EventTarget}
 * @fires module:ol/events/Event~Event
 * @struct
 * @api
 */
/**
 * @module ol/Observable
 */
var Observable = function Observable() {

  _EventTarget2.default.call(this);

  /**
   * @private
   * @type {number}
   */
  this.revision_ = 0;
};

(0, _index.inherits)(Observable, _EventTarget2.default);

/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      (0, _events.unlistenByKey)(key[i]);
    }
  } else {
    (0, _events.unlistenByKey)( /** @type {module:ol/events~EventsKey} */key);
  }
}

/**
 * Increases the revision counter and dispatches a 'change' event.
 * @api
 */
Observable.prototype.changed = function () {
  ++this.revision_;
  this.dispatchEvent(_EventType2.default.CHANGE);
};

/**
 * Dispatches an event and calls all listeners listening for events
 * of this type. The event parameter can either be a string or an
 * Object with a `type` property.
 *
 * @param {{type: string,
 *     target: (EventTarget|module:ol/events/EventTarget|undefined)}|
 *     module:ol/events/Event|string} event Event object.
 * @function
 * @api
 */
Observable.prototype.dispatchEvent;

/**
 * Get the version number for this object.  Each time the object is modified,
 * its version number will be incremented.
 * @return {number} Revision.
 * @api
 */
Observable.prototype.getRevision = function () {
  return this.revision_;
};

/**
 * Listen for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.on = function (type, listener) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);
    for (var i = 0; i < len; ++i) {
      keys[i] = (0, _events.listen)(this, type[i], listener);
    }
    return keys;
  } else {
    return (0, _events.listen)(this, /** @type {string} */type, listener);
  }
};

/**
 * Listen once for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.once = function (type, listener) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);
    for (var i = 0; i < len; ++i) {
      keys[i] = (0, _events.listenOnce)(this, type[i], listener);
    }
    return keys;
  } else {
    return (0, _events.listenOnce)(this, /** @type {string} */type, listener);
  }
};

/**
 * Unlisten for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @api
 */
Observable.prototype.un = function (type, listener) {
  if (Array.isArray(type)) {
    for (var i = 0, ii = type.length; i < ii; ++i) {
      (0, _events.unlisten)(this, type[i], listener);
    }
    return;
  } else {
    (0, _events.unlisten)(this, /** @type {string} */type, listener);
  }
};
exports.default = Observable;

/***/ }),

/***/ "./node_modules/ol/Tile.js":
/*!*********************************!*\
  !*** ./node_modules/ol/Tile.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _TileState = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _easing = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");

var _EventTarget = __webpack_require__(/*! ./events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");

var _EventTarget2 = _interopRequireDefault(_EventTarget);

var _EventType = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A function that takes an {@link module:ol/Tile} for the tile and a
 * `{string}` for the url as arguments.
 *
 * @typedef {function(module:ol/Tile, string)} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(module:ol/tilecoord~TileCoord, number,
 *           module:ol/proj/Projection): (string|undefined)} UrlFunction
 * @api
 */

/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @api
 */

/**
 * @classdesc
 * Base class for tiles.
 *
 * @constructor
 * @abstract
 * @extends {module:ol/events/EventTarget}
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/TileState} state State.
 * @param {module:ol/Tile~Options=} opt_options Tile options.
 */
var Tile = function Tile(tileCoord, state, opt_options) {
  _EventTarget2.default.call(this);

  var options = opt_options ? opt_options : {};

  /**
   * @type {module:ol/tilecoord~TileCoord}
   */
  this.tileCoord = tileCoord;

  /**
   * @protected
   * @type {module:ol/TileState}
   */
  this.state = state;

  /**
   * An "interim" tile for this tile. The interim tile may be used while this
   * one is loading, for "smooth" transitions when changing params/dimensions
   * on the source.
   * @type {module:ol/Tile}
   */
  this.interimTile = null;

  /**
   * A key assigned to the tile. This is used by the tile source to determine
   * if this tile can effectively be used, or if a new tile should be created
   * and this one be used as an interim tile for this new tile.
   * @type {string}
   */
  this.key = '';

  /**
   * The duration for the opacity transition.
   * @type {number}
   */
  this.transition_ = options.transition === undefined ? 250 : options.transition;

  /**
   * Lookup of start times for rendering transitions.  If the start time is
   * equal to -1, the transition is complete.
   * @type {Object.<number, number>}
   */
  this.transitionStarts_ = {};
}; /**
    * @module ol/Tile
    */


(0, _index.inherits)(Tile, _EventTarget2.default);

/**
 * @protected
 */
Tile.prototype.changed = function () {
  this.dispatchEvent(_EventType2.default.CHANGE);
};

/**
 * @return {string} Key.
 */
Tile.prototype.getKey = function () {
  return this.key + '/' + this.tileCoord;
};

/**
 * Get the interim tile most suitable for rendering using the chain of interim
 * tiles. This corresponds to the  most recent tile that has been loaded, if no
 * such tile exists, the original tile is returned.
 * @return {!module:ol/Tile} Best tile for rendering.
 */
Tile.prototype.getInterimTile = function () {
  if (!this.interimTile) {
    //empty chain
    return this;
  }
  var tile = this.interimTile;

  // find the first loaded tile and return it. Since the chain is sorted in
  // decreasing order of creation time, there is no need to search the remainder
  // of the list (all those tiles correspond to older requests and will be
  // cleaned up by refreshInterimChain)
  do {
    if (tile.getState() == _TileState2.default.LOADED) {
      return tile;
    }
    tile = tile.interimTile;
  } while (tile);

  // we can not find a better tile
  return this;
};

/**
 * Goes through the chain of interim tiles and discards sections of the chain
 * that are no longer relevant.
 */
Tile.prototype.refreshInterimChain = function () {
  if (!this.interimTile) {
    return;
  }

  var tile = this.interimTile;
  var prev = this;

  do {
    if (tile.getState() == _TileState2.default.LOADED) {
      //we have a loaded tile, we can discard the rest of the list
      //we would could abort any LOADING tile request
      //older than this tile (i.e. any LOADING tile following this entry in the chain)
      tile.interimTile = null;
      break;
    } else if (tile.getState() == _TileState2.default.LOADING) {
      //keep this LOADING tile any loaded tiles later in the chain are
      //older than this tile, so we're still interested in the request
      prev = tile;
    } else if (tile.getState() == _TileState2.default.IDLE) {
      //the head of the list is the most current tile, we don't need
      //to start any other requests for this chain
      prev.interimTile = tile.interimTile;
    } else {
      prev = tile;
    }
    tile = prev.interimTile;
  } while (tile);
};

/**
 * Get the tile coordinate for this tile.
 * @return {module:ol/tilecoord~TileCoord} The tile coordinate.
 * @api
 */
Tile.prototype.getTileCoord = function () {
  return this.tileCoord;
};

/**
 * @return {module:ol/TileState} State.
 */
Tile.prototype.getState = function () {
  return this.state;
};

/**
 * @param {module:ol/TileState} state State.
 */
Tile.prototype.setState = function (state) {
  this.state = state;
  this.changed();
};

/**
 * Load the image or retry if loading previously failed.
 * Loading is taken care of by the tile queue, and calling this method is
 * only needed for preloading or for reloading in case of an error.
 * @abstract
 * @api
 */
Tile.prototype.load = function () {};

/**
 * Get the alpha value for rendering.
 * @param {number} id An id for the renderer.
 * @param {number} time The render frame time.
 * @return {number} A number between 0 and 1.
 */
Tile.prototype.getAlpha = function (id, time) {
  if (!this.transition_) {
    return 1;
  }

  var start = this.transitionStarts_[id];
  if (!start) {
    start = time;
    this.transitionStarts_[id] = start;
  } else if (start === -1) {
    return 1;
  }

  var delta = time - start + 1000 / 60; // avoid rendering at 0
  if (delta >= this.transition_) {
    return 1;
  }
  return (0, _easing.easeIn)(delta / this.transition_);
};

/**
 * Determine if a tile is in an alpha transition.  A tile is considered in
 * transition if tile.getAlpha() has not yet been called or has been called
 * and returned 1.
 * @param {number} id An id for the renderer.
 * @return {boolean} The tile is in transition.
 */
Tile.prototype.inTransition = function (id) {
  if (!this.transition_) {
    return false;
  }
  return this.transitionStarts_[id] !== -1;
};

/**
 * Mark a transition as complete.
 * @param {number} id An id for the renderer.
 */
Tile.prototype.endTransition = function (id) {
  if (this.transition_) {
    this.transitionStarts_[id] = -1;
  }
};
exports.default = Tile;

/***/ }),

/***/ "./node_modules/ol/TileCache.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileCache.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _LRUCache = __webpack_require__(/*! ./structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");

var _LRUCache2 = _interopRequireDefault(_LRUCache);

var _tilecoord = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {module:ol/structs/LRUCache.<module:ol/Tile>}
 * @param {number=} opt_highWaterMark High water mark.
 * @struct
 */
var TileCache = function TileCache(opt_highWaterMark) {

  _LRUCache2.default.call(this, opt_highWaterMark);
}; /**
    * @module ol/TileCache
    */


(0, _index.inherits)(TileCache, _LRUCache2.default);

/**
 * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.
 */
TileCache.prototype.expireCache = function (usedTiles) {
  while (this.canExpireCache()) {
    var tile = this.peekLast();
    var zKey = tile.tileCoord[0].toString();
    if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
      break;
    } else {
      this.pop().dispose();
    }
  }
};

/**
 * Prune all tiles from the cache that don't have the same z as the newest tile.
 */
TileCache.prototype.pruneExceptNewestZ = function () {
  if (this.getCount() === 0) {
    return;
  }
  var key = this.peekFirstKey();
  var tileCoord = (0, _tilecoord.fromKey)(key);
  var z = tileCoord[0];
  this.forEach(function (tile) {
    if (tile.tileCoord[0] !== z) {
      this.remove((0, _tilecoord.getKey)(tile.tileCoord));
      tile.dispose();
    }
  }, this);
};
exports.default = TileCache;

/***/ }),

/***/ "./node_modules/ol/TileRange.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileRange.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOrUpdate = createOrUpdate;
/**
 * @module ol/TileRange
 */
/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 *
 * @constructor
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @struct
 */
var TileRange = function TileRange(minX, maxX, minY, maxY) {

  /**
   * @type {number}
   */
  this.minX = minX;

  /**
   * @type {number}
   */
  this.maxX = maxX;

  /**
   * @type {number}
   */
  this.minY = minY;

  /**
   * @type {number}
   */
  this.maxY = maxY;
};

/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {module:ol/TileRange=} tileRange TileRange.
 * @return {module:ol/TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */
TileRange.prototype.contains = function (tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */
TileRange.prototype.containsTileRange = function (tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};

/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */
TileRange.prototype.containsXY = function (x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */
TileRange.prototype.equals = function (tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 */
TileRange.prototype.extend = function (tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }
  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }
  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }
  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};

/**
 * @return {number} Height.
 */
TileRange.prototype.getHeight = function () {
  return this.maxY - this.minY + 1;
};

/**
 * @return {module:ol/size~Size} Size.
 */
TileRange.prototype.getSize = function () {
  return [this.getWidth(), this.getHeight()];
};

/**
 * @return {number} Width.
 */
TileRange.prototype.getWidth = function () {
  return this.maxX - this.minX + 1;
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 * @return {boolean} Intersects.
 */
TileRange.prototype.intersects = function (tileRange) {
  return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
};
exports.default = TileRange;

/***/ }),

/***/ "./node_modules/ol/TileState.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileState.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
exports.default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4,
  ABORT: 5
};

/***/ }),

/***/ "./node_modules/ol/array.js":
/*!**********************************!*\
  !*** ./node_modules/ol/array.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binarySearch = binarySearch;
exports.numberSafeCompareFunction = numberSafeCompareFunction;
exports.includes = includes;
exports.linearFindNearest = linearFindNearest;
exports.reverseSubArray = reverseSubArray;
exports.extend = extend;
exports.remove = remove;
exports.find = find;
exports.equals = equals;
exports.stableSort = stableSort;
exports.findIndex = findIndex;
exports.isSorted = isSorted;
/**
 * @module ol/array
 */

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array.<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
  var mid = void 0,
      cmp = void 0;
  var comparator = opt_comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
}

/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}

/**
 * Whether the array contains the given object.
 * @param {Array.<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */
function includes(arr, obj) {
  return arr.indexOf(obj) >= 0;
}

/**
 * @param {Array.<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
  var n = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i = void 0;
    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }
    return n - 1;
  }
}

/**
 * @param {Array.<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}

/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {!Array.<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}

/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}

/**
 * @param {Array.<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */
function find(arr, func) {
  var length = arr.length >>> 0;
  var value = void 0;

  for (var i = 0; i < length; i++) {
    value = arr[i];
    if (func(value, i, arr)) {
      return value;
    }
  }
  return null;
}

/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

/**
 * @param {Array.<*>} arr The array to sort (modifies original).
 * @param {Function} compareFnc Comparison function.
 */
function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i = void 0;
  for (i = 0; i < length; i++) {
    tmp[i] = { index: i, value: arr[i] };
  }
  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}

/**
 * @param {Array.<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */
function findIndex(arr, func) {
  var index = void 0;
  var found = !arr.every(function (el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
}

/**
 * @param {Array.<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}

/***/ }),

/***/ "./node_modules/ol/asserts.js":
/*!************************************!*\
  !*** ./node_modules/ol/asserts.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

var _AssertionError = __webpack_require__(/*! ./AssertionError.js */ "./node_modules/ol/AssertionError.js");

var _AssertionError2 = _interopRequireDefault(_AssertionError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new _AssertionError2.default(errorCode);
  }
} /**
   * @module ol/asserts
   */

/***/ }),

/***/ "./node_modules/ol/dom.js":
/*!********************************!*\
  !*** ./node_modules/ol/dom.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCanvasContext2D = createCanvasContext2D;
exports.outerWidth = outerWidth;
exports.outerHeight = outerHeight;
exports.replaceNode = replaceNode;
exports.removeNode = removeNode;
exports.removeChildren = removeChildren;
/**
 * @module ol/dom
 */

/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(opt_width, opt_height) {
  var canvas = /** @type {HTMLCanvasElement} */document.createElement('CANVAS');
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return (/** @type {CanvasRenderingContext2D} */canvas.getContext('2d')
  );
}

/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!Element} element Element.
 * @return {number} The width.
 */
function outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
}

/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!Element} element Element.
 * @return {number} The height.
 */
function outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
}

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}

/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}

/**
 * @param {Node} node The node to remove the children from.
 */
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

/***/ }),

/***/ "./node_modules/ol/easing.js":
/*!***********************************!*\
  !*** ./node_modules/ol/easing.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.easeIn = easeIn;
exports.easeOut = easeOut;
exports.inAndOut = inAndOut;
exports.linear = linear;
exports.upAndDown = upAndDown;
/**
 * @module ol/easing
 */

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}

/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeOut(t) {
  return 1 - easeIn(1 - t);
}

/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}

/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function linear(t) {
  return t;
}

/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing~inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  } else {
    return 1 - inAndOut(2 * (t - 0.5));
  }
}

/***/ }),

/***/ "./node_modules/ol/events.js":
/*!***********************************!*\
  !*** ./node_modules/ol/events.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bindListener = bindListener;
exports.findListener = findListener;
exports.getListeners = getListeners;
exports.listen = listen;
exports.listenOnce = listenOnce;
exports.unlisten = unlisten;
exports.unlistenByKey = unlistenByKey;
exports.unlistenAll = unlistenAll;

var _obj = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");

/**
 * Key to use with {@link module:ol/Observable~Observable#unByKey}.
 * @typedef {Object} EventsKey
 * @property {Object} [bindTo]
 * @property {module:ol/events~ListenerFunction} [boundListener]
 * @property {boolean} callOnce
 * @property {number} [deleteIndex]
 * @property {module:ol/events~ListenerFunction} listener
 * @property {EventTarget|module:ol/events/EventTarget} target
 * @property {string} type
 * @api
 */

/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function(module:ol/events/Event)|function(module:ol/events/Event): boolean} ListenerFunction
 * @api
 */

/**
 * @param {module:ol/events~EventsKey} listenerObj Listener object.
 * @return {module:ol/events~ListenerFunction} Bound listener.
 */
function bindListener(listenerObj) {
  var boundListener = function boundListener(evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;
    if (listenerObj.callOnce) {
      unlistenByKey(listenerObj);
    }
    return listener.call(bindTo, evt);
  };
  listenerObj.boundListener = boundListener;
  return boundListener;
}

/**
 * Finds the matching {@link module:ol/events~EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!module:ol/events~EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link module:ol/events~unlistenByKey}.
 * @return {module:ol/events~EventsKey|undefined} The matching listener object.
 */
/**
 * @module ol/events
 */
function findListener(listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj = void 0;
  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];
    if (listenerObj.listener === listener && listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }
      return listenerObj;
    }
  }
  return undefined;
}

/**
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array.<module:ol/events~EventsKey>|undefined} Listeners.
 */
function getListeners(target, type) {
  var listenerMap = target.ol_lm;
  return listenerMap ? listenerMap[type] : undefined;
}

/**
 * Get the lookup of listeners.  If one does not exist on the target, it is
 * created.
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 * @return {!Object.<string, Array.<module:ol/events~EventsKey>>} Map of
 *     listeners by event type.
 */
function getListenerMap(target) {
  var listenerMap = target.ol_lm;
  if (!listenerMap) {
    listenerMap = target.ol_lm = {};
  }
  return listenerMap;
}

/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 * @param {string} type Type.
 */
function removeListeners(target, type) {
  var listeners = getListeners(target, type);
  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      target.removeEventListener(type, listeners[i].boundListener);
      (0, _obj.clear)(listeners[i]);
    }
    listeners.length = 0;
    var listenerMap = target.ol_lm;
    if (listenerMap) {
      delete listenerMap[type];
      if (Object.keys(listenerMap).length === 0) {
        delete target.ol_lm;
      }
    }
  }
}

/**
 * Registers an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events~unlistenByKey}.
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {module:ol/events~EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, opt_this, opt_once) {
  var listenerMap = getListenerMap(target);
  var listeners = listenerMap[type];
  if (!listeners) {
    listeners = listenerMap[type] = [];
  }
  var listenerObj = findListener(listeners, listener, opt_this, false);
  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = /** @type {module:ol/events~EventsKey} */{
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    };
    target.addEventListener(type, bindListener(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
}

/**
 * Registers a one-off event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events~unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events~listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {module:ol/events~EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, opt_this) {
  return listen(target, type, listener, opt_this, true);
}

/**
 * Unregisters an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link module:ol/events~listen} call.
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */
function unlisten(target, type, listener, opt_this) {
  var listeners = getListeners(target, type);
  if (listeners) {
    var listenerObj = findListener(listeners, listener, opt_this, true);
    if (listenerObj) {
      unlistenByKey(listenerObj);
    }
  }
}

/**
 * Unregisters event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
 *
 * @param {module:ol/events~EventsKey} key The key.
 */
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.boundListener);
    var listeners = getListeners(key.target, key.type);
    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);
      if (i !== -1) {
        listeners.splice(i, 1);
      }
      if (listeners.length === 0) {
        removeListeners(key.target, key.type);
      }
    }
    (0, _obj.clear)(key);
  }
}

/**
 * Unregisters all event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 */
function unlistenAll(target) {
  var listenerMap = getListenerMap(target);
  for (var type in listenerMap) {
    removeListeners(target, type);
  }
}

/***/ }),

/***/ "./node_modules/ol/events/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/events/Event.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stopPropagation = stopPropagation;
exports.preventDefault = preventDefault;
/**
 * @module ol/events/Event
 */
/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/EventTarget~EventTarget}.
 *
 * @constructor
 * @param {string} type Type.
 */
var Event = function Event(type) {

  /**
   * @type {boolean}
   */
  this.propagationStopped;

  /**
   * The event type.
   * @type {string}
   * @api
   */
  this.type = type;

  /**
   * The event target.
   * @type {Object}
   * @api
   */
  this.target = null;
};

/**
 * Stop event propagation.
 * @function
 * @api
 */
Event.prototype.preventDefault =

/**
 * Stop event propagation.
 * @function
 * @api
 */
Event.prototype.stopPropagation = function () {
  this.propagationStopped = true;
};

/**
 * @param {Event|module:ol/events/Event} evt Event
 */
function stopPropagation(evt) {
  evt.stopPropagation();
}

/**
 * @param {Event|module:ol/events/Event} evt Event
 */
function preventDefault(evt) {
  evt.preventDefault();
}

exports.default = Event;

/***/ }),

/***/ "./node_modules/ol/events/EventTarget.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/events/EventTarget.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _Disposable = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");

var _Disposable2 = _interopRequireDefault(_Disposable);

var _events = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");

var _functions = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");

var _Event = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");

var _Event2 = _interopRequireDefault(_Event);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {EventTarget|module:ol/events/EventTarget} EventTargetLike
 */

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 *
 * @constructor
 * @extends {module:ol/Disposable}
 */
var EventTarget = function EventTarget() {

  _Disposable2.default.call(this);

  /**
   * @private
   * @type {!Object.<string, number>}
   */
  this.pendingRemovals_ = {};

  /**
   * @private
   * @type {!Object.<string, number>}
   */
  this.dispatching_ = {};

  /**
   * @private
   * @type {!Object.<string, Array.<module:ol/events~ListenerFunction>>}
   */
  this.listeners_ = {};
}; /**
    * @module ol/events/EventTarget
    */


(0, _index.inherits)(EventTarget, _Disposable2.default);

/**
 * @param {string} type Type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 */
EventTarget.prototype.addEventListener = function (type, listener) {
  var listeners = this.listeners_[type];
  if (!listeners) {
    listeners = this.listeners_[type] = [];
  }
  if (listeners.indexOf(listener) === -1) {
    listeners.push(listener);
  }
};

/**
 * @param {{type: string,
 *     target: (EventTarget|module:ol/events/EventTarget|undefined)}|module:ol/events/Event|
 *     string} event Event or event type.
 * @return {boolean|undefined} `false` if anyone called preventDefault on the
 *     event object or if any of the listeners returned false.
 */
EventTarget.prototype.dispatchEvent = function (event) {
  var evt = typeof event === 'string' ? new _Event2.default(event) : event;
  var type = evt.type;
  evt.target = this;
  var listeners = this.listeners_[type];
  var propagate = void 0;
  if (listeners) {
    if (!(type in this.dispatching_)) {
      this.dispatching_[type] = 0;
      this.pendingRemovals_[type] = 0;
    }
    ++this.dispatching_[type];
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    --this.dispatching_[type];
    if (this.dispatching_[type] === 0) {
      var pendingRemovals = this.pendingRemovals_[type];
      delete this.pendingRemovals_[type];
      while (pendingRemovals--) {
        this.removeEventListener(type, _functions.UNDEFINED);
      }
      delete this.dispatching_[type];
    }
    return propagate;
  }
};

/**
 * @inheritDoc
 */
EventTarget.prototype.disposeInternal = function () {
  (0, _events.unlistenAll)(this);
};

/**
 * Get the listeners for a specified event type. Listeners are returned in the
 * order that they will be called in.
 *
 * @param {string} type Type.
 * @return {Array.<module:ol/events~ListenerFunction>} Listeners.
 */
EventTarget.prototype.getListeners = function (type) {
  return this.listeners_[type];
};

/**
 * @param {string=} opt_type Type. If not provided,
 *     `true` will be returned if this EventTarget has any listeners.
 * @return {boolean} Has listeners.
 */
EventTarget.prototype.hasListener = function (opt_type) {
  return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
};

/**
 * @param {string} type Type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 */
EventTarget.prototype.removeEventListener = function (type, listener) {
  var listeners = this.listeners_[type];
  if (listeners) {
    var index = listeners.indexOf(listener);
    if (type in this.pendingRemovals_) {
      // make listener a no-op, and remove later in #dispatchEvent()
      listeners[index] = _functions.UNDEFINED;
      ++this.pendingRemovals_[type];
    } else {
      listeners.splice(index, 1);
      if (listeners.length === 0) {
        delete this.listeners_[type];
      }
    }
  }
};
exports.default = EventTarget;

/***/ }),

/***/ "./node_modules/ol/events/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/EventType.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
exports.default = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~Event#change
   * @api
   */
  CHANGE: 'change',

  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
};

/***/ }),

/***/ "./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.boundingExtent = boundingExtent;
exports.buffer = buffer;
exports.clone = clone;
exports.closestSquaredDistanceXY = closestSquaredDistanceXY;
exports.containsCoordinate = containsCoordinate;
exports.containsExtent = containsExtent;
exports.containsXY = containsXY;
exports.coordinateRelationship = coordinateRelationship;
exports.createEmpty = createEmpty;
exports.createOrUpdate = createOrUpdate;
exports.createOrUpdateEmpty = createOrUpdateEmpty;
exports.createOrUpdateFromCoordinate = createOrUpdateFromCoordinate;
exports.createOrUpdateFromCoordinates = createOrUpdateFromCoordinates;
exports.createOrUpdateFromFlatCoordinates = createOrUpdateFromFlatCoordinates;
exports.createOrUpdateFromRings = createOrUpdateFromRings;
exports.equals = equals;
exports.extend = extend;
exports.extendCoordinate = extendCoordinate;
exports.extendCoordinates = extendCoordinates;
exports.extendFlatCoordinates = extendFlatCoordinates;
exports.extendRings = extendRings;
exports.extendXY = extendXY;
exports.forEachCorner = forEachCorner;
exports.getArea = getArea;
exports.getBottomLeft = getBottomLeft;
exports.getBottomRight = getBottomRight;
exports.getCenter = getCenter;
exports.getCorner = getCorner;
exports.getEnlargedArea = getEnlargedArea;
exports.getForViewAndSize = getForViewAndSize;
exports.getHeight = getHeight;
exports.getIntersectionArea = getIntersectionArea;
exports.getIntersection = getIntersection;
exports.getMargin = getMargin;
exports.getSize = getSize;
exports.getTopLeft = getTopLeft;
exports.getTopRight = getTopRight;
exports.getWidth = getWidth;
exports.intersects = intersects;
exports.isEmpty = isEmpty;
exports.returnOrUpdate = returnOrUpdate;
exports.scaleFromCenter = scaleFromCenter;
exports.intersectsSegment = intersectsSegment;
exports.applyTransform = applyTransform;

var _asserts = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");

var _Corner = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");

var _Corner2 = _interopRequireDefault(_Corner);

var _Relationship = __webpack_require__(/*! ./extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");

var _Relationship2 = _interopRequireDefault(_Relationship);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array.<number>} Extent
 * @api
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
 * @return {module:ol/extent~Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  var extent = createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {Array.<number>} xs Xs.
 * @param {Array.<number>} ys Ys.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @private
 * @return {module:ol/extent~Extent} Extent.
 */
/**
 * @module ol/extent
 */
function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}

/**
 * Return extent increased by the provided value.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
function buffer(extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
}

/**
 * Creates a clone of an extent.
 *
 * @param {module:ol/extent~Extent} extent Extent to clone.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} The clone.
 */
function clone(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
  var dx = void 0,
      dy = void 0;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}

/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}

/**
 * Get the relationship between a coordinate and extent.
 * @param {module:ol/extent~Extent} extent The extent.
 * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.
 * @return {module:ol/extent/Relationship} The relationship (bitwise compare with
 *     module:ol/extent/Relationship~Relationship).
 */
function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _Relationship2.default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | _Relationship2.default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | _Relationship2.default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _Relationship2.default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | _Relationship2.default.ABOVE;
  }
  if (relationship === _Relationship2.default.UNKNOWN) {
    relationship = _Relationship2.default.INTERSECTING;
  }
  return relationship;
}

/**
 * Create an empty extent.
 * @return {module:ol/extent~Extent} Empty extent.
 * @api
 */
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}

/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}

/**
 * Create a new empty extent or make the provided one empty.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}

/**
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, opt_extent);
}

/**
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent, coordinates);
}

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}

/**
 * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} rings Rings.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromRings(rings, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendRings(extent, rings);
}

/**
 * Determine if two extents are equivalent.
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}

/**
 * Modify an extent to include another extent.
 * @param {module:ol/extent~Extent} extent1 The extent to be modified.
 * @param {module:ol/extent~Extent} extent2 The extent that will be included in the first.
 * @return {module:ol/extent~Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
 * @return {module:ol/extent~Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {module:ol/extent~Extent} Extent.
 */
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} rings Rings.
 * @return {module:ol/extent~Extent} Extent.
 */
function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}

/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {function(this:T, module:ol/coordinate~Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */
function forEachCorner(extent, callback, opt_this) {
  var val = void 0;
  val = callback.call(opt_this, getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}

/**
 * Get the size of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
  var area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}

/**
 * Get the bottom left coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}

/**
 * Get the bottom right coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}

/**
 * Get the center coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Center.
 * @api
 */
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}

/**
 * Get a corner coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/extent/Corner} corner Corner.
 * @return {module:ol/coordinate~Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
  var coordinate = void 0;
  if (corner === _Corner2.default.BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === _Corner2.default.BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === _Corner2.default.TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === _Corner2.default.TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    (0, _asserts.assert)(false, 13); // Invalid corner
  }
  return (
    /** @type {!module:ol/coordinate~Coordinate} */coordinate
  );
}

/**
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}

/**
 * @param {module:ol/coordinate~Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {module:ol/size~Size} size Size.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
}

/**
 * Get the height of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
  return extent[3] - extent[1];
}

/**
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}

/**
 * Get the intersection of two extents.
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @param {module:ol/extent~Extent=} opt_extent Optional extent to populate with intersection.
 * @return {module:ol/extent~Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}

/**
 * Get the size (width, height) of an extent.
 * @param {module:ol/extent~Extent} extent The extent.
 * @return {module:ol/size~Size} The extent size.
 * @api
 */
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}

/**
 * Get the top left coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}

/**
 * Get the top right coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
  return [extent[2], extent[3]];
}

/**
 * Get the width of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
  return extent[2] - extent[0];
}

/**
 * Determine if one extent intersects another.
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}

/**
 * Determine if an extent is empty.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function returnOrUpdate(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}

/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {module:ol/extent~Extent} extent The extent.
 * @param {module:ol/coordinate~Coordinate} start Segment start coordinate.
 * @param {module:ol/coordinate~Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);
  if (startRel === _Relationship2.default.INTERSECTING || endRel === _Relationship2.default.INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x = void 0,
        y = void 0;
    if (!!(endRel & _Relationship2.default.ABOVE) && !(startRel & _Relationship2.default.ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _Relationship2.default.RIGHT) && !(startRel & _Relationship2.default.RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }
    if (!intersects && !!(endRel & _Relationship2.default.BELOW) && !(startRel & _Relationship2.default.BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _Relationship2.default.LEFT) && !(startRel & _Relationship2.default.LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }
  return intersects;
}

/**
 * Apply a transform function to the extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/proj~TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, opt_extent) {
  var coordinates = [extent[0], extent[1], extent[0], extent[3], extent[2], extent[1], extent[2], extent[3]];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return _boundingExtentXYs(xs, ys, opt_extent);
}

/***/ }),

/***/ "./node_modules/ol/extent/Corner.js":
/*!******************************************!*\
  !*** ./node_modules/ol/extent/Corner.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/extent/Corner
 */

/**
 * Extent corner.
 * @enum {string}
 */
exports.default = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};

/***/ }),

/***/ "./node_modules/ol/extent/Relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/Relationship.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
exports.default = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};

/***/ }),

/***/ "./node_modules/ol/functions.js":
/*!**************************************!*\
  !*** ./node_modules/ol/functions.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRUE = TRUE;
exports.FALSE = FALSE;
exports.UNDEFINED = UNDEFINED;
/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @returns {boolean} true.
 */
function TRUE() {
  return true;
}

/**
 * Always returns false.
 * @returns {boolean} false.
 */
function FALSE() {
  return false;
}

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {undefined} Nothing.
 */
function UNDEFINED() {}

/***/ }),

/***/ "./node_modules/ol/geom/GeometryType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/GeometryType.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/geom/GeometryType
 */

/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
exports.default = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};

/***/ }),

/***/ "./node_modules/ol/index.js":
/*!**********************************!*\
  !*** ./node_modules/ol/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = exports.WEBGL_EXTENSIONS = exports.WEBGL_MAX_TEXTURE_SIZE = exports.HAS_WEBGL = exports.DEBUG_WEBGL = undefined;
exports.inherits = inherits;
exports.getUid = getUid;

var _webgl = __webpack_require__(/*! ./webgl.js */ "./node_modules/ol/webgl.js");

/**
 * An array with two elements, representing a pixel. The first element is the
 * x-coordinate, the second the y-coordinate of the pixel.
 * @typedef {Array.<number>} Pixel
 * @api
 */

/**
 * Include debuggable shader sources.  Default is `true`. This should be set to
 * `false` for production builds.
 * TODO: move to a separate ol-webgl package
 * @type {boolean}
 */
var DEBUG_WEBGL = exports.DEBUG_WEBGL = true;

/**
 * TODO: move to a separate ol-webgl package
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @type {number|undefined}
 */
/**
 * @module ol
 */

var WEBGL_MAX_TEXTURE_SIZE = void 0; // value is set below


/**
 * TODO: move to a separate ol-webgl package
 * List of supported WebGL extensions.
 * @type {Array.<string>}
 */
var WEBGL_EXTENSIONS = void 0; // value is set below


/**
 * TODO: move to a separate ol-webgl package
 * WebGL is available.
 * @type {boolean}
 */
var HAS_WEBGL = false;

if (typeof window !== 'undefined' && 'WebGLRenderingContext' in window) {
  try {
    var canvas = /** @type {HTMLCanvasElement} */document.createElement('CANVAS');
    var gl = (0, _webgl.getContext)(canvas, { failIfMajorPerformanceCaveat: true });
    if (gl) {
      exports.HAS_WEBGL = HAS_WEBGL = true;
      exports.WEBGL_MAX_TEXTURE_SIZE = WEBGL_MAX_TEXTURE_SIZE = /** @type {number} */gl.getParameter(gl.MAX_TEXTURE_SIZE);
      exports.WEBGL_EXTENSIONS = WEBGL_EXTENSIONS = gl.getSupportedExtensions();
    }
  } catch (e) {
    // pass
  }
}

exports.HAS_WEBGL = HAS_WEBGL;
exports.WEBGL_MAX_TEXTURE_SIZE = WEBGL_MAX_TEXTURE_SIZE;
exports.WEBGL_EXTENSIONS = WEBGL_EXTENSIONS;

/**
 * OpenLayers version.
 * @type {string}
 */

var VERSION = exports.VERSION = 'v4.6.4';

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function
 * @api
 */
function inherits(childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
}

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
var uidCounter_ = 0;

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = ++uidCounter_);
}

/***/ }),

/***/ "./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cosh = undefined;
exports.clamp = clamp;
exports.roundUpToPowerOfTwo = roundUpToPowerOfTwo;
exports.squaredSegmentDistance = squaredSegmentDistance;
exports.squaredDistance = squaredDistance;
exports.solveLinearSystem = solveLinearSystem;
exports.toDegrees = toDegrees;
exports.toRadians = toRadians;
exports.modulo = modulo;
exports.lerp = lerp;

var _asserts = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
/**
 * @module ol/math
 */
var cosh = exports.cosh = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh = void 0;
  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it…
    cosh = Math.cosh;
  } else {
    // … else, use the reference implementation of MDN:
    cosh = function cosh(x) {
      var y = Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }
  return cosh;
}();

/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */
function roundUpToPowerOfTwo(x) {
  (0, _asserts.assert)(0 < x, 29); // `x` must be greater than `0`
  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
}

/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}

/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}

/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array.<number>} The resulting vector.
 */
function solveLinearSystem(mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}

/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}

/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
  return a + x * (b - a);
}

/***/ }),

/***/ "./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.getValues = getValues;
exports.isEmpty = isEmpty;
/**
 * @module ol/obj
 */

/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 *
 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = exports.assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];
    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};

/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}

/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
function getValues(object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
}

/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
  var property = void 0;
  for (property in object) {
    return false;
  }
  return !property;
}

/***/ }),

/***/ "./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.METERS_PER_UNIT = undefined;
exports.cloneTransform = cloneTransform;
exports.identityTransform = identityTransform;
exports.addProjection = addProjection;
exports.addProjections = addProjections;
exports.get = get;
exports.getPointResolution = getPointResolution;
exports.addEquivalentProjections = addEquivalentProjections;
exports.addEquivalentTransforms = addEquivalentTransforms;
exports.clearAllProjections = clearAllProjections;
exports.createProjection = createProjection;
exports.createTransformFromCoordinateTransform = createTransformFromCoordinateTransform;
exports.addCoordinateTransforms = addCoordinateTransforms;
exports.fromLonLat = fromLonLat;
exports.toLonLat = toLonLat;
exports.equivalent = equivalent;
exports.getTransformFromProjections = getTransformFromProjections;
exports.getTransform = getTransform;
exports.transform = transform;
exports.transformExtent = transformExtent;
exports.transformWithProjections = transformWithProjections;
exports.addCommon = addCommon;

var _sphere = __webpack_require__(/*! ./sphere.js */ "./node_modules/ol/sphere.js");

var _extent = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");

var _math = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");

var _epsg = __webpack_require__(/*! ./proj/epsg3857.js */ "./node_modules/ol/proj/epsg3857.js");

var _epsg2 = __webpack_require__(/*! ./proj/epsg4326.js */ "./node_modules/ol/proj/epsg4326.js");

var _Projection = __webpack_require__(/*! ./proj/Projection.js */ "./node_modules/ol/proj/Projection.js");

var _Projection2 = _interopRequireDefault(_Projection);

var _Units = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");

var _Units2 = _interopRequireDefault(_Units);

var _projections = __webpack_require__(/*! ./proj/projections.js */ "./node_modules/ol/proj/projections.js");

var projections = _interopRequireWildcard(_projections);

var _transforms = __webpack_require__(/*! ./proj/transforms.js */ "./node_modules/ol/proj/transforms.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A projection as {@link module:ol/proj/Projection}, SRS identifier
 * string or undefined.
 * @typedef {module:ol/proj/Projection|string|undefined} ProjectionLike
 * @api
 */

/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array.<number>, Array.<number>=, number=): Array.<number>} TransformFunction
 * @api
 */

exports.METERS_PER_UNIT = _Units.METERS_PER_UNIT;

/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the {@link http://proj4js.org/}
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * {@link https://epsg.io/}, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection} object for the new projection and add it with
 * {@link module:ol/proj~addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj~addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection} with
 * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of
 * this.
 */

function cloneTransform(input, opt_output, opt_dimension) {
  var output = void 0;
  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
}

/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    input = opt_output;
  }
  return input;
}

/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {module:ol/proj/Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
  projections.add(projection.getCode(), projection);
  (0, _transforms.add)(projection, projection, cloneTransform);
}

/**
 * @param {Array.<module:ol/proj/Projection>} projections Projections.
 */
function addProjections(projections) {
  projections.forEach(addProjection);
}

/**
 * Fetches a Projection object for the code specified.
 *
 * @param {module:ol/proj~ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {module:ol/proj/Projection} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
  var projection = null;
  if (projectionLike instanceof _Projection2.default) {
    projection = projectionLike;
  } else if (typeof projectionLike === 'string') {
    var code = projectionLike;
    projection = projections.get(code);
  }
  return projection;
}

/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {module:ol/proj~ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {module:ol/coordinate~Coordinate} point Point to find adjusted resolution at.
 * @param {module:ol/proj/Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, opt_units) {
  projection = get(projection);
  var pointResolution = void 0;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();
    if (units == _Units2.default.DEGREES && !opt_units || opt_units == _Units2.default.DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var _toEPSG = getTransformFromProjections(projection, get('EPSG:4326'));
      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
      vertices = _toEPSG(vertices, vertices, 2);
      var width = (0, _sphere.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
      var height = (0, _sphere.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ? _Units.METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}

/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array.<module:ol/proj/Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        (0, _transforms.add)(source, destination, cloneTransform);
      }
    });
  });
}

/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array.<module:ol/proj/Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array.<module:ol/proj/Projection>} projections2 Projections with equal
 *     meaning.
 * @param {module:ol/proj~TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {module:ol/proj~TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      (0, _transforms.add)(projection1, projection2, forwardTransform);
      (0, _transforms.add)(projection2, projection1, inverseTransform);
    });
  });
}

/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
  projections.clear();
  (0, _transforms.clear)();
}

/**
 * @param {module:ol/proj/Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {module:ol/proj/Projection} Projection.
 */
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  } else if (typeof projection === 'string') {
    return get(projection);
  } else {
    return (
      /** @type {module:ol/proj/Projection} */projection
    );
  }
}

/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} coordTransform Coordinate
 *     transform.
 * @return {module:ol/proj~TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array.<number>} input Input.
     * @param {Array.<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array.<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);
      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];
        for (var j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }
      return output;
    }
  );
}

/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {module:ol/proj~ProjectionLike} source Source projection.
 * @param {module:ol/proj~ProjectionLike} destination Destination projection.
 * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = get(source);
  var destProj = get(destination);
  (0, _transforms.add)(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  (0, _transforms.add)(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}

/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {module:ol/proj~ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {module:ol/coordinate~Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, opt_projection) {
  return transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}

/**
 * Transforms a coordinate to longitude/latitude.
 * @param {module:ol/coordinate~Coordinate} coordinate Projected coordinate.
 * @param {module:ol/proj~ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {module:ol/coordinate~Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, opt_projection) {
  var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = (0, _math.modulo)(lon + 180, 360) - 180;
  }
  return lonLat;
}

/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {module:ol/proj/Projection} projection1 Projection 1.
 * @param {module:ol/proj/Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}

/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {module:ol/proj/Projection} sourceProjection Source Projection object.
 * @param {module:ol/proj/Projection} destinationProjection Destination Projection
 *     object.
 * @return {module:ol/proj~TransformFunction} Transform function.
 */
function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = (0, _transforms.get)(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}

/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {module:ol/proj~ProjectionLike} source Source.
 * @param {module:ol/proj~ProjectionLike} destination Destination.
 * @return {module:ol/proj~TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
  var sourceProjection = get(source);
  var destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}

/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj~transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {module:ol/proj~ProjectionLike} source Source projection-like.
 * @param {module:ol/proj~ProjectionLike} destination Destination projection-like.
 * @return {module:ol/coordinate~Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}

/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {module:ol/extent~Extent} extent The extent to transform.
 * @param {module:ol/proj~ProjectionLike} source Source projection-like.
 * @param {module:ol/proj~ProjectionLike} destination Destination projection-like.
 * @return {module:ol/extent~Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination) {
  var transformFunc = getTransform(source, destination);
  return (0, _extent.applyTransform)(extent, transformFunc);
}

/**
 * Transforms the given point to the destination projection.
 *
 * @param {module:ol/coordinate~Coordinate} point Point.
 * @param {module:ol/proj/Projection} sourceProjection Source projection.
 * @param {module:ol/proj/Projection} destinationProjection Destination projection.
 * @return {module:ol/coordinate~Coordinate} Point.
 */
function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_epsg.PROJECTIONS);
  addEquivalentProjections(_epsg2.PROJECTIONS);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  addEquivalentTransforms(_epsg2.PROJECTIONS, _epsg.PROJECTIONS, _epsg.fromEPSG4326, _epsg.toEPSG4326);
}

addCommon();

/***/ }),

/***/ "./node_modules/ol/proj/Projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/Projection.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Units = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");

/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {module:ol/proj/Units|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {module:ol/extent~Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {module:ol/extent~Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, module:ol/coordinate~Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `{number}` view resolution and an `{module:ol/coordinate~Coordinate}` as arguments, and returns
 * the `{number}` resolution at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj#getPointResolution} function will be used.
 */

/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj~get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use proj4js, aliases can be added using `proj4.defs()`; see
 * [documentation](https://github.com/proj4js/proj4js). To set an alternative
 * namespace for proj4, use {@link module:ol/proj~setProj4}.
 *
 * @constructor
 * @param {module:ol/proj/Projection~Options} options Projection options.
 * @struct
 * @api
 */
var Projection = function Projection(options) {
  /**
   * @private
   * @type {string}
   */
  this.code_ = options.code;

  /**
   * Units of projected coordinates. When set to `TILE_PIXELS`, a
   * `this.extent_` and `this.worldExtent_` must be configured properly for each
   * tile.
   * @private
   * @type {module:ol/proj/Units}
   */
  this.units_ = /** @type {module:ol/proj/Units} */options.units;

  /**
   * Validity extent of the projection in projected coordinates. For projections
   * with `TILE_PIXELS` units, this is the extent of the tile in
   * tile pixel space.
   * @private
   * @type {module:ol/extent~Extent}
   */
  this.extent_ = options.extent !== undefined ? options.extent : null;

  /**
   * Extent of the world in EPSG:4326. For projections with
   * `TILE_PIXELS` units, this is the extent of the tile in
   * projected coordinate space.
   * @private
   * @type {module:ol/extent~Extent}
   */
  this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;

  /**
   * @private
   * @type {string}
   */
  this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';

  /**
   * @private
   * @type {boolean}
   */
  this.global_ = options.global !== undefined ? options.global : false;

  /**
   * @private
   * @type {boolean}
   */
  this.canWrapX_ = !!(this.global_ && this.extent_);

  /**
   * @private
   * @type {function(number, module:ol/coordinate~Coordinate):number|undefined}
   */
  this.getPointResolutionFunc_ = options.getPointResolution;

  /**
   * @private
   * @type {module:ol/tilegrid/TileGrid}
   */
  this.defaultTileGrid_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.metersPerUnit_ = options.metersPerUnit;
};

/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */
/**
 * @module ol/proj/Projection
 */
Projection.prototype.canWrapX = function () {
  return this.canWrapX_;
};

/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */
Projection.prototype.getCode = function () {
  return this.code_;
};

/**
 * Get the validity extent for this projection.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
Projection.prototype.getExtent = function () {
  return this.extent_;
};

/**
 * Get the units of this projection.
 * @return {module:ol/proj/Units} Units.
 * @api
 */
Projection.prototype.getUnits = function () {
  return this.units_;
};

/**
 * Get the amount of meters per unit of this projection.  If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */
Projection.prototype.getMetersPerUnit = function () {
  return this.metersPerUnit_ || _Units.METERS_PER_UNIT[this.units_];
};

/**
 * Get the world extent for this projection.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
Projection.prototype.getWorldExtent = function () {
  return this.worldExtent_;
};

/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *     or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *     "west positive" coordinate systems
 * @return {string} Axis orientation.
 * @api
 */
Projection.prototype.getAxisOrientation = function () {
  return this.axisOrientation_;
};

/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */
Projection.prototype.isGlobal = function () {
  return this.global_;
};

/**
* Set if the projection is a global projection which spans the whole world
* @param {boolean} global Whether the projection is global.
* @api
*/
Projection.prototype.setGlobal = function (global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};

/**
 * @return {module:ol/tilegrid/TileGrid} The default tile grid.
 */
Projection.prototype.getDefaultTileGrid = function () {
  return this.defaultTileGrid_;
};

/**
 * @param {module:ol/tilegrid/TileGrid} tileGrid The default tile grid.
 */
Projection.prototype.setDefaultTileGrid = function (tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};

/**
 * Set the validity extent for this projection.
 * @param {module:ol/extent~Extent} extent Extent.
 * @api
 */
Projection.prototype.setExtent = function (extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};

/**
 * Set the world extent for this projection.
 * @param {module:ol/extent~Extent} worldExtent World extent
 *     [minlon, minlat, maxlon, maxlat].
 * @api
 */
Projection.prototype.setWorldExtent = function (worldExtent) {
  this.worldExtent_ = worldExtent;
};

/**
 * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
 * for this projection.
 * @param {function(number, module:ol/coordinate~Coordinate):number} func Function
 * @api
 */
Projection.prototype.setGetPointResolution = function (func) {
  this.getPointResolutionFunc_ = func;
};

/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, module:ol/coordinate~Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */
Projection.prototype.getPointResolutionFunc = function () {
  return this.getPointResolutionFunc_;
};
exports.default = Projection;

/***/ }),

/***/ "./node_modules/ol/proj/Units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/Units.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/proj/Units
 */

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};

/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<module:ol/proj/Units, number>}
 * @api
 */
var METERS_PER_UNIT = exports.METERS_PER_UNIT = {};
// use the radius of the Normal sphere
METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

exports.default = Units;

/***/ }),

/***/ "./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROJECTIONS = exports.WORLD_EXTENT = exports.EXTENT = exports.HALF_SIZE = exports.RADIUS = undefined;
exports.fromEPSG4326 = fromEPSG4326;
exports.toEPSG4326 = toEPSG4326;

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _math = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");

var _Projection = __webpack_require__(/*! ../proj/Projection.js */ "./node_modules/ol/proj/Projection.js");

var _Projection2 = _interopRequireDefault(_Projection);

var _Units = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");

var _Units2 = _interopRequireDefault(_Units);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
/**
 * @module ol/proj/epsg3857
 */
var RADIUS = exports.RADIUS = 6378137;

/**
 * @const
 * @type {number}
 */
var HALF_SIZE = exports.HALF_SIZE = Math.PI * RADIUS;

/**
 * @const
 * @type {module:ol/extent~Extent}
 */
var EXTENT = exports.EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];

/**
 * @const
 * @type {module:ol/extent~Extent}
 */
var WORLD_EXTENT = exports.WORLD_EXTENT = [-180, -85, 180, 85];

/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 *
 * @constructor
 * @extends {module:ol/proj/Projection}
 * @param {string} code Code.
 */
function EPSG3857Projection(code) {
  _Projection2.default.call(this, {
    code: code,
    units: _Units2.default.METERS,
    extent: EXTENT,
    global: true,
    worldExtent: WORLD_EXTENT,
    getPointResolution: function getPointResolution(resolution, point) {
      return resolution / (0, _math.cosh)(point[1] / RADIUS);
    }
  });
}
(0, _index.inherits)(EPSG3857Projection, _Projection2.default);

/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array.<module:ol/proj/Projection>}
 */
var PROJECTIONS = exports.PROJECTIONS = [new EPSG3857Projection('EPSG:3857'), new EPSG3857Projection('EPSG:102100'), new EPSG3857Projection('EPSG:102113'), new EPSG3857Projection('EPSG:900913'), new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'), new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'), new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')];

/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  var halfSize = HALF_SIZE;
  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = RADIUS * Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));
    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }
    output[i + 1] = y;
  }
  return output;
}

/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */
function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}

/***/ }),

/***/ "./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROJECTIONS = exports.METERS_PER_UNIT = exports.EXTENT = exports.RADIUS = undefined;

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _Projection = __webpack_require__(/*! ../proj/Projection.js */ "./node_modules/ol/proj/Projection.js");

var _Projection2 = _interopRequireDefault(_Projection);

var _Units = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");

var _Units2 = _interopRequireDefault(_Units);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var RADIUS = exports.RADIUS = 6378137;

/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {module:ol/extent~Extent}
 */
/**
 * @module ol/proj/epsg4326
 */
var EXTENT = exports.EXTENT = [-180, -90, 180, 90];

/**
 * @const
 * @type {number}
 */
var METERS_PER_UNIT = exports.METERS_PER_UNIT = Math.PI * RADIUS / 180;

/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 *
 * @constructor
 * @extends {module:ol/proj/Projection}
 * @param {string} code Code.
 * @param {string=} opt_axisOrientation Axis orientation.
 */
function EPSG4326Projection(code, opt_axisOrientation) {
  _Projection2.default.call(this, {
    code: code,
    units: _Units2.default.DEGREES,
    extent: EXTENT,
    axisOrientation: opt_axisOrientation,
    global: true,
    metersPerUnit: METERS_PER_UNIT,
    worldExtent: EXTENT
  });
}
(0, _index.inherits)(EPSG4326Projection, _Projection2.default);

/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array.<module:ol/proj/Projection>}
 */
var PROJECTIONS = exports.PROJECTIONS = [new EPSG4326Projection('CRS:84'), new EPSG4326Projection('EPSG:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'), new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'), new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu')];

/***/ }),

/***/ "./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.get = get;
exports.add = add;
/**
 * @module ol/proj/projections
 */

/**
 * @type {Object.<string, module:ol/proj/Projection>}
 */
var cache = {};

/**
 * Clear the projections cache.
 */
function clear() {
  cache = {};
}

/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {module:ol/proj/Projection} The projection (if cached).
 */
function get(code) {
  return cache[code] || null;
}

/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {module:ol/proj/Projection} projection The projection to cache.
 */
function add(code, projection) {
  cache[code] = projection;
}

/***/ }),

/***/ "./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.add = add;
exports.remove = remove;
exports.get = get;

var _obj = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");

/**
 * @private
 * @type {!Object.<string, Object.<string, module:ol/proj~TransformFunction>>}
 */
var transforms = {};

/**
 * Clear the transform cache.
 */
/**
 * @module ol/proj/transforms
 */
function clear() {
  transforms = {};
}

/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {module:ol/proj/Projection} source Source.
 * @param {module:ol/proj/Projection} destination Destination.
 * @param {module:ol/proj~TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}

/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {module:ol/proj/Projection} source Source projection.
 * @param {module:ol/proj/Projection} destination Destination projection.
 * @return {module:ol/proj~TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if ((0, _obj.isEmpty)(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
}

/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {module:ol/proj~TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
  var transform = void 0;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
}

/***/ }),

/***/ "./node_modules/ol/reproj.js":
/*!***********************************!*\
  !*** ./node_modules/ol/reproj.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateSourceResolution = calculateSourceResolution;
exports.render = render;

var _dom = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");

var _extent = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");

var _math = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");

var _proj = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {module:ol/proj/Projection} sourceProj Source projection.
 * @param {module:ol/proj/Projection} targetProj Target projection.
 * @param {module:ol/coordinate~Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
/**
 * @module ol/reproj
 */
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {

  var sourceCenter = (0, _proj.transform)(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  var sourceResolution = (0, _proj.getPointResolution)(targetProj, targetResolution, targetCenter);

  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  var sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || (0, _extent.containsCoordinate)(sourceExtent, sourceCenter)) {
    var compensationFactor = (0, _proj.getPointResolution)(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}

/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {module:ol/coordinate~Coordinate} New point 1 px farther from the centroid.
 */
function enlargeClipPoint(centroidX, centroidY, x, y) {
  var dX = x - centroidX;
  var dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
}

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {module:ol/extent~Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {module:ol/extent~Extent} targetExtent Target extent.
 * @param {module:ol/reproj/Triangulation} triangulation
 * Calculated triangulation.
 * @param {Array.<{extent: module:ol/extent~Extent,
 *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources
 * Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {

  var context = (0, _dom.createCanvasContext2D)(Math.round(pixelRatio * width), Math.round(pixelRatio * height));

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  var sourceDataExtent = (0, _extent.createEmpty)();
  sources.forEach(function (src, i, arr) {
    (0, _extent.extend)(sourceDataExtent, src.extent);
  });

  var canvasWidthInUnits = (0, _extent.getWidth)(sourceDataExtent);
  var canvasHeightInUnits = (0, _extent.getHeight)(sourceDataExtent);
  var stitchContext = (0, _dom.createCanvasContext2D)(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  var stitchScale = pixelRatio / sourceResolution;

  sources.forEach(function (src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = (0, _extent.getWidth)(src.extent);
    var srcHeight = (0, _extent.getHeight)(src.extent);

    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
  });

  var targetTopLeft = (0, _extent.getTopLeft)(targetExtent);

  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0],
        y0 = source[0][1];
    var x1 = source[1][0],
        y1 = source[1][1];
    var x2 = source[2][0],
        y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;

    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
    var affineCoefs = (0, _math.solveLinearSystem)(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3;
    var centroidY = (v0 + v1 + v2) / 3;
    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);
    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);
    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);

    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();

    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);

    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);

    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);

    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();

    context.strokeStyle = 'black';
    context.lineWidth = 1;

    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });

    context.restore();
  }
  return context.canvas;
}

/***/ }),

/***/ "./node_modules/ol/reproj/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/reproj/Tile.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _Tile = __webpack_require__(/*! ../Tile.js */ "./node_modules/ol/Tile.js");

var _Tile2 = _interopRequireDefault(_Tile);

var _TileState = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _events = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");

var _EventType = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

var _extent = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");

var _math = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");

var _reproj = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");

var _Triangulation = __webpack_require__(/*! ../reproj/Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");

var _Triangulation2 = _interopRequireDefault(_Triangulation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {function(number, number, number, number) : module:ol/Tile} FunctionType
 */

/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 * @constructor
 * @extends {module:ol/Tile}
 * @param {module:ol/proj/Projection} sourceProj Source projection.
 * @param {module:ol/tilegrid/TileGrid} sourceTileGrid Source tile grid.
 * @param {module:ol/proj/Projection} targetProj Target projection.
 * @param {module:ol/tilegrid/TileGrid} targetTileGrid Target tile grid.
 * @param {module:ol/tilecoord~TileCoord} tileCoord Coordinate of the tile.
 * @param {module:ol/tilecoord~TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} gutter Gutter of the source tiles.
 * @param {module:ol/reproj/Tile~FunctionType} getTileFunction
 *     Function returning source tiles (z, x, y, pixelRatio).
 * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 */
/**
 * @module ol/reproj/Tile
 */
var ReprojTile = function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {
  _Tile2.default.call(this, tileCoord, _TileState2.default.IDLE);

  /**
   * @private
   * @type {boolean}
   */
  this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;

  /**
   * @private
   * @type {number}
   */
  this.pixelRatio_ = pixelRatio;

  /**
   * @private
   * @type {number}
   */
  this.gutter_ = gutter;

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = null;

  /**
   * @private
   * @type {module:ol/tilegrid/TileGrid}
   */
  this.sourceTileGrid_ = sourceTileGrid;

  /**
   * @private
   * @type {module:ol/tilegrid/TileGrid}
   */
  this.targetTileGrid_ = targetTileGrid;

  /**
   * @private
   * @type {module:ol/tilecoord~TileCoord}
   */
  this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

  /**
   * @private
   * @type {!Array.<module:ol/Tile>}
   */
  this.sourceTiles_ = [];

  /**
   * @private
   * @type {Array.<module:ol/events~EventsKey>}
   */
  this.sourcesListenerKeys_ = null;

  /**
   * @private
   * @type {number}
   */
  this.sourceZ_ = 0;

  var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
  var maxTargetExtent = this.targetTileGrid_.getExtent();
  var maxSourceExtent = this.sourceTileGrid_.getExtent();

  var limitedTargetExtent = maxTargetExtent ? (0, _extent.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;

  if ((0, _extent.getArea)(limitedTargetExtent) === 0) {
    // Tile is completely outside range -> EMPTY
    // TODO: is it actually correct that the source even creates the tile ?
    this.state = _TileState2.default.EMPTY;
    return;
  }

  var sourceProjExtent = sourceProj.getExtent();
  if (sourceProjExtent) {
    if (!maxSourceExtent) {
      maxSourceExtent = sourceProjExtent;
    } else {
      maxSourceExtent = (0, _extent.getIntersection)(maxSourceExtent, sourceProjExtent);
    }
  }

  var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);

  var targetCenter = (0, _extent.getCenter)(limitedTargetExtent);
  var sourceResolution = (0, _reproj.calculateSourceResolution)(sourceProj, targetProj, targetCenter, targetResolution);

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    // invalid sourceResolution -> EMPTY
    // probably edges of the projections when no extent is defined
    this.state = _TileState2.default.EMPTY;
    return;
  }

  var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : _common.ERROR_THRESHOLD;

  /**
   * @private
   * @type {!module:ol/reproj/Triangulation}
   */
  this.triangulation_ = new _Triangulation2.default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);

  if (this.triangulation_.getTriangles().length === 0) {
    // no valid triangles -> EMPTY
    this.state = _TileState2.default.EMPTY;
    return;
  }

  this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
  var sourceExtent = this.triangulation_.calculateSourceExtent();

  if (maxSourceExtent) {
    if (sourceProj.canWrapX()) {
      sourceExtent[1] = (0, _math.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
      sourceExtent[3] = (0, _math.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
    } else {
      sourceExtent = (0, _extent.getIntersection)(sourceExtent, maxSourceExtent);
    }
  }

  if (!(0, _extent.getArea)(sourceExtent)) {
    this.state = _TileState2.default.EMPTY;
  } else {
    var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);

    for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
      for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
        var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
        if (tile) {
          this.sourceTiles_.push(tile);
        }
      }
    }

    if (this.sourceTiles_.length === 0) {
      this.state = _TileState2.default.EMPTY;
    }
  }
};

(0, _index.inherits)(ReprojTile, _Tile2.default);

/**
 * @inheritDoc
 */
ReprojTile.prototype.disposeInternal = function () {
  if (this.state == _TileState2.default.LOADING) {
    this.unlistenSources_();
  }
  _Tile2.default.prototype.disposeInternal.call(this);
};

/**
 * Get the HTML Canvas element for this tile.
 * @return {HTMLCanvasElement} Canvas.
 */
ReprojTile.prototype.getImage = function () {
  return this.canvas_;
};

/**
 * @private
 */
ReprojTile.prototype.reproject_ = function () {
  var sources = [];
  this.sourceTiles_.forEach(function (tile, i, arr) {
    if (tile && tile.getState() == _TileState2.default.LOADED) {
      sources.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
        image: tile.getImage()
      });
    }
  }.bind(this));
  this.sourceTiles_.length = 0;

  if (sources.length === 0) {
    this.state = _TileState2.default.ERROR;
  } else {
    var z = this.wrappedTileCoord_[0];
    var size = this.targetTileGrid_.getTileSize(z);
    var width = typeof size === 'number' ? size : size[0];
    var height = typeof size === 'number' ? size : size[1];
    var targetResolution = this.targetTileGrid_.getResolution(z);
    var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);

    var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
    this.canvas_ = (0, _reproj.render)(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);

    this.state = _TileState2.default.LOADED;
  }
  this.changed();
};

/**
 * @inheritDoc
 */
ReprojTile.prototype.load = function () {
  if (this.state == _TileState2.default.IDLE) {
    this.state = _TileState2.default.LOADING;
    this.changed();

    var leftToLoad = 0;

    this.sourcesListenerKeys_ = [];
    this.sourceTiles_.forEach(function (tile, i, arr) {
      var state = tile.getState();
      if (state == _TileState2.default.IDLE || state == _TileState2.default.LOADING) {
        leftToLoad++;

        var sourceListenKey = (0, _events.listen)(tile, _EventType2.default.CHANGE, function (e) {
          var state = tile.getState();
          if (state == _TileState2.default.LOADED || state == _TileState2.default.ERROR || state == _TileState2.default.EMPTY) {
            (0, _events.unlistenByKey)(sourceListenKey);
            leftToLoad--;
            if (leftToLoad === 0) {
              this.unlistenSources_();
              this.reproject_();
            }
          }
        }, this);
        this.sourcesListenerKeys_.push(sourceListenKey);
      }
    }.bind(this));

    this.sourceTiles_.forEach(function (tile, i, arr) {
      var state = tile.getState();
      if (state == _TileState2.default.IDLE) {
        tile.load();
      }
    });

    if (leftToLoad === 0) {
      setTimeout(this.reproject_.bind(this), 0);
    }
  }
};

/**
 * @private
 */
ReprojTile.prototype.unlistenSources_ = function () {
  this.sourcesListenerKeys_.forEach(_events.unlistenByKey);
  this.sourcesListenerKeys_ = null;
};
exports.default = ReprojTile;

/***/ }),

/***/ "./node_modules/ol/reproj/Triangulation.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/reproj/Triangulation.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extent = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");

var _math = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");

var _proj = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");

/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array.<module:ol/coordinate~Coordinate>} source
 * @property {Array.<module:ol/coordinate~Coordinate>} target
 */

/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
var MAX_SUBDIVISION = 10;

/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
/**
 * @module ol/reproj/Triangulation
 */
var MAX_TRIANGLE_WIDTH = 0.25;

/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 *
 * @param {module:ol/proj/Projection} sourceProj Source projection.
 * @param {module:ol/proj/Projection} targetProj Target projection.
 * @param {module:ol/extent~Extent} targetExtent Target extent to triangulate.
 * @param {module:ol/extent~Extent} maxSourceExtent Maximal source extent that can be used.
 * @param {number} errorThreshold Acceptable error (in source units).
 * @constructor
 */
var Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {

  /**
   * @type {module:ol/proj/Projection}
   * @private
   */
  this.sourceProj_ = sourceProj;

  /**
   * @type {module:ol/proj/Projection}
   * @private
   */
  this.targetProj_ = targetProj;

  /** @type {!Object.<string, module:ol/coordinate~Coordinate>} */
  var transformInvCache = {};
  var transformInv = (0, _proj.getTransform)(this.targetProj_, this.sourceProj_);

  /**
   * @param {module:ol/coordinate~Coordinate} c A coordinate.
   * @return {module:ol/coordinate~Coordinate} Transformed coordinate.
   * @private
   */
  this.transformInv_ = function (c) {
    var key = c[0] + '/' + c[1];
    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }
    return transformInvCache[key];
  };

  /**
   * @type {module:ol/extent~Extent}
   * @private
   */
  this.maxSourceExtent_ = maxSourceExtent;

  /**
   * @type {number}
   * @private
   */
  this.errorThresholdSquared_ = errorThreshold * errorThreshold;

  /**
   * @type {Array.<module:ol/reproj/Triangulation~Triangle>}
   * @private
   */
  this.triangles_ = [];

  /**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */
  this.wrapsXInSource_ = false;

  /**
   * @type {boolean}
   * @private
   */
  this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && (0, _extent.getWidth)(maxSourceExtent) == (0, _extent.getWidth)(this.sourceProj_.getExtent());

  /**
   * @type {?number}
   * @private
   */
  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? (0, _extent.getWidth)(this.sourceProj_.getExtent()) : null;

  /**
   * @type {?number}
   * @private
   */
  this.targetWorldWidth_ = this.targetProj_.getExtent() ? (0, _extent.getWidth)(this.targetProj_.getExtent()) : null;

  var destinationTopLeft = (0, _extent.getTopLeft)(targetExtent);
  var destinationTopRight = (0, _extent.getTopRight)(targetExtent);
  var destinationBottomRight = (0, _extent.getBottomRight)(targetExtent);
  var destinationBottomLeft = (0, _extent.getBottomLeft)(targetExtent);
  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);

  this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, MAX_SUBDIVISION);

  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function (triangle, i, arr) {
      leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    });

    // Shift triangles to be as close to `leftBound` as possible
    // (if the distance is more than `worldWidth / 2` it can be closer.
    this.triangles_.forEach(function (triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];
        if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }
        if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }
        if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        }

        // Rarely (if the extent contains both the dateline and prime meridian)
        // the shift can in turn break some triangles.
        // Detect this here and don't shift in such cases.
        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        if (maxX - minX < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }.bind(this));
  }

  transformInvCache = {};
};

/**
 * Adds triangle to the triangulation.
 * @param {module:ol/coordinate~Coordinate} a The target a coordinate.
 * @param {module:ol/coordinate~Coordinate} b The target b coordinate.
 * @param {module:ol/coordinate~Coordinate} c The target c coordinate.
 * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.
 * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.
 * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.
 * @private
 */
Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({
    source: [aSrc, bSrc, cSrc],
    target: [a, b, c]
  });
};

/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {module:ol/coordinate~Coordinate} a The target a coordinate.
 * @param {module:ol/coordinate~Coordinate} b The target b coordinate.
 * @param {module:ol/coordinate~Coordinate} c The target c coordinate.
 * @param {module:ol/coordinate~Coordinate} d The target d coordinate.
 * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.
 * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.
 * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.
 * @param {module:ol/coordinate~Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */
Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {

  var sourceQuadExtent = (0, _extent.boundingExtent)([aSrc, bSrc, cSrc, dSrc]);
  var sourceCoverageX = this.sourceWorldWidth_ ? (0, _extent.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;

  // when the quad is wrapped in the source projection
  // it covers most of the projection extent, but not fully
  var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;

  var needsSubdivision = false;

  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = (0, _extent.boundingExtent)([a, b, c, d]);
      var targetCoverageX = (0, _extent.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision |= targetCoverageX > MAX_TRIANGLE_WIDTH;
    }
    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision |= sourceCoverageX > MAX_TRIANGLE_WIDTH;
    }
  }

  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!(0, _extent.intersects)(sourceQuadExtent, this.maxSourceExtent_)) {
      // whole quad outside source projection extent -> ignore
      return;
    }
  }

  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }

  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);

      var dx = void 0;
      if (wrapsX) {
        var centerSrcEstimX = ((0, _math.modulo)(aSrc[0], sourceWorldWidth) + (0, _math.modulo)(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX - (0, _math.modulo)(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }
      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }
    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        // split horizontally (top & bottom)
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);

        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        // split vertically (left & right)
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);

        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }
      return;
    }
  }

  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }
    this.wrapsXInSource_ = true;
  }

  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};

/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {module:ol/extent~Extent} Calculated extent.
 */
Triangulation.prototype.calculateSourceExtent = function () {
  var extent = (0, _extent.createEmpty)();

  this.triangles_.forEach(function (triangle, i, arr) {
    var src = triangle.source;
    (0, _extent.extendCoordinate)(extent, src[0]);
    (0, _extent.extendCoordinate)(extent, src[1]);
    (0, _extent.extendCoordinate)(extent, src[2]);
  });

  return extent;
};

/**
 * @return {Array.<module:ol/reproj/Triangulation~Triangle>} Array of the calculated triangles.
 */
Triangulation.prototype.getTriangles = function () {
  return this.triangles_;
};
exports.default = Triangulation;

/***/ }),

/***/ "./node_modules/ol/reproj/common.js":
/*!******************************************!*\
  !*** ./node_modules/ol/reproj/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = exports.ERROR_THRESHOLD = 0.5;

/**
 * Enable automatic reprojection of raster sources. Default is `true`.
 * TODO: decide if we want to expose this as a build flag or remove it
 * @type {boolean}
 */
var ENABLE_RASTER_REPROJECTION = exports.ENABLE_RASTER_REPROJECTION = true;

/***/ }),

/***/ "./node_modules/ol/size.js":
/*!*********************************!*\
  !*** ./node_modules/ol/size.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buffer = buffer;
exports.hasArea = hasArea;
exports.scale = scale;
exports.toSize = toSize;
/**
 * @module ol/size
 */

/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array.<number>} Size
 * @api
 */

/**
 * Returns a buffered size.
 * @param {module:ol/size~Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {module:ol/size~Size=} opt_size Optional reusable size array.
 * @return {module:ol/size~Size} The buffered size.
 */
function buffer(size, num, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}

/**
 * Determines if a size has a positive area.
 * @param {module:ol/size~Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}

/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {module:ol/size~Size} size Size.
 * @param {number} ratio Ratio.
 * @param {module:ol/size~Size=} opt_size Optional reusable size array.
 * @return {module:ol/size~Size} The scaled size.
 */
function scale(size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
}

/**
 * Returns an `module:ol/size~Size` array for the passed in number (meaning: square) or
 * `module:ol/size~Size` array.
 * (meaning: non-square),
 * @param {number|module:ol/size~Size} size Width and height.
 * @param {module:ol/size~Size=} opt_size Optional reusable size array.
 * @return {module:ol/size~Size} Size.
 * @api
 */
function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] = /** @type {number} */size;
    }
    return opt_size;
  }
}

/***/ }),

/***/ "./node_modules/ol/source/Source.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Source.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _functions = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");

var _Object = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");

var _Object2 = _interopRequireDefault(_Object);

var _proj = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");

var _State = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");

var _State2 = _interopRequireDefault(_State);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A function that returns a string or an array of strings representing source
 * attributions.
 *
 * @typedef {function(module:ol/PluggableMap~FrameState): (string|Array.<string>)} Attribution
 */

/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)
 *
 * @typedef {string|Array.<string>|module:ol/source/Source~Attribution} AttributionLike
 */

/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions]
 * @property {module:ol/proj~ProjectionLike} projection
 * @property {module:ol/source/State} [state]
 * @property {boolean} [wrapX]
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {module:ol/Object}
 * @param {module:ol/source/Source~Options} options Source options.
 * @api
 */
var Source = function Source(options) {

  _Object2.default.call(this);

  /**
   * @private
   * @type {module:ol/proj/Projection}
   */
  this.projection_ = (0, _proj.get)(options.projection);

  /**
   * @private
   * @type {?module:ol/source/Source~Attribution}
   */
  this.attributions_ = this.adaptAttributions_(options.attributions);

  /**
   * @private
   * @type {module:ol/source/State}
   */
  this.state_ = options.state !== undefined ? options.state : _State2.default.READY;

  /**
   * @private
   * @type {boolean}
   */
  this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
}; /**
    * @module ol/source/Source
    */


(0, _index.inherits)(Source, _Object2.default);

/**
 * Turns the attributions option into an attributions function.
 * @param {module:ol/source/Source~AttributionLike|undefined} attributionLike The attribution option.
 * @return {?module:ol/source/Source~Attribution} An attribution function (or null).
 */
Source.prototype.adaptAttributions_ = function (attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function (frameState) {
    return [attributionLike];
  };
};

/**
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.
 * @param {function((module:ol/Feature|module:ol/render/Feature)): T} callback Feature callback.
 * @return {T|undefined} Callback result.
 * @template T
 */
Source.prototype.forEachFeatureAtCoordinate = _functions.UNDEFINED;

/**
 * Get the attribution function for the source.
 * @return {?module:ol/source/Source~Attribution} Attribution function.
 */
Source.prototype.getAttributions = function () {
  return this.attributions_;
};

/**
 * Get the projection of the source.
 * @return {module:ol/proj/Projection} Projection.
 * @api
 */
Source.prototype.getProjection = function () {
  return this.projection_;
};

/**
 * @abstract
 * @return {Array.<number>|undefined} Resolutions.
 */
Source.prototype.getResolutions = function () {};

/**
 * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
 * @return {module:ol/source/State} State.
 * @api
 */
Source.prototype.getState = function () {
  return this.state_;
};

/**
 * @return {boolean|undefined} Wrap X.
 */
Source.prototype.getWrapX = function () {
  return this.wrapX_;
};

/**
 * Refreshes the source and finally dispatches a 'change' event.
 * @api
 */
Source.prototype.refresh = function () {
  this.changed();
};

/**
 * Set the attributions of the source.
 * @param {module:ol/source/Source~AttributionLike|undefined} attributions Attributions.
 *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,
 *     or `undefined`.
 * @api
 */
Source.prototype.setAttributions = function (attributions) {
  this.attributions_ = this.adaptAttributions_(attributions);
  this.changed();
};

/**
 * Set the state of the source.
 * @param {module:ol/source/State} state State.
 * @protected
 */
Source.prototype.setState = function (state) {
  this.state_ = state;
  this.changed();
};
exports.default = Source;

/***/ }),

/***/ "./node_modules/ol/source/State.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/source/State.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/source/State
 */

/**
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 * @enum {string}
 */
exports.default = {
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
};

/***/ }),

/***/ "./node_modules/ol/source/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/Tile.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TileSourceEvent = undefined;

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _functions = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");

var _TileCache = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");

var _TileCache2 = _interopRequireDefault(_TileCache);

var _TileState = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _Event = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");

var _Event2 = _interopRequireDefault(_Event);

var _proj = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");

var _size = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");

var _Source = __webpack_require__(/*! ../source/Source.js */ "./node_modules/ol/source/Source.js");

var _Source2 = _interopRequireDefault(_Source);

var _tilecoord = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");

var _tilegrid = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions]
 * @property {number} [cacheSize]
 * @property {module:ol/extent~Extent} [extent]
 * @property {boolean} [opaque]
 * @property {number} [tilePixelRatio]
 * @property {module:ol/proj~ProjectionLike} [projection]
 * @property {module:ol/source/State} [state]
 * @property {module:ol/tilegrid/TileGrid} [tileGrid]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @abstract
 * @extends {module:ol/source/Source}
 * @param {module:ol/source/Tile~Options=} options SourceTile source options.
 * @api
 */
/**
 * @module ol/source/Tile
 */
var TileSource = function TileSource(options) {

  _Source2.default.call(this, {
    attributions: options.attributions,
    extent: options.extent,
    projection: options.projection,
    state: options.state,
    wrapX: options.wrapX
  });

  /**
   * @private
   * @type {boolean}
   */
  this.opaque_ = options.opaque !== undefined ? options.opaque : false;

  /**
   * @private
   * @type {number}
   */
  this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;

  /**
   * @protected
   * @type {module:ol/tilegrid/TileGrid}
   */
  this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

  /**
   * @protected
   * @type {module:ol/TileCache}
   */
  this.tileCache = new _TileCache2.default(options.cacheSize);

  /**
   * @protected
   * @type {module:ol/size~Size}
   */
  this.tmpSize = [0, 0];

  /**
   * @private
   * @type {string}
   */
  this.key_ = '';

  /**
   * @protected
   * @type {module:ol/Tile~Options}
   */
  this.tileOptions = { transition: options.transition };
};

(0, _index.inherits)(TileSource, _Source2.default);

/**
 * @return {boolean} Can expire cache.
 */
TileSource.prototype.canExpireCache = function () {
  return this.tileCache.canExpireCache();
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.
 */
TileSource.prototype.expireCache = function (projection, usedTiles) {
  var tileCache = this.getTileCacheForProjection(projection);
  if (tileCache) {
    tileCache.expireCache(usedTiles);
  }
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @param {number} z Zoom level.
 * @param {module:ol/TileRange} tileRange Tile range.
 * @param {function(module:ol/Tile):(boolean|undefined)} callback Called with each
 *     loaded tile.  If the callback returns `false`, the tile will not be
 *     considered loaded.
 * @return {boolean} The tile range is fully covered with loaded tiles.
 */
TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
  var tileCache = this.getTileCacheForProjection(projection);
  if (!tileCache) {
    return false;
  }

  var covered = true;
  var tile = void 0,
      tileCoordKey = void 0,
      loaded = void 0;
  for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
      loaded = false;
      if (tileCache.containsKey(tileCoordKey)) {
        tile = /** @type {!module:ol/Tile} */tileCache.get(tileCoordKey);
        loaded = tile.getState() === _TileState2.default.LOADED;
        if (loaded) {
          loaded = callback(tile) !== false;
        }
      }
      if (!loaded) {
        covered = false;
      }
    }
  }
  return covered;
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {number} Gutter.
 */
TileSource.prototype.getGutter = function (projection) {
  return 0;
};

/**
 * Return the key to be used for all tiles in the source.
 * @return {string} The key for all tiles.
 * @protected
 */
TileSource.prototype.getKey = function () {
  return this.key_;
};

/**
 * Set the value to be used as the key for all tiles in the source.
 * @param {string} key The key for tiles.
 * @protected
 */
TileSource.prototype.setKey = function (key) {
  if (this.key_ !== key) {
    this.key_ = key;
    this.changed();
  }
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {boolean} Opaque.
 */
TileSource.prototype.getOpaque = function (projection) {
  return this.opaque_;
};

/**
 * @inheritDoc
 */
TileSource.prototype.getResolutions = function () {
  return this.tileGrid.getResolutions();
};

/**
 * @abstract
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {!module:ol/Tile} Tile.
 */
TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {};

/**
 * Return the tile grid of the tile source.
 * @return {module:ol/tilegrid/TileGrid} Tile grid.
 * @api
 */
TileSource.prototype.getTileGrid = function () {
  return this.tileGrid;
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {!module:ol/tilegrid/TileGrid} Tile grid.
 */
TileSource.prototype.getTileGridForProjection = function (projection) {
  if (!this.tileGrid) {
    return (0, _tilegrid.getForProjection)(projection);
  } else {
    return this.tileGrid;
  }
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {module:ol/TileCache} Tile cache.
 * @protected
 */
TileSource.prototype.getTileCacheForProjection = function (projection) {
  var thisProj = this.getProjection();
  if (thisProj && !(0, _proj.equivalent)(thisProj, projection)) {
    return null;
  } else {
    return this.tileCache;
  }
};

/**
 * Get the tile pixel ratio for this source. Subclasses may override this
 * method, which is meant to return a supported pixel ratio that matches the
 * provided `pixelRatio` as close as possible.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Tile pixel ratio.
 */
TileSource.prototype.getTilePixelRatio = function (pixelRatio) {
  return this.tilePixelRatio_;
};

/**
 * @param {number} z Z.
 * @param {number} pixelRatio Pixel ratio.
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {module:ol/size~Size} Tile size.
 */
TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
  var tileGrid = this.getTileGridForProjection(projection);
  var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
  var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z), this.tmpSize);
  if (tilePixelRatio == 1) {
    return tileSize;
  } else {
    return (0, _size.scale)(tileSize, tilePixelRatio, this.tmpSize);
  }
};

/**
 * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
 * is outside the resolution and extent range of the tile grid, `null` will be
 * returned.
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/proj/Projection=} opt_projection Projection.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate to be passed to the tileUrlFunction or
 *     null if no tile URL should be created for the passed `tileCoord`.
 */
TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
  var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
  var tileGrid = this.getTileGridForProjection(projection);
  if (this.getWrapX() && projection.isGlobal()) {
    tileCoord = (0, _tilegrid.wrapX)(tileGrid, tileCoord, projection);
  }
  return (0, _tilecoord.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
};

/**
 * @inheritDoc
 */
TileSource.prototype.refresh = function () {
  this.tileCache.clear();
  this.changed();
};

/**
 * Marks a tile coord as being used, without triggering a load.
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {module:ol/proj/Projection} projection Projection.
 */
TileSource.prototype.useTile = _functions.UNDEFINED;

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {module:ol/events/Event}
 * @param {string} type Type.
 * @param {module:ol/Tile} tile The tile.
 */
var TileSourceEvent = exports.TileSourceEvent = function TileSourceEvent(type, tile) {

  _Event2.default.call(this, type);

  /**
   * The tile related to the event.
   * @type {module:ol/Tile}
   * @api
   */
  this.tile = tile;
};
(0, _index.inherits)(TileSourceEvent, _Event2.default);

exports.default = TileSource;

/***/ }),

/***/ "./node_modules/ol/source/TileEventType.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/TileEventType.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
exports.default = {

  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile~TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile~TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event module:ol/source/Tile~TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'

};

/***/ }),

/***/ "./node_modules/ol/source/TileImage.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/TileImage.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(/*! ../reproj/common.js */ "./node_modules/ol/reproj/common.js");

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _ImageTile = __webpack_require__(/*! ../ImageTile.js */ "./node_modules/ol/ImageTile.js");

var _ImageTile2 = _interopRequireDefault(_ImageTile);

var _TileCache = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");

var _TileCache2 = _interopRequireDefault(_TileCache);

var _TileState = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _events = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");

var _EventType = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

var _proj = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");

var _Tile = __webpack_require__(/*! ../reproj/Tile.js */ "./node_modules/ol/reproj/Tile.js");

var _Tile2 = _interopRequireDefault(_Tile);

var _UrlTile = __webpack_require__(/*! ../source/UrlTile.js */ "./node_modules/ol/source/UrlTile.js");

var _UrlTile2 = _interopRequireDefault(_UrlTile);

var _tilecoord = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");

var _tilegrid = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image} for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {module:ol/proj~ProjectionLike} projection Projection.
 * @property {boolean} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {module:ol/source/State} [state] Source state.
 * @property {module:ol/ImageTile~TileClass} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.
 * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array.<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @fires module:ol/source/Tile~TileSourceEvent
 * @extends {module:ol/source/UrlTile}
 * @param {module:ol/source/TileImage~Options=} options Image tile options.
 * @api
 */
/**
 * @module ol/source/TileImage
 */
var TileImage = function TileImage(options) {

  _UrlTile2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    extent: options.extent,
    opaque: options.opaque,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX,
    transition: options.transition
  });

  /**
   * @protected
   * @type {?string}
   */
  this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;

  /**
   * @protected
   * @type {function(new: module:ol/ImageTile, module:ol/tilecoord~TileCoord, module:ol/TileState, string,
   *        ?string, module:ol/Tile~LoadFunction, module:ol/Tile~Options=)}
   */
  this.tileClass = options.tileClass !== undefined ? options.tileClass : _ImageTile2.default;

  /**
   * @protected
   * @type {!Object.<string, module:ol/TileCache>}
   */
  this.tileCacheForProjection = {};

  /**
   * @protected
   * @type {!Object.<string, module:ol/tilegrid/TileGrid>}
   */
  this.tileGridForProjection = {};

  /**
   * @private
   * @type {number|undefined}
   */
  this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

  /**
   * @private
   * @type {boolean}
   */
  this.renderReprojectionEdges_ = false;
};

(0, _index.inherits)(TileImage, _UrlTile2.default);

/**
 * @inheritDoc
 */
TileImage.prototype.canExpireCache = function () {
  if (!_common.ENABLE_RASTER_REPROJECTION) {
    return _UrlTile2.default.prototype.canExpireCache.call(this);
  }
  if (this.tileCache.canExpireCache()) {
    return true;
  } else {
    for (var key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
  }
  return false;
};

/**
 * @inheritDoc
 */
TileImage.prototype.expireCache = function (projection, usedTiles) {
  if (!_common.ENABLE_RASTER_REPROJECTION) {
    _UrlTile2.default.prototype.expireCache.call(this, projection, usedTiles);
    return;
  }
  var usedTileCache = this.getTileCacheForProjection(projection);

  this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
  for (var id in this.tileCacheForProjection) {
    var tileCache = this.tileCacheForProjection[id];
    tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
  }
};

/**
 * @inheritDoc
 */
TileImage.prototype.getGutter = function (projection) {
  if (_common.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !(0, _proj.equivalent)(this.getProjection(), projection)) {
    return 0;
  } else {
    return this.getGutterInternal();
  }
};

/**
 * @protected
 * @return {number} Gutter.
 */
TileImage.prototype.getGutterInternal = function () {
  return 0;
};

/**
 * @inheritDoc
 */
TileImage.prototype.getOpaque = function (projection) {
  if (_common.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !(0, _proj.equivalent)(this.getProjection(), projection)) {
    return false;
  } else {
    return _UrlTile2.default.prototype.getOpaque.call(this, projection);
  }
};

/**
 * @inheritDoc
 */
TileImage.prototype.getTileGridForProjection = function (projection) {
  if (!_common.ENABLE_RASTER_REPROJECTION) {
    return _UrlTile2.default.prototype.getTileGridForProjection.call(this, projection);
  }
  var thisProj = this.getProjection();
  if (this.tileGrid && (!thisProj || (0, _proj.equivalent)(thisProj, projection))) {
    return this.tileGrid;
  } else {
    var projKey = (0, _index.getUid)(projection).toString();
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = (0, _tilegrid.getForProjection)(projection);
    }
    return (
      /** @type {!module:ol/tilegrid/TileGrid} */this.tileGridForProjection[projKey]
    );
  }
};

/**
 * @inheritDoc
 */
TileImage.prototype.getTileCacheForProjection = function (projection) {
  if (!_common.ENABLE_RASTER_REPROJECTION) {
    return _UrlTile2.default.prototype.getTileCacheForProjection.call(this, projection);
  }
  var thisProj = this.getProjection();if (!thisProj || (0, _proj.equivalent)(thisProj, projection)) {
    return this.tileCache;
  } else {
    var projKey = (0, _index.getUid)(projection).toString();
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new _TileCache2.default(this.tileCache.highWaterMark);
    }
    return this.tileCacheForProjection[projKey];
  }
};

/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {module:ol/proj/Projection} projection Projection.
 * @param {string} key The key set on the tile.
 * @return {!module:ol/Tile} Tile.
 * @private
 */
TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
  var tileCoord = [z, x, y];
  var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
  var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
  var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? _TileState2.default.IDLE : _TileState2.default.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
  tile.key = key;
  (0, _events.listen)(tile, _EventType2.default.CHANGE, this.handleTileChange, this);
  return tile;
};

/**
 * @inheritDoc
 */
TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {
  var sourceProjection = /** @type {!module:ol/proj/Projection} */this.getProjection();
  if (!_common.ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || (0, _proj.equivalent)(sourceProjection, projection)) {
    return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
  } else {
    var cache = this.getTileCacheForProjection(projection);
    var tileCoord = [z, x, y];
    var tile = void 0;
    var tileCoordKey = (0, _tilecoord.getKey)(tileCoord);
    if (cache.containsKey(tileCoordKey)) {
      tile = /** @type {!module:ol/Tile} */cache.get(tileCoordKey);
    }
    var key = this.getKey();
    if (tile && tile.key == key) {
      return tile;
    } else {
      var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
      var targetTileGrid = this.getTileGridForProjection(projection);
      var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var newTile = new _Tile2.default(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutterInternal(), function (z, x, y, pixelRatio) {
        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
      }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_);
      newTile.key = key;

      if (tile) {
        newTile.interimTile = tile;
        newTile.refreshInterimChain();
        cache.replace(tileCoordKey, newTile);
      } else {
        cache.set(tileCoordKey, newTile);
      }
      return newTile;
    }
  }
};

/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {!module:ol/proj/Projection} projection Projection.
 * @return {!module:ol/Tile} Tile.
 * @protected
 */
TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
  var tile = null;
  var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
  var key = this.getKey();
  if (!this.tileCache.containsKey(tileCoordKey)) {
    tile = this.createTile_(z, x, y, pixelRatio, projection, key);
    this.tileCache.set(tileCoordKey, tile);
  } else {
    tile = this.tileCache.get(tileCoordKey);
    if (tile.key != key) {
      // The source's params changed. If the tile has an interim tile and if we
      // can use it then we use it. Otherwise we create a new tile.  In both
      // cases we attempt to assign an interim tile to the new tile.
      var interimTile = tile;
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);

      //make the new tile the head of the list,
      if (interimTile.getState() == _TileState2.default.IDLE) {
        //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
        tile.interimTile = interimTile.interimTile;
      } else {
        tile.interimTile = interimTile;
      }
      tile.refreshInterimChain();
      this.tileCache.replace(tileCoordKey, tile);
    }
  }
  return tile;
};

/**
 * Sets whether to render reprojection edges or not (usually for debugging).
 * @param {boolean} render Render the edges.
 * @api
 */
TileImage.prototype.setRenderReprojectionEdges = function (render) {
  if (!_common.ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
    return;
  }
  this.renderReprojectionEdges_ = render;
  for (var id in this.tileCacheForProjection) {
    this.tileCacheForProjection[id].clear();
  }
  this.changed();
};

/**
 * Sets the tile grid to use when reprojecting the tiles to the given
 * projection instead of the default tile grid for the projection.
 *
 * This can be useful when the default tile grid cannot be created
 * (e.g. projection has no extent defined) or
 * for optimization reasons (custom tile size, resolutions, ...).
 *
 * @param {module:ol/proj~ProjectionLike} projection Projection.
 * @param {module:ol/tilegrid/TileGrid} tilegrid Tile grid to use for the projection.
 * @api
 */
TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {
  if (_common.ENABLE_RASTER_REPROJECTION) {
    var proj = (0, _proj.get)(projection);
    if (proj) {
      var projKey = (0, _index.getUid)(proj).toString();
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
};

/**
 * @param {module:ol/ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}

exports.default = TileImage;

/***/ }),

/***/ "./node_modules/ol/source/UrlTile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/UrlTile.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _TileState = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _tileurlfunction = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");

var _Tile = __webpack_require__(/*! ../source/Tile.js */ "./node_modules/ol/source/Tile.js");

var _Tile2 = _interopRequireDefault(_Tile);

var _TileEventType = __webpack_require__(/*! ../source/TileEventType.js */ "./node_modules/ol/source/TileEventType.js");

var _TileEventType2 = _interopRequireDefault(_TileEventType);

var _tilecoord = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions]
 * @property {number} [cacheSize]
 * @property {module:ol/extent~Extent} [extent]
 * @property {boolean} [opaque]
 * @property {module:ol/proj~ProjectionLike} [projection]
 * @property {module:ol/source/State} [state]
 * @property {module:ol/tilegrid/TileGrid} [tileGrid]
 * @property {module:ol/Tile~LoadFunction} tileLoadFunction
 * @property {number} [tilePixelRatio]
 * @property {module:ol/Tile~UrlFunction} [tileUrlFunction]
 * @property {string} [url]
 * @property {Array.<string>} [urls]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 */

/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @constructor
 * @abstract
 * @fires module:ol/source/TileEvent
 * @extends {module:ol/source/Tile}
 * @param {module:ol/source/UrlTile~Options=} options Image tile options.
 */
/**
 * @module ol/source/UrlTile
 */
var UrlTile = function UrlTile(options) {

  _Tile2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    extent: options.extent,
    opaque: options.opaque,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tilePixelRatio: options.tilePixelRatio,
    wrapX: options.wrapX,
    transition: options.transition
  });

  /**
   * @protected
   * @type {module:ol/Tile~LoadFunction}
   */
  this.tileLoadFunction = options.tileLoadFunction;

  /**
   * @protected
   * @type {module:ol/Tile~UrlFunction}
   */
  this.tileUrlFunction = this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : _tileurlfunction.nullTileUrlFunction;

  /**
   * @protected
   * @type {!Array.<string>|null}
   */
  this.urls = null;

  if (options.urls) {
    this.setUrls(options.urls);
  } else if (options.url) {
    this.setUrl(options.url);
  }
  if (options.tileUrlFunction) {
    this.setTileUrlFunction(options.tileUrlFunction);
  }

  /**
   * @private
   * @type {!Object.<number, boolean>}
   */
  this.tileLoadingKeys_ = {};
};

(0, _index.inherits)(UrlTile, _Tile2.default);

/**
 * @type {module:ol/Tile~UrlFunction|undefined}
 * @protected
 */
UrlTile.prototype.fixedTileUrlFunction;

/**
 * Return the tile load function of the source.
 * @return {module:ol/Tile~LoadFunction} TileLoadFunction
 * @api
 */
UrlTile.prototype.getTileLoadFunction = function () {
  return this.tileLoadFunction;
};

/**
 * Return the tile URL function of the source.
 * @return {module:ol/Tile~UrlFunction} TileUrlFunction
 * @api
 */
UrlTile.prototype.getTileUrlFunction = function () {
  return this.tileUrlFunction;
};

/**
 * Return the URLs used for this source.
 * When a tileUrlFunction is used instead of url or urls,
 * null will be returned.
 * @return {!Array.<string>|null} URLs.
 * @api
 */
UrlTile.prototype.getUrls = function () {
  return this.urls;
};

/**
 * Handle tile change events.
 * @param {module:ol/events/Event} event Event.
 * @protected
 */
UrlTile.prototype.handleTileChange = function (event) {
  var tile = /** @type {module:ol/Tile} */event.target;
  var uid = (0, _index.getUid)(tile);
  var tileState = tile.getState();
  var type = void 0;
  if (tileState == _TileState2.default.LOADING) {
    this.tileLoadingKeys_[uid] = true;
    type = _TileEventType2.default.TILELOADSTART;
  } else if (uid in this.tileLoadingKeys_) {
    delete this.tileLoadingKeys_[uid];
    type = tileState == _TileState2.default.ERROR ? _TileEventType2.default.TILELOADERROR : tileState == _TileState2.default.LOADED || tileState == _TileState2.default.ABORT ? _TileEventType2.default.TILELOADEND : undefined;
  }
  if (type != undefined) {
    this.dispatchEvent(new _Tile.TileSourceEvent(type, tile));
  }
};

/**
 * Set the tile load function of the source.
 * @param {module:ol/Tile~LoadFunction} tileLoadFunction Tile load function.
 * @api
 */
UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {
  this.tileCache.clear();
  this.tileLoadFunction = tileLoadFunction;
  this.changed();
};

/**
 * Set the tile URL function of the source.
 * @param {module:ol/Tile~UrlFunction} tileUrlFunction Tile URL function.
 * @param {string=} opt_key Optional new tile key for the source.
 * @api
 */
UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, opt_key) {
  this.tileUrlFunction = tileUrlFunction;
  this.tileCache.pruneExceptNewestZ();
  if (typeof opt_key !== 'undefined') {
    this.setKey(opt_key);
  } else {
    this.changed();
  }
};

/**
 * Set the URL to use for requests.
 * @param {string} url URL.
 * @api
 */
UrlTile.prototype.setUrl = function (url) {
  var urls = this.urls = (0, _tileurlfunction.expandUrl)(url);
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : (0, _tileurlfunction.createFromTemplates)(urls, this.tileGrid), url);
};

/**
 * Set the URLs to use for requests.
 * @param {Array.<string>} urls URLs.
 * @api
 */
UrlTile.prototype.setUrls = function (urls) {
  this.urls = urls;
  var key = urls.join('\n');
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : (0, _tileurlfunction.createFromTemplates)(urls, this.tileGrid), key);
};

/**
 * @inheritDoc
 */
UrlTile.prototype.useTile = function (z, x, y) {
  var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
  if (this.tileCache.containsKey(tileCoordKey)) {
    this.tileCache.get(tileCoordKey);
  }
};
exports.default = UrlTile;

/***/ }),

/***/ "./node_modules/ol/source/XYZ.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/XYZ.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _TileImage = __webpack_require__(/*! ../source/TileImage.js */ "./node_modules/ol/source/TileImage.js");

var _TileImage2 = _interopRequireDefault(_TileImage);

var _tilegrid = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image} for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {boolean} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=18] Optional max zoom level.
 * @property {number} [minZoom=0] Optional min zoom level.
 * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.
 * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|module:ol/size~Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if url or urls are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array.<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`
 * such as:
 *
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 *
 *
 * @constructor
 * @extends {module:ol/source/TileImage}
 * @param {module:ol/source/XYZ~Options=} opt_options XYZ options.
 * @api
 */
var XYZ = function XYZ(opt_options) {
  var options = opt_options || {};
  var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';

  var tileGrid = options.tileGrid !== undefined ? options.tileGrid : (0, _tilegrid.createXYZ)({
    extent: (0, _tilegrid.extentFromProjection)(projection),
    maxZoom: options.maxZoom,
    minZoom: options.minZoom,
    tileSize: options.tileSize
  });

  _TileImage2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    opaque: options.opaque,
    projection: projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileGrid: tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX !== undefined ? options.wrapX : true,
    transition: options.transition
  });
}; /**
    * @module ol/source/XYZ
    */


(0, _index.inherits)(XYZ, _TileImage2.default);
exports.default = XYZ;

/***/ }),

/***/ "./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_RADIUS = undefined;
exports.getDistance = getDistance;
exports.getLength = getLength;
exports.getArea = getArea;
exports.offset = offset;

var _math = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");

var _GeometryType = __webpack_require__(/*! ./geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");

var _GeometryType2 = _interopRequireDefault(_GeometryType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the
 * earth is used (Clarke 1866 Authalic Sphere).
 */

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */

/**
 * @module ol/sphere
 */
var DEFAULT_RADIUS = exports.DEFAULT_RADIUS = 6371008.8;

/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = (0, _math.toRadians)(c1[1]);
  var lat2 = (0, _math.toRadians)(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = (0, _math.toRadians)(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
  var length = 0;
  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
}

/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {module:ol/geom/Geometry} geometry A geometry.
 * @param {module:ol/sphere~SphereMetricOptions=} opt_options Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _GeometryType2.default.GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var length = 0;
  var coordinates = void 0,
      coords = void 0,
      i = void 0,
      ii = void 0,
      j = void 0,
      jj = void 0;
  switch (type) {
    case _GeometryType2.default.POINT:
    case _GeometryType2.default.MULTI_POINT:
      {
        break;
      }
    case _GeometryType2.default.LINE_STRING:
    case _GeometryType2.default.LINEAR_RING:
      {
        coordinates = /** @type {module:ol/geom/SimpleGeometry} */geometry.getCoordinates();
        length = getLengthInternal(coordinates, radius);
        break;
      }
    case _GeometryType2.default.MULTI_LINE_STRING:
    case _GeometryType2.default.POLYGON:
      {
        coordinates = /** @type {module:ol/geom/SimpleGeometry} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += getLengthInternal(coordinates[i], radius);
        }
        break;
      }
    case _GeometryType2.default.MULTI_POLYGON:
      {
        coordinates = /** @type {module:ol/geom/SimpleGeometry} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += getLengthInternal(coords[j], radius);
          }
        }
        break;
      }
    case _GeometryType2.default.GEOMETRY_COLLECTION:
      {
        var geometries = /** @type {module:ol/geom/GeometryCollection} */geometry.getGeometries();
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += getLength(geometries[i], opt_options);
        }
        break;
      }
    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }
  return length;
}

/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];
  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += (0, _math.toRadians)(x2 - x1) * (2 + Math.sin((0, _math.toRadians)(y1)) + Math.sin((0, _math.toRadians)(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2.0;
}

/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {module:ol/geom/Geometry} geometry A geometry.
 * @param {module:ol/sphere~SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _GeometryType2.default.GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var area = 0;
  var coordinates = void 0,
      coords = void 0,
      i = void 0,
      ii = void 0,
      j = void 0,
      jj = void 0;
  switch (type) {
    case _GeometryType2.default.POINT:
    case _GeometryType2.default.MULTI_POINT:
    case _GeometryType2.default.LINE_STRING:
    case _GeometryType2.default.MULTI_LINE_STRING:
    case _GeometryType2.default.LINEAR_RING:
      {
        break;
      }
    case _GeometryType2.default.POLYGON:
      {
        coordinates = /** @type {module:ol/geom/Polygon} */geometry.getCoordinates();
        area = Math.abs(getAreaInternal(coordinates[0], radius));
        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(getAreaInternal(coordinates[i], radius));
        }
        break;
      }
    case _GeometryType2.default.MULTI_POLYGON:
      {
        coordinates = /** @type {module:ol/geom/SimpleGeometry} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(getAreaInternal(coords[0], radius));
          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(getAreaInternal(coords[j], radius));
          }
        }
        break;
      }
    case _GeometryType2.default.GEOMETRY_COLLECTION:
      {
        var geometries = /** @type {module:ol/geom/GeometryCollection} */geometry.getGeometries();
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += getArea(geometries[i], opt_options);
        }
        break;
      }
    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }
  return area;
}

/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {module:ol/coordinate~Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {module:ol/coordinate~Coordinate} The target point.
 */
function offset(c1, distance, bearing, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = (0, _math.toRadians)(c1[1]);
  var lon1 = (0, _math.toRadians)(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [(0, _math.toDegrees)(lon), (0, _math.toDegrees)(lat)];
}

/***/ }),

/***/ "./node_modules/ol/structs/LRUCache.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/structs/LRUCache.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _asserts = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");

var _EventTarget = __webpack_require__(/*! ../events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");

var _EventTarget2 = _interopRequireDefault(_EventTarget);

var _EventType = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Entry
 * @property {string} key_
 * @property {Object} newer
 * @property {Object} older
 * @property {*} value_
 */

/**
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 * @constructor
 * @extends {module:ol/events/EventTarget}
 * @fires module:ol/events/Event~Event
 * @struct
 * @template T
 * @param {number=} opt_highWaterMark High water mark.
 */
/**
 * @module ol/structs/LRUCache
 */
var LRUCache = function LRUCache(opt_highWaterMark) {

  _EventTarget2.default.call(this);

  /**
   * @type {number}
   */
  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;

  /**
   * @private
   * @type {number}
   */
  this.count_ = 0;

  /**
   * @private
   * @type {!Object.<string, module:ol/structs/LRUCache~Entry>}
   */
  this.entries_ = {};

  /**
   * @private
   * @type {?module:ol/structs/LRUCache~Entry}
   */
  this.oldest_ = null;

  /**
   * @private
   * @type {?module:ol/structs/LRUCache~Entry}
   */
  this.newest_ = null;
};

(0, _index.inherits)(LRUCache, _EventTarget2.default);

/**
 * @return {boolean} Can expire cache.
 */
LRUCache.prototype.canExpireCache = function () {
  return this.getCount() > this.highWaterMark;
};

/**
 * FIXME empty description for jsdoc
 */
LRUCache.prototype.clear = function () {
  this.count_ = 0;
  this.entries_ = {};
  this.oldest_ = null;
  this.newest_ = null;
  this.dispatchEvent(_EventType2.default.CLEAR);
};

/**
 * @param {string} key Key.
 * @return {boolean} Contains key.
 */
LRUCache.prototype.containsKey = function (key) {
  return this.entries_.hasOwnProperty(key);
};

/**
 * @param {function(this: S, T, string, module:ol/structs/LRUCache): ?} f The function
 *     to call for every entry from the oldest to the newer. This function takes
 *     3 arguments (the entry value, the entry key and the LRUCache object).
 *     The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 */
LRUCache.prototype.forEach = function (f, opt_this) {
  var entry = this.oldest_;
  while (entry) {
    f.call(opt_this, entry.value_, entry.key_, this);
    entry = entry.newer;
  }
};

/**
 * @param {string} key Key.
 * @return {T} Value.
 */
LRUCache.prototype.get = function (key) {
  var entry = this.entries_[key];
  (0, _asserts.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
  if (entry === this.newest_) {
    return entry.value_;
  } else if (entry === this.oldest_) {
    this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */this.oldest_.newer;
    this.oldest_.older = null;
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }
  entry.newer = null;
  entry.older = this.newest_;
  this.newest_.newer = entry;
  this.newest_ = entry;
  return entry.value_;
};

/**
 * Remove an entry from the cache.
 * @param {string} key The entry key.
 * @return {T} The removed entry.
 */
LRUCache.prototype.remove = function (key) {
  var entry = this.entries_[key];
  (0, _asserts.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
  if (entry === this.newest_) {
    this.newest_ = /** @type {module:ol/structs/LRUCache~Entry} */entry.older;
    if (this.newest_) {
      this.newest_.newer = null;
    }
  } else if (entry === this.oldest_) {
    this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */entry.newer;
    if (this.oldest_) {
      this.oldest_.older = null;
    }
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }
  delete this.entries_[key];
  --this.count_;
  return entry.value_;
};

/**
 * @return {number} Count.
 */
LRUCache.prototype.getCount = function () {
  return this.count_;
};

/**
 * @return {Array.<string>} Keys.
 */
LRUCache.prototype.getKeys = function () {
  var keys = new Array(this.count_);
  var i = 0;
  var entry = void 0;
  for (entry = this.newest_; entry; entry = entry.older) {
    keys[i++] = entry.key_;
  }
  return keys;
};

/**
 * @return {Array.<T>} Values.
 */
LRUCache.prototype.getValues = function () {
  var values = new Array(this.count_);
  var i = 0;
  var entry = void 0;
  for (entry = this.newest_; entry; entry = entry.older) {
    values[i++] = entry.value_;
  }
  return values;
};

/**
 * @return {T} Last value.
 */
LRUCache.prototype.peekLast = function () {
  return this.oldest_.value_;
};

/**
 * @return {string} Last key.
 */
LRUCache.prototype.peekLastKey = function () {
  return this.oldest_.key_;
};

/**
 * Get the key of the newest item in the cache.  Throws if the cache is empty.
 * @return {string} The newest key.
 */
LRUCache.prototype.peekFirstKey = function () {
  return this.newest_.key_;
};

/**
 * @return {T} value Value.
 */
LRUCache.prototype.pop = function () {
  var entry = this.oldest_;
  delete this.entries_[entry.key_];
  if (entry.newer) {
    entry.newer.older = null;
  }
  this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */entry.newer;
  if (!this.oldest_) {
    this.newest_ = null;
  }
  --this.count_;
  return entry.value_;
};

/**
 * @param {string} key Key.
 * @param {T} value Value.
 */
LRUCache.prototype.replace = function (key, value) {
  this.get(key); // update `newest_`
  this.entries_[key].value_ = value;
};

/**
 * @param {string} key Key.
 * @param {T} value Value.
 */
LRUCache.prototype.set = function (key, value) {
  (0, _asserts.assert)(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
  var entry = /** @type {module:ol/structs/LRUCache~Entry} */{
    key_: key,
    newer: null,
    older: this.newest_,
    value_: value
  };
  if (!this.newest_) {
    this.oldest_ = entry;
  } else {
    this.newest_.newer = entry;
  }
  this.newest_ = entry;
  this.entries_[key] = entry;
  ++this.count_;
};

/**
 * Set a maximum number of entries for the cache.
 * @param {number} size Cache size.
 * @api
 */
LRUCache.prototype.setSize = function (size) {
  this.highWaterMark = size;
};

/**
 * Prune the cache.
 */
LRUCache.prototype.prune = function () {
  while (this.canExpireCache()) {
    this.pop();
  }
};
exports.default = LRUCache;

/***/ }),

/***/ "./node_modules/ol/tilecoord.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilecoord.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOrUpdate = createOrUpdate;
exports.getKeyZXY = getKeyZXY;
exports.getKey = getKey;
exports.fromKey = fromKey;
exports.hash = hash;
exports.quadKey = quadKey;
exports.withinExtentAndZ = withinExtentAndZ;
/**
 * @module ol/tilecoord
 */

/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.
 * @typedef {Array.<number>} TileCoord
 * @api
 */

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Tile coordinate.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
}

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}

/**
 * Get the key for a tile coord.
 * @param {module:ol/tilecoord~TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}

/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {module:ol/tilecoord~TileCoord} The tile coord.
 */
function fromKey(key) {
  return key.split('/').map(Number);
}

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */
function quadKey(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i = void 0,
      charCode = void 0;
  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join('');
}

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {!module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var extent = tileGrid.getExtent();
  var tileRange = void 0;
  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}

/***/ }),

/***/ "./node_modules/ol/tilegrid.js":
/*!*************************************!*\
  !*** ./node_modules/ol/tilegrid.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getForProjection = getForProjection;
exports.wrapX = wrapX;
exports.createForExtent = createForExtent;
exports.createXYZ = createXYZ;
exports.createForProjection = createForProjection;
exports.extentFromProjection = extentFromProjection;

var _common = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");

var _size = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");

var _extent = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");

var _Corner = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");

var _Corner2 = _interopRequireDefault(_Corner);

var _obj = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");

var _proj = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");

var _Units = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");

var _Units2 = _interopRequireDefault(_Units);

var _TileGrid = __webpack_require__(/*! ./tilegrid/TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");

var _TileGrid2 = _interopRequireDefault(_TileGrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {!module:ol/tilegrid/TileGrid} Default tile grid for the
 * passed projection.
 */
/**
 * @module ol/tilegrid
 */
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}

/**
 * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);
  if (!(0, _extent.containsCoordinate)(projectionExtent, center)) {
    var worldWidth = (0, _extent.getWidth)(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {module:ol/extent/Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!module:ol/tilegrid/TileGrid} TileGrid instance.
 */
function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _Corner2.default.TOP_LEFT;

  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

  return new _TileGrid2.default({
    extent: extent,
    origin: (0, _extent.getCorner)(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
}

/**
 * @typedef {Object} XYZOptions
 * @property {module:ol/extent~Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the
 * provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|module:ol/size~Size} [tileSize=[256, 256]] Tile size in pixels.
 */

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {module:ol/tilegrid~XYZOptions=} opt_options Tile grid options.
 * @return {!module:ol/tilegrid/TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(opt_options) {
  var options = /** @type {module:ol/tilegrid/TileGrid~Options} */{};
  (0, _obj.assign)(options, opt_options !== undefined ? opt_options : /** @type {module:ol/tilegrid~XYZOptions} */{});
  if (options.extent === undefined) {
    options.extent = (0, _proj.get)('EPSG:3857').getExtent();
  }
  options.resolutions = resolutionsFromExtent(options.extent, options.maxZoom, options.tileSize);
  delete options.maxZoom;

  return new _TileGrid2.default(options);
}

/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @return {!Array.<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : _common.DEFAULT_MAX_ZOOM;

  var height = (0, _extent.getHeight)(extent);
  var width = (0, _extent.getWidth)(extent);

  var tileSize = (0, _size.toSize)(opt_tileSize !== undefined ? opt_tileSize : _common.DEFAULT_TILE_SIZE);
  var maxResolution = Math.max(width / tileSize[0], height / tileSize[1]);

  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}

/**
 * @param {module:ol/proj~ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {module:ol/extent/Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!module:ol/tilegrid/TileGrid} TileGrid instance.
 */
function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}

/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {module:ol/proj~ProjectionLike} projection Projection.
 * @return {module:ol/extent~Extent} Extent.
 */
function extentFromProjection(projection) {
  projection = (0, _proj.get)(projection);
  var extent = projection.getExtent();
  if (!extent) {
    var half = 180 * _proj.METERS_PER_UNIT[_Units2.default.DEGREES] / projection.getMetersPerUnit();
    extent = (0, _extent.createOrUpdate)(-half, -half, half, half);
  }
  return extent;
}

/***/ }),

/***/ "./node_modules/ol/tilegrid/TileGrid.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/tilegrid/TileGrid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(/*! ./common.js */ "./node_modules/ol/tilegrid/common.js");

var _asserts = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");

var _TileRange = __webpack_require__(/*! ../TileRange.js */ "./node_modules/ol/TileRange.js");

var _TileRange2 = _interopRequireDefault(_TileRange);

var _array = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");

var _extent = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");

var _math = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");

var _size = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");

var _tilecoord = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Options
 * @property {module:ol/extent~Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {module:ol/coordinate~Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array.<module:ol/coordinate~Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array.<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array.<module:ol/size~Size>} [sizes] Sizes.
 * @property {number|module:ol/size~Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array.<module:ol/size~Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 *
 * @constructor
 * @param {module:ol/tilegrid/TileGrid~Options} options Tile grid options.
 * @struct
 * @api
 */
/**
 * @module ol/tilegrid/TileGrid
 */
var TileGrid = function TileGrid(options) {

  /**
   * @protected
   * @type {number}
   */
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

  /**
   * @private
   * @type {!Array.<number>}
   */
  this.resolutions_ = options.resolutions;
  (0, _asserts.assert)((0, _array.isSorted)(this.resolutions_, function (a, b) {
    return b - a;
  }, true), 17); // `resolutions` must be sorted in descending order


  // check if we've got a consistent zoom factor and origin
  var zoomFactor = void 0;
  if (!options.origins) {
    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
      if (!zoomFactor) {
        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
      } else {
        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
          zoomFactor = undefined;
          break;
        }
      }
    }
  }

  /**
   * @private
   * @type {number|undefined}
   */
  this.zoomFactor_ = zoomFactor;

  /**
   * @protected
   * @type {number}
   */
  this.maxZoom = this.resolutions_.length - 1;

  /**
   * @private
   * @type {module:ol/coordinate~Coordinate}
   */
  this.origin_ = options.origin !== undefined ? options.origin : null;

  /**
   * @private
   * @type {Array.<module:ol/coordinate~Coordinate>}
   */
  this.origins_ = null;
  if (options.origins !== undefined) {
    this.origins_ = options.origins;
    (0, _asserts.assert)(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
  }

  var extent = options.extent;

  if (extent !== undefined && !this.origin_ && !this.origins_) {
    this.origin_ = (0, _extent.getTopLeft)(extent);
  }

  (0, _asserts.assert)(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

  /**
   * @private
   * @type {Array.<number|module:ol/size~Size>}
   */
  this.tileSizes_ = null;
  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;
    (0, _asserts.assert)(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
  }

  /**
   * @private
   * @type {number|module:ol/size~Size}
   */
  this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _common.DEFAULT_TILE_SIZE : null;
  (0, _asserts.assert)(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

  /**
   * @private
   * @type {module:ol/extent~Extent}
   */
  this.extent_ = extent !== undefined ? extent : null;

  /**
   * @private
   * @type {Array.<module:ol/TileRange>}
   */
  this.fullTileRanges_ = null;

  /**
   * @private
   * @type {module:ol/size~Size}
   */
  this.tmpSize_ = [0, 0];

  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function (size, z) {
      var tileRange = new _TileRange2.default(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else if (extent) {
    this.calculateTileRanges_(extent);
  }
};

/**
 * @private
 * @type {module:ol/tilecoord~TileCoord}
 */
var tmpTileCoord = [0, 0, 0];

/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} zoom Integer zoom level.
 * @param {function(module:ol/tilecoord~TileCoord)} callback Function called with each tile coordinate.
 * @api
 */
TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, module:ol/TileRange): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {module:ol/TileRange=} opt_tileRange Temporary module:ol/TileRange object.
 * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */
TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
  var tileRange = void 0,
      x = void 0,
      y = void 0;
  var tileCoordExtent = null;
  var z = tileCoord[0] - 1;
  if (this.zoomFactor_ === 2) {
    x = tileCoord[1];
    y = tileCoord[2];
  } else {
    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  }
  while (z >= this.minZoom) {
    if (this.zoomFactor_ === 2) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      tileRange = (0, _TileRange.createOrUpdate)(x, x, y, y, opt_tileRange);
    } else {
      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    }
    if (callback.call(opt_this, z, tileRange)) {
      return true;
    }
    --z;
  }
  return false;
};

/**
 * Get the extent for this tile grid, if it was configured.
 * @return {module:ol/extent~Extent} Extent.
 */
TileGrid.prototype.getExtent = function () {
  return this.extent_;
};

/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */
TileGrid.prototype.getMaxZoom = function () {
  return this.maxZoom;
};

/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */
TileGrid.prototype.getMinZoom = function () {
  return this.minZoom;
};

/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {module:ol/coordinate~Coordinate} Origin.
 * @api
 */
TileGrid.prototype.getOrigin = function (z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};

/**
 * Get the resolution for the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {number} Resolution.
 * @api
 */
TileGrid.prototype.getResolution = function (z) {
  return this.resolutions_[z];
};

/**
 * Get the list of resolutions for the tile grid.
 * @return {Array.<number>} Resolutions.
 * @api
 */
TileGrid.prototype.getResolutions = function () {
  return this.resolutions_;
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/TileRange=} opt_tileRange Temporary module:ol/TileRange object.
 * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
 * @return {module:ol/TileRange} Tile range.
 */
TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    if (this.zoomFactor_ === 2) {
      var minX = tileCoord[1] * 2;
      var minY = tileCoord[2] * 2;
      return (0, _TileRange.createOrUpdate)(minX, minX + 1, minY, minY + 1, opt_tileRange);
    }
    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  }
  return null;
};

/**
 * Get the extent for a tile range.
 * @param {number} z Integer zoom level.
 * @param {module:ol/TileRange} tileRange Tile range.
 * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
 * @return {module:ol/extent~Extent} Extent.
 */
TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);
  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return (0, _extent.createOrUpdate)(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get a tile range for the given extent and integer zoom level.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} z Integer zoom level.
 * @param {module:ol/TileRange=} opt_tileRange Temporary tile range object.
 * @return {module:ol/TileRange} Tile range.
 */
TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
  var tileCoord = tmpTileCoord;
  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
  return (0, _TileRange.createOrUpdate)(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @return {module:ol/coordinate~Coordinate} Tile center.
 */
TileGrid.prototype.getTileCoordCenter = function (tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = (0, _size.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
  return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution];
};

/**
 * Get the extent of a tile coordinate.
 *
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/extent~Extent=} opt_extent Temporary extent object.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = (0, _size.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return (0, _extent.createOrUpdate)(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get the tile coordinate for the given map coordinate and resolution.  This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Destination module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};

/**
 * Note that this method should not be called for resolutions that correspond
 * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution (for a non-integer zoom level).
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Temporary module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);
  var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return (0, _tilecoord.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
 * they should have separate implementations.  This method is for integer zoom
 * levels.  The other method should only be called for resolutions corresponding
 * to non-integer zoom levels.
 * @param {number} x Map x coordinate.
 * @param {number} y Map y coordinate.
 * @param {number} z Integer zoom level.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Temporary module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = xFromOrigin / tileSize[0];
  var tileCoordY = yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return (0, _tilecoord.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Destination module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
  return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */
TileGrid.prototype.getTileCoordResolution = function (tileCoord) {
  return this.resolutions_[tileCoord[0]];
};

/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `module:ol/size~Size`, run the result through `module:ol/size~Size.toSize()`.
 * @param {number} z Z.
 * @return {number|module:ol/size~Size} Tile size.
 * @api
 */
TileGrid.prototype.getTileSize = function (z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};

/**
 * @param {number} z Zoom level.
 * @return {module:ol/TileRange} Extent tile range for the specified zoom level.
 */
TileGrid.prototype.getFullTileRange = function (z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};

/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *     If 1, the nearest lower resolution will be used. If -1, the nearest
 *     higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */
TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {
  var z = (0, _array.linearFindNearest)(this.resolutions_, resolution, opt_direction || 0);
  return (0, _math.clamp)(z, this.minZoom, this.maxZoom);
};

/**
 * @param {!module:ol/extent~Extent} extent Extent for this tile grid.
 * @private
 */
TileGrid.prototype.calculateTileRanges_ = function (extent) {
  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);
  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
  }
  this.fullTileRanges_ = fullTileRanges;
};
exports.default = TileGrid;

/***/ }),

/***/ "./node_modules/ol/tilegrid/common.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tilegrid/common.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = exports.DEFAULT_MAX_ZOOM = 42;

/**
 * Default tile size.
 * @type {number}
 */
var DEFAULT_TILE_SIZE = exports.DEFAULT_TILE_SIZE = 256;

/***/ }),

/***/ "./node_modules/ol/tileurlfunction.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tileurlfunction.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFromTemplate = createFromTemplate;
exports.createFromTemplates = createFromTemplates;
exports.createFromTileUrlFunctions = createFromTileUrlFunctions;
exports.nullTileUrlFunction = nullTileUrlFunction;
exports.expandUrl = expandUrl;

var _asserts = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");

var _math = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");

var _tilecoord = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");

/**
 * @param {string} template Template.
 * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @return {module:ol/Tile~UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {module:ol/proj/Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, function () {
          var y = -tileCoord[2] - 1;
          return y.toString();
        }).replace(dashYRegEx, function () {
          var z = tileCoord[0];
          var range = tileGrid.getFullTileRange(z);
          (0, _asserts.assert)(range, 55); // The {-y} placeholder requires a tile grid with extent
          var y = range.getHeight() + tileCoord[2];
          return y.toString();
        });
      }
    }
  );
}

/**
 * @param {Array.<string>} templates Templates.
 * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @return {module:ol/Tile~UrlFunction} Tile URL function.
 */
/**
 * @module ol/tileurlfunction
 */
function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}

/**
 * @param {Array.<module:ol/Tile~UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {module:ol/Tile~UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {module:ol/proj/Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = (0, _tilecoord.hash)(tileCoord);
        var index = (0, _math.modulo)(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}

/**
 * @param {string} url URL.
 * @return {Array.<string>} Array of urls.
 */
function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode = void 0;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    var stop = parseInt(match[2], 10);
    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

/***/ }),

/***/ "./node_modules/ol/webgl.js":
/*!**********************************!*\
  !*** ./node_modules/ol/webgl.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContext = getContext;
/**
 * @module ol/webgl
 */

/**
 * Constants taken from goog.webgl
 */

/**
 * @const
 * @type {number}
 */
var ONE = exports.ONE = 1;

/**
 * @const
 * @type {number}
 */
var SRC_ALPHA = exports.SRC_ALPHA = 0x0302;

/**
 * @const
 * @type {number}
 */
var COLOR_ATTACHMENT0 = exports.COLOR_ATTACHMENT0 = 0x8CE0;

/**
 * @const
 * @type {number}
 */
var COLOR_BUFFER_BIT = exports.COLOR_BUFFER_BIT = 0x00004000;

/**
 * @const
 * @type {number}
 */
var TRIANGLES = exports.TRIANGLES = 0x0004;

/**
 * @const
 * @type {number}
 */
var TRIANGLE_STRIP = exports.TRIANGLE_STRIP = 0x0005;

/**
 * @const
 * @type {number}
 */
var ONE_MINUS_SRC_ALPHA = exports.ONE_MINUS_SRC_ALPHA = 0x0303;

/**
 * @const
 * @type {number}
 */
var ARRAY_BUFFER = exports.ARRAY_BUFFER = 0x8892;

/**
 * @const
 * @type {number}
 */
var ELEMENT_ARRAY_BUFFER = exports.ELEMENT_ARRAY_BUFFER = 0x8893;

/**
 * @const
 * @type {number}
 */
var STREAM_DRAW = exports.STREAM_DRAW = 0x88E0;

/**
 * @const
 * @type {number}
 */
var STATIC_DRAW = exports.STATIC_DRAW = 0x88E4;

/**
 * @const
 * @type {number}
 */
var DYNAMIC_DRAW = exports.DYNAMIC_DRAW = 0x88E8;

/**
 * @const
 * @type {number}
 */
var CULL_FACE = exports.CULL_FACE = 0x0B44;

/**
 * @const
 * @type {number}
 */
var BLEND = exports.BLEND = 0x0BE2;

/**
 * @const
 * @type {number}
 */
var STENCIL_TEST = exports.STENCIL_TEST = 0x0B90;

/**
 * @const
 * @type {number}
 */
var DEPTH_TEST = exports.DEPTH_TEST = 0x0B71;

/**
 * @const
 * @type {number}
 */
var SCISSOR_TEST = exports.SCISSOR_TEST = 0x0C11;

/**
 * @const
 * @type {number}
 */
var UNSIGNED_BYTE = exports.UNSIGNED_BYTE = 0x1401;

/**
 * @const
 * @type {number}
 */
var UNSIGNED_SHORT = exports.UNSIGNED_SHORT = 0x1403;

/**
 * @const
 * @type {number}
 */
var UNSIGNED_INT = exports.UNSIGNED_INT = 0x1405;

/**
 * @const
 * @type {number}
 */
var FLOAT = exports.FLOAT = 0x1406;

/**
 * @const
 * @type {number}
 */
var RGBA = exports.RGBA = 0x1908;

/**
 * @const
 * @type {number}
 */
var FRAGMENT_SHADER = exports.FRAGMENT_SHADER = 0x8B30;

/**
 * @const
 * @type {number}
 */
var VERTEX_SHADER = exports.VERTEX_SHADER = 0x8B31;

/**
 * @const
 * @type {number}
 */
var LINK_STATUS = exports.LINK_STATUS = 0x8B82;

/**
 * @const
 * @type {number}
 */
var LINEAR = exports.LINEAR = 0x2601;

/**
 * @const
 * @type {number}
 */
var TEXTURE_MAG_FILTER = exports.TEXTURE_MAG_FILTER = 0x2800;

/**
 * @const
 * @type {number}
 */
var TEXTURE_MIN_FILTER = exports.TEXTURE_MIN_FILTER = 0x2801;

/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_S = exports.TEXTURE_WRAP_S = 0x2802;

/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_T = exports.TEXTURE_WRAP_T = 0x2803;

/**
 * @const
 * @type {number}
 */
var TEXTURE_2D = exports.TEXTURE_2D = 0x0DE1;

/**
 * @const
 * @type {number}
 */
var TEXTURE0 = exports.TEXTURE0 = 0x84C0;

/**
 * @const
 * @type {number}
 */
var CLAMP_TO_EDGE = exports.CLAMP_TO_EDGE = 0x812F;

/**
 * @const
 * @type {number}
 */
var COMPILE_STATUS = exports.COMPILE_STATUS = 0x8B81;

/**
 * @const
 * @type {number}
 */
var FRAMEBUFFER = exports.FRAMEBUFFER = 0x8D40;

/** end of goog.webgl constants
 */

/**
 * @const
 * @type {Array.<string>}
 */
var CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];

/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object=} opt_attributes Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */
function getContext(canvas, opt_attributes) {
  var ii = CONTEXT_IDS.length;
  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);
      if (context) {
        return (/** @type {!WebGLRenderingContext} */context
        );
      }
    } catch (e) {
      // pass
    }
  }
  return null;
}

/***/ }),

/***/ "./node_modules/webfont-matcher/lib/fonts/google.js":
/*!**********************************************************!*\
  !*** ./node_modules/webfont-matcher/lib/fonts/google.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Generated by CoffeeScript 1.10.0
(function () {
  var families;

  module.exports = {
    icon: 'icons/google.svg',
    name: 'google',
    title: 'Google Fonts',
    link: 'google.com/fonts',
    getNames: function getNames() {
      return families;
    },
    getLink: function getLink(name) {
      return "https://fonts.google.com/specimen/" + name.replace(/( )/g, '+');
    },
    normalizeName: function normalizeName(name) {
      return name;
    }
  };

  families = ["ABeeZee", "Abel", "Abril Fatface", "Aclonica", "Acme", "Actor", "Adamina", "Advent Pro", "Aguafina Script", "Akronim", "Aladin", "Aldrich", "Alef", "Alegreya", "Alegreya SC", "Alegreya Sans", "Alegreya Sans SC", "Alex Brush", "Alfa Slab One", "Alice", "Alike", "Alike Angular", "Allan", "Allerta", "Allerta Stencil", "Allura", "Almendra", "Almendra Display", "Almendra SC", "Amarante", "Amaranth", "Amatic SC", "Amethysta", "Amiri", "Amita", "Anaheim", "Andada", "Andika", "Angkor", "Annie Use Your Telescope", "Anonymous Pro", "Antic", "Antic Didone", "Antic Slab", "Anton", "Arapey", "Arbutus", "Arbutus Slab", "Architects Daughter", "Archivo Black", "Archivo Narrow", "Arimo", "Arizonia", "Armata", "Artifika", "Arvo", "Arya", "Asap", "Asar", "Asset", "Astloch", "Asul", "Atomic Age", "Aubrey", "Audiowide", "Autour One", "Average", "Average Sans", "Averia Gruesa Libre", "Averia Libre", "Averia Sans Libre", "Averia Serif Libre", "Bad Script", "Balthazar", "Bangers", "Basic", "Battambang", "Baumans", "Bayon", "Belgrano", "Belleza", "BenchNine", "Bentham", "Berkshire Swash", "Bevan", "Bigelow Rules", "Bigshot One", "Bilbo", "Bilbo Swash Caps", "Biryani", "Bitter", "Black Ops One", "Bokor", "Bonbon", "Boogaloo", "Bowlby One", "Bowlby One SC", "Brawler", "Bree Serif", "Bubblegum Sans", "Bubbler One", "Buda", "Buenard", "Butcherman", "Butterfly Kids", "Cabin", "Cabin Condensed", "Cabin Sketch", "Caesar Dressing", "Cagliostro", "Calligraffitti", "Cambay", "Cambo", "Candal", "Cantarell", "Cantata One", "Cantora One", "Capriola", "Cardo", "Carme", "Carrois Gothic", "Carrois Gothic SC", "Carter One", "Catamaran", "Caudex", "Caveat", "Caveat Brush", "Cedarville Cursive", "Ceviche One", "Changa One", "Chango", "Chau Philomene One", "Chela One", "Chelsea Market", "Chenla", "Cherry Cream Soda", "Cherry Swash", "Chewy", "Chicle", "Chivo", "Chonburi", "Cinzel", "Cinzel Decorative", "Clicker Script", "Coda", "Coda Caption", "Codystar", "Combo", "Comfortaa", "Coming Soon", "Concert One", "Condiment", "Content", "Contrail One", "Convergence", "Cookie", "Copse", "Corben", "Courgette", "Cousine", "Coustard", "Covered By Your Grace", "Crafty Girls", "Creepster", "Crete Round", "Crimson Text", "Croissant One", "Crushed", "Cuprum", "Cutive", "Cutive Mono", "Damion", "Dancing Script", "Dangrek", "Dawning of a New Day", "Days One", "Dekko", "Delius", "Delius Swash Caps", "Delius Unicase", "Della Respira", "Denk One", "Devonshire", "Dhurjati", "Didact Gothic", "Diplomata", "Diplomata SC", "Domine", "Donegal One", "Doppio One", "Dorsa", "Dosis", "Dr Sugiyama", "Droid Sans", "Droid Sans Mono", "Droid Serif", "Duru Sans", "Dynalight", "EB Garamond", "Eagle Lake", "Eater", "Economica", "Eczar", "Ek Mukta", "Electrolize", "Elsie", "Elsie Swash Caps", "Emblema One", "Emilys Candy", "Engagement", "Englebert", "Enriqueta", "Erica One", "Esteban", "Euphoria Script", "Ewert", "Exo", "Exo 2", "Expletus Sans", "Fanwood Text", "Fascinate", "Fascinate Inline", "Faster One", "Fasthand", "Fauna One", "Federant", "Federo", "Felipa", "Fenix", "Finger Paint", "Fira Mono", "Fira Sans", "Fjalla One", "Fjord One", "Flamenco", "Flavors", "Fondamento", "Fontdiner Swanky", "Forum", "Francois One", "Freckle Face", "Fredericka the Great", "Fredoka One", "Freehand", "Fresca", "Frijole", "Fruktur", "Fugaz One", "GFS Didot", "GFS Neohellenic", "Gabriela", "Gafata", "Galdeano", "Galindo", "Gentium Basic", "Gentium Book Basic", "Geo", "Geostar", "Geostar Fill", "Germania One", "Gidugu", "Gilda Display", "Give You Glory", "Glass Antiqua", "Glegoo", "Gloria Hallelujah", "Goblin One", "Gochi Hand", "Gorditas", "Goudy Bookletter 1911", "Graduate", "Grand Hotel", "Gravitas One", "Great Vibes", "Griffy", "Gruppo", "Gudea", "Gurajada", "Habibi", "Halant", "Hammersmith One", "Hanalei", "Hanalei Fill", "Handlee", "Hanuman", "Happy Monkey", "Headland One", "Henny Penny", "Herr Von Muellerhoff", "Hind", "Hind Siliguri", "Hind Vadodara", "Holtwood One SC", "Homemade Apple", "Homenaje", "IM Fell DW Pica", "IM Fell DW Pica SC", "IM Fell Double Pica", "IM Fell Double Pica SC", "IM Fell English", "IM Fell English SC", "IM Fell French Canon", "IM Fell French Canon SC", "IM Fell Great Primer", "IM Fell Great Primer SC", "Iceberg", "Iceland", "Imprima", "Inconsolata", "Inder", "Indie Flower", "Inika", "Inknut Antiqua", "Irish Grover", "Istok Web", "Italiana", "Italianno", "Itim", "Jacques Francois", "Jacques Francois Shadow", "Jaldi", "Jim Nightshade", "Jockey One", "Jolly Lodger", "Josefin Sans", "Josefin Slab", "Joti One", "Judson", "Julee", "Julius Sans One", "Junge", "Jura", "Just Another Hand", "Just Me Again Down Here", "Kadwa", "Kalam", "Kameron", "Kantumruy", "Karla", "Karma", "Kaushan Script", "Kavoon", "Kdam Thmor", "Keania One", "Kelly Slab", "Kenia", "Khand", "Khmer", "Khula", "Kite One", "Knewave", "Kotta One", "Koulen", "Kranky", "Kreon", "Kristi", "Krona One", "Kurale", "La Belle Aurore", "Laila", "Lakki Reddy", "Lancelot", "Lateef", "Lato", "League Script", "Leckerli One", "Ledger", "Lekton", "Lemon", "Libre Baskerville", "Life Savers", "Lilita One", "Lily Script One", "Limelight", "Linden Hill", "Lobster", "Lobster Two", "Londrina Outline", "Londrina Shadow", "Londrina Sketch", "Londrina Solid", "Lora", "Love Ya Like A Sister", "Loved by the King", "Lovers Quarrel", "Luckiest Guy", "Lusitana", "Lustria", "Macondo", "Macondo Swash Caps", "Magra", "Maiden Orange", "Mako", "Mallanna", "Mandali", "Marcellus", "Marcellus SC", "Marck Script", "Margarine", "Marko One", "Marmelad", "Martel", "Martel Sans", "Marvel", "Mate", "Mate SC", "Maven Pro", "McLaren", "Meddon", "MedievalSharp", "Medula One", "Megrim", "Meie Script", "Merienda", "Merienda One", "Merriweather", "Merriweather Sans", "Metal", "Metal Mania", "Metamorphous", "Metrophobic", "Michroma", "Milonga", "Miltonian", "Miltonian Tattoo", "Miniver", "Miss Fajardose", "Modak", "Modern Antiqua", "Molengo", "Molle", "Monda", "Monofett", "Monoton", "Monsieur La Doulaise", "Montaga", "Montez", "Montserrat", "Montserrat Alternates", "Montserrat Subrayada", "Moul", "Moulpali", "Mountains of Christmas", "Mouse Memoirs", "Mr Bedfort", "Mr Dafoe", "Mr De Haviland", "Mrs Saint Delafield", "Mrs Sheppards", "Muli", "Mystery Quest", "NTR", "Neucha", "Neuton", "New Rocker", "News Cycle", "Niconne", "Nixie One", "Nobile", "Nokora", "Norican", "Nosifer", "Nothing You Could Do", "Noticia Text", "Noto Sans", "Noto Serif", "Nova Cut", "Nova Flat", "Nova Mono", "Nova Oval", "Nova Round", "Nova Script", "Nova Slim", "Nova Square", "Numans", "Nunito", "Odor Mean Chey", "Offside", "Old Standard TT", "Oldenburg", "Oleo Script", "Oleo Script Swash Caps", "Open Sans", "Open Sans Condensed", "Oranienbaum", "Orbitron", "Oregano", "Orienta", "Original Surfer", "Oswald", "Over the Rainbow", "Overlock", "Overlock SC", "Ovo", "Oxygen", "Oxygen Mono", "PT Mono", "PT Sans", "PT Sans Caption", "PT Sans Narrow", "PT Serif", "PT Serif Caption", "Pacifico", "Palanquin", "Palanquin Dark", "Paprika", "Parisienne", "Passero One", "Passion One", "Pathway Gothic One", "Patrick Hand", "Patrick Hand SC", "Patua One", "Paytone One", "Peddana", "Peralta", "Permanent Marker", "Petit Formal Script", "Petrona", "Philosopher", "Piedra", "Pinyon Script", "Pirata One", "Plaster", "Play", "Playball", "Playfair Display", "Playfair Display SC", "Podkova", "Poiret One", "Poller One", "Poly", "Pompiere", "Pontano Sans", "Poppins", "Port Lligat Sans", "Port Lligat Slab", "Pragati Narrow", "Prata", "Preahvihear", "Press Start 2P", "Princess Sofia", "Prociono", "Prosto One", "Puritan", "Purple Purse", "Quando", "Quantico", "Quattrocento", "Quattrocento Sans", "Questrial", "Quicksand", "Quintessential", "Qwigley", "Racing Sans One", "Radley", "Rajdhani", "Raleway", "Raleway Dots", "Ramabhadra", "Ramaraja", "Rambla", "Rammetto One", "Ranchers", "Rancho", "Ranga", "Rationale", "Ravi Prakash", "Redressed", "Reenie Beanie", "Revalia", "Rhodium Libre", "Ribeye", "Ribeye Marrow", "Righteous", "Risque", "Roboto", "Roboto Condensed", "Roboto Mono", "Roboto Slab", "Rochester", "Rock Salt", "Rokkitt", "Romanesco", "Ropa Sans", "Rosario", "Rosarivo", "Rouge Script", "Rozha One", "Rubik", "Rubik Mono One", "Rubik One", "Ruda", "Rufina", "Ruge Boogie", "Ruluko", "Rum Raisin", "Ruslan Display", "Russo One", "Ruthie", "Rye", "Sacramento", "Sahitya", "Sail", "Salsa", "Sanchez", "Sancreek", "Sansita One", "Sarala", "Sarina", "Sarpanch", "Satisfy", "Scada", "Scheherazade", "Schoolbell", "Seaweed Script", "Sevillana", "Seymour One", "Shadows Into Light", "Shadows Into Light Two", "Shanti", "Share", "Share Tech", "Share Tech Mono", "Shojumaru", "Short Stack", "Siemreap", "Sigmar One", "Signika", "Signika Negative", "Simonetta", "Sintony", "Sirin Stencil", "Six Caps", "Skranji", "Slabo 13px", "Slabo 27px", "Slackey", "Smokum", "Smythe", "Sniglet", "Snippet", "Snowburst One", "Sofadi One", "Sofia", "Sonsie One", "Sorts Mill Goudy", "Source Code Pro", "Source Sans Pro", "Source Serif Pro", "Special Elite", "Spicy Rice", "Spinnaker", "Spirax", "Squada One", "Sree Krushnadevaraya", "Stalemate", "Stalinist One", "Stardos Stencil", "Stint Ultra Condensed", "Stint Ultra Expanded", "Stoke", "Strait", "Sue Ellen Francisco", "Sumana", "Sunshiney", "Supermercado One", "Sura", "Suranna", "Suravaram", "Suwannaphum", "Swanky and Moo Moo", "Syncopate", "Tangerine", "Taprom", "Tauri", "Teko", "Telex", "Tenali Ramakrishna", "Tenor Sans", "Text Me One", "The Girl Next Door", "Tienne", "Tillana", "Timmana", "Tinos", "Titan One", "Titillium Web", "Trade Winds", "Trocchi", "Trochut", "Trykker", "Tulpen One", "Ubuntu", "Ubuntu Condensed", "Ubuntu Mono", "Ultra", "Uncial Antiqua", "Underdog", "Unica One", "UnifrakturCook", "UnifrakturMaguntia", "Unkempt", "Unlock", "Unna", "VT323", "Vampiro One", "Varela", "Varela Round", "Vast Shadow", "Vesper Libre", "Vibur", "Vidaloka", "Viga", "Voces", "Volkhov", "Vollkorn", "Voltaire", "Waiting for the Sunrise", "Wallpoet", "Walter Turncoat", "Warnes", "Wellfleet", "Wendy One", "Wire One", "Work Sans", "Yanone Kaffeesatz", "Yantramanav", "Yellowtail", "Yeseva One", "Yesteryear", "Zeyada"];
}).call(undefined);

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "./olms.js":
/*!*****************!*\
  !*** ./olms.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index */ "./index.js");

var _stylefunction = __webpack_require__(/*! ./stylefunction */ "./stylefunction.js");

var _stylefunction2 = _interopRequireDefault(_stylefunction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var olms = {
  apply: _index.apply,
  applyBackground: _index.applyBackground,
  applyStyle: _index.applyStyle,
  stylefunction: _stylefunction2.default
};
if (window) {
  window.olms = olms;
}
exports.default = olms;

/***/ }),

/***/ "./stylefunction.js":
/*!**************************!*\
  !*** ./stylefunction.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValue = getValue;

exports.default = function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, spriteImage, fonts) {
  if (!resolutions) {
    resolutions = [];
    for (var res = 78271.51696402048; resolutions.length < 21; res /= 2) {
      resolutions.push(res);
    }
  }
  if (typeof glStyle == 'string') {
    glStyle = JSON.parse(glStyle);
  }
  if (glStyle.version != 8) {
    throw new Error('glStyle version 8 required.');
  }

  var spriteImgSize = void 0;
  if (spriteImageUrl && !spriteImage) {
    var img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = function () {
      spriteImage = img;
      spriteImgSize = [img.width, img.height];
      olLayer.changed();
    };
    img.src = spriteImageUrl;
  }

  var ctx = document.createElement('CANVAS').getContext('2d');
  var measureCache = {};

  function wrapText(text, font, em) {
    var key = em + ',' + font + ',' + text;
    var wrappedText = measureCache[key];
    if (!wrappedText) {
      ctx.font = font;
      var oneEm = ctx.measureText('M').width;
      var width = oneEm * em;
      var words = text.split(' ');
      var line = '';
      var lines = [];
      for (var i = 0, ii = words.length; i < ii; ++i) {
        var word = words[i];
        if (ctx.measureText(line + word).width <= width) {
          line += (line ? ' ' : '') + word;
        } else {
          if (line) {
            lines.push(line);
          }
          line = word;
        }
      }
      if (line) {
        lines.push(line);
      }
      measureCache[key] = wrappedText = lines.join('\n');
    }
    return wrappedText;
  }

  var allLayers = (0, _mapboxGlStyleSpec.derefLayers)(glStyle.layers);

  var layersBySourceLayer = {};
  var mapboxLayers = [];
  var mapboxSource = void 0;
  for (var i = 0, ii = allLayers.length; i < ii; ++i) {
    var layer = allLayers[i];
    var layerId = layer.id;
    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {
      var sourceLayer = layer['source-layer'];
      if (!mapboxSource) {
        mapboxSource = layer.source;
      }
      var layers = layersBySourceLayer[sourceLayer];
      if (!layers) {
        layers = layersBySourceLayer[sourceLayer] = [];
      }
      layers.push({
        layer: layer,
        index: i
      });
      mapboxLayers.push(layerId);
    }
    // // TODO revisit when diffing gets added
    delete functionCache[layerId];
    delete filterCache[layerId];
  }
  var iconImageCache = {};

  var styles = [];
  var patternCache = {};

  var styleFunction = function styleFunction(feature, resolution) {
    var properties = feature.getProperties();
    feature.styleIds = feature.styleIds || {};
    var layers = layersBySourceLayer[properties.layer];
    if (!layers) {
      return;
    }
    var zoom = resolutions.indexOf(resolution);
    if (zoom == -1) {
      zoom = Math.round((0, _util.getZoomForResolution)(resolution, resolutions));
    }
    var type = types[feature.getGeometry().getType()];
    var f = {
      properties: properties,
      type: type
    };
    var stylesLength = -1;
    for (var _i = 0, _ii = layers.length; _i < _ii; ++_i) {
      var layerData = layers[_i];
      var _layer = layerData.layer;
      var _layerId = _layer.id;

      var layout = _layer.layout || emptyObj;
      var paint = _layer.paint || emptyObj;
      if (layout.visibility === 'none' || 'minzoom' in _layer && zoom < _layer.minzoom || 'maxzoom' in _layer && zoom >= _layer.maxzoom) {
        continue;
      }
      feature.styleIds[zoom] = feature.styleIds[zoom] || [];
      var filter = _layer.filter;
      var icon = void 0,
          iconImg = void 0;
      if (!filter || evaluateFilter(_layerId, filter, f, zoom)) {
        var color = void 0,
            opacity = void 0,
            fill = void 0,
            stroke = void 0,
            strokeColor = void 0,
            style = void 0;
        var index = layerData.index;
        if (type == 3 && _layer.type == 'fill') {
          opacity = getValue(_layer, 'paint', 'fill-opacity', zoom, f);
          if ('fill-pattern' in paint) {
            var iconImage = getValue(_layer, 'paint', 'fill-pattern', zoom, f);
            if (iconImage) {
              icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();
              if (spriteImage && spriteData && spriteData[icon]) {
                ++stylesLength;
                if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                  feature.styleIds[zoom].push(_layerId);
                }
                style = styles[stylesLength];
                if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                  style = styles[stylesLength] = new _Style2.default({
                    fill: new _Fill2.default()
                  });
                }
                fill = style.getFill();
                style.setZIndex(index);
                var icon_cache_key = icon + '.' + opacity;
                var pattern = patternCache[icon_cache_key];
                if (!pattern) {
                  var spriteImageData = spriteData[icon];
                  var canvas = document.createElement('canvas');
                  canvas.width = spriteImageData.width;
                  canvas.height = spriteImageData.height;
                  var _ctx = canvas.getContext('2d');
                  _ctx.globalAlpha = opacity;
                  _ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);
                  pattern = _ctx.createPattern(canvas, 'repeat');
                  patternCache[icon_cache_key] = pattern;
                }
                fill.setColor(pattern);
              }
            }
          } else if ('fill-color' in paint) {
            color = colorWithOpacity(getValue(_layer, 'paint', 'fill-color', zoom, f), opacity);
            if (color) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  fill: new _Fill2.default()
                });
              }
              fill = style.getFill();
              fill.setColor(color);
              style.setZIndex(index);
            }
            if ('fill-outline-color' in paint) {
              strokeColor = colorWithOpacity(getValue(_layer, 'paint', 'fill-outline-color', zoom, properties), opacity);
            } else if ('fill-antialias' in paint) {
              strokeColor = color;
            }
            if (strokeColor) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  stroke: new _Stroke2.default()
                });
              }
              stroke = style.getStroke();
              stroke.setColor(strokeColor);
              stroke.setWidth(1);
              style.setZIndex(index);
            }
          }
        }
        if (type != 1 && _layer.type == 'line') {
          (function () {
            color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(_layer, 'paint', 'line-color', zoom, f), getValue(_layer, 'paint', 'line-opacity', zoom, f)) : undefined;
            var width = getValue(_layer, 'paint', 'line-width', zoom, f);
            if (color && width > 0) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  stroke: new _Stroke2.default()
                });
              }
              stroke = style.getStroke();
              stroke.setLineCap(getValue(_layer, 'layout', 'line-cap', zoom, f));
              stroke.setLineJoin(getValue(_layer, 'layout', 'line-join', zoom, f));
              stroke.setMiterLimit(getValue(_layer, 'layout', 'line-miter-limit', zoom, f));
              stroke.setColor(color);
              stroke.setWidth(width);
              stroke.setLineDash(paint['line-dasharray'] ? getValue(_layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {
                return x * width;
              }) : null);
              style.setZIndex(index);
            }
          })();
        }

        var hasImage = false;
        var text = null;
        var skipLabel = void 0;
        if ((type == 1 || type == 2) && 'icon-image' in layout) {
          var _iconImage = getValue(_layer, 'layout', 'icon-image', zoom, f);
          if (_iconImage) {
            icon = typeof _iconImage === 'string' ? fromTemplate(_iconImage, properties) : _iconImage.toString();
            var styleGeom = undefined;
            if (spriteImage && spriteData && spriteData[icon]) {
              if (type == 2) {
                var geom = feature.getGeometry();
                // ol package and ol-debug.js only
                if (geom.getFlatMidpoint) {
                  var extent = geom.getExtent();
                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));
                  if (size > 150) {
                    //FIXME Do not hard-code a size of 150
                    styleGeom = new _Point2.default(geom.getFlatMidpoint());
                  }
                }
              }
              if (type !== 2 || styleGeom) {
                ++stylesLength;
                if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                  feature.styleIds[zoom].push(_layerId);
                }
                style = styles[stylesLength];
                if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
                  style = styles[stylesLength] = new _Style2.default();
                }
                style.setGeometry(styleGeom);
                var iconSize = getValue(_layer, 'layout', 'icon-size', zoom, f);
                var iconColor = paint['icon-color'] !== undefined ? getValue(_layer, 'paint', 'icon-color', zoom, f) : null;
                var iconTranslate = getValue(_layer, 'paint', 'icon-translate', zoom, f);
                var iconTranslateAnchor = getValue(_layer, 'paint', 'icon-translate-anchor', zoom, f);
                var iconAnchorValue = getValue(_layer, 'layout', 'icon-anchor', zoom, f);
                var iconOffset = getValue(_layer, 'layout', 'icon-offset', zoom, f);

                var _covertIconAnchor = covertIconAnchor(iconAnchorValue),
                    anchorOffset = _covertIconAnchor.anchorOffset,
                    _covertIconAnchor$ico = _covertIconAnchor.iconAnchor,
                    iconAnchor = _covertIconAnchor$ico === undefined ? iconAnchorValue : _covertIconAnchor$ico;

                var _icon_cache_key = icon + '.' + iconSize + '.' + iconTranslate + '.' + iconTranslateAnchor + '.' + iconAnchor + '.' + iconOffset + '.' + anchorOffset;
                if (iconColor !== null) {
                  _icon_cache_key += '.' + iconColor;
                }
                iconImg = iconImageCache[_icon_cache_key];
                if (!iconImg) {
                  var _spriteImageData = spriteData[icon];
                  var _canvas = document.createElement('canvas');
                  _canvas.width = _spriteImageData.width;
                  _canvas.height = _spriteImageData.height;
                  var _ctx2 = _canvas.getContext('2d');
                  _ctx2.drawImage(spriteImage, _spriteImageData.x, _spriteImageData.y, _spriteImageData.width, _spriteImageData.height, 0, 0, _spriteImageData.width, _spriteImageData.height);
                  var data = _ctx2.getImageData(0, 0, _canvas.width, _canvas.height);
                  if (iconColor !== null) {
                    // cut out the sprite and color it
                    color = colorWithOpacity(iconColor, 1);
                    for (var c = 0, cc = data.data.length; c < cc; c += 4) {
                      data.data[c] = color[0];
                      data.data[c + 1] = color[1];
                      data.data[c + 2] = color[2];
                    }
                  }
                  _ctx2.putImageData(data, 0, 0);
                  var translateOffset = [iconTranslate[0] / _spriteImageData.width, iconTranslate[1] / _spriteImageData.height];
                  iconImg = iconImageCache[_icon_cache_key] = new _Icon2.default({
                    img: _canvas,
                    anchorOrigin: iconAnchor,
                    anchor: [iconOffset[0] + anchorOffset[0] + translateOffset[0], iconOffset[1] + anchorOffset[1] - translateOffset[1]],
                    imgSize: [_canvas.width, _canvas.height],
                    scale: iconSize / _spriteImageData.pixelRatio
                  });
                }
                var rotateValue = getValue(_layer, 'layout', 'icon-rotate', zoom, f);
                if (rotateValue.indexOf && rotateValue.indexOf('{') === 0) {
                  rotateValue = 360 - fromTemplate(rotateValue, properties);
                }
                iconImg.setRotation((0, _util.deg2rad)(rotateValue));
                iconImg.setOpacity(getValue(_layer, 'paint', 'icon-opacity', zoom, f));
                style.setImage(iconImg);
                text = style.getText();
                style.setText(undefined);
                style.setZIndex(99999 - index);
                hasImage = true;
                skipLabel = false;
              } else {
                skipLabel = true;
              }
            }
          }
        }

        if (type == 1 && 'circle-radius' in paint) {
          ++stylesLength;
          if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
            feature.styleIds[zoom].push(_layerId);
          }
          style = styles[stylesLength];
          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
            style = styles[stylesLength] = new _Style2.default();
          }
          var circleRadius = getValue(_layer, 'paint', 'circle-radius', zoom, f);
          var circleStrokeColor = getValue(_layer, 'paint', 'circle-stroke-color', zoom, f);
          var circleColor = getValue(_layer, 'paint', 'circle-color', zoom, f);
          var circleOpacity = getValue(_layer, 'paint', 'circle-opacity', zoom, f);
          var circleStrokeWidth = getValue(_layer, 'paint', 'circle-stroke-width', zoom, f);
          var circleStrokeOpacity = getValue(_layer, 'paint', 'circle-stroke-opacity', zoom, f);
          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleOpacity + '.' + circleStrokeWidth + '.' + circleStrokeOpacity;
          iconImg = iconImageCache[cache_key];
          if (!iconImg) {
            iconImg = new _Circle2.default({
              radius: circleRadius,
              stroke: circleStrokeWidth === 0 ? undefined : new _Stroke2.default({
                width: circleStrokeWidth,
                color: colorWithOpacity(circleStrokeColor, circleStrokeOpacity)
              }),
              fill: new _Fill2.default({
                color: colorWithOpacity(circleColor, circleOpacity)
              })
            });
          }
          style.setImage(iconImg);
          text = style.getText();
          style.setText(undefined);
          style.setGeometry(undefined);
          style.setZIndex(99999 - index);
          hasImage = true;
        }

        var label = void 0;
        if ('text-field' in layout) {
          var textField = getValue(_layer, 'layout', 'text-field', zoom, f);
          label = fromTemplate(textField, properties);
        }
        if (label && !skipLabel) {
          if (!hasImage) {
            ++stylesLength;
            if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
              feature.styleIds[zoom].push(_layerId);
            }
            style = styles[stylesLength];
            if (!style || !style.getText() || style.getFill() || style.getStroke()) {
              style = styles[stylesLength] = new _Style2.default();
            }
            style.setImage(undefined);
            style.setGeometry(undefined);
          }
          if (!style.getText()) {
            style.setText(text || new _Text2.default());
          }
          text = style.getText();
          var textSize = getValue(_layer, 'layout', 'text-size', zoom, f);
          var textLineHeight = getValue(_layer, 'layout', 'text-line-height', zoom, f);
          var font = (0, _mapboxToCssFont2.default)(chooseFont(getValue(_layer, 'layout', 'text-font', zoom, f)), textSize);
          var textTransform = layout['text-transform'];
          if (textTransform == 'uppercase') {
            label = label.toUpperCase();
          } else if (textTransform == 'lowercase') {
            label = label.toLowerCase();
          }
          var wrappedLabel = type == 2 ? label : wrapText(label, font, getValue(_layer, 'layout', 'text-max-width', zoom, f));
          text.setText(wrappedLabel);
          text.setFont(font);
          text.setRotation((0, _util.deg2rad)(getValue(_layer, 'layout', 'text-rotate', zoom, f)));
          var textAnchor = getValue(_layer, 'layout', 'text-anchor', zoom, f);
          var placement = hasImage || type == 1 ? 'point' : getValue(_layer, 'layout', 'symbol-placement', zoom, f);
          text.setPlacement(placement);
          var textHaloWidth = getValue(_layer, 'paint', 'text-halo-width', zoom, f);
          var textOffset = getValue(_layer, 'layout', 'text-offset', zoom, f);
          var textTranslate = getValue(_layer, 'paint', 'text-translate', zoom, f);
          var vOffset = 0;
          var hOffset = 0;
          var textAlign = 'center';
          if (textAnchor.indexOf('left') !== -1) {
            textAlign = 'left';
            hOffset = textHaloWidth;
          } else if (textAnchor.indexOf('right') !== -1) {
            textAlign = 'right';
            hOffset = -textHaloWidth;
          }
          if (placement == 'point') {
            text.setTextAlign(textAlign);
          } else {
            text.setMaxAngle((0, _util.deg2rad)(getValue(_layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);
            text.setTextAlign();
          }
          var textBaseline = 'middle';
          if (textAnchor.indexOf('bottom') == 0) {
            textBaseline = 'bottom';
            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;
          } else if (textAnchor.indexOf('top') == 0) {
            textBaseline = 'top';
            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;
          }
          text.setTextBaseline(textBaseline);
          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);
          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);
          opacity = getValue(_layer, 'paint', 'text-opacity', zoom, f);
          var textColor = new _Fill2.default();

          textColor.setColor(colorWithOpacity(getValue(_layer, 'paint', 'text-color', zoom, f), opacity));
          text.setFill(textColor);
          var haloColor = colorWithOpacity(getValue(_layer, 'paint', 'text-halo-color', zoom, f), opacity);
          if (haloColor) {
            var textHalo = new _Stroke2.default();
            textHalo.setColor(haloColor);
            textHalo.setWidth(getValue(_layer, 'paint', 'text-halo-width', zoom, f));
            text.setStroke(textHalo);
          } else {
            text.setStroke(undefined);
          }
          style.setZIndex(99999 - index);
        }
      }
    }

    if (stylesLength > -1) {
      styles.length = stylesLength + 1;
      return styles;
    }
  };

  olLayer.setStyle(styleFunction);
  olLayer.set('mapbox-source', mapboxSource);
  olLayer.set('mapbox-layers', mapboxLayers);
  return styleFunction;
};

var _Style = __webpack_require__(/*! ol/style/Style */ "ol/style/Style");

var _Style2 = _interopRequireDefault(_Style);

var _Fill = __webpack_require__(/*! ol/style/Fill */ "ol/style/Fill");

var _Fill2 = _interopRequireDefault(_Fill);

var _Stroke = __webpack_require__(/*! ol/style/Stroke */ "ol/style/Stroke");

var _Stroke2 = _interopRequireDefault(_Stroke);

var _Icon = __webpack_require__(/*! ol/style/Icon */ "ol/style/Icon");

var _Icon2 = _interopRequireDefault(_Icon);

var _Text = __webpack_require__(/*! ol/style/Text */ "ol/style/Text");

var _Text2 = _interopRequireDefault(_Text);

var _Circle = __webpack_require__(/*! ol/style/Circle */ "ol/style/Circle");

var _Circle2 = _interopRequireDefault(_Circle);

var _Point = __webpack_require__(/*! ol/geom/Point */ "ol/geom/Point");

var _Point2 = _interopRequireDefault(_Point);

var _mapboxGlStyleSpec = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec */ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js");

var _mapboxToCssFont = __webpack_require__(/*! mapbox-to-css-font */ "./node_modules/mapbox-to-css-font/index.js");

var _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);

var _util = __webpack_require__(/*! ./util */ "./util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isFunction = _mapboxGlStyleSpec.function.isFunction; /*
                                                         ol-mapbox-style - Use Mapbox Style objects with OpenLayers
                                                         Copyright 2016-present Boundless Spatial, Inc.
                                                         License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE
                                                         */

var convertFunction = _mapboxGlStyleSpec.function.convertFunction;
var isExpression = _mapboxGlStyleSpec.expression.isExpression;
var createPropertyExpression = _mapboxGlStyleSpec.expression.createPropertyExpression;

var types = {
  'Point': 1,
  'MultiPoint': 1,
  'LineString': 2,
  'MultiLineString': 2,
  'Polygon': 3,
  'MultiPolygon': 3
};
var expressionData = function expressionData(rawExpression, propertySpec) {
  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);
  if (compiledExpression.result === 'error') {
    throw new Error(compiledExpression.value.map(function (err) {
      return err.key + ': ' + err.message;
    }).join(', '));
  }
  return compiledExpression.value;
};

var emptyObj = {};
var zoomObj = { zoom: 0 };
var functionCache = {};

/**
 * @private
 * @param {Object} layer Gl object layer.
 * @param {string} layoutOrPaint 'layout' or 'paint'.
 * @param {string} property Feature property.
 * @param {number} zoom Zoom.
 * @param {Object} feature Gl feature.
 * @return {?} Value.
 */
function getValue(layer, layoutOrPaint, property, zoom, feature) {
  var layerId = layer.id;
  if (!functionCache[layerId]) {
    functionCache[layerId] = {};
  }
  var functions = functionCache[layerId];
  if (!functions[property]) {
    var value = (layer[layoutOrPaint] || emptyObj)[property];
    var propertySpec = _mapboxGlStyleSpec.latest[layoutOrPaint + '_' + layer.type][property];
    if (value === undefined) {
      value = propertySpec.default;
    }
    var isExpr = isExpression(value);
    if (!isExpr && isFunction(value)) {
      value = convertFunction(value, propertySpec);
      isExpr = true;
    }
    if (isExpr) {
      var compiledExpression = expressionData(value, propertySpec);
      functions[property] = compiledExpression.evaluate.bind(compiledExpression);
    } else {
      if (propertySpec.type == 'color') {
        value = _mapboxGlStyleSpec.Color.parse(value);
      }
      functions[property] = function () {
        return value;
      };
    }
  }
  zoomObj.zoom = zoom;
  return functions[property](zoomObj, feature);
}

function covertIconAnchor(iconAnchor) {
  var anchorOffset = [0.5, 0.5];
  if (['top-left', 'top-right', 'bottom-left', 'bottom-right'].indexOf(iconAnchor) > -1) {
    anchorOffset = [0, 0];
  }
  if (iconAnchor === 'left') {
    iconAnchor = 'top-left';
    anchorOffset = [0, 0.5];
  }
  if (iconAnchor === 'right') {
    iconAnchor = 'top-left';
    anchorOffset = [1, 0.5];
  }
  if (iconAnchor === 'bottom') {
    iconAnchor = 'top-left';
    anchorOffset = [0.5, 1];
  }
  if (iconAnchor === 'top') {
    iconAnchor = 'top-left';
    anchorOffset = [0.5, 0];
  }
  //center
  return {
    anchorOffset: anchorOffset,
    iconAnchor: iconAnchor
  };
}

var fontMap = {};

function chooseFont(fonts, availableFonts) {
  if (fontMap[fonts]) {
    return fontMap[fonts];
  }
  if (availableFonts) {
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      if (availableFonts.indexOf(font) != -1) {
        fontMap[fonts] = font;
        break;
      }
    }
    if (!fontMap[fonts]) {
      // fallback font
      fontMap[fonts] = fonts[fonts.length - 1];
    }
  } else {
    fontMap[fonts] = fonts[0];
  }
  return fontMap[fonts];
}

var filterCache = {};

function evaluateFilter(layerId, filter, feature, zoom) {
  if (!(layerId in filterCache)) {
    filterCache[layerId] = (0, _mapboxGlStyleSpec.featureFilter)(filter).filter;
  }
  zoomObj.zoom = zoom;
  return filterCache[layerId](zoomObj, feature);
}

function colorWithOpacity(color, opacity) {
  if (color) {
    if (color.a === 0 || opacity === 0) {
      return undefined;
    }
    var a = color.a;
    opacity = opacity === undefined ? 1 : opacity;
    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';
  }
  return color;
}

var templateRegEx = /^([^]*)\{(.*)\}([^]*)$/;

function fromTemplate(text, properties) {
  var parts = void 0;
  do {
    parts = text.match(templateRegEx);
    if (parts) {
      var value = properties[parts[2]] || '';
      text = parts[1] + value + parts[3];
    }
  } while (parts);
  return text;
}

/**
 * Creates a style function from the `glStyle` object for all layers that use
 * the specified `source`, which needs to be a `"type": "vector"` or
 * `"type": "geojson"` source and applies it to the specified OpenLayers layer.
 *
 * @param {ol.layer.Vector|ol.layer.VectorTile} olLayer OpenLayers layer to
 * apply the style to. In addition to the style, the layer will get two
 * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used
 * for the layer, and `mapbox-layers` will be an array of the `id`s of the
 * `glStyle`'s layers.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>} source `source` key or an array of layer `id`s
 * from the Mapbox Style object. When a `source` key is provided, all layers for
 * the specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,
 * 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,
 * 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,
 * 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,
 * 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,
 * 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]
 * Resolutions for mapping resolution to zoom level.
 * @param {Object} [spriteData=undefined] Sprite data from the url specified in
 * the Mapbox Style object's `sprite` property. Only required if a `sprite`
 * property is specified in the Mapbox Style object.
 * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite
 * specified in the Mapbox Style object's `sprite` property. Only required if a
 * `sprite` property is specified in the Mapbox Style object.
 * @param {Array<string>} [fonts=undefined] Array of available fonts, using the
 * same font names as the Mapbox Style object. If not provided, the style
 * function will always use the first font from the font array.
 * @return {ol.style.StyleFunction} Style function for use in
 * `ol.layer.Vector` or `ol.layer.VectorTile`.
 */

/***/ }),

/***/ "./util.js":
/*!*****************!*\
  !*** ./util.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deg2rad = deg2rad;
exports.getZoomForResolution = getZoomForResolution;
function deg2rad(degrees) {
  return degrees * Math.PI / 180;
}

function getZoomForResolution(resolution, resolutions) {
  var i = 0;
  var ii = resolutions.length;
  for (; i < ii; ++i) {
    var candidate = resolutions[i];
    if (candidate < resolution && i + 1 < ii) {
      var zoomFactor = resolutions[i] / resolutions[i + 1];
      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);
    }
  }
  return ii - 1;
}

/***/ }),

/***/ "ol/Map":
/*!**********************************************************************************************!*\
  !*** external {"root":["ol","Map"],"commonjs":"ol/Map","commonjs2":"ol/Map","amd":"ol/Map"} ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_Map__;

/***/ }),

/***/ "ol/Observable":
/*!**************************************************************************************************************************!*\
  !*** external {"root":["ol","Observable"],"commonjs":"ol/Observable","commonjs2":"ol/Observable","amd":"ol/Observable"} ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_Observable__;

/***/ }),

/***/ "ol/format/GeoJSON":
/*!********************************************************************************************************************************************!*\
  !*** external {"root":["ol","format","GeoJSON"],"commonjs":"ol/format/GeoJSON","commonjs2":"ol/format/GeoJSON","amd":"ol/format/GeoJSON"} ***!
  \********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_format_GeoJSON__;

/***/ }),

/***/ "ol/format/MVT":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","format","MVT"],"commonjs":"ol/format/MVT","commonjs2":"ol/format/MVT","amd":"ol/format/MVT"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_format_MVT__;

/***/ }),

/***/ "ol/geom/Point":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","geom","Point"],"commonjs":"ol/geom/Point","commonjs2":"ol/geom/Point","amd":"ol/geom/Point"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_geom_Point__;

/***/ }),

/***/ "ol/layer/Tile":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","layer","Tile"],"commonjs":"ol/layer/Tile","commonjs2":"ol/layer/Tile","amd":"ol/layer/Tile"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_layer_Tile__;

/***/ }),

/***/ "ol/layer/Vector":
/*!************************************************************************************************************************************!*\
  !*** external {"root":["ol","layer","Vector"],"commonjs":"ol/layer/Vector","commonjs2":"ol/layer/Vector","amd":"ol/layer/Vector"} ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_layer_Vector__;

/***/ }),

/***/ "ol/layer/VectorTile":
/*!****************************************************************************************************************************************************!*\
  !*** external {"root":["ol","layer","VectorTile"],"commonjs":"ol/layer/VectorTile","commonjs2":"ol/layer/VectorTile","amd":"ol/layer/VectorTile"} ***!
  \****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_layer_VectorTile__;

/***/ }),

/***/ "ol/proj":
/*!**************************************************************************************************!*\
  !*** external {"root":["ol","proj"],"commonjs":"ol/proj","commonjs2":"ol/proj","amd":"ol/proj"} ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_proj__;

/***/ }),

/***/ "ol/source/TileJSON":
/*!************************************************************************************************************************************************!*\
  !*** external {"root":["ol","source","TileJSON"],"commonjs":"ol/source/TileJSON","commonjs2":"ol/source/TileJSON","amd":"ol/source/TileJSON"} ***!
  \************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_source_TileJSON__;

/***/ }),

/***/ "ol/source/Vector":
/*!****************************************************************************************************************************************!*\
  !*** external {"root":["ol","source","Vector"],"commonjs":"ol/source/Vector","commonjs2":"ol/source/Vector","amd":"ol/source/Vector"} ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_source_Vector__;

/***/ }),

/***/ "ol/source/VectorTile":
/*!********************************************************************************************************************************************************!*\
  !*** external {"root":["ol","source","VectorTile"],"commonjs":"ol/source/VectorTile","commonjs2":"ol/source/VectorTile","amd":"ol/source/VectorTile"} ***!
  \********************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_source_VectorTile__;

/***/ }),

/***/ "ol/style/Circle":
/*!************************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Circle"],"commonjs":"ol/style/Circle","commonjs2":"ol/style/Circle","amd":"ol/style/Circle"} ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Circle__;

/***/ }),

/***/ "ol/style/Fill":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Fill"],"commonjs":"ol/style/Fill","commonjs2":"ol/style/Fill","amd":"ol/style/Fill"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Fill__;

/***/ }),

/***/ "ol/style/Icon":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Icon"],"commonjs":"ol/style/Icon","commonjs2":"ol/style/Icon","amd":"ol/style/Icon"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Icon__;

/***/ }),

/***/ "ol/style/Stroke":
/*!************************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Stroke"],"commonjs":"ol/style/Stroke","commonjs2":"ol/style/Stroke","amd":"ol/style/Stroke"} ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Stroke__;

/***/ }),

/***/ "ol/style/Style":
/*!********************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Style"],"commonjs":"ol/style/Style","commonjs2":"ol/style/Style","amd":"ol/style/Style"} ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Style__;

/***/ }),

/***/ "ol/style/Text":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Text"],"commonjs":"ol/style/Text","commonjs2":"ol/style/Text","amd":"ol/style/Text"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Text__;

/***/ }),

/***/ "ol/tilegrid":
/*!******************************************************************************************************************!*\
  !*** external {"root":["ol","tilegrid"],"commonjs":"ol/tilegrid","commonjs2":"ol/tilegrid","amd":"ol/tilegrid"} ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_tilegrid__;

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbG1zL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9vbG1zL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL29sbXMvLi9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL0BtYXBib3gvbWFwYm94LWdsLXN0eWxlLXNwZWMvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvbWFwYm94LXRvLWNzcy1mb250L2luZGV4LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvQXNzZXJ0aW9uRXJyb3IuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9EaXNwb3NhYmxlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VUaWxlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0RXZlbnRUeXBlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL1RpbGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9UaWxlQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9UaWxlUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9UaWxlU3RhdGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9hcnJheS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL2Fzc2VydHMuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9kb20uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvRXZlbnRUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvRXZlbnRUeXBlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50L0Nvcm5lci5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL2V4dGVudC9SZWxhdGlvbnNoaXAuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9mdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0dlb21ldHJ5VHlwZS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL2luZGV4LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvbWF0aC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL29iai5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ouanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1Byb2plY3Rpb24uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1VuaXRzLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9lcHNnMzg1Ny5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ovZXBzZzQzMjYuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL3Byb2plY3Rpb25zLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvcHJvai90cmFuc2Zvcm1zLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL1RpbGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovVHJpYW5ndWxhdGlvbi5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9jb21tb24uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9zaXplLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9TdGF0ZS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGVFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVGlsZUltYWdlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1VybFRpbGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvWFlaLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvc3BoZXJlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvc3RydWN0cy9MUlVDYWNoZS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVjb29yZC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQvVGlsZUdyaWQuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC90aWxldXJsZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC93ZWJnbC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL3dlYmZvbnQtbWF0Y2hlci9saWIvZm9udHMvZ29vZ2xlLmpzIiwid2VicGFjazovL29sbXMvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL29sbXMvLi9vbG1zLmpzIiwid2VicGFjazovL29sbXMvLi9zdHlsZWZ1bmN0aW9uLmpzIiwid2VicGFjazovL29sbXMvLi91dGlsLmpzIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwge1wicm9vdFwiOltcIm9sXCIsXCJNYXBcIl0sXCJjb21tb25qc1wiOlwib2wvTWFwXCIsXCJjb21tb25qczJcIjpcIm9sL01hcFwiLFwiYW1kXCI6XCJvbC9NYXBcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcIk9ic2VydmFibGVcIl0sXCJjb21tb25qc1wiOlwib2wvT2JzZXJ2YWJsZVwiLFwiY29tbW9uanMyXCI6XCJvbC9PYnNlcnZhYmxlXCIsXCJhbWRcIjpcIm9sL09ic2VydmFibGVcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcImZvcm1hdFwiLFwiR2VvSlNPTlwiXSxcImNvbW1vbmpzXCI6XCJvbC9mb3JtYXQvR2VvSlNPTlwiLFwiY29tbW9uanMyXCI6XCJvbC9mb3JtYXQvR2VvSlNPTlwiLFwiYW1kXCI6XCJvbC9mb3JtYXQvR2VvSlNPTlwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwiZm9ybWF0XCIsXCJNVlRcIl0sXCJjb21tb25qc1wiOlwib2wvZm9ybWF0L01WVFwiLFwiY29tbW9uanMyXCI6XCJvbC9mb3JtYXQvTVZUXCIsXCJhbWRcIjpcIm9sL2Zvcm1hdC9NVlRcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcImdlb21cIixcIlBvaW50XCJdLFwiY29tbW9uanNcIjpcIm9sL2dlb20vUG9pbnRcIixcImNvbW1vbmpzMlwiOlwib2wvZ2VvbS9Qb2ludFwiLFwiYW1kXCI6XCJvbC9nZW9tL1BvaW50XCJ9Iiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwge1wicm9vdFwiOltcIm9sXCIsXCJsYXllclwiLFwiVGlsZVwiXSxcImNvbW1vbmpzXCI6XCJvbC9sYXllci9UaWxlXCIsXCJjb21tb25qczJcIjpcIm9sL2xheWVyL1RpbGVcIixcImFtZFwiOlwib2wvbGF5ZXIvVGlsZVwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwibGF5ZXJcIixcIlZlY3RvclwiXSxcImNvbW1vbmpzXCI6XCJvbC9sYXllci9WZWN0b3JcIixcImNvbW1vbmpzMlwiOlwib2wvbGF5ZXIvVmVjdG9yXCIsXCJhbWRcIjpcIm9sL2xheWVyL1ZlY3RvclwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwibGF5ZXJcIixcIlZlY3RvclRpbGVcIl0sXCJjb21tb25qc1wiOlwib2wvbGF5ZXIvVmVjdG9yVGlsZVwiLFwiY29tbW9uanMyXCI6XCJvbC9sYXllci9WZWN0b3JUaWxlXCIsXCJhbWRcIjpcIm9sL2xheWVyL1ZlY3RvclRpbGVcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcInByb2pcIl0sXCJjb21tb25qc1wiOlwib2wvcHJvalwiLFwiY29tbW9uanMyXCI6XCJvbC9wcm9qXCIsXCJhbWRcIjpcIm9sL3Byb2pcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcInNvdXJjZVwiLFwiVGlsZUpTT05cIl0sXCJjb21tb25qc1wiOlwib2wvc291cmNlL1RpbGVKU09OXCIsXCJjb21tb25qczJcIjpcIm9sL3NvdXJjZS9UaWxlSlNPTlwiLFwiYW1kXCI6XCJvbC9zb3VyY2UvVGlsZUpTT05cIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcInNvdXJjZVwiLFwiVmVjdG9yXCJdLFwiY29tbW9uanNcIjpcIm9sL3NvdXJjZS9WZWN0b3JcIixcImNvbW1vbmpzMlwiOlwib2wvc291cmNlL1ZlY3RvclwiLFwiYW1kXCI6XCJvbC9zb3VyY2UvVmVjdG9yXCJ9Iiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwge1wicm9vdFwiOltcIm9sXCIsXCJzb3VyY2VcIixcIlZlY3RvclRpbGVcIl0sXCJjb21tb25qc1wiOlwib2wvc291cmNlL1ZlY3RvclRpbGVcIixcImNvbW1vbmpzMlwiOlwib2wvc291cmNlL1ZlY3RvclRpbGVcIixcImFtZFwiOlwib2wvc291cmNlL1ZlY3RvclRpbGVcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcInN0eWxlXCIsXCJDaXJjbGVcIl0sXCJjb21tb25qc1wiOlwib2wvc3R5bGUvQ2lyY2xlXCIsXCJjb21tb25qczJcIjpcIm9sL3N0eWxlL0NpcmNsZVwiLFwiYW1kXCI6XCJvbC9zdHlsZS9DaXJjbGVcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcInN0eWxlXCIsXCJGaWxsXCJdLFwiY29tbW9uanNcIjpcIm9sL3N0eWxlL0ZpbGxcIixcImNvbW1vbmpzMlwiOlwib2wvc3R5bGUvRmlsbFwiLFwiYW1kXCI6XCJvbC9zdHlsZS9GaWxsXCJ9Iiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwge1wicm9vdFwiOltcIm9sXCIsXCJzdHlsZVwiLFwiSWNvblwiXSxcImNvbW1vbmpzXCI6XCJvbC9zdHlsZS9JY29uXCIsXCJjb21tb25qczJcIjpcIm9sL3N0eWxlL0ljb25cIixcImFtZFwiOlwib2wvc3R5bGUvSWNvblwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwic3R5bGVcIixcIlN0cm9rZVwiXSxcImNvbW1vbmpzXCI6XCJvbC9zdHlsZS9TdHJva2VcIixcImNvbW1vbmpzMlwiOlwib2wvc3R5bGUvU3Ryb2tlXCIsXCJhbWRcIjpcIm9sL3N0eWxlL1N0cm9rZVwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwic3R5bGVcIixcIlN0eWxlXCJdLFwiY29tbW9uanNcIjpcIm9sL3N0eWxlL1N0eWxlXCIsXCJjb21tb25qczJcIjpcIm9sL3N0eWxlL1N0eWxlXCIsXCJhbWRcIjpcIm9sL3N0eWxlL1N0eWxlXCJ9Iiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwge1wicm9vdFwiOltcIm9sXCIsXCJzdHlsZVwiLFwiVGV4dFwiXSxcImNvbW1vbmpzXCI6XCJvbC9zdHlsZS9UZXh0XCIsXCJjb21tb25qczJcIjpcIm9sL3N0eWxlL1RleHRcIixcImFtZFwiOlwib2wvc3R5bGUvVGV4dFwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwidGlsZWdyaWRcIl0sXCJjb21tb25qc1wiOlwib2wvdGlsZWdyaWRcIixcImNvbW1vbmpzMlwiOlwib2wvdGlsZWdyaWRcIixcImFtZFwiOlwib2wvdGlsZWdyaWRcIn0iXSwibmFtZXMiOlsiYXBwbHlTdHlsZSIsImFwcGx5QmFja2dyb3VuZCIsImFwcGx5IiwiZ2V0TGF5ZXIiLCJnZXRTb3VyY2UiLCJhdmFpbGFibGVGb250cyIsImxvYWRGb250IiwiZm9udHMiLCJpIiwiaWkiLCJBcnJheSIsImlzQXJyYXkiLCJzdG9wcyIsImxlbmd0aCIsImdvb2dsZUZhbWlsaWVzIiwiZ29vZ2xlRm9udHMiLCJnZXROYW1lcyIsImZhbWlsaWVzIiwibWFwIiwiZm9udCIsInNwbGl0IiwicmVwbGFjZSIsImZhbWlseSIsImluZGV4T2YiLCJwdXNoIiwiZm9udFVybCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm1hcmt1cCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwicmVsIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJhcHBlbmRDaGlsZCIsImRlZmF1bHRGb250IiwicHJlcHJvY2VzcyIsImxheWVyIiwibGF5b3V0Iiwic3ByaXRlUmVnRXgiLCJ3aXRoUGF0aCIsInVybCIsInBhdGgiLCJ0b1Nwcml0ZVVybCIsImV4dGVuc2lvbiIsInBhcnRzIiwibWF0Y2giLCJnbFN0eWxlIiwic291cmNlIiwicmVzb2x1dGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIkpTT04iLCJwYXJzZSIsInZlcnNpb24iLCJFcnJvciIsInNwcml0ZVNjYWxlIiwic3ByaXRlRGF0YSIsInNwcml0ZUltYWdlVXJsIiwic3ByaXRlIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNpemVGYWN0b3IiLCJzcHJpdGVVcmwiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwidGhlbiIsInJlc3BvbnNlIiwic3RhdHVzIiwianNvbiIsInIiLCJzcHJpdGVzSnNvbiIsInVuZGVmaW5lZCIsIm9uQ2hhbmdlIiwiY2F0Y2giLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJzdHlsZSIsInNldFN0eWxlIiwiVmVjdG9yVGlsZUxheWVyIiwiVmVjdG9yTGF5ZXIiLCJsYXllcnMiLCJpZCIsImUiLCJzZXRUaW1lb3V0Iiwic2V0QmFja2dyb3VuZCIsImJhY2tncm91bmQiLCJ0eXBlIiwidXBkYXRlU3R5bGUiLCJlbGVtZW50IiwiZ2V0VGFyZ2V0RWxlbWVudCIsInBhaW50Iiwiem9vbSIsImdldFZpZXciLCJnZXRab29tIiwiYmciLCJDb2xvciIsInRvU3RyaW5nIiwib3BhY2l0eSIsInZpc2liaWxpdHkiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvbiIsInNvbWUiLCJsIiwiZ2V0U291cmNlSWRCeVJlZiIsInJlZiIsInNvdXJjZUlkIiwicHJvY2Vzc1N0eWxlIiwiYmFzZVVybCIsImhvc3QiLCJhY2Nlc3NUb2tlbiIsInZpZXciLCJnZXRDZW50ZXIiLCJzZXRDZW50ZXIiLCJjZW50ZXIiLCJzZXRab29tIiwiZml0IiwiZ2V0UHJvamVjdGlvbiIsImdldEV4dGVudCIsIm5lYXJlc3QiLCJzaXplIiwiZ2V0U2l6ZSIsImdsTGF5ZXJzIiwiZ2VvSnNvbkZvcm1hdCIsIkdlb0pTT04iLCJsYXllcklkcyIsImZpbmFsaXplTGF5ZXIiLCJhZGRMYXllciIsInNldFZpc2libGUiLCJvbmNlIiwiZ2xMYXllciIsImdsU291cmNlIiwiZ2xTb3VyY2VJZCIsIm1hcGlkIiwic291cmNlcyIsInRpbGVzIiwidGlsZUdyaWQiLCJ0aWxlU2l6ZSIsIm1heFpvb20iLCJtYXh6b29tIiwibWluWm9vbSIsIm1pbnpvb20iLCJkZWNsdXR0ZXIiLCJtYXhSZXNvbHV0aW9uIiwiZ2V0TWluWm9vbSIsImdldFJlc29sdXRpb24iLCJWZWN0b3JUaWxlU291cmNlIiwiYXR0cmlidXRpb25zIiwiYXR0cmlidXRpb24iLCJmb3JtYXQiLCJNVlQiLCJ1cmxzIiwidmlzaWJsZSIsInpJbmRleCIsInRpbGVqc29uIiwiVGlsZUpTT04iLCJrZXkiLCJnZXRTdGF0ZSIsInRpbGVKU09ORG9jIiwiZ2V0VGlsZUpTT04iLCJ0aWxlIiwiZ2V0VGlsZUdyaWQiLCJzZXRTb3VyY2UiLCJnZXRBdHRyaWJ1dGlvbnMiLCJnZXRNYXhab29tIiwic2V0TWF4UmVzb2x1dGlvbiIsImNyb3NzT3JpZ2luIiwiWFlaIiwic2V0VGlsZUxvYWRGdW5jdGlvbiIsInNyYyIsImJib3giLCJnZXRUaWxlQ29vcmRFeHRlbnQiLCJnZXRUaWxlQ29vcmQiLCJnZXRJbWFnZSIsIlRpbGVMYXllciIsImRhdGEiLCJmZWF0dXJlcyIsImdlb0pzb25VcmwiLCJyZWFkRmVhdHVyZXMiLCJmZWF0dXJlUHJvamVjdGlvbiIsIlZlY3RvclNvdXJjZSIsInNldCIsIk1hcCIsInRhcmdldCIsImEiLCJwYXRobmFtZSIsInNsaWNlIiwiam9pbiIsInN1YnN0ciIsImxheWVySWQiLCJnZXRMYXllcnMiLCJnZXRBcnJheSIsImdldCIsIiR2ZXJzaW9uIiwiJHJvb3QiLCJyZXF1aXJlZCIsInZhbHVlcyIsImRvYyIsImV4YW1wbGUiLCJuYW1lIiwibWV0YWRhdGEiLCJ2YWx1ZSIsImJlYXJpbmciLCJwZXJpb2QiLCJ1bml0cyIsInBpdGNoIiwibGlnaHQiLCJhbmNob3IiLCJjb2xvciIsImludGVuc2l0eSIsImdseXBocyIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImRlbGF5Iiwic291cmNlX3ZlY3RvciIsInZlY3RvciIsImJvdW5kcyIsInNjaGVtZSIsInh5eiIsInRtcyIsInByb21vdGVJZCIsInNvdXJjZV9yYXN0ZXIiLCJyYXN0ZXIiLCJzb3VyY2VfcmFzdGVyX2RlbSIsImVuY29kaW5nIiwidGVycmFyaXVtIiwibWFwYm94Iiwic291cmNlX2dlb2pzb24iLCJnZW9qc29uIiwiYnVmZmVyIiwibWF4aW11bSIsIm1pbmltdW0iLCJ0b2xlcmFuY2UiLCJjbHVzdGVyIiwiY2x1c3RlclJhZGl1cyIsImNsdXN0ZXJNYXhab29tIiwiY2x1c3RlclByb3BlcnRpZXMiLCJsaW5lTWV0cmljcyIsImdlbmVyYXRlSWQiLCJzb3VyY2VfdmlkZW8iLCJ2aWRlbyIsImNvb3JkaW5hdGVzIiwic291cmNlX2ltYWdlIiwiaW1hZ2UiLCJmaWxsIiwianMiLCJhbmRyb2lkIiwiaW9zIiwibWFjb3MiLCJsaW5lIiwic3ltYm9sIiwiY2lyY2xlIiwiaGVhdG1hcCIsImhpbGxzaGFkZSIsImZpbHRlciIsImxheW91dF9iYWNrZ3JvdW5kIiwibm9uZSIsImxheW91dF9maWxsIiwiZXhwcmVzc2lvbiIsImludGVycG9sYXRlZCIsInBhcmFtZXRlcnMiLCJsYXlvdXRfY2lyY2xlIiwibGF5b3V0X2hlYXRtYXAiLCJsYXlvdXRfbGluZSIsImJ1dHQiLCJyb3VuZCIsInNxdWFyZSIsImJldmVsIiwibWl0ZXIiLCJyZXF1aXJlcyIsImxheW91dF9zeW1ib2wiLCJwb2ludCIsImF1dG8iLCJ2aWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwiYm90aCIsInRva2VucyIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsInVwcGVyY2FzZSIsImxvd2VyY2FzZSIsImxheW91dF9yYXN0ZXIiLCJsYXlvdXRfaGlsbHNoYWRlIiwiZmlsdGVyX29wZXJhdG9yIiwiYWxsIiwiYW55IiwiaGFzIiwiZ2VvbWV0cnlfdHlwZSIsIlBvaW50IiwiTGluZVN0cmluZyIsIlBvbHlnb24iLCJmdW5jdGlvbl9zdG9wIiwiZXhwcmVzc2lvbl9uYW1lIiwiZ3JvdXAiLCJsaXRlcmFsIiwiYXJyYXkiLCJhdCIsImNvYWxlc2NlIiwic3RlcCIsImludGVycG9sYXRlIiwibG4yIiwicGkiLCJzdHJpbmciLCJudW1iZXIiLCJib29sZWFuIiwib2JqZWN0IiwiY29sbGF0b3IiLCJyZ2IiLCJyZ2JhIiwicHJvcGVydGllcyIsImFjY3VtdWxhdGVkIiwic3FydCIsImxvZzEwIiwibG4iLCJsb2cyIiwic2luIiwiY29zIiwidGFuIiwiYXNpbiIsImFjb3MiLCJhdGFuIiwibWluIiwibWF4IiwiYWJzIiwiY2VpbCIsImZsb29yIiwid2l0aGluIiwidXBjYXNlIiwiZG93bmNhc2UiLCJjb25jYXQiLCJwb3NpdGlvbiIsInBhaW50X2ZpbGwiLCJwYWludF9saW5lIiwicGFpbnRfY2lyY2xlIiwicGFpbnRfaGVhdG1hcCIsInBhaW50X3N5bWJvbCIsIm92ZXJyaWRhYmxlIiwicGFpbnRfcmFzdGVyIiwibGluZWFyIiwicGFpbnRfaGlsbHNoYWRlIiwicGFpbnRfYmFja2dyb3VuZCIsInY4IiwiYmFzZSIsInByb3BlcnR5IiwiaWRlbnRpdHkiLCJleHBvbmVudGlhbCIsImludGVydmFsIiwiY2F0ZWdvcmljYWwiLCJjb2xvclNwYWNlIiwibGFiIiwiaGNsIiwiY29uc3RhbnQiLCJzdHJpbmdPckNoYXIiLCJqc29uU3RyaW5naWZ5UHJldHR5Q29tcGFjdCIsInN0cmluZ2lmeSIsInBhc3NlZE9iaiIsIm9wdGlvbnMiLCJpbmRlbnQiLCJtYXhMZW5ndGgiLCJyZXBsYWNlciIsIkluZmluaXR5IiwiX3N0cmluZ2lmeSIsIm9iaiIsImN1cnJlbnRJbmRlbnQiLCJyZXNlcnZlZCIsImVuZCIsImluZGV4IiwiaXRlbXMiLCJrZXlQYXJ0Iiwia2V5cyIsIm5leHRJbmRlbnQiLCJwcmV0dGlmaWVkIiwic3RhcnQiLCJ0b0pTT04iLCJzdHJpbmdMaXRlcmFsIiwiT2JqZWN0Iiwic29ydEtleXNCeSIsInJlZmVyZW5jZSIsInJlc3VsdCIsImtleSQxIiwic3BhY2UiLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJnbG9iYWwiLCJzZWxmIiwiY29tbW9uanNSZXF1aXJlIiwiY3JlYXRlQ29tbW9uanNNb2R1bGUiLCJmbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJwdW55Y29kZSIsInJvb3QiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJtYXhJbnQiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsIk1hdGgiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJSYW5nZUVycm9yIiwibWFwRG9tYWluIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJvdXRwdXQiLCJjb3VudGVyIiwiZXh0cmEiLCJjaGFyQ29kZUF0IiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJrIiwiZGVjb2RlIiwiaW5wdXQiLCJpbnB1dExlbmd0aCIsIm91dCIsIm4iLCJiaWFzIiwiYmFzaWMiLCJqIiwib2xkaSIsInciLCJ0IiwiYmFzZU1pbnVzVCIsImxhc3RJbmRleE9mIiwic3BsaWNlIiwiZW5jb2RlIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsIm0iLCJxIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsInRvVW5pY29kZSIsInRlc3QiLCJ0b0xvd2VyQ2FzZSIsInRvQVNDSUkiLCJoYXNPd25Qcm9wZXJ0eSIsInV0aWwiLCJpc1N0cmluZyIsImFyZyIsImlzT2JqZWN0IiwiaXNOdWxsIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJwcm9wIiwicHJvdG90eXBlIiwiY2FsbCIsInFzIiwic2VwIiwiZXEiLCJyZWdleHAiLCJtYXhLZXlzIiwibGVuIiwieCIsImlkeCIsImtzdHIiLCJ2c3RyIiwidiIsImRlY29kZVVSSUNvbXBvbmVudCIsInN0cmluZ2lmeVByaW1pdGl2ZSIsImlzRmluaXRlIiwia3MiLCJlbmNvZGVVUklDb21wb25lbnQiLCJxdWVyeXN0cmluZyIsInF1ZXJ5c3RyaW5nXzEiLCJxdWVyeXN0cmluZ18yIiwicXVlcnlzdHJpbmdfMyIsInF1ZXJ5c3RyaW5nXzQiLCJ1cmxQYXJzZSIsInVybFJlc29sdmUiLCJyZXNvbHZlT2JqZWN0IiwidXJsUmVzb2x2ZU9iamVjdCIsImZvcm1hdCQxIiwidXJsRm9ybWF0IiwiVXJsXzEiLCJVcmwiLCJwcm90b2NvbCIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsImhvc3RuYW1lIiwiaGFzaCIsInNlYXJjaCIsInF1ZXJ5IiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsInVuc2FmZVByb3RvY29sIiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInBhcnNlUXVlcnlTdHJpbmciLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJUeXBlRXJyb3IiLCJxdWVyeUluZGV4Iiwic3BsaXR0ZXIiLCJ1U3BsaXQiLCJzbGFzaFJlZ2V4IiwicmVzdCIsInRyaW0iLCJzaW1wbGVQYXRoIiwiZXhlYyIsInByb3RvIiwibG93ZXJQcm90byIsImhvc3RFbmQiLCJoZWMiLCJhdFNpZ24iLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwidW5zaGlmdCIsInAiLCJoIiwiYWUiLCJlc2MiLCJlc2NhcGUiLCJxbSIsInMiLCJjaGFyQXQiLCJyZWxhdGl2ZSIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJyZWxQYXRoIiwic2hpZnQiLCJpc1NvdXJjZUFicyIsImlzUmVsQWJzIiwibXVzdEVuZEFicyIsInJlbW92ZUFsbERvdHMiLCJzcmNQYXRoIiwicHN5Y2hvdGljIiwicG9wIiwiYXV0aEluSG9zdCIsImxhc3QiLCJoYXNUcmFpbGluZ1NsYXNoIiwidXAiLCJpc0Fic29sdXRlIiwiZ2V0UHJvcGVydHlSZWZlcmVuY2UiLCJwcm9wZXJ0eU5hbWUiLCJpJDEiLCJlYWNoU291cmNlIiwiY2FsbGJhY2siLCJlYWNoTGF5ZXIiLCJsaXN0IiwiZWFjaFByb3BlcnR5IiwiaW5uZXIiLCJwcm9wZXJ0eVR5cGUiLCJmb3JFYWNoIiwiZWFjaExheW91dCIsImVhY2hQYWludCIsInJlc29sdmVDb25zdGFudCIsImNvbnN0YW50cyIsImlzRnVuY3Rpb24iLCJyZW5hbWVQcm9wZXJ0eSIsImZyb20iLCJ0byIsIm1pZ3JhdGVUb1Y4IiwiY29vcmQiLCJyZXZlcnNlIiwic3RvcCIsIm1pZ3JhdGVGb250c3RhY2tVUkwiLCJpbnB1dFBhcnNlZCIsImlucHV0UGF0aG5hbWVQYXJ0cyIsIm1pZ3JhdGVGb250U3RhY2siLCJzcGxpdEFuZFRyaW0iLCJmaXJzdFN5bWJvbExheWVyIiwic3ltYm9sTGF5ZXJzIiwiZXh0ZW5kIiwiaW5wdXRzIiwiYXJndW1lbnRzIiwiUGFyc2luZ0Vycm9yIiwibWVzc2FnZSIsIl9fcHJvdG9fXyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiU2NvcGUiLCJwYXJlbnQiLCJiaW5kaW5ncyIsIk51bGxUeXBlIiwia2luZCIsIk51bWJlclR5cGUiLCJTdHJpbmdUeXBlIiwiQm9vbGVhblR5cGUiLCJDb2xvclR5cGUiLCJPYmplY3RUeXBlIiwiVmFsdWVUeXBlIiwiRXJyb3JUeXBlIiwiQ29sbGF0b3JUeXBlIiwiRm9ybWF0dGVkVHlwZSIsIlJlc29sdmVkSW1hZ2VUeXBlIiwiaXRlbVR5cGUiLCJOIiwidmFsdWVNZW1iZXJUeXBlcyIsImNoZWNrU3VidHlwZSIsImV4cGVjdGVkIiwibWVtYmVyVHlwZSIsImlzVmFsaWRUeXBlIiwicHJvdmlkZWQiLCJhbGxvd2VkVHlwZXMiLCJpc1ZhbGlkTmF0aXZlVHlwZSIsImNzc2NvbG9ycGFyc2VyIiwia0NTU0NvbG9yVGFibGUiLCJjbGFtcF9jc3NfYnl0ZSIsImNsYW1wX2Nzc19mbG9hdCIsImYiLCJwYXJzZV9jc3NfaW50Iiwic3RyIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwicGFyc2VfY3NzX2Zsb2F0IiwiY3NzX2h1ZV90b19yZ2IiLCJtMSIsIm0yIiwicGFyc2VDU1NDb2xvciIsImNzc19zdHIiLCJpdiIsIm9wIiwiZXAiLCJmbmFtZSIsInBhcmFtcyIsImFscGhhIiwiY3NzY29sb3JwYXJzZXJfMSIsImciLCJiIiwidG9BcnJheSIsImJsYWNrIiwid2hpdGUiLCJ0cmFuc3BhcmVudCIsInJlZCIsIkNvbGxhdG9yIiwiY2FzZVNlbnNpdGl2ZSIsImRpYWNyaXRpY1NlbnNpdGl2ZSIsImxvY2FsZSIsInNlbnNpdGl2aXR5IiwiSW50bCIsInVzYWdlIiwiY29tcGFyZSIsImxocyIsInJocyIsInJlc29sdmVkTG9jYWxlIiwicmVzb2x2ZWRPcHRpb25zIiwiRm9ybWF0dGVkU2VjdGlvbiIsInRleHQiLCJzY2FsZSIsImZvbnRTdGFjayIsInRleHRDb2xvciIsIkZvcm1hdHRlZCIsInNlY3Rpb25zIiwiZnJvbVN0cmluZyIsInVuZm9ybWF0dGVkIiwiaXNFbXB0eSIsInNlY3Rpb24iLCJmYWN0b3J5Iiwic2VyaWFsaXplIiwic2VyaWFsaXplZCIsIlJlc29sdmVkSW1hZ2UiLCJhdmFpbGFibGUiLCJ2YWxpZGF0ZVJHQkEiLCJpc1ZhbHVlIiwibWl4ZWQiLCJpdGVtIiwidHlwZU9mIiwidG9TdHJpbmckMSIsIkxpdGVyYWwiLCJhcmdzIiwiY29udGV4dCIsImV4cGVjdGVkVHlwZSIsImV2YWx1YXRlIiwiZWFjaENoaWxkIiwib3V0cHV0RGVmaW5lZCIsIlJ1bnRpbWVFcnJvciIsInR5cGVzIiwiQXNzZXJ0aW9uIiwidHlwZSQxIiwicGFyc2VkIiwiY3R4IiwiZXZlcnkiLCJGb3JtYXRFeHByZXNzaW9uIiwiZmlyc3RBcmciLCJuZXh0VG9rZW5NYXlCZU9iamVjdCIsImxhc3RFeHByZXNzaW9uIiwiY29udGVudCIsImV2YWx1YXRlU2VjdGlvbiIsImV2YWx1YXRlZENvbnRlbnQiLCJJbWFnZUV4cHJlc3Npb24iLCJldmFsdWF0ZWRJbWFnZU5hbWUiLCJhdmFpbGFibGVJbWFnZXMiLCJ0eXBlcyQxIiwiQ29lcmNpb24iLCJCb29sZWFuIiwiYyIsInBhcnNlQ29sb3IiLCJsaXN0JDEiLCJhcmckMSIsIm51bSIsIk51bWJlciIsImlzTmFOIiwiY2hpbGQiLCJnZW9tZXRyeVR5cGVzIiwiRXZhbHVhdGlvbkNvbnRleHQiLCJnbG9iYWxzIiwiZmVhdHVyZSIsImZlYXR1cmVTdGF0ZSIsImZvcm1hdHRlZFNlY3Rpb24iLCJfcGFyc2VDb2xvckNhY2hlIiwiY2Fub25pY2FsIiwiZ2VvbWV0cnlUeXBlIiwiZ2VvbWV0cnkiLCJjYW5vbmljYWxJRCIsImNhY2hlZCIsIkNvbXBvdW5kRXhwcmVzc2lvbiIsIl9ldmFsdWF0ZSIsInJlZiQxIiwiZGVmaW5pdGlvbiIsImRlZmluaXRpb25zIiwiYXZhaWxhYmxlT3ZlcmxvYWRzIiwib3ZlcmxvYWRzIiwic2lnbmF0dXJlIiwic2lnbmF0dXJlQ29udGV4dCIsImkkMyIsIlBhcnNpbmdDb250ZXh0IiwicmVnaXN0cnkiLCJzY29wZSIsInBhcnNlZEFyZ3MiLCJhcmdQYXJzZUZhaWxlZCIsImV4cGVjdGVkJDEiLCJzaWduYXR1cmVzIiwic3RyaW5naWZ5U2lnbmF0dXJlIiwiYWN0dWFsVHlwZXMiLCJpJDIiLCJwYXJzZWQkMSIsInJlZ2lzdGVyIiwiQ29sbGF0b3JFeHByZXNzaW9uIiwiRVhURU5UIiwidXBkYXRlQkJveCIsIm1lcmNhdG9yWGZyb21MbmciLCJsbmciLCJtZXJjYXRvcllmcm9tTGF0IiwibGF0IiwiUEkiLCJsb2ciLCJib3hXaXRoaW5Cb3giLCJiYm94MSIsImJib3gyIiwiZ2V0VGlsZUNvb3JkaW5hdGVzIiwieSIsInRpbGVzQXRab29tIiwicG93IiwieiIsIm9uQm91bmRhcnkiLCJwMSIsInAyIiwieDEiLCJ5MSIsIngyIiwieTIiLCJyYXlJbnRlcnNlY3QiLCJwb2ludFdpdGhpblBvbHlnb24iLCJyaW5ncyIsImluc2lkZSIsInJpbmciLCJsZW4yIiwicG9pbnRXaXRoaW5Qb2x5Z29ucyIsInBvbHlnb25zIiwicGVycCIsInYxIiwidjIiLCJ0d29TaWRlZCIsInExIiwicTIiLCJ4MyIsInkzIiwiZGV0MSIsImRldDIiLCJsaW5lSW50ZXJzZWN0TGluZSIsImQiLCJ2ZWN0b3JQIiwidmVjdG9yUSIsImxpbmVJbnRlcnNlY3RQb2x5Z29uIiwicG9seWdvbiIsImxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uIiwibGluZVN0cmluZ1dpdGhpblBvbHlnb25zIiwiZ2V0VGlsZVBvbHlnb24iLCJnZXRUaWxlUG9seWdvbnMiLCJ1cGRhdGVQb2ludCIsInBvbHlCQm94Iiwid29ybGRTaXplIiwiaGFsZldvcmxkU2l6ZSIsInJlc2V0QkJveCIsImdldFRpbGVQb2ludHMiLCJwb2ludEJCb3giLCJzaGlmdHMiLCJ0aWxlUG9pbnRzIiwicG9pbnRzIiwiZ2V0VGlsZUxpbmVzIiwibGluZUJCb3giLCJ0aWxlTGluZXMiLCJ0aWxlTGluZSIsImxpc3QkMyIsImxpbmUkMSIsImxpc3QkMiIsInAkMSIsInBvaW50c1dpdGhpblBvbHlnb25zIiwicG9seWdvbkdlb21ldHJ5IiwidGlsZVBvbHlnb24iLCJ0aWxlUG9seWdvbnMiLCJ0aWxlUG9pbnRzJDEiLCJwb2ludCQxIiwibGluZXNXaXRoaW5Qb2x5Z29ucyIsInRpbGVMaW5lcyQxIiwiV2l0aGluIiwiZ2VvbWV0cmllcyIsImlzRmVhdHVyZUNvbnN0YW50IiwiaXNTdGF0ZUNvbnN0YW50IiwiaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50IiwiVmFyIiwiYm91bmRFeHByZXNzaW9uIiwiZXhwciIsIl9wYXJzZSIsImFubm90YXRlIiwidHlwZUFubm90YXRpb24iLCJFeHByIiwiYWN0dWFsIiwiaXNDb25zdGFudCIsImVjIiwiZXJyb3IkMSIsImNoZWNrU3VidHlwZSQxIiwiaXNUeXBlQW5ub3RhdGlvbiIsImNoaWxkcmVuQ29uc3RhbnQiLCJmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvIiwibGFzdEluZGV4IiwibG93ZXJJbmRleCIsInVwcGVySW5kZXgiLCJjdXJyZW50SW5kZXgiLCJuZXh0VmFsdWUiLCJTdGVwIiwib3V0cHV0cyIsImxhYmVsIiwib3V0cHV0VHlwZSIsImxhYmVsS2V5IiwidmFsdWVLZXkiLCJzdG9wQ291bnQiLCJ1bml0YmV6aWVyIiwiVW5pdEJlemllciIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsImN4IiwiYngiLCJheCIsImN5IiwiYnkiLCJheSIsInNhbXBsZUN1cnZlWCIsInNhbXBsZUN1cnZlWSIsInNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgiLCJzb2x2ZUN1cnZlWCIsImVwc2lsb24iLCJ0MCIsInQxIiwidDIiLCJkMiIsInNvbHZlIiwiYXJyYXkkMSIsImZyZWV6ZSIsIlhuIiwiWW4iLCJabiIsInQzIiwiZGVnMnJhZCIsInJhZDJkZWciLCJ4eXoybGFiIiwibGFiMnh5eiIsInh5ejJyZ2IiLCJyZ2IyeHl6IiwicmdiVG9MYWIiLCJyZ2JDb2xvciIsImxhYlRvUmdiIiwibGFiQ29sb3IiLCJpbnRlcnBvbGF0ZUxhYiIsInJnYlRvSGNsIiwiYXRhbjIiLCJoY2xUb1JnYiIsImhjbENvbG9yIiwiaW50ZXJwb2xhdGVIdWUiLCJpbnRlcnBvbGF0ZUhjbCIsImZvcndhcmQiLCJjb2xvclNwYWNlcyIsIkludGVycG9sYXRlIiwib3BlcmF0b3IiLCJpbnRlcnBvbGF0aW9uIiwiaW50ZXJwb2xhdGlvbkZhY3RvciIsImxvd2VyIiwidXBwZXIiLCJleHBvbmVudGlhbEludGVycG9sYXRpb24iLCJjb250cm9sUG9pbnRzIiwidWIiLCJvdXRwdXRMb3dlciIsIm91dHB1dFVwcGVyIiwibG93ZXJWYWx1ZSIsInVwcGVyVmFsdWUiLCJkaWZmZXJlbmNlIiwicHJvZ3Jlc3MiLCJDb2FsZXNjZSIsIm5lZWRzQW5ub3RhdGlvbiIsImFyZ0NvdW50IiwicmVxdWVzdGVkSW1hZ2VOYW1lIiwiTGV0IiwiYmluZGluZyIsIkF0IiwiSW4iLCJuZWVkbGUiLCJoYXlzdGFjayIsIkluZGV4T2YiLCJmcm9tSW5kZXgiLCJNYXRjaCIsImlucHV0VHlwZSIsImNhc2VzIiwib3RoZXJ3aXNlIiwibGFiZWxDb250ZXh0IiwiTUFYX1NBRkVfSU5URUdFUiIsInRoaXMkMSIsInNvcnRlZExhYmVscyIsInNvcnQiLCJncm91cGVkQnlPdXRwdXQiLCJvdXRwdXRMb29rdXAiLCJvdXRwdXRJbmRleCIsImNvZXJjZUxhYmVsIiwib3V0cHV0SW5kZXgkMSIsIkNhc2UiLCJicmFuY2hlcyIsIl8iLCJTbGljZSIsImJlZ2luSW5kZXgiLCJlbmRJbmRleCIsImlzQ29tcGFyYWJsZVR5cGUiLCJuZXEiLCJsdCIsImd0IiwibHRlcSIsImd0ZXEiLCJlcUNvbGxhdGUiLCJuZXFDb2xsYXRlIiwibHRDb2xsYXRlIiwiZ3RDb2xsYXRlIiwibHRlcUNvbGxhdGUiLCJndGVxQ29sbGF0ZSIsIm1ha2VDb21wYXJpc29uIiwiY29tcGFyZUJhc2ljIiwiY29tcGFyZVdpdGhDb2xsYXRvciIsImlzT3JkZXJDb21wYXJpc29uIiwiQ29tcGFyaXNvbiIsImhhc1VudHlwZWRBcmd1bWVudCIsInJ0IiwibHQkMSIsInJ0JDEiLCJFcXVhbHMiLCJOb3RFcXVhbHMiLCJMZXNzVGhhbiIsIkdyZWF0ZXJUaGFuIiwiTGVzc1RoYW5PckVxdWFsIiwiR3JlYXRlclRoYW5PckVxdWFsIiwiTnVtYmVyRm9ybWF0IiwiY3VycmVuY3kiLCJtaW5GcmFjdGlvbkRpZ2l0cyIsIm1heEZyYWN0aW9uRGlnaXRzIiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwiTGVuZ3RoIiwiZXhwcmVzc2lvbnMiLCJiaW5hcnlTZWFyY2giLCJ2YXJhcmdzIiwiaGVhdG1hcERlbnNpdHkiLCJsaW5lUHJvZ3Jlc3MiLCJMTjIiLCJFIiwiTE4xMCIsImlzU3VwcG9ydGVkU2NyaXB0IiwidG9VcHBlckNhc2UiLCJzdWNjZXNzIiwic3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24iLCJzcGVjIiwic3VwcG9ydHNab29tRXhwcmVzc2lvbiIsInN1cHBvcnRzSW50ZXJwb2xhdGlvbiIsImdldFR5cGUiLCJ2YWwiLCJpc0Z1bmN0aW9uJDEiLCJpZGVudGl0eUZ1bmN0aW9uIiwiY3JlYXRlRnVuY3Rpb24iLCJwcm9wZXJ0eVNwZWMiLCJpc0NvbG9yIiwiem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQiLCJmZWF0dXJlRGVwZW5kZW50Iiwiem9vbURlcGVuZGVudCIsImRlZmF1bHQiLCJpbm5lckZ1biIsImhhc2hlZFN0b3BzIiwiY2F0ZWdvcmljYWxLZXlUeXBlIiwiZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uIiwiZXZhbHVhdGVJbnRlcnZhbEZ1bmN0aW9uIiwiZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uIiwiZXZhbHVhdGVJZGVudGl0eUZ1bmN0aW9uIiwiZmVhdHVyZUZ1bmN0aW9ucyIsInpvb21TdG9wcyIsInN0b3AkMSIsImZlYXR1cmVGdW5jdGlvblN0b3BzIiwiaW50ZXJwb2xhdGlvblR5cGUiLCJiaW5kIiwiaW50ZXJwb2xhdGlvblR5cGUkMSIsImtleVR5cGUiLCJldmFsdWF0ZWQiLCJpbnRlcnAiLCJjb2xvcnNwYWNlIiwiZXZhbHVhdGVkTG93ZXIiLCJldmFsdWF0ZWRVcHBlciIsIlN0eWxlRXhwcmVzc2lvbiIsIl93YXJuaW5nSGlzdG9yeSIsIl9ldmFsdWF0b3IiLCJfZGVmYXVsdFZhbHVlIiwiZ2V0RGVmYXVsdFZhbHVlIiwiX2VudW1WYWx1ZXMiLCJldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nIiwid2FybiIsImlzRXhwcmVzc2lvbiIsImNyZWF0ZUV4cHJlc3Npb24iLCJwYXJzZXIiLCJnZXRFeHBlY3RlZFR5cGUiLCJab29tQ29uc3RhbnRFeHByZXNzaW9uIiwiX3N0eWxlRXhwcmVzc2lvbiIsImlzU3RhdGVEZXBlbmRlbnQiLCJab29tRGVwZW5kZW50RXhwcmVzc2lvbiIsImNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbiIsImlzRmVhdHVyZUNvbnN0YW50JDEiLCJpc1pvb21Db25zdGFudCIsInpvb21DdXJ2ZSIsImZpbmRab29tQ3VydmUiLCJTdHlsZVByb3BlcnR5RnVuY3Rpb24iLCJzcGVjaWZpY2F0aW9uIiwiX3BhcmFtZXRlcnMiLCJfc3BlY2lmaWNhdGlvbiIsImRlc2VyaWFsaXplIiwibm9ybWFsaXplUHJvcGVydHlFeHByZXNzaW9uIiwiY2hpbGRSZXN1bHQiLCJlbnVtIiwiZm9ybWF0dGVkIiwicmVzb2x2ZWRJbWFnZSIsImNvbnZlcnRMaXRlcmFsIiwiY29udmVydEZ1bmN0aW9uIiwiY29udmVydElkZW50aXR5RnVuY3Rpb24iLCJjb252ZXJ0VG9rZW5TdHJpbmciLCJjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24iLCJjb252ZXJ0Wm9vbUZ1bmN0aW9uIiwiY29udmVydFByb3BlcnR5RnVuY3Rpb24iLCJnZXRJbnRlcnBvbGF0ZU9wZXJhdG9yIiwiZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVycyIsImZ1bmN0aW9uVHlwZSIsImdldEZ1bmN0aW9uVHlwZSIsImFwcGVuZFN0b3BQYWlyIiwiZXhwcmVzc2lvbiQxIiwieiQxIiwib3V0cHV0JDEiLCJmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUiLCJjb2FsZXNjZSQxIiwiZXhwcmVzc2lvbiQyIiwic3RvcCQyIiwiZXhwcmVzc2lvbiQzIiwic3RvcCQzIiwiaXNTdGVwIiwiY3VydmUiLCJyZSIsInBvcyIsImlzRXhwcmVzc2lvbkZpbHRlciIsImZpbHRlclNwZWMiLCJjcmVhdGVGaWx0ZXIiLCJuZWVkR2VvbWV0cnkiLCJjb252ZXJ0RmlsdGVyIiwiY29tcGlsZWQiLCJnbG9iYWxQcm9wZXJ0aWVzIiwiY29udmVydGVkIiwiY29udmVydENvbXBhcmlzb25PcCIsImNvbnZlcnROZWdhdGlvbiIsImNvbnZlcnREaXNqdW5jdGlvbk9wIiwiY29udmVydEluT3AiLCJjb252ZXJ0SGFzT3AiLCJmaWx0ZXJzIiwiY29udmVydEZpbHRlciQxIiwiX2NvbnZlcnRGaWx0ZXIiLCJleHBlY3RlZFR5cGVzIiwiY29udmVydENvbXBhcmlzb25PcCQxIiwiY2hpbGRyZW4iLCJ0eXBlY2hlY2tzIiwicnVudGltZVR5cGVDaGVja3MiLCJjaGlsZHJlbiQxIiwiY29udmVydEluT3AkMSIsImNvbnZlcnRIYXNPcCQxIiwiY29uZGl0aW9ucyIsIm5lZ2F0ZSIsInVuaWZvcm1UeXBlcyIsInVuaXF1ZVZhbHVlcyIsIm1pZ3JhdGVUb0V4cHJlc3Npb25zIiwibWlncmF0ZSIsIm1pZ3JhdGVkIiwiY29tcG9zaXRlIiwic3R5bGVJRHMiLCJzb3VyY2VJRHMiLCJjb21wb3NpdGVkU291cmNlTGF5ZXJzIiwiY29tcG9zaXRlSUQiLCJyZWZQcm9wZXJ0aWVzIiwiZGVyZWYiLCJkZXJlZkxheWVycyIsImRlZXBFcXVhbCIsIm9wZXJhdGlvbnMiLCJyZW1vdmVMYXllciIsInNldFBhaW50UHJvcGVydHkiLCJzZXRMYXlvdXRQcm9wZXJ0eSIsInNldEZpbHRlciIsImFkZFNvdXJjZSIsInJlbW92ZVNvdXJjZSIsInNldEdlb0pTT05Tb3VyY2VEYXRhIiwic2V0TGF5ZXJab29tUmFuZ2UiLCJzZXRMYXllclByb3BlcnR5Iiwic2V0QmVhcmluZyIsInNldFBpdGNoIiwic2V0U3ByaXRlIiwic2V0R2x5cGhzIiwic2V0VHJhbnNpdGlvbiIsInNldExpZ2h0IiwiYWZ0ZXIiLCJjb21tYW5kcyIsImNvbW1hbmQiLCJzb3VyY2VzUmVtb3ZlZCIsInVwZGF0ZVNvdXJjZSIsImNhblVwZGF0ZUdlb0pTT04iLCJiZWZvcmUiLCJkaWZmU291cmNlcyIsImRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyIsImtsYXNzIiwicGx1Y2tJZCIsImluZGV4QnlJZCIsImRpZmZMYXllcnMiLCJiZWZvcmVPcmRlciIsImFmdGVyT3JkZXIiLCJiZWZvcmVJbmRleCIsInJlZHVjZSIsImFmdGVySW5kZXgiLCJ0cmFja2VyIiwiY2xlYW4iLCJiZWZvcmVMYXllciIsImFmdGVyTGF5ZXIiLCJpbnNlcnRCZWZvcmVMYXllcklkIiwiZGlmZlN0eWxlcyIsInJlbW92ZU9yQWRkU291cmNlQ29tbWFuZHMiLCJiZWZvcmVMYXllcnMiLCJWYWxpZGF0aW9uRXJyb3IiLCJpZGVudGlmaWVyIiwiX19saW5lX18iLCJQYXJzaW5nRXJyb3IkMSIsInZhbGlkYXRlQ29uc3RhbnRzIiwidW5idW5kbGUiLCJ2YWx1ZU9mIiwiZGVlcFVuYnVuZGxlIiwidW5idW5kbGVkVmFsdWUiLCJ2YWxpZGF0ZU9iamVjdCIsImVsZW1lbnRTcGVjcyIsInZhbHVlU3BlYyIsImVsZW1lbnRWYWxpZGF0b3JzIiwib2JqZWN0RWxlbWVudFZhbGlkYXRvcnMiLCJzdHlsZVNwZWMiLCJvYmplY3RLZXkiLCJlbGVtZW50U3BlY0tleSIsImVsZW1lbnRTcGVjIiwidmFsaWRhdGVFbGVtZW50IiwidmFsaWRhdGUiLCJlbGVtZW50U3BlY0tleSQxIiwidmFsaWRhdGVBcnJheSIsImFycmF5U3BlYyIsInZhbGlkYXRlQXJyYXlFbGVtZW50IiwiYXJyYXlFbGVtZW50VmFsaWRhdG9yIiwiYXJyYXlFbGVtZW50U3BlYyIsImZ1bmN0aW9uIiwiYXJyYXlJbmRleCIsInZhbGlkYXRlTnVtYmVyIiwidmFsaWRhdGVGdW5jdGlvbiIsImZ1bmN0aW9uVmFsdWVTcGVjIiwic3RvcEtleVR5cGUiLCJzdG9wRG9tYWluVmFsdWVzIiwicHJldmlvdXNTdG9wRG9tYWluVmFsdWUiLCJwcmV2aW91c1N0b3BEb21haW5ab29tIiwiaXNab29tRnVuY3Rpb24iLCJpc1Byb3BlcnR5RnVuY3Rpb24iLCJpc1pvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uIiwidmFsaWRhdGVGdW5jdGlvblN0b3BzIiwidmFsaWRhdGVGdW5jdGlvbkRlZmF1bHQiLCJ2YWxpZGF0ZUZ1bmN0aW9uU3RvcCIsInZhbGlkYXRlU3RvcERvbWFpblZhbHVlIiwicmVwb3J0VmFsdWUiLCJ2YWxpZGF0ZUV4cHJlc3Npb24iLCJleHByZXNzaW9uQ29udGV4dCIsImV4cHJlc3Npb25PYmoiLCJwcm9wZXJ0eUtleSIsInZhbGlkYXRlQm9vbGVhbiIsInZhbGlkYXRlQ29sb3IiLCJ2YWxpZGF0ZUVudW0iLCJ2YWxpZGF0ZUZpbHRlciIsInZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlciIsInZhbGlkYXRlUHJvcGVydHkiLCJsYXllclNwZWMiLCJsYXllclR5cGUiLCJ0cmFuc2l0aW9uTWF0Y2giLCJ0b2tlbk1hdGNoIiwidmFsaWRhdGVQYWludFByb3BlcnR5IiwidmFsaWRhdGVMYXlvdXRQcm9wZXJ0eSIsInZhbGlkYXRlTGF5ZXIiLCJvdGhlckxheWVyIiwic291cmNlVHlwZSIsInZhbGlkYXRlU3RyaW5nIiwidmFsaWRhdGVQcm9tb3RlSWQiLCJ2YWxpZGF0ZVNvdXJjZSIsIm1hcEV4cHIiLCJyZWR1Y2VFeHByIiwidmFsaWRhdGVMaWdodCIsImxpZ2h0U3BlYyIsInJvb3RUeXBlIiwidmFsaWRhdGVGb3JtYXR0ZWQiLCJ2YWxpZGF0ZUltYWdlIiwiVkFMSURBVE9SUyIsInZhbGlkIiwidmFsaWRhdGVHbHlwaHNVUkwiLCJ2YWxpZGF0ZVN0eWxlTWluIiwic29ydEVycm9ycyIsIndyYXBDbGVhbkVycm9ycyIsInBhaW50UHJvcGVydHkiLCJsYXlvdXRQcm9wZXJ0eSIsImpzb25saW50IiwibyIsIiRWMCIsIiRWMSIsIiRWMiIsIiRWMyIsIiRWNCIsIiRWNSIsIiRWNiIsIiRWNyIsIiRWOCIsIiRWOSIsInRyYWNlIiwieXkiLCJzeW1ib2xzXyIsInRlcm1pbmFsc18iLCJwcm9kdWN0aW9uc18iLCJwZXJmb3JtQWN0aW9uIiwiYW5vbnltb3VzIiwieXl0ZXh0IiwieXlsZW5nIiwieXlsaW5lbm8iLCJ5eXN0YXRlIiwiJCQiLCJfJCIsIiQwIiwiJCIsImZpcnN0X2xpbmUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ0YWJsZSIsImRlZmF1bHRBY3Rpb25zIiwicGFyc2VFcnJvciIsInJlY292ZXJhYmxlIiwic3RhY2siLCJ2c3RhY2siLCJsc3RhY2siLCJURVJST1IiLCJFT0YiLCJsZXhlciIsInNoYXJlZFN0YXRlIiwic2V0SW5wdXQiLCJ5eWxsb2MiLCJ5eWxvYyIsInJhbmdlcyIsImdldFByb3RvdHlwZU9mIiwibGV4IiwidG9rZW4iLCJzdGF0ZSIsImFjdGlvbiIsInl5dmFsIiwibmV3U3RhdGUiLCJlcnJTdHIiLCJzaG93UG9zaXRpb24iLCJsb2MiLCJsYXN0X2xpbmUiLCJmaXJzdF9jb2x1bW4iLCJsYXN0X2NvbHVtbiIsInJhbmdlIiwiX2lucHV0IiwiX21vcmUiLCJfYmFja3RyYWNrIiwiZG9uZSIsIm1hdGNoZWQiLCJjb25kaXRpb25TdGFjayIsIm9mZnNldCIsImNoIiwibGluZXMiLCJ1bnB1dCIsIm9sZExpbmVzIiwibW9yZSIsImJhY2t0cmFja19sZXhlciIsImxlc3MiLCJwYXN0SW5wdXQiLCJwYXN0IiwidXBjb21pbmdJbnB1dCIsIm5leHQiLCJwcmUiLCJ0ZXN0X21hdGNoIiwiaW5kZXhlZF9ydWxlIiwiYmFja3VwIiwibWF0Y2hlcyIsInRlbXBNYXRjaCIsInJ1bGVzIiwiX2N1cnJlbnRSdWxlcyIsImZsZXgiLCJiZWdpbiIsImNvbmRpdGlvbiIsInBvcFN0YXRlIiwidG9wU3RhdGUiLCJwdXNoU3RhdGUiLCJzdGF0ZVN0YWNrU2l6ZSIsInl5XyIsIiRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMiLCJZWV9TVEFSVCIsIlBhcnNlciIsImpzb25saW50XzEiLCJqc29ubGludF8yIiwianNvbmxpbnRfMyIsInJlYWRTdHlsZSIsIkJ1ZmZlciIsInZhbGlkYXRlU3R5bGUiLCJTVVBQT1JURURfU1BFQ19WRVJTSU9OIiwiTUFYX1NPVVJDRVNfSU5fU1RZTEUiLCJpc1ZhbGlkIiwicmVnZXgiLCJnZXRTb3VyY2VDb3VudCIsImdldEFsbG93ZWRLZXlFcnJvcnMiLCJhbGxvd2VkIiwiU2V0IiwiZ2V0U291cmNlRXJyb3JzIiwic291cmNlS2V5cyIsInNvdXJjZVVybFBhdHRlcm4iLCJnZXRTb3VyY2VzRXJyb3JzIiwiY291bnQiLCJzb3VyY2VFcnJvcnMiLCJnZXRSb290RXJyb3JzIiwic3BlY0tleXMiLCJvcHRpb25hbFJvb3RQcm9wZXJ0aWVzIiwiYWxsb3dlZEtleUVycm9ycyIsImdseXBoVXJsUGF0dGVybiIsInNwcml0ZVVybFBhdHRlcm4iLCJ2aXNpYmlsaXR5UGF0dGVybiIsInZhbGlkYXRlTWFwYm94QXBpU3VwcG9ydGVkIiwic3R5bGVGdW5jdGlvbiIsInZpc2l0IiwibGF0ZXN0IiwiZGlmZiIsImZlYXR1cmVGaWx0ZXIiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsImNvZGUiLCJnZXRMZW5zIiwiYjY0IiwidmFsaWRMZW4iLCJwbGFjZUhvbGRlcnNMZW4iLCJsZW5zIiwiX2J5dGVMZW5ndGgiLCJ0bXAiLCJhcnIiLCJjdXJCeXRlIiwidHJpcGxldFRvQmFzZTY0IiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsImV4dHJhQnl0ZXMiLCJtYXhDaHVua0xlbmd0aCIsImJhc2U2NCIsInJlcXVpcmUiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsImZvbyIsInN1YmFycmF5IiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJBcnJheUJ1ZmZlciIsImZyb21BcnJheUJ1ZmZlciIsImZyb21PYmplY3QiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uZmlndXJhYmxlIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsImlzRW5jb2RpbmciLCJ3cml0ZSIsImZyb21BcnJheUxpa2UiLCJieXRlT2Zmc2V0IiwiaXNCdWZmZXIiLCJjb3B5IiwiaXNuYW4iLCJfaXNCdWZmZXIiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwiaW5zcGVjdCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsImRpciIsImFycmF5SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwicmVtYWluaW5nIiwic3RyTGVuIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJfYXJyIiwicmVzIiwiZmlyc3RCeXRlIiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsInJldCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJkc3QiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsImZvbnRXZWlnaHRzIiwidGhpbiIsImhhaXJsaW5lIiwiYm9vayIsInJlZ3VsYXIiLCJub3JtYWwiLCJwbGFpbiIsInJvbWFuIiwic3RhbmRhcmQiLCJtZWRpdW0iLCJib2xkIiwiaGVhdnkiLCJmYXQiLCJwb3N0ZXIiLCJzcCIsIml0YWxpY1JFIiwiZm9udENhY2hlIiwibGluZUhlaWdodCIsImNzc0RhdGEiLCJ3ZWlnaHQiLCJmb250RmFtaWxpZXMiLCJoYXZlV2VpZ2h0IiwiaGF2ZVN0eWxlIiwibWF5YmVXZWlnaHQiLCJmb250RmFtaWx5IiwiQXNzZXJ0aW9uRXJyb3IiLCJWRVJTSU9OIiwiRGlzcG9zYWJsZSIsImRpc3Bvc2VkXyIsImRpc3Bvc2UiLCJkaXNwb3NlSW50ZXJuYWwiLCJVTkRFRklORUQiLCJJbWFnZVRpbGUiLCJ0aWxlQ29vcmQiLCJ0aWxlTG9hZEZ1bmN0aW9uIiwib3B0X29wdGlvbnMiLCJUaWxlIiwiY3Jvc3NPcmlnaW5fIiwic3JjXyIsImltYWdlXyIsIkltYWdlIiwiaW1hZ2VMaXN0ZW5lcktleXNfIiwidGlsZUxvYWRGdW5jdGlvbl8iLCJUaWxlU3RhdGUiLCJMT0FESU5HIiwidW5saXN0ZW5JbWFnZV8iLCJnZXRCbGFua0ltYWdlIiwiaW50ZXJpbVRpbGUiLCJBQk9SVCIsImNoYW5nZWQiLCJnZXRLZXkiLCJoYW5kbGVJbWFnZUVycm9yXyIsIkVSUk9SIiwiaGFuZGxlSW1hZ2VMb2FkXyIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJMT0FERUQiLCJFTVBUWSIsImxvYWQiLCJJRExFIiwiRXZlbnRUeXBlIiwiTE9BRCIsInVubGlzdGVuQnlLZXkiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImNhbnZhcyIsImdldENoYW5nZUV2ZW50VHlwZSIsIk9iamVjdEV2ZW50Iiwib2xkVmFsdWUiLCJFdmVudCIsIkJhc2VPYmplY3QiLCJvcHRfdmFsdWVzIiwiT2JzZXJ2YWJsZSIsInZhbHVlc18iLCJzZXRQcm9wZXJ0aWVzIiwiY2hhbmdlRXZlbnRUeXBlQ2FjaGUiLCJnZXRLZXlzIiwiZ2V0UHJvcGVydGllcyIsIm5vdGlmeSIsImV2ZW50VHlwZSIsImRpc3BhdGNoRXZlbnQiLCJPYmplY3RFdmVudFR5cGUiLCJQUk9QRVJUWUNIQU5HRSIsIm9wdF9zaWxlbnQiLCJ1bnNldCIsInVuQnlLZXkiLCJFdmVudFRhcmdldCIsInJldmlzaW9uXyIsIkNIQU5HRSIsImdldFJldmlzaW9uIiwibGlzdGVuZXIiLCJ1biIsInRyYW5zaXRpb25fIiwidHJhbnNpdGlvblN0YXJ0c18iLCJnZXRJbnRlcmltVGlsZSIsInJlZnJlc2hJbnRlcmltQ2hhaW4iLCJwcmV2Iiwic2V0U3RhdGUiLCJnZXRBbHBoYSIsInRpbWUiLCJpblRyYW5zaXRpb24iLCJlbmRUcmFuc2l0aW9uIiwiVGlsZUNhY2hlIiwib3B0X2hpZ2hXYXRlck1hcmsiLCJMUlVDYWNoZSIsImV4cGlyZUNhY2hlIiwidXNlZFRpbGVzIiwiY2FuRXhwaXJlQ2FjaGUiLCJwZWVrTGFzdCIsInpLZXkiLCJjb250YWlucyIsInBydW5lRXhjZXB0TmV3ZXN0WiIsImdldENvdW50IiwicGVla0ZpcnN0S2V5IiwicmVtb3ZlIiwiY3JlYXRlT3JVcGRhdGUiLCJUaWxlUmFuZ2UiLCJtaW5YIiwibWF4WCIsIm1pblkiLCJtYXhZIiwidGlsZVJhbmdlIiwiY29udGFpbnNYWSIsImNvbnRhaW5zVGlsZVJhbmdlIiwiZ2V0SGVpZ2h0IiwiZ2V0V2lkdGgiLCJpbnRlcnNlY3RzIiwibnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbiIsImxpbmVhckZpbmROZWFyZXN0IiwicmV2ZXJzZVN1YkFycmF5IiwiZmluZCIsInN0YWJsZVNvcnQiLCJmaW5kSW5kZXgiLCJpc1NvcnRlZCIsIm9wdF9jb21wYXJhdG9yIiwibWlkIiwiY21wIiwiY29tcGFyYXRvciIsImxvdyIsImhpZ2giLCJkaXJlY3Rpb24iLCJmdW5jIiwiYXJyMSIsImFycjIiLCJsZW4xIiwiY29tcGFyZUZuYyIsImVsIiwib3B0X2Z1bmMiLCJvcHRfc3RyaWN0IiwiY3VycmVudFZhbCIsImFzc2VydCIsImFzc2VydGlvbiIsImVycm9yQ29kZSIsImNyZWF0ZUNhbnZhc0NvbnRleHQyRCIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsInJlcGxhY2VOb2RlIiwicmVtb3ZlTm9kZSIsInJlbW92ZUNoaWxkcmVuIiwib3B0X3dpZHRoIiwib3B0X2hlaWdodCIsImdldENvbnRleHQiLCJvZmZzZXRXaWR0aCIsImdldENvbXB1dGVkU3R5bGUiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJvZmZzZXRIZWlnaHQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5Cb3R0b20iLCJuZXdOb2RlIiwib2xkTm9kZSIsInBhcmVudE5vZGUiLCJyZXBsYWNlQ2hpbGQiLCJub2RlIiwicmVtb3ZlQ2hpbGQiLCJsYXN0Q2hpbGQiLCJlYXNlSW4iLCJlYXNlT3V0IiwiaW5BbmRPdXQiLCJ1cEFuZERvd24iLCJiaW5kTGlzdGVuZXIiLCJmaW5kTGlzdGVuZXIiLCJnZXRMaXN0ZW5lcnMiLCJsaXN0ZW4iLCJsaXN0ZW5PbmNlIiwidW5saXN0ZW4iLCJ1bmxpc3RlbkFsbCIsImxpc3RlbmVyT2JqIiwiYm91bmRMaXN0ZW5lciIsImV2dCIsImJpbmRUbyIsImNhbGxPbmNlIiwibGlzdGVuZXJzIiwib3B0X3RoaXMiLCJvcHRfc2V0RGVsZXRlSW5kZXgiLCJkZWxldGVJbmRleCIsImxpc3RlbmVyTWFwIiwib2xfbG0iLCJnZXRMaXN0ZW5lck1hcCIsInJlbW92ZUxpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvcHRfb25jZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsInByb3BhZ2F0aW9uU3RvcHBlZCIsInBlbmRpbmdSZW1vdmFsc18iLCJkaXNwYXRjaGluZ18iLCJsaXN0ZW5lcnNfIiwiZXZlbnQiLCJwcm9wYWdhdGUiLCJwZW5kaW5nUmVtb3ZhbHMiLCJoYXNMaXN0ZW5lciIsIm9wdF90eXBlIiwiQ0xFQVIiLCJDT05URVhUTUVOVSIsIkNMSUNLIiwiREJMQ0xJQ0siLCJEUkFHRU5URVIiLCJEUkFHT1ZFUiIsIkRST1AiLCJLRVlET1dOIiwiS0VZUFJFU1MiLCJNT1VTRURPV04iLCJNT1VTRU1PVkUiLCJNT1VTRU9VVCIsIk1PVVNFVVAiLCJNT1VTRVdIRUVMIiwiTVNQT0lOVEVSRE9XTiIsIlJFU0laRSIsIlRPVUNIU1RBUlQiLCJUT1VDSE1PVkUiLCJUT1VDSEVORCIsIldIRUVMIiwiYm91bmRpbmdFeHRlbnQiLCJjbG9uZSIsImNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSIsImNvbnRhaW5zQ29vcmRpbmF0ZSIsImNvbnRhaW5zRXh0ZW50IiwiY29vcmRpbmF0ZVJlbGF0aW9uc2hpcCIsImNyZWF0ZUVtcHR5IiwiY3JlYXRlT3JVcGRhdGVFbXB0eSIsImNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUiLCJjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlcyIsImNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyIsImNyZWF0ZU9yVXBkYXRlRnJvbVJpbmdzIiwiZXh0ZW5kQ29vcmRpbmF0ZSIsImV4dGVuZENvb3JkaW5hdGVzIiwiZXh0ZW5kRmxhdENvb3JkaW5hdGVzIiwiZXh0ZW5kUmluZ3MiLCJleHRlbmRYWSIsImZvckVhY2hDb3JuZXIiLCJnZXRBcmVhIiwiZ2V0Qm90dG9tTGVmdCIsImdldEJvdHRvbVJpZ2h0IiwiZ2V0Q29ybmVyIiwiZ2V0RW5sYXJnZWRBcmVhIiwiZ2V0Rm9yVmlld0FuZFNpemUiLCJnZXRJbnRlcnNlY3Rpb25BcmVhIiwiZ2V0SW50ZXJzZWN0aW9uIiwiZ2V0TWFyZ2luIiwiZ2V0VG9wTGVmdCIsImdldFRvcFJpZ2h0IiwicmV0dXJuT3JVcGRhdGUiLCJzY2FsZUZyb21DZW50ZXIiLCJpbnRlcnNlY3RzU2VnbWVudCIsImFwcGx5VHJhbnNmb3JtIiwiZXh0ZW50IiwiX2JvdW5kaW5nRXh0ZW50WFlzIiwieHMiLCJ5cyIsIm9wdF9leHRlbnQiLCJkeCIsImR5IiwiY29vcmRpbmF0ZSIsImV4dGVudDEiLCJleHRlbnQyIiwicmVsYXRpb25zaGlwIiwiUmVsYXRpb25zaGlwIiwiVU5LTk9XTiIsIkxFRlQiLCJSSUdIVCIsIkJFTE9XIiwiQUJPVkUiLCJJTlRFUlNFQ1RJTkciLCJmbGF0Q29vcmRpbmF0ZXMiLCJzdHJpZGUiLCJhcmVhIiwiY29ybmVyIiwiQ29ybmVyIiwiQk9UVE9NX0xFRlQiLCJCT1RUT01fUklHSFQiLCJUT1BfTEVGVCIsIlRPUF9SSUdIVCIsInJlc29sdXRpb24iLCJyb3RhdGlvbiIsImNvc1JvdGF0aW9uIiwic2luUm90YXRpb24iLCJ4Q29zIiwieFNpbiIsInlDb3MiLCJ5U2luIiwieDAiLCJ5MCIsImludGVyc2VjdGlvbiIsImRlbHRhWCIsImRlbHRhWSIsInN0YXJ0UmVsIiwiZW5kUmVsIiwic3RhcnRYIiwic3RhcnRZIiwiZW5kWCIsImVuZFkiLCJzbG9wZSIsInRyYW5zZm9ybUZuIiwiVFJVRSIsIkZBTFNFIiwiUE9JTlQiLCJMSU5FX1NUUklORyIsIkxJTkVBUl9SSU5HIiwiUE9MWUdPTiIsIk1VTFRJX1BPSU5UIiwiTVVMVElfTElORV9TVFJJTkciLCJNVUxUSV9QT0xZR09OIiwiR0VPTUVUUllfQ09MTEVDVElPTiIsIkNJUkNMRSIsImluaGVyaXRzIiwiZ2V0VWlkIiwiREVCVUdfV0VCR0wiLCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFIiwiV0VCR0xfRVhURU5TSU9OUyIsIkhBU19XRUJHTCIsImdsIiwiZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCIsImdldFBhcmFtZXRlciIsIk1BWF9URVhUVVJFX1NJWkUiLCJnZXRTdXBwb3J0ZWRFeHRlbnNpb25zIiwiY2hpbGRDdG9yIiwicGFyZW50Q3RvciIsInVpZENvdW50ZXJfIiwib2xfdWlkIiwiY2xhbXAiLCJyb3VuZFVwVG9Qb3dlck9mVHdvIiwic3F1YXJlZFNlZ21lbnREaXN0YW5jZSIsInNxdWFyZWREaXN0YW5jZSIsInNvbHZlTGluZWFyU3lzdGVtIiwidG9EZWdyZWVzIiwidG9SYWRpYW5zIiwibW9kdWxvIiwibGVycCIsImNvc2giLCJleHAiLCJtYXQiLCJtYXhSb3ciLCJtYXhFbCIsImFic1ZhbHVlIiwiY29lZiIsImFuZ2xlSW5SYWRpYW5zIiwiYW5nbGVJbkRlZ3JlZXMiLCJjbGVhciIsImdldFZhbHVlcyIsImFzc2lnbiIsInZhcl9zb3VyY2VzIiwiY2xvbmVUcmFuc2Zvcm0iLCJpZGVudGl0eVRyYW5zZm9ybSIsImFkZFByb2plY3Rpb24iLCJhZGRQcm9qZWN0aW9ucyIsImdldFBvaW50UmVzb2x1dGlvbiIsImFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyIsImFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zIiwiY2xlYXJBbGxQcm9qZWN0aW9ucyIsImNyZWF0ZVByb2plY3Rpb24iLCJjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybSIsImFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zIiwiZnJvbUxvbkxhdCIsInRvTG9uTGF0IiwiZXF1aXZhbGVudCIsImdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyIsImdldFRyYW5zZm9ybSIsInRyYW5zZm9ybSIsInRyYW5zZm9ybUV4dGVudCIsInRyYW5zZm9ybVdpdGhQcm9qZWN0aW9ucyIsImFkZENvbW1vbiIsInByb2plY3Rpb25zIiwiTUVURVJTX1BFUl9VTklUIiwib3B0X291dHB1dCIsIm9wdF9kaW1lbnNpb24iLCJwcm9qZWN0aW9uIiwiYWRkIiwiZ2V0Q29kZSIsInByb2plY3Rpb25MaWtlIiwiUHJvamVjdGlvbiIsIm9wdF91bml0cyIsInBvaW50UmVzb2x1dGlvbiIsImdldHRlciIsImdldFBvaW50UmVzb2x1dGlvbkZ1bmMiLCJnZXRVbml0cyIsIlVuaXRzIiwiREVHUkVFUyIsInRvRVBTRzQzMjYiLCJ2ZXJ0aWNlcyIsIm1ldGVyc1BlclVuaXQiLCJnZXRNZXRlcnNQZXJVbml0IiwiZGVzdGluYXRpb24iLCJwcm9qZWN0aW9uczEiLCJwcm9qZWN0aW9uczIiLCJmb3J3YXJkVHJhbnNmb3JtIiwiaW52ZXJzZVRyYW5zZm9ybSIsInByb2plY3Rpb24xIiwicHJvamVjdGlvbjIiLCJkZWZhdWx0Q29kZSIsImNvb3JkVHJhbnNmb3JtIiwiZGltZW5zaW9uIiwiaW52ZXJzZSIsInNvdXJjZVByb2oiLCJkZXN0UHJvaiIsIm9wdF9wcm9qZWN0aW9uIiwibG9uTGF0IiwibG9uIiwiZXF1YWxVbml0cyIsInRyYW5zZm9ybUZ1bmMiLCJzb3VyY2VQcm9qZWN0aW9uIiwiZGVzdGluYXRpb25Qcm9qZWN0aW9uIiwic291cmNlQ29kZSIsImRlc3RpbmF0aW9uQ29kZSIsIkVQU0czODU3X1BST0pFQ1RJT05TIiwiRVBTRzQzMjZfUFJPSkVDVElPTlMiLCJmcm9tRVBTRzQzMjYiLCJjb2RlXyIsInVuaXRzXyIsImV4dGVudF8iLCJ3b3JsZEV4dGVudF8iLCJ3b3JsZEV4dGVudCIsImF4aXNPcmllbnRhdGlvbl8iLCJheGlzT3JpZW50YXRpb24iLCJnbG9iYWxfIiwiY2FuV3JhcFhfIiwiZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18iLCJkZWZhdWx0VGlsZUdyaWRfIiwibWV0ZXJzUGVyVW5pdF8iLCJjYW5XcmFwWCIsImdldFdvcmxkRXh0ZW50IiwiZ2V0QXhpc09yaWVudGF0aW9uIiwiaXNHbG9iYWwiLCJzZXRHbG9iYWwiLCJnZXREZWZhdWx0VGlsZUdyaWQiLCJzZXREZWZhdWx0VGlsZUdyaWQiLCJzZXRFeHRlbnQiLCJzZXRXb3JsZEV4dGVudCIsInNldEdldFBvaW50UmVzb2x1dGlvbiIsIkZFRVQiLCJNRVRFUlMiLCJQSVhFTFMiLCJUSUxFX1BJWEVMUyIsIlVTRkVFVCIsIlJBRElVUyIsIkhBTEZfU0laRSIsIldPUkxEX0VYVEVOVCIsIkVQU0czODU3UHJvamVjdGlvbiIsIlBST0pFQ1RJT05TIiwiaGFsZlNpemUiLCJFUFNHNDMyNlByb2plY3Rpb24iLCJvcHRfYXhpc09yaWVudGF0aW9uIiwiY2FjaGUiLCJ0cmFuc2Zvcm1zIiwiY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbiIsInJlbmRlciIsInRhcmdldFByb2oiLCJ0YXJnZXRDZW50ZXIiLCJ0YXJnZXRSZXNvbHV0aW9uIiwic291cmNlQ2VudGVyIiwic291cmNlUmVzb2x1dGlvbiIsInRhcmdldE1ldGVyc1BlclVuaXQiLCJzb3VyY2VNZXRlcnNQZXJVbml0Iiwic291cmNlRXh0ZW50IiwiY29tcGVuc2F0aW9uRmFjdG9yIiwiZW5sYXJnZUNsaXBQb2ludCIsImNlbnRyb2lkWCIsImNlbnRyb2lkWSIsImRYIiwiZFkiLCJkaXN0YW5jZSIsInBpeGVsUmF0aW8iLCJ0YXJnZXRFeHRlbnQiLCJ0cmlhbmd1bGF0aW9uIiwiZ3V0dGVyIiwib3B0X3JlbmRlckVkZ2VzIiwic291cmNlRGF0YUV4dGVudCIsImNhbnZhc1dpZHRoSW5Vbml0cyIsImNhbnZhc0hlaWdodEluVW5pdHMiLCJzdGl0Y2hDb250ZXh0Iiwic3RpdGNoU2NhbGUiLCJ4UG9zIiwieVBvcyIsInNyY1dpZHRoIiwic3JjSGVpZ2h0IiwiZHJhd0ltYWdlIiwidGFyZ2V0VG9wTGVmdCIsImdldFRyaWFuZ2xlcyIsInRyaWFuZ2xlIiwidTAiLCJ2MCIsInUxIiwidTIiLCJzb3VyY2VOdW1lcmljYWxTaGlmdFgiLCJzb3VyY2VOdW1lcmljYWxTaGlmdFkiLCJhdWdtZW50ZWRNYXRyaXgiLCJhZmZpbmVDb2VmcyIsInNhdmUiLCJiZWdpblBhdGgiLCJwMCIsIm1vdmVUbyIsImxpbmVUbyIsImNsaXAiLCJ0cmFuc2xhdGUiLCJyZXN0b3JlIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJSZXByb2pUaWxlIiwic291cmNlVGlsZUdyaWQiLCJ0YXJnZXRUaWxlR3JpZCIsIndyYXBwZWRUaWxlQ29vcmQiLCJnZXRUaWxlRnVuY3Rpb24iLCJvcHRfZXJyb3JUaHJlc2hvbGQiLCJyZW5kZXJFZGdlc18iLCJwaXhlbFJhdGlvXyIsImd1dHRlcl8iLCJjYW52YXNfIiwic291cmNlVGlsZUdyaWRfIiwidGFyZ2V0VGlsZUdyaWRfIiwid3JhcHBlZFRpbGVDb29yZF8iLCJzb3VyY2VUaWxlc18iLCJzb3VyY2VzTGlzdGVuZXJLZXlzXyIsInNvdXJjZVpfIiwibWF4VGFyZ2V0RXh0ZW50IiwibWF4U291cmNlRXh0ZW50IiwibGltaXRlZFRhcmdldEV4dGVudCIsInNvdXJjZVByb2pFeHRlbnQiLCJlcnJvclRocmVzaG9sZEluUGl4ZWxzIiwiRVJST1JfVEhSRVNIT0xEIiwidHJpYW5ndWxhdGlvbl8iLCJUcmlhbmd1bGF0aW9uIiwiZ2V0WkZvclJlc29sdXRpb24iLCJjYWxjdWxhdGVTb3VyY2VFeHRlbnQiLCJzb3VyY2VSYW5nZSIsImdldFRpbGVSYW5nZUZvckV4dGVudEFuZFoiLCJzcmNYIiwic3JjWSIsInVubGlzdGVuU291cmNlc18iLCJyZXByb2plY3RfIiwiZ2V0VGlsZVNpemUiLCJsZWZ0VG9Mb2FkIiwic291cmNlTGlzdGVuS2V5IiwiTUFYX1NVQkRJVklTSU9OIiwiTUFYX1RSSUFOR0xFX1dJRFRIIiwiZXJyb3JUaHJlc2hvbGQiLCJzb3VyY2VQcm9qXyIsInRhcmdldFByb2pfIiwidHJhbnNmb3JtSW52Q2FjaGUiLCJ0cmFuc2Zvcm1JbnYiLCJ0cmFuc2Zvcm1JbnZfIiwibWF4U291cmNlRXh0ZW50XyIsImVycm9yVGhyZXNob2xkU3F1YXJlZF8iLCJ0cmlhbmdsZXNfIiwid3JhcHNYSW5Tb3VyY2VfIiwiY2FuV3JhcFhJblNvdXJjZV8iLCJzb3VyY2VXb3JsZFdpZHRoXyIsInRhcmdldFdvcmxkV2lkdGhfIiwiZGVzdGluYXRpb25Ub3BMZWZ0IiwiZGVzdGluYXRpb25Ub3BSaWdodCIsImRlc3RpbmF0aW9uQm90dG9tUmlnaHQiLCJkZXN0aW5hdGlvbkJvdHRvbUxlZnQiLCJzb3VyY2VUb3BMZWZ0Iiwic291cmNlVG9wUmlnaHQiLCJzb3VyY2VCb3R0b21SaWdodCIsInNvdXJjZUJvdHRvbUxlZnQiLCJhZGRRdWFkXyIsImxlZnRCb3VuZCIsIm5ld1RyaWFuZ2xlIiwiYWRkVHJpYW5nbGVfIiwiYVNyYyIsImJTcmMiLCJjU3JjIiwiZFNyYyIsIm1heFN1YmRpdmlzaW9uIiwic291cmNlUXVhZEV4dGVudCIsInNvdXJjZUNvdmVyYWdlWCIsInNvdXJjZVdvcmxkV2lkdGgiLCJ3cmFwc1giLCJuZWVkc1N1YmRpdmlzaW9uIiwidGFyZ2V0UXVhZEV4dGVudCIsInRhcmdldENvdmVyYWdlWCIsImNlbnRlclNyYyIsImNlbnRlclNyY0VzdGltWCIsImNlbnRlclNyY0Vycm9yU3F1YXJlZCIsImJjIiwiYmNTcmMiLCJkYSIsImRhU3JjIiwiYWIiLCJhYlNyYyIsImNkIiwiY2RTcmMiLCJFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiIsImhhc0FyZWEiLCJ0b1NpemUiLCJvcHRfc2l6ZSIsInJhdGlvIiwiU291cmNlIiwicHJvamVjdGlvbl8iLCJhdHRyaWJ1dGlvbnNfIiwiYWRhcHRBdHRyaWJ1dGlvbnNfIiwic3RhdGVfIiwiU291cmNlU3RhdGUiLCJSRUFEWSIsIndyYXBYXyIsIndyYXBYIiwiYXR0cmlidXRpb25MaWtlIiwiZnJhbWVTdGF0ZSIsImZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlIiwiZ2V0UmVzb2x1dGlvbnMiLCJnZXRXcmFwWCIsInJlZnJlc2giLCJzZXRBdHRyaWJ1dGlvbnMiLCJUaWxlU291cmNlIiwib3BhcXVlXyIsIm9wYXF1ZSIsInRpbGVQaXhlbFJhdGlvXyIsInRpbGVQaXhlbFJhdGlvIiwidGlsZUNhY2hlIiwiY2FjaGVTaXplIiwidG1wU2l6ZSIsImtleV8iLCJ0aWxlT3B0aW9ucyIsImdldFRpbGVDYWNoZUZvclByb2plY3Rpb24iLCJmb3JFYWNoTG9hZGVkVGlsZSIsImNvdmVyZWQiLCJ0aWxlQ29vcmRLZXkiLCJsb2FkZWQiLCJjb250YWluc0tleSIsImdldEd1dHRlciIsInNldEtleSIsImdldE9wYXF1ZSIsImdldFRpbGUiLCJnZXRUaWxlR3JpZEZvclByb2plY3Rpb24iLCJ0aGlzUHJvaiIsImdldFRpbGVQaXhlbFJhdGlvIiwiZ2V0VGlsZVBpeGVsU2l6ZSIsImdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbiIsInVzZVRpbGUiLCJUaWxlU291cmNlRXZlbnQiLCJUSUxFTE9BRFNUQVJUIiwiVElMRUxPQURFTkQiLCJUSUxFTE9BREVSUk9SIiwiVGlsZUltYWdlIiwiVXJsVGlsZSIsImRlZmF1bHRUaWxlTG9hZEZ1bmN0aW9uIiwidGlsZVVybEZ1bmN0aW9uIiwidGlsZUNsYXNzIiwidGlsZUNhY2hlRm9yUHJvamVjdGlvbiIsInRpbGVHcmlkRm9yUHJvamVjdGlvbiIsInJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkXyIsInJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkIiwicmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfIiwidXNlZFRpbGVDYWNoZSIsImdldEd1dHRlckludGVybmFsIiwicHJvaktleSIsImhpZ2hXYXRlck1hcmsiLCJjcmVhdGVUaWxlXyIsInVybFRpbGVDb29yZCIsInRpbGVVcmwiLCJoYW5kbGVUaWxlQ2hhbmdlIiwiZ2V0VGlsZUludGVybmFsIiwibmV3VGlsZSIsInNldFJlbmRlclJlcHJvamVjdGlvbkVkZ2VzIiwic2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uIiwidGlsZWdyaWQiLCJwcm9qIiwiaW1hZ2VUaWxlIiwiZml4ZWRUaWxlVXJsRnVuY3Rpb24iLCJudWxsVGlsZVVybEZ1bmN0aW9uIiwic2V0VXJscyIsInNldFVybCIsInNldFRpbGVVcmxGdW5jdGlvbiIsInRpbGVMb2FkaW5nS2V5c18iLCJnZXRUaWxlTG9hZEZ1bmN0aW9uIiwiZ2V0VGlsZVVybEZ1bmN0aW9uIiwiZ2V0VXJscyIsInVpZCIsInRpbGVTdGF0ZSIsIlRpbGVFdmVudFR5cGUiLCJvcHRfa2V5IiwiZ2V0RGlzdGFuY2UiLCJnZXRMZW5ndGgiLCJERUZBVUxUX1JBRElVUyIsImMxIiwiYzIiLCJvcHRfcmFkaXVzIiwicmFkaXVzIiwibGF0MSIsImxhdDIiLCJkZWx0YUxhdEJ5MiIsImRlbHRhTG9uQnkyIiwiZ2V0TGVuZ3RoSW50ZXJuYWwiLCJHZW9tZXRyeVR5cGUiLCJjb29yZHMiLCJqaiIsImdldENvb3JkaW5hdGVzIiwiZ2V0R2VvbWV0cmllcyIsImdldEFyZWFJbnRlcm5hbCIsImxvbjEiLCJkQnlSIiwiY291bnRfIiwiZW50cmllc18iLCJvbGRlc3RfIiwibmV3ZXN0XyIsImVudHJ5IiwidmFsdWVfIiwibmV3ZXIiLCJvbGRlciIsInBlZWtMYXN0S2V5Iiwic2V0U2l6ZSIsInBydW5lIiwiZ2V0S2V5WlhZIiwiZnJvbUtleSIsInF1YWRLZXkiLCJ3aXRoaW5FeHRlbnRBbmRaIiwib3B0X3RpbGVDb29yZCIsImRpZ2l0cyIsIm1hc2siLCJjaGFyQ29kZSIsImdldEZ1bGxUaWxlUmFuZ2UiLCJnZXRGb3JQcm9qZWN0aW9uIiwiY3JlYXRlRm9yRXh0ZW50IiwiY3JlYXRlWFlaIiwiY3JlYXRlRm9yUHJvamVjdGlvbiIsImV4dGVudEZyb21Qcm9qZWN0aW9uIiwiZ2V0VGlsZUNvb3JkQ2VudGVyIiwicHJvamVjdGlvbkV4dGVudCIsIndvcmxkV2lkdGgiLCJ3b3JsZHNBd2F5IiwiZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaIiwib3B0X21heFpvb20iLCJvcHRfdGlsZVNpemUiLCJvcHRfY29ybmVyIiwicmVzb2x1dGlvbnNGcm9tRXh0ZW50IiwiVGlsZUdyaWQiLCJvcmlnaW4iLCJERUZBVUxUX01BWF9aT09NIiwiREVGQVVMVF9USUxFX1NJWkUiLCJoYWxmIiwicmVzb2x1dGlvbnNfIiwiem9vbUZhY3RvciIsIm9yaWdpbnMiLCJ6b29tRmFjdG9yXyIsIm9yaWdpbl8iLCJvcmlnaW5zXyIsInRpbGVTaXplc18iLCJ0aWxlU2l6ZXMiLCJ0aWxlU2l6ZV8iLCJmdWxsVGlsZVJhbmdlc18iLCJ0bXBTaXplXyIsInNpemVzIiwiY2FsY3VsYXRlVGlsZVJhbmdlc18iLCJ0bXBUaWxlQ29vcmQiLCJmb3JFYWNoVGlsZUNvb3JkIiwiZm9yRWFjaFRpbGVDb29yZFBhcmVudFRpbGVSYW5nZSIsIm9wdF90aWxlUmFuZ2UiLCJ0aWxlQ29vcmRFeHRlbnQiLCJnZXRPcmlnaW4iLCJnZXRUaWxlQ29vcmRDaGlsZFRpbGVSYW5nZSIsImdldFRpbGVSYW5nZUV4dGVudCIsImdldFRpbGVDb29yZEZvclhZQW5kWl8iLCJnZXRUaWxlQ29vcmRGb3JDb29yZEFuZFJlc29sdXRpb24iLCJnZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fIiwicmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSIsImFkanVzdFgiLCJhZGp1c3RZIiwieEZyb21PcmlnaW4iLCJ5RnJvbU9yaWdpbiIsInRpbGVDb29yZFgiLCJ0aWxlQ29vcmRZIiwiZ2V0VGlsZUNvb3JkUmVzb2x1dGlvbiIsIm9wdF9kaXJlY3Rpb24iLCJmdWxsVGlsZVJhbmdlcyIsImNyZWF0ZUZyb21UZW1wbGF0ZSIsImNyZWF0ZUZyb21UZW1wbGF0ZXMiLCJjcmVhdGVGcm9tVGlsZVVybEZ1bmN0aW9ucyIsImV4cGFuZFVybCIsInRlbXBsYXRlIiwielJlZ0V4IiwieFJlZ0V4IiwieVJlZ0V4IiwiZGFzaFlSZWdFeCIsInRlbXBsYXRlcyIsInRpbGVVcmxGdW5jdGlvbnMiLCJzdGFydENoYXJDb2RlIiwic3RvcENoYXJDb2RlIiwiT05FIiwiU1JDX0FMUEhBIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJDT0xPUl9CVUZGRVJfQklUIiwiVFJJQU5HTEVTIiwiVFJJQU5HTEVfU1RSSVAiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiQVJSQVlfQlVGRkVSIiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJTVFJFQU1fRFJBVyIsIlNUQVRJQ19EUkFXIiwiRFlOQU1JQ19EUkFXIiwiQ1VMTF9GQUNFIiwiQkxFTkQiLCJTVEVOQ0lMX1RFU1QiLCJERVBUSF9URVNUIiwiU0NJU1NPUl9URVNUIiwiVU5TSUdORURfQllURSIsIlVOU0lHTkVEX1NIT1JUIiwiVU5TSUdORURfSU5UIiwiRkxPQVQiLCJSR0JBIiwiRlJBR01FTlRfU0hBREVSIiwiVkVSVEVYX1NIQURFUiIsIkxJTktfU1RBVFVTIiwiTElORUFSIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiVEVYVFVSRV9XUkFQX1MiLCJURVhUVVJFX1dSQVBfVCIsIlRFWFRVUkVfMkQiLCJURVhUVVJFMCIsIkNMQU1QX1RPX0VER0UiLCJDT01QSUxFX1NUQVRVUyIsIkZSQU1FQlVGRkVSIiwiQ09OVEVYVF9JRFMiLCJvcHRfYXR0cmlidXRlcyIsImljb24iLCJ0aXRsZSIsImxpbmsiLCJnZXRMaW5rIiwibm9ybWFsaXplTmFtZSIsIkZ1bmN0aW9uIiwib2xtcyIsInN0eWxlZnVuY3Rpb24iLCJnZXRWYWx1ZSIsIm9sTGF5ZXIiLCJzcHJpdGVJbWFnZSIsInNwcml0ZUltZ1NpemUiLCJpbWciLCJvbmxvYWQiLCJtZWFzdXJlQ2FjaGUiLCJ3cmFwVGV4dCIsImVtIiwid3JhcHBlZFRleHQiLCJvbmVFbSIsIm1lYXN1cmVUZXh0Iiwid29yZHMiLCJ3b3JkIiwiYWxsTGF5ZXJzIiwibGF5ZXJzQnlTb3VyY2VMYXllciIsIm1hcGJveExheWVycyIsIm1hcGJveFNvdXJjZSIsInNvdXJjZUxheWVyIiwiZnVuY3Rpb25DYWNoZSIsImZpbHRlckNhY2hlIiwiaWNvbkltYWdlQ2FjaGUiLCJzdHlsZXMiLCJwYXR0ZXJuQ2FjaGUiLCJzdHlsZUlkcyIsImdldEdlb21ldHJ5Iiwic3R5bGVzTGVuZ3RoIiwibGF5ZXJEYXRhIiwiZW1wdHlPYmoiLCJpY29uSW1nIiwiZXZhbHVhdGVGaWx0ZXIiLCJzdHJva2VDb2xvciIsImljb25JbWFnZSIsImZyb21UZW1wbGF0ZSIsImdldEZpbGwiLCJnZXRTdHJva2UiLCJnZXRUZXh0IiwiU3R5bGUiLCJGaWxsIiwic2V0WkluZGV4IiwiaWNvbl9jYWNoZV9rZXkiLCJwYXR0ZXJuIiwic3ByaXRlSW1hZ2VEYXRhIiwiZ2xvYmFsQWxwaGEiLCJjcmVhdGVQYXR0ZXJuIiwic2V0Q29sb3IiLCJjb2xvcldpdGhPcGFjaXR5IiwiU3Ryb2tlIiwic2V0V2lkdGgiLCJzZXRMaW5lQ2FwIiwic2V0TGluZUpvaW4iLCJzZXRNaXRlckxpbWl0Iiwic2V0TGluZURhc2giLCJoYXNJbWFnZSIsInNraXBMYWJlbCIsInN0eWxlR2VvbSIsImdlb20iLCJnZXRGbGF0TWlkcG9pbnQiLCJzZXRHZW9tZXRyeSIsImljb25TaXplIiwiaWNvbkNvbG9yIiwiaWNvblRyYW5zbGF0ZSIsImljb25UcmFuc2xhdGVBbmNob3IiLCJpY29uQW5jaG9yVmFsdWUiLCJpY29uT2Zmc2V0IiwiY292ZXJ0SWNvbkFuY2hvciIsImFuY2hvck9mZnNldCIsImljb25BbmNob3IiLCJnZXRJbWFnZURhdGEiLCJjYyIsInB1dEltYWdlRGF0YSIsInRyYW5zbGF0ZU9mZnNldCIsIkljb24iLCJhbmNob3JPcmlnaW4iLCJpbWdTaXplIiwicm90YXRlVmFsdWUiLCJzZXRSb3RhdGlvbiIsInNldE9wYWNpdHkiLCJzZXRJbWFnZSIsInNldFRleHQiLCJjaXJjbGVSYWRpdXMiLCJjaXJjbGVTdHJva2VDb2xvciIsImNpcmNsZUNvbG9yIiwiY2lyY2xlT3BhY2l0eSIsImNpcmNsZVN0cm9rZVdpZHRoIiwiY2lyY2xlU3Ryb2tlT3BhY2l0eSIsImNhY2hlX2tleSIsIkNpcmNsZSIsInRleHRGaWVsZCIsIlRleHQiLCJ0ZXh0U2l6ZSIsInRleHRMaW5lSGVpZ2h0IiwiY2hvb3NlRm9udCIsInRleHRUcmFuc2Zvcm0iLCJ3cmFwcGVkTGFiZWwiLCJzZXRGb250IiwidGV4dEFuY2hvciIsInBsYWNlbWVudCIsInNldFBsYWNlbWVudCIsInRleHRIYWxvV2lkdGgiLCJ0ZXh0T2Zmc2V0IiwidGV4dFRyYW5zbGF0ZSIsInZPZmZzZXQiLCJoT2Zmc2V0IiwidGV4dEFsaWduIiwic2V0VGV4dEFsaWduIiwic2V0TWF4QW5nbGUiLCJ0ZXh0QmFzZWxpbmUiLCJzZXRUZXh0QmFzZWxpbmUiLCJzZXRPZmZzZXRYIiwic2V0T2Zmc2V0WSIsInNldEZpbGwiLCJoYWxvQ29sb3IiLCJ0ZXh0SGFsbyIsInNldFN0cm9rZSIsImV4cHJlc3Npb25EYXRhIiwicmF3RXhwcmVzc2lvbiIsImNvbXBpbGVkRXhwcmVzc2lvbiIsInpvb21PYmoiLCJsYXlvdXRPclBhaW50IiwiZnVuY3Rpb25zIiwiaXNFeHByIiwiZm9udE1hcCIsInRlbXBsYXRlUmVnRXgiLCJnZXRab29tRm9yUmVzb2x1dGlvbiIsImRlZ3JlZXMiLCJjYW5kaWRhdGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFD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O0FDQUEsMkQ7Ozs7Ozs7Ozs7O0FDQUEsNkQ7Ozs7Ozs7Ozs7O0FDQUEsNEQ7Ozs7Ozs7Ozs7O0FDQUEsMkQ7Ozs7Ozs7Ozs7O0FDQUEseUQiLCJmaWxlIjoib2xtcy1kZWJ1Zy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIm9sL01hcFwiKSwgcmVxdWlyZShcIm9sL09ic2VydmFibGVcIiksIHJlcXVpcmUoXCJvbC9mb3JtYXQvR2VvSlNPTlwiKSwgcmVxdWlyZShcIm9sL2Zvcm1hdC9NVlRcIiksIHJlcXVpcmUoXCJvbC9nZW9tL1BvaW50XCIpLCByZXF1aXJlKFwib2wvbGF5ZXIvVGlsZVwiKSwgcmVxdWlyZShcIm9sL2xheWVyL1ZlY3RvclwiKSwgcmVxdWlyZShcIm9sL2xheWVyL1ZlY3RvclRpbGVcIiksIHJlcXVpcmUoXCJvbC9wcm9qXCIpLCByZXF1aXJlKFwib2wvc291cmNlL1RpbGVKU09OXCIpLCByZXF1aXJlKFwib2wvc291cmNlL1ZlY3RvclwiKSwgcmVxdWlyZShcIm9sL3NvdXJjZS9WZWN0b3JUaWxlXCIpLCByZXF1aXJlKFwib2wvc3R5bGUvQ2lyY2xlXCIpLCByZXF1aXJlKFwib2wvc3R5bGUvRmlsbFwiKSwgcmVxdWlyZShcIm9sL3N0eWxlL0ljb25cIiksIHJlcXVpcmUoXCJvbC9zdHlsZS9TdHJva2VcIiksIHJlcXVpcmUoXCJvbC9zdHlsZS9TdHlsZVwiKSwgcmVxdWlyZShcIm9sL3N0eWxlL1RleHRcIiksIHJlcXVpcmUoXCJvbC90aWxlZ3JpZFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJvbC9NYXBcIiwgXCJvbC9PYnNlcnZhYmxlXCIsIFwib2wvZm9ybWF0L0dlb0pTT05cIiwgXCJvbC9mb3JtYXQvTVZUXCIsIFwib2wvZ2VvbS9Qb2ludFwiLCBcIm9sL2xheWVyL1RpbGVcIiwgXCJvbC9sYXllci9WZWN0b3JcIiwgXCJvbC9sYXllci9WZWN0b3JUaWxlXCIsIFwib2wvcHJvalwiLCBcIm9sL3NvdXJjZS9UaWxlSlNPTlwiLCBcIm9sL3NvdXJjZS9WZWN0b3JcIiwgXCJvbC9zb3VyY2UvVmVjdG9yVGlsZVwiLCBcIm9sL3N0eWxlL0NpcmNsZVwiLCBcIm9sL3N0eWxlL0ZpbGxcIiwgXCJvbC9zdHlsZS9JY29uXCIsIFwib2wvc3R5bGUvU3Ryb2tlXCIsIFwib2wvc3R5bGUvU3R5bGVcIiwgXCJvbC9zdHlsZS9UZXh0XCIsIFwib2wvdGlsZWdyaWRcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wib2xtc1wiXSA9IGZhY3RvcnkocmVxdWlyZShcIm9sL01hcFwiKSwgcmVxdWlyZShcIm9sL09ic2VydmFibGVcIiksIHJlcXVpcmUoXCJvbC9mb3JtYXQvR2VvSlNPTlwiKSwgcmVxdWlyZShcIm9sL2Zvcm1hdC9NVlRcIiksIHJlcXVpcmUoXCJvbC9nZW9tL1BvaW50XCIpLCByZXF1aXJlKFwib2wvbGF5ZXIvVGlsZVwiKSwgcmVxdWlyZShcIm9sL2xheWVyL1ZlY3RvclwiKSwgcmVxdWlyZShcIm9sL2xheWVyL1ZlY3RvclRpbGVcIiksIHJlcXVpcmUoXCJvbC9wcm9qXCIpLCByZXF1aXJlKFwib2wvc291cmNlL1RpbGVKU09OXCIpLCByZXF1aXJlKFwib2wvc291cmNlL1ZlY3RvclwiKSwgcmVxdWlyZShcIm9sL3NvdXJjZS9WZWN0b3JUaWxlXCIpLCByZXF1aXJlKFwib2wvc3R5bGUvQ2lyY2xlXCIpLCByZXF1aXJlKFwib2wvc3R5bGUvRmlsbFwiKSwgcmVxdWlyZShcIm9sL3N0eWxlL0ljb25cIiksIHJlcXVpcmUoXCJvbC9zdHlsZS9TdHJva2VcIiksIHJlcXVpcmUoXCJvbC9zdHlsZS9TdHlsZVwiKSwgcmVxdWlyZShcIm9sL3N0eWxlL1RleHRcIiksIHJlcXVpcmUoXCJvbC90aWxlZ3JpZFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wib2xtc1wiXSA9IGZhY3Rvcnkocm9vdFtcIm9sXCJdW1wiTWFwXCJdLCByb290W1wib2xcIl1bXCJPYnNlcnZhYmxlXCJdLCByb290W1wib2xcIl1bXCJmb3JtYXRcIl1bXCJHZW9KU09OXCJdLCByb290W1wib2xcIl1bXCJmb3JtYXRcIl1bXCJNVlRcIl0sIHJvb3RbXCJvbFwiXVtcImdlb21cIl1bXCJQb2ludFwiXSwgcm9vdFtcIm9sXCJdW1wibGF5ZXJcIl1bXCJUaWxlXCJdLCByb290W1wib2xcIl1bXCJsYXllclwiXVtcIlZlY3RvclwiXSwgcm9vdFtcIm9sXCJdW1wibGF5ZXJcIl1bXCJWZWN0b3JUaWxlXCJdLCByb290W1wib2xcIl1bXCJwcm9qXCJdLCByb290W1wib2xcIl1bXCJzb3VyY2VcIl1bXCJUaWxlSlNPTlwiXSwgcm9vdFtcIm9sXCJdW1wic291cmNlXCJdW1wiVmVjdG9yXCJdLCByb290W1wib2xcIl1bXCJzb3VyY2VcIl1bXCJWZWN0b3JUaWxlXCJdLCByb290W1wib2xcIl1bXCJzdHlsZVwiXVtcIkNpcmNsZVwiXSwgcm9vdFtcIm9sXCJdW1wic3R5bGVcIl1bXCJGaWxsXCJdLCByb290W1wib2xcIl1bXCJzdHlsZVwiXVtcIkljb25cIl0sIHJvb3RbXCJvbFwiXVtcInN0eWxlXCJdW1wiU3Ryb2tlXCJdLCByb290W1wib2xcIl1bXCJzdHlsZVwiXVtcIlN0eWxlXCJdLCByb290W1wib2xcIl1bXCJzdHlsZVwiXVtcIlRleHRcIl0sIHJvb3RbXCJvbFwiXVtcInRpbGVncmlkXCJdKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9NYXBfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9PYnNlcnZhYmxlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfZm9ybWF0X0dlb0pTT05fXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9mb3JtYXRfTVZUX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfZ2VvbV9Qb2ludF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX2xheWVyX1RpbGVfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9sYXllcl9WZWN0b3JfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9sYXllcl9WZWN0b3JUaWxlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfcHJval9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3NvdXJjZV9UaWxlSlNPTl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3NvdXJjZV9WZWN0b3JfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zb3VyY2VfVmVjdG9yVGlsZV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3N0eWxlX0NpcmNsZV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3N0eWxlX0ZpbGxfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zdHlsZV9JY29uX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfc3R5bGVfU3Ryb2tlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfc3R5bGVfU3R5bGVfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zdHlsZV9UZXh0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfdGlsZWdyaWRfXykge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vb2xtcy5qc1wiKTtcbiIsIi8qXHJcbm9sLW1hcGJveC1zdHlsZSAtIFVzZSBNYXBib3ggU3R5bGUgb2JqZWN0cyB3aXRoIE9wZW5MYXllcnNcclxuQ29weXJpZ2h0IDIwMTYtcHJlc2VudCBCb3VuZGxlc3MgU3BhdGlhbCwgSW5jLlxyXG5MaWNlbnNlOiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYm91bmRsZXNzZ2VvL29sLW1hcGJveC1nbC1zdHlsZS9tYXN0ZXIvTElDRU5TRVxyXG4qL1xyXG5cclxuaW1wb3J0IHtDb2xvcn0gZnJvbSAnQG1hcGJveC9tYXBib3gtZ2wtc3R5bGUtc3BlYyc7XHJcbmltcG9ydCBtYjJjc3MgZnJvbSAnbWFwYm94LXRvLWNzcy1mb250JztcclxuaW1wb3J0IGFwcGx5U3R5bGVGdW5jdGlvbiwge2dldFZhbHVlfSBmcm9tICcuL3N0eWxlZnVuY3Rpb24nO1xyXG5pbXBvcnQgZ29vZ2xlRm9udHMgZnJvbSAnd2ViZm9udC1tYXRjaGVyL2xpYi9mb250cy9nb29nbGUnO1xyXG5pbXBvcnQge2Zyb21Mb25MYXR9IGZyb20gJ29sL3Byb2onO1xyXG5pbXBvcnQge2NyZWF0ZVhZWn0gZnJvbSAnb2wvdGlsZWdyaWQnO1xyXG5pbXBvcnQgTWFwIGZyb20gJ29sL01hcCc7XHJcbmltcG9ydCBHZW9KU09OIGZyb20gJ29sL2Zvcm1hdC9HZW9KU09OJztcclxuaW1wb3J0IE1WVCBmcm9tICdvbC9mb3JtYXQvTVZUJztcclxuaW1wb3J0IHt1bkJ5S2V5fSBmcm9tICdvbC9PYnNlcnZhYmxlJztcclxuaW1wb3J0IFRpbGVMYXllciBmcm9tICdvbC9sYXllci9UaWxlJztcclxuaW1wb3J0IFZlY3RvckxheWVyIGZyb20gJ29sL2xheWVyL1ZlY3Rvcic7XHJcbmltcG9ydCBWZWN0b3JUaWxlTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVmVjdG9yVGlsZSc7XHJcbmltcG9ydCBUaWxlSlNPTiBmcm9tICdvbC9zb3VyY2UvVGlsZUpTT04nO1xyXG5pbXBvcnQgVmVjdG9yU291cmNlIGZyb20gJ29sL3NvdXJjZS9WZWN0b3InO1xyXG5pbXBvcnQgVmVjdG9yVGlsZVNvdXJjZSBmcm9tICdvbC9zb3VyY2UvVmVjdG9yVGlsZSc7XHJcbmltcG9ydCBYWVogZnJvbSAnb2wvc291cmNlL1hZWic7XHJcblxyXG52YXIgYXZhaWxhYmxlRm9udHM7XHJcblxyXG5mdW5jdGlvbiBsb2FkRm9udChmb250cykge1xyXG4gIHZhciBpLCBpaTtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkoZm9udHMpKSB7XHJcbiAgICB2YXIgc3RvcHMgPSBmb250cy5zdG9wcztcclxuICAgIGlmIChzdG9wcykge1xyXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHN0b3BzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgICBsb2FkRm9udChzdG9wc1tpXVsxXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIGdvb2dsZUZhbWlsaWVzID0gZ29vZ2xlRm9udHMuZ2V0TmFtZXMoKTtcclxuICB2YXIgZmFtaWxpZXMgPSBmb250cy5tYXAoZnVuY3Rpb24oZm9udCkge1xyXG4gICAgcmV0dXJuIG1iMmNzcyhmb250LCAxKS5zcGxpdCgnIDFweCAnKVsxXS5yZXBsYWNlKC9cIi9nLCAnJyk7XHJcbiAgfSk7XHJcbiAgZm9yIChpID0gMCwgaWkgPSBmYW1pbGllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICB2YXIgZmFtaWx5ID0gZmFtaWxpZXNbaV07XHJcbiAgICB2YXIgZm9udCA9IGZvbnRzW2ldO1xyXG4gICAgaWYgKGdvb2dsZUZhbWlsaWVzLmluZGV4T2YoZmFtaWx5KSAhPT0gLTEpIHtcclxuICAgICAgaWYgKCFhdmFpbGFibGVGb250cykge1xyXG4gICAgICAgIGF2YWlsYWJsZUZvbnRzID0gW107XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGF2YWlsYWJsZUZvbnRzLmluZGV4T2YoZm9udCkgPT0gLTEpIHtcclxuICAgICAgICBhdmFpbGFibGVGb250cy5wdXNoKGZvbnQpO1xyXG4gICAgICAgIHZhciBmb250VXJsID0gJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT0nICsgZmFtaWx5LnJlcGxhY2UoLyAvZywgJysnKTtcclxuICAgICAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZj1cIicgKyBmb250VXJsICsgJ1wiXScpKSB7XHJcbiAgICAgICAgICB2YXIgbWFya3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xyXG4gICAgICAgICAgbWFya3VwLmhyZWYgPSBmb250VXJsO1xyXG4gICAgICAgICAgbWFya3VwLnJlbCA9ICdzdHlsZXNoZWV0JztcclxuICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobWFya3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgZGVmYXVsdEZvbnQgPSBbJ09wZW4gU2FucyBSZWd1bGFyJywgJ0FyaWFsIFJlZ3VsYXInXTtcclxuXHJcbmZ1bmN0aW9uIHByZXByb2Nlc3MobGF5ZXIpIHtcclxuICBpZiAoJ2xheW91dCcgaW4gbGF5ZXIgJiYgJ3RleHQtZmllbGQnIGluIGxheWVyLmxheW91dCkge1xyXG4gICAgbG9hZEZvbnQobGF5ZXIubGF5b3V0Wyd0ZXh0LWZvbnQnXSB8fCBkZWZhdWx0Rm9udCk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgc3ByaXRlUmVnRXggPSAvXiguKikoXFw/LiopJC87XHJcblxyXG5mdW5jdGlvbiB3aXRoUGF0aCh1cmwsIHBhdGgpIHtcclxuICBpZiAocGF0aCAmJiB1cmwuaW5kZXhPZignaHR0cCcpICE9IDApIHtcclxuICAgIHVybCA9IHBhdGggKyB1cmw7XHJcbiAgfVxyXG4gIHJldHVybiB1cmw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvU3ByaXRlVXJsKHVybCwgcGF0aCwgZXh0ZW5zaW9uKSB7XHJcbiAgdXJsID0gd2l0aFBhdGgodXJsLCBwYXRoKTtcclxuICB2YXIgcGFydHMgPSB1cmwubWF0Y2goc3ByaXRlUmVnRXgpO1xyXG4gIHJldHVybiBwYXJ0cyA/XHJcbiAgICBwYXJ0c1sxXSArIGV4dGVuc2lvbiArIChwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiAnJykgOlxyXG4gICAgdXJsICsgZXh0ZW5zaW9uO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbGllcyBhIHN0eWxlIGZ1bmN0aW9uIHRvIGFuIGBvbC5sYXllci5WZWN0b3JUaWxlYCBvciBgb2wubGF5ZXIuVmVjdG9yYFxyXG4gKiB3aXRoIGFuIGBvbC5zb3VyY2UuVmVjdG9yVGlsZWAgb3IgYW4gYG9sLnNvdXJjZS5WZWN0b3JgLiBUaGUgc3R5bGUgZnVuY3Rpb25cclxuICogd2lsbCByZW5kZXIgYWxsIGxheWVycyBmcm9tIHRoZSBgZ2xTdHlsZWAgb2JqZWN0IHRoYXQgdXNlIHRoZSBzcGVjaWZpZWRcclxuICogYHNvdXJjZWAsIG9yIGEgc3Vic2V0IG9mIGxheWVycyBmcm9tIHRoZSBzYW1lIHNvdXJjZS4gVGhlIHNvdXJjZSBuZWVkcyB0byBiZVxyXG4gKiBhIGBcInR5cGVcIjogXCJ2ZWN0b3JcImAsIGBcInR5cGVcIjogXCJnZW9qc29uXCJgIG9yIGBcInR5cGVcIjogXCJyYXN0ZXJcImAgc291cmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29sLmxheWVyLlZlY3RvclRpbGV9IGxheWVyIE9wZW5MYXllcnMgbGF5ZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZ2xTdHlsZSBNYXBib3ggU3R5bGUgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIGBzb3VyY2VgIGtleSBvciBhbiBhcnJheSBvZiBsYXllciBgaWRgcyBmcm9tIHRoZVxyXG4gKiBNYXBib3ggU3R5bGUgb2JqZWN0LiBXaGVuIGEgYHNvdXJjZWAga2V5IGlzIHByb3ZpZGVkLCBhbGwgbGF5ZXJzIGZvciB0aGVcclxuICogc3BlY2lmaWVkIHNvdXJjZSB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBzdHlsZSBmdW5jdGlvbi4gV2hlbiBsYXllciBgaWRgc1xyXG4gKiBhcmUgcHJvdmlkZWQsIHRoZXkgbXVzdCBiZSBmcm9tIGxheWVycyB0aGF0IHVzZSB0aGUgc2FtZSBzb3VyY2UuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aD11bmRlZmluZWRdIFBhdGggb2YgdGhlIHN0eWxlIGZpbGUuIE9ubHkgcmVxdWlyZWQgd2hlblxyXG4gKiBhIHJlbGF0aXZlIHBhdGggaXMgdXNlZCB3aXRoIHRoZSBgXCJzcHJpdGVcImAgcHJvcGVydHkgb2YgdGhlIHN0eWxlLlxyXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtyZXNvbHV0aW9ucz11bmRlZmluZWRdIFJlc29sdXRpb25zIGZvciBtYXBwaW5nIHJlc29sdXRpb24gdG8gem9vbSBsZXZlbC5cclxuICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHN0eWxlIGNhbiBiZSB1c2VkXHJcbiAqIGZvciByZW5kZXJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTdHlsZShsYXllciwgZ2xTdHlsZSwgc291cmNlLCBwYXRoLCByZXNvbHV0aW9ucykge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIGdsU3R5bGUgIT0gJ29iamVjdCcpIHtcclxuICAgICAgZ2xTdHlsZSA9IEpTT04ucGFyc2UoZ2xTdHlsZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZ2xTdHlsZS52ZXJzaW9uICE9IDgpIHtcclxuICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2xTdHlsZSB2ZXJzaW9uIDggcmVxdWlyZWQuJykpO1xyXG4gICAgfVxyXG4gICAgdmFyIHNwcml0ZVNjYWxlLCBzcHJpdGVEYXRhLCBzcHJpdGVJbWFnZVVybDtcclxuICAgIGlmIChnbFN0eWxlLnNwcml0ZSkge1xyXG4gICAgICBzcHJpdGVTY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID49IDEuNSA/IDAuNSA6IDE7XHJcbiAgICAgIHZhciBzaXplRmFjdG9yID0gc3ByaXRlU2NhbGUgPT0gMC41ID8gJ0AyeCcgOiAnJztcclxuICAgICAgdmFyIHNwcml0ZVVybCA9IHRvU3ByaXRlVXJsKGdsU3R5bGUuc3ByaXRlLCBwYXRoLCBzaXplRmFjdG9yICsgJy5qc29uJyk7XHJcblxyXG4gICAgICBmZXRjaChzcHJpdGVVcmwsIHtjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ30pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgIC8vIGlmIHRoZSByZXNwb25zZSBpcyByZWFkeSByZXR1cm4gdGhlIEpTT04gcHJvbWlzZVxyXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHNpemVGYWN0b3IgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgSlNPTiBwcm9taXNlIGZvciB0aGUgbG93LXJlc29sdXRpb24gc3ByaXRlcy5cclxuICAgICAgICAgICAgc2l6ZUZhY3RvciA9ICcnO1xyXG4gICAgICAgICAgICBzcHJpdGVVcmwgPSB0b1Nwcml0ZVVybChnbFN0eWxlLnNwcml0ZSwgcGF0aCwgJy5qc29uJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChzcHJpdGVVcmwsIHtjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ30pLnRoZW4ociA9PiByLmpzb24oKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihzcHJpdGVzSnNvbikge1xyXG4gICAgICAgICAgaWYgKHNwcml0ZXNKc29uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ05vIHNwcml0ZXMgZm91bmQuJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNwcml0ZURhdGEgPSBzcHJpdGVzSnNvbjtcclxuICAgICAgICAgIHNwcml0ZUltYWdlVXJsID0gdG9TcHJpdGVVcmwoZ2xTdHlsZS5zcHJpdGUsIHBhdGgsIHNpemVGYWN0b3IgKyAnLnBuZycpO1xyXG4gICAgICAgICAgb25DaGFuZ2UoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1Nwcml0ZXMgY2Fubm90IGJlIGxvYWRlZCBmcm9tICcgKyBzcHJpdGVVcmwpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3R5bGU7XHJcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcclxuICAgICAgaWYgKCFzdHlsZSAmJiAoIWdsU3R5bGUuc3ByaXRlIHx8IHNwcml0ZURhdGEpICYmICghYXZhaWxhYmxlRm9udHMgfHwgYXZhaWxhYmxlRm9udHMubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICBzdHlsZSA9IGFwcGx5U3R5bGVGdW5jdGlvbihsYXllciwgZ2xTdHlsZSwgc291cmNlLCByZXNvbHV0aW9ucywgc3ByaXRlRGF0YSwgc3ByaXRlSW1hZ2VVcmwsIGF2YWlsYWJsZUZvbnRzKTtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUpIHtcclxuICAgICAgICBsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBWZWN0b3JUaWxlTGF5ZXIgfHwgbGF5ZXIgaW5zdGFuY2VvZiBWZWN0b3JMYXllcikge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBsYXllcnMgPSBnbFN0eWxlLmxheWVycztcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT0gJ3N0cmluZycgJiYgbGF5ZXJzW2ldLnNvdXJjZSA9PSBzb3VyY2UgfHwgc291cmNlLmluZGV4T2YobGF5ZXJzW2ldLmlkKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHByZXByb2Nlc3MobGF5ZXJzW2ldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb25DaGFuZ2UoKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0QmFja2dyb3VuZChtYXAsIGxheWVyKSB7XHJcbiAgY29uc3QgYmFja2dyb3VuZCA9IHtcclxuICAgIHR5cGU6IGxheWVyLnR5cGVcclxuICB9O1xyXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBtYXAuZ2V0VGFyZ2V0RWxlbWVudCgpO1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBsYXlvdXQgPSBsYXllci5sYXlvdXQgfHwge307XHJcbiAgICB2YXIgcGFpbnQgPSBsYXllci5wYWludCB8fCB7fTtcclxuICAgIGJhY2tncm91bmRbJ3BhaW50J10gPSBwYWludDtcclxuICAgIGJhY2tncm91bmQuaWQgPSAnb2xtcy1iZy0nICsgcGFpbnRbJ2JhY2tncm91bmQtb3BhY2l0eSddICsgcGFpbnRbJ2JhY2tncm91bmQtY29sb3InXTtcclxuICAgIHZhciB6b29tID0gbWFwLmdldFZpZXcoKS5nZXRab29tKCk7XHJcbiAgICBpZiAocGFpbnRbJ2JhY2tncm91bmQtY29sb3InXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IGJnID0gZ2V0VmFsdWUoYmFja2dyb3VuZCwgJ3BhaW50JywgJ2JhY2tncm91bmQtY29sb3InLCB6b29tLCB7fSk7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9IENvbG9yLnBhcnNlKGJnKS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhaW50WydiYWNrZ3JvdW5kLW9wYWNpdHknXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IGdldFZhbHVlKGJhY2tncm91bmQsICdwYWludCcsICdiYWNrZ3JvdW5kLW9wYWNpdHknLCB6b29tLCB7fSk7XHJcbiAgICB9XHJcbiAgICBpZiAobGF5b3V0LnZpc2liaWxpdHkgPT0gJ25vbmUnKSB7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyc7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9ICcnO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAobWFwLmdldFRhcmdldEVsZW1lbnQoKSkge1xyXG4gICAgdXBkYXRlU3R5bGUoKTtcclxuICB9XHJcbiAgbWFwLm9uKFsnY2hhbmdlOnJlc29sdXRpb24nLCAnY2hhbmdlOnRhcmdldCddLCB1cGRhdGVTdHlsZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHByb3BlcnRpZXMgb2YgdGhlIE1hcGJveCBTdHlsZSdzIGZpcnN0IGBiYWNrZ3JvdW5kYCBsYXllciB0byB0aGUgbWFwLlxyXG4gKiBAcGFyYW0ge29sLk1hcH0gbWFwIE9wZW5MYXllcnMgTWFwLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZ2xTdHlsZSBNYXBib3ggU3R5bGUgb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5QmFja2dyb3VuZChtYXAsIGdsU3R5bGUpIHtcclxuICBnbFN0eWxlLmxheWVycy5zb21lKGZ1bmN0aW9uKGwpIHtcclxuICAgIGlmIChsLnR5cGUgPT0gJ2JhY2tncm91bmQnKSB7XHJcbiAgICAgIHNldEJhY2tncm91bmQobWFwLCBsKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNvdXJjZUlkQnlSZWYobGF5ZXJzLCByZWYpIHtcclxuICB2YXIgc291cmNlSWQ7XHJcbiAgbGF5ZXJzLnNvbWUoZnVuY3Rpb24obGF5ZXIpIHtcclxuICAgIGlmIChsYXllci5pZCA9PSByZWYpIHtcclxuICAgICAgc291cmNlSWQgPSBsYXllci5zb3VyY2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBzb3VyY2VJZDtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1N0eWxlKGdsU3R5bGUsIG1hcCwgYmFzZVVybCwgaG9zdCwgcGF0aCwgYWNjZXNzVG9rZW4pIHtcclxuICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XHJcbiAgaWYgKCdjZW50ZXInIGluIGdsU3R5bGUgJiYgIXZpZXcuZ2V0Q2VudGVyKCkpIHtcclxuICAgIHZpZXcuc2V0Q2VudGVyKGZyb21Mb25MYXQoZ2xTdHlsZS5jZW50ZXIpKTtcclxuICB9XHJcbiAgaWYgKCd6b29tJyBpbiBnbFN0eWxlICYmIHZpZXcuZ2V0Wm9vbSgpID09PSB1bmRlZmluZWQpIHtcclxuICAgIHZpZXcuc2V0Wm9vbShnbFN0eWxlLnpvb20pO1xyXG4gIH1cclxuICBpZiAoIXZpZXcuZ2V0Q2VudGVyKCkgfHwgdmlldy5nZXRab29tKCkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdmlldy5maXQodmlldy5nZXRQcm9qZWN0aW9uKCkuZ2V0RXh0ZW50KCksIHtcclxuICAgICAgbmVhcmVzdDogdHJ1ZSxcclxuICAgICAgc2l6ZTogbWFwLmdldFNpemUoKVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChnbFN0eWxlLnNwcml0ZSkge1xyXG4gICAgaWYgKGdsU3R5bGUuc3ByaXRlLmluZGV4T2YoJ21hcGJveDovLycpID09IDApIHtcclxuICAgICAgZ2xTdHlsZS5zcHJpdGUgPSBiYXNlVXJsICsgJy9zcHJpdGUnICsgYWNjZXNzVG9rZW47XHJcbiAgICB9IGVsc2UgaWYgKGdsU3R5bGUuc3ByaXRlLmluZGV4T2YoJ2h0dHAnKSAhPSAwKSB7XHJcbiAgICAgIGdsU3R5bGUuc3ByaXRlID0gKGhvc3QgPyAoaG9zdCArIHBhdGgpIDogJycpICsgZ2xTdHlsZS5zcHJpdGUgKyBhY2Nlc3NUb2tlbjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBnbExheWVycyA9IGdsU3R5bGUubGF5ZXJzO1xyXG4gIHZhciBnZW9Kc29uRm9ybWF0ID0gbmV3IEdlb0pTT04oKTtcclxuICB2YXIgbGF5ZXJJZHMgPSBbXTtcclxuXHJcbiAgZnVuY3Rpb24gZmluYWxpemVMYXllcihsYXllcikge1xyXG4gICAgaWYgKGxheWVySWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgbWFwLmFkZExheWVyKGxheWVyKTtcclxuICAgICAgdmFyIHNldFN0eWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXBwbHlTdHlsZShsYXllciwgZ2xTdHlsZSwgbGF5ZXJJZHMsIHBhdGgpLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBsYXllci5zZXRWaXNpYmxlKHRydWUpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIC8qZXNsaW50IG5vLWNvbnNvbGU6IFtcImVycm9yXCIsIHsgYWxsb3c6IFtcImVycm9yXCJdIH1dICovXHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICBpZiAobGF5ZXIuZ2V0U291cmNlKCkpIHtcclxuICAgICAgICBzZXRTdHlsZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxheWVyLm9uY2UoJ2NoYW5nZTpzb3VyY2UnLCBzZXRTdHlsZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBnbExheWVyLCBnbFNvdXJjZSwgZ2xTb3VyY2VJZCwgaWQsIGxheWVyLCBtYXBpZCwgdXJsO1xyXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGdsTGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgIGdsTGF5ZXIgPSBnbExheWVyc1tpXTtcclxuICAgIGlmIChnbExheWVyLnR5cGUgPT0gJ2JhY2tncm91bmQnKSB7XHJcbiAgICAgIHNldEJhY2tncm91bmQobWFwLCBnbExheWVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlkID0gZ2xMYXllci5zb3VyY2UgfHwgZ2V0U291cmNlSWRCeVJlZihnbExheWVycywgZ2xMYXllci5yZWYpO1xyXG4gICAgICBpZiAoaWQgIT0gZ2xTb3VyY2VJZCkge1xyXG4gICAgICAgIGZpbmFsaXplTGF5ZXIobGF5ZXIpO1xyXG4gICAgICAgIGxheWVySWRzID0gW107XHJcbiAgICAgICAgZ2xTb3VyY2UgPSBnbFN0eWxlLnNvdXJjZXNbaWRdO1xyXG4gICAgICAgIHVybCA9IGdsU291cmNlLnVybDtcclxuICAgICAgICB2YXIgdGlsZXMgPSBnbFNvdXJjZS50aWxlcztcclxuICAgICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJ21hcGJveDovLycpID09IDApIHtcclxuICAgICAgICAgICAgbWFwaWQgPSB1cmwucmVwbGFjZSgnbWFwYm94Oi8vJywgJycpO1xyXG4gICAgICAgICAgICB0aWxlcyA9IFsnYScsICdiJywgJ2MnLCAnZCddLm1hcChmdW5jdGlvbihob3N0KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICdodHRwczovLycgKyBob3N0ICsgJy50aWxlcy5tYXBib3guY29tL3Y0LycgKyBtYXBpZCArXHJcbiAgICAgICAgICAgICAgICAgICcve3p9L3t4fS97eX0uJyArXHJcbiAgICAgICAgICAgICAgICAgIChnbFNvdXJjZS50eXBlID09ICd2ZWN0b3InID8gJ3ZlY3Rvci5wYmYnIDogJ3BuZycpICtcclxuICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGdsU291cmNlLnR5cGUgPT0gJ3ZlY3RvcicpIHtcclxuICAgICAgICAgIGxheWVyID0gdGlsZXMgPyAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlR3JpZCA9IGNyZWF0ZVhZWih7XHJcbiAgICAgICAgICAgICAgdGlsZVNpemU6IDUxMixcclxuICAgICAgICAgICAgICBtYXhab29tOiAnbWF4em9vbScgaW4gZ2xTb3VyY2UgPyBnbFNvdXJjZS5tYXh6b29tIDogMjIsXHJcbiAgICAgICAgICAgICAgbWluWm9vbTogZ2xTb3VyY2UubWluem9vbVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3JUaWxlTGF5ZXIoe1xyXG4gICAgICAgICAgICAgIGRlY2x1dHRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICBtYXhSZXNvbHV0aW9uOiB0aWxlR3JpZC5nZXRNaW5ab29tKCkgPiAwID9cclxuICAgICAgICAgICAgICAgIHRpbGVHcmlkLmdldFJlc29sdXRpb24odGlsZUdyaWQuZ2V0TWluWm9vbSgpKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICBzb3VyY2U6IG5ldyBWZWN0b3JUaWxlU291cmNlKHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0aW9uczogZ2xTb3VyY2UuYXR0cmlidXRpb24sXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IG5ldyBNVlQoKSxcclxuICAgICAgICAgICAgICAgIHRpbGVHcmlkOiB0aWxlR3JpZCxcclxuICAgICAgICAgICAgICAgIHVybHM6IHRpbGVzXHJcbiAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgekluZGV4OiBpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSkoKSA6IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gbmV3IFZlY3RvclRpbGVMYXllcih7XHJcbiAgICAgICAgICAgICAgZGVjbHV0dGVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIHpJbmRleDogaVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHRpbGVqc29uID0gbmV3IFRpbGVKU09OKHtcclxuICAgICAgICAgICAgICB1cmw6IHVybFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRpbGVqc29uLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBpZiAodGlsZWpzb24uZ2V0U3RhdGUoKSA9PSAncmVhZHknKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlsZUpTT05Eb2MgPSB0aWxlanNvbi5nZXRUaWxlSlNPTigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVzID0gQXJyYXkuaXNBcnJheSh0aWxlSlNPTkRvYy50aWxlcykgPyB0aWxlSlNPTkRvYy50aWxlcyA6IFt0aWxlSlNPTkRvYy50aWxlc107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aWxlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB0aWxlID0gdGlsZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgIGlmICh0aWxlLmluZGV4T2YoJ2h0dHAnKSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZXNbaV0gPSBnbFNvdXJjZS51cmwgKyB0aWxlO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlsZUdyaWQgPSB0aWxlanNvbi5nZXRUaWxlR3JpZCgpO1xyXG4gICAgICAgICAgICAgICAgbGF5ZXIuc2V0U291cmNlKG5ldyBWZWN0b3JUaWxlU291cmNlKHtcclxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb25zOiB0aWxlanNvbi5nZXRBdHRyaWJ1dGlvbnMoKSB8fCB0aWxlSlNPTkRvYy5hdHRyaWJ1dGlvbixcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0OiBuZXcgTVZUKCksXHJcbiAgICAgICAgICAgICAgICAgIHRpbGVHcmlkOiBjcmVhdGVYWVooe1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblpvb206IHRpbGVHcmlkLmdldE1pblpvb20oKSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhab29tOiB0aWxlR3JpZC5nZXRNYXhab29tKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZVNpemU6IDUxMlxyXG4gICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgdXJsczogdGlsZXNcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aWxlR3JpZC5nZXRNaW5ab29tKCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIGxheWVyLnNldE1heFJlc29sdXRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih0aWxlR3JpZC5nZXRNaW5ab29tKCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVuQnlLZXkoa2V5KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICAgICAgICB9KSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZ2xTb3VyY2UudHlwZSA9PSAncmFzdGVyJykge1xyXG4gICAgICAgICAgdmFyIHNvdXJjZTtcclxuICAgICAgICAgIGlmICghZ2xTb3VyY2UudGlsZXMpIHtcclxuICAgICAgICAgICAgc291cmNlID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVGlsZUpTT04oe1xyXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IG5ldyBYWVooe1xyXG4gICAgICAgICAgICAgIGF0dHJpYnV0aW9uczogZ2xTb3VyY2UuYXR0cmlidXRpb24sXHJcbiAgICAgICAgICAgICAgbWluWm9vbTogZ2xTb3VyY2UubWluem9vbSxcclxuICAgICAgICAgICAgICBtYXhab29tOiAnbWF4em9vbScgaW4gZ2xTb3VyY2UgPyBnbFNvdXJjZS5tYXh6b29tIDogMjIsXHJcbiAgICAgICAgICAgICAgdGlsZVNpemU6IGdsU291cmNlLnRpbGVTaXplIHx8IDUxMixcclxuICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICB1cmxzOiBnbFNvdXJjZS50aWxlcyxcclxuICAgICAgICAgICAgICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzb3VyY2Uuc2V0VGlsZUxvYWRGdW5jdGlvbihmdW5jdGlvbih0aWxlLCBzcmMpIHtcclxuICAgICAgICAgICAgaWYgKHNyYy5pbmRleE9mKCd7YmJveC1lcHNnLTM4NTd9JykgIT0gLTEpIHtcclxuICAgICAgICAgICAgICB2YXIgYmJveCA9IHNvdXJjZS5nZXRUaWxlR3JpZCgpLmdldFRpbGVDb29yZEV4dGVudCh0aWxlLmdldFRpbGVDb29yZCgpKTtcclxuICAgICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgne2Jib3gtZXBzZy0zODU3fScsIGJib3gudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgbGF5ZXIgPSBuZXcgVGlsZUxheWVyKHtcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGdsTGF5ZXIubGF5b3V0ID8gZ2xMYXllci5sYXlvdXQudmlzaWJpbGl0eSAhPT0gJ25vbmUnIDogdHJ1ZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChnbFNvdXJjZS50eXBlID09ICdnZW9qc29uJykge1xyXG4gICAgICAgICAgdmFyIGRhdGEgPSBnbFNvdXJjZS5kYXRhO1xyXG4gICAgICAgICAgdmFyIGZlYXR1cmVzLCBnZW9Kc29uVXJsO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGdlb0pzb25VcmwgPSB3aXRoUGF0aChkYXRhLCBwYXRoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmVzID0gZ2VvSnNvbkZvcm1hdC5yZWFkRmVhdHVyZXMoZGF0YSwge2ZlYXR1cmVQcm9qZWN0aW9uOiAnRVBTRzozODU3J30pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGF5ZXIgPSBuZXcgVmVjdG9yTGF5ZXIoe1xyXG4gICAgICAgICAgICBzb3VyY2U6IG5ldyBWZWN0b3JTb3VyY2Uoe1xyXG4gICAgICAgICAgICAgIGF0dHJpYnV0aW9uczogZ2xTb3VyY2UuYXR0cmlidXRpb24sXHJcbiAgICAgICAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzLFxyXG4gICAgICAgICAgICAgIGZvcm1hdDogZ2VvSnNvbkZvcm1hdCxcclxuICAgICAgICAgICAgICB1cmw6IGdlb0pzb25VcmxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB6SW5kZXg6IGlcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbFNvdXJjZUlkID0gaWQ7XHJcbiAgICAgIH1cclxuICAgICAgbGF5ZXJJZHMucHVzaChnbExheWVyLmlkKTtcclxuICAgIH1cclxuICB9XHJcbiAgZmluYWxpemVMYXllcihsYXllcik7XHJcbiAgbWFwLnNldCgnbWFwYm94LXN0eWxlJywgZ2xTdHlsZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBhbmQgYXBwbGllcyBhIE1hcGJveCBTdHlsZSBvYmplY3QgdG8gYW4gT3BlbkxheWVycyBNYXAuIFRoaXMgaW5jbHVkZXNcclxuICogdGhlIG1hcCBiYWNrZ3JvdW5kLCB0aGUgbGF5ZXJzLCB0aGUgY2VudGVyIGFuZCB0aGUgem9vbS5cclxuICpcclxuICogVGhlIGNlbnRlciBhbmQgem9vbSB3aWxsIG9ubHkgYmUgc2V0IGlmIHByZXNlbnQgaW4gdGhlIE1hcGJveCBTdHlsZSBkb2N1bWVudCxcclxuICogYW5kIGlmIG5vdCBhbHJlYWR5IHNldCBvbiB0aGUgT3BlbkxheWVycyBtYXAuXHJcbiAqXHJcbiAqIExheWVycyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBPcGVuTGF5ZXJzIG1hcCwgd2l0aG91dCBhZmZlY3RpbmcgYW55IGxheWVycyB0aGF0XHJcbiAqIG1pZ2h0IGFscmVhZHkgYmUgc2V0IG9uIHRoZSBtYXAuXHJcbiAqXHJcbiAqIExheWVycyBhZGRlZCBieSBgYXBwbHkoKWAgd2lsbCBoYXZlIHR3byBhZGRpdGlvbmFsIHByb3BlcnRpZXM6XHJcbiAqXHJcbiAqICAqIGBtYXBib3gtc291cmNlYDogVGhlIGBpZGAgb2YgdGhlIE1hcGJveCBTdHlsZSBkb2N1bWVudCdzIHNvdXJjZSB0aGF0IHRoZVxyXG4gKiAgICBPcGVuTGF5ZXJzIGxheWVyIHdhcyBjcmVhdGVkIGZyb20uIFVzdWFsbHkgYGFwcGx5KClgIGNyZWF0ZXMgb25lXHJcbiAqICAgIE9wZW5MYXllcnMgbGF5ZXIgcGVyIE1hcGJveCBTdHlsZSBzb3VyY2UsIHVubGVzcyB0aGUgbGF5ZXIgc3RhY2sgaGFzXHJcbiAqICAgIGxheWVycyBmcm9tIGRpZmZlcmVudCBzb3VyY2VzIGluIGJldHdlZW4uXHJcbiAqICAqIGBtYXBib3gtbGF5ZXJzYDogVGhlIGBpZGBzIG9mIHRoZSBNYXBib3ggU3R5bGUgZG9jdW1lbnQncyBsYXllcnMgdGhhdCBhcmVcclxuICogICAgaW5jbHVkZWQgaW4gdGhlIE9wZW5MYXllcnMgbGF5ZXIuXHJcbiAqXHJcbiAqIFRoZSBtYXAgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiB3aWxsIGhhdmUgYW4gYWRkaXRpb25hbCBgbWFwYm94LXN0eWxlYFxyXG4gKiBwcm9wZXJ0eSB3aGljaCBob2xkcyB0aGUgTWFwYm94IFN0eWxlIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtvbC5NYXB8SFRNTEVsZW1lbnR8c3RyaW5nfSBtYXAgRWl0aGVyIGFuIGV4aXN0aW5nIE9wZW5MYXllcnMgTWFwXHJcbiAqIGluc3RhbmNlLCBvciBhIEhUTUwgZWxlbWVudCwgb3IgdGhlIGlkIG9mIGEgSFRNTCBlbGVtZW50IHRoYXQgd2lsbCBiZSB0aGVcclxuICogdGFyZ2V0IG9mIGEgbmV3IE9wZW5MYXllcnMgTWFwLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHN0eWxlIEpTT04gc3R5bGUgb2JqZWN0IG9yIHN0eWxlIHVybCBwb2ludGluZyB0byBhXHJcbiAqIE1hcGJveCBTdHlsZSBvYmplY3QuIFdoZW4gdXNpbmcgTWFwYm94IEFQSXMsIHRoZSB1cmwgbXVzdCBjb250YWluIGFuIGFjY2Vzc1xyXG4gKiB0b2tlbiBhbmQgbG9vayBsaWtlXHJcbiAqIGBodHRwczovL2FwaS5tYXBib3guY29tL3N0eWxlcy92MS9tYXBib3gvYnJpZ2h0LXY5P2FjY2Vzc190b2tlbj1beW91cl9hY2Nlc3NfdG9rZW5faGVyZV1gLlxyXG4gKiBXaGVuIHBhc3NlZCBhcyBKU09OIHN0eWxlIG9iamVjdCwgYWxsIE9wZW5MYXllcnMgbGF5ZXJzIGNyZWF0ZWQgYnkgYGFwcGx5KClgXHJcbiAqIHdpbGwgYmUgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLCBidXQgdGhleSBtYXkgbm90IGhhdmUgYSBzb3VyY2UgeWV0IChpLmUuIHdoZW5cclxuICogdGhleSBhcmUgZGVmaW5lZCBieSBhIFRpbGVKU09OIHVybCBpbiB0aGUgTWFwYm94IFN0eWxlIGRvY3VtZW50KS4gV2hlbiBwYXNzZWRcclxuICogYXMgc3R5bGUgdXJsLCBsYXllcnMgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIHdoZW4gdGhlIE1hcGJveCBTdHlsZSBkb2N1bWVudFxyXG4gKiBpcyBsb2FkZWQgYW5kIHBhcnNlZC5cclxuICogQHJldHVybiB7b2wuTWFwfSBUaGUgT3BlbkxheWVycyBNYXAgaW5zdGFuY2UgdGhhdCB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHRoZVxyXG4gKiBjb250ZW50cyBkZXNjcmliZWQgaW4gdGhlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkobWFwLCBzdHlsZSkge1xyXG5cclxuICB2YXIgYWNjZXNzVG9rZW4sIGJhc2VVcmwsIGhvc3QsIHBhdGg7XHJcbiAgYWNjZXNzVG9rZW4gPSBiYXNlVXJsID0gaG9zdCA9IHBhdGggPSAnJztcclxuXHJcbiAgaWYgKCEobWFwIGluc3RhbmNlb2YgTWFwKSkge1xyXG4gICAgbWFwID0gbmV3IE1hcCh7XHJcbiAgICAgIHRhcmdldDogbWFwXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICB2YXIgcGFydHMgPSBzdHlsZS5tYXRjaChzcHJpdGVSZWdFeCk7XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgYmFzZVVybCA9IHBhcnRzWzFdO1xyXG4gICAgICBhY2Nlc3NUb2tlbiA9IHBhcnRzLmxlbmd0aCA+IDIgPyBwYXJ0c1syXSA6ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGZldGNoKHN0eWxlLCB7XHJcbiAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXHJcbiAgICB9KVxyXG4gICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC50aGVuKGZ1bmN0aW9uKGdsU3R5bGUpIHtcclxuICAgICAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0EnKTtcclxuICAgICAgICBhLmhyZWYgPSBzdHlsZTtcclxuICAgICAgICBwYXRoID0gYS5wYXRobmFtZS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5qb2luKCcvJykgKyAnLyc7XHJcbiAgICAgICAgaG9zdCA9IHN0eWxlLnN1YnN0cigwLCBzdHlsZS5pbmRleE9mKHBhdGgpKTtcclxuXHJcbiAgICAgICAgcHJvY2Vzc1N0eWxlKGdsU3R5bGUsIG1hcCwgYmFzZVVybCwgaG9zdCwgcGF0aCwgYWNjZXNzVG9rZW4pO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGxvYWQgJyArIHN0eWxlKTtcclxuICAgICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHByb2Nlc3NTdHlsZShzdHlsZSwgbWFwKTtcclxuICAgIH0sIDApO1xyXG4gIH1cclxuICByZXR1cm4gbWFwO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBPcGVuTGF5ZXJzIGxheWVyIGluc3RhbmNlIHRoYXQgY29udGFpbnMgdGhlIHByb3ZpZGVkIE1hcGJveCBTdHlsZVxyXG4gKiBgbGF5ZXJgLiBOb3RlIHRoYXQgbXVsdGlwbGUgTWFwYm94IFN0eWxlIGxheWVycyBhcmUgY29tYmluZWQgaW4gYSBzaW5nbGVcclxuICogT3BlbkxheWVycyBsYXllciBpbnN0YW5jZSB3aGVuIHRoZXkgdXNlIHRoZSBzYW1lIE1hcGJveCBTdHlsZSBgc291cmNlYC5cclxuICogQHBhcmFtIHtvbC5NYXB9IG1hcCBPcGVuTGF5ZXJzIE1hcC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGxheWVySWQgTWFwYm94IFN0eWxlIGxheWVyIGlkLlxyXG4gKiBAcmV0dXJuIHtvbC5sYXllci5MYXllcn0gbGF5ZXIgT3BlbkxheWVycyBsYXllciBpbnN0YW5jZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXllcihtYXAsIGxheWVySWQpIHtcclxuICBjb25zdCBsYXllcnMgPSBtYXAuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKTtcclxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgaWYgKGxheWVyc1tpXS5nZXQoJ21hcGJveC1sYXllcnMnKS5pbmRleE9mKGxheWVySWQpICE9PSAtMSkge1xyXG4gICAgICByZXR1cm4gbGF5ZXJzW2ldO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgT3BlbkxheWVycyBzb3VyY2UgaW5zdGFuY2UgZm9yIHRoZSBwcm92aWRlZCBNYXBib3ggU3R5bGUgYHNvdXJjZWAuXHJcbiAqIEBwYXJhbSB7b2wuTWFwfSBtYXAgT3BlbkxheWVycyBNYXAuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VJZCBNYXBib3ggU3R5bGUgc291cmNlIGlkLlxyXG4gKiBAcmV0dXJuIHtvbC5sYXllci5MYXllcn0gbGF5ZXIgT3BlbkxheWVycyBsYXllciBpbnN0YW5jZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTb3VyY2UobWFwLCBzb3VyY2VJZCkge1xyXG4gIGNvbnN0IGxheWVycyA9IG1hcC5nZXRMYXllcnMoKS5nZXRBcnJheSgpO1xyXG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGxheWVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBsYXllcnNbaV0uZ2V0U291cmNlKCk7XHJcbiAgICBpZiAobGF5ZXJzW2ldLmdldCgnbWFwYm94LXNvdXJjZScpLmluZGV4T2Yoc291cmNlSWQpICE9PSAtMSkge1xyXG4gICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJ2YXIgJHZlcnNpb24gPSA4O1xudmFyICRyb290ID0ge1xuXHR2ZXJzaW9uOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiBbXG5cdFx0XHQ4XG5cdFx0XSxcblx0XHRkb2M6IFwiU3R5bGUgc3BlY2lmaWNhdGlvbiB2ZXJzaW9uIG51bWJlci4gTXVzdCBiZSA4LlwiLFxuXHRcdGV4YW1wbGU6IDhcblx0fSxcblx0bmFtZToge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkEgaHVtYW4tcmVhZGFibGUgbmFtZSBmb3IgdGhlIHN0eWxlLlwiLFxuXHRcdGV4YW1wbGU6IFwiQnJpZ2h0XCJcblx0fSxcblx0bWV0YWRhdGE6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRkb2M6IFwiQXJiaXRyYXJ5IHByb3BlcnRpZXMgdXNlZnVsIHRvIHRyYWNrIHdpdGggdGhlIHN0eWxlc2hlZXQsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuXCJcblx0fSxcblx0Y2VudGVyOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJEZWZhdWx0IG1hcCBjZW50ZXIgaW4gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZS4gIFRoZSBzdHlsZSBjZW50ZXIgd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcblx0XHRleGFtcGxlOiBbXG5cdFx0XHQtNzMuOTc0OSxcblx0XHRcdDQwLjc3MzZcblx0XHRdXG5cdH0sXG5cdHpvb206IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJEZWZhdWx0IHpvb20gbGV2ZWwuICBUaGUgc3R5bGUgem9vbSB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuXHRcdGV4YW1wbGU6IDEyLjVcblx0fSxcblx0YmVhcmluZzoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0cGVyaW9kOiAzNjAsXG5cdFx0dW5pdHM6IFwiZGVncmVlc1wiLFxuXHRcdGRvYzogXCJEZWZhdWx0IGJlYXJpbmcsIGluIGRlZ3JlZXMuIFRoZSBiZWFyaW5nIGlzIHRoZSBjb21wYXNzIGRpcmVjdGlvbiB0aGF0IGlzIFxcXCJ1cFxcXCI7IGZvciBleGFtcGxlLCBhIGJlYXJpbmcgb2YgOTDCsCBvcmllbnRzIHRoZSBtYXAgc28gdGhhdCBlYXN0IGlzIHVwLiBUaGlzIHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG5cdFx0ZXhhbXBsZTogMjlcblx0fSxcblx0cGl0Y2g6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdHVuaXRzOiBcImRlZ3JlZXNcIixcblx0XHRkb2M6IFwiRGVmYXVsdCBwaXRjaCwgaW4gZGVncmVlcy4gWmVybyBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBzdXJmYWNlLCBmb3IgYSBsb29rIHN0cmFpZ2h0IGRvd24gYXQgdGhlIG1hcCwgd2hpbGUgYSBncmVhdGVyIHZhbHVlIGxpa2UgNjAgbG9va3MgYWhlYWQgdG93YXJkcyB0aGUgaG9yaXpvbi4gVGhlIHN0eWxlIHBpdGNoIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG5cdFx0ZXhhbXBsZTogNTBcblx0fSxcblx0bGlnaHQ6IHtcblx0XHR0eXBlOiBcImxpZ2h0XCIsXG5cdFx0ZG9jOiBcIlRoZSBnbG9iYWwgbGlnaHQgc291cmNlLlwiLFxuXHRcdGV4YW1wbGU6IHtcblx0XHRcdGFuY2hvcjogXCJ2aWV3cG9ydFwiLFxuXHRcdFx0Y29sb3I6IFwid2hpdGVcIixcblx0XHRcdGludGVuc2l0eTogMC40XG5cdFx0fVxuXHR9LFxuXHRzb3VyY2VzOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJzb3VyY2VzXCIsXG5cdFx0ZG9jOiBcIkRhdGEgc291cmNlIHNwZWNpZmljYXRpb25zLlwiLFxuXHRcdGV4YW1wbGU6IHtcblx0XHRcdFwibWFwYm94LXN0cmVldHNcIjoge1xuXHRcdFx0XHR0eXBlOiBcInZlY3RvclwiLFxuXHRcdFx0XHR1cmw6IFwibWFwYm94Oi8vbWFwYm94Lm1hcGJveC1zdHJlZXRzLXY2XCJcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHNwcml0ZToge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkEgYmFzZSBVUkwgZm9yIHJldHJpZXZpbmcgdGhlIHNwcml0ZSBpbWFnZSBhbmQgbWV0YWRhdGEuIFRoZSBleHRlbnNpb25zIGAucG5nYCwgYC5qc29uYCBhbmQgc2NhbGUgZmFjdG9yIGBAMngucG5nYCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXBwZW5kZWQuIFRoaXMgcHJvcGVydHkgaXMgcmVxdWlyZWQgaWYgYW55IGxheWVyIHVzZXMgdGhlIGBiYWNrZ3JvdW5kLXBhdHRlcm5gLCBgZmlsbC1wYXR0ZXJuYCwgYGxpbmUtcGF0dGVybmAsIGBmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuYCwgb3IgYGljb24taW1hZ2VgIHByb3BlcnRpZXMuIFRoZSBVUkwgbXVzdCBiZSBhYnNvbHV0ZSwgY29udGFpbmluZyB0aGUgW3NjaGVtZSwgYXV0aG9yaXR5IGFuZCBwYXRoIGNvbXBvbmVudHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VSTCNTeW50YXgpLlwiLFxuXHRcdGV4YW1wbGU6IFwibWFwYm94Oi8vc3ByaXRlcy9tYXBib3gvYnJpZ2h0LXY4XCJcblx0fSxcblx0Z2x5cGhzOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQSBVUkwgdGVtcGxhdGUgZm9yIGxvYWRpbmcgc2lnbmVkLWRpc3RhbmNlLWZpZWxkIGdseXBoIHNldHMgaW4gUEJGIGZvcm1hdC4gVGhlIFVSTCBtdXN0IGluY2x1ZGUgYHtmb250c3RhY2t9YCBhbmQgYHtyYW5nZX1gIHRva2Vucy4gVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpZiBhbnkgbGF5ZXIgdXNlcyB0aGUgYHRleHQtZmllbGRgIGxheW91dCBwcm9wZXJ0eS4gVGhlIFVSTCBtdXN0IGJlIGFic29sdXRlLCBjb250YWluaW5nIHRoZSBbc2NoZW1lLCBhdXRob3JpdHkgYW5kIHBhdGggY29tcG9uZW50c10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVJMI1N5bnRheCkuXCIsXG5cdFx0ZXhhbXBsZTogXCJtYXBib3g6Ly9mb250cy9tYXBib3gve2ZvbnRzdGFja30ve3JhbmdlfS5wYmZcIlxuXHR9LFxuXHR0cmFuc2l0aW9uOiB7XG5cdFx0dHlwZTogXCJ0cmFuc2l0aW9uXCIsXG5cdFx0ZG9jOiBcIkEgZ2xvYmFsIHRyYW5zaXRpb24gZGVmaW5pdGlvbiB0byB1c2UgYXMgYSBkZWZhdWx0IGFjcm9zcyBwcm9wZXJ0aWVzLCB0byBiZSB1c2VkIGZvciB0aW1pbmcgdHJhbnNpdGlvbnMgYmV0d2VlbiBvbmUgdmFsdWUgYW5kIHRoZSBuZXh0IHdoZW4gbm8gcHJvcGVydHktc3BlY2lmaWMgdHJhbnNpdGlvbiBpcyBzZXQuIENvbGxpc2lvbi1iYXNlZCBzeW1ib2wgZmFkaW5nIGlzIGNvbnRyb2xsZWQgaW5kZXBlbmRlbnRseSBvZiB0aGUgc3R5bGUncyBgdHJhbnNpdGlvbmAgcHJvcGVydHkuXCIsXG5cdFx0ZXhhbXBsZToge1xuXHRcdFx0ZHVyYXRpb246IDMwMCxcblx0XHRcdGRlbGF5OiAwXG5cdFx0fVxuXHR9LFxuXHRsYXllcnM6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibGF5ZXJcIixcblx0XHRkb2M6IFwiTGF5ZXJzIHdpbGwgYmUgZHJhd24gaW4gdGhlIG9yZGVyIG9mIHRoaXMgYXJyYXkuXCIsXG5cdFx0ZXhhbXBsZTogW1xuXHRcdFx0e1xuXHRcdFx0XHRpZDogXCJ3YXRlclwiLFxuXHRcdFx0XHRzb3VyY2U6IFwibWFwYm94LXN0cmVldHNcIixcblx0XHRcdFx0XCJzb3VyY2UtbGF5ZXJcIjogXCJ3YXRlclwiLFxuXHRcdFx0XHR0eXBlOiBcImZpbGxcIixcblx0XHRcdFx0cGFpbnQ6IHtcblx0XHRcdFx0XHRcImZpbGwtY29sb3JcIjogXCIjMDBmZmZmXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF1cblx0fVxufTtcbnZhciBzb3VyY2VzID0ge1xuXHRcIipcIjoge1xuXHRcdHR5cGU6IFwic291cmNlXCIsXG5cdFx0ZG9jOiBcIlNwZWNpZmljYXRpb24gb2YgYSBkYXRhIHNvdXJjZS4gRm9yIHZlY3RvciBhbmQgcmFzdGVyIHNvdXJjZXMsIGVpdGhlciBUaWxlSlNPTiBvciBhIFVSTCB0byBhIFRpbGVKU09OIG11c3QgYmUgcHJvdmlkZWQuIEZvciBpbWFnZSBhbmQgdmlkZW8gc291cmNlcywgYSBVUkwgbXVzdCBiZSBwcm92aWRlZC4gRm9yIEdlb0pTT04gc291cmNlcywgYSBVUkwgb3IgaW5saW5lIEdlb0pTT04gbXVzdCBiZSBwcm92aWRlZC5cIlxuXHR9XG59O1xudmFyIHNvdXJjZSA9IFtcblx0XCJzb3VyY2VfdmVjdG9yXCIsXG5cdFwic291cmNlX3Jhc3RlclwiLFxuXHRcInNvdXJjZV9yYXN0ZXJfZGVtXCIsXG5cdFwic291cmNlX2dlb2pzb25cIixcblx0XCJzb3VyY2VfdmlkZW9cIixcblx0XCJzb3VyY2VfaW1hZ2VcIlxuXTtcbnZhciBzb3VyY2VfdmVjdG9yID0ge1xuXHR0eXBlOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2ZWN0b3I6IHtcblx0XHRcdFx0ZG9jOiBcIkEgdmVjdG9yIHRpbGUgc291cmNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmw6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLlwiXG5cdH0sXG5cdHRpbGVzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRib3VuZHM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQtMTgwLFxuXHRcdFx0LTg1LjA1MTEyOSxcblx0XHRcdDE4MCxcblx0XHRcdDg1LjA1MTEyOVxuXHRcdF0sXG5cdFx0ZG9jOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuXHR9LFxuXHRzY2hlbWU6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHh5ejoge1xuXHRcdFx0XHRkb2M6IFwiU2xpcHB5IG1hcCB0aWxlbmFtZXMgc2NoZW1lLlwiXG5cdFx0XHR9LFxuXHRcdFx0dG1zOiB7XG5cdFx0XHRcdGRvYzogXCJPU0dlbyBzcGVjIHNjaGVtZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwieHl6XCIsXG5cdFx0ZG9jOiBcIkluZmx1ZW5jZXMgdGhlIHkgZGlyZWN0aW9uIG9mIHRoZSB0aWxlIGNvb3JkaW5hdGVzLiBUaGUgZ2xvYmFsLW1lcmNhdG9yIChha2EgU3BoZXJpY2FsIE1lcmNhdG9yKSBwcm9maWxlIGlzIGFzc3VtZWQuXCJcblx0fSxcblx0bWluem9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0ZG9jOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcblx0fSxcblx0bWF4em9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDIyLFxuXHRcdGRvYzogXCJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLlwiXG5cdH0sXG5cdGF0dHJpYnV0aW9uOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuXCJcblx0fSxcblx0cHJvbW90ZUlkOiB7XG5cdFx0dHlwZTogXCJwcm9tb3RlSWRcIixcblx0XHRkb2M6IFwiQSBwcm9wZXJ0eSB0byB1c2UgYXMgYSBmZWF0dXJlIGlkIChmb3IgZmVhdHVyZSBzdGF0ZSkuIEVpdGhlciBhIHByb3BlcnR5IG5hbWUsIG9yIGFuIG9iamVjdCBvZiB0aGUgZm9ybSBgezxzb3VyY2VMYXllcj46IDxwcm9wZXJ0eU5hbWU+fWAuIElmIHNwZWNpZmllZCBhcyBhIHN0cmluZyBmb3IgYSB2ZWN0b3IgdGlsZSBzb3VyY2UsIHRoZSBzYW1lIHByb3BlcnR5IGlzIHVzZWQgYWNyb3NzIGFsbCBpdHMgc291cmNlIGxheWVycy5cIlxuXHR9LFxuXHRcIipcIjoge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcblx0fVxufTtcbnZhciBzb3VyY2VfcmFzdGVyID0ge1xuXHR0eXBlOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRyYXN0ZXI6IHtcblx0XHRcdFx0ZG9jOiBcIkEgcmFzdGVyIHRpbGUgc291cmNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmw6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLlwiXG5cdH0sXG5cdHRpbGVzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRib3VuZHM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQtMTgwLFxuXHRcdFx0LTg1LjA1MTEyOSxcblx0XHRcdDE4MCxcblx0XHRcdDg1LjA1MTEyOVxuXHRcdF0sXG5cdFx0ZG9jOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuXHR9LFxuXHRtaW56b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRtYXh6b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMjIsXG5cdFx0ZG9jOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcblx0fSxcblx0dGlsZVNpemU6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiA1MTIsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG5cdH0sXG5cdHNjaGVtZToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0eHl6OiB7XG5cdFx0XHRcdGRvYzogXCJTbGlwcHkgbWFwIHRpbGVuYW1lcyBzY2hlbWUuXCJcblx0XHRcdH0sXG5cdFx0XHR0bXM6IHtcblx0XHRcdFx0ZG9jOiBcIk9TR2VvIHNwZWMgc2NoZW1lLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ4eXpcIixcblx0XHRkb2M6IFwiSW5mbHVlbmNlcyB0aGUgeSBkaXJlY3Rpb24gb2YgdGhlIHRpbGUgY29vcmRpbmF0ZXMuIFRoZSBnbG9iYWwtbWVyY2F0b3IgKGFrYSBTcGhlcmljYWwgTWVyY2F0b3IpIHByb2ZpbGUgaXMgYXNzdW1lZC5cIlxuXHR9LFxuXHRhdHRyaWJ1dGlvbjoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLlwiXG5cdH0sXG5cdFwiKlwiOiB7XG5cdFx0dHlwZTogXCIqXCIsXG5cdFx0ZG9jOiBcIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS5cIlxuXHR9XG59O1xudmFyIHNvdXJjZV9yYXN0ZXJfZGVtID0ge1xuXHR0eXBlOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRcInJhc3Rlci1kZW1cIjoge1xuXHRcdFx0XHRkb2M6IFwiQSBSR0ItZW5jb2RlZCByYXN0ZXIgREVNIHNvdXJjZVwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmw6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLlwiXG5cdH0sXG5cdHRpbGVzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRib3VuZHM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQtMTgwLFxuXHRcdFx0LTg1LjA1MTEyOSxcblx0XHRcdDE4MCxcblx0XHRcdDg1LjA1MTEyOVxuXHRcdF0sXG5cdFx0ZG9jOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuXHR9LFxuXHRtaW56b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRtYXh6b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMjIsXG5cdFx0ZG9jOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcblx0fSxcblx0dGlsZVNpemU6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiA1MTIsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG5cdH0sXG5cdGF0dHJpYnV0aW9uOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuXCJcblx0fSxcblx0ZW5jb2Rpbmc6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHRlcnJhcml1bToge1xuXHRcdFx0XHRkb2M6IFwiVGVycmFyaXVtIGZvcm1hdCBQTkcgdGlsZXMuIFNlZSBodHRwczovL2F3cy5hbWF6b24uY29tL2VzL3B1YmxpYy1kYXRhc2V0cy90ZXJyYWluLyBmb3IgbW9yZSBpbmZvLlwiXG5cdFx0XHR9LFxuXHRcdFx0bWFwYm94OiB7XG5cdFx0XHRcdGRvYzogXCJNYXBib3ggVGVycmFpbiBSR0IgdGlsZXMuIFNlZSBodHRwczovL3d3dy5tYXBib3guY29tL2hlbHAvYWNjZXNzLWVsZXZhdGlvbi1kYXRhLyNtYXBib3gtdGVycmFpbi1yZ2IgZm9yIG1vcmUgaW5mby5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwYm94XCIsXG5cdFx0ZG9jOiBcIlRoZSBlbmNvZGluZyB1c2VkIGJ5IHRoaXMgc291cmNlLiBNYXBib3ggVGVycmFpbiBSR0IgaXMgdXNlZCBieSBkZWZhdWx0XCJcblx0fSxcblx0XCIqXCI6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRkb2M6IFwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwiXG5cdH1cbn07XG52YXIgc291cmNlX2dlb2pzb24gPSB7XG5cdHR5cGU6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGdlb2pzb246IHtcblx0XHRcdFx0ZG9jOiBcIkEgR2VvSlNPTiBkYXRhIHNvdXJjZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIEdlb0pTT04gc291cmNlLlwiXG5cdH0sXG5cdGRhdGE6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRkb2M6IFwiQSBVUkwgdG8gYSBHZW9KU09OIGZpbGUsIG9yIGlubGluZSBHZW9KU09OLlwiXG5cdH0sXG5cdG1heHpvb206IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxOCxcblx0XHRkb2M6IFwiTWF4aW11bSB6b29tIGxldmVsIGF0IHdoaWNoIHRvIGNyZWF0ZSB2ZWN0b3IgdGlsZXMgKGhpZ2hlciBtZWFucyBncmVhdGVyIGRldGFpbCBhdCBoaWdoIHpvb20gbGV2ZWxzKS5cIlxuXHR9LFxuXHRhdHRyaWJ1dGlvbjoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLlwiXG5cdH0sXG5cdGJ1ZmZlcjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEyOCxcblx0XHRtYXhpbXVtOiA1MTIsXG5cdFx0bWluaW11bTogMCxcblx0XHRkb2M6IFwiU2l6ZSBvZiB0aGUgdGlsZSBidWZmZXIgb24gZWFjaCBzaWRlLiBBIHZhbHVlIG9mIDAgcHJvZHVjZXMgbm8gYnVmZmVyLiBBIHZhbHVlIG9mIDUxMiBwcm9kdWNlcyBhIGJ1ZmZlciBhcyB3aWRlIGFzIHRoZSB0aWxlIGl0c2VsZi4gTGFyZ2VyIHZhbHVlcyBwcm9kdWNlIGZld2VyIHJlbmRlcmluZyBhcnRpZmFjdHMgbmVhciB0aWxlIGVkZ2VzIGFuZCBzbG93ZXIgcGVyZm9ybWFuY2UuXCJcblx0fSxcblx0dG9sZXJhbmNlOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMC4zNzUsXG5cdFx0ZG9jOiBcIkRvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2UgKGhpZ2hlciBtZWFucyBzaW1wbGVyIGdlb21ldHJpZXMgYW5kIGZhc3RlciBwZXJmb3JtYW5jZSkuXCJcblx0fSxcblx0Y2x1c3Rlcjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiSWYgdGhlIGRhdGEgaXMgYSBjb2xsZWN0aW9uIG9mIHBvaW50IGZlYXR1cmVzLCBzZXR0aW5nIHRoaXMgdG8gdHJ1ZSBjbHVzdGVycyB0aGUgcG9pbnRzIGJ5IHJhZGl1cyBpbnRvIGdyb3Vwcy4gQ2x1c3RlciBncm91cHMgYmVjb21lIG5ldyBgUG9pbnRgIGZlYXR1cmVzIGluIHRoZSBzb3VyY2Ugd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXM6XFxuICogYGNsdXN0ZXJgIElzIGB0cnVlYCBpZiB0aGUgcG9pbnQgaXMgYSBjbHVzdGVyIFxcbiAqIGBjbHVzdGVyX2lkYCBBIHVucWl1ZSBpZCBmb3IgdGhlIGNsdXN0ZXIgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBbY2x1c3RlciBpbnNwZWN0aW9uIG1ldGhvZHNdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2FwaS8jZ2VvanNvbnNvdXJjZSNnZXRjbHVzdGVyZXhwYW5zaW9uem9vbSlcXG4gKiBgcG9pbnRfY291bnRgIE51bWJlciBvZiBvcmlnaW5hbCBwb2ludHMgZ3JvdXBlZCBpbnRvIHRoaXMgY2x1c3RlclxcbiAqIGBwb2ludF9jb3VudF9hYmJyZXZpYXRlZGAgQW4gYWJicmV2aWF0ZWQgcG9pbnQgY291bnRcIlxuXHR9LFxuXHRjbHVzdGVyUmFkaXVzOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogNTAsXG5cdFx0bWluaW11bTogMCxcblx0XHRkb2M6IFwiUmFkaXVzIG9mIGVhY2ggY2x1c3RlciBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIEEgdmFsdWUgb2YgNTEyIGluZGljYXRlcyBhIHJhZGl1cyBlcXVhbCB0byB0aGUgd2lkdGggb2YgYSB0aWxlLlwiXG5cdH0sXG5cdGNsdXN0ZXJNYXhab29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiTWF4IHpvb20gb24gd2hpY2ggdG8gY2x1c3RlciBwb2ludHMgaWYgY2x1c3RlcmluZyBpcyBlbmFibGVkLiBEZWZhdWx0cyB0byBvbmUgem9vbSBsZXNzIHRoYW4gbWF4em9vbSAoc28gdGhhdCBsYXN0IHpvb20gZmVhdHVyZXMgYXJlIG5vdCBjbHVzdGVyZWQpLlwiXG5cdH0sXG5cdGNsdXN0ZXJQcm9wZXJ0aWVzOiB7XG5cdFx0dHlwZTogXCIqXCIsXG5cdFx0ZG9jOiBcIkFuIG9iamVjdCBkZWZpbmluZyBjdXN0b20gcHJvcGVydGllcyBvbiB0aGUgZ2VuZXJhdGVkIGNsdXN0ZXJzIGlmIGNsdXN0ZXJpbmcgaXMgZW5hYmxlZCwgYWdncmVnYXRpbmcgdmFsdWVzIGZyb20gY2x1c3RlcmVkIHBvaW50cy4gSGFzIHRoZSBmb3JtIGB7XFxcInByb3BlcnR5X25hbWVcXFwiOiBbb3BlcmF0b3IsIG1hcF9leHByZXNzaW9uXX1gLiBgb3BlcmF0b3JgIGlzIGFueSBleHByZXNzaW9uIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhdCBsZWFzdCAyIG9wZXJhbmRzIChlLmcuIGBcXFwiK1xcXCJgIG9yIGBcXFwibWF4XFxcImApIOKAlCBpdCBhY2N1bXVsYXRlcyB0aGUgcHJvcGVydHkgdmFsdWUgZnJvbSBjbHVzdGVycy9wb2ludHMgdGhlIGNsdXN0ZXIgY29udGFpbnM7IGBtYXBfZXhwcmVzc2lvbmAgcHJvZHVjZXMgdGhlIHZhbHVlIG9mIGEgc2luZ2xlIHBvaW50LlxcblxcbkV4YW1wbGU6IGB7XFxcInN1bVxcXCI6IFtcXFwiK1xcXCIsIFtcXFwiZ2V0XFxcIiwgXFxcInNjYWxlcmFua1xcXCJdXX1gLlxcblxcbkZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcywgaW4gcGxhY2Ugb2YgYG9wZXJhdG9yYCwgeW91IGNhbiB1c2UgYSBjdXN0b20gcmVkdWNlIGV4cHJlc3Npb24gdGhhdCByZWZlcmVuY2VzIGEgc3BlY2lhbCBgW1xcXCJhY2N1bXVsYXRlZFxcXCJdYCB2YWx1ZSwgZS5nLjpcXG5ge1xcXCJzdW1cXFwiOiBbW1xcXCIrXFxcIiwgW1xcXCJhY2N1bXVsYXRlZFxcXCJdLCBbXFxcImdldFxcXCIsIFxcXCJzdW1cXFwiXV0sIFtcXFwiZ2V0XFxcIiwgXFxcInNjYWxlcmFua1xcXCJdXX1gXCJcblx0fSxcblx0bGluZU1ldHJpY3M6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdG8gY2FsY3VsYXRlIGxpbmUgZGlzdGFuY2UgbWV0cmljcy4gVGhpcyBpcyByZXF1aXJlZCBmb3IgbGluZSBsYXllcnMgdGhhdCBzcGVjaWZ5IGBsaW5lLWdyYWRpZW50YCB2YWx1ZXMuXCJcblx0fSxcblx0Z2VuZXJhdGVJZDoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiV2hldGhlciB0byBnZW5lcmF0ZSBpZHMgZm9yIHRoZSBnZW9qc29uIGZlYXR1cmVzLiBXaGVuIGVuYWJsZWQsIHRoZSBgZmVhdHVyZS5pZGAgcHJvcGVydHkgd2lsbCBiZSBhdXRvIGFzc2lnbmVkIGJhc2VkIG9uIGl0cyBpbmRleCBpbiB0aGUgYGZlYXR1cmVzYCBhcnJheSwgb3Zlci13cml0aW5nIGFueSBwcmV2aW91cyB2YWx1ZXMuXCJcblx0fSxcblx0cHJvbW90ZUlkOiB7XG5cdFx0dHlwZTogXCJwcm9tb3RlSWRcIixcblx0XHRkb2M6IFwiQSBwcm9wZXJ0eSB0byB1c2UgYXMgYSBmZWF0dXJlIGlkIChmb3IgZmVhdHVyZSBzdGF0ZSkuIEVpdGhlciBhIHByb3BlcnR5IG5hbWUsIG9yIGFuIG9iamVjdCBvZiB0aGUgZm9ybSBgezxzb3VyY2VMYXllcj46IDxwcm9wZXJ0eU5hbWU+fWAuXCJcblx0fVxufTtcbnZhciBzb3VyY2VfdmlkZW8gPSB7XG5cdHR5cGU6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpZGVvOiB7XG5cdFx0XHRcdGRvYzogXCJBIHZpZGVvIGRhdGEgc291cmNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgdmlkZW8gc291cmNlLlwiXG5cdH0sXG5cdHVybHM6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIlVSTHMgdG8gdmlkZW8gY29udGVudCBpbiBvcmRlciBvZiBwcmVmZXJyZWQgZm9ybWF0LlwiXG5cdH0sXG5cdGNvb3JkaW5hdGVzOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0ZG9jOiBcIkNvcm5lcnMgb2YgdmlkZW8gc3BlY2lmaWVkIGluIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpcnMuXCIsXG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdGxlbmd0aDogNCxcblx0XHR2YWx1ZToge1xuXHRcdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdFx0bGVuZ3RoOiAyLFxuXHRcdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0XHRkb2M6IFwiQSBzaW5nbGUgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlyLlwiXG5cdFx0fVxuXHR9XG59O1xudmFyIHNvdXJjZV9pbWFnZSA9IHtcblx0dHlwZToge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0aW1hZ2U6IHtcblx0XHRcdFx0ZG9jOiBcIkFuIGltYWdlIGRhdGEgc291cmNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgaW1hZ2Ugc291cmNlLlwiXG5cdH0sXG5cdHVybDoge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIlVSTCB0aGF0IHBvaW50cyB0byBhbiBpbWFnZS5cIlxuXHR9LFxuXHRjb29yZGluYXRlczoge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdGRvYzogXCJDb3JuZXJzIG9mIGltYWdlIHNwZWNpZmllZCBpbiBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXJzLlwiLFxuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRsZW5ndGg6IDQsXG5cdFx0dmFsdWU6IHtcblx0XHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRcdGxlbmd0aDogMixcblx0XHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdFx0ZG9jOiBcIkEgc2luZ2xlIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpci5cIlxuXHRcdH1cblx0fVxufTtcbnZhciBsYXllciA9IHtcblx0aWQ6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJVbmlxdWUgbGF5ZXIgbmFtZS5cIixcblx0XHRyZXF1aXJlZDogdHJ1ZVxuXHR9LFxuXHR0eXBlOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRmaWxsOiB7XG5cdFx0XHRcdGRvYzogXCJBIGZpbGxlZCBwb2x5Z29uIHdpdGggYW4gb3B0aW9uYWwgc3Ryb2tlZCBib3JkZXIuXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGxpbmU6IHtcblx0XHRcdFx0ZG9jOiBcIkEgc3Ryb2tlZCBsaW5lLlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzeW1ib2w6IHtcblx0XHRcdFx0ZG9jOiBcIkFuIGljb24gb3IgYSB0ZXh0IGxhYmVsLlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjaXJjbGU6IHtcblx0XHRcdFx0ZG9jOiBcIkEgZmlsbGVkIGNpcmNsZS5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGVhdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiQSBoZWF0bWFwLlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRcImZpbGwtZXh0cnVzaW9uXCI6IHtcblx0XHRcdFx0ZG9jOiBcIkFuIGV4dHJ1ZGVkICgzRCkgcG9seWdvbi5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmFzdGVyOiB7XG5cdFx0XHRcdGRvYzogXCJSYXN0ZXIgbWFwIHRleHR1cmVzIHN1Y2ggYXMgc2F0ZWxsaXRlIGltYWdlcnkuXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhpbGxzaGFkZToge1xuXHRcdFx0XHRkb2M6IFwiQ2xpZW50LXNpZGUgaGlsbHNoYWRpbmcgdmlzdWFsaXphdGlvbiBiYXNlZCBvbiBERU0gZGF0YS4gQ3VycmVudGx5LCB0aGUgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBNYXBib3ggVGVycmFpbiBSR0IgYW5kIE1hcHplbiBUZXJyYXJpdW0gdGlsZXMuXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJhY2tncm91bmQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9yIHBhdHRlcm4gb2YgdGhlIG1hcC5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIixcblx0XHRyZXF1aXJlZDogdHJ1ZVxuXHR9LFxuXHRtZXRhZGF0YToge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJBcmJpdHJhcnkgcHJvcGVydGllcyB1c2VmdWwgdG8gdHJhY2sgd2l0aCB0aGUgbGF5ZXIsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuXCJcblx0fSxcblx0c291cmNlOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiTmFtZSBvZiBhIHNvdXJjZSBkZXNjcmlwdGlvbiB0byBiZSB1c2VkIGZvciB0aGlzIGxheWVyLiBSZXF1aXJlZCBmb3IgYWxsIGxheWVyIHR5cGVzIGV4Y2VwdCBgYmFja2dyb3VuZGAuXCJcblx0fSxcblx0XCJzb3VyY2UtbGF5ZXJcIjoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkxheWVyIHRvIHVzZSBmcm9tIGEgdmVjdG9yIHRpbGUgc291cmNlLiBSZXF1aXJlZCBmb3IgdmVjdG9yIHRpbGUgc291cmNlczsgcHJvaGliaXRlZCBmb3IgYWxsIG90aGVyIHNvdXJjZSB0eXBlcywgaW5jbHVkaW5nIEdlb0pTT04gc291cmNlcy5cIlxuXHR9LFxuXHRtaW56b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDI0LFxuXHRcdGRvYzogXCJUaGUgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgbGF5ZXIuIEF0IHpvb20gbGV2ZWxzIGxlc3MgdGhhbiB0aGUgbWluem9vbSwgdGhlIGxheWVyIHdpbGwgYmUgaGlkZGVuLlwiXG5cdH0sXG5cdG1heHpvb206IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMjQsXG5cdFx0ZG9jOiBcIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBsYXllci4gQXQgem9vbSBsZXZlbHMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIHRoZSBtYXh6b29tLCB0aGUgbGF5ZXIgd2lsbCBiZSBoaWRkZW4uXCJcblx0fSxcblx0ZmlsdGVyOiB7XG5cdFx0dHlwZTogXCJmaWx0ZXJcIixcblx0XHRkb2M6IFwiQSBleHByZXNzaW9uIHNwZWNpZnlpbmcgY29uZGl0aW9ucyBvbiBzb3VyY2UgZmVhdHVyZXMuIE9ubHkgZmVhdHVyZXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyIGFyZSBkaXNwbGF5ZWQuIFpvb20gZXhwcmVzc2lvbnMgaW4gZmlsdGVycyBhcmUgb25seSBldmFsdWF0ZWQgYXQgaW50ZWdlciB6b29tIGxldmVscy4gVGhlIGBmZWF0dXJlLXN0YXRlYCBleHByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZmlsdGVyIGV4cHJlc3Npb25zLlwiXG5cdH0sXG5cdGxheW91dDoge1xuXHRcdHR5cGU6IFwibGF5b3V0XCIsXG5cdFx0ZG9jOiBcIkxheW91dCBwcm9wZXJ0aWVzIGZvciB0aGUgbGF5ZXIuXCJcblx0fSxcblx0cGFpbnQ6IHtcblx0XHR0eXBlOiBcInBhaW50XCIsXG5cdFx0ZG9jOiBcIkRlZmF1bHQgcGFpbnQgcHJvcGVydGllcyBmb3IgdGhpcyBsYXllci5cIlxuXHR9XG59O1xudmFyIGxheW91dCA9IFtcblx0XCJsYXlvdXRfZmlsbFwiLFxuXHRcImxheW91dF9saW5lXCIsXG5cdFwibGF5b3V0X2NpcmNsZVwiLFxuXHRcImxheW91dF9oZWF0bWFwXCIsXG5cdFwibGF5b3V0X2ZpbGwtZXh0cnVzaW9uXCIsXG5cdFwibGF5b3V0X3N5bWJvbFwiLFxuXHRcImxheW91dF9yYXN0ZXJcIixcblx0XCJsYXlvdXRfaGlsbHNoYWRlXCIsXG5cdFwibGF5b3V0X2JhY2tncm91bmRcIlxuXTtcbnZhciBsYXlvdXRfYmFja2dyb3VuZCA9IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfZmlsbCA9IHtcblx0XCJmaWxsLXNvcnQta2V5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJTb3J0cyBmZWF0dXJlcyBpbiBhc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhpcyB2YWx1ZS4gRmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIGFwcGVhciBhYm92ZSBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIxLjIuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMS4yLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn07XG52YXIgbGF5b3V0X2NpcmNsZSA9IHtcblx0XCJjaXJjbGUtc29ydC1rZXlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgYXBwZWFyIGFib3ZlIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjEuMi4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIxLjIuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfaGVhdG1hcCA9IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfbGluZSA9IHtcblx0XCJsaW5lLWNhcFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRidXR0OiB7XG5cdFx0XHRcdGRvYzogXCJBIGNhcCB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIHRvIHRoZSBleGFjdCBlbmRwb2ludCBvZiB0aGUgbGluZS5cIlxuXHRcdFx0fSxcblx0XHRcdHJvdW5kOiB7XG5cdFx0XHRcdGRvYzogXCJBIGNhcCB3aXRoIGEgcm91bmRlZCBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIHJhZGl1cyBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoIGFuZCBjZW50ZXJlZCBvbiB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHRzcXVhcmU6IHtcblx0XHRcdFx0ZG9jOiBcIkEgY2FwIHdpdGggYSBzcXVhcmVkLW9mZiBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIGRpc3RhbmNlIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGguXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImJ1dHRcIixcblx0XHRkb2M6IFwiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJsaW5lLWpvaW5cIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0YmV2ZWw6IHtcblx0XHRcdFx0ZG9jOiBcIkEgam9pbiB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSBkaXN0YW5jZSBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoLlwiXG5cdFx0XHR9LFxuXHRcdFx0cm91bmQ6IHtcblx0XHRcdFx0ZG9jOiBcIkEgam9pbiB3aXRoIGEgcm91bmRlZCBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIHJhZGl1cyBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoIGFuZCBjZW50ZXJlZCBvbiB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHRtaXRlcjoge1xuXHRcdFx0XHRkb2M6IFwiQSBqb2luIHdpdGggYSBzaGFycCwgYW5nbGVkIGNvcm5lciB3aGljaCBpcyBkcmF3biB3aXRoIHRoZSBvdXRlciBzaWRlcyBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBwYXRoIHVudGlsIHRoZXkgbWVldC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibWl0ZXJcIixcblx0XHRkb2M6IFwiVGhlIGRpc3BsYXkgb2YgbGluZXMgd2hlbiBqb2luaW5nLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS1taXRlci1saW1pdFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMixcblx0XHRkb2M6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcImxpbmUtam9pblwiOiBcIm1pdGVyXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImxpbmUtcm91bmQtbGltaXRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEuMDUsXG5cdFx0ZG9jOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IHJvdW5kIGpvaW5zIHRvIG1pdGVyIGpvaW5zIGZvciBzaGFsbG93IGFuZ2xlcy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcImxpbmUtam9pblwiOiBcInJvdW5kXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImxpbmUtc29ydC1rZXlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgYXBwZWFyIGFib3ZlIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjEuMi4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIxLjIuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfc3ltYm9sID0ge1xuXHRcInN5bWJvbC1wbGFjZW1lbnRcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0cG9pbnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYWJlbCBpcyBwbGFjZWQgYXQgdGhlIHBvaW50IHdoZXJlIHRoZSBnZW9tZXRyeSBpcyBsb2NhdGVkLlwiXG5cdFx0XHR9LFxuXHRcdFx0bGluZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxhYmVsIGlzIHBsYWNlZCBhbG9uZyB0aGUgbGluZSBvZiB0aGUgZ2VvbWV0cnkuIENhbiBvbmx5IGJlIHVzZWQgb24gYExpbmVTdHJpbmdgIGFuZCBgUG9seWdvbmAgZ2VvbWV0cmllcy5cIlxuXHRcdFx0fSxcblx0XHRcdFwibGluZS1jZW50ZXJcIjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxhYmVsIGlzIHBsYWNlZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBsaW5lIG9mIHRoZSBnZW9tZXRyeS4gQ2FuIG9ubHkgYmUgdXNlZCBvbiBgTGluZVN0cmluZ2AgYW5kIGBQb2x5Z29uYCBnZW9tZXRyaWVzLiBOb3RlIHRoYXQgYSBzaW5nbGUgZmVhdHVyZSBpbiBhIHZlY3RvciB0aWxlIG1heSBjb250YWluIG11bHRpcGxlIGxpbmUgZ2VvbWV0cmllcy5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwicG9pbnRcIixcblx0XHRkb2M6IFwiTGFiZWwgcGxhY2VtZW50IHJlbGF0aXZlIHRvIGl0cyBnZW9tZXRyeS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJgbGluZS1jZW50ZXJgIHZhbHVlXCI6IHtcblx0XHRcdFx0anM6IFwiMC40Ny4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi40LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTAuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwic3ltYm9sLXNwYWNpbmdcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDI1MCxcblx0XHRtaW5pbXVtOiAxLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJEaXN0YW5jZSBiZXR3ZWVuIHR3byBzeW1ib2wgYW5jaG9ycy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInN5bWJvbC1hdm9pZC1lZGdlc1wiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCB0aGUgc3ltYm9scyB3aWxsIG5vdCBjcm9zcyB0aWxlIGVkZ2VzIHRvIGF2b2lkIG11dHVhbCBjb2xsaXNpb25zLiBSZWNvbW1lbmRlZCBpbiBsYXllcnMgdGhhdCBkb24ndCBoYXZlIGVub3VnaCBwYWRkaW5nIGluIHRoZSB2ZWN0b3IgdGlsZSB0byBwcmV2ZW50IGNvbGxpc2lvbnMsIG9yIGlmIGl0IGlzIGEgcG9pbnQgc3ltYm9sIGxheWVyIHBsYWNlZCBhZnRlciBhIGxpbmUgc3ltYm9sIGxheWVyLiBXaGVuIHVzaW5nIGEgY2xpZW50IHRoYXQgc3VwcG9ydHMgZ2xvYmFsIGNvbGxpc2lvbiBkZXRlY3Rpb24sIGxpa2UgTWFwYm94IEdMIEpTIHZlcnNpb24gMC40Mi4wIG9yIGdyZWF0ZXIsIGVuYWJsaW5nIHRoaXMgcHJvcGVydHkgaXMgbm90IG5lZWRlZCB0byBwcmV2ZW50IGNsaXBwZWQgbGFiZWxzIGF0IHRpbGUgYm91bmRhcmllcy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwic3ltYm9sLXNvcnQta2V5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJTb3J0cyBmZWF0dXJlcyBpbiBhc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhpcyB2YWx1ZS4gRmVhdHVyZXMgd2l0aCBsb3dlciBzb3J0IGtleXMgYXJlIGRyYXduIGFuZCBwbGFjZWQgZmlyc3QuICBXaGVuIGBpY29uLWFsbG93LW92ZXJsYXBgIG9yIGB0ZXh0LWFsbG93LW92ZXJsYXBgIGlzIGBmYWxzZWAsIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleSB3aWxsIGhhdmUgcHJpb3JpdHkgZHVyaW5nIHBsYWNlbWVudC4gV2hlbiBgaWNvbi1hbGxvdy1vdmVybGFwYCBvciBgdGV4dC1hbGxvdy1vdmVybGFwYCBpcyBzZXQgdG8gYHRydWVgLCBmZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgb3ZlcmxhcCBvdmVyIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjExLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjUzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI3LjQuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4xMS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJzeW1ib2wtei1vcmRlclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJJZiBgc3ltYm9sLXNvcnQta2V5YCBpcyBzZXQsIHNvcnQgYmFzZWQgb24gdGhhdC4gT3RoZXJ3aXNlIHNvcnQgc3ltYm9scyBieSB0aGVpciB5LXBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fSxcblx0XHRcdFwidmlld3BvcnQteVwiOiB7XG5cdFx0XHRcdGRvYzogXCJTeW1ib2xzIHdpbGwgYmUgc29ydGVkIGJ5IHRoZWlyIHktcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9LFxuXHRcdFx0c291cmNlOiB7XG5cdFx0XHRcdGRvYzogXCJTeW1ib2xzIHdpbGwgYmUgcmVuZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHNvdXJjZSBkYXRhIHdpdGggbm8gc29ydGluZyBhcHBsaWVkLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJhdXRvXCIsXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBvcmRlciBpbiB3aGljaCBvdmVybGFwcGluZyBzeW1ib2xzIGluIHRoZSBzYW1lIGxheWVyIGFyZSByZW5kZXJlZFwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40OS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi42LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTIuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi1hbGxvdy1vdmVybGFwXCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRydWUsIHRoZSBpY29uIHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgcHJldmlvdXNseSBkcmF3biBzeW1ib2xzLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24taWdub3JlLXBsYWNlbWVudFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIGljb24uXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi1vcHRpb25hbFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCB0ZXh0IHdpbGwgZGlzcGxheSB3aXRob3V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgaWNvbnMgd2hlbiB0aGUgaWNvbiBjb2xsaWRlcyB3aXRoIG90aGVyIHN5bWJvbHMgYW5kIHRoZSB0ZXh0IGRvZXMgbm90LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIixcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgYWxpZ25zIGljb25zIGVhc3Qtd2VzdC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCBvciBgbGluZS1jZW50ZXJgLCBhbGlnbnMgaWNvbiB4LWF4ZXMgd2l0aCB0aGUgbGluZS5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJQcm9kdWNlcyBpY29ucyB3aG9zZSB4LWF4ZXMgYXJlIGFsaWduZWQgd2l0aCB0aGUgeC1heGlzIG9mIHRoZSB2aWV3cG9ydCwgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYHN5bWJvbC1wbGFjZW1lbnRgLlwiXG5cdFx0XHR9LFxuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRkb2M6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgdmlld3BvcnRgLiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgbWFwYC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwiYXV0b1wiLFxuXHRcdGRvYzogXCJJbiBjb21iaW5hdGlvbiB3aXRoIGBzeW1ib2wtcGxhY2VtZW50YCwgZGV0ZXJtaW5lcyB0aGUgcm90YXRpb24gYmVoYXZpb3Igb2YgaWNvbnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJgYXV0b2AgdmFsdWVcIjoge1xuXHRcdFx0XHRqczogXCIwLjI1LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI0LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy40LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4zLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24tc2l6ZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcImZhY3RvciBvZiB0aGUgb3JpZ2luYWwgaWNvbiBzaXplXCIsXG5cdFx0ZG9jOiBcIlNjYWxlcyB0aGUgb3JpZ2luYWwgc2l6ZSBvZiB0aGUgaWNvbiBieSB0aGUgcHJvdmlkZWQgZmFjdG9yLiBUaGUgbmV3IHBpeGVsIHNpemUgb2YgdGhlIGltYWdlIHdpbGwgYmUgdGhlIG9yaWdpbmFsIHBpeGVsIHNpemUgbXVsdGlwbGllZCBieSBgaWNvbi1zaXplYC4gMSBpcyB0aGUgb3JpZ2luYWwgc2l6ZTsgMyB0cmlwbGVzIHRoZSBzaXplIG9mIHRoZSBpbWFnZS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjM1LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLXRleHQtZml0XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBpY29uIGlzIGRpc3BsYXllZCBhdCBpdHMgaW50cmluc2ljIGFzcGVjdCByYXRpby5cIlxuXHRcdFx0fSxcblx0XHRcdHdpZHRoOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaWNvbiBpcyBzY2FsZWQgaW4gdGhlIHgtZGltZW5zaW9uIHRvIGZpdCB0aGUgd2lkdGggb2YgdGhlIHRleHQuXCJcblx0XHRcdH0sXG5cdFx0XHRoZWlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBpY29uIGlzIHNjYWxlZCBpbiB0aGUgeS1kaW1lbnNpb24gdG8gZml0IHRoZSBoZWlnaHQgb2YgdGhlIHRleHQuXCJcblx0XHRcdH0sXG5cdFx0XHRib3RoOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaWNvbiBpcyBzY2FsZWQgaW4gYm90aCB4LSBhbmQgeS1kaW1lbnNpb25zLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJub25lXCIsXG5cdFx0ZG9jOiBcIlNjYWxlcyB0aGUgaWNvbiB0byBmaXQgYXJvdW5kIHRoZSBhc3NvY2lhdGVkIHRleHQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiLFxuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMi4xXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLXRleHQtZml0LXBhZGRpbmdcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDQsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwLFxuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYWRkZWQgdG8gZGltZW5zaW9ucyBkZXRlcm1pbmVkIGJ5IGBpY29uLXRleHQtZml0YCwgaW4gY2xvY2t3aXNlIG9yZGVyOiB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiLFxuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwiaWNvbi10ZXh0LWZpdFwiOiBbXG5cdFx0XHRcdFx0XCJib3RoXCIsXG5cdFx0XHRcdFx0XCJ3aWR0aFwiLFxuXHRcdFx0XHRcdFwiaGVpZ2h0XCJcblx0XHRcdFx0XVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjIxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI0LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy40LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4yLjFcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi1pbWFnZVwiOiB7XG5cdFx0dHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG5cdFx0ZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBhbiBpbWFnZSBiYWNrZ3JvdW5kLlwiLFxuXHRcdHRva2VuczogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24tcm90YXRlXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdHBlcmlvZDogMzYwLFxuXHRcdHVuaXRzOiBcImRlZ3JlZXNcIixcblx0XHRkb2M6IFwiUm90YXRlcyB0aGUgaWNvbiBjbG9ja3dpc2UuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi1wYWRkaW5nXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAyLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhcm91bmQgdGhlIGljb24gYm91bmRpbmcgYm94IHVzZWQgZm9yIGRldGVjdGluZyBzeW1ib2wgY29sbGlzaW9ucy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24ta2VlcC11cHJpZ2h0XCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRydWUsIHRoZSBpY29uIG1heSBiZSBmbGlwcGVkIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93bi5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjogXCJtYXBcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0XCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcblx0XHRcdFx0XHRcImxpbmVcIixcblx0XHRcdFx0XHRcImxpbmUtY2VudGVyXCJcblx0XHRcdFx0XVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24tb2Zmc2V0XCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MFxuXHRcdF0sXG5cdFx0ZG9jOiBcIk9mZnNldCBkaXN0YW5jZSBvZiBpY29uIGZyb20gaXRzIGFuY2hvci4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuIEVhY2ggY29tcG9uZW50IGlzIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlIG9mIGBpY29uLXNpemVgIHRvIG9idGFpbiB0aGUgZmluYWwgb2Zmc2V0IGluIHBpeGVscy4gV2hlbiBjb21iaW5lZCB3aXRoIGBpY29uLXJvdGF0ZWAgdGhlIG9mZnNldCB3aWxsIGJlIGFzIGlmIHRoZSByb3RhdGVkIGRpcmVjdGlvbiB3YXMgdXAuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0Y2VudGVyOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgY2VudGVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRsZWZ0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGVmdCBzaWRlIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRyaWdodDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdHRvcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRvcCBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0Ym90dG9tOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcInRvcC1sZWZ0XCI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdFwidG9wLXJpZ2h0XCI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcImJvdHRvbS1sZWZ0XCI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdFwiYm90dG9tLXJpZ2h0XCI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuXHRcdGRvYzogXCJQYXJ0IG9mIHRoZSBpY29uIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40MC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24tcGl0Y2gtYWxpZ25tZW50XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGljb24gaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaWNvbiBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH0sXG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJBdXRvbWF0aWNhbGx5IG1hdGNoZXMgdGhlIHZhbHVlIG9mIGBpY29uLXJvdGF0aW9uLWFsaWdubWVudGAuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImF1dG9cIixcblx0XHRkb2M6IFwiT3JpZW50YXRpb24gb2YgaWNvbiB3aGVuIG1hcCBpcyBwaXRjaGVkLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjM5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtcGl0Y2gtYWxpZ25tZW50XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH0sXG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJBdXRvbWF0aWNhbGx5IG1hdGNoZXMgdGhlIHZhbHVlIG9mIGB0ZXh0LXJvdGF0aW9uLWFsaWdubWVudGAuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImF1dG9cIixcblx0XHRkb2M6IFwiT3JpZW50YXRpb24gb2YgdGV4dCB3aGVuIG1hcCBpcyBwaXRjaGVkLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjIxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI0LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy40LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4yLjFcIlxuXHRcdFx0fSxcblx0XHRcdFwiYGF1dG9gIHZhbHVlXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIldoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgcG9pbnRgLCBhbGlnbnMgdGV4dCBlYXN0LXdlc3QuIFdoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgbGluZWAgb3IgYGxpbmUtY2VudGVyYCwgYWxpZ25zIHRleHQgeC1heGVzIHdpdGggdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiUHJvZHVjZXMgZ2x5cGhzIHdob3NlIHgtYXhlcyBhcmUgYWxpZ25lZCB3aXRoIHRoZSB4LWF4aXMgb2YgdGhlIHZpZXdwb3J0LCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBgc3ltYm9sLXBsYWNlbWVudGAuXCJcblx0XHRcdH0sXG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGB2aWV3cG9ydGAuIFdoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgbGluZWAgb3IgYGxpbmUtY2VudGVyYCwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGBtYXBgLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJhdXRvXCIsXG5cdFx0ZG9jOiBcIkluIGNvbWJpbmF0aW9uIHdpdGggYHN5bWJvbC1wbGFjZW1lbnRgLCBkZXRlcm1pbmVzIHRoZSByb3RhdGlvbiBiZWhhdmlvciBvZiB0aGUgaW5kaXZpZHVhbCBnbHlwaHMgZm9ybWluZyB0aGUgdGV4dC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImBhdXRvYCB2YWx1ZVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjUuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjQuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjQuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjMuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1maWVsZFwiOiB7XG5cdFx0dHlwZTogXCJmb3JtYXR0ZWRcIixcblx0XHRcImRlZmF1bHRcIjogXCJcIixcblx0XHR0b2tlbnM6IHRydWUsXG5cdFx0ZG9jOiBcIlZhbHVlIHRvIHVzZSBmb3IgYSB0ZXh0IGxhYmVsLiBJZiBhIHBsYWluIGBzdHJpbmdgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBgZm9ybWF0dGVkYCB3aXRoIGRlZmF1bHQvaW5oZXJpdGVkIGZvcm1hdHRpbmcgb3B0aW9ucy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtZm9udFwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHRcIk9wZW4gU2FucyBSZWd1bGFyXCIsXG5cdFx0XHRcIkFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiXG5cdFx0XSxcblx0XHRkb2M6IFwiRm9udCBzdGFjayB0byB1c2UgZm9yIGRpc3BsYXlpbmcgdGV4dC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1zaXplXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxNixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJGb250IHNpemUuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1tYXgtd2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwiZW1zXCIsXG5cdFx0ZG9jOiBcIlRoZSBtYXhpbXVtIGxpbmUgd2lkdGggZm9yIHRleHQgd3JhcHBpbmcuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40MC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1saW5lLWhlaWdodFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMS4yLFxuXHRcdHVuaXRzOiBcImVtc1wiLFxuXHRcdGRvYzogXCJUZXh0IGxlYWRpbmcgdmFsdWUgZm9yIG11bHRpLWxpbmUgdGV4dC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0dW5pdHM6IFwiZW1zXCIsXG5cdFx0ZG9jOiBcIlRleHQgdHJhY2tpbmcgYW1vdW50LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtanVzdGlmeVwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvd2FyZHMgdGhlIGFuY2hvciBwb3NpdGlvbi5cIlxuXHRcdFx0fSxcblx0XHRcdGxlZnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIGxlZnQuXCJcblx0XHRcdH0sXG5cdFx0XHRjZW50ZXI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGNlbnRlcmVkLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIHJpZ2h0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcblx0XHRkb2M6IFwiVGV4dCBqdXN0aWZpY2F0aW9uIG9wdGlvbnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH0sXG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTQuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjEwLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtcmFkaWFsLW9mZnNldFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHR1bml0czogXCJlbXNcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiUmFkaWFsIG9mZnNldCBvZiB0ZXh0LCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzeW1ib2wncyBhbmNob3IuIFVzZWZ1bCBpbiBjb21iaW5hdGlvbiB3aXRoIGB0ZXh0LXZhcmlhYmxlLWFuY2hvcmAsIHdoaWNoIGRlZmF1bHRzIHRvIHVzaW5nIHRoZSB0d28tZGltZW5zaW9uYWwgYHRleHQtb2Zmc2V0YCBpZiBwcmVzZW50LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC41NC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNy40LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMTAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTQuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjEwLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIixcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH1cblx0fSxcblx0XCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGNlbnRlcjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGNlbnRlciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0bGVmdDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHR0b3A6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3Agb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdGJvdHRvbToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ0b3AtbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcInRvcC1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJib3R0b20tbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcImJvdHRvbS1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG5cdFx0XHRcdFx0XCJwb2ludFwiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdGRvYzogXCJUbyBpbmNyZWFzZSB0aGUgY2hhbmNlIG9mIHBsYWNpbmcgaGlnaC1wcmlvcml0eSBsYWJlbHMgb24gdGhlIG1hcCwgeW91IGNhbiBwcm92aWRlIGFuIGFycmF5IG9mIGB0ZXh0LWFuY2hvcmAgbG9jYXRpb25zOiB0aGUgcmVuZGVyZXIgd2lsbCBhdHRlbXB0IHRvIHBsYWNlIHRoZSBsYWJlbCBhdCBlYWNoIGxvY2F0aW9uLCBpbiBvcmRlciwgYmVmb3JlIG1vdmluZyBvbnRvIHRoZSBuZXh0IGxhYmVsLiBVc2UgYHRleHQtanVzdGlmeTogYXV0b2AgdG8gY2hvb3NlIGp1c3RpZmljYXRpb24gYmFzZWQgb24gYW5jaG9yIHBvc2l0aW9uLiBUbyBhcHBseSBhbiBvZmZzZXQsIHVzZSB0aGUgYHRleHQtcmFkaWFsLW9mZnNldGAgb3IgdGhlIHR3by1kaW1lbnNpb25hbCBgdGV4dC1vZmZzZXRgLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC41NC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNy40LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMTAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGNlbnRlcjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGNlbnRlciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0bGVmdDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHR0b3A6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3Agb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdGJvdHRvbToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ0b3AtbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcInRvcC1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJib3R0b20tbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcImJvdHRvbS1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcblx0XHRkb2M6IFwiUGFydCBvZiB0aGUgdGV4dCBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwidGV4dC12YXJpYWJsZS1hbmNob3JcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LW1heC1hbmdsZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogNDUsXG5cdFx0dW5pdHM6IFwiZGVncmVlc1wiLFxuXHRcdGRvYzogXCJNYXhpbXVtIGFuZ2xlIGNoYW5nZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcInN5bWJvbC1wbGFjZW1lbnRcIjogW1xuXHRcdFx0XHRcdFwibGluZVwiLFxuXHRcdFx0XHRcdFwibGluZS1jZW50ZXJcIlxuXHRcdFx0XHRdXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXdyaXRpbmctbW9kZVwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGhvcml6b250YWw6IHtcblx0XHRcdFx0ZG9jOiBcIklmIGEgdGV4dCdzIGxhbmd1YWdlIHN1cHBvcnRzIGhvcml6b250YWwgd3JpdGluZyBtb2RlLCBzeW1ib2xzIHdpdGggcG9pbnQgcGxhY2VtZW50IHdvdWxkIGJlIGxhaWQgb3V0IGhvcml6b250YWxseS5cIlxuXHRcdFx0fSxcblx0XHRcdHZlcnRpY2FsOiB7XG5cdFx0XHRcdGRvYzogXCJJZiBhIHRleHQncyBsYW5ndWFnZSBzdXBwb3J0cyB2ZXJ0aWNhbCB3cml0aW5nIG1vZGUsIHN5bWJvbHMgd2l0aCBwb2ludCBwbGFjZW1lbnQgd291bGQgYmUgbGFpZCBvdXQgdmVydGljYWxseS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBwcm9wZXJ0eSBhbGxvd3MgY29udHJvbCBvdmVyIGEgc3ltYm9sJ3Mgb3JpZW50YXRpb24uIE5vdGUgdGhhdCB0aGUgcHJvcGVydHkgdmFsdWVzIGFjdCBhcyBhIGhpbnQsIHNvIHRoYXQgYSBzeW1ib2wgd2hvc2UgbGFuZ3VhZ2UgZG9lc27igJl0IHN1cHBvcnQgdGhlIHByb3ZpZGVkIG9yaWVudGF0aW9uIHdpbGwgYmUgbGFpZCBvdXQgaW4gaXRzIG5hdHVyYWwgb3JpZW50YXRpb24uIEV4YW1wbGU6IEVuZ2xpc2ggcG9pbnQgc3ltYm9sIHdpbGwgYmUgcmVuZGVyZWQgaG9yaXpvbnRhbGx5IGV2ZW4gaWYgYXJyYXkgdmFsdWUgY29udGFpbnMgc2luZ2xlICd2ZXJ0aWNhbCcgZW51bSB2YWx1ZS4gVGhlIG9yZGVyIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5IGRlZmluZSBwcmlvcml0eSBvcmRlciBmb3IgdGhlIHBsYWNlbWVudCBvZiBhbiBvcmllbnRhdGlvbiB2YXJpYW50LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdHtcblx0XHRcdFx0XCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcblx0XHRcdFx0XHRcInBvaW50XCJcblx0XHRcdFx0XVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIxLjMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjguMy4wXCIsXG5cdFx0XHRcdGlvczogXCI1LjMuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtcm90YXRlXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdHBlcmlvZDogMzYwLFxuXHRcdHVuaXRzOiBcImRlZ3JlZXNcIixcblx0XHRkb2M6IFwiUm90YXRlcyB0aGUgdGV4dCBjbG9ja3dpc2UuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1wYWRkaW5nXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAyLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhcm91bmQgdGhlIHRleHQgYm91bmRpbmcgYm94IHVzZWQgZm9yIGRldGVjdGluZyBzeW1ib2wgY29sbGlzaW9ucy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQta2VlcC11cHJpZ2h0XCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogdHJ1ZSxcblx0XHRkb2M6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgbWF5IGJlIGZsaXBwZWQgdmVydGljYWxseSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG5cdFx0XHRcdFx0XCJsaW5lXCIsXG5cdFx0XHRcdFx0XCJsaW5lLWNlbnRlclwiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyBub3QgYWx0ZXJlZC5cIlxuXHRcdFx0fSxcblx0XHRcdHVwcGVyY2FzZToge1xuXHRcdFx0XHRkb2M6IFwiRm9yY2VzIGFsbCBsZXR0ZXJzIHRvIGJlIGRpc3BsYXllZCBpbiB1cHBlcmNhc2UuXCJcblx0XHRcdH0sXG5cdFx0XHRsb3dlcmNhc2U6IHtcblx0XHRcdFx0ZG9jOiBcIkZvcmNlcyBhbGwgbGV0dGVycyB0byBiZSBkaXNwbGF5ZWQgaW4gbG93ZXJjYXNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJub25lXCIsXG5cdFx0ZG9jOiBcIlNwZWNpZmllcyBob3cgdG8gY2FwaXRhbGl6ZSB0ZXh0LCBzaW1pbGFyIHRvIHRoZSBDU1MgYHRleHQtdHJhbnNmb3JtYCBwcm9wZXJ0eS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1vZmZzZXRcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRkb2M6IFwiT2Zmc2V0IGRpc3RhbmNlIG9mIHRleHQgZnJvbSBpdHMgYW5jaG9yLiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC4gSWYgdXNlZCB3aXRoIHRleHQtdmFyaWFibGUtYW5jaG9yLCBpbnB1dCB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBhcyBhYnNvbHV0ZSB2YWx1ZXMuIE9mZnNldHMgYWxvbmcgdGhlIHgtIGFuZCB5LWF4aXMgd2lsbCBiZSBhcHBsaWVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhlIGFuY2hvciBwb3NpdGlvbi5cIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHR1bml0czogXCJlbXNcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcInRleHQtcmFkaWFsLW9mZnNldFwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgcHJldmlvdXNseSBkcmF3biBzeW1ib2xzLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIHRleHQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1vcHRpb25hbFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCBpY29ucyB3aWxsIGRpc3BsYXkgd2l0aG91dCB0aGVpciBjb3JyZXNwb25kaW5nIHRleHQgd2hlbiB0aGUgdGV4dCBjb2xsaWRlcyB3aXRoIG90aGVyIHN5bWJvbHMgYW5kIHRoZSBpY29uIGRvZXMgbm90LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn07XG52YXIgbGF5b3V0X3Jhc3RlciA9IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfaGlsbHNoYWRlID0ge1xuXHR2aXNpYmlsaXR5OiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2aXNpYmxlOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcblx0XHRcdH0sXG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIGZpbHRlciA9IHtcblx0dHlwZTogXCJhcnJheVwiLFxuXHR2YWx1ZTogXCIqXCIsXG5cdGRvYzogXCJBIGZpbHRlciBzZWxlY3RzIHNwZWNpZmljIGZlYXR1cmVzIGZyb20gYSBsYXllci5cIlxufTtcbnZhciBmaWx0ZXJfb3BlcmF0b3IgPSB7XG5cdHR5cGU6IFwiZW51bVwiLFxuXHR2YWx1ZXM6IHtcblx0XHRcIj09XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCI9PVxcXCIsIGtleSwgdmFsdWVdYCBlcXVhbGl0eTogYGZlYXR1cmVba2V5XSA9IHZhbHVlYFwiXG5cdFx0fSxcblx0XHRcIiE9XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCIhPVxcXCIsIGtleSwgdmFsdWVdYCBpbmVxdWFsaXR5OiBgZmVhdHVyZVtrZXldIOKJoCB2YWx1ZWBcIlxuXHRcdH0sXG5cdFx0XCI+XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCI+XFxcIiwga2V5LCB2YWx1ZV1gIGdyZWF0ZXIgdGhhbjogYGZlYXR1cmVba2V5XSA+IHZhbHVlYFwiXG5cdFx0fSxcblx0XHRcIj49XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCI+PVxcXCIsIGtleSwgdmFsdWVdYCBncmVhdGVyIHRoYW4gb3IgZXF1YWw6IGBmZWF0dXJlW2tleV0g4omlIHZhbHVlYFwiXG5cdFx0fSxcblx0XHRcIjxcIjoge1xuXHRcdFx0ZG9jOiBcImBbXFxcIjxcXFwiLCBrZXksIHZhbHVlXWAgbGVzcyB0aGFuOiBgZmVhdHVyZVtrZXldIDwgdmFsdWVgXCJcblx0XHR9LFxuXHRcdFwiPD1cIjoge1xuXHRcdFx0ZG9jOiBcImBbXFxcIjw9XFxcIiwga2V5LCB2YWx1ZV1gIGxlc3MgdGhhbiBvciBlcXVhbDogYGZlYXR1cmVba2V5XSDiiaQgdmFsdWVgXCJcblx0XHR9LFxuXHRcdFwiaW5cIjoge1xuXHRcdFx0ZG9jOiBcImBbXFxcImluXFxcIiwga2V5LCB2MCwgLi4uLCB2bl1gIHNldCBpbmNsdXNpb246IGBmZWF0dXJlW2tleV0g4oiIIHt2MCwgLi4uLCB2bn1gXCJcblx0XHR9LFxuXHRcdFwiIWluXCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCIhaW5cXFwiLCBrZXksIHYwLCAuLi4sIHZuXWAgc2V0IGV4Y2x1c2lvbjogYGZlYXR1cmVba2V5XSDiiIkge3YwLCAuLi4sIHZufWBcIlxuXHRcdH0sXG5cdFx0YWxsOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiYWxsXFxcIiwgZjAsIC4uLiwgZm5dYCBsb2dpY2FsIGBBTkRgOiBgZjAg4oinIC4uLiDiiKcgZm5gXCJcblx0XHR9LFxuXHRcdGFueToge1xuXHRcdFx0ZG9jOiBcImBbXFxcImFueVxcXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgT1JgOiBgZjAg4oioIC4uLiDiiKggZm5gXCJcblx0XHR9LFxuXHRcdG5vbmU6IHtcblx0XHRcdGRvYzogXCJgW1xcXCJub25lXFxcIiwgZjAsIC4uLiwgZm5dYCBsb2dpY2FsIGBOT1JgOiBgwqxmMCDiiKcgLi4uIOKIpyDCrGZuYFwiXG5cdFx0fSxcblx0XHRoYXM6IHtcblx0XHRcdGRvYzogXCJgW1xcXCJoYXNcXFwiLCBrZXldYCBgZmVhdHVyZVtrZXldYCBleGlzdHNcIlxuXHRcdH0sXG5cdFx0XCIhaGFzXCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCIhaGFzXFxcIiwga2V5XWAgYGZlYXR1cmVba2V5XWAgZG9lcyBub3QgZXhpc3RcIlxuXHRcdH1cblx0fSxcblx0ZG9jOiBcIlRoZSBmaWx0ZXIgb3BlcmF0b3IuXCJcbn07XG52YXIgZ2VvbWV0cnlfdHlwZSA9IHtcblx0dHlwZTogXCJlbnVtXCIsXG5cdHZhbHVlczoge1xuXHRcdFBvaW50OiB7XG5cdFx0XHRkb2M6IFwiRmlsdGVyIHRvIHBvaW50IGdlb21ldHJpZXMuXCJcblx0XHR9LFxuXHRcdExpbmVTdHJpbmc6IHtcblx0XHRcdGRvYzogXCJGaWx0ZXIgdG8gbGluZSBnZW9tZXRyaWVzLlwiXG5cdFx0fSxcblx0XHRQb2x5Z29uOiB7XG5cdFx0XHRkb2M6IFwiRmlsdGVyIHRvIHBvbHlnb24gZ2VvbWV0cmllcy5cIlxuXHRcdH1cblx0fSxcblx0ZG9jOiBcIlRoZSBnZW9tZXRyeSB0eXBlIGZvciB0aGUgZmlsdGVyIHRvIHNlbGVjdC5cIlxufTtcbnZhciBmdW5jdGlvbl9zdG9wID0ge1xuXHR0eXBlOiBcImFycmF5XCIsXG5cdG1pbmltdW06IDAsXG5cdG1heGltdW06IDI0LFxuXHR2YWx1ZTogW1xuXHRcdFwibnVtYmVyXCIsXG5cdFx0XCJjb2xvclwiXG5cdF0sXG5cdGxlbmd0aDogMixcblx0ZG9jOiBcIlpvb20gbGV2ZWwgYW5kIHZhbHVlIHBhaXIuXCJcbn07XG52YXIgZXhwcmVzc2lvbiA9IHtcblx0dHlwZTogXCJhcnJheVwiLFxuXHR2YWx1ZTogXCIqXCIsXG5cdG1pbmltdW06IDEsXG5cdGRvYzogXCJBbiBleHByZXNzaW9uIGRlZmluZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGZvciBkYXRhLWRyaXZlbiBzdHlsZSBwcm9wZXJ0aWVzIG9yIGZlYXR1cmUgZmlsdGVycy5cIlxufTtcbnZhciBleHByZXNzaW9uX25hbWUgPSB7XG5cdGRvYzogXCJcIixcblx0dHlwZTogXCJlbnVtXCIsXG5cdHZhbHVlczoge1xuXHRcdFwibGV0XCI6IHtcblx0XHRcdGRvYzogXCJCaW5kcyBleHByZXNzaW9ucyB0byBuYW1lZCB2YXJpYWJsZXMsIHdoaWNoIGNhbiB0aGVuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIHJlc3VsdCBleHByZXNzaW9uIHVzaW5nIFtcXFwidmFyXFxcIiwgXFxcInZhcmlhYmxlX25hbWVcXFwiXS5cIixcblx0XHRcdGdyb3VwOiBcIlZhcmlhYmxlIGJpbmRpbmdcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwidmFyXCI6IHtcblx0XHRcdGRvYzogXCJSZWZlcmVuY2VzIHZhcmlhYmxlIGJvdW5kIHVzaW5nIFxcXCJsZXRcXFwiLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVmFyaWFibGUgYmluZGluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bGl0ZXJhbDoge1xuXHRcdFx0ZG9jOiBcIlByb3ZpZGVzIGEgbGl0ZXJhbCBhcnJheSBvciBvYmplY3QgdmFsdWUuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXJyYXk6IHtcblx0XHRcdGRvYzogXCJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IGlzIGFuIGFycmF5IChvcHRpb25hbGx5IHdpdGggYSBzcGVjaWZpYyBpdGVtIHR5cGUgYW5kIGxlbmd0aCkuICBJZiwgd2hlbiB0aGUgaW5wdXQgZXhwcmVzc2lvbiBpcyBldmFsdWF0ZWQsIGl0IGlzIG5vdCBvZiB0aGUgYXNzZXJ0ZWQgdHlwZSwgdGhlbiB0aGlzIGFzc2VydGlvbiB3aWxsIGNhdXNlIHRoZSB3aG9sZSBleHByZXNzaW9uIHRvIGJlIGFib3J0ZWQuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXQ6IHtcblx0XHRcdGRvYzogXCJSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImluXCI6IHtcblx0XHRcdGRvYzogXCJEZXRlcm1pbmVzIHdoZXRoZXIgYW4gaXRlbSBleGlzdHMgaW4gYW4gYXJyYXkgb3IgYSBzdWJzdHJpbmcgZXhpc3RzIGluIGEgc3RyaW5nLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjYuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiaW5kZXgtb2ZcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gYW4gYXJyYXksIG9yIGZvciBhIHN0cmluZywgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCB2YWx1ZS4gSWYgYSBzZWNvbmQgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZW4gdGhlIHNlYXJjaCBpcyBzdGFydGVkIGZyb20gdGhhdCBwb3NpdGlvbi4gUmV0dXJucyAtMSBpZiB0aGUgdmFsdWUgaXMgbm90IGZvdW5kLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjEwLjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImNhc2VcIjoge1xuXHRcdFx0ZG9jOiBcIlNlbGVjdHMgdGhlIGZpcnN0IG91dHB1dCB3aG9zZSBjb3JyZXNwb25kaW5nIHRlc3QgY29uZGl0aW9uIGV2YWx1YXRlcyB0byB0cnVlLCBvciB0aGUgZmFsbGJhY2sgdmFsdWUgb3RoZXJ3aXNlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG1hdGNoOiB7XG5cdFx0XHRkb2M6IFwiU2VsZWN0cyB0aGUgb3V0cHV0IHdob3NlIGxhYmVsIHZhbHVlIG1hdGNoZXMgdGhlIGlucHV0IHZhbHVlLCBvciB0aGUgZmFsbGJhY2sgdmFsdWUgaWYgbm8gbWF0Y2ggaXMgZm91bmQuIFRoZSBpbnB1dCBjYW4gYmUgYW55IGV4cHJlc3Npb24gKGUuZy4gYFtcXFwiZ2V0XFxcIiwgXFxcImJ1aWxkaW5nX3R5cGVcXFwiXWApLiBFYWNoIGxhYmVsIG11c3QgYmUgZWl0aGVyOlxcbiAqIGEgc2luZ2xlIGxpdGVyYWwgdmFsdWU7IG9yXFxuICogYW4gYXJyYXkgb2YgbGl0ZXJhbCB2YWx1ZXMsIHdob3NlIHZhbHVlcyBtdXN0IGJlIGFsbCBzdHJpbmdzIG9yIGFsbCBudW1iZXJzIChlLmcuIGBbMTAwLCAxMDFdYCBvciBgW1xcXCJjXFxcIiwgXFxcImJcXFwiXWApLiBUaGUgaW5wdXQgbWF0Y2hlcyBpZiBhbnkgb2YgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgbWF0Y2hlcywgc2ltaWxhciB0byB0aGUgYFxcXCJpblxcXCJgIG9wZXJhdG9yLlxcblxcbkVhY2ggbGFiZWwgbXVzdCBiZSB1bmlxdWUuIElmIHRoZSBpbnB1dCB0eXBlIGRvZXMgbm90IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBsYWJlbHMsIHRoZSByZXN1bHQgd2lsbCBiZSB0aGUgZmFsbGJhY2sgdmFsdWUuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29hbGVzY2U6IHtcblx0XHRcdGRvYzogXCJFdmFsdWF0ZXMgZWFjaCBleHByZXNzaW9uIGluIHR1cm4gdW50aWwgdGhlIGZpcnN0IG5vbi1udWxsIHZhbHVlIGlzIG9idGFpbmVkLCBhbmQgcmV0dXJucyB0aGF0IHZhbHVlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHN0ZXA6IHtcblx0XHRcdGRvYzogXCJQcm9kdWNlcyBkaXNjcmV0ZSwgc3RlcHBlZCByZXN1bHRzIGJ5IGV2YWx1YXRpbmcgYSBwaWVjZXdpc2UtY29uc3RhbnQgZnVuY3Rpb24gZGVmaW5lZCBieSBwYWlycyBvZiBpbnB1dCBhbmQgb3V0cHV0IHZhbHVlcyAoXFxcInN0b3BzXFxcIikuIFRoZSBgaW5wdXRgIG1heSBiZSBhbnkgbnVtZXJpYyBleHByZXNzaW9uIChlLmcuLCBgW1xcXCJnZXRcXFwiLCBcXFwicG9wdWxhdGlvblxcXCJdYCkuIFN0b3AgaW5wdXRzIG11c3QgYmUgbnVtZXJpYyBsaXRlcmFscyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuIFJldHVybnMgdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBqdXN0IGxlc3MgdGhhbiB0aGUgaW5wdXQsIG9yIHRoZSBmaXJzdCBvdXRwdXQgaWYgdGhlIGlucHV0IGlzIGxlc3MgdGhhbiB0aGUgZmlyc3Qgc3RvcC5cIixcblx0XHRcdGdyb3VwOiBcIlJhbXBzLCBzY2FsZXMsIGN1cnZlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40Mi4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW50ZXJwb2xhdGU6IHtcblx0XHRcdGRvYzogXCJQcm9kdWNlcyBjb250aW51b3VzLCBzbW9vdGggcmVzdWx0cyBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFxcXCJzdG9wc1xcXCIpLiBUaGUgYGlucHV0YCBtYXkgYmUgYW55IG51bWVyaWMgZXhwcmVzc2lvbiAoZS5nLiwgYFtcXFwiZ2V0XFxcIiwgXFxcInBvcHVsYXRpb25cXFwiXWApLiBTdG9wIGlucHV0cyBtdXN0IGJlIG51bWVyaWMgbGl0ZXJhbHMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLiBUaGUgb3V0cHV0IHR5cGUgbXVzdCBiZSBgbnVtYmVyYCwgYGFycmF5PG51bWJlcj5gLCBvciBgY29sb3JgLlxcblxcbkludGVycG9sYXRpb24gdHlwZXM6XFxuLSBgW1xcXCJsaW5lYXJcXFwiXWA6IGludGVycG9sYXRlcyBsaW5lYXJseSBiZXR3ZWVuIHRoZSBwYWlyIG9mIHN0b3BzIGp1c3QgbGVzcyB0aGFuIGFuZCBqdXN0IGdyZWF0ZXIgdGhhbiB0aGUgaW5wdXQuXFxuLSBgW1xcXCJleHBvbmVudGlhbFxcXCIsIGJhc2VdYDogaW50ZXJwb2xhdGVzIGV4cG9uZW50aWFsbHkgYmV0d2VlbiB0aGUgc3RvcHMganVzdCBsZXNzIHRoYW4gYW5kIGp1c3QgZ3JlYXRlciB0aGFuIHRoZSBpbnB1dC4gYGJhc2VgIGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBvdXRwdXQgaW5jcmVhc2VzOiBoaWdoZXIgdmFsdWVzIG1ha2UgdGhlIG91dHB1dCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCB2YWx1ZXMgY2xvc2UgdG8gMSB0aGUgb3V0cHV0IGluY3JlYXNlcyBsaW5lYXJseS5cXG4tIGBbXFxcImN1YmljLWJlemllclxcXCIsIHgxLCB5MSwgeDIsIHkyXWA6IGludGVycG9sYXRlcyB1c2luZyB0aGUgY3ViaWMgYmV6aWVyIGN1cnZlIGRlZmluZWQgYnkgdGhlIGdpdmVuIGNvbnRyb2wgcG9pbnRzLlwiLFxuXHRcdFx0Z3JvdXA6IFwiUmFtcHMsIHNjYWxlcywgY3VydmVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQyLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImludGVycG9sYXRlLWhjbFwiOiB7XG5cdFx0XHRkb2M6IFwiUHJvZHVjZXMgY29udGludW91cywgc21vb3RoIHJlc3VsdHMgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcXFwic3RvcHNcXFwiKS4gV29ya3MgbGlrZSBgaW50ZXJwb2xhdGVgLCBidXQgdGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYGNvbG9yYCwgYW5kIHRoZSBpbnRlcnBvbGF0aW9uIGlzIHBlcmZvcm1lZCBpbiB0aGUgSHVlLUNocm9tYS1MdW1pbmFuY2UgY29sb3Igc3BhY2UuXCIsXG5cdFx0XHRncm91cDogXCJSYW1wcywgc2NhbGVzLCBjdXJ2ZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiaW50ZXJwb2xhdGUtbGFiXCI6IHtcblx0XHRcdGRvYzogXCJQcm9kdWNlcyBjb250aW51b3VzLCBzbW9vdGggcmVzdWx0cyBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFxcXCJzdG9wc1xcXCIpLiBXb3JrcyBsaWtlIGBpbnRlcnBvbGF0ZWAsIGJ1dCB0aGUgb3V0cHV0IHR5cGUgbXVzdCBiZSBgY29sb3JgLCBhbmQgdGhlIGludGVycG9sYXRpb24gaXMgcGVyZm9ybWVkIGluIHRoZSBDSUVMQUIgY29sb3Igc3BhY2UuXCIsXG5cdFx0XHRncm91cDogXCJSYW1wcywgc2NhbGVzLCBjdXJ2ZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGxuMjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgbWF0aGVtYXRpY2FsIGNvbnN0YW50IGxuKDIpLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cGk6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBtYXRoZW1hdGljYWwgY29uc3RhbnQgcGkuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgbWF0aGVtYXRpY2FsIGNvbnN0YW50IGUuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInR5cGVvZlwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSB0eXBlIG9mIHRoZSBnaXZlbiB2YWx1ZS5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdHJpbmc6IHtcblx0XHRcdGRvYzogXCJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IHZhbHVlIGlzIGEgc3RyaW5nLiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgYSBzdHJpbmcgaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgc3RyaW5ncywgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bnVtYmVyOiB7XG5cdFx0XHRkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIG51bWJlci4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgbnVtYmVyIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIG51bWJlcnMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGJvb2xlYW46IHtcblx0XHRcdGRvYzogXCJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IHZhbHVlIGlzIGEgYm9vbGVhbi4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgYm9vbGVhbiBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGFyZSBib29sZWFucywgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b2JqZWN0OiB7XG5cdFx0XHRkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhbiBvYmplY3QuIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhbiBvYmplY3QgaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgb2JqZWN0cywgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29sbGF0b3I6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGEgYGNvbGxhdG9yYCBmb3IgdXNlIGluIGxvY2FsZS1kZXBlbmRlbnQgY29tcGFyaXNvbiBvcGVyYXRpb25zLiBUaGUgYGNhc2Utc2Vuc2l0aXZlYCBhbmQgYGRpYWNyaXRpYy1zZW5zaXRpdmVgIG9wdGlvbnMgZGVmYXVsdCB0byBgZmFsc2VgLiBUaGUgYGxvY2FsZWAgYXJndW1lbnQgc3BlY2lmaWVzIHRoZSBJRVRGIGxhbmd1YWdlIHRhZyBvZiB0aGUgbG9jYWxlIHRvIHVzZS4gSWYgbm9uZSBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgbG9jYWxlIGlzIHVzZWQuIElmIHRoZSByZXF1ZXN0ZWQgbG9jYWxlIGlzIG5vdCBhdmFpbGFibGUsIHRoZSBgY29sbGF0b3JgIHdpbGwgdXNlIGEgc3lzdGVtLWRlZmluZWQgZmFsbGJhY2sgbG9jYWxlLiBVc2UgYHJlc29sdmVkLWxvY2FsZWAgdG8gdGVzdCB0aGUgcmVzdWx0cyBvZiBsb2NhbGUgZmFsbGJhY2sgYmVoYXZpb3IuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zm9ybWF0OiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgZm9ybWF0dGVkYCB0ZXh0IGNvbnRhaW5pbmcgYW5ub3RhdGlvbnMgZm9yIHVzZSBpbiBtaXhlZC1mb3JtYXQgYHRleHQtZmllbGRgIGVudHJpZXMuIEZvciBhIGB0ZXh0LWZpZWxkYCBlbnRyaWVzIG9mIGEgc3RyaW5nIHR5cGUsIGZvbGxvd2luZyBvcHRpb24gb2JqZWN0J3MgcHJvcGVydGllcyBhcmUgc3VwcG9ydGVkOiBJZiBzZXQsIHRoZSBgdGV4dC1mb250YCB2YWx1ZSBvdmVycmlkZXMgdGhlIGZvbnQgc3BlY2lmaWVkIGJ5IHRoZSByb290IGxheW91dCBwcm9wZXJ0aWVzLiBJZiBzZXQsIHRoZSBgZm9udC1zY2FsZWAgdmFsdWUgc3BlY2lmaWVzIGEgc2NhbGluZyBmYWN0b3IgcmVsYXRpdmUgdG8gdGhlIGB0ZXh0LXNpemVgIHNwZWNpZmllZCBpbiB0aGUgcm9vdCBsYXlvdXQgcHJvcGVydGllcy4gSWYgc2V0LCB0aGUgYHRleHQtY29sb3JgIHZhbHVlIG92ZXJyaWRlcyB0aGUgY29sb3Igc3BlY2lmaWVkIGJ5IHRoZSByb290IHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40OC4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjcuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjYuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuMTIuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwidGV4dC1mb250XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ4LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNy4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuNi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xMi4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJmb250LXNjYWxlXCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ4LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNy4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuNi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xMi4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJ0ZXh0LWNvbG9yXCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjMuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNy4zLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4xMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0aW1hZ2U6IHtcblx0XHRcdFx0XHRqczogXCIxLjYuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGltYWdlOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhbiBgaW1hZ2VgIHR5cGUgZm9yIHVzZSBpbiBgaWNvbi1pbWFnZWAsIGAqLXBhdHRlcm5gIGVudHJpZXMgYW5kIGFzIGEgc2VjdGlvbiBpbiB0aGUgYGZvcm1hdGAgZXhwcmVzc2lvbi4gSWYgc2V0LCB0aGUgYGltYWdlYCBhcmd1bWVudCB3aWxsIGNoZWNrIHRoYXQgdGhlIHJlcXVlc3RlZCBpbWFnZSBleGlzdHMgaW4gdGhlIHN0eWxlIGFuZCB3aWxsIHJldHVybiBlaXRoZXIgdGhlIHJlc29sdmVkIGltYWdlIG5hbWUgb3IgYG51bGxgLCBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3QgdGhlIGltYWdlIGlzIGN1cnJlbnRseSBpbiB0aGUgc3R5bGUuIFRoaXMgdmFsaWRhdGlvbiBwcm9jZXNzIGlzIHN5bmNocm9ub3VzIGFuZCByZXF1aXJlcyB0aGUgaW1hZ2UgdG8gaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBzdHlsZSBiZWZvcmUgcmVxdWVzdGluZyBpdCBpbiB0aGUgYGltYWdlYCBhcmd1bWVudC5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjQuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiOC42LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNS42LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIm51bWJlci1mb3JtYXRcIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCBudW1iZXIgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiB1c2luZyB0aGUgcHJvdmlkaW5nIGZvcm1hdHRpbmcgcnVsZXMuIElmIHNldCwgdGhlIGBsb2NhbGVgIGFyZ3VtZW50IHNwZWNpZmllcyB0aGUgbG9jYWxlIHRvIHVzZSwgYXMgYSBCQ1AgNDcgbGFuZ3VhZ2UgdGFnLiBJZiBzZXQsIHRoZSBgY3VycmVuY3lgIGFyZ3VtZW50IHNwZWNpZmllcyBhbiBJU08gNDIxNyBjb2RlIHRvIHVzZSBmb3IgY3VycmVuY3ktc3R5bGUgZm9ybWF0dGluZy4gSWYgc2V0LCB0aGUgYG1pbi1mcmFjdGlvbi1kaWdpdHNgIGFuZCBgbWF4LWZyYWN0aW9uLWRpZ2l0c2AgYXJndW1lbnRzIHNwZWNpZnkgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbnVtYmVyIG9mIGZyYWN0aW9uYWwgZGlnaXRzIHRvIGluY2x1ZGUuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC41NC4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ0by1zdHJpbmdcIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIHN0cmluZy4gSWYgdGhlIGlucHV0IGlzIGBudWxsYCwgdGhlIHJlc3VsdCBpcyBgXFxcIlxcXCJgLiBJZiB0aGUgaW5wdXQgaXMgYSBib29sZWFuLCB0aGUgcmVzdWx0IGlzIGBcXFwidHJ1ZVxcXCJgIG9yIGBcXFwiZmFsc2VcXFwiYC4gSWYgdGhlIGlucHV0IGlzIGEgbnVtYmVyLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgYXMgc3BlY2lmaWVkIGJ5IHRoZSBbXFxcIk51bWJlclRvU3RyaW5nXFxcIiBhbGdvcml0aG1dKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvc3RyaW5nLWFwcGxpZWQtdG8tdGhlLW51bWJlci10eXBlKSBvZiB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uLiBJZiB0aGUgaW5wdXQgaXMgYSBjb2xvciwgaXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIG9mIHRoZSBmb3JtIGBcXFwicmdiYShyLGcsYixhKVxcXCJgLCB3aGVyZSBgcmAsIGBnYCwgYW5kIGBiYCBhcmUgbnVtZXJhbHMgcmFuZ2luZyBmcm9tIDAgdG8gMjU1LCBhbmQgYGFgIHJhbmdlcyBmcm9tIDAgdG8gMS4gT3RoZXJ3aXNlLCB0aGUgaW5wdXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IHRoZSBbYEpTT04uc3RyaW5naWZ5YF0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtanNvbi5zdHJpbmdpZnkpIGZ1bmN0aW9uIG9mIHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb24uXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ0by1udW1iZXJcIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciwgaWYgcG9zc2libGUuIElmIHRoZSBpbnB1dCBpcyBgbnVsbGAgb3IgYGZhbHNlYCwgdGhlIHJlc3VsdCBpcyAwLiBJZiB0aGUgaW5wdXQgaXMgYHRydWVgLCB0aGUgcmVzdWx0IGlzIDEuIElmIHRoZSBpbnB1dCBpcyBhIHN0cmluZywgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyIGFzIHNwZWNpZmllZCBieSB0aGUgW1xcXCJUb051bWJlciBBcHBsaWVkIHRvIHRoZSBTdHJpbmcgVHlwZVxcXCIgYWxnb3JpdGhtXShodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b251bWJlci1hcHBsaWVkLXRvLXRoZS1zdHJpbmctdHlwZSkgb2YgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgU3BlY2lmaWNhdGlvbi4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGNvbnZlcnNpb24gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBjYW4gYmUgY29udmVydGVkLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInRvLWJvb2xlYW5cIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIGJvb2xlYW4uIFRoZSByZXN1bHQgaXMgYGZhbHNlYCB3aGVuIHRoZW4gaW5wdXQgaXMgYW4gZW1wdHkgc3RyaW5nLCAwLCBgZmFsc2VgLCBgbnVsbGAsIG9yIGBOYU5gOyBvdGhlcndpc2UgaXQgaXMgYHRydWVgLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwidG8tcmdiYVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhIGZvdXItZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSBpbnB1dCBjb2xvcidzIHJlZCwgZ3JlZW4sIGJsdWUsIGFuZCBhbHBoYSBjb21wb25lbnRzLCBpbiB0aGF0IG9yZGVyLlwiLFxuXHRcdFx0Z3JvdXA6IFwiQ29sb3JcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwidG8tY29sb3JcIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIGNvbG9yLiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgdGhlIGZpcnN0IHN1Y2Nlc3NmdWwgY29udmVyc2lvbiBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGNhbiBiZSBjb252ZXJ0ZWQsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJnYjoge1xuXHRcdFx0ZG9jOiBcIkNyZWF0ZXMgYSBjb2xvciB2YWx1ZSBmcm9tIHJlZCwgZ3JlZW4sIGFuZCBibHVlIGNvbXBvbmVudHMsIHdoaWNoIG11c3QgcmFuZ2UgYmV0d2VlbiAwIGFuZCAyNTUsIGFuZCBhbiBhbHBoYSBjb21wb25lbnQgb2YgMS4gSWYgYW55IGNvbXBvbmVudCBpcyBvdXQgb2YgcmFuZ2UsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiQ29sb3JcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJnYmE6IHtcblx0XHRcdGRvYzogXCJDcmVhdGVzIGEgY29sb3IgdmFsdWUgZnJvbSByZWQsIGdyZWVuLCBibHVlIGNvbXBvbmVudHMsIHdoaWNoIG11c3QgcmFuZ2UgYmV0d2VlbiAwIGFuZCAyNTUsIGFuZCBhbiBhbHBoYSBjb21wb25lbnQgd2hpY2ggbXVzdCByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuIElmIGFueSBjb21wb25lbnQgaXMgb3V0IG9mIHJhbmdlLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcblx0XHRcdGdyb3VwOiBcIkNvbG9yXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXQ6IHtcblx0XHRcdGRvYzogXCJSZXRyaWV2ZXMgYSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IGZlYXR1cmUncyBwcm9wZXJ0aWVzLCBvciBmcm9tIGFub3RoZXIgb2JqZWN0IGlmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLiBSZXR1cm5zIG51bGwgaWYgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSBpcyBtaXNzaW5nLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoYXM6IHtcblx0XHRcdGRvYzogXCJUZXN0cyBmb3IgdGhlIHByZXNlbmNlIG9mIGFuIHByb3BlcnR5IHZhbHVlIGluIHRoZSBjdXJyZW50IGZlYXR1cmUncyBwcm9wZXJ0aWVzLCBvciBmcm9tIGFub3RoZXIgb2JqZWN0IGlmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsZW5ndGg6IHtcblx0XHRcdGRvYzogXCJHZXRzIHRoZSBsZW5ndGggb2YgYW4gYXJyYXkgb3Igc3RyaW5nLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRwcm9wZXJ0aWVzOiB7XG5cdFx0XHRkb2M6IFwiR2V0cyB0aGUgZmVhdHVyZSBwcm9wZXJ0aWVzIG9iamVjdC4gIE5vdGUgdGhhdCBpbiBzb21lIGNhc2VzLCBpdCBtYXkgYmUgbW9yZSBlZmZpY2llbnQgdG8gdXNlIFtcXFwiZ2V0XFxcIiwgXFxcInByb3BlcnR5X25hbWVcXFwiXSBkaXJlY3RseS5cIixcblx0XHRcdGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJmZWF0dXJlLXN0YXRlXCI6IHtcblx0XHRcdGRvYzogXCJSZXRyaWV2ZXMgYSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IGZlYXR1cmUncyBzdGF0ZS4gUmV0dXJucyBudWxsIGlmIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgb24gdGhlIGZlYXR1cmUncyBzdGF0ZS4gQSBmZWF0dXJlJ3Mgc3RhdGUgaXMgbm90IHBhcnQgb2YgdGhlIEdlb0pTT04gb3IgdmVjdG9yIHRpbGUgZGF0YSwgYW5kIG11c3QgYmUgc2V0IHByb2dyYW1tYXRpY2FsbHkgb24gZWFjaCBmZWF0dXJlLiBGZWF0dXJlcyBhcmUgaWRlbnRpZmllZCBieSB0aGVpciBgaWRgIGF0dHJpYnV0ZSwgd2hpY2ggbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIGEgc3RyaW5nIHRoYXQgY2FuIGJlIGNhc3QgdG8gYW4gaW50ZWdlci4gTm90ZSB0aGF0IFtcXFwiZmVhdHVyZS1zdGF0ZVxcXCJdIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBwYWludCBwcm9wZXJ0aWVzIHRoYXQgc3VwcG9ydCBkYXRhLWRyaXZlbiBzdHlsaW5nLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ2LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImdlb21ldHJ5LXR5cGVcIjoge1xuXHRcdFx0ZG9jOiBcIkdldHMgdGhlIGZlYXR1cmUncyBnZW9tZXRyeSB0eXBlOiBQb2ludCwgTXVsdGlQb2ludCwgTGluZVN0cmluZywgTXVsdGlMaW5lU3RyaW5nLCBQb2x5Z29uLCBNdWx0aVBvbHlnb24uXCIsXG5cdFx0XHRncm91cDogXCJGZWF0dXJlIGRhdGFcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGlkOiB7XG5cdFx0XHRkb2M6IFwiR2V0cyB0aGUgZmVhdHVyZSdzIGlkLCBpZiBpdCBoYXMgb25lLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR6b29tOiB7XG5cdFx0XHRkb2M6IFwiR2V0cyB0aGUgY3VycmVudCB6b29tIGxldmVsLiAgTm90ZSB0aGF0IGluIHN0eWxlIGxheW91dCBhbmQgcGFpbnQgcHJvcGVydGllcywgW1xcXCJ6b29tXFxcIl0gbWF5IG9ubHkgYXBwZWFyIGFzIHRoZSBpbnB1dCB0byBhIHRvcC1sZXZlbCBcXFwic3RlcFxcXCIgb3IgXFxcImludGVycG9sYXRlXFxcIiBleHByZXNzaW9uLlwiLFxuXHRcdFx0Z3JvdXA6IFwiWm9vbVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJoZWF0bWFwLWRlbnNpdHlcIjoge1xuXHRcdFx0ZG9jOiBcIkdldHMgdGhlIGtlcm5lbCBkZW5zaXR5IGVzdGltYXRpb24gb2YgYSBwaXhlbCBpbiBhIGhlYXRtYXAgbGF5ZXIsIHdoaWNoIGlzIGEgcmVsYXRpdmUgbWVhc3VyZSBvZiBob3cgbWFueSBkYXRhIHBvaW50cyBhcmUgY3Jvd2RlZCBhcm91bmQgYSBwYXJ0aWN1bGFyIHBpeGVsLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgaGVhdG1hcC1jb2xvcmAgcHJvcGVydHkuXCIsXG5cdFx0XHRncm91cDogXCJIZWF0bWFwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImxpbmUtcHJvZ3Jlc3NcIjoge1xuXHRcdFx0ZG9jOiBcIkdldHMgdGhlIHByb2dyZXNzIGFsb25nIGEgZ3JhZGllbnQgbGluZS4gQ2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgYGxpbmUtZ3JhZGllbnRgIHByb3BlcnR5LlwiLFxuXHRcdFx0Z3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuNi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xMi4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YWNjdW11bGF0ZWQ6IHtcblx0XHRcdGRvYzogXCJHZXRzIHRoZSB2YWx1ZSBvZiBhIGNsdXN0ZXIgcHJvcGVydHkgYWNjdW11bGF0ZWQgc28gZmFyLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgY2x1c3RlclByb3BlcnRpZXNgIG9wdGlvbiBvZiBhIGNsdXN0ZXJlZCBHZW9KU09OIHNvdXJjZS5cIixcblx0XHRcdGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC41My4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIrXCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGlucHV0cy5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiKlwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGUgaW5wdXRzLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCItXCI6IHtcblx0XHRcdGRvYzogXCJGb3IgdHdvIGlucHV0cywgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW5nIHRoZSBzZWNvbmQgaW5wdXQgZnJvbSB0aGUgZmlyc3QuIEZvciBhIHNpbmdsZSBpbnB1dCwgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW5nIGl0IGZyb20gMC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiL1wiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgcmVzdWx0IG9mIGZsb2F0aW5nIHBvaW50IGRpdmlzaW9uIG9mIHRoZSBmaXJzdCBpbnB1dCBieSB0aGUgc2Vjb25kLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIlXCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSByZW1haW5kZXIgYWZ0ZXIgaW50ZWdlciBkaXZpc2lvbiBvZiB0aGUgZmlyc3QgaW5wdXQgYnkgdGhlIHNlY29uZC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiXlwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgcmVzdWx0IG9mIHJhaXNpbmcgdGhlIGZpcnN0IGlucHV0IHRvIHRoZSBwb3dlciBzcGVjaWZpZWQgYnkgdGhlIHNlY29uZC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNxcnQ6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQyLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsb2cxMDoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGJhc2UtdGVuIGxvZ2FyaXRobSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsbjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGxvZzI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBiYXNlLXR3byBsb2dhcml0aG0gb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2luOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgc2luZSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjb3M6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBjb3NpbmUgb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dGFuOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgdGFuZ2VudCBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhc2luOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgYXJjc2luZSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhY29zOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgYXJjY29zaW5lIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGF0YW46IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBhcmN0YW5nZW50IG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG1pbjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIGlucHV0cy5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG1heDoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIGlucHV0cy5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJvdW5kOiB7XG5cdFx0XHRkb2M6IFwiUm91bmRzIHRoZSBpbnB1dCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLiBIYWxmd2F5IHZhbHVlcyBhcmUgcm91bmRlZCBhd2F5IGZyb20gemVyby4gRm9yIGV4YW1wbGUsIGBbXFxcInJvdW5kXFxcIiwgLTEuNV1gIGV2YWx1YXRlcyB0byAtMi5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFiczoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNlaWw6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBzbWFsbGVzdCBpbnRlZ2VyIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGZsb29yOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiPT1cIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGNvbXBhcmlzb24gaXMgc3RyaWN0bHkgdHlwZWQ6IHZhbHVlcyBvZiBkaWZmZXJlbnQgcnVudGltZSB0eXBlcyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQgdW5lcXVhbC4gQ2FzZXMgd2hlcmUgdGhlIHR5cGVzIGFyZSBrbm93biB0byBiZSBkaWZmZXJlbnQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbnZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29sbGF0b3I6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIiE9XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSBub3QgZXF1YWwsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgY29tcGFyaXNvbiBpcyBzdHJpY3RseSB0eXBlZDogdmFsdWVzIG9mIGRpZmZlcmVudCBydW50aW1lIHR5cGVzIGFyZSBhbHdheXMgY29uc2lkZXJlZCB1bmVxdWFsLiBDYXNlcyB3aGVyZSB0aGUgdHlwZXMgYXJlIGtub3duIHRvIGJlIGRpZmZlcmVudCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGludmFsaWQgYW5kIHdpbGwgcHJvZHVjZSBhIHBhcnNlIGVycm9yLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGBjb2xsYXRvcmAgYXJndW1lbnQgdG8gY29udHJvbCBsb2NhbGUtZGVwZW5kZW50IHN0cmluZyBjb21wYXJpc29ucy5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb2xsYXRvcjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4yLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiPlwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI8XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgc3RyaWN0bHkgbGVzcyB0aGFuIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29sbGF0b3I6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIj49XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29sbGF0b3I6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIjw9XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29sbGF0b3I6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbGw6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiBhbGwgdGhlIGlucHV0cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGlucHV0cyBhcmUgZXZhbHVhdGVkIGluIG9yZGVyLCBhbmQgZXZhbHVhdGlvbiBpcyBzaG9ydC1jaXJjdWl0aW5nOiBvbmNlIGFuIGlucHV0IGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGBmYWxzZWAsIHRoZSByZXN1bHQgaXMgYGZhbHNlYCBhbmQgbm8gZnVydGhlciBpbnB1dCBleHByZXNzaW9ucyBhcmUgZXZhbHVhdGVkLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFueToge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIGFueSBvZiB0aGUgaW5wdXRzIGFyZSBgdHJ1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgaW5wdXRzIGFyZSBldmFsdWF0ZWQgaW4gb3JkZXIsIGFuZCBldmFsdWF0aW9uIGlzIHNob3J0LWNpcmN1aXRpbmc6IG9uY2UgYW4gaW5wdXQgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYHRydWVgLCB0aGUgcmVzdWx0IGlzIGB0cnVlYCBhbmQgbm8gZnVydGhlciBpbnB1dCBleHByZXNzaW9ucyBhcmUgZXZhbHVhdGVkLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiIVwiOiB7XG5cdFx0XHRkb2M6IFwiTG9naWNhbCBuZWdhdGlvbi4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IGlzIGBmYWxzZWAsIGFuZCBgZmFsc2VgIGlmIHRoZSBpbnB1dCBpcyBgdHJ1ZWAuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0d2l0aGluOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZlYXR1cmUgYmVpbmcgZXZhbHVhdGVkIGlzIGluc2lkZSB0aGUgcHJlLWRlZmluZWQgZ2VvbWV0cnkgYm91bmRhcnksIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgZXhwcmVzc2lvbiBoYXMgb25lIGFyZ3VtZW50IHdoaWNoIG11c3QgYmUgYSB2YWxpZCBHZW9KU09OIFBvbHlnb24vTXVsdGktUG9seWdvbiBvYmplY3QuIFRoZSBleHByZXNzaW9uIG9ubHkgZXZhbHVhdGVzIG9uIGBQb2ludGAgb3IgYExpbmVTdHJpbmdgIGZlYXR1cmUuIEZvciBgUG9pbnRgIGZlYXR1cmUsIFRoZSBleHByZXNzaW9uIHdpbGwgcmV0dXJuIGZhbHNlIGlmIGFueSBwb2ludCBvZiB0aGUgZmVhdHVyZSBpcyBvbiB0aGUgYm91bmRhcnkgb3Igb3V0c2lkZSB0aGUgYm91bmRhcnkuIEZvciBgTGluZVN0cmluZ2AgZmVhdHVyZSwgdGhlIGV4cHJlc3Npb24gd2lsbCByZXR1cm4gZmFsc2UgaWYgdGhlIGxpbmUgaXMgZnVsbHkgb3V0c2lkZSB0aGUgYm91bmRhcnksIG9yIHRoZSBsaW5lIGlzIHBhcnRpYWxseSBpbnRlcnNlY3RpbmcgdGhlIGJvdW5kYXJ5LCB3aGljaCBtZWFucyBlaXRoZXIgcGFydCBvZiB0aGUgbGluZSBpcyBvdXRzaWRlIG9mIHRoZSBib3VuZGFyeSwgb3IgZW5kIHBvaW50IG9mIHRoZSBsaW5lIGxpZXMgb24gdGhlIGJvdW5kYXJ5LlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjEuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJpcy1zdXBwb3J0ZWQtc2NyaXB0XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5wdXQgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIHJlbmRlciBsZWdpYmx5LiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGlucHV0IHN0cmluZyBjb250YWlucyBzZWN0aW9ucyB0aGF0IGNhbm5vdCBiZSByZW5kZXJlZCB3aXRob3V0IHBvdGVudGlhbCBsb3NzIG9mIG1lYW5pbmcgKGUuZy4gSW5kaWMgc2NyaXB0cyB0aGF0IHJlcXVpcmUgY29tcGxleCB0ZXh0IHNoYXBpbmcsIG9yIHJpZ2h0LXRvLWxlZnQgc2NyaXB0cyBpZiB0aGUgdGhlIGBtYXBib3gtZ2wtcnRsLXRleHRgIHBsdWdpbiBpcyBub3QgaW4gdXNlIGluIE1hcGJveCBHTCBKUykuXCIsXG5cdFx0XHRncm91cDogXCJTdHJpbmdcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi42LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR1cGNhc2U6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBpbnB1dCBzdHJpbmcgY29udmVydGVkIHRvIHVwcGVyY2FzZS4gRm9sbG93cyB0aGUgVW5pY29kZSBEZWZhdWx0IENhc2UgQ29udmVyc2lvbiBhbGdvcml0aG0gYW5kIHRoZSBsb2NhbGUtaW5zZW5zaXRpdmUgY2FzZSBtYXBwaW5ncyBpbiB0aGUgVW5pY29kZSBDaGFyYWN0ZXIgRGF0YWJhc2UuXCIsXG5cdFx0XHRncm91cDogXCJTdHJpbmdcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvd25jYXNlOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgaW5wdXQgc3RyaW5nIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UuIEZvbGxvd3MgdGhlIFVuaWNvZGUgRGVmYXVsdCBDYXNlIENvbnZlcnNpb24gYWxnb3JpdGhtIGFuZCB0aGUgbG9jYWxlLWluc2Vuc2l0aXZlIGNhc2UgbWFwcGluZ3MgaW4gdGhlIFVuaWNvZGUgQ2hhcmFjdGVyIERhdGFiYXNlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiU3RyaW5nXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjb25jYXQ6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGEgYHN0cmluZ2AgY29uc2lzdGluZyBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgaW5wdXRzLiBFYWNoIGlucHV0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBhcyBpZiBieSBgdG8tc3RyaW5nYC5cIixcblx0XHRcdGdyb3VwOiBcIlN0cmluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJyZXNvbHZlZC1sb2NhbGVcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIElFVEYgbGFuZ3VhZ2UgdGFnIG9mIHRoZSBsb2NhbGUgYmVpbmcgdXNlZCBieSB0aGUgcHJvdmlkZWQgYGNvbGxhdG9yYC4gVGhpcyBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgc3lzdGVtIGxvY2FsZSwgb3IgdG8gZGV0ZXJtaW5lIGlmIGEgcmVxdWVzdGVkIGxvY2FsZSB3YXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cIixcblx0XHRcdGdyb3VwOiBcIlN0cmluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2xpY2U6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGEgcG9ydGlvbiBvZiBhIHN0cmluZyBvciBhbiBhcnJheSBzdGFydGluZyBmcm9tIHRoZSBwcm92aWRlZCBiZWdpbm5pbmcgaW5kZXguIElmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB0aGVuIHRoZSByZXR1cm4gcG9ydGlvbiB3aWxsIHJ1biB0bywgYnV0IG5vdCBpbmNsdWRlLCB0aGUgZW5kIGluZGV4LlwiLFxuXHRcdFx0Z3JvdXA6IFwiU3RyaW5nXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjEwLjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xudmFyIGxpZ2h0ID0ge1xuXHRhbmNob3I6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHRcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSBpcyBhbGlnbmVkIHRvIHRoZSByb3RhdGlvbiBvZiB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBwb3NpdGlvbiBvZiB0aGUgbGlnaHQgc291cmNlIGlzIGFsaWduZWQgdG8gdGhlIHJvdGF0aW9uIG9mIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuXHRcdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRkb2M6IFwiV2hldGhlciBleHRydWRlZCBnZW9tZXRyaWVzIGFyZSBsaXQgcmVsYXRpdmUgdG8gdGhlIG1hcCBvciB2aWV3cG9ydC5cIixcblx0XHRleGFtcGxlOiBcIm1hcFwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHBvc2l0aW9uOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQxLjE1LFxuXHRcdFx0MjEwLFxuXHRcdFx0MzBcblx0XHRdLFxuXHRcdGxlbmd0aDogMyxcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRkb2M6IFwiUG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSByZWxhdGl2ZSB0byBsaXQgKGV4dHJ1ZGVkKSBnZW9tZXRyaWVzLCBpbiBbciByYWRpYWwgY29vcmRpbmF0ZSwgYSBhemltdXRoYWwgYW5nbGUsIHAgcG9sYXIgYW5nbGVdIHdoZXJlIHIgaW5kaWNhdGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGJhc2Ugb2YgYW4gb2JqZWN0IHRvIGl0cyBsaWdodCwgYSBpbmRpY2F0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCByZWxhdGl2ZSB0byAwwrAgKDDCsCB3aGVuIGBsaWdodC5hbmNob3JgIGlzIHNldCB0byBgdmlld3BvcnRgIGNvcnJlc3BvbmRzIHRvIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0LCBvciAwwrAgd2hlbiBgbGlnaHQuYW5jaG9yYCBpcyBzZXQgdG8gYG1hcGAgY29ycmVzcG9uZHMgdG8gZHVlIG5vcnRoLCBhbmQgZGVncmVlcyBwcm9jZWVkIGNsb2Nrd2lzZSksIGFuZCBwIGluZGljYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBsaWdodCAoZnJvbSAwwrAsIGRpcmVjdGx5IGFib3ZlLCB0byAxODDCsCwgZGlyZWN0bHkgYmVsb3cpLlwiLFxuXHRcdGV4YW1wbGU6IFtcblx0XHRcdDEuNSxcblx0XHRcdDkwLFxuXHRcdFx0ODBcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGNvbG9yOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcblx0XHRcImRlZmF1bHRcIjogXCIjZmZmZmZmXCIsXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiQ29sb3IgdGludCBmb3IgbGlnaHRpbmcgZXh0cnVkZWQgZ2VvbWV0cmllcy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRpbnRlbnNpdHk6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcblx0XHRcImRlZmF1bHRcIjogMC41LFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJJbnRlbnNpdHkgb2YgbGlnaHRpbmcgKG9uIGEgc2NhbGUgZnJvbSAwIHRvIDEpLiBIaWdoZXIgbnVtYmVycyB3aWxsIHByZXNlbnQgYXMgbW9yZSBleHRyZW1lIGNvbnRyYXN0LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG52YXIgcGFpbnQgPSBbXG5cdFwicGFpbnRfZmlsbFwiLFxuXHRcInBhaW50X2xpbmVcIixcblx0XCJwYWludF9jaXJjbGVcIixcblx0XCJwYWludF9oZWF0bWFwXCIsXG5cdFwicGFpbnRfZmlsbC1leHRydXNpb25cIixcblx0XCJwYWludF9zeW1ib2xcIixcblx0XCJwYWludF9yYXN0ZXJcIixcblx0XCJwYWludF9oaWxsc2hhZGVcIixcblx0XCJwYWludF9iYWNrZ3JvdW5kXCJcbl07XG52YXIgcGFpbnRfZmlsbCA9IHtcblx0XCJmaWxsLWFudGlhbGlhc1wiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IHRydWUsXG5cdFx0ZG9jOiBcIldoZXRoZXIgb3Igbm90IHRoZSBmaWxsIHNob3VsZCBiZSBhbnRpYWxpYXNlZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiZmlsbC1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIGVudGlyZSBmaWxsIGxheWVyLiBJbiBjb250cmFzdCB0byB0aGUgYGZpbGwtY29sb3JgLCB0aGlzIHZhbHVlIHdpbGwgYWxzbyBhZmZlY3QgdGhlIDFweCBzdHJva2UgYXJvdW5kIHRoZSBmaWxsLCBpZiB0aGUgc3Ryb2tlIGlzIHVzZWQuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImZpbGwtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciBvZiB0aGUgZmlsbGVkIHBhcnQgb2YgdGhpcyBsYXllci4gVGhpcyBjb2xvciBjYW4gYmUgc3BlY2lmaWVkIGFzIGByZ2JhYCB3aXRoIGFuIGFscGhhIGNvbXBvbmVudCBhbmQgdGhlIGNvbG9yJ3Mgb3BhY2l0eSB3aWxsIG5vdCBhZmZlY3QgdGhlIG9wYWNpdHkgb2YgdGhlIDFweCBzdHJva2UsIGlmIGl0IGlzIHVzZWQuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJmaWxsLXBhdHRlcm5cIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJmaWxsLW91dGxpbmUtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRkb2M6IFwiVGhlIG91dGxpbmUgY29sb3Igb2YgdGhlIGZpbGwuIE1hdGNoZXMgdGhlIHZhbHVlIG9mIGBmaWxsLWNvbG9yYCBpZiB1bnNwZWNpZmllZC5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcImZpbGwtcGF0dGVyblwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRcImZpbGwtYW50aWFsaWFzXCI6IHRydWVcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjE5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiZmlsbC10cmFuc2xhdGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBmaWxsIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgZmlsbCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBmaWxsLXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiZmlsbC10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImZpbGwtcGF0dGVyblwiOiB7XG5cdFx0dHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGZpbGxzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40OS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMS4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcblx0fVxufTtcbnZhciBwYWludF9saW5lID0ge1xuXHRcImxpbmUtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRkb2M6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLXRyYW5zbGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogMixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwibGluZS10cmFuc2xhdGUtYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxpbmUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsaW5lIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiQ29udHJvbHMgdGhlIGZyYW1lIG9mIHJlZmVyZW5jZSBmb3IgYGxpbmUtdHJhbnNsYXRlYC5cIixcblx0XHRcImRlZmF1bHRcIjogXCJtYXBcIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJsaW5lLXRyYW5zbGF0ZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwibGluZS13aWR0aFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlN0cm9rZSB0aGlja25lc3MuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLWdhcC13aWR0aFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdGRvYzogXCJEcmF3cyBhIGxpbmUgY2FzaW5nIG91dHNpZGUgb2YgYSBsaW5lJ3MgYWN0dWFsIHBhdGguIFZhbHVlIGluZGljYXRlcyB0aGUgd2lkdGggb2YgdGhlIGlubmVyIGdhcC5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS1vZmZzZXRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0ZG9jOiBcIlRoZSBsaW5lJ3Mgb2Zmc2V0LiBGb3IgbGluZWFyIGZlYXR1cmVzLCBhIHBvc2l0aXZlIHZhbHVlIG9mZnNldHMgdGhlIGxpbmUgdG8gdGhlIHJpZ2h0LCByZWxhdGl2ZSB0byB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lLCBhbmQgYSBuZWdhdGl2ZSB2YWx1ZSB0byB0aGUgbGVmdC4gRm9yIHBvbHlnb24gZmVhdHVyZXMsIGEgcG9zaXRpdmUgdmFsdWUgcmVzdWx0cyBpbiBhbiBpbnNldCwgYW5kIGEgbmVnYXRpdmUgdmFsdWUgcmVzdWx0cyBpbiBhbiBvdXRzZXQuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTIuMVwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjMuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjEuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtYmx1clwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIkJsdXIgYXBwbGllZCB0byB0aGUgbGluZSwgaW4gcGl4ZWxzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS1kYXNoYXJyYXlcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiU3BlY2lmaWVzIHRoZSBsZW5ndGhzIG9mIHRoZSBhbHRlcm5hdGluZyBkYXNoZXMgYW5kIGdhcHMgdGhhdCBmb3JtIHRoZSBkYXNoIHBhdHRlcm4uIFRoZSBsZW5ndGhzIGFyZSBsYXRlciBzY2FsZWQgYnkgdGhlIGxpbmUgd2lkdGguIFRvIGNvbnZlcnQgYSBkYXNoIGxlbmd0aCB0byBwaXhlbHMsIG11bHRpcGx5IHRoZSBsZW5ndGggYnkgdGhlIGN1cnJlbnQgbGluZSB3aWR0aC4gTm90ZSB0aGF0IEdlb0pTT04gc291cmNlcyB3aXRoIGBsaW5lTWV0cmljczogdHJ1ZWAgc3BlY2lmaWVkIHdvbid0IHJlbmRlciBkYXNoZWQgbGluZXMgdG8gdGhlIGV4cGVjdGVkIHNjYWxlLiBBbHNvIG5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcImxpbmUgd2lkdGhzXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkXCJcblx0fSxcblx0XCJsaW5lLXBhdHRlcm5cIjoge1xuXHRcdHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBsaW5lcy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLiBOb3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQ5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjExLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtZ3JhZGllbnRcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRkb2M6IFwiRGVmaW5lcyBhIGdyYWRpZW50IHdpdGggd2hpY2ggdG8gY29sb3IgYSBsaW5lIGZlYXR1cmUuIENhbiBvbmx5IGJlIHVzZWQgd2l0aCBHZW9KU09OIHNvdXJjZXMgdGhhdCBzcGVjaWZ5IGBcXFwibGluZU1ldHJpY3NcXFwiOiB0cnVlYC5cIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJsaW5lLWRhc2hhcnJheVwiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0c291cmNlOiBcImdlb2pzb25cIixcblx0XHRcdFx0aGFzOiB7XG5cdFx0XHRcdFx0bGluZU1ldHJpY3M6IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC40LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcImxpbmUtcHJvZ3Jlc3NcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG5cdH1cbn07XG52YXIgcGFpbnRfY2lyY2xlID0ge1xuXHRcImNpcmNsZS1yYWRpdXNcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDUsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJDaXJjbGUgcmFkaXVzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjE4LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiY2lyY2xlLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdGRvYzogXCJUaGUgZmlsbCBjb2xvciBvZiB0aGUgY2lyY2xlLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTguMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJjaXJjbGUtYmx1clwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiQW1vdW50IHRvIGJsdXIgdGhlIGNpcmNsZS4gMSBibHVycyB0aGUgY2lyY2xlIHN1Y2ggdGhhdCBvbmx5IHRoZSBjZW50ZXJwb2ludCBpcyBmdWxsIG9wYWNpdHkuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImNpcmNsZS1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgY2lyY2xlIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJjaXJjbGUtdHJhbnNsYXRlXCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MFxuXHRcdF0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBjaXJjbGUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBjaXJjbGUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgY2lyY2xlLXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiY2lyY2xlLXRyYW5zbGF0ZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiQ2lyY2xlcyBhcmUgc2NhbGVkIGFjY29yZGluZyB0byB0aGVpciBhcHBhcmVudCBkaXN0YW5jZSB0byB0aGUgY2FtZXJhLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIkNpcmNsZXMgYXJlIG5vdCBzY2FsZWQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgc2NhbGluZyBiZWhhdmlvciBvZiB0aGUgY2lyY2xlIHdoZW4gdGhlIG1hcCBpcyBwaXRjaGVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMi4xXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGNpcmNsZSBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBjaXJjbGUgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuXHRcdGRvYzogXCJPcmllbnRhdGlvbiBvZiBjaXJjbGUgd2hlbiBtYXAgaXMgcGl0Y2hlZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSB3aWR0aCBvZiB0aGUgY2lyY2xlJ3Mgc3Ryb2tlLiBTdHJva2VzIGFyZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgYGNpcmNsZS1yYWRpdXNgLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiY2lyY2xlLXN0cm9rZS1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgY2lyY2xlLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBjaXJjbGUncyBzdHJva2UuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fVxufTtcbnZhciBwYWludF9oZWF0bWFwID0ge1xuXHRcImhlYXRtYXAtcmFkaXVzXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAzMCxcblx0XHRtaW5pbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlJhZGl1cyBvZiBpbmZsdWVuY2Ugb2Ygb25lIGhlYXRtYXAgcG9pbnQgaW4gcGl4ZWxzLiBJbmNyZWFzaW5nIHRoZSB2YWx1ZSBtYWtlcyB0aGUgaGVhdG1hcCBzbW9vdGhlciwgYnV0IGxlc3MgZGV0YWlsZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJoZWF0bWFwLXdlaWdodFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcdGRvYzogXCJBIG1lYXN1cmUgb2YgaG93IG11Y2ggYW4gaW5kaXZpZHVhbCBwb2ludCBjb250cmlidXRlcyB0byB0aGUgaGVhdG1hcC4gQSB2YWx1ZSBvZiAxMCB3b3VsZCBiZSBlcXVpdmFsZW50IHRvIGhhdmluZyAxMCBwb2ludHMgb2Ygd2VpZ2h0IDEgaW4gdGhlIHNhbWUgc3BvdC4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiBjb21iaW5lZCB3aXRoIGNsdXN0ZXJpbmcuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJoZWF0bWFwLWludGVuc2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIlNpbWlsYXIgdG8gYGhlYXRtYXAtd2VpZ2h0YCBidXQgY29udHJvbHMgdGhlIGludGVuc2l0eSBvZiB0aGUgaGVhdG1hcCBnbG9iYWxseS4gUHJpbWFyaWx5IHVzZWQgZm9yIGFkanVzdGluZyB0aGUgaGVhdG1hcCBiYXNlZCBvbiB6b29tIGxldmVsLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImhlYXRtYXAtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0XCJpbnRlcnBvbGF0ZVwiLFxuXHRcdFx0W1xuXHRcdFx0XHRcImxpbmVhclwiXG5cdFx0XHRdLFxuXHRcdFx0W1xuXHRcdFx0XHRcImhlYXRtYXAtZGVuc2l0eVwiXG5cdFx0XHRdLFxuXHRcdFx0MCxcblx0XHRcdFwicmdiYSgwLCAwLCAyNTUsIDApXCIsXG5cdFx0XHQwLjEsXG5cdFx0XHRcInJveWFsYmx1ZVwiLFxuXHRcdFx0MC4zLFxuXHRcdFx0XCJjeWFuXCIsXG5cdFx0XHQwLjUsXG5cdFx0XHRcImxpbWVcIixcblx0XHRcdDAuNyxcblx0XHRcdFwieWVsbG93XCIsXG5cdFx0XHQxLFxuXHRcdFx0XCJyZWRcIlxuXHRcdF0sXG5cdFx0ZG9jOiBcIkRlZmluZXMgdGhlIGNvbG9yIG9mIGVhY2ggcGl4ZWwgYmFzZWQgb24gaXRzIGRlbnNpdHkgdmFsdWUgaW4gYSBoZWF0bWFwLiAgU2hvdWxkIGJlIGFuIGV4cHJlc3Npb24gdGhhdCB1c2VzIGBbXFxcImhlYXRtYXAtZGVuc2l0eVxcXCJdYCBhcyBpbnB1dC5cIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJoZWF0bWFwLWRlbnNpdHlcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG5cdH0sXG5cdFwiaGVhdG1hcC1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJUaGUgZ2xvYmFsIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGhlYXRtYXAgbGF5ZXIgd2lsbCBiZSBkcmF3bi5cIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fVxufTtcbnZhciBwYWludF9zeW1ib2wgPSB7XG5cdFwiaWNvbi1vcGFjaXR5XCI6IHtcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGljb24gd2lsbCBiZSBkcmF3bi5cIixcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciBvZiB0aGUgaWNvbi4gVGhpcyBjYW4gb25seSBiZSB1c2VkIHdpdGggc2RmIGljb25zLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLWhhbG8tY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uJ3MgaGFsby4gSWNvbiBoYWxvcyBjYW4gb25seSBiZSB1c2VkIHdpdGggU0RGIGljb25zLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLWhhbG8td2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBpY29uIG91dGxpbmUuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24taGFsby1ibHVyXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiRmFkZSBvdXQgdGhlIGhhbG8gdG93YXJkcyB0aGUgb3V0c2lkZS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi10cmFuc2xhdGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJEaXN0YW5jZSB0aGF0IHRoZSBpY29uJ3MgYW5jaG9yIGlzIG1vdmVkIGZyb20gaXRzIG9yaWdpbmFsIHBsYWNlbWVudC4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJJY29ucyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIkljb25zIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBpY29uLXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiLFxuXHRcdFx0XCJpY29uLXRyYW5zbGF0ZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0b3ZlcnJpZGFibGU6IHRydWUsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtaGFsby1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIHRleHQncyBoYWxvLCB3aGljaCBoZWxwcyBpdCBzdGFuZCBvdXQgZnJvbSBiYWNrZ3JvdW5kcy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1oYWxvLXdpZHRoXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgZm9udCBvdXRsaW5lLiBNYXggdGV4dCBoYWxvIHdpZHRoIGlzIDEvNCBvZiB0aGUgZm9udC1zaXplLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LWhhbG8tYmx1clwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBoYWxvJ3MgZmFkZW91dCBkaXN0YW5jZSB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LXRyYW5zbGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogMixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIkRpc3RhbmNlIHRoYXQgdGhlIHRleHQncyBhbmNob3IgaXMgbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcGxhY2VtZW50LiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGB0ZXh0LXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0XCJ0ZXh0LXRyYW5zbGF0ZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH1cbn07XG52YXIgcGFpbnRfcmFzdGVyID0ge1xuXHRcInJhc3Rlci1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItaHVlLXJvdGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRwZXJpb2Q6IDM2MCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcImRlZ3JlZXNcIixcblx0XHRkb2M6IFwiUm90YXRlcyBodWVzIGFyb3VuZCB0aGUgY29sb3Igd2hlZWwuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1pbmltdW0gYnJpZ2h0bmVzcy5cIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgaW1hZ2UuIFRoZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBicmlnaHRuZXNzLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInJhc3Rlci1zYXR1cmF0aW9uXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIHNhdHVyYXRpb24gb2YgdGhlIGltYWdlLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IC0xLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItY29udHJhc3RcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgY29udHJhc3Qgb2YgdGhlIGltYWdlLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IC0xLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItcmVzYW1wbGluZ1wiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0ZG9jOiBcIlRoZSByZXNhbXBsaW5nL2ludGVycG9sYXRpb24gbWV0aG9kIHRvIHVzZSBmb3Igb3ZlcnNjYWxpbmcsIGFsc28ga25vd24gYXMgdGV4dHVyZSBtYWduaWZpY2F0aW9uIGZpbHRlclwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bGluZWFyOiB7XG5cdFx0XHRcdGRvYzogXCIoQmkpbGluZWFyIGZpbHRlcmluZyBpbnRlcnBvbGF0ZXMgcGl4ZWwgdmFsdWVzIHVzaW5nIHRoZSB3ZWlnaHRlZCBhdmVyYWdlIG9mIHRoZSBmb3VyIGNsb3Nlc3Qgb3JpZ2luYWwgc291cmNlIHBpeGVscyBjcmVhdGluZyBhIHNtb290aCBidXQgYmx1cnJ5IGxvb2sgd2hlbiBvdmVyc2NhbGVkXCJcblx0XHRcdH0sXG5cdFx0XHRuZWFyZXN0OiB7XG5cdFx0XHRcdGRvYzogXCJOZWFyZXN0IG5laWdoYm9yIGZpbHRlcmluZyBpbnRlcnBvbGF0ZXMgcGl4ZWwgdmFsdWVzIHVzaW5nIHRoZSBuZWFyZXN0IG9yaWdpbmFsIHNvdXJjZSBwaXhlbCBjcmVhdGluZyBhIHNoYXJwIGJ1dCBwaXhlbGF0ZWQgbG9vayB3aGVuIG92ZXJzY2FsZWRcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibGluZWFyXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQ3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjMuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4yLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAzMDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHR1bml0czogXCJtaWxsaXNlY29uZHNcIixcblx0XHRkb2M6IFwiRmFkZSBkdXJhdGlvbiB3aGVuIGEgbmV3IHRpbGUgaXMgYWRkZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH1cbn07XG52YXIgcGFpbnRfaGlsbHNoYWRlID0ge1xuXHRcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tZGlyZWN0aW9uXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAzMzUsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAzNTksXG5cdFx0ZG9jOiBcIlRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBoaWxsc2hhZGluZyB3aXRoIDAgYXMgdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgaWYgYGhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yYCBpcyBzZXQgdG8gYHZpZXdwb3J0YCBhbmQgZHVlIG5vcnRoIGlmIGBoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvcmAgaXMgc2V0IHRvIGBtYXBgLlwiLFxuXHRcdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGhpbGxzaGFkZSBpbGx1bWluYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG5vcnRoIGRpcmVjdGlvbi5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaGlsbHNoYWRlIGlsbHVtaW5hdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcblx0XHRkb2M6IFwiRGlyZWN0aW9uIG9mIGxpZ2h0IHNvdXJjZSB3aGVuIG1hcCBpcyByb3RhdGVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJJbnRlbnNpdHkgb2YgdGhlIGhpbGxzaGFkZVwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLjUsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaGlsbHNoYWRlLXNoYWRvdy1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIHNoYWRpbmcgY29sb3Igb2YgYXJlYXMgdGhhdCBmYWNlIGF3YXkgZnJvbSB0aGUgbGlnaHQgc291cmNlLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaGlsbHNoYWRlLWhpZ2hsaWdodC1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiNGRkZGRkZcIixcblx0XHRkb2M6IFwiVGhlIHNoYWRpbmcgY29sb3Igb2YgYXJlYXMgdGhhdCBmYWNlcyB0b3dhcmRzIHRoZSBsaWdodCBzb3VyY2UuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdGRvYzogXCJUaGUgc2hhZGluZyBjb2xvciB1c2VkIHRvIGFjY2VudHVhdGUgcnVnZ2VkIHRlcnJhaW4gbGlrZSBzaGFycCBjbGlmZnMgYW5kIGdvcmdlcy5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIHBhaW50X2JhY2tncm91bmQgPSB7XG5cdFwiYmFja2dyb3VuZC1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcImJhY2tncm91bmQtcGF0dGVyblwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJiYWNrZ3JvdW5kLXBhdHRlcm5cIjoge1xuXHRcdHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBhbiBpbWFnZSBiYWNrZ3JvdW5kLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZFwiXG5cdH0sXG5cdFwiYmFja2dyb3VuZC1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIHRyYW5zaXRpb24gPSB7XG5cdGR1cmF0aW9uOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMzAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwibWlsbGlzZWNvbmRzXCIsXG5cdFx0ZG9jOiBcIlRpbWUgYWxsb3R0ZWQgZm9yIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlLlwiXG5cdH0sXG5cdGRlbGF5OiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcIm1pbGxpc2Vjb25kc1wiLFxuXHRcdGRvYzogXCJMZW5ndGggb2YgdGltZSBiZWZvcmUgYSB0cmFuc2l0aW9uIGJlZ2lucy5cIlxuXHR9XG59O1xudmFyIHByb21vdGVJZCA9IHtcblx0XCIqXCI6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIG5hbWUgb2YgYSBmZWF0dXJlIHByb3BlcnR5IHRvIHVzZSBhcyBJRCBmb3IgZmVhdHVyZSBzdGF0ZS5cIlxuXHR9XG59O1xudmFyIHY4ID0ge1xuXHQkdmVyc2lvbjogJHZlcnNpb24sXG5cdCRyb290OiAkcm9vdCxcblx0c291cmNlczogc291cmNlcyxcblx0c291cmNlOiBzb3VyY2UsXG5cdHNvdXJjZV92ZWN0b3I6IHNvdXJjZV92ZWN0b3IsXG5cdHNvdXJjZV9yYXN0ZXI6IHNvdXJjZV9yYXN0ZXIsXG5cdHNvdXJjZV9yYXN0ZXJfZGVtOiBzb3VyY2VfcmFzdGVyX2RlbSxcblx0c291cmNlX2dlb2pzb246IHNvdXJjZV9nZW9qc29uLFxuXHRzb3VyY2VfdmlkZW86IHNvdXJjZV92aWRlbyxcblx0c291cmNlX2ltYWdlOiBzb3VyY2VfaW1hZ2UsXG5cdGxheWVyOiBsYXllcixcblx0bGF5b3V0OiBsYXlvdXQsXG5cdGxheW91dF9iYWNrZ3JvdW5kOiBsYXlvdXRfYmFja2dyb3VuZCxcblx0bGF5b3V0X2ZpbGw6IGxheW91dF9maWxsLFxuXHRsYXlvdXRfY2lyY2xlOiBsYXlvdXRfY2lyY2xlLFxuXHRsYXlvdXRfaGVhdG1hcDogbGF5b3V0X2hlYXRtYXAsXG5cdFwibGF5b3V0X2ZpbGwtZXh0cnVzaW9uXCI6IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufSxcblx0bGF5b3V0X2xpbmU6IGxheW91dF9saW5lLFxuXHRsYXlvdXRfc3ltYm9sOiBsYXlvdXRfc3ltYm9sLFxuXHRsYXlvdXRfcmFzdGVyOiBsYXlvdXRfcmFzdGVyLFxuXHRsYXlvdXRfaGlsbHNoYWRlOiBsYXlvdXRfaGlsbHNoYWRlLFxuXHRmaWx0ZXI6IGZpbHRlcixcblx0ZmlsdGVyX29wZXJhdG9yOiBmaWx0ZXJfb3BlcmF0b3IsXG5cdGdlb21ldHJ5X3R5cGU6IGdlb21ldHJ5X3R5cGUsXG5cdFwiZnVuY3Rpb25cIjoge1xuXHRleHByZXNzaW9uOiB7XG5cdFx0dHlwZTogXCJleHByZXNzaW9uXCIsXG5cdFx0ZG9jOiBcIkFuIGV4cHJlc3Npb24uXCJcblx0fSxcblx0c3RvcHM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0ZG9jOiBcIkFuIGFycmF5IG9mIHN0b3BzLlwiLFxuXHRcdHZhbHVlOiBcImZ1bmN0aW9uX3N0b3BcIlxuXHR9LFxuXHRiYXNlOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdGRvYzogXCJUaGUgZXhwb25lbnRpYWwgYmFzZSBvZiB0aGUgaW50ZXJwb2xhdGlvbiBjdXJ2ZS4gSXQgY29udHJvbHMgdGhlIHJhdGUgYXQgd2hpY2ggdGhlIHJlc3VsdCBpbmNyZWFzZXMuIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgcmVzdWx0IGluY3JlYXNlIG1vcmUgdG93YXJkcyB0aGUgaGlnaCBlbmQgb2YgdGhlIHJhbmdlLiBXaXRoIGAxYCB0aGUgc3RvcHMgYXJlIGludGVycG9sYXRlZCBsaW5lYXJseS5cIlxuXHR9LFxuXHRwcm9wZXJ0eToge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIlRoZSBuYW1lIG9mIGEgZmVhdHVyZSBwcm9wZXJ0eSB0byB1c2UgYXMgdGhlIGZ1bmN0aW9uIGlucHV0LlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiR6b29tXCJcblx0fSxcblx0dHlwZToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0aWRlbnRpdHk6IHtcblx0XHRcdFx0ZG9jOiBcIlJldHVybiB0aGUgaW5wdXQgdmFsdWUgYXMgdGhlIG91dHB1dCB2YWx1ZS5cIlxuXHRcdFx0fSxcblx0XHRcdGV4cG9uZW50aWFsOiB7XG5cdFx0XHRcdGRvYzogXCJHZW5lcmF0ZSBhbiBvdXRwdXQgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHN0b3BzIGp1c3QgbGVzcyB0aGFuIGFuZCBqdXN0IGdyZWF0ZXIgdGhhbiB0aGUgZnVuY3Rpb24gaW5wdXQuXCJcblx0XHRcdH0sXG5cdFx0XHRpbnRlcnZhbDoge1xuXHRcdFx0XHRkb2M6IFwiUmV0dXJuIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhlIHN0b3AganVzdCBsZXNzIHRoYW4gdGhlIGZ1bmN0aW9uIGlucHV0LlwiXG5cdFx0XHR9LFxuXHRcdFx0Y2F0ZWdvcmljYWw6IHtcblx0XHRcdFx0ZG9jOiBcIlJldHVybiB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoZSBzdG9wIGVxdWFsIHRvIHRoZSBmdW5jdGlvbiBpbnB1dC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBpbnRlcnBvbGF0aW9uIHN0cmF0ZWd5IHRvIHVzZSBpbiBmdW5jdGlvbiBldmFsdWF0aW9uLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcImV4cG9uZW50aWFsXCJcblx0fSxcblx0Y29sb3JTcGFjZToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0cmdiOiB7XG5cdFx0XHRcdGRvYzogXCJVc2UgdGhlIFJHQiBjb2xvciBzcGFjZSB0byBpbnRlcnBvbGF0ZSBjb2xvciB2YWx1ZXNcIlxuXHRcdFx0fSxcblx0XHRcdGxhYjoge1xuXHRcdFx0XHRkb2M6IFwiVXNlIHRoZSBMQUIgY29sb3Igc3BhY2UgdG8gaW50ZXJwb2xhdGUgY29sb3IgdmFsdWVzLlwiXG5cdFx0XHR9LFxuXHRcdFx0aGNsOiB7XG5cdFx0XHRcdGRvYzogXCJVc2UgdGhlIEhDTCBjb2xvciBzcGFjZSB0byBpbnRlcnBvbGF0ZSBjb2xvciB2YWx1ZXMsIGludGVycG9sYXRpbmcgdGhlIEh1ZSwgQ2hyb21hLCBhbmQgTHVtaW5hbmNlIGNoYW5uZWxzIGluZGl2aWR1YWxseS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciBzcGFjZSBpbiB3aGljaCBjb2xvcnMgaW50ZXJwb2xhdGVkLiBJbnRlcnBvbGF0aW5nIGNvbG9ycyBpbiBwZXJjZXB0dWFsIGNvbG9yIHNwYWNlcyBsaWtlIExBQiBhbmQgSENMIHRlbmQgdG8gcHJvZHVjZSBjb2xvciByYW1wcyB0aGF0IGxvb2sgbW9yZSBjb25zaXN0ZW50IGFuZCBwcm9kdWNlIGNvbG9ycyB0aGF0IGNhbiBiZSBkaWZmZXJlbnRpYXRlZCBtb3JlIGVhc2lseSB0aGFuIHRob3NlIGludGVycG9sYXRlZCBpbiBSR0Igc3BhY2UuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwicmdiXCJcblx0fSxcblx0XCJkZWZhdWx0XCI6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRyZXF1aXJlZDogZmFsc2UsXG5cdFx0ZG9jOiBcIkEgdmFsdWUgdG8gc2VydmUgYXMgYSBmYWxsYmFjayBmdW5jdGlvbiByZXN1bHQgd2hlbiBhIHZhbHVlIGlzbid0IG90aGVyd2lzZSBhdmFpbGFibGUuIEl0IGlzIHVzZWQgaW4gdGhlIGZvbGxvd2luZyBjaXJjdW1zdGFuY2VzOlxcbiogSW4gY2F0ZWdvcmljYWwgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgc3RvcCBkb21haW4gdmFsdWVzLlxcbiogSW4gcHJvcGVydHkgYW5kIHpvb20tYW5kLXByb3BlcnR5IGZ1bmN0aW9ucywgd2hlbiBhIGZlYXR1cmUgZG9lcyBub3QgY29udGFpbiBhIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxcbiogSW4gaWRlbnRpdHkgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGlzIG5vdCB2YWxpZCBmb3IgdGhlIHN0eWxlIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgaWYgdGhlIGZ1bmN0aW9uIGlzIGJlaW5nIHVzZWQgZm9yIGEgYGNpcmNsZS1jb2xvcmAgcHJvcGVydHkgYnV0IHRoZSBmZWF0dXJlIHByb3BlcnR5IHZhbHVlIGlzIG5vdCBhIHN0cmluZyBvciBub3QgYSB2YWxpZCBjb2xvcikuXFxuKiBJbiBpbnRlcnZhbCBvciBleHBvbmVudGlhbCBwcm9wZXJ0eSBhbmQgem9vbS1hbmQtcHJvcGVydHkgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGlzIG5vdCBudW1lcmljLlxcbklmIG5vIGRlZmF1bHQgaXMgcHJvdmlkZWQsIHRoZSBzdHlsZSBwcm9wZXJ0eSdzIGRlZmF1bHQgaXMgdXNlZCBpbiB0aGVzZSBjaXJjdW1zdGFuY2VzLlwiXG5cdH1cbn0sXG5cdGZ1bmN0aW9uX3N0b3A6IGZ1bmN0aW9uX3N0b3AsXG5cdGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG5cdGV4cHJlc3Npb25fbmFtZTogZXhwcmVzc2lvbl9uYW1lLFxuXHRsaWdodDogbGlnaHQsXG5cdHBhaW50OiBwYWludCxcblx0cGFpbnRfZmlsbDogcGFpbnRfZmlsbCxcblx0XCJwYWludF9maWxsLWV4dHJ1c2lvblwiOiB7XG5cdFwiZmlsbC1leHRydXNpb24tb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBlbnRpcmUgZmlsbCBleHRydXNpb24gbGF5ZXIuIFRoaXMgaXMgcmVuZGVyZWQgb24gYSBwZXItbGF5ZXIsIG5vdCBwZXItZmVhdHVyZSwgYmFzaXMsIGFuZCBkYXRhLWRyaXZlbiBzdHlsaW5nIGlzIG5vdCBhdmFpbGFibGUuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIGJhc2UgY29sb3Igb2YgdGhlIGV4dHJ1ZGVkIGZpbGwuIFRoZSBleHRydXNpb24ncyBzdXJmYWNlcyB3aWxsIGJlIHNoYWRlZCBkaWZmZXJlbnRseSBiYXNlZCBvbiB0aGlzIGNvbG9yIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIHJvb3QgYGxpZ2h0YCBzZXR0aW5ncy4gSWYgdGhpcyBjb2xvciBpcyBzcGVjaWZpZWQgYXMgYHJnYmFgIHdpdGggYW4gYWxwaGEgY29tcG9uZW50LCB0aGUgYWxwaGEgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZDsgdXNlIGBmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5YCB0byBzZXQgbGF5ZXIgb3BhY2l0eS5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCAob24gdGhlIGZsYXQgcGxhbmUpLCByZXNwZWN0aXZlbHkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBmaWxsIGV4dHJ1c2lvbiBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGZpbGwgZXh0cnVzaW9uIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiQ29udHJvbHMgdGhlIGZyYW1lIG9mIHJlZmVyZW5jZSBmb3IgYGZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCI6IHtcblx0XHR0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2VzIG9uIGV4dHJ1ZGVkIGZpbGxzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40OS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMS4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi1oZWlnaHRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR1bml0czogXCJtZXRlcnNcIixcblx0XHRkb2M6IFwiVGhlIGhlaWdodCB3aXRoIHdoaWNoIHRvIGV4dHJ1ZGUgdGhpcyBsYXllci5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiZmlsbC1leHRydXNpb24tYmFzZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcIm1ldGVyc1wiLFxuXHRcdGRvYzogXCJUaGUgaGVpZ2h0IHdpdGggd2hpY2ggdG8gZXh0cnVkZSB0aGUgYmFzZSBvZiB0aGlzIGxheWVyLiBNdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgZmlsbC1leHRydXNpb24taGVpZ2h0YC5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImZpbGwtZXh0cnVzaW9uLWhlaWdodFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImZpbGwtZXh0cnVzaW9uLXZlcnRpY2FsLWdyYWRpZW50XCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogdHJ1ZSxcblx0XHRkb2M6IFwiV2hldGhlciB0byBhcHBseSBhIHZlcnRpY2FsIGdyYWRpZW50IHRvIHRoZSBzaWRlcyBvZiBhIGZpbGwtZXh0cnVzaW9uIGxheWVyLiBJZiB0cnVlLCBzaWRlcyB3aWxsIGJlIHNoYWRlZCBzbGlnaHRseSBkYXJrZXIgZmFydGhlciBkb3duLlwiLFxuXHRcdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC41MC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEzLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59LFxuXHRwYWludF9saW5lOiBwYWludF9saW5lLFxuXHRwYWludF9jaXJjbGU6IHBhaW50X2NpcmNsZSxcblx0cGFpbnRfaGVhdG1hcDogcGFpbnRfaGVhdG1hcCxcblx0cGFpbnRfc3ltYm9sOiBwYWludF9zeW1ib2wsXG5cdHBhaW50X3Jhc3RlcjogcGFpbnRfcmFzdGVyLFxuXHRwYWludF9oaWxsc2hhZGU6IHBhaW50X2hpbGxzaGFkZSxcblx0cGFpbnRfYmFja2dyb3VuZDogcGFpbnRfYmFja2dyb3VuZCxcblx0dHJhbnNpdGlvbjogdHJhbnNpdGlvbixcblx0XCJwcm9wZXJ0eS10eXBlXCI6IHtcblx0XCJkYXRhLWRyaXZlblwiOiB7XG5cdFx0dHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG5cdFx0ZG9jOiBcIlByb3BlcnR5IGlzIGludGVycG9sYWJsZSBhbmQgY2FuIGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi5cIlxuXHR9LFxuXHRcImNyb3NzLWZhZGVkXCI6IHtcblx0XHR0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcblx0XHRkb2M6IFwiUHJvcGVydHkgaXMgbm9uLWludGVycG9sYWJsZTsgcmF0aGVyLCBpdHMgdmFsdWVzIHdpbGwgYmUgY3Jvc3MtZmFkZWQgdG8gc21vb3RobHkgdHJhbnNpdGlvbiBiZXR3ZWVuIGludGVnZXIgem9vbXMuXCJcblx0fSxcblx0XCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiOiB7XG5cdFx0dHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG5cdFx0ZG9jOiBcIlByb3BlcnR5IGlzIG5vbi1pbnRlcnBvbGFibGU7IHJhdGhlciwgaXRzIHZhbHVlcyB3aWxsIGJlIGNyb3NzLWZhZGVkIHRvIHNtb290aGx5IHRyYW5zaXRpb24gYmV0d2VlbiBpbnRlZ2VyIHpvb21zLiBJdCBjYW4gYmUgcmVwcmVzZW50ZWQgdXNpbmcgYSBwcm9wZXJ0eSBleHByZXNzaW9uLlwiXG5cdH0sXG5cdFwiY29sb3ItcmFtcFwiOiB7XG5cdFx0dHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG5cdFx0ZG9jOiBcIlByb3BlcnR5IHNob3VsZCBiZSBzcGVjaWZpZWQgdXNpbmcgYSBjb2xvciByYW1wIGZyb20gd2hpY2ggdGhlIG91dHB1dCBjb2xvciBjYW4gYmUgc2FtcGxlZCBiYXNlZCBvbiBhIHByb3BlcnR5IGNhbGN1bGF0aW9uLlwiXG5cdH0sXG5cdFwiZGF0YS1jb25zdGFudFwiOiB7XG5cdFx0dHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG5cdFx0ZG9jOiBcIlByb3BlcnR5IGlzIGludGVycG9sYWJsZSBidXQgY2Fubm90IGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi5cIlxuXHR9LFxuXHRjb25zdGFudDoge1xuXHRcdHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuXHRcdGRvYzogXCJQcm9wZXJ0eSBpcyBjb25zdGFudCBhY3Jvc3MgYWxsIHpvb20gbGV2ZWxzIGFuZCBwcm9wZXJ0eSB2YWx1ZXMuXCJcblx0fVxufSxcblx0cHJvbW90ZUlkOiBwcm9tb3RlSWRcbn07XG5cbi8vIE5vdGU6IFRoaXMgcmVnZXggbWF0Y2hlcyBldmVuIGludmFsaWQgSlNPTiBzdHJpbmdzLCBidXQgc2luY2Ugd2XigJlyZVxuLy8gd29ya2luZyBvbiB0aGUgb3V0cHV0IG9mIGBKU09OLnN0cmluZ2lmeWAgd2Uga25vdyB0aGF0IG9ubHkgdmFsaWQgc3RyaW5nc1xuLy8gYXJlIHByZXNlbnQgKHVubGVzcyB0aGUgdXNlciBzdXBwbGllZCBhIHdlaXJkIGBvcHRpb25zLmluZGVudGAgYnV0IGluXG4vLyB0aGF0IGNhc2Ugd2UgZG9u4oCZdCBjYXJlIHNpbmNlIHRoZSBvdXRwdXQgd291bGQgYmUgaW52YWxpZCBhbnl3YXkpLlxudmFyIHN0cmluZ09yQ2hhciA9IC8oXCIoPzpbXlxcXFxcIl18XFxcXC4pKlwiKXxbOixdL2c7XG5cbnZhciBqc29uU3RyaW5naWZ5UHJldHR5Q29tcGFjdCA9IGZ1bmN0aW9uIHN0cmluZ2lmeShwYXNzZWRPYmosIG9wdGlvbnMpIHtcbiAgdmFyIGluZGVudCwgbWF4TGVuZ3RoLCByZXBsYWNlcjtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaW5kZW50ID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgWzFdLFxuICAgIHVuZGVmaW5lZCxcbiAgICBvcHRpb25zLmluZGVudCA9PT0gdW5kZWZpbmVkID8gMiA6IG9wdGlvbnMuaW5kZW50XG4gICkuc2xpY2UoMiwgLTMpO1xuICBtYXhMZW5ndGggPVxuICAgIGluZGVudCA9PT0gXCJcIlxuICAgICAgPyBJbmZpbml0eVxuICAgICAgOiBvcHRpb25zLm1heExlbmd0aCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IDgwXG4gICAgICA6IG9wdGlvbnMubWF4TGVuZ3RoO1xuICByZXBsYWNlciA9IG9wdGlvbnMucmVwbGFjZXI7XG5cbiAgcmV0dXJuIChmdW5jdGlvbiBfc3RyaW5naWZ5KG9iaiwgY3VycmVudEluZGVudCwgcmVzZXJ2ZWQpIHtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICB2YXIgZW5kLCBpbmRleCwgaXRlbXMsIGtleSwga2V5UGFydCwga2V5cywgbGVuZ3RoLCBuZXh0SW5kZW50LCBwcmV0dGlmaWVkLCBzdGFydCwgc3RyaW5nLCB2YWx1ZTtcblxuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgIH1cblxuICAgIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIpO1xuXG4gICAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIGxlbmd0aCA9IG1heExlbmd0aCAtIGN1cnJlbnRJbmRlbnQubGVuZ3RoIC0gcmVzZXJ2ZWQ7XG5cbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgIHByZXR0aWZpZWQgPSBzdHJpbmcucmVwbGFjZShzdHJpbmdPckNoYXIsIGZ1bmN0aW9uKG1hdGNoLCBzdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdMaXRlcmFsIHx8IG1hdGNoICsgXCIgXCI7XG4gICAgICB9KTtcbiAgICAgIGlmIChwcmV0dGlmaWVkLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHByZXR0aWZpZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2VyICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IEpTT04ucGFyc2Uoc3RyaW5nKTtcbiAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgbmV4dEluZGVudCA9IGN1cnJlbnRJbmRlbnQgKyBpbmRlbnQ7XG4gICAgICBpdGVtcyA9IFtdO1xuICAgICAgaW5kZXggPSAwO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHN0YXJ0ID0gXCJbXCI7XG4gICAgICAgIGVuZCA9IFwiXVwiO1xuICAgICAgICBsZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKFxuICAgICAgICAgICAgX3N0cmluZ2lmeShvYmpbaW5kZXhdLCBuZXh0SW5kZW50LCBpbmRleCA9PT0gbGVuZ3RoIC0gMSA/IDAgOiAxKSB8fFxuICAgICAgICAgICAgICBcIm51bGxcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gXCJ7XCI7XG4gICAgICAgIGVuZCA9IFwifVwiO1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICAgIGtleVBhcnQgPSBKU09OLnN0cmluZ2lmeShrZXkpICsgXCI6IFwiO1xuICAgICAgICAgIHZhbHVlID0gX3N0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAgbmV4dEluZGVudCxcbiAgICAgICAgICAgIGtleVBhcnQubGVuZ3RoICsgKGluZGV4ID09PSBsZW5ndGggLSAxID8gMCA6IDEpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChrZXlQYXJ0ICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gW3N0YXJ0LCBpbmRlbnQgKyBpdGVtcy5qb2luKFwiLFxcblwiICsgbmV4dEluZGVudCksIGVuZF0uam9pbihcbiAgICAgICAgICBcIlxcblwiICsgY3VycmVudEluZGVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH0pKHBhc3NlZE9iaiwgXCJcIiwgMCk7XG59O1xuXG5mdW5jdGlvbiBzb3J0S2V5c0J5KG9iaiwgcmVmZXJlbmNlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiByZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5JDEgaW4gb2JqKSB7XG4gICAgICAgIGlmIChyZXN1bHRba2V5JDFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXkkMV0gPSBvYmpba2V5JDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmb3JtYXQoc3R5bGUsIHNwYWNlKSB7XG4gICAgaWYgKHNwYWNlID09PSB2b2lkIDApXG4gICAgICAgIHNwYWNlID0gMjtcbiAgICBzdHlsZSA9IHNvcnRLZXlzQnkoc3R5bGUsIHY4LiRyb290KTtcbiAgICBpZiAoc3R5bGUubGF5ZXJzKSB7XG4gICAgICAgIHN0eWxlLmxheWVycyA9IHN0eWxlLmxheWVycy5tYXAoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydEtleXNCeShsYXllciwgdjgubGF5ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25TdHJpbmdpZnlQcmV0dHlDb21wYWN0KHN0eWxlLCB7IGluZGVudDogc3BhY2UgfSk7XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBjb21tb25qc1JlcXVpcmUgKCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHJvbGx1cC1wbHVnaW4tY29tbW9uanMnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBwdW55Y29kZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbihmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSAgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0oY29tbW9uanNHbG9iYWwpKTtcbn0pO1xuXG52YXIgdXRpbCA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxudmFyIGVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHsgcmV0dXJuICcnOyB9XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgcXVlcnlzdHJpbmcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IGRlY29kZTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBlbmNvZGU7XG59KTtcbnZhciBxdWVyeXN0cmluZ18xID0gcXVlcnlzdHJpbmcuZGVjb2RlO1xudmFyIHF1ZXJ5c3RyaW5nXzIgPSBxdWVyeXN0cmluZy5wYXJzZTtcbnZhciBxdWVyeXN0cmluZ18zID0gcXVlcnlzdHJpbmcuZW5jb2RlO1xudmFyIHF1ZXJ5c3RyaW5nXzQgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnk7XG5cbnZhciBwYXJzZSA9IHVybFBhcnNlO1xudmFyIHJlc29sdmUgPSB1cmxSZXNvbHZlO1xudmFyIHJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xudmFyIGZvcm1hdCQxID0gdXJsRm9ybWF0O1xuXG52YXIgVXJsXzEgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9O1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICB7IGhvc3RFbmQgPSBoZWM7IH1cbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICB7IGhvc3RFbmQgPSBoZWM7IH1cbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIHsgaG9zdEVuZCA9IHJlc3QubGVuZ3RoOyB9XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICB7IGNvbnRpbnVlOyB9XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB7IHRoaXMucGF0aG5hbWUgPSByZXN0OyB9XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIHsgb2JqID0gdXJsUGFyc2Uob2JqKTsgfVxuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSB7IHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7IH1cbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHsgcHJvdG9jb2wgKz0gJzonOyB9XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHsgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTsgfVxuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgeyBoYXNoID0gJyMnICsgaGFzaDsgfVxuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgeyBzZWFyY2ggPSAnPycgKyBzZWFyY2g7IH1cblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSB7IHJldHVybiByZWxhdGl2ZTsgfVxuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICB7IHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldOyB9XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSl7IH1cbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgeyByZWxhdGl2ZS5ob3N0ID0gJyc7IH1cbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHsgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJzsgfVxuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSB7IHJlbFBhdGgudW5zaGlmdCgnJyk7IH1cbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHsgcmVsUGF0aC51bnNoaWZ0KCcnKTsgfVxuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSB7IHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDsgfVxuICAgICAgZWxzZSB7IHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7IH1cbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSB7IHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0OyB9XG4gICAgICAgIGVsc2UgeyByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7IH1cbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSB7IHNyY1BhdGggPSBbXTsgfVxuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB7IHRoaXMuaG9zdG5hbWUgPSBob3N0OyB9XG59O1xuXG52YXIgdXJsID0ge1xuXHRwYXJzZTogcGFyc2UsXG5cdHJlc29sdmU6IHJlc29sdmUsXG5cdHJlc29sdmVPYmplY3Q6IHJlc29sdmVPYmplY3QsXG5cdGZvcm1hdDogZm9ybWF0JDEsXG5cdFVybDogVXJsXzFcbn07XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5UmVmZXJlbmNlKHByb3BlcnR5TmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdjgubGF5b3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2OFt2OC5sYXlvdXRbaV1dKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjhbdjgubGF5b3V0W2ldXVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHY4LnBhaW50Lmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgZm9yICh2YXIga2V5JDEgaW4gdjhbdjgucGFpbnRbaSQxXV0pIHtcbiAgICAgICAgICAgIGlmIChrZXkkMSA9PT0gcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY4W3Y4LnBhaW50W2kkMV1dW2tleSQxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVhY2hTb3VyY2Uoc3R5bGUsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgayBpbiBzdHlsZS5zb3VyY2VzKSB7XG4gICAgICAgIGNhbGxiYWNrKHN0eWxlLnNvdXJjZXNba10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVhY2hMYXllcihzdHlsZSwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0eWxlLmxheWVyczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGxheWVyID0gbGlzdFtpXTtcbiAgICAgICAgY2FsbGJhY2sobGF5ZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVhY2hQcm9wZXJ0eShzdHlsZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBpbm5lcihsYXllciwgcHJvcGVydHlUeXBlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gbGF5ZXJbcHJvcGVydHlUeXBlXTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgICAgICBsYXllci5pZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlUeXBlLFxuICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wZXJ0aWVzW2tleV0sXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBnZXRQcm9wZXJ0eVJlZmVyZW5jZShrZXkpLFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1trZXldID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBhaW50KSB7XG4gICAgICAgICAgICBpbm5lcihsYXllciwgJ3BhaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubGF5b3V0KSB7XG4gICAgICAgICAgICBpbm5lcihsYXllciwgJ2xheW91dCcpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGVhY2hMYXlvdXQobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgayBpbiBsYXllcikge1xuICAgICAgICBpZiAoay5pbmRleE9mKCdsYXlvdXQnKSA9PT0gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobGF5ZXJba10sIGspO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZWFjaFBhaW50KGxheWVyLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGsgaW4gbGF5ZXIpIHtcbiAgICAgICAgaWYgKGsuaW5kZXhPZigncGFpbnQnKSA9PT0gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobGF5ZXJba10sIGspO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0YW50KHN0eWxlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnQCcpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVDb25zdGFudChzdHlsZSwgc3R5bGUuY29uc3RhbnRzW3ZhbHVlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZS5zdG9wcyk7XG59XG5mdW5jdGlvbiByZW5hbWVQcm9wZXJ0eShvYmosIGZyb20sIHRvKSB7XG4gICAgb2JqW3RvXSA9IG9ialtmcm9tXTtcbiAgICBkZWxldGUgb2JqW2Zyb21dO1xufVxuZnVuY3Rpb24gbWlncmF0ZVRvVjggKHN0eWxlKSB7XG4gICAgc3R5bGUudmVyc2lvbiA9IDg7XG4gICAgZWFjaFNvdXJjZShzdHlsZSwgZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLnR5cGUgPT09ICd2aWRlbycgJiYgc291cmNlLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShzb3VyY2UsICd1cmwnLCAndXJscycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgc291cmNlLmNvb3JkaW5hdGVzLmZvckVhY2goZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgZWFjaExheW91dChsYXllciwgZnVuY3Rpb24gKGxheW91dCkge1xuICAgICAgICAgICAgaWYgKGxheW91dFsnc3ltYm9sLW1pbi1kaXN0YW5jZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShsYXlvdXQsICdzeW1ib2wtbWluLWRpc3RhbmNlJywgJ3N5bWJvbC1zcGFjaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoUGFpbnQobGF5ZXIsIGZ1bmN0aW9uIChwYWludCkge1xuICAgICAgICAgICAgaWYgKHBhaW50WydiYWNrZ3JvdW5kLWltYWdlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmFtZVByb3BlcnR5KHBhaW50LCAnYmFja2dyb3VuZC1pbWFnZScsICdiYWNrZ3JvdW5kLXBhdHRlcm4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWludFsnbGluZS1pbWFnZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShwYWludCwgJ2xpbmUtaW1hZ2UnLCAnbGluZS1wYXR0ZXJuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFpbnRbJ2ZpbGwtaW1hZ2UnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuYW1lUHJvcGVydHkocGFpbnQsICdmaWxsLWltYWdlJywgJ2ZpbGwtcGF0dGVybicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBlYWNoUHJvcGVydHkoc3R5bGUsIHtcbiAgICAgICAgcGFpbnQ6IHRydWUsXG4gICAgICAgIGxheW91dDogdHJ1ZVxuICAgIH0sIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgdmFsdWUgPSByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHByb3BlcnR5LnZhbHVlKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5zdG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgc3RvcFsxXSA9IHJlc29sdmVDb25zdGFudChzdHlsZSwgc3RvcFsxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wZXJ0eS5zZXQodmFsdWUpO1xuICAgIH0pO1xuICAgIGRlbGV0ZSBzdHlsZS5jb25zdGFudHM7XG4gICAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgZWFjaExheW91dChsYXllciwgZnVuY3Rpb24gKGxheW91dCkge1xuICAgICAgICAgICAgZGVsZXRlIGxheW91dFsndGV4dC1tYXgtc2l6ZSddO1xuICAgICAgICAgICAgZGVsZXRlIGxheW91dFsnaWNvbi1tYXgtc2l6ZSddO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaFBhaW50KGxheWVyLCBmdW5jdGlvbiAocGFpbnQpIHtcbiAgICAgICAgICAgIGlmIChwYWludFsndGV4dC1zaXplJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLmxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5sYXlvdXQgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGF5ZXIubGF5b3V0Wyd0ZXh0LXNpemUnXSA9IHBhaW50Wyd0ZXh0LXNpemUnXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFpbnRbJ3RleHQtc2l6ZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhaW50WydpY29uLXNpemUnXSkge1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXIubGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmxheW91dCA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXllci5sYXlvdXRbJ2ljb24tc2l6ZSddID0gcGFpbnRbJ2ljb24tc2l6ZSddO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYWludFsnaWNvbi1zaXplJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG1pZ3JhdGVGb250c3RhY2tVUkwoaW5wdXQpIHtcbiAgICAgICAgdmFyIGlucHV0UGFyc2VkID0gdXJsLnBhcnNlKGlucHV0KTtcbiAgICAgICAgdmFyIGlucHV0UGF0aG5hbWVQYXJ0cyA9IGlucHV0UGFyc2VkLnBhdGhuYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChpbnB1dFBhcnNlZC5wcm90b2NvbCAhPT0gJ21hcGJveDonKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRQYXJzZWQuaG9zdG5hbWUgPT09ICdmb250c3RhY2snKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21hcGJveDovL2ZvbnRzL21hcGJveC97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZic7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRQYXJzZWQuaG9zdG5hbWUgPT09ICdmb250cycpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFwYm94Oi8vZm9udHMvJyArIGlucHV0UGF0aG5hbWVQYXJ0c1syXSArICcve2ZvbnRzdGFja30ve3JhbmdlfS5wYmYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZS5nbHlwaHMpIHtcbiAgICAgICAgc3R5bGUuZ2x5cGhzID0gbWlncmF0ZUZvbnRzdGFja1VSTChzdHlsZS5nbHlwaHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtaWdyYXRlRm9udFN0YWNrKGZvbnQpIHtcbiAgICAgICAgZnVuY3Rpb24gc3BsaXRBbmRUcmltKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzLnRyaW0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZvbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9udDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGxpdEFuZFRyaW0oZm9udCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb250LnN0b3BzLmZvckVhY2goZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgICAgICAgICBzdG9wWzFdID0gc3BsaXRBbmRUcmltKHN0b3BbMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm9udDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBmb250IHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgZWFjaExheW91dChsYXllciwgZnVuY3Rpb24gKGxheW91dCkge1xuICAgICAgICAgICAgaWYgKGxheW91dFsndGV4dC1mb250J10pIHtcbiAgICAgICAgICAgICAgICBsYXlvdXRbJ3RleHQtZm9udCddID0gbWlncmF0ZUZvbnRTdGFjayhsYXlvdXRbJ3RleHQtZm9udCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGZpcnN0U3ltYm9sTGF5ZXIgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdHlsZS5sYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGxheWVyID0gc3R5bGUubGF5ZXJzW2ldO1xuICAgICAgICBpZiAobGF5ZXIudHlwZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIGZpcnN0U3ltYm9sTGF5ZXIgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzeW1ib2xMYXllcnMgPSBzdHlsZS5sYXllcnMuc3BsaWNlKGZpcnN0U3ltYm9sTGF5ZXIpO1xuICAgIHN5bWJvbExheWVycy5yZXZlcnNlKCk7XG4gICAgc3R5bGUubGF5ZXJzID0gc3R5bGUubGF5ZXJzLmNvbmNhdChzeW1ib2xMYXllcnMpO1xuICAgIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kIChvdXRwdXQpIHtcbiAgICB2YXIgaW5wdXRzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsZW4tLSA+IDApXG4gICAgICAgIGlucHV0c1tsZW5dID0gYXJndW1lbnRzW2xlbiArIDFdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gaW5wdXRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgaW5wdXQgPSBsaXN0W2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIGlucHV0KSB7XG4gICAgICAgICAgICBvdXRwdXRba10gPSBpbnB1dFtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG52YXIgUGFyc2luZ0Vycm9yID0gZnVuY3Rpb24gKEVycm9yKSB7XG4gICAgZnVuY3Rpb24gUGFyc2luZ0Vycm9yKGtleSwgbWVzc2FnZSkge1xuICAgICAgICBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgaWYgKEVycm9yKVxuICAgICAgICBQYXJzaW5nRXJyb3IuX19wcm90b19fID0gRXJyb3I7XG4gICAgUGFyc2luZ0Vycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IgJiYgRXJyb3IucHJvdG90eXBlKTtcbiAgICBQYXJzaW5nRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyc2luZ0Vycm9yO1xuICAgIHJldHVybiBQYXJzaW5nRXJyb3I7XG59KEVycm9yKTtcblxudmFyIFNjb3BlID0gZnVuY3Rpb24gU2NvcGUocGFyZW50LCBiaW5kaW5ncykge1xuICAgIGlmIChiaW5kaW5ncyA9PT0gdm9pZCAwKVxuICAgICAgICBiaW5kaW5ncyA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGJpbmRpbmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmVmID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIG5hbWUgPSByZWZbMF07XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcmVmWzFdO1xuICAgICAgICB0aGlzLmJpbmRpbmdzW25hbWVdID0gZXhwcmVzc2lvbjtcbiAgICB9XG59O1xuU2NvcGUucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChiaW5kaW5ncykge1xuICAgIHJldHVybiBuZXcgU2NvcGUodGhpcywgYmluZGluZ3MpO1xufTtcblNjb3BlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIGlmICh0aGlzLmJpbmRpbmdzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldChuYW1lKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnIG5vdCBmb3VuZCBpbiBzY29wZS4nKTtcbn07XG5TY29wZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICBpZiAodGhpcy5iaW5kaW5nc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuaGFzKG5hbWUpIDogZmFsc2U7XG59O1xuXG52YXIgTnVsbFR5cGUgPSB7IGtpbmQ6ICdudWxsJyB9O1xudmFyIE51bWJlclR5cGUgPSB7IGtpbmQ6ICdudW1iZXInIH07XG52YXIgU3RyaW5nVHlwZSA9IHsga2luZDogJ3N0cmluZycgfTtcbnZhciBCb29sZWFuVHlwZSA9IHsga2luZDogJ2Jvb2xlYW4nIH07XG52YXIgQ29sb3JUeXBlID0geyBraW5kOiAnY29sb3InIH07XG52YXIgT2JqZWN0VHlwZSA9IHsga2luZDogJ29iamVjdCcgfTtcbnZhciBWYWx1ZVR5cGUgPSB7IGtpbmQ6ICd2YWx1ZScgfTtcbnZhciBFcnJvclR5cGUgPSB7IGtpbmQ6ICdlcnJvcicgfTtcbnZhciBDb2xsYXRvclR5cGUgPSB7IGtpbmQ6ICdjb2xsYXRvcicgfTtcbnZhciBGb3JtYXR0ZWRUeXBlID0geyBraW5kOiAnZm9ybWF0dGVkJyB9O1xudmFyIFJlc29sdmVkSW1hZ2VUeXBlID0geyBraW5kOiAncmVzb2x2ZWRJbWFnZScgfTtcbmZ1bmN0aW9uIGFycmF5KGl0ZW1UeXBlLCBOKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ2FycmF5JyxcbiAgICAgICAgaXRlbVR5cGU6IGl0ZW1UeXBlLFxuICAgICAgICBOOiBOXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHR5cGUpIHtcbiAgICBpZiAodHlwZS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgICAgIHZhciBpdGVtVHlwZSA9IHRvU3RyaW5nKHR5cGUuaXRlbVR5cGUpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHR5cGUuTiA9PT0gJ251bWJlcicgPyAnYXJyYXk8JyArIGl0ZW1UeXBlICsgJywgJyArIHR5cGUuTiArICc+JyA6IHR5cGUuaXRlbVR5cGUua2luZCA9PT0gJ3ZhbHVlJyA/ICdhcnJheScgOiAnYXJyYXk8JyArIGl0ZW1UeXBlICsgJz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0eXBlLmtpbmQ7XG4gICAgfVxufVxudmFyIHZhbHVlTWVtYmVyVHlwZXMgPSBbXG4gICAgTnVsbFR5cGUsXG4gICAgTnVtYmVyVHlwZSxcbiAgICBTdHJpbmdUeXBlLFxuICAgIEJvb2xlYW5UeXBlLFxuICAgIENvbG9yVHlwZSxcbiAgICBGb3JtYXR0ZWRUeXBlLFxuICAgIE9iamVjdFR5cGUsXG4gICAgYXJyYXkoVmFsdWVUeXBlKSxcbiAgICBSZXNvbHZlZEltYWdlVHlwZVxuXTtcbmZ1bmN0aW9uIGNoZWNrU3VidHlwZShleHBlY3RlZCwgdCkge1xuICAgIGlmICh0LmtpbmQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZC5raW5kID09PSAnYXJyYXknKSB7XG4gICAgICAgIGlmICh0LmtpbmQgPT09ICdhcnJheScgJiYgKHQuTiA9PT0gMCAmJiB0Lml0ZW1UeXBlLmtpbmQgPT09ICd2YWx1ZScgfHwgIWNoZWNrU3VidHlwZShleHBlY3RlZC5pdGVtVHlwZSwgdC5pdGVtVHlwZSkpICYmICh0eXBlb2YgZXhwZWN0ZWQuTiAhPT0gJ251bWJlcicgfHwgZXhwZWN0ZWQuTiA9PT0gdC5OKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09IHQua2luZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB2YWx1ZU1lbWJlclR5cGVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG1lbWJlclR5cGUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKCFjaGVja1N1YnR5cGUobWVtYmVyVHlwZSwgdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ0V4cGVjdGVkICcgKyB0b1N0cmluZyhleHBlY3RlZCkgKyAnIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodCkgKyAnIGluc3RlYWQuJztcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUeXBlKHByb3ZpZGVkLCBhbGxvd2VkVHlwZXMpIHtcbiAgICByZXR1cm4gYWxsb3dlZFR5cGVzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQua2luZCA9PT0gcHJvdmlkZWQua2luZDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWROYXRpdmVUeXBlKHByb3ZpZGVkLCBhbGxvd2VkVHlwZXMpIHtcbiAgICByZXR1cm4gYWxsb3dlZFR5cGVzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgPT09ICdudWxsJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkID09PSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHByb3ZpZGVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkICYmICFBcnJheS5pc0FycmF5KHByb3ZpZGVkKSAmJiB0eXBlb2YgcHJvdmlkZWQgPT09ICdvYmplY3QnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHQgPT09IHR5cGVvZiBwcm92aWRlZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG52YXIgY3NzY29sb3JwYXJzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL2Nzcy1jb2xvci1wYXJzZXItanNcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuLy8gSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yL1xudmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICBcInRyYW5zcGFyZW50XCI6IFswLDAsMCwwXSwgXCJhbGljZWJsdWVcIjogWzI0MCwyNDgsMjU1LDFdLFxuICBcImFudGlxdWV3aGl0ZVwiOiBbMjUwLDIzNSwyMTUsMV0sIFwiYXF1YVwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImFxdWFtYXJpbmVcIjogWzEyNywyNTUsMjEyLDFdLCBcImF6dXJlXCI6IFsyNDAsMjU1LDI1NSwxXSxcbiAgXCJiZWlnZVwiOiBbMjQ1LDI0NSwyMjAsMV0sIFwiYmlzcXVlXCI6IFsyNTUsMjI4LDE5NiwxXSxcbiAgXCJibGFja1wiOiBbMCwwLDAsMV0sIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwyMzUsMjA1LDFdLFxuICBcImJsdWVcIjogWzAsMCwyNTUsMV0sIFwiYmx1ZXZpb2xldFwiOiBbMTM4LDQzLDIyNiwxXSxcbiAgXCJicm93blwiOiBbMTY1LDQyLDQyLDFdLCBcImJ1cmx5d29vZFwiOiBbMjIyLDE4NCwxMzUsMV0sXG4gIFwiY2FkZXRibHVlXCI6IFs5NSwxNTgsMTYwLDFdLCBcImNoYXJ0cmV1c2VcIjogWzEyNywyNTUsMCwxXSxcbiAgXCJjaG9jb2xhdGVcIjogWzIxMCwxMDUsMzAsMV0sIFwiY29yYWxcIjogWzI1NSwxMjcsODAsMV0sXG4gIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwxNDksMjM3LDFdLCBcImNvcm5zaWxrXCI6IFsyNTUsMjQ4LDIyMCwxXSxcbiAgXCJjcmltc29uXCI6IFsyMjAsMjAsNjAsMV0sIFwiY3lhblwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImRhcmtibHVlXCI6IFswLDAsMTM5LDFdLCBcImRhcmtjeWFuXCI6IFswLDEzOSwxMzksMV0sXG4gIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LDEzNCwxMSwxXSwgXCJkYXJrZ3JheVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2dyZWVuXCI6IFswLDEwMCwwLDFdLCBcImRhcmtncmV5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJra2hha2lcIjogWzE4OSwxODMsMTA3LDFdLCBcImRhcmttYWdlbnRhXCI6IFsxMzksMCwxMzksMV0sXG4gIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LDEwNyw0NywxXSwgXCJkYXJrb3JhbmdlXCI6IFsyNTUsMTQwLDAsMV0sXG4gIFwiZGFya29yY2hpZFwiOiBbMTUzLDUwLDIwNCwxXSwgXCJkYXJrcmVkXCI6IFsxMzksMCwwLDFdLFxuICBcImRhcmtzYWxtb25cIjogWzIzMywxNTAsMTIyLDFdLCBcImRhcmtzZWFncmVlblwiOiBbMTQzLDE4OCwxNDMsMV0sXG4gIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsNjEsMTM5LDFdLCBcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LDc5LDc5LDFdLFxuICBcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LDc5LDc5LDFdLCBcImRhcmt0dXJxdW9pc2VcIjogWzAsMjA2LDIwOSwxXSxcbiAgXCJkYXJrdmlvbGV0XCI6IFsxNDgsMCwyMTEsMV0sIFwiZGVlcHBpbmtcIjogWzI1NSwyMCwxNDcsMV0sXG4gIFwiZGVlcHNreWJsdWVcIjogWzAsMTkxLDI1NSwxXSwgXCJkaW1ncmF5XCI6IFsxMDUsMTA1LDEwNSwxXSxcbiAgXCJkaW1ncmV5XCI6IFsxMDUsMTA1LDEwNSwxXSwgXCJkb2RnZXJibHVlXCI6IFszMCwxNDQsMjU1LDFdLFxuICBcImZpcmVicmlja1wiOiBbMTc4LDM0LDM0LDFdLCBcImZsb3JhbHdoaXRlXCI6IFsyNTUsMjUwLDI0MCwxXSxcbiAgXCJmb3Jlc3RncmVlblwiOiBbMzQsMTM5LDM0LDFdLCBcImZ1Y2hzaWFcIjogWzI1NSwwLDI1NSwxXSxcbiAgXCJnYWluc2Jvcm9cIjogWzIyMCwyMjAsMjIwLDFdLCBcImdob3N0d2hpdGVcIjogWzI0OCwyNDgsMjU1LDFdLFxuICBcImdvbGRcIjogWzI1NSwyMTUsMCwxXSwgXCJnb2xkZW5yb2RcIjogWzIxOCwxNjUsMzIsMV0sXG4gIFwiZ3JheVwiOiBbMTI4LDEyOCwxMjgsMV0sIFwiZ3JlZW5cIjogWzAsMTI4LDAsMV0sXG4gIFwiZ3JlZW55ZWxsb3dcIjogWzE3MywyNTUsNDcsMV0sIFwiZ3JleVwiOiBbMTI4LDEyOCwxMjgsMV0sXG4gIFwiaG9uZXlkZXdcIjogWzI0MCwyNTUsMjQwLDFdLCBcImhvdHBpbmtcIjogWzI1NSwxMDUsMTgwLDFdLFxuICBcImluZGlhbnJlZFwiOiBbMjA1LDkyLDkyLDFdLCBcImluZGlnb1wiOiBbNzUsMCwxMzAsMV0sXG4gIFwiaXZvcnlcIjogWzI1NSwyNTUsMjQwLDFdLCBcImtoYWtpXCI6IFsyNDAsMjMwLDE0MCwxXSxcbiAgXCJsYXZlbmRlclwiOiBbMjMwLDIzMCwyNTAsMV0sIFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LDI0MCwyNDUsMV0sXG4gIFwibGF3bmdyZWVuXCI6IFsxMjQsMjUyLDAsMV0sIFwibGVtb25jaGlmZm9uXCI6IFsyNTUsMjUwLDIwNSwxXSxcbiAgXCJsaWdodGJsdWVcIjogWzE3MywyMTYsMjMwLDFdLCBcImxpZ2h0Y29yYWxcIjogWzI0MCwxMjgsMTI4LDFdLFxuICBcImxpZ2h0Y3lhblwiOiBbMjI0LDI1NSwyNTUsMV0sIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwyNTAsMjEwLDFdLFxuICBcImxpZ2h0Z3JheVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRncmVlblwiOiBbMTQ0LDIzOCwxNDQsMV0sXG4gIFwibGlnaHRncmV5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodHBpbmtcIjogWzI1NSwxODIsMTkzLDFdLFxuICBcImxpZ2h0c2FsbW9uXCI6IFsyNTUsMTYwLDEyMiwxXSwgXCJsaWdodHNlYWdyZWVuXCI6IFszMiwxNzgsMTcwLDFdLFxuICBcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LDIwNiwyNTAsMV0sIFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwxMzYsMTUzLDFdLFxuICBcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksMTM2LDE1MywxXSwgXCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LDE5NiwyMjIsMV0sXG4gIFwibGlnaHR5ZWxsb3dcIjogWzI1NSwyNTUsMjI0LDFdLCBcImxpbWVcIjogWzAsMjU1LDAsMV0sXG4gIFwibGltZWdyZWVuXCI6IFs1MCwyMDUsNTAsMV0sIFwibGluZW5cIjogWzI1MCwyNDAsMjMwLDFdLFxuICBcIm1hZ2VudGFcIjogWzI1NSwwLDI1NSwxXSwgXCJtYXJvb25cIjogWzEyOCwwLDAsMV0sXG4gIFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLDIwNSwxNzAsMV0sIFwibWVkaXVtYmx1ZVwiOiBbMCwwLDIwNSwxXSxcbiAgXCJtZWRpdW1vcmNoaWRcIjogWzE4Niw4NSwyMTEsMV0sIFwibWVkaXVtcHVycGxlXCI6IFsxNDcsMTEyLDIxOSwxXSxcbiAgXCJtZWRpdW1zZWFncmVlblwiOiBbNjAsMTc5LDExMywxXSwgXCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywxMDQsMjM4LDFdLFxuICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLDI1MCwxNTQsMV0sIFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwyMDksMjA0LDFdLFxuICBcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LDIxLDEzMywxXSwgXCJtaWRuaWdodGJsdWVcIjogWzI1LDI1LDExMiwxXSxcbiAgXCJtaW50Y3JlYW1cIjogWzI0NSwyNTUsMjUwLDFdLCBcIm1pc3R5cm9zZVwiOiBbMjU1LDIyOCwyMjUsMV0sXG4gIFwibW9jY2FzaW5cIjogWzI1NSwyMjgsMTgxLDFdLCBcIm5hdmFqb3doaXRlXCI6IFsyNTUsMjIyLDE3MywxXSxcbiAgXCJuYXZ5XCI6IFswLDAsMTI4LDFdLCBcIm9sZGxhY2VcIjogWzI1MywyNDUsMjMwLDFdLFxuICBcIm9saXZlXCI6IFsxMjgsMTI4LDAsMV0sIFwib2xpdmVkcmFiXCI6IFsxMDcsMTQyLDM1LDFdLFxuICBcIm9yYW5nZVwiOiBbMjU1LDE2NSwwLDFdLCBcIm9yYW5nZXJlZFwiOiBbMjU1LDY5LDAsMV0sXG4gIFwib3JjaGlkXCI6IFsyMTgsMTEyLDIxNCwxXSwgXCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsMjMyLDE3MCwxXSxcbiAgXCJwYWxlZ3JlZW5cIjogWzE1MiwyNTEsMTUyLDFdLCBcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwyMzgsMjM4LDFdLFxuICBcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwxMTIsMTQ3LDFdLCBcInBhcGF5YXdoaXBcIjogWzI1NSwyMzksMjEzLDFdLFxuICBcInBlYWNocHVmZlwiOiBbMjU1LDIxOCwxODUsMV0sIFwicGVydVwiOiBbMjA1LDEzMyw2MywxXSxcbiAgXCJwaW5rXCI6IFsyNTUsMTkyLDIwMywxXSwgXCJwbHVtXCI6IFsyMjEsMTYwLDIyMSwxXSxcbiAgXCJwb3dkZXJibHVlXCI6IFsxNzYsMjI0LDIzMCwxXSwgXCJwdXJwbGVcIjogWzEyOCwwLDEyOCwxXSxcbiAgXCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsNTEsMTUzLDFdLFxuICBcInJlZFwiOiBbMjU1LDAsMCwxXSwgXCJyb3N5YnJvd25cIjogWzE4OCwxNDMsMTQzLDFdLFxuICBcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNSwxXSwgXCJzYWRkbGVicm93blwiOiBbMTM5LDY5LDE5LDFdLFxuICBcInNhbG1vblwiOiBbMjUwLDEyOCwxMTQsMV0sIFwic2FuZHlicm93blwiOiBbMjQ0LDE2NCw5NiwxXSxcbiAgXCJzZWFncmVlblwiOiBbNDYsMTM5LDg3LDFdLCBcInNlYXNoZWxsXCI6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgXCJzaWVubmFcIjogWzE2MCw4Miw0NSwxXSwgXCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyLDFdLFxuICBcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1LDFdLCBcInNsYXRlYmx1ZVwiOiBbMTA2LDkwLDIwNSwxXSxcbiAgXCJzbGF0ZWdyYXlcIjogWzExMiwxMjgsMTQ0LDFdLCBcInNsYXRlZ3JleVwiOiBbMTEyLDEyOCwxNDQsMV0sXG4gIFwic25vd1wiOiBbMjU1LDI1MCwyNTAsMV0sIFwic3ByaW5nZ3JlZW5cIjogWzAsMjU1LDEyNywxXSxcbiAgXCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODAsMV0sIFwidGFuXCI6IFsyMTAsMTgwLDE0MCwxXSxcbiAgXCJ0ZWFsXCI6IFswLDEyOCwxMjgsMV0sIFwidGhpc3RsZVwiOiBbMjE2LDE5MSwyMTYsMV0sXG4gIFwidG9tYXRvXCI6IFsyNTUsOTksNzEsMV0sIFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4LDFdLFxuICBcInZpb2xldFwiOiBbMjM4LDEzMCwyMzgsMV0sIFwid2hlYXRcIjogWzI0NSwyMjIsMTc5LDFdLFxuICBcIndoaXRlXCI6IFsyNTUsMjU1LDI1NSwxXSwgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgXCJ5ZWxsb3dcIjogWzI1NSwyNTUsMCwxXSwgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MCwxXX07XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19ieXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfaW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgeyByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTsgfVxuICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgeyByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7IH1cbiAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHtcbiAgaWYgKGggPCAwKSB7IGggKz0gMTsgfVxuICBlbHNlIGlmIChoID4gMSkgeyBoIC09IDE7IH1cblxuICBpZiAoaCAqIDYgPCAxKSB7IHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2OyB9XG4gIGlmIChoICogMiA8IDEpIHsgcmV0dXJuIG0yOyB9XG4gIGlmIChoICogMyA8IDIpIHsgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjsgfVxuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1NTQ29sb3IoY3NzX3N0cikge1xuICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHsgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgfSAgLy8gZHVwLlxuXG4gIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkgeyByZXR1cm4gbnVsbDsgfSAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKChpdiAmIDB4ZjAwKSA+PiA0KSB8ICgoaXYgJiAweGYwMCkgPj4gOCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZjApIHwgKChpdiAmIDB4ZjApID4+IDQpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXG4gICAgICAgICAgICAgIDFdO1xuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkgeyByZXR1cm4gbnVsbDsgfSAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4gW3BhcnNlX2Nzc19pbnQocGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1sxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMl0pLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICAgICAgcmV0dXJuIFtjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgrMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG50cnkgeyBleHBvcnRzLnBhcnNlQ1NTQ29sb3IgPSBwYXJzZUNTU0NvbG9yOyB9IGNhdGNoKGUpIHsgfVxufSk7XG52YXIgY3NzY29sb3JwYXJzZXJfMSA9IGNzc2NvbG9ycGFyc2VyLnBhcnNlQ1NTQ29sb3I7XG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uIENvbG9yKHIsIGcsIGIsIGEpIHtcbiAgICBpZiAoYSA9PT0gdm9pZCAwKVxuICAgICAgICBhID0gMTtcbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMuZyA9IGc7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmEgPSBhO1xufTtcbkNvbG9yLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHJnYmEgPSBjc3Njb2xvcnBhcnNlcl8xKGlucHV0KTtcbiAgICBpZiAoIXJnYmEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb2xvcihyZ2JhWzBdIC8gMjU1ICogcmdiYVszXSwgcmdiYVsxXSAvIDI1NSAqIHJnYmFbM10sIHJnYmFbMl0gLyAyNTUgKiByZ2JhWzNdLCByZ2JhWzNdKTtcbn07XG5Db2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgcmVmID0gdGhpcy50b0FycmF5KCk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgdmFyIGEgPSByZWZbM107XG4gICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKHIpICsgJywnICsgTWF0aC5yb3VuZChnKSArICcsJyArIE1hdGgucm91bmQoYikgKyAnLCcgKyBhICsgJyknO1xufTtcbkNvbG9yLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgciA9IHJlZi5yO1xuICAgIHZhciBnID0gcmVmLmc7XG4gICAgdmFyIGIgPSByZWYuYjtcbiAgICB2YXIgYSA9IHJlZi5hO1xuICAgIHJldHVybiBhID09PSAwID8gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgXSA6IFtcbiAgICAgICAgciAqIDI1NSAvIGEsXG4gICAgICAgIGcgKiAyNTUgLyBhLFxuICAgICAgICBiICogMjU1IC8gYSxcbiAgICAgICAgYVxuICAgIF07XG59O1xuQ29sb3IuYmxhY2sgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7XG5Db2xvci53aGl0ZSA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKTtcbkNvbG9yLnRyYW5zcGFyZW50ID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuQ29sb3IucmVkID0gbmV3IENvbG9yKDEsIDAsIDAsIDEpO1xuXG52YXIgQ29sbGF0b3IgPSBmdW5jdGlvbiBDb2xsYXRvcihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSkge1xuICAgIGlmIChjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSBkaWFjcml0aWNTZW5zaXRpdmUgPyAndmFyaWFudCcgOiAnY2FzZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZW5zaXRpdml0eSA9IGRpYWNyaXRpY1NlbnNpdGl2ZSA/ICdhY2NlbnQnIDogJ2Jhc2UnO1xuICAgIH1cbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB0aGlzLmNvbGxhdG9yID0gbmV3IEludGwuQ29sbGF0b3IodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZSA6IFtdLCB7XG4gICAgICAgIHNlbnNpdGl2aXR5OiB0aGlzLnNlbnNpdGl2aXR5LFxuICAgICAgICB1c2FnZTogJ3NlYXJjaCdcbiAgICB9KTtcbn07XG5Db2xsYXRvci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUobGhzLCByaHMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsYXRvci5jb21wYXJlKGxocywgcmhzKTtcbn07XG5Db2xsYXRvci5wcm90b3R5cGUucmVzb2x2ZWRMb2NhbGUgPSBmdW5jdGlvbiByZXNvbHZlZExvY2FsZSgpIHtcbiAgICByZXR1cm4gbmV3IEludGwuQ29sbGF0b3IodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZSA6IFtdKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG59O1xuXG52YXIgRm9ybWF0dGVkU2VjdGlvbiA9IGZ1bmN0aW9uIEZvcm1hdHRlZFNlY3Rpb24odGV4dCwgaW1hZ2UsIHNjYWxlLCBmb250U3RhY2ssIHRleHRDb2xvcikge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLmZvbnRTdGFjayA9IGZvbnRTdGFjaztcbiAgICB0aGlzLnRleHRDb2xvciA9IHRleHRDb2xvcjtcbn07XG52YXIgRm9ybWF0dGVkID0gZnVuY3Rpb24gRm9ybWF0dGVkKHNlY3Rpb25zKSB7XG4gICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xufTtcbkZvcm1hdHRlZC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyh1bmZvcm1hdHRlZCkge1xuICAgIHJldHVybiBuZXcgRm9ybWF0dGVkKFtuZXcgRm9ybWF0dGVkU2VjdGlvbih1bmZvcm1hdHRlZCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCldKTtcbn07XG5Gb3JtYXR0ZWQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLnNlY3Rpb25zLnNvbWUoZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24udGV4dC5sZW5ndGggIT09IDAgfHwgc2VjdGlvbi5pbWFnZSAmJiBzZWN0aW9uLmltYWdlLm5hbWUubGVuZ3RoICE9PSAwO1xuICAgIH0pO1xufTtcbkZvcm1hdHRlZC5mYWN0b3J5ID0gZnVuY3Rpb24gZmFjdG9yeSh0ZXh0KSB7XG4gICAgaWYgKHRleHQgaW5zdGFuY2VvZiBGb3JtYXR0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlZC5mcm9tU3RyaW5nKHRleHQpO1xuICAgIH1cbn07XG5Gb3JtYXR0ZWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBzZWN0aW9uLnRleHQ7XG4gICAgfSkuam9pbignJyk7XG59O1xuRm9ybWF0dGVkLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5zZWN0aW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBsaXN0W2ldO1xuICAgICAgICBpZiAoc2VjdGlvbi5pbWFnZSkge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKFtcbiAgICAgICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgIHNlY3Rpb24uaW1hZ2UubmFtZVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkLnB1c2goc2VjdGlvbi50ZXh0KTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHNlY3Rpb24uZm9udFN0YWNrKSB7XG4gICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWZvbnQnXSA9IFtcbiAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5mb250U3RhY2suc3BsaXQoJywnKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkge1xuICAgICAgICAgICAgb3B0aW9uc1snZm9udC1zY2FsZSddID0gc2VjdGlvbi5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbi50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ3RleHQtY29sb3InXSA9IFsncmdiYSddLmNvbmNhdChzZWN0aW9uLnRleHRDb2xvci50b0FycmF5KCkpO1xuICAgICAgICB9XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaChvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG52YXIgUmVzb2x2ZWRJbWFnZSA9IGZ1bmN0aW9uIFJlc29sdmVkSW1hZ2Uob3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLmF2YWlsYWJsZSA9IG9wdGlvbnMuYXZhaWxhYmxlO1xufTtcblJlc29sdmVkSW1hZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbn07XG5SZXNvbHZlZEltYWdlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVzb2x2ZWRJbWFnZSh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGF2YWlsYWJsZTogZmFsc2VcbiAgICB9KTtcbn07XG5SZXNvbHZlZEltYWdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgdGhpcy5uYW1lXG4gICAgXTtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUkdCQShyLCBnLCBiLCBhKSB7XG4gICAgaWYgKCEodHlwZW9mIHIgPT09ICdudW1iZXInICYmIHIgPj0gMCAmJiByIDw9IDI1NSAmJiB0eXBlb2YgZyA9PT0gJ251bWJlcicgJiYgZyA+PSAwICYmIGcgPD0gMjU1ICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiBiID49IDAgJiYgYiA8PSAyNTUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhID09PSAnbnVtYmVyJyA/IFtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGFcbiAgICAgICAgXSA6IFtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgYlxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gJ0ludmFsaWQgcmdiYSB2YWx1ZSBbJyArIHZhbHVlLmpvaW4oJywgJykgKyAnXTogXFwnclxcJywgXFwnZ1xcJywgYW5kIFxcJ2JcXCcgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS4nO1xuICAgIH1cbiAgICBpZiAoISh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGEgPT09ICdudW1iZXInICYmIGEgPj0gMCAmJiBhIDw9IDEpKSB7XG4gICAgICAgIHJldHVybiAnSW52YWxpZCByZ2JhIHZhbHVlIFsnICsgW1xuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYVxuICAgICAgICBdLmpvaW4oJywgJykgKyAnXTogXFwnYVxcJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS4nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzVmFsdWUobWl4ZWQpIHtcbiAgICBpZiAobWl4ZWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgQ29sbGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIEZvcm1hdHRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWl4ZWQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbWl4ZWQ7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoIWlzVmFsdWUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtaXhlZCkge1xuICAgICAgICAgICAgaWYgKCFpc1ZhbHVlKG1peGVkW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0eXBlT2YodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE51bGxUeXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nVHlwZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuVHlwZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlclR5cGU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICAgIHJldHVybiBDb2xvclR5cGU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbGxhdG9yKSB7XG4gICAgICAgIHJldHVybiBDb2xsYXRvclR5cGU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZvcm1hdHRlZCkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVkVHlwZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkge1xuICAgICAgICByZXR1cm4gUmVzb2x2ZWRJbWFnZVR5cGU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbVR5cGU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdmFsdWU7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICB2YXIgdCA9IHR5cGVPZihpdGVtKTtcbiAgICAgICAgICAgIGlmICghaXRlbVR5cGUpIHtcbiAgICAgICAgICAgICAgICBpdGVtVHlwZSA9IHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1UeXBlID09PSB0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1UeXBlID0gVmFsdWVUeXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheShpdGVtVHlwZSB8fCBWYWx1ZVR5cGUsIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdFR5cGU7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TdHJpbmckMSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yIHx8IHZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbn1cblxudmFyIExpdGVyYWwgPSBmdW5jdGlvbiBMaXRlcmFsKHR5cGUsIHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59O1xuTGl0ZXJhbC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1xcJ2xpdGVyYWxcXCcgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbHVlKGFyZ3NbMV0pKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdpbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IGFyZ3NbMV07XG4gICAgdmFyIHR5cGUgPSB0eXBlT2YodmFsdWUpO1xuICAgIHZhciBleHBlY3RlZCA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgIGlmICh0eXBlLmtpbmQgPT09ICdhcnJheScgJiYgdHlwZS5OID09PSAwICYmIGV4cGVjdGVkICYmIGV4cGVjdGVkLmtpbmQgPT09ICdhcnJheScgJiYgKHR5cGVvZiBleHBlY3RlZC5OICE9PSAnbnVtYmVyJyB8fCBleHBlY3RlZC5OID09PSAwKSkge1xuICAgICAgICB0eXBlID0gZXhwZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbCh0eXBlLCB2YWx1ZSk7XG59O1xuTGl0ZXJhbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5MaXRlcmFsLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoKSB7XG59O1xuTGl0ZXJhbC5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuTGl0ZXJhbC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2FycmF5JyB8fCB0aGlzLnR5cGUua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgIHRoaXMudmFsdWVcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICByZXR1cm4gWydyZ2JhJ10uY29uY2F0KHRoaXMudmFsdWUudG9BcnJheSgpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBGb3JtYXR0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc2VyaWFsaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufTtcblxudmFyIFJ1bnRpbWVFcnJvciA9IGZ1bmN0aW9uIFJ1bnRpbWVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5uYW1lID0gJ0V4cHJlc3Npb25FdmFsdWF0aW9uRXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59O1xuUnVudGltZUVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbn07XG5cbnZhciB0eXBlcyA9IHtcbiAgICBzdHJpbmc6IFN0cmluZ1R5cGUsXG4gICAgbnVtYmVyOiBOdW1iZXJUeXBlLFxuICAgIGJvb2xlYW46IEJvb2xlYW5UeXBlLFxuICAgIG9iamVjdDogT2JqZWN0VHlwZVxufTtcbnZhciBBc3NlcnRpb24gPSBmdW5jdGlvbiBBc3NlcnRpb24odHlwZSwgYXJncykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbn07XG5Bc3NlcnRpb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHR5cGU7XG4gICAgdmFyIG5hbWUgPSBhcmdzWzBdO1xuICAgIGlmIChuYW1lID09PSAnYXJyYXknKSB7XG4gICAgICAgIHZhciBpdGVtVHlwZTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIHR5cGUkMSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUkMSAhPT0gJ3N0cmluZycgfHwgISh0eXBlJDEgaW4gdHlwZXMpIHx8IHR5cGUkMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignVGhlIGl0ZW0gdHlwZSBhcmd1bWVudCBvZiBcImFycmF5XCIgbXVzdCBiZSBvbmUgb2Ygc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4nLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1UeXBlID0gdHlwZXNbdHlwZSQxXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1UeXBlID0gVmFsdWVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBOO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICBpZiAoYXJnc1syXSAhPT0gbnVsbCAmJiAodHlwZW9mIGFyZ3NbMl0gIT09ICdudW1iZXInIHx8IGFyZ3NbMl0gPCAwIHx8IGFyZ3NbMl0gIT09IE1hdGguZmxvb3IoYXJnc1syXSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1RoZSBsZW5ndGggYXJndW1lbnQgdG8gXCJhcnJheVwiIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxpdGVyYWwnLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE4gPSBhcmdzWzJdO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSBhcnJheShpdGVtVHlwZSwgTik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHR5cGVzW25hbWVdO1xuICAgIH1cbiAgICB2YXIgcGFyc2VkID0gW107XG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgaSwgVmFsdWVUeXBlKTtcbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLnB1c2goaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0eXBlLCBwYXJzZWQpO1xufTtcbkFzc2VydGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmFyZ3NbaV0uZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tTdWJ0eXBlKHRoaXMudHlwZSwgdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSB0aGlzLmFyZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSAnICsgdG9TdHJpbmcodGhpcy50eXBlKSArICcsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodHlwZU9mKHZhbHVlKSkgKyAnIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuQXNzZXJ0aW9uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG59O1xuQXNzZXJ0aW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSk7XG59O1xuQXNzZXJ0aW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbdHlwZS5raW5kXTtcbiAgICBpZiAodHlwZS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgICAgIHZhciBpdGVtVHlwZSA9IHR5cGUuaXRlbVR5cGU7XG4gICAgICAgIGlmIChpdGVtVHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCBpdGVtVHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCBpdGVtVHlwZS5raW5kID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChpdGVtVHlwZS5raW5kKTtcbiAgICAgICAgICAgIHZhciBOID0gdHlwZS5OO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBOID09PSAnbnVtYmVyJyB8fCB0aGlzLmFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZC5jb25jYXQodGhpcy5hcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmcuc2VyaWFsaXplKCk7XG4gICAgfSkpO1xufTtcblxudmFyIEZvcm1hdEV4cHJlc3Npb24gPSBmdW5jdGlvbiBGb3JtYXRFeHByZXNzaW9uKHNlY3Rpb25zKSB7XG4gICAgdGhpcy50eXBlID0gRm9ybWF0dGVkVHlwZTtcbiAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG59O1xuRm9ybWF0RXhwcmVzc2lvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBmaXJzdEFyZyA9IGFyZ3NbMV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpcnN0QXJnKSAmJiB0eXBlb2YgZmlyc3RBcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGltYWdlIG9yIHRleHQgc2VjdGlvbi4nKTtcbiAgICB9XG4gICAgdmFyIHNlY3Rpb25zID0gW107XG4gICAgdmFyIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gYXJncy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgIGlmIChuZXh0VG9rZW5NYXlCZU9iamVjdCAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBuZXh0VG9rZW5NYXlCZU9iamVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChhcmdbJ2ZvbnQtc2NhbGUnXSkge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gY29udGV4dC5wYXJzZShhcmdbJ2ZvbnQtc2NhbGUnXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm9udCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJnWyd0ZXh0LWZvbnQnXSkge1xuICAgICAgICAgICAgICAgIGZvbnQgPSBjb250ZXh0LnBhcnNlKGFyZ1sndGV4dC1mb250J10sIDEsIGFycmF5KFN0cmluZ1R5cGUpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHRDb2xvciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJnWyd0ZXh0LWNvbG9yJ10pIHtcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3IgPSBjb250ZXh0LnBhcnNlKGFyZ1sndGV4dC1jb2xvciddLCAxLCBDb2xvclR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghdGV4dENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0RXhwcmVzc2lvbiA9IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbGFzdEV4cHJlc3Npb24uc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgIGxhc3RFeHByZXNzaW9uLmZvbnQgPSBmb250O1xuICAgICAgICAgICAgbGFzdEV4cHJlc3Npb24udGV4dENvbG9yID0gdGV4dENvbG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBraW5kID0gY29udGVudC50eXBlLmtpbmQ7XG4gICAgICAgICAgICBpZiAoa2luZCAhPT0gJ3N0cmluZycgJiYga2luZCAhPT0gJ3ZhbHVlJyAmJiBraW5kICE9PSAnbnVsbCcgJiYga2luZCAhPT0gJ3Jlc29sdmVkSW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0Zvcm1hdHRlZCB0ZXh0IHR5cGUgbXVzdCBiZSBcXCdzdHJpbmdcXCcsIFxcJ3ZhbHVlXFwnLCBcXCdpbWFnZVxcJyBvciBcXCdudWxsXFwnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFRva2VuTWF5QmVPYmplY3QgPSB0cnVlO1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICBzY2FsZTogbnVsbCxcbiAgICAgICAgICAgICAgICBmb250OiBudWxsLFxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGb3JtYXRFeHByZXNzaW9uKHNlY3Rpb25zKTtcbn07XG5Gb3JtYXRFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBldmFsdWF0ZVNlY3Rpb24gPSBmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICB2YXIgZXZhbHVhdGVkQ29udGVudCA9IHNlY3Rpb24uY29udGVudC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBpZiAodHlwZU9mKGV2YWx1YXRlZENvbnRlbnQpID09PSBSZXNvbHZlZEltYWdlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWRTZWN0aW9uKCcnLCBldmFsdWF0ZWRDb250ZW50LCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvcm1hdHRlZFNlY3Rpb24odG9TdHJpbmckMShldmFsdWF0ZWRDb250ZW50KSwgbnVsbCwgc2VjdGlvbi5zY2FsZSA/IHNlY3Rpb24uc2NhbGUuZXZhbHVhdGUoY3R4KSA6IG51bGwsIHNlY3Rpb24uZm9udCA/IHNlY3Rpb24uZm9udC5ldmFsdWF0ZShjdHgpLmpvaW4oJywnKSA6IG51bGwsIHNlY3Rpb24udGV4dENvbG9yID8gc2VjdGlvbi50ZXh0Q29sb3IuZXZhbHVhdGUoY3R4KSA6IG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWQodGhpcy5zZWN0aW9ucy5tYXAoZXZhbHVhdGVTZWN0aW9uKSk7XG59O1xuRm9ybWF0RXhwcmVzc2lvbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLnNlY3Rpb25zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGxpc3RbaV07XG4gICAgICAgIGZuKHNlY3Rpb24uY29udGVudCk7XG4gICAgICAgIGlmIChzZWN0aW9uLnNjYWxlKSB7XG4gICAgICAgICAgICBmbihzZWN0aW9uLnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbi5mb250KSB7XG4gICAgICAgICAgICBmbihzZWN0aW9uLmZvbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uLnRleHRDb2xvcikge1xuICAgICAgICAgICAgZm4oc2VjdGlvbi50ZXh0Q29sb3IpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkZvcm1hdEV4cHJlc3Npb24ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5Gb3JtYXRFeHByZXNzaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5zZWN0aW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBsaXN0W2ldO1xuICAgICAgICBzZXJpYWxpemVkLnB1c2goc2VjdGlvbi5jb250ZW50LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHNlY3Rpb24uc2NhbGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ2ZvbnQtc2NhbGUnXSA9IHNlY3Rpb24uc2NhbGUuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb24uZm9udCkge1xuICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1mb250J10gPSBzZWN0aW9uLmZvbnQuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb24udGV4dENvbG9yKSB7XG4gICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWNvbG9yJ10gPSBzZWN0aW9uLnRleHRDb2xvci5zZXJpYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkLnB1c2gob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIEltYWdlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIEltYWdlRXhwcmVzc2lvbihpbnB1dCkge1xuICAgIHRoaXMudHlwZSA9IFJlc29sdmVkSW1hZ2VUeXBlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbn07XG5JbWFnZUV4cHJlc3Npb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCB0d28gYXJndW1lbnRzLicpO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgU3RyaW5nVHlwZSk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdObyBpbWFnZSBuYW1lIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEltYWdlRXhwcmVzc2lvbihuYW1lKTtcbn07XG5JbWFnZUV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgdmFyIGV2YWx1YXRlZEltYWdlTmFtZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICB2YXIgdmFsdWUgPSBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcoZXZhbHVhdGVkSW1hZ2VOYW1lKTtcbiAgICBpZiAodmFsdWUgJiYgY3R4LmF2YWlsYWJsZUltYWdlcykge1xuICAgICAgICB2YWx1ZS5hdmFpbGFibGUgPSBjdHguYXZhaWxhYmxlSW1hZ2VzLmluZGV4T2YoZXZhbHVhdGVkSW1hZ2VOYW1lKSA+IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuSW1hZ2VFeHByZXNzaW9uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLmlucHV0KTtcbn07XG5JbWFnZUV4cHJlc3Npb24ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5JbWFnZUV4cHJlc3Npb24ucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXG4gICAgXTtcbn07XG5cbnZhciB0eXBlcyQxID0ge1xuICAgICd0by1ib29sZWFuJzogQm9vbGVhblR5cGUsXG4gICAgJ3RvLWNvbG9yJzogQ29sb3JUeXBlLFxuICAgICd0by1udW1iZXInOiBOdW1iZXJUeXBlLFxuICAgICd0by1zdHJpbmcnOiBTdHJpbmdUeXBlXG59O1xudmFyIENvZXJjaW9uID0gZnVuY3Rpb24gQ29lcmNpb24odHlwZSwgYXJncykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbn07XG5Db2VyY2lvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBuYW1lID0gYXJnc1swXTtcbiAgICBpZiAoKG5hbWUgPT09ICd0by1ib29sZWFuJyB8fCBuYW1lID09PSAndG8tc3RyaW5nJykgJiYgYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIG9uZSBhcmd1bWVudC4nKTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB0eXBlcyQxW25hbWVdO1xuICAgIHZhciBwYXJzZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCBpLCBWYWx1ZVR5cGUpO1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQucHVzaChpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29lcmNpb24odHlwZSwgcGFyc2VkKTtcbn07XG5Db2VyY2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2NvbG9yJykge1xuICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLmFyZ3M7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlucHV0ID0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gY3R4LnBhcnNlQ29sb3IoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIDwgMyB8fCBpbnB1dC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ0ludmFsaWQgcmJnYSB2YWx1ZSAnICsgSlNPTi5zdHJpbmdpZnkoaW5wdXQpICsgJzogZXhwZWN0ZWQgYW4gYXJyYXkgY29udGFpbmluZyBlaXRoZXIgdGhyZWUgb3IgZm91ciBudW1lcmljIHZhbHVlcy4nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdmFsaWRhdGVSR0JBKGlucHV0WzBdLCBpbnB1dFsxXSwgaW5wdXRbMl0sIGlucHV0WzNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKGlucHV0WzBdIC8gMjU1LCBpbnB1dFsxXSAvIDI1NSwgaW5wdXRbMl0gLyAyNTUsIGlucHV0WzNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihlcnJvciB8fCAnQ291bGQgbm90IHBhcnNlIGNvbG9yIGZyb20gdmFsdWUgXFwnJyArICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gaW5wdXQgOiBTdHJpbmcoSlNPTi5zdHJpbmdpZnkoaW5wdXQpKSkgKyAnXFwnJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gdGhpcy5hcmdzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGFyZyQxID0gbGlzdCQxW2kkMV07XG4gICAgICAgICAgICB2YWx1ZSA9IGFyZyQxLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG51bSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcgdG8gbnVtYmVyLicpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdmb3JtYXR0ZWQnKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZWQuZnJvbVN0cmluZyh0b1N0cmluZyQxKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSB7XG4gICAgICAgIHJldHVybiBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcodG9TdHJpbmckMSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyQxKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKTtcbiAgICB9XG59O1xuQ29lcmNpb24ucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIHRoaXMuYXJncy5mb3JFYWNoKGZuKTtcbn07XG5Db2VyY2lvbi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmcub3V0cHV0RGVmaW5lZCgpO1xuICAgIH0pO1xufTtcbkNvZXJjaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMudHlwZS5raW5kID09PSAnZm9ybWF0dGVkJykge1xuICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEV4cHJlc3Npb24oW3tcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgc2NhbGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZm9udDogbnVsbCxcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IG51bGxcbiAgICAgICAgICAgIH1dKS5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZS5raW5kID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbWFnZUV4cHJlc3Npb24odGhpcy5hcmdzWzBdKS5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ3RvLScgKyB0aGlzLnR5cGUua2luZF07XG4gICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaChjaGlsZC5zZXJpYWxpemUoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG52YXIgZ2VvbWV0cnlUeXBlcyA9IFtcbiAgICAnVW5rbm93bicsXG4gICAgJ1BvaW50JyxcbiAgICAnTGluZVN0cmluZycsXG4gICAgJ1BvbHlnb24nXG5dO1xudmFyIEV2YWx1YXRpb25Db250ZXh0ID0gZnVuY3Rpb24gRXZhbHVhdGlvbkNvbnRleHQoKSB7XG4gICAgdGhpcy5nbG9iYWxzID0gbnVsbDtcbiAgICB0aGlzLmZlYXR1cmUgPSBudWxsO1xuICAgIHRoaXMuZmVhdHVyZVN0YXRlID0gbnVsbDtcbiAgICB0aGlzLmZvcm1hdHRlZFNlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuX3BhcnNlQ29sb3JDYWNoZSA9IHt9O1xuICAgIHRoaXMuYXZhaWxhYmxlSW1hZ2VzID0gbnVsbDtcbiAgICB0aGlzLmNhbm9uaWNhbCA9IG51bGw7XG59O1xuRXZhbHVhdGlvbkNvbnRleHQucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiAnaWQnIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5pZCA6IG51bGw7XG59O1xuRXZhbHVhdGlvbkNvbnRleHQucHJvdG90eXBlLmdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdlb21ldHJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlID8gdHlwZW9mIHRoaXMuZmVhdHVyZS50eXBlID09PSAnbnVtYmVyJyA/IGdlb21ldHJ5VHlwZXNbdGhpcy5mZWF0dXJlLnR5cGVdIDogdGhpcy5mZWF0dXJlLnR5cGUgOiBudWxsO1xufTtcbkV2YWx1YXRpb25Db250ZXh0LnByb3RvdHlwZS5nZW9tZXRyeSA9IGZ1bmN0aW9uIGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgJ2dlb21ldHJ5JyBpbiB0aGlzLmZlYXR1cmUgPyB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgOiBudWxsO1xufTtcbkV2YWx1YXRpb25Db250ZXh0LnByb3RvdHlwZS5jYW5vbmljYWxJRCA9IGZ1bmN0aW9uIGNhbm9uaWNhbElEKCkge1xuICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbDtcbn07XG5FdmFsdWF0aW9uQ29udGV4dC5wcm90b3R5cGUucHJvcGVydGllcyA9IGZ1bmN0aW9uIHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUucHJvcGVydGllcyB8fCB7fTtcbn07XG5FdmFsdWF0aW9uQ29udGV4dC5wcm90b3R5cGUucGFyc2VDb2xvciA9IGZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXQpIHtcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW2lucHV0XTtcbiAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICBjYWNoZWQgPSB0aGlzLl9wYXJzZUNvbG9yQ2FjaGVbaW5wdXRdID0gQ29sb3IucGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkO1xufTtcblxudmFyIENvbXBvdW5kRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIENvbXBvdW5kRXhwcmVzc2lvbihuYW1lLCB0eXBlLCBldmFsdWF0ZSwgYXJncykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLl9ldmFsdWF0ZSA9IGV2YWx1YXRlO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHJldHVybiB0aGlzLl9ldmFsdWF0ZShjdHgsIHRoaXMuYXJncyk7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFt0aGlzLm5hbWVdLmNvbmNhdCh0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5zZXJpYWxpemUoKTtcbiAgICB9KSk7XG59O1xuQ29tcG91bmRFeHByZXNzaW9uLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIHZhciByZWYkMTtcbiAgICB2YXIgb3AgPSBhcmdzWzBdO1xuICAgIHZhciBkZWZpbml0aW9uID0gQ29tcG91bmRFeHByZXNzaW9uLmRlZmluaXRpb25zW29wXTtcbiAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1Vua25vd24gZXhwcmVzc2lvbiBcIicgKyBvcCArICdcIi4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS4nLCAwKTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBBcnJheS5pc0FycmF5KGRlZmluaXRpb24pID8gZGVmaW5pdGlvblswXSA6IGRlZmluaXRpb24udHlwZTtcbiAgICB2YXIgYXZhaWxhYmxlT3ZlcmxvYWRzID0gQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSA/IFtbXG4gICAgICAgICAgICBkZWZpbml0aW9uWzFdLFxuICAgICAgICAgICAgZGVmaW5pdGlvblsyXVxuICAgICAgICBdXSA6IGRlZmluaXRpb24ub3ZlcmxvYWRzO1xuICAgIHZhciBvdmVybG9hZHMgPSBhdmFpbGFibGVPdmVybG9hZHMuZmlsdGVyKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHJlZlswXTtcbiAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHNpZ25hdHVyZSkgfHwgc2lnbmF0dXJlLmxlbmd0aCA9PT0gYXJncy5sZW5ndGggLSAxO1xuICAgIH0pO1xuICAgIHZhciBzaWduYXR1cmVDb250ZXh0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpJDMgPSAwLCBsaXN0ID0gb3ZlcmxvYWRzOyBpJDMgPCBsaXN0Lmxlbmd0aDsgaSQzICs9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IGxpc3RbaSQzXTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHJlZlswXTtcbiAgICAgICAgdmFyIGV2YWx1YXRlID0gcmVmWzFdO1xuICAgICAgICBzaWduYXR1cmVDb250ZXh0ID0gbmV3IFBhcnNpbmdDb250ZXh0KGNvbnRleHQucmVnaXN0cnksIGNvbnRleHQucGF0aCwgbnVsbCwgY29udGV4dC5zY29wZSk7XG4gICAgICAgIHZhciBwYXJzZWRBcmdzID0gW107XG4gICAgICAgIHZhciBhcmdQYXJzZUZhaWxlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IEFycmF5LmlzQXJyYXkocGFyYW1zKSA/IHBhcmFtc1tpIC0gMV0gOiBwYXJhbXMudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBzaWduYXR1cmVDb250ZXh0LnBhcnNlKGFyZywgMSArIHBhcnNlZEFyZ3MubGVuZ3RoLCBleHBlY3RlZFR5cGUpO1xuICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBhcmdQYXJzZUZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWRBcmdzLnB1c2gocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnUGFyc2VGYWlsZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSBwYXJzZWRBcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkICcgKyBwYXJhbXMubGVuZ3RoICsgJyBhcmd1bWVudHMsIGJ1dCBmb3VuZCAnICsgcGFyc2VkQXJncy5sZW5ndGggKyAnIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcGFyc2VkQXJncy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSBBcnJheS5pc0FycmF5KHBhcmFtcykgPyBwYXJhbXNbaSQxXSA6IHBhcmFtcy50eXBlO1xuICAgICAgICAgICAgdmFyIGFyZyQxID0gcGFyc2VkQXJnc1tpJDFdO1xuICAgICAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5jb25jYXQoaSQxICsgMSkuY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCBhcmckMS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmF0dXJlQ29udGV4dC5lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kRXhwcmVzc2lvbihvcCwgdHlwZSwgZXZhbHVhdGUsIHBhcnNlZEFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVybG9hZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIChyZWYkMSA9IGNvbnRleHQuZXJyb3JzKS5wdXNoLmFwcGx5KHJlZiQxLCBzaWduYXR1cmVDb250ZXh0LmVycm9ycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkJDEgPSBvdmVybG9hZHMubGVuZ3RoID8gb3ZlcmxvYWRzIDogYXZhaWxhYmxlT3ZlcmxvYWRzO1xuICAgICAgICB2YXIgc2lnbmF0dXJlcyA9IGV4cGVjdGVkJDEubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5U2lnbmF0dXJlKHBhcmFtcyk7XG4gICAgICAgIH0pLmpvaW4oJyB8ICcpO1xuICAgICAgICB2YXIgYWN0dWFsVHlwZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgYXJncy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkJDEgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaSQyXSwgMSArIGFjdHVhbFR5cGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZCQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3R1YWxUeXBlcy5wdXNoKHRvU3RyaW5nKHBhcnNlZCQxLnR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhcmd1bWVudHMgb2YgdHlwZSAnICsgc2lnbmF0dXJlcyArICcsIGJ1dCBmb3VuZCAoJyArIGFjdHVhbFR5cGVzLmpvaW4oJywgJykgKyAnKSBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5Db21wb3VuZEV4cHJlc3Npb24ucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihyZWdpc3RyeSwgZGVmaW5pdGlvbnMpIHtcbiAgICBDb21wb3VuZEV4cHJlc3Npb24uZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICBmb3IgKHZhciBuYW1lIGluIGRlZmluaXRpb25zKSB7XG4gICAgICAgIHJlZ2lzdHJ5W25hbWVdID0gQ29tcG91bmRFeHByZXNzaW9uO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzdHJpbmdpZnlTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlKSkge1xuICAgICAgICByZXR1cm4gJygnICsgc2lnbmF0dXJlLm1hcCh0b1N0cmluZykuam9pbignLCAnKSArICcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJygnICsgdG9TdHJpbmcoc2lnbmF0dXJlLnR5cGUpICsgJy4uLiknO1xuICAgIH1cbn1cblxudmFyIENvbGxhdG9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIENvbGxhdG9yRXhwcmVzc2lvbihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSkge1xuICAgIHRoaXMudHlwZSA9IENvbGxhdG9yVHlwZTtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjYXNlU2Vuc2l0aXZlO1xuICAgIHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlID0gZGlhY3JpdGljU2Vuc2l0aXZlO1xufTtcbkNvbGxhdG9yRXhwcmVzc2lvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIG9uZSBhcmd1bWVudC4nKTtcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignQ29sbGF0b3Igb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG4gICAgdmFyIGNhc2VTZW5zaXRpdmUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2Nhc2Utc2Vuc2l0aXZlJ10gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9uc1snY2FzZS1zZW5zaXRpdmUnXSwgMSwgQm9vbGVhblR5cGUpO1xuICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGRpYWNyaXRpY1NlbnNpdGl2ZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snZGlhY3JpdGljLXNlbnNpdGl2ZSddID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnNbJ2RpYWNyaXRpYy1zZW5zaXRpdmUnXSwgMSwgQm9vbGVhblR5cGUpO1xuICAgIGlmICghZGlhY3JpdGljU2Vuc2l0aXZlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbG9jYWxlID0gbnVsbDtcbiAgICBpZiAob3B0aW9uc1snbG9jYWxlJ10pIHtcbiAgICAgICAgbG9jYWxlID0gY29udGV4dC5wYXJzZShvcHRpb25zWydsb2NhbGUnXSwgMSwgU3RyaW5nVHlwZSk7XG4gICAgICAgIGlmICghbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbGxhdG9yRXhwcmVzc2lvbihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSk7XG59O1xuQ29sbGF0b3JFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHJldHVybiBuZXcgQ29sbGF0b3IodGhpcy5jYXNlU2Vuc2l0aXZlLmV2YWx1YXRlKGN0eCksIHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlLmV2YWx1YXRlKGN0eCksIHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUoY3R4KSA6IG51bGwpO1xufTtcbkNvbGxhdG9yRXhwcmVzc2lvbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5jYXNlU2Vuc2l0aXZlKTtcbiAgICBmbih0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSk7XG4gICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgIGZuKHRoaXMubG9jYWxlKTtcbiAgICB9XG59O1xuQ29sbGF0b3JFeHByZXNzaW9uLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuQ29sbGF0b3JFeHByZXNzaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICBvcHRpb25zWydjYXNlLXNlbnNpdGl2ZSddID0gdGhpcy5jYXNlU2Vuc2l0aXZlLnNlcmlhbGl6ZSgpO1xuICAgIG9wdGlvbnNbJ2RpYWNyaXRpYy1zZW5zaXRpdmUnXSA9IHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlLnNlcmlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICBvcHRpb25zWydsb2NhbGUnXSA9IHRoaXMubG9jYWxlLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICAnY29sbGF0b3InLFxuICAgICAgICBvcHRpb25zXG4gICAgXTtcbn07XG5cbnZhciBFWFRFTlQgPSA4MTkyO1xuZnVuY3Rpb24gdXBkYXRlQkJveChiYm94LCBjb29yZCkge1xuICAgIGJib3hbMF0gPSBNYXRoLm1pbihiYm94WzBdLCBjb29yZFswXSk7XG4gICAgYmJveFsxXSA9IE1hdGgubWluKGJib3hbMV0sIGNvb3JkWzFdKTtcbiAgICBiYm94WzJdID0gTWF0aC5tYXgoYmJveFsyXSwgY29vcmRbMF0pO1xuICAgIGJib3hbM10gPSBNYXRoLm1heChiYm94WzNdLCBjb29yZFsxXSk7XG59XG5mdW5jdGlvbiBtZXJjYXRvclhmcm9tTG5nKGxuZykge1xuICAgIHJldHVybiAoMTgwICsgbG5nKSAvIDM2MDtcbn1cbmZ1bmN0aW9uIG1lcmNhdG9yWWZyb21MYXQobGF0KSB7XG4gICAgcmV0dXJuICgxODAgLSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBsYXQgKiBNYXRoLlBJIC8gMzYwKSkpIC8gMzYwO1xufVxuZnVuY3Rpb24gYm94V2l0aGluQm94KGJib3gxLCBiYm94Mikge1xuICAgIGlmIChiYm94MVswXSA8PSBiYm94MlswXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiYm94MVsyXSA+PSBiYm94MlsyXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiYm94MVsxXSA8PSBiYm94MlsxXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiYm94MVszXSA+PSBiYm94MlszXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VGlsZUNvb3JkaW5hdGVzKHAsIGNhbm9uaWNhbCkge1xuICAgIHZhciB4ID0gbWVyY2F0b3JYZnJvbUxuZyhwWzBdKTtcbiAgICB2YXIgeSA9IG1lcmNhdG9yWWZyb21MYXQocFsxXSk7XG4gICAgdmFyIHRpbGVzQXRab29tID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopO1xuICAgIHJldHVybiBbXG4gICAgICAgIE1hdGgucm91bmQoeCAqIHRpbGVzQXRab29tICogRVhURU5UKSxcbiAgICAgICAgTWF0aC5yb3VuZCh5ICogdGlsZXNBdFpvb20gKiBFWFRFTlQpXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG9uQm91bmRhcnkocCwgcDEsIHAyKSB7XG4gICAgdmFyIHgxID0gcFswXSAtIHAxWzBdO1xuICAgIHZhciB5MSA9IHBbMV0gLSBwMVsxXTtcbiAgICB2YXIgeDIgPSBwWzBdIC0gcDJbMF07XG4gICAgdmFyIHkyID0gcFsxXSAtIHAyWzFdO1xuICAgIHJldHVybiB4MSAqIHkyIC0geDIgKiB5MSA9PT0gMCAmJiB4MSAqIHgyIDw9IDAgJiYgeTEgKiB5MiA8PSAwO1xufVxuZnVuY3Rpb24gcmF5SW50ZXJzZWN0KHAsIHAxLCBwMikge1xuICAgIHJldHVybiBwMVsxXSA+IHBbMV0gIT09IHAyWzFdID4gcFsxXSAmJiBwWzBdIDwgKHAyWzBdIC0gcDFbMF0pICogKHBbMV0gLSBwMVsxXSkgLyAocDJbMV0gLSBwMVsxXSkgKyBwMVswXTtcbn1cbmZ1bmN0aW9uIHBvaW50V2l0aGluUG9seWdvbihwb2ludCwgcmluZ3MpIHtcbiAgICB2YXIgaW5zaWRlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gcmluZy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG4gICAgICAgICAgICBpZiAob25Cb3VuZGFyeShwb2ludCwgcmluZ1tqXSwgcmluZ1tqICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJheUludGVyc2VjdChwb2ludCwgcmluZ1tqXSwgcmluZ1tqICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuZnVuY3Rpb24gcG9pbnRXaXRoaW5Qb2x5Z29ucyhwb2ludCwgcG9seWdvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwb2ludFdpdGhpblBvbHlnb24ocG9pbnQsIHBvbHlnb25zW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGVycCh2MSwgdjIpIHtcbiAgICByZXR1cm4gdjFbMF0gKiB2MlsxXSAtIHYxWzFdICogdjJbMF07XG59XG5mdW5jdGlvbiB0d29TaWRlZChwMSwgcDIsIHExLCBxMikge1xuICAgIHZhciB4MSA9IHAxWzBdIC0gcTFbMF07XG4gICAgdmFyIHkxID0gcDFbMV0gLSBxMVsxXTtcbiAgICB2YXIgeDIgPSBwMlswXSAtIHExWzBdO1xuICAgIHZhciB5MiA9IHAyWzFdIC0gcTFbMV07XG4gICAgdmFyIHgzID0gcTJbMF0gLSBxMVswXTtcbiAgICB2YXIgeTMgPSBxMlsxXSAtIHExWzFdO1xuICAgIHZhciBkZXQxID0geDEgKiB5MyAtIHgzICogeTE7XG4gICAgdmFyIGRldDIgPSB4MiAqIHkzIC0geDMgKiB5MjtcbiAgICBpZiAoZGV0MSA+IDAgJiYgZGV0MiA8IDAgfHwgZGV0MSA8IDAgJiYgZGV0MiA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RMaW5lKGEsIGIsIGMsIGQpIHtcbiAgICB2YXIgdmVjdG9yUCA9IFtcbiAgICAgICAgYlswXSAtIGFbMF0sXG4gICAgICAgIGJbMV0gLSBhWzFdXG4gICAgXTtcbiAgICB2YXIgdmVjdG9yUSA9IFtcbiAgICAgICAgZFswXSAtIGNbMF0sXG4gICAgICAgIGRbMV0gLSBjWzFdXG4gICAgXTtcbiAgICBpZiAocGVycCh2ZWN0b3JRLCB2ZWN0b3JQKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0d29TaWRlZChhLCBiLCBjLCBkKSAmJiB0d29TaWRlZChjLCBkLCBhLCBiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbGluZUludGVyc2VjdFBvbHlnb24ocDEsIHAyLCBwb2x5Z29uKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwb2x5Z29uOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmluZyA9IGxpc3RbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGggLSAxOyArK2opIHtcbiAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0TGluZShwMSwgcDIsIHJpbmdbal0sIHJpbmdbaiArIDFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHBvbHlnb24pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCFwb2ludFdpdGhpblBvbHlnb24obGluZVtpXSwgcG9seWdvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsaW5lLmxlbmd0aCAtIDE7ICsraSQxKSB7XG4gICAgICAgIGlmIChsaW5lSW50ZXJzZWN0UG9seWdvbihsaW5lW2kkMV0sIGxpbmVbaSQxICsgMV0sIHBvbHlnb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaW5lU3RyaW5nV2l0aGluUG9seWdvbnMobGluZSwgcG9seWdvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lU3RyaW5nV2l0aGluUG9seWdvbihsaW5lLCBwb2x5Z29uc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFRpbGVQb2x5Z29uKGNvb3JkaW5hdGVzLCBiYm94LCBjYW5vbmljYWwpIHtcbiAgICB2YXIgcG9seWdvbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb29yZGluYXRlc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gZ2V0VGlsZUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzW2ldW2pdLCBjYW5vbmljYWwpO1xuICAgICAgICAgICAgdXBkYXRlQkJveChiYm94LCBjb29yZCk7XG4gICAgICAgICAgICByaW5nLnB1c2goY29vcmQpO1xuICAgICAgICB9XG4gICAgICAgIHBvbHlnb24ucHVzaChyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlnb247XG59XG5mdW5jdGlvbiBnZXRUaWxlUG9seWdvbnMoY29vcmRpbmF0ZXMsIGJib3gsIGNhbm9uaWNhbCkge1xuICAgIHZhciBwb2x5Z29ucyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBnZXRUaWxlUG9seWdvbihjb29yZGluYXRlc1tpXSwgYmJveCwgY2Fub25pY2FsKTtcbiAgICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlnb25zO1xufVxuZnVuY3Rpb24gdXBkYXRlUG9pbnQocCwgYmJveCwgcG9seUJCb3gsIHdvcmxkU2l6ZSkge1xuICAgIGlmIChwWzBdIDwgcG9seUJCb3hbMF0gfHwgcFswXSA+IHBvbHlCQm94WzJdKSB7XG4gICAgICAgIHZhciBoYWxmV29ybGRTaXplID0gd29ybGRTaXplICogMC41O1xuICAgICAgICB2YXIgc2hpZnQgPSBwWzBdIC0gcG9seUJCb3hbMF0gPiBoYWxmV29ybGRTaXplID8gLXdvcmxkU2l6ZSA6IHBvbHlCQm94WzBdIC0gcFswXSA+IGhhbGZXb3JsZFNpemUgPyB3b3JsZFNpemUgOiAwO1xuICAgICAgICBpZiAoc2hpZnQgPT09IDApIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gcFswXSAtIHBvbHlCQm94WzJdID4gaGFsZldvcmxkU2l6ZSA/IC13b3JsZFNpemUgOiBwb2x5QkJveFsyXSAtIHBbMF0gPiBoYWxmV29ybGRTaXplID8gd29ybGRTaXplIDogMDtcbiAgICAgICAgfVxuICAgICAgICBwWzBdICs9IHNoaWZ0O1xuICAgIH1cbiAgICB1cGRhdGVCQm94KGJib3gsIHApO1xufVxuZnVuY3Rpb24gcmVzZXRCQm94KGJib3gpIHtcbiAgICBiYm94WzBdID0gYmJveFsxXSA9IEluZmluaXR5O1xuICAgIGJib3hbMl0gPSBiYm94WzNdID0gLUluZmluaXR5O1xufVxuZnVuY3Rpb24gZ2V0VGlsZVBvaW50cyhnZW9tZXRyeSwgcG9pbnRCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKSB7XG4gICAgdmFyIHdvcmxkU2l6ZSA9IE1hdGgucG93KDIsIGNhbm9uaWNhbC56KSAqIEVYVEVOVDtcbiAgICB2YXIgc2hpZnRzID0gW1xuICAgICAgICBjYW5vbmljYWwueCAqIEVYVEVOVCxcbiAgICAgICAgY2Fub25pY2FsLnkgKiBFWFRFTlRcbiAgICBdO1xuICAgIHZhciB0aWxlUG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZ2VvbWV0cnk7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBsaXN0JDFbaSQxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwb2ludHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBsaXN0W2ldO1xuICAgICAgICAgICAgdmFyIHAgPSBbXG4gICAgICAgICAgICAgICAgcG9pbnQueCArIHNoaWZ0c1swXSxcbiAgICAgICAgICAgICAgICBwb2ludC55ICsgc2hpZnRzWzFdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdXBkYXRlUG9pbnQocCwgcG9pbnRCQm94LCBwb2x5QkJveCwgd29ybGRTaXplKTtcbiAgICAgICAgICAgIHRpbGVQb2ludHMucHVzaChwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlsZVBvaW50cztcbn1cbmZ1bmN0aW9uIGdldFRpbGVMaW5lcyhnZW9tZXRyeSwgbGluZUJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpIHtcbiAgICB2YXIgd29ybGRTaXplID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopICogRVhURU5UO1xuICAgIHZhciBzaGlmdHMgPSBbXG4gICAgICAgIGNhbm9uaWNhbC54ICogRVhURU5ULFxuICAgICAgICBjYW5vbmljYWwueSAqIEVYVEVOVFxuICAgIF07XG4gICAgdmFyIHRpbGVMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGdlb21ldHJ5OyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgbGluZSA9IGxpc3QkMVtpJDFdO1xuICAgICAgICB2YXIgdGlsZUxpbmUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBsaW5lOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgICAgIHBvaW50LnggKyBzaGlmdHNbMF0sXG4gICAgICAgICAgICAgICAgcG9pbnQueSArIHNoaWZ0c1sxXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHVwZGF0ZUJCb3gobGluZUJCb3gsIHApO1xuICAgICAgICAgICAgdGlsZUxpbmUucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgICB0aWxlTGluZXMucHVzaCh0aWxlTGluZSk7XG4gICAgfVxuICAgIGlmIChsaW5lQkJveFsyXSAtIGxpbmVCQm94WzBdIDw9IHdvcmxkU2l6ZSAvIDIpIHtcbiAgICAgICAgcmVzZXRCQm94KGxpbmVCQm94KTtcbiAgICAgICAgZm9yICh2YXIgaSQzID0gMCwgbGlzdCQzID0gdGlsZUxpbmVzOyBpJDMgPCBsaXN0JDMubGVuZ3RoOyBpJDMgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGxpbmUkMSA9IGxpc3QkM1tpJDNdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMCwgbGlzdCQyID0gbGluZSQxOyBpJDIgPCBsaXN0JDIubGVuZ3RoOyBpJDIgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBwJDEgPSBsaXN0JDJbaSQyXTtcbiAgICAgICAgICAgICAgICB1cGRhdGVQb2ludChwJDEsIGxpbmVCQm94LCBwb2x5QkJveCwgd29ybGRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlsZUxpbmVzO1xufVxuZnVuY3Rpb24gcG9pbnRzV2l0aGluUG9seWdvbnMoY3R4LCBwb2x5Z29uR2VvbWV0cnkpIHtcbiAgICB2YXIgcG9pbnRCQm94ID0gW1xuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIC1JbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5XG4gICAgXTtcbiAgICB2YXIgcG9seUJCb3ggPSBbXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5LFxuICAgICAgICAtSW5maW5pdHlcbiAgICBdO1xuICAgIHZhciBjYW5vbmljYWwgPSBjdHguY2Fub25pY2FsSUQoKTtcbiAgICBpZiAocG9seWdvbkdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICB2YXIgdGlsZVBvbHlnb24gPSBnZXRUaWxlUG9seWdvbihwb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICB2YXIgdGlsZVBvaW50cyA9IGdldFRpbGVQb2ludHMoY3R4Lmdlb21ldHJ5KCksIHBvaW50QkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIGlmICghYm94V2l0aGluQm94KHBvaW50QkJveCwgcG9seUJCb3gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aWxlUG9pbnRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmICghcG9pbnRXaXRoaW5Qb2x5Z29uKHBvaW50LCB0aWxlUG9seWdvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICB2YXIgdGlsZVBvbHlnb25zID0gZ2V0VGlsZVBvbHlnb25zKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIHZhciB0aWxlUG9pbnRzJDEgPSBnZXRUaWxlUG9pbnRzKGN0eC5nZW9tZXRyeSgpLCBwb2ludEJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICBpZiAoIWJveFdpdGhpbkJveChwb2ludEJCb3gsIHBvbHlCQm94KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHRpbGVQb2ludHMkMTsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCQxID0gbGlzdCQxW2kkMV07XG4gICAgICAgICAgICBpZiAoIXBvaW50V2l0aGluUG9seWdvbnMocG9pbnQkMSwgdGlsZVBvbHlnb25zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGxpbmVzV2l0aGluUG9seWdvbnMoY3R4LCBwb2x5Z29uR2VvbWV0cnkpIHtcbiAgICB2YXIgbGluZUJCb3ggPSBbXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5LFxuICAgICAgICAtSW5maW5pdHlcbiAgICBdO1xuICAgIHZhciBwb2x5QkJveCA9IFtcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICAtSW5maW5pdHksXG4gICAgICAgIC1JbmZpbml0eVxuICAgIF07XG4gICAgdmFyIGNhbm9uaWNhbCA9IGN0eC5jYW5vbmljYWxJRCgpO1xuICAgIGlmIChwb2x5Z29uR2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIHZhciB0aWxlUG9seWdvbiA9IGdldFRpbGVQb2x5Z29uKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIHZhciB0aWxlTGluZXMgPSBnZXRUaWxlTGluZXMoY3R4Lmdlb21ldHJ5KCksIGxpbmVCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICAgICAgaWYgKCFib3hXaXRoaW5Cb3gobGluZUJCb3gsIHBvbHlCQm94KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGlsZUxpbmVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKCFsaW5lU3RyaW5nV2l0aGluUG9seWdvbihsaW5lLCB0aWxlUG9seWdvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICB2YXIgdGlsZVBvbHlnb25zID0gZ2V0VGlsZVBvbHlnb25zKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIHZhciB0aWxlTGluZXMkMSA9IGdldFRpbGVMaW5lcyhjdHguZ2VvbWV0cnkoKSwgbGluZUJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICBpZiAoIWJveFdpdGhpbkJveChsaW5lQkJveCwgcG9seUJCb3gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gdGlsZUxpbmVzJDE7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbGluZSQxID0gbGlzdCQxW2kkMV07XG4gICAgICAgICAgICBpZiAoIWxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29ucyhsaW5lJDEsIHRpbGVQb2x5Z29ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG52YXIgV2l0aGluID0gZnVuY3Rpb24gV2l0aGluKGdlb2pzb24sIGdlb21ldHJpZXMpIHtcbiAgICB0aGlzLnR5cGUgPSBCb29sZWFuVHlwZTtcbiAgICB0aGlzLmdlb2pzb24gPSBnZW9qc29uO1xuICAgIHRoaXMuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG59O1xuV2l0aGluLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignXFwnd2l0aGluXFwnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIGJ1dCBmb3VuZCAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmIChpc1ZhbHVlKGFyZ3NbMV0pKSB7XG4gICAgICAgIHZhciBnZW9qc29uID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBnZW9qc29uLmZlYXR1cmVzW2ldLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdQb2x5Z29uJyB8fCB0eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdpdGhpbihnZW9qc29uLCBnZW9qc29uLmZlYXR1cmVzW2ldLmdlb21ldHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgICAgIHZhciB0eXBlJDEgPSBnZW9qc29uLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSQxID09PSAnUG9seWdvbicgfHwgdHlwZSQxID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24uZ2VvbWV0cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb2pzb24udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdcXCd3aXRoaW5cXCcgZXhwcmVzc2lvbiByZXF1aXJlcyB2YWxpZCBnZW9qc29uIG9iamVjdCB0aGF0IGNvbnRhaW5zIHBvbHlnb24gZ2VvbWV0cnkgdHlwZS4nKTtcbn07XG5XaXRoaW4ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgaWYgKGN0eC5nZW9tZXRyeSgpICE9IG51bGwgJiYgY3R4LmNhbm9uaWNhbElEKCkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY3R4Lmdlb21ldHJ5VHlwZSgpID09PSAnUG9pbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzV2l0aGluUG9seWdvbnMoY3R4LCB0aGlzLmdlb21ldHJpZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZXNXaXRoaW5Qb2x5Z29ucyhjdHgsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbldpdGhpbi5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKCkge1xufTtcbldpdGhpbi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuV2l0aGluLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ3dpdGhpbicsXG4gICAgICAgIHRoaXMuZ2VvanNvblxuICAgIF07XG59O1xuXG5mdW5jdGlvbiBpc0ZlYXR1cmVDb25zdGFudChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ2dldCcgJiYgZS5hcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ2ZlYXR1cmUtc3RhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnaGFzJyAmJiBlLmFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAncHJvcGVydGllcycgfHwgZS5uYW1lID09PSAnZ2VvbWV0cnktdHlwZScgfHwgZS5uYW1lID09PSAnaWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoL15maWx0ZXItLy50ZXN0KGUubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZSBpbnN0YW5jZW9mIFdpdGhpbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIGUuZWFjaENoaWxkKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNGZWF0dXJlQ29uc3RhbnQoYXJnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNTdGF0ZUNvbnN0YW50KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZS5uYW1lID09PSAnZmVhdHVyZS1zdGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBlLmVhY2hDaGlsZChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgIWlzU3RhdGVDb25zdGFudChhcmcpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoZSwgcHJvcGVydGllcykge1xuICAgIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIHByb3BlcnRpZXMuaW5kZXhPZihlLm5hbWUpID49IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBlLmVhY2hDaGlsZChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgIWlzR2xvYmFsUHJvcGVydHlDb25zdGFudChhcmcsIHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBWYXIgPSBmdW5jdGlvbiBWYXIobmFtZSwgYm91bmRFeHByZXNzaW9uKSB7XG4gICAgdGhpcy50eXBlID0gYm91bmRFeHByZXNzaW9uLnR5cGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmJvdW5kRXhwcmVzc2lvbiA9IGJvdW5kRXhwcmVzc2lvbjtcbn07XG5WYXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyIHx8IHR5cGVvZiBhcmdzWzFdICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignXFwndmFyXFwnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RyaW5nIGxpdGVyYWwgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBuYW1lID0gYXJnc1sxXTtcbiAgICBpZiAoIWNvbnRleHQuc2NvcGUuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdVbmtub3duIHZhcmlhYmxlIFwiJyArIG5hbWUgKyAnXCIuIE1ha2Ugc3VyZSBcIicgKyBuYW1lICsgJ1wiIGhhcyBiZWVuIGJvdW5kIGluIGFuIGVuY2xvc2luZyBcImxldFwiIGV4cHJlc3Npb24gYmVmb3JlIHVzaW5nIGl0LicsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZhcihuYW1lLCBjb250ZXh0LnNjb3BlLmdldChuYW1lKSk7XG59O1xuVmFyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHJldHVybiB0aGlzLmJvdW5kRXhwcmVzc2lvbi5ldmFsdWF0ZShjdHgpO1xufTtcblZhci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKCkge1xufTtcblZhci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblZhci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICd2YXInLFxuICAgICAgICB0aGlzLm5hbWVcbiAgICBdO1xufTtcblxudmFyIFBhcnNpbmdDb250ZXh0ID0gZnVuY3Rpb24gUGFyc2luZ0NvbnRleHQocmVnaXN0cnksIHBhdGgsIGV4cGVjdGVkVHlwZSwgc2NvcGUsIGVycm9ycykge1xuICAgIGlmIChwYXRoID09PSB2b2lkIDApXG4gICAgICAgIHBhdGggPSBbXTtcbiAgICBpZiAoc2NvcGUgPT09IHZvaWQgMClcbiAgICAgICAgc2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICBpZiAoZXJyb3JzID09PSB2b2lkIDApXG4gICAgICAgIGVycm9ycyA9IFtdO1xuICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMua2V5ID0gcGF0aC5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuICdbJyArIHBhcnQgKyAnXSc7XG4gICAgfSkuam9pbignJyk7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMuZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlO1xufTtcblBhcnNpbmdDb250ZXh0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGV4cHIsIGluZGV4LCBleHBlY3RlZFR5cGUsIGJpbmRpbmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMClcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIGlmIChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQoaW5kZXgsIGV4cGVjdGVkVHlwZSwgYmluZGluZ3MpLl9wYXJzZShleHByLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlKGV4cHIsIG9wdGlvbnMpO1xufTtcblBhcnNpbmdDb250ZXh0LnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbiBfcGFyc2UoZXhwciwgb3B0aW9ucykge1xuICAgIGlmIChleHByID09PSBudWxsIHx8IHR5cGVvZiBleHByID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZXhwciA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBleHByID09PSAnbnVtYmVyJykge1xuICAgICAgICBleHByID0gW1xuICAgICAgICAgICAgJ2xpdGVyYWwnLFxuICAgICAgICAgICAgZXhwclxuICAgICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbm5vdGF0ZShwYXJzZWQsIHR5cGUsIHR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlQW5ub3RhdGlvbiA9PT0gJ2Fzc2VydCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHR5cGUsIFtwYXJzZWRdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlQW5ub3RhdGlvbiA9PT0gJ2NvZXJjZScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29lcmNpb24odHlwZSwgW3BhcnNlZF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShleHByKSkge1xuICAgICAgICBpZiAoZXhwci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50LiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgW11dLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IGV4cHJbMF07XG4gICAgICAgIGlmICh0eXBlb2Ygb3AgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCdFeHByZXNzaW9uIG5hbWUgbXVzdCBiZSBhIHN0cmluZywgYnV0IGZvdW5kICcgKyB0eXBlb2Ygb3AgKyAnIGluc3RlYWQuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uJywgMCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgRXhwciA9IHRoaXMucmVnaXN0cnlbb3BdO1xuICAgICAgICBpZiAoRXhwcikge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IEV4cHIucGFyc2UoZXhwciwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gdGhpcy5leHBlY3RlZFR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbCA9IHBhcnNlZC50eXBlO1xuICAgICAgICAgICAgICAgIGlmICgoZXhwZWN0ZWQua2luZCA9PT0gJ3N0cmluZycgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ251bWJlcicgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ2Jvb2xlYW4nIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdvYmplY3QnIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdhcnJheScpICYmIGFjdHVhbC5raW5kID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGFubm90YXRlKHBhcnNlZCwgZXhwZWN0ZWQsIG9wdGlvbnMudHlwZUFubm90YXRpb24gfHwgJ2Fzc2VydCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGV4cGVjdGVkLmtpbmQgPT09ICdjb2xvcicgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ2Zvcm1hdHRlZCcgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSAmJiAoYWN0dWFsLmtpbmQgPT09ICd2YWx1ZScgfHwgYWN0dWFsLmtpbmQgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBhbm5vdGF0ZShwYXJzZWQsIGV4cGVjdGVkLCBvcHRpb25zLnR5cGVBbm5vdGF0aW9uIHx8ICdjb2VyY2UnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCBhY3R1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHBhcnNlZCBpbnN0YW5jZW9mIExpdGVyYWwpICYmIHBhcnNlZC50eXBlLmtpbmQgIT09ICdyZXNvbHZlZEltYWdlJyAmJiBpc0NvbnN0YW50KHBhcnNlZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWMgPSBuZXcgRXZhbHVhdGlvbkNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBuZXcgTGl0ZXJhbChwYXJzZWQudHlwZSwgcGFyc2VkLmV2YWx1YXRlKGVjKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1Vua25vd24gZXhwcmVzc2lvbiBcIicgKyBvcCArICdcIi4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS4nLCAwKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignXFwndW5kZWZpbmVkXFwnIHZhbHVlIGludmFsaWQuIFVzZSBudWxsIGluc3RlYWQuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0JhcmUgb2JqZWN0cyBpbnZhbGlkLiBVc2UgW1wibGl0ZXJhbFwiLCB7Li4ufV0gaW5zdGVhZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCBmb3VuZCAnICsgdHlwZW9mIGV4cHIgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxufTtcblBhcnNpbmdDb250ZXh0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQoaW5kZXgsIGV4cGVjdGVkVHlwZSwgYmluZGluZ3MpIHtcbiAgICB2YXIgcGF0aCA9IHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgPyB0aGlzLnBhdGguY29uY2F0KGluZGV4KSA6IHRoaXMucGF0aDtcbiAgICB2YXIgc2NvcGUgPSBiaW5kaW5ncyA/IHRoaXMuc2NvcGUuY29uY2F0KGJpbmRpbmdzKSA6IHRoaXMuc2NvcGU7XG4gICAgcmV0dXJuIG5ldyBQYXJzaW5nQ29udGV4dCh0aGlzLnJlZ2lzdHJ5LCBwYXRoLCBleHBlY3RlZFR5cGUgfHwgbnVsbCwgc2NvcGUsIHRoaXMuZXJyb3JzKTtcbn07XG5QYXJzaW5nQ29udGV4dC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlcnJvciQxKSB7XG4gICAgdmFyIGtleXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGxlbi0tID4gMClcbiAgICAgICAga2V5c1tsZW5dID0gYXJndW1lbnRzW2xlbiArIDFdO1xuICAgIHZhciBrZXkgPSAnJyArIHRoaXMua2V5ICsga2V5cy5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuICdbJyArIGsgKyAnXSc7XG4gICAgfSkuam9pbignJyk7XG4gICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2luZ0Vycm9yKGtleSwgZXJyb3IkMSkpO1xufTtcblBhcnNpbmdDb250ZXh0LnByb3RvdHlwZS5jaGVja1N1YnR5cGUgPSBmdW5jdGlvbiBjaGVja1N1YnR5cGUkMShleHBlY3RlZCwgdCkge1xuICAgIHZhciBlcnJvciA9IGNoZWNrU3VidHlwZShleHBlY3RlZCwgdCk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59O1xuZnVuY3Rpb24gaXNDb25zdGFudChleHByZXNzaW9uKSB7XG4gICAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBWYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29uc3RhbnQoZXhwcmVzc2lvbi5ib3VuZEV4cHJlc3Npb24pO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbiAmJiBleHByZXNzaW9uLm5hbWUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIENvbGxhdG9yRXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgV2l0aGluKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGlzVHlwZUFubm90YXRpb24gPSBleHByZXNzaW9uIGluc3RhbmNlb2YgQ29lcmNpb24gfHwgZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFzc2VydGlvbjtcbiAgICB2YXIgY2hpbGRyZW5Db25zdGFudCA9IHRydWU7XG4gICAgZXhwcmVzc2lvbi5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChpc1R5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICBjaGlsZHJlbkNvbnN0YW50ID0gY2hpbGRyZW5Db25zdGFudCAmJiBpc0NvbnN0YW50KGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkcmVuQ29uc3RhbnQgPSBjaGlsZHJlbkNvbnN0YW50ICYmIGNoaWxkIGluc3RhbmNlb2YgTGl0ZXJhbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hpbGRyZW5Db25zdGFudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0ZlYXR1cmVDb25zdGFudChleHByZXNzaW9uKSAmJiBpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoZXhwcmVzc2lvbiwgW1xuICAgICAgICAnem9vbScsXG4gICAgICAgICdoZWF0bWFwLWRlbnNpdHknLFxuICAgICAgICAnbGluZS1wcm9ncmVzcycsXG4gICAgICAgICdhY2N1bXVsYXRlZCcsXG4gICAgICAgICdpcy1zdXBwb3J0ZWQtc2NyaXB0J1xuICAgIF0pO1xufVxuXG5mdW5jdGlvbiBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHN0b3BzLCBpbnB1dCkge1xuICAgIHZhciBsYXN0SW5kZXggPSBzdG9wcy5sZW5ndGggLSAxO1xuICAgIHZhciBsb3dlckluZGV4ID0gMDtcbiAgICB2YXIgdXBwZXJJbmRleCA9IGxhc3RJbmRleDtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gMDtcbiAgICB2YXIgY3VycmVudFZhbHVlLCBuZXh0VmFsdWU7XG4gICAgd2hpbGUgKGxvd2VySW5kZXggPD0gdXBwZXJJbmRleCkge1xuICAgICAgICBjdXJyZW50SW5kZXggPSBNYXRoLmZsb29yKChsb3dlckluZGV4ICsgdXBwZXJJbmRleCkgLyAyKTtcbiAgICAgICAgY3VycmVudFZhbHVlID0gc3RvcHNbY3VycmVudEluZGV4XTtcbiAgICAgICAgbmV4dFZhbHVlID0gc3RvcHNbY3VycmVudEluZGV4ICsgMV07XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgPD0gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IGxhc3RJbmRleCB8fCBpbnB1dCA8IG5leHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb3dlckluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPiBpbnB1dCkge1xuICAgICAgICAgICAgdXBwZXJJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdJbnB1dCBpcyBub3QgYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5cbnZhciBTdGVwID0gZnVuY3Rpb24gU3RlcCh0eXBlLCBpbnB1dCwgc3RvcHMpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RvcHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByZWYgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgbGFiZWwgPSByZWZbMF07XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcmVmWzFdO1xuICAgICAgICB0aGlzLmxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgfVxufTtcblN0ZXAucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIC0gMSA8IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnLicpO1xuICAgIH1cbiAgICBpZiAoKGFyZ3MubGVuZ3RoIC0gMSkgJSAyICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuJyk7XG4gICAgfVxuICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHN0b3BzID0gW107XG4gICAgdmFyIG91dHB1dFR5cGUgPSBudWxsO1xuICAgIGlmIChjb250ZXh0LmV4cGVjdGVkVHlwZSAmJiBjb250ZXh0LmV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGkgPT09IDEgPyAtSW5maW5pdHkgOiBhcmdzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgdmFyIGxhYmVsS2V5ID0gaTtcbiAgICAgICAgdmFyIHZhbHVlS2V5ID0gaSArIDE7XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcInN0ZXBcIiBleHByZXNzaW9ucyBtdXN0IGJlIGRlZmluZWQgdXNpbmcgbGl0ZXJhbCBudW1lcmljIHZhbHVlcyAobm90IGNvbXB1dGVkIGV4cHJlc3Npb25zKSBmb3IgdGhlIGlucHV0IHZhbHVlcy4nLCBsYWJlbEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3BzLmxlbmd0aCAmJiBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXVswXSA+PSBsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJzdGVwXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBhcnJhbmdlZCB3aXRoIGlucHV0IHZhbHVlcyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuJywgbGFiZWxLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCB2YWx1ZUtleSwgb3V0cHV0VHlwZSk7XG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCBwYXJzZWQudHlwZTtcbiAgICAgICAgc3RvcHMucHVzaChbXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIHBhcnNlZFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdGVwKG91dHB1dFR5cGUsIGlucHV0LCBzdG9wcyk7XG59O1xuU3RlcC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgbGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgdmFyIG91dHB1dHMgPSB0aGlzLm91dHB1dHM7XG4gICAgaWYgKGxhYmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgIGlmICh2YWx1ZSA8PSBsYWJlbHNbMF0pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gICAgdmFyIHN0b3BDb3VudCA9IGxhYmVscy5sZW5ndGg7XG4gICAgaWYgKHZhbHVlID49IGxhYmVsc1tzdG9wQ291bnQgLSAxXSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0c1tzdG9wQ291bnQgLSAxXS5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKGxhYmVscywgdmFsdWUpO1xuICAgIHJldHVybiBvdXRwdXRzW2luZGV4XS5ldmFsdWF0ZShjdHgpO1xufTtcblN0ZXAucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5vdXRwdXRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGxpc3RbaV07XG4gICAgICAgIGZuKGV4cHJlc3Npb24pO1xuICAgIH1cbn07XG5TdGVwLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSk7XG59O1xuU3RlcC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gW1xuICAgICAgICAnc3RlcCcsXG4gICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKClcbiAgICBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5sYWJlbHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm91dHB1dHNbaV0uc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDggQXBwbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgQVBQTEUgSU5DLiBgYEFTIElTJycgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICogUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIEFQUExFIElOQy4gT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZXG4gKiBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBQb3J0ZWQgZnJvbSBXZWJraXRcbiAqIGh0dHA6Ly9zdm4ud2Via2l0Lm9yZy9yZXBvc2l0b3J5L3dlYmtpdC90cnVuay9Tb3VyY2UvV2ViQ29yZS9wbGF0Zm9ybS9ncmFwaGljcy9Vbml0QmV6aWVyLmhcbiAqL1xuXG52YXIgdW5pdGJlemllciA9IFVuaXRCZXppZXI7XG5cbmZ1bmN0aW9uIFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cywgaW1wbGljaXQgZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHMgYXJlICgwLDApIGFuZCAoMSwxKS5cbiAgICB0aGlzLmN4ID0gMy4wICogcDF4O1xuICAgIHRoaXMuYnggPSAzLjAgKiAocDJ4IC0gcDF4KSAtIHRoaXMuY3g7XG4gICAgdGhpcy5heCA9IDEuMCAtIHRoaXMuY3ggLSB0aGlzLmJ4O1xuXG4gICAgdGhpcy5jeSA9IDMuMCAqIHAxeTtcbiAgICB0aGlzLmJ5ID0gMy4wICogKHAyeSAtIHAxeSkgLSB0aGlzLmN5O1xuICAgIHRoaXMuYXkgPSAxLjAgLSB0aGlzLmN5IC0gdGhpcy5ieTtcblxuICAgIHRoaXMucDF4ID0gcDF4O1xuICAgIHRoaXMucDF5ID0gcDJ5O1xuICAgIHRoaXMucDJ4ID0gcDJ4O1xuICAgIHRoaXMucDJ5ID0gcDJ5O1xufVxuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgLy8gYGF4IHReMyArIGJ4IHReMiArIGN4IHQnIGV4cGFuZGVkIHVzaW5nIEhvcm5lcidzIHJ1bGUuXG4gICAgcmV0dXJuICgodGhpcy5heCAqIHQgKyB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVkgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgodGhpcy5heSAqIHQgKyB0aGlzLmJ5KSAqIHQgKyB0aGlzLmN5KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAoMy4wICogdGhpcy5heCAqIHQgKyAyLjAgKiB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgaWYgKHR5cGVvZiBlcHNpbG9uID09PSAndW5kZWZpbmVkJykgeyBlcHNpbG9uID0gMWUtNjsgfVxuXG4gICAgdmFyIHQwLCB0MSwgdDIsIHgyLCBpO1xuXG4gICAgLy8gRmlyc3QgdHJ5IGEgZmV3IGl0ZXJhdGlvbnMgb2YgTmV3dG9uJ3MgbWV0aG9kIC0tIG5vcm1hbGx5IHZlcnkgZmFzdC5cbiAgICBmb3IgKHQyID0geCwgaSA9IDA7IGkgPCA4OyBpKyspIHtcblxuICAgICAgICB4MiA9IHRoaXMuc2FtcGxlQ3VydmVYKHQyKSAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MikgPCBlcHNpbG9uKSB7IHJldHVybiB0MjsgfVxuXG4gICAgICAgIHZhciBkMiA9IHRoaXMuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyhkMikgPCAxZS02KSB7IGJyZWFrOyB9XG5cbiAgICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGZvciByZWxpYWJpbGl0eS5cbiAgICB0MCA9IDAuMDtcbiAgICB0MSA9IDEuMDtcbiAgICB0MiA9IHg7XG5cbiAgICBpZiAodDIgPCB0MCkgeyByZXR1cm4gdDA7IH1cbiAgICBpZiAodDIgPiB0MSkgeyByZXR1cm4gdDE7IH1cblxuICAgIHdoaWxlICh0MCA8IHQxKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MiAtIHgpIDwgZXBzaWxvbikgeyByZXR1cm4gdDI7IH1cblxuICAgICAgICBpZiAoeCA+IHgyKSB7XG4gICAgICAgICAgICB0MCA9IHQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdDEgPSB0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHQyID0gKHQxIC0gdDApICogMC41ICsgdDA7XG4gICAgfVxuXG4gICAgLy8gRmFpbHVyZS5cbiAgICByZXR1cm4gdDI7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVDdXJ2ZVkodGhpcy5zb2x2ZUN1cnZlWCh4LCBlcHNpbG9uKSk7XG59O1xuXG5mdW5jdGlvbiBudW1iZXIoYSwgYiwgdCkge1xuICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xufVxuZnVuY3Rpb24gY29sb3IoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKG51bWJlcihmcm9tLnIsIHRvLnIsIHQpLCBudW1iZXIoZnJvbS5nLCB0by5nLCB0KSwgbnVtYmVyKGZyb20uYiwgdG8uYiwgdCksIG51bWJlcihmcm9tLmEsIHRvLmEsIHQpKTtcbn1cbmZ1bmN0aW9uIGFycmF5JDEoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gZnJvbS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcihkLCB0b1tpXSwgdCk7XG4gICAgfSk7XG59XG5cbnZhciBpbnRlcnBvbGF0ZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBudW1iZXI6IG51bWJlcixcbiAgY29sb3I6IGNvbG9yLFxuICBhcnJheTogYXJyYXkkMVxufSk7XG5cbnZhciBYbiA9IDAuOTUwNDcsIFluID0gMSwgWm4gPSAxLjA4ODgzLCB0MCA9IDQgLyAyOSwgdDEgPSA2IC8gMjksIHQyID0gMyAqIHQxICogdDEsIHQzID0gdDEgKiB0MSAqIHQxLCBkZWcycmFkID0gTWF0aC5QSSAvIDE4MCwgcmFkMmRlZyA9IDE4MCAvIE1hdGguUEk7XG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG59XG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cbmZ1bmN0aW9uIHh5ejJyZ2IoeCkge1xuICAgIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuZnVuY3Rpb24gcmdiMnh5eih4KSB7XG4gICAgeCAvPSAyNTU7XG4gICAgcmV0dXJuIHggPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5mdW5jdGlvbiByZ2JUb0xhYihyZ2JDb2xvcikge1xuICAgIHZhciBiID0gcmdiMnh5eihyZ2JDb2xvci5yKSwgYSA9IHJnYjJ4eXoocmdiQ29sb3IuZyksIGwgPSByZ2IyeHl6KHJnYkNvbG9yLmIpLCB4ID0geHl6MmxhYigoMC40MTI0NTY0ICogYiArIDAuMzU3NTc2MSAqIGEgKyAwLjE4MDQzNzUgKiBsKSAvIFhuKSwgeSA9IHh5ejJsYWIoKDAuMjEyNjcyOSAqIGIgKyAwLjcxNTE1MjIgKiBhICsgMC4wNzIxNzUgKiBsKSAvIFluKSwgeiA9IHh5ejJsYWIoKDAuMDE5MzMzOSAqIGIgKyAwLjExOTE5MiAqIGEgKyAwLjk1MDMwNDEgKiBsKSAvIFpuKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsOiAxMTYgKiB5IC0gMTYsXG4gICAgICAgIGE6IDUwMCAqICh4IC0geSksXG4gICAgICAgIGI6IDIwMCAqICh5IC0geiksXG4gICAgICAgIGFscGhhOiByZ2JDb2xvci5hXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxhYlRvUmdiKGxhYkNvbG9yKSB7XG4gICAgdmFyIHkgPSAobGFiQ29sb3IubCArIDE2KSAvIDExNiwgeCA9IGlzTmFOKGxhYkNvbG9yLmEpID8geSA6IHkgKyBsYWJDb2xvci5hIC8gNTAwLCB6ID0gaXNOYU4obGFiQ29sb3IuYikgPyB5IDogeSAtIGxhYkNvbG9yLmIgLyAyMDA7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih4eXoycmdiKDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeiksIHh5ejJyZ2IoLTAuOTY5MjY2ICogeCArIDEuODc2MDEwOCAqIHkgKyAwLjA0MTU1NiAqIHopLCB4eXoycmdiKDAuMDU1NjQzNCAqIHggLSAwLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeiksIGxhYkNvbG9yLmFscGhhKTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlTGFiKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbDogbnVtYmVyKGZyb20ubCwgdG8ubCwgdCksXG4gICAgICAgIGE6IG51bWJlcihmcm9tLmEsIHRvLmEsIHQpLFxuICAgICAgICBiOiBudW1iZXIoZnJvbS5iLCB0by5iLCB0KSxcbiAgICAgICAgYWxwaGE6IG51bWJlcihmcm9tLmFscGhhLCB0by5hbHBoYSwgdClcbiAgICB9O1xufVxuZnVuY3Rpb24gcmdiVG9IY2wocmdiQ29sb3IpIHtcbiAgICB2YXIgcmVmID0gcmdiVG9MYWIocmdiQ29sb3IpO1xuICAgIHZhciBsID0gcmVmLmw7XG4gICAgdmFyIGEgPSByZWYuYTtcbiAgICB2YXIgYiA9IHJlZi5iO1xuICAgIHZhciBoID0gTWF0aC5hdGFuMihiLCBhKSAqIHJhZDJkZWc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaDogaCA8IDAgPyBoICsgMzYwIDogaCxcbiAgICAgICAgYzogTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpLFxuICAgICAgICBsOiBsLFxuICAgICAgICBhbHBoYTogcmdiQ29sb3IuYVxuICAgIH07XG59XG5mdW5jdGlvbiBoY2xUb1JnYihoY2xDb2xvcikge1xuICAgIHZhciBoID0gaGNsQ29sb3IuaCAqIGRlZzJyYWQsIGMgPSBoY2xDb2xvci5jLCBsID0gaGNsQ29sb3IubDtcbiAgICByZXR1cm4gbGFiVG9SZ2Ioe1xuICAgICAgICBsOiBsLFxuICAgICAgICBhOiBNYXRoLmNvcyhoKSAqIGMsXG4gICAgICAgIGI6IE1hdGguc2luKGgpICogYyxcbiAgICAgICAgYWxwaGE6IGhjbENvbG9yLmFscGhhXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUh1ZShhLCBiLCB0KSB7XG4gICAgdmFyIGQgPSBiIC0gYTtcbiAgICByZXR1cm4gYSArIHQgKiAoZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCk7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUhjbChmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGg6IGludGVycG9sYXRlSHVlKGZyb20uaCwgdG8uaCwgdCksXG4gICAgICAgIGM6IG51bWJlcihmcm9tLmMsIHRvLmMsIHQpLFxuICAgICAgICBsOiBudW1iZXIoZnJvbS5sLCB0by5sLCB0KSxcbiAgICAgICAgYWxwaGE6IG51bWJlcihmcm9tLmFscGhhLCB0by5hbHBoYSwgdClcbiAgICB9O1xufVxudmFyIGxhYiA9IHtcbiAgICBmb3J3YXJkOiByZ2JUb0xhYixcbiAgICByZXZlcnNlOiBsYWJUb1JnYixcbiAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGVMYWJcbn07XG52YXIgaGNsID0ge1xuICAgIGZvcndhcmQ6IHJnYlRvSGNsLFxuICAgIHJldmVyc2U6IGhjbFRvUmdiLFxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZUhjbFxufTtcblxudmFyIGNvbG9yU3BhY2VzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGxhYjogbGFiLFxuICBoY2w6IGhjbFxufSk7XG5cbnZhciBJbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIEludGVycG9sYXRlKHR5cGUsIG9wZXJhdG9yLCBpbnRlcnBvbGF0aW9uLCBpbnB1dCwgc3RvcHMpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RvcHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByZWYgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgbGFiZWwgPSByZWZbMF07XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcmVmWzFdO1xuICAgICAgICB0aGlzLmxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgfVxufTtcbkludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IgPSBmdW5jdGlvbiBpbnRlcnBvbGF0aW9uRmFjdG9yKGludGVycG9sYXRpb24sIGlucHV0LCBsb3dlciwgdXBwZXIpIHtcbiAgICB2YXIgdCA9IDA7XG4gICAgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICB0ID0gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCBpbnRlcnBvbGF0aW9uLmJhc2UsIGxvd2VyLCB1cHBlcik7XG4gICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIHQgPSBleHBvbmVudGlhbEludGVycG9sYXRpb24oaW5wdXQsIDEsIGxvd2VyLCB1cHBlcik7XG4gICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdjdWJpYy1iZXppZXInKSB7XG4gICAgICAgIHZhciBjID0gaW50ZXJwb2xhdGlvbi5jb250cm9sUG9pbnRzO1xuICAgICAgICB2YXIgdWIgPSBuZXcgdW5pdGJlemllcihjWzBdLCBjWzFdLCBjWzJdLCBjWzNdKTtcbiAgICAgICAgdCA9IHViLnNvbHZlKGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgMSwgbG93ZXIsIHVwcGVyKSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcbkludGVycG9sYXRlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIHZhciBvcGVyYXRvciA9IGFyZ3NbMF07XG4gICAgdmFyIGludGVycG9sYXRpb24gPSBhcmdzWzFdO1xuICAgIHZhciBpbnB1dCA9IGFyZ3NbMl07XG4gICAgdmFyIHJlc3QgPSBhcmdzLnNsaWNlKDMpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnRlcnBvbGF0aW9uKSB8fCBpbnRlcnBvbGF0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYW4gaW50ZXJwb2xhdGlvbiB0eXBlIGV4cHJlc3Npb24uJywgMSk7XG4gICAgfVxuICAgIGlmIChpbnRlcnBvbGF0aW9uWzBdID09PSAnbGluZWFyJykge1xuICAgICAgICBpbnRlcnBvbGF0aW9uID0geyBuYW1lOiAnbGluZWFyJyB9O1xuICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvblswXSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICB2YXIgYmFzZSA9IGludGVycG9sYXRpb25bMV07XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGEgbnVtZXJpYyBiYXNlLicsIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGludGVycG9sYXRpb24gPSB7XG4gICAgICAgICAgICBuYW1lOiAnZXhwb25lbnRpYWwnLFxuICAgICAgICAgICAgYmFzZTogYmFzZVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvblswXSA9PT0gJ2N1YmljLWJlemllcicpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBpbnRlcnBvbGF0aW9uLnNsaWNlKDEpO1xuICAgICAgICBpZiAoY29udHJvbFBvaW50cy5sZW5ndGggIT09IDQgfHwgY29udHJvbFBvaW50cy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0ICE9PSAnbnVtYmVyJyB8fCB0IDwgMCB8fCB0ID4gMTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignQ3ViaWMgYmV6aWVyIGludGVycG9sYXRpb24gcmVxdWlyZXMgZm91ciBudW1lcmljIGFyZ3VtZW50cyB3aXRoIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuJywgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJwb2xhdGlvbiA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjdWJpYy1iZXppZXInLFxuICAgICAgICAgICAgY29udHJvbFBvaW50czogY29udHJvbFBvaW50c1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdVbmtub3duIGludGVycG9sYXRpb24gdHlwZSAnICsgU3RyaW5nKGludGVycG9sYXRpb25bMF0pLCAxLCAwKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoIC0gMSA8IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnLicpO1xuICAgIH1cbiAgICBpZiAoKGFyZ3MubGVuZ3RoIC0gMSkgJSAyICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuJyk7XG4gICAgfVxuICAgIGlucHV0ID0gY29udGV4dC5wYXJzZShpbnB1dCwgMiwgTnVtYmVyVHlwZSk7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHN0b3BzID0gW107XG4gICAgdmFyIG91dHB1dFR5cGUgPSBudWxsO1xuICAgIGlmIChvcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlLWhjbCcgfHwgb3BlcmF0b3IgPT09ICdpbnRlcnBvbGF0ZS1sYWInKSB7XG4gICAgICAgIG91dHB1dFR5cGUgPSBDb2xvclR5cGU7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0LmV4cGVjdGVkVHlwZSAmJiBjb250ZXh0LmV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IHJlc3RbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3RbaSArIDFdO1xuICAgICAgICB2YXIgbGFiZWxLZXkgPSBpICsgMztcbiAgICAgICAgdmFyIHZhbHVlS2V5ID0gaSArIDQ7XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgbGFiZWxLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wcy5sZW5ndGggJiYgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV1bMF0gPj0gbGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBtdXN0IGJlIGFycmFuZ2VkIHdpdGggaW5wdXQgdmFsdWVzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4nLCBsYWJlbEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnNlZCA9IGNvbnRleHQucGFyc2UodmFsdWUsIHZhbHVlS2V5LCBvdXRwdXRUeXBlKTtcbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHBhcnNlZC50eXBlO1xuICAgICAgICBzdG9wcy5wdXNoKFtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgcGFyc2VkXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAob3V0cHV0VHlwZS5raW5kICE9PSAnbnVtYmVyJyAmJiBvdXRwdXRUeXBlLmtpbmQgIT09ICdjb2xvcicgJiYgIShvdXRwdXRUeXBlLmtpbmQgPT09ICdhcnJheScgJiYgb3V0cHV0VHlwZS5pdGVtVHlwZS5raW5kID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb3V0cHV0VHlwZS5OID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1R5cGUgJyArIHRvU3RyaW5nKG91dHB1dFR5cGUpICsgJyBpcyBub3QgaW50ZXJwb2xhdGFibGUuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGUob3V0cHV0VHlwZSwgb3BlcmF0b3IsIGludGVycG9sYXRpb24sIGlucHV0LCBzdG9wcyk7XG59O1xuSW50ZXJwb2xhdGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgdmFyIGxhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgIHZhciBvdXRwdXRzID0gdGhpcy5vdXRwdXRzO1xuICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAodmFsdWUgPD0gbGFiZWxzWzBdKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICAgIHZhciBzdG9wQ291bnQgPSBsYWJlbHMubGVuZ3RoO1xuICAgIGlmICh2YWx1ZSA+PSBsYWJlbHNbc3RvcENvdW50IC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbc3RvcENvdW50IC0gMV0uZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhsYWJlbHMsIHZhbHVlKTtcbiAgICB2YXIgbG93ZXIgPSBsYWJlbHNbaW5kZXhdO1xuICAgIHZhciB1cHBlciA9IGxhYmVsc1tpbmRleCArIDFdO1xuICAgIHZhciB0ID0gSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvcih0aGlzLmludGVycG9sYXRpb24sIHZhbHVlLCBsb3dlciwgdXBwZXIpO1xuICAgIHZhciBvdXRwdXRMb3dlciA9IG91dHB1dHNbaW5kZXhdLmV2YWx1YXRlKGN0eCk7XG4gICAgdmFyIG91dHB1dFVwcGVyID0gb3V0cHV0c1tpbmRleCArIDFdLmV2YWx1YXRlKGN0eCk7XG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICdpbnRlcnBvbGF0ZScpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlW3RoaXMudHlwZS5raW5kLnRvTG93ZXJDYXNlKCldKG91dHB1dExvd2VyLCBvdXRwdXRVcHBlciwgdCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUtaGNsJykge1xuICAgICAgICByZXR1cm4gaGNsLnJldmVyc2UoaGNsLmludGVycG9sYXRlKGhjbC5mb3J3YXJkKG91dHB1dExvd2VyKSwgaGNsLmZvcndhcmQob3V0cHV0VXBwZXIpLCB0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxhYi5yZXZlcnNlKGxhYi5pbnRlcnBvbGF0ZShsYWIuZm9yd2FyZChvdXRwdXRMb3dlciksIGxhYi5mb3J3YXJkKG91dHB1dFVwcGVyKSwgdCkpO1xuICAgIH1cbn07XG5JbnRlcnBvbGF0ZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5pbnB1dCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLm91dHB1dHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gbGlzdFtpXTtcbiAgICAgICAgZm4oZXhwcmVzc2lvbik7XG4gICAgfVxufTtcbkludGVycG9sYXRlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSk7XG59O1xuSW50ZXJwb2xhdGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICB2YXIgaW50ZXJwb2xhdGlvbjtcbiAgICBpZiAodGhpcy5pbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGludGVycG9sYXRpb24gPSBbJ2xpbmVhciddO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5iYXNlID09PSAxKSB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uID0gWydsaW5lYXInXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycG9sYXRpb24gPSBbXG4gICAgICAgICAgICAgICAgJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb24uYmFzZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRpb24gPSBbJ2N1YmljLWJlemllciddLmNvbmNhdCh0aGlzLmludGVycG9sYXRpb24uY29udHJvbFBvaW50cyk7XG4gICAgfVxuICAgIHZhciBzZXJpYWxpemVkID0gW1xuICAgICAgICB0aGlzLm9wZXJhdG9yLFxuICAgICAgICBpbnRlcnBvbGF0aW9uLFxuICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXG4gICAgXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLmxhYmVsc1tpXSwgdGhpcy5vdXRwdXRzW2ldLnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuZnVuY3Rpb24gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCBiYXNlLCBsb3dlclZhbHVlLCB1cHBlclZhbHVlKSB7XG4gICAgdmFyIGRpZmZlcmVuY2UgPSB1cHBlclZhbHVlIC0gbG93ZXJWYWx1ZTtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBpbnB1dCAtIGxvd2VyVmFsdWU7XG4gICAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChiYXNlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwcm9ncmVzcyAvIGRpZmZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyhiYXNlLCBwcm9ncmVzcykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCBkaWZmZXJlbmNlKSAtIDEpO1xuICAgIH1cbn1cblxudmFyIENvYWxlc2NlID0gZnVuY3Rpb24gQ29hbGVzY2UodHlwZSwgYXJncykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbn07XG5Db2FsZXNjZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBvdXRwdXRUeXBlID0gbnVsbDtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG4gICAgaWYgKGV4cGVjdGVkVHlwZSAmJiBleHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICBvdXRwdXRUeXBlID0gZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICB2YXIgcGFyc2VkQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gYXJncy5zbGljZSgxKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGFyZyA9IGxpc3RbaV07XG4gICAgICAgIHZhciBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKGFyZywgMSArIHBhcnNlZEFyZ3MubGVuZ3RoLCBvdXRwdXRUeXBlLCB1bmRlZmluZWQsIHsgdHlwZUFubm90YXRpb246ICdvbWl0JyB9KTtcbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHBhcnNlZC50eXBlO1xuICAgICAgICBwYXJzZWRBcmdzLnB1c2gocGFyc2VkKTtcbiAgICB9XG4gICAgdmFyIG5lZWRzQW5ub3RhdGlvbiA9IGV4cGVjdGVkVHlwZSAmJiBwYXJzZWRBcmdzLnNvbWUoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gY2hlY2tTdWJ0eXBlKGV4cGVjdGVkVHlwZSwgYXJnLnR5cGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZWVkc0Fubm90YXRpb24gPyBuZXcgQ29hbGVzY2UoVmFsdWVUeXBlLCBwYXJzZWRBcmdzKSA6IG5ldyBDb2FsZXNjZShvdXRwdXRUeXBlLCBwYXJzZWRBcmdzKTtcbn07XG5Db2FsZXNjZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgYXJnQ291bnQgPSAwO1xuICAgIHZhciByZXF1ZXN0ZWRJbWFnZU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLmFyZ3M7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBhcmcgPSBsaXN0W2ldO1xuICAgICAgICBhcmdDb3VudCsrO1xuICAgICAgICByZXN1bHQgPSBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlICYmICFyZXN1bHQuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBpZiAoIXJlcXVlc3RlZEltYWdlTmFtZSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RlZEltYWdlTmFtZSA9IHJlc3VsdC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChhcmdDb3VudCA9PT0gdGhpcy5hcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcXVlc3RlZEltYWdlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbkNvYWxlc2NlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG59O1xuQ29hbGVzY2UucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnLm91dHB1dERlZmluZWQoKTtcbiAgICB9KTtcbn07XG5Db2FsZXNjZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gWydjb2FsZXNjZSddO1xuICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIExldCA9IGZ1bmN0aW9uIExldChiaW5kaW5ncywgcmVzdWx0KSB7XG4gICAgdGhpcy50eXBlID0gcmVzdWx0LnR5cGU7XG4gICAgdGhpcy5iaW5kaW5ncyA9IFtdLmNvbmNhdChiaW5kaW5ncyk7XG4gICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuTGV0LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5ldmFsdWF0ZShjdHgpO1xufTtcbkxldC5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLmJpbmRpbmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYmluZGluZyA9IGxpc3RbaV07XG4gICAgICAgIGZuKGJpbmRpbmdbMV0pO1xuICAgIH1cbiAgICBmbih0aGlzLnJlc3VsdCk7XG59O1xuTGV0LnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICB2YXIgYmluZGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIHZhciBuYW1lID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIHN0cmluZywgYnV0IGZvdW5kICcgKyB0eXBlb2YgbmFtZSArICcgaW5zdGVhZC4nLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL1teYS16QS1aMC05X10vLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdWYXJpYWJsZSBuYW1lcyBtdXN0IGNvbnRhaW4gb25seSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBvciBcXCdfXFwnLicsIGkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IGNvbnRleHQucGFyc2UoYXJnc1tpICsgMV0sIGkgKyAxKTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZ3MucHVzaChbXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbYXJncy5sZW5ndGggLSAxXSwgYXJncy5sZW5ndGggLSAxLCBjb250ZXh0LmV4cGVjdGVkVHlwZSwgYmluZGluZ3MpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExldChiaW5kaW5ncywgcmVzdWx0KTtcbn07XG5MZXQucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5vdXRwdXREZWZpbmVkKCk7XG59O1xuTGV0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2xldCddO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5iaW5kaW5nczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IGxpc3RbaV07XG4gICAgICAgIHZhciBuYW1lID0gcmVmWzBdO1xuICAgICAgICB2YXIgZXhwciA9IHJlZlsxXTtcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKG5hbWUsIGV4cHIuc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLnB1c2godGhpcy5yZXN1bHQuc2VyaWFsaXplKCkpO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIEF0ID0gZnVuY3Rpb24gQXQodHlwZSwgaW5kZXgsIGlucHV0KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xufTtcbkF0LnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgMiBhcmd1bWVudHMsIGJ1dCBmb3VuZCAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBhcnJheShjb250ZXh0LmV4cGVjdGVkVHlwZSB8fCBWYWx1ZVR5cGUpKTtcbiAgICBpZiAoIWluZGV4IHx8ICFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHQgPSBpbnB1dC50eXBlO1xuICAgIHJldHVybiBuZXcgQXQodC5pdGVtVHlwZSwgaW5kZXgsIGlucHV0KTtcbn07XG5BdC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4LmV2YWx1YXRlKGN0eCk7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kczogJyArIGluZGV4ICsgJyA8IDAuJyk7XG4gICAgfVxuICAgIGlmIChpbmRleCA+PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kczogJyArIGluZGV4ICsgJyA+ICcgKyAoYXJyYXkubGVuZ3RoIC0gMSkgKyAnLicpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IE1hdGguZmxvb3IoaW5kZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0FycmF5IGluZGV4IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGZvdW5kICcgKyBpbmRleCArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W2luZGV4XTtcbn07XG5BdC5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgZm4odGhpcy5pbmRleCk7XG4gICAgZm4odGhpcy5pbnB1dCk7XG59O1xuQXQucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5BdC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICdhdCcsXG4gICAgICAgIHRoaXMuaW5kZXguc2VyaWFsaXplKCksXG4gICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKClcbiAgICBdO1xufTtcblxudmFyIEluID0gZnVuY3Rpb24gSW4obmVlZGxlLCBoYXlzdGFjaykge1xuICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlO1xuICAgIHRoaXMubmVlZGxlID0gbmVlZGxlO1xuICAgIHRoaXMuaGF5c3RhY2sgPSBoYXlzdGFjaztcbn07XG5Jbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgJyArIChhcmdzLmxlbmd0aCAtIDEpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICB2YXIgbmVlZGxlID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgIHZhciBoYXlzdGFjayA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgVmFsdWVUeXBlKTtcbiAgICBpZiAoIW5lZWRsZSB8fCAhaGF5c3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFR5cGUobmVlZGxlLnR5cGUsIFtcbiAgICAgICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdWxsVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKG5lZWRsZS50eXBlKSArICcgaW5zdGVhZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEluKG5lZWRsZSwgaGF5c3RhY2spO1xufTtcbkluLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBuZWVkbGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShjdHgpO1xuICAgIHZhciBoYXlzdGFjayA9IHRoaXMuaGF5c3RhY2suZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAoIWhheXN0YWNrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShuZWVkbGUsIFtcbiAgICAgICAgICAgICdib29sZWFuJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAnbnVsbCdcbiAgICAgICAgXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZihuZWVkbGUpKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShoYXlzdGFjaywgW1xuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnYXJyYXknXG4gICAgICAgIF0pKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICcgKyB0b1N0cmluZyh0eXBlT2YoaGF5c3RhY2spKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKSA+PSAwO1xufTtcbkluLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLm5lZWRsZSk7XG4gICAgZm4odGhpcy5oYXlzdGFjayk7XG59O1xuSW4ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcbkluLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2luJyxcbiAgICAgICAgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksXG4gICAgICAgIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKClcbiAgICBdO1xufTtcblxudmFyIEluZGV4T2YgPSBmdW5jdGlvbiBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2ssIGZyb21JbmRleCkge1xuICAgIHRoaXMudHlwZSA9IE51bWJlclR5cGU7XG4gICAgdGhpcy5uZWVkbGUgPSBuZWVkbGU7XG4gICAgdGhpcy5oYXlzdGFjayA9IGhheXN0YWNrO1xuICAgIHRoaXMuZnJvbUluZGV4ID0gZnJvbUluZGV4O1xufTtcbkluZGV4T2YucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDIgfHwgYXJncy5sZW5ndGggPj0gNSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgdmFyIG5lZWRsZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTtcbiAgICB2YXIgaGF5c3RhY2sgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7XG4gICAgaWYgKCFuZWVkbGUgfHwgIWhheXN0YWNrKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRUeXBlKG5lZWRsZS50eXBlLCBbXG4gICAgICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVsbFR5cGUsXG4gICAgICAgICAgICBWYWx1ZVR5cGVcbiAgICAgICAgXSkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kICcgKyB0b1N0cmluZyhuZWVkbGUudHlwZSkgKyAnIGluc3RlYWQnKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSBjb250ZXh0LnBhcnNlKGFyZ3NbM10sIDMsIE51bWJlclR5cGUpO1xuICAgICAgICBpZiAoIWZyb21JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2ssIGZyb21JbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2spO1xuICAgIH1cbn07XG5JbmRleE9mLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBuZWVkbGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShjdHgpO1xuICAgIHZhciBoYXlzdGFjayA9IHRoaXMuaGF5c3RhY2suZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKG5lZWRsZSwgW1xuICAgICAgICAgICAgJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICdudWxsJ1xuICAgICAgICBdKSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodHlwZU9mKG5lZWRsZSkpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKGhheXN0YWNrLCBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdhcnJheSdcbiAgICAgICAgXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZihoYXlzdGFjaykpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IHRoaXMuZnJvbUluZGV4LmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKTtcbn07XG5JbmRleE9mLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLm5lZWRsZSk7XG4gICAgZm4odGhpcy5oYXlzdGFjayk7XG4gICAgaWYgKHRoaXMuZnJvbUluZGV4KSB7XG4gICAgICAgIGZuKHRoaXMuZnJvbUluZGV4KTtcbiAgICB9XG59O1xuSW5kZXhPZi5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbkluZGV4T2YucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5mcm9tSW5kZXggIT0gbnVsbCAmJiB0aGlzLmZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSB0aGlzLmZyb21JbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdpbmRleC1vZicsXG4gICAgICAgICAgICB0aGlzLm5lZWRsZS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCksXG4gICAgICAgICAgICBmcm9tSW5kZXhcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2luZGV4LW9mJyxcbiAgICAgICAgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksXG4gICAgICAgIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKClcbiAgICBdO1xufTtcblxudmFyIE1hdGNoID0gZnVuY3Rpb24gTWF0Y2goaW5wdXRUeXBlLCBvdXRwdXRUeXBlLCBpbnB1dCwgY2FzZXMsIG91dHB1dHMsIG90aGVyd2lzZSkge1xuICAgIHRoaXMuaW5wdXRUeXBlID0gaW5wdXRUeXBlO1xuICAgIHRoaXMudHlwZSA9IG91dHB1dFR5cGU7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgIHRoaXMub3RoZXJ3aXNlID0gb3RoZXJ3aXNlO1xufTtcbk1hdGNoLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnLicpO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggJSAyICE9PSAxKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuJyk7XG4gICAgfVxuICAgIHZhciBpbnB1dFR5cGU7XG4gICAgdmFyIG91dHB1dFR5cGU7XG4gICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICB2YXIgY2FzZXMgPSB7fTtcbiAgICB2YXIgb3V0cHV0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IGFyZ3NbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbaSArIDFdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGFiZWxzKSkge1xuICAgICAgICAgICAgbGFiZWxzID0gW2xhYmVsc107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhYmVsQ29udGV4dCA9IGNvbnRleHQuY29uY2F0KGkpO1xuICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGJyYW5jaCBsYWJlbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gbGFiZWxzOyBpJDEgPCBsaXN0Lmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGxpc3RbaSQxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFiZWwgIT09ICdudW1iZXInICYmIHR5cGVvZiBsYWJlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKCdCcmFuY2ggbGFiZWxzIG11c3QgYmUgbnVtYmVycyBvciBzdHJpbmdzLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGFiZWwgPT09ICdudW1iZXInICYmIE1hdGguYWJzKGxhYmVsKSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignQnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXJzIG5vIGxhcmdlciB0aGFuICcgKyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiArICcuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ251bWJlcicgJiYgTWF0aC5mbG9vcihsYWJlbCkgIT09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignTnVtZXJpYyBicmFuY2ggbGFiZWxzIG11c3QgYmUgaW50ZWdlciB2YWx1ZXMuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFR5cGUgPSB0eXBlT2YobGFiZWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYWJlbENvbnRleHQuY2hlY2tTdWJ0eXBlKGlucHV0VHlwZSwgdHlwZU9mKGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FzZXNbU3RyaW5nKGxhYmVsKV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignQnJhbmNoIGxhYmVscyBtdXN0IGJlIHVuaXF1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2VzW1N0cmluZyhsYWJlbCldID0gb3V0cHV0cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UodmFsdWUsIGksIG91dHB1dFR5cGUpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcmVzdWx0LnR5cGU7XG4gICAgICAgIG91dHB1dHMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICB2YXIgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG90aGVyd2lzZSA9IGNvbnRleHQucGFyc2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBhcmdzLmxlbmd0aCAtIDEsIG91dHB1dFR5cGUpO1xuICAgIGlmICghb3RoZXJ3aXNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaW5wdXQudHlwZS5raW5kICE9PSAndmFsdWUnICYmIGNvbnRleHQuY29uY2F0KDEpLmNoZWNrU3VidHlwZShpbnB1dFR5cGUsIGlucHV0LnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1hdGNoKGlucHV0VHlwZSwgb3V0cHV0VHlwZSwgaW5wdXQsIGNhc2VzLCBvdXRwdXRzLCBvdGhlcndpc2UpO1xufTtcbk1hdGNoLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICB2YXIgb3V0cHV0ID0gdHlwZU9mKGlucHV0KSA9PT0gdGhpcy5pbnB1dFR5cGUgJiYgdGhpcy5vdXRwdXRzW3RoaXMuY2FzZXNbaW5wdXRdXSB8fCB0aGlzLm90aGVyd2lzZTtcbiAgICByZXR1cm4gb3V0cHV0LmV2YWx1YXRlKGN0eCk7XG59O1xuTWF0Y2gucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgIHRoaXMub3V0cHV0cy5mb3JFYWNoKGZuKTtcbiAgICBmbih0aGlzLm90aGVyd2lzZSk7XG59O1xuTWF0Y2gucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dHMuZXZlcnkoZnVuY3Rpb24gKG91dCkge1xuICAgICAgICByZXR1cm4gb3V0Lm91dHB1dERlZmluZWQoKTtcbiAgICB9KSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7XG59O1xuTWF0Y2gucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICB2YXIgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgJ21hdGNoJyxcbiAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKVxuICAgIF07XG4gICAgdmFyIHNvcnRlZExhYmVscyA9IE9iamVjdC5rZXlzKHRoaXMuY2FzZXMpLnNvcnQoKTtcbiAgICB2YXIgZ3JvdXBlZEJ5T3V0cHV0ID0gW107XG4gICAgdmFyIG91dHB1dExvb2t1cCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc29ydGVkTGFiZWxzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSBvdXRwdXRMb29rdXBbdGhpcy5jYXNlc1tsYWJlbF1dO1xuICAgICAgICBpZiAob3V0cHV0SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3V0cHV0TG9va3VwW3RoaXMuY2FzZXNbbGFiZWxdXSA9IGdyb3VwZWRCeU91dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICBncm91cGVkQnlPdXRwdXQucHVzaChbXG4gICAgICAgICAgICAgICAgdGhpcy5jYXNlc1tsYWJlbF0sXG4gICAgICAgICAgICAgICAgW2xhYmVsXVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncm91cGVkQnlPdXRwdXRbb3V0cHV0SW5kZXhdWzFdLnB1c2gobGFiZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjb2VyY2VMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcyQxLmlucHV0VHlwZS5raW5kID09PSAnbnVtYmVyJyA/IE51bWJlcihsYWJlbCkgOiBsYWJlbDtcbiAgICB9O1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGdyb3VwZWRCeU91dHB1dDsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IGxpc3QkMVtpJDFdO1xuICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSByZWZbMF07XG4gICAgICAgIHZhciBsYWJlbHMgPSByZWZbMV07XG4gICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goY29lcmNlTGFiZWwobGFiZWxzWzBdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2gobGFiZWxzLm1hcChjb2VyY2VMYWJlbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm91dHB1dHNbb3V0cHV0SW5kZXgkMV0uc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLnB1c2godGhpcy5vdGhlcndpc2Uuc2VyaWFsaXplKCkpO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIENhc2UgPSBmdW5jdGlvbiBDYXNlKHR5cGUsIGJyYW5jaGVzLCBvdGhlcndpc2UpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYnJhbmNoZXMgPSBicmFuY2hlcztcbiAgICB0aGlzLm90aGVyd2lzZSA9IG90aGVyd2lzZTtcbn07XG5DYXNlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnLicpO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhbiBvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cy4nKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dFR5cGU7XG4gICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICB2YXIgYnJhbmNoZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCBpLCBCb29sZWFuVHlwZSk7XG4gICAgICAgIGlmICghdGVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UoYXJnc1tpICsgMV0sIGkgKyAxLCBvdXRwdXRUeXBlKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyYW5jaGVzLnB1c2goW1xuICAgICAgICAgICAgdGVzdCxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICBdKTtcbiAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcmVzdWx0LnR5cGU7XG4gICAgfVxuICAgIHZhciBvdGhlcndpc2UgPSBjb250ZXh0LnBhcnNlKGFyZ3NbYXJncy5sZW5ndGggLSAxXSwgYXJncy5sZW5ndGggLSAxLCBvdXRwdXRUeXBlKTtcbiAgICBpZiAoIW90aGVyd2lzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDYXNlKG91dHB1dFR5cGUsIGJyYW5jaGVzLCBvdGhlcndpc2UpO1xufTtcbkNhc2UucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB0aGlzLmJyYW5jaGVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmVmID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIHRlc3QgPSByZWZbMF07XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcmVmWzFdO1xuICAgICAgICBpZiAodGVzdC5ldmFsdWF0ZShjdHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ldmFsdWF0ZShjdHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm90aGVyd2lzZS5ldmFsdWF0ZShjdHgpO1xufTtcbkNhc2UucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5icmFuY2hlczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IGxpc3RbaV07XG4gICAgICAgIHZhciB0ZXN0ID0gcmVmWzBdO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJlZlsxXTtcbiAgICAgICAgZm4odGVzdCk7XG4gICAgICAgIGZuKGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBmbih0aGlzLm90aGVyd2lzZSk7XG59O1xuQ2FzZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnJhbmNoZXMuZXZlcnkoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgXyA9IHJlZlswXTtcbiAgICAgICAgdmFyIG91dCA9IHJlZlsxXTtcbiAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSkgJiYgdGhpcy5vdGhlcndpc2Uub3V0cHV0RGVmaW5lZCgpO1xufTtcbkNhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9IFsnY2FzZSddO1xuICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufTtcblxudmFyIFNsaWNlID0gZnVuY3Rpb24gU2xpY2UodHlwZSwgaW5wdXQsIGJlZ2luSW5kZXgsIGVuZEluZGV4KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5iZWdpbkluZGV4ID0gYmVnaW5JbmRleDtcbiAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG59O1xuU2xpY2UucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDIgfHwgYXJncy5sZW5ndGggPj0gNSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kICcgKyAoYXJncy5sZW5ndGggLSAxKSArICcgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgIHZhciBiZWdpbkluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBOdW1iZXJUeXBlKTtcbiAgICBpZiAoIWlucHV0IHx8ICFiZWdpbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRUeXBlKGlucHV0LnR5cGUsIFtcbiAgICAgICAgICAgIGFycmF5KFZhbHVlVHlwZSksXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0pKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICcgKyB0b1N0cmluZyhpbnB1dC50eXBlKSArICcgaW5zdGVhZCcpO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzNdLCAzLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFlbmRJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShpbnB1dC50eXBlLCBpbnB1dCwgYmVnaW5JbmRleCwgZW5kSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoaW5wdXQudHlwZSwgaW5wdXQsIGJlZ2luSW5kZXgpO1xuICAgIH1cbn07XG5TbGljZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7XG4gICAgdmFyIGJlZ2luSW5kZXggPSB0aGlzLmJlZ2luSW5kZXguZXZhbHVhdGUoY3R4KTtcbiAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKGlucHV0LCBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdhcnJheSdcbiAgICAgICAgXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcodHlwZU9mKGlucHV0KSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVuZEluZGV4KSB7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHRoaXMuZW5kSW5kZXguZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKGJlZ2luSW5kZXgsIGVuZEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnNsaWNlKGJlZ2luSW5kZXgpO1xufTtcblNsaWNlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLmlucHV0KTtcbiAgICBmbih0aGlzLmJlZ2luSW5kZXgpO1xuICAgIGlmICh0aGlzLmVuZEluZGV4KSB7XG4gICAgICAgIGZuKHRoaXMuZW5kSW5kZXgpO1xuICAgIH1cbn07XG5TbGljZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblNsaWNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuZW5kSW5kZXggIT0gbnVsbCAmJiB0aGlzLmVuZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5lbmRJbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdzbGljZScsXG4gICAgICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgZW5kSW5kZXhcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ3NsaWNlJyxcbiAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSxcbiAgICAgICAgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpXG4gICAgXTtcbn07XG5cbmZ1bmN0aW9uIGlzQ29tcGFyYWJsZVR5cGUob3AsIHR5cGUpIHtcbiAgICBpZiAob3AgPT09ICc9PScgfHwgb3AgPT09ICchPScpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUua2luZCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGUua2luZCA9PT0gJ3N0cmluZycgfHwgdHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCB0eXBlLmtpbmQgPT09ICdudWxsJyB8fCB0eXBlLmtpbmQgPT09ICd2YWx1ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGUua2luZCA9PT0gJ3N0cmluZycgfHwgdHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCB0eXBlLmtpbmQgPT09ICd2YWx1ZSc7XG4gICAgfVxufVxuZnVuY3Rpb24gZXEoY3R4LCBhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5mdW5jdGlvbiBuZXEoY3R4LCBhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT09IGI7XG59XG5mdW5jdGlvbiBsdChjdHgsIGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGI7XG59XG5mdW5jdGlvbiBndChjdHgsIGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGI7XG59XG5mdW5jdGlvbiBsdGVxKGN0eCwgYSwgYikge1xuICAgIHJldHVybiBhIDw9IGI7XG59XG5mdW5jdGlvbiBndGVxKGN0eCwgYSwgYikge1xuICAgIHJldHVybiBhID49IGI7XG59XG5mdW5jdGlvbiBlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA9PT0gMDtcbn1cbmZ1bmN0aW9uIG5lcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gICAgcmV0dXJuICFlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKTtcbn1cbmZ1bmN0aW9uIGx0Q29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYy5jb21wYXJlKGEsIGIpIDwgMDtcbn1cbmZ1bmN0aW9uIGd0Q29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYy5jb21wYXJlKGEsIGIpID4gMDtcbn1cbmZ1bmN0aW9uIGx0ZXFDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPD0gMDtcbn1cbmZ1bmN0aW9uIGd0ZXFDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPj0gMDtcbn1cbmZ1bmN0aW9uIG1ha2VDb21wYXJpc29uKG9wLCBjb21wYXJlQmFzaWMsIGNvbXBhcmVXaXRoQ29sbGF0b3IpIHtcbiAgICB2YXIgaXNPcmRlckNvbXBhcmlzb24gPSBvcCAhPT0gJz09JyAmJiBvcCAhPT0gJyE9JztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb21wYXJpc29uKGxocywgcmhzLCBjb2xsYXRvcikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gQm9vbGVhblR5cGU7XG4gICAgICAgICAgICB0aGlzLmxocyA9IGxocztcbiAgICAgICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICAgICAgdGhpcy5jb2xsYXRvciA9IGNvbGxhdG9yO1xuICAgICAgICAgICAgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQgPSBsaHMudHlwZS5raW5kID09PSAndmFsdWUnIHx8IHJocy50eXBlLmtpbmQgPT09ICd2YWx1ZSc7XG4gICAgICAgIH1cbiAgICAgICAgQ29tcGFyaXNvbi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMyAmJiBhcmdzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlZCB0d28gb3IgdGhyZWUgYXJndW1lbnRzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wID0gYXJnc1swXTtcbiAgICAgICAgICAgIHZhciBsaHMgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWxocykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0NvbXBhcmFibGVUeXBlKG9wLCBsaHMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb25jYXQoMSkuZXJyb3IoJ1wiJyArIG9wICsgJ1wiIGNvbXBhcmlzb25zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlIFxcJycgKyB0b1N0cmluZyhsaHMudHlwZSkgKyAnXFwnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJocyA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgVmFsdWVUeXBlKTtcbiAgICAgICAgICAgIGlmICghcmhzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQ29tcGFyYWJsZVR5cGUob3AsIHJocy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmNhdCgyKS5lcnJvcignXCInICsgb3AgKyAnXCIgY29tcGFyaXNvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgXFwnJyArIHRvU3RyaW5nKHJocy50eXBlKSArICdcXCcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGhzLnR5cGUua2luZCAhPT0gcmhzLnR5cGUua2luZCAmJiBsaHMudHlwZS5raW5kICE9PSAndmFsdWUnICYmIHJocy50eXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignQ2Fubm90IGNvbXBhcmUgdHlwZXMgXFwnJyArIHRvU3RyaW5nKGxocy50eXBlKSArICdcXCcgYW5kIFxcJycgKyB0b1N0cmluZyhyaHMudHlwZSkgKyAnXFwnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzT3JkZXJDb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgPT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICBsaHMgPSBuZXcgQXNzZXJ0aW9uKHJocy50eXBlLCBbbGhzXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaHMudHlwZS5raW5kICE9PSAndmFsdWUnICYmIHJocy50eXBlLmtpbmQgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmhzID0gbmV3IEFzc2VydGlvbihsaHMudHlwZSwgW3Joc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xsYXRvciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGhzLnR5cGUua2luZCAhPT0gJ3N0cmluZycgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3N0cmluZycgJiYgbGhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJyAmJiByaHMudHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdDYW5ub3QgdXNlIGNvbGxhdG9yIHRvIGNvbXBhcmUgbm9uLXN0cmluZyB0eXBlcy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGF0b3IgPSBjb250ZXh0LnBhcnNlKGFyZ3NbM10sIDMsIENvbGxhdG9yVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb2xsYXRvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBhcmlzb24obGhzLCByaHMsIGNvbGxhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29tcGFyaXNvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgICAgICAgIHZhciBsaHMgPSB0aGlzLmxocy5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgdmFyIHJocyA9IHRoaXMucmhzLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBpZiAoaXNPcmRlckNvbXBhcmlzb24gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbHQgPSB0eXBlT2YobGhzKTtcbiAgICAgICAgICAgICAgICB2YXIgcnQgPSB0eXBlT2YocmhzKTtcbiAgICAgICAgICAgICAgICBpZiAobHQua2luZCAhPT0gcnQua2luZCB8fCAhKGx0LmtpbmQgPT09ICdzdHJpbmcnIHx8IGx0LmtpbmQgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdFeHBlY3RlZCBhcmd1bWVudHMgZm9yIFwiJyArIG9wICsgJ1wiIHRvIGJlIChzdHJpbmcsIHN0cmluZykgb3IgKG51bWJlciwgbnVtYmVyKSwgYnV0IGZvdW5kICgnICsgbHQua2luZCArICcsICcgKyBydC5raW5kICsgJykgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsYXRvciAmJiAhaXNPcmRlckNvbXBhcmlzb24gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbHQkMSA9IHR5cGVPZihsaHMpO1xuICAgICAgICAgICAgICAgIHZhciBydCQxID0gdHlwZU9mKHJocyk7XG4gICAgICAgICAgICAgICAgaWYgKGx0JDEua2luZCAhPT0gJ3N0cmluZycgfHwgcnQkMS5raW5kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZUJhc2ljKGN0eCwgbGhzLCByaHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxhdG9yID8gY29tcGFyZVdpdGhDb2xsYXRvcihjdHgsIGxocywgcmhzLCB0aGlzLmNvbGxhdG9yLmV2YWx1YXRlKGN0eCkpIDogY29tcGFyZUJhc2ljKGN0eCwgbGhzLCByaHMpO1xuICAgICAgICB9O1xuICAgICAgICBDb21wYXJpc29uLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgICAgIGZuKHRoaXMubGhzKTtcbiAgICAgICAgICAgIGZuKHRoaXMucmhzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbGxhdG9yKSB7XG4gICAgICAgICAgICAgICAgZm4odGhpcy5jb2xsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIENvbXBhcmlzb24ucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIENvbXBhcmlzb24ucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkID0gW29wXTtcbiAgICAgICAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChjaGlsZC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29tcGFyaXNvbjtcbiAgICB9KCk7XG59XG52YXIgRXF1YWxzID0gbWFrZUNvbXBhcmlzb24oJz09JywgZXEsIGVxQ29sbGF0ZSk7XG52YXIgTm90RXF1YWxzID0gbWFrZUNvbXBhcmlzb24oJyE9JywgbmVxLCBuZXFDb2xsYXRlKTtcbnZhciBMZXNzVGhhbiA9IG1ha2VDb21wYXJpc29uKCc8JywgbHQsIGx0Q29sbGF0ZSk7XG52YXIgR3JlYXRlclRoYW4gPSBtYWtlQ29tcGFyaXNvbignPicsIGd0LCBndENvbGxhdGUpO1xudmFyIExlc3NUaGFuT3JFcXVhbCA9IG1ha2VDb21wYXJpc29uKCc8PScsIGx0ZXEsIGx0ZXFDb2xsYXRlKTtcbnZhciBHcmVhdGVyVGhhbk9yRXF1YWwgPSBtYWtlQ29tcGFyaXNvbignPj0nLCBndGVxLCBndGVxQ29sbGF0ZSk7XG5cbnZhciBOdW1iZXJGb3JtYXQgPSBmdW5jdGlvbiBOdW1iZXJGb3JtYXQobnVtYmVyLCBsb2NhbGUsIGN1cnJlbmN5LCBtaW5GcmFjdGlvbkRpZ2l0cywgbWF4RnJhY3Rpb25EaWdpdHMpIHtcbiAgICB0aGlzLnR5cGUgPSBTdHJpbmdUeXBlO1xuICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgICB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID0gbWluRnJhY3Rpb25EaWdpdHM7XG4gICAgdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA9IG1heEZyYWN0aW9uRGlnaXRzO1xufTtcbk51bWJlckZvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIHR3byBhcmd1bWVudHMuJyk7XG4gICAgfVxuICAgIHZhciBudW1iZXIgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIE51bWJlclR5cGUpO1xuICAgIGlmICghbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3NbMl07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdOdW1iZXJGb3JtYXQgb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG4gICAgdmFyIGxvY2FsZSA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnNbJ2xvY2FsZSddKSB7XG4gICAgICAgIGxvY2FsZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbG9jYWxlJ10sIDEsIFN0cmluZ1R5cGUpO1xuICAgICAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGN1cnJlbmN5ID0gbnVsbDtcbiAgICBpZiAob3B0aW9uc1snY3VycmVuY3knXSkge1xuICAgICAgICBjdXJyZW5jeSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snY3VycmVuY3knXSwgMSwgU3RyaW5nVHlwZSk7XG4gICAgICAgIGlmICghY3VycmVuY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBtaW5GcmFjdGlvbkRpZ2l0cyA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnNbJ21pbi1mcmFjdGlvbi1kaWdpdHMnXSkge1xuICAgICAgICBtaW5GcmFjdGlvbkRpZ2l0cyA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbWluLWZyYWN0aW9uLWRpZ2l0cyddLCAxLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFtaW5GcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1heEZyYWN0aW9uRGlnaXRzID0gbnVsbDtcbiAgICBpZiAob3B0aW9uc1snbWF4LWZyYWN0aW9uLWRpZ2l0cyddKSB7XG4gICAgICAgIG1heEZyYWN0aW9uRGlnaXRzID0gY29udGV4dC5wYXJzZShvcHRpb25zWydtYXgtZnJhY3Rpb24tZGlnaXRzJ10sIDEsIE51bWJlclR5cGUpO1xuICAgICAgICBpZiAoIW1heEZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE51bWJlckZvcm1hdChudW1iZXIsIGxvY2FsZSwgY3VycmVuY3ksIG1pbkZyYWN0aW9uRGlnaXRzLCBtYXhGcmFjdGlvbkRpZ2l0cyk7XG59O1xuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZS5ldmFsdWF0ZShjdHgpIDogW10sIHtcbiAgICAgICAgc3R5bGU6IHRoaXMuY3VycmVuY3kgPyAnY3VycmVuY3knIDogJ2RlY2ltYWwnLFxuICAgICAgICBjdXJyZW5jeTogdGhpcy5jdXJyZW5jeSA/IHRoaXMuY3VycmVuY3kuZXZhbHVhdGUoY3R4KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID8gdGhpcy5taW5GcmFjdGlvbkRpZ2l0cy5ldmFsdWF0ZShjdHgpIDogdW5kZWZpbmVkLFxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMgPyB0aGlzLm1heEZyYWN0aW9uRGlnaXRzLmV2YWx1YXRlKGN0eCkgOiB1bmRlZmluZWRcbiAgICB9KS5mb3JtYXQodGhpcy5udW1iZXIuZXZhbHVhdGUoY3R4KSk7XG59O1xuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICBmbih0aGlzLm51bWJlcik7XG4gICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgIGZuKHRoaXMubG9jYWxlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVuY3kpIHtcbiAgICAgICAgZm4odGhpcy5jdXJyZW5jeSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIGZuKHRoaXMubWluRnJhY3Rpb25EaWdpdHMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhGcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICBmbih0aGlzLm1heEZyYWN0aW9uRGlnaXRzKTtcbiAgICB9XG59O1xuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICBpZiAodGhpcy5sb2NhbGUpIHtcbiAgICAgICAgb3B0aW9uc1snbG9jYWxlJ10gPSB0aGlzLmxvY2FsZS5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVuY3kpIHtcbiAgICAgICAgb3B0aW9uc1snY3VycmVuY3knXSA9IHRoaXMuY3VycmVuY3kuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIG9wdGlvbnNbJ21pbi1mcmFjdGlvbi1kaWdpdHMnXSA9IHRoaXMubWluRnJhY3Rpb25EaWdpdHMuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heEZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIG9wdGlvbnNbJ21heC1mcmFjdGlvbi1kaWdpdHMnXSA9IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgICdudW1iZXItZm9ybWF0JyxcbiAgICAgICAgdGhpcy5udW1iZXIuc2VyaWFsaXplKCksXG4gICAgICAgIG9wdGlvbnNcbiAgICBdO1xufTtcblxudmFyIExlbmd0aCA9IGZ1bmN0aW9uIExlbmd0aChpbnB1dCkge1xuICAgIHRoaXMudHlwZSA9IE51bWJlclR5cGU7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xufTtcbkxlbmd0aC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIDEgYXJndW1lbnQsIGJ1dCBmb3VuZCAnICsgKGFyZ3MubGVuZ3RoIC0gMSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSk7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlucHV0LnR5cGUua2luZCAhPT0gJ2FycmF5JyAmJiBpbnB1dC50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIGlucHV0LnR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXksIGJ1dCBmb3VuZCAnICsgdG9TdHJpbmcoaW5wdXQudHlwZSkgKyAnIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGVuZ3RoKGlucHV0KTtcbn07XG5MZW5ndGgucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5sZW5ndGg7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0V4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgc3RyaW5nIG9yIGFycmF5LCBidXQgZm91bmQgJyArIHRvU3RyaW5nKHR5cGVPZihpbnB1dCkpICsgJyBpbnN0ZWFkLicpO1xuICAgIH1cbn07XG5MZW5ndGgucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgIGZuKHRoaXMuaW5wdXQpO1xufTtcbkxlbmd0aC5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbkxlbmd0aC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gWydsZW5ndGgnXTtcbiAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbnZhciBleHByZXNzaW9ucyA9IHtcbiAgICAnPT0nOiBFcXVhbHMsXG4gICAgJyE9JzogTm90RXF1YWxzLFxuICAgICc+JzogR3JlYXRlclRoYW4sXG4gICAgJzwnOiBMZXNzVGhhbixcbiAgICAnPj0nOiBHcmVhdGVyVGhhbk9yRXF1YWwsXG4gICAgJzw9JzogTGVzc1RoYW5PckVxdWFsLFxuICAgICdhcnJheSc6IEFzc2VydGlvbixcbiAgICAnYXQnOiBBdCxcbiAgICAnYm9vbGVhbic6IEFzc2VydGlvbixcbiAgICAnY2FzZSc6IENhc2UsXG4gICAgJ2NvYWxlc2NlJzogQ29hbGVzY2UsXG4gICAgJ2NvbGxhdG9yJzogQ29sbGF0b3JFeHByZXNzaW9uLFxuICAgICdmb3JtYXQnOiBGb3JtYXRFeHByZXNzaW9uLFxuICAgICdpbWFnZSc6IEltYWdlRXhwcmVzc2lvbixcbiAgICAnaW4nOiBJbixcbiAgICAnaW5kZXgtb2YnOiBJbmRleE9mLFxuICAgICdpbnRlcnBvbGF0ZSc6IEludGVycG9sYXRlLFxuICAgICdpbnRlcnBvbGF0ZS1oY2wnOiBJbnRlcnBvbGF0ZSxcbiAgICAnaW50ZXJwb2xhdGUtbGFiJzogSW50ZXJwb2xhdGUsXG4gICAgJ2xlbmd0aCc6IExlbmd0aCxcbiAgICAnbGV0JzogTGV0LFxuICAgICdsaXRlcmFsJzogTGl0ZXJhbCxcbiAgICAnbWF0Y2gnOiBNYXRjaCxcbiAgICAnbnVtYmVyJzogQXNzZXJ0aW9uLFxuICAgICdudW1iZXItZm9ybWF0JzogTnVtYmVyRm9ybWF0LFxuICAgICdvYmplY3QnOiBBc3NlcnRpb24sXG4gICAgJ3NsaWNlJzogU2xpY2UsXG4gICAgJ3N0ZXAnOiBTdGVwLFxuICAgICdzdHJpbmcnOiBBc3NlcnRpb24sXG4gICAgJ3RvLWJvb2xlYW4nOiBDb2VyY2lvbixcbiAgICAndG8tY29sb3InOiBDb2VyY2lvbixcbiAgICAndG8tbnVtYmVyJzogQ29lcmNpb24sXG4gICAgJ3RvLXN0cmluZyc6IENvZXJjaW9uLFxuICAgICd2YXInOiBWYXIsXG4gICAgJ3dpdGhpbic6IFdpdGhpblxufTtcbmZ1bmN0aW9uIHJnYmEoY3R4LCByZWYpIHtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgYSA9IHJlZlszXTtcbiAgICByID0gci5ldmFsdWF0ZShjdHgpO1xuICAgIGcgPSBnLmV2YWx1YXRlKGN0eCk7XG4gICAgYiA9IGIuZXZhbHVhdGUoY3R4KTtcbiAgICB2YXIgYWxwaGEgPSBhID8gYS5ldmFsdWF0ZShjdHgpIDogMTtcbiAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZVJHQkEociwgZywgYiwgYWxwaGEpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb2xvcihyIC8gMjU1ICogYWxwaGEsIGcgLyAyNTUgKiBhbHBoYSwgYiAvIDI1NSAqIGFscGhhLCBhbHBoYSk7XG59XG5mdW5jdGlvbiBoYXMoa2V5LCBvYmopIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbn1cbmZ1bmN0aW9uIGdldChrZXksIG9iaikge1xuICAgIHZhciB2ID0gb2JqW2tleV07XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB2O1xufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKHYsIGEsIGksIGopIHtcbiAgICB3aGlsZSAoaSA8PSBqKSB7XG4gICAgICAgIHZhciBtID0gaSArIGogPj4gMTtcbiAgICAgICAgaWYgKGFbbV0gPT09IHYpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW21dID4gdikge1xuICAgICAgICAgICAgaiA9IG0gLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSA9IG0gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHZhcmFyZ3ModHlwZSkge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUgfTtcbn1cbkNvbXBvdW5kRXhwcmVzc2lvbi5yZWdpc3RlcihleHByZXNzaW9ucywge1xuICAgICdlcnJvcic6IFtcbiAgICAgICAgRXJyb3JUeXBlLFxuICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKHYuZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICd0eXBlb2YnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtWYWx1ZVR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHR5cGVPZih2LmV2YWx1YXRlKGN0eCkpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3RvLXJnYmEnOiBbXG4gICAgICAgIGFycmF5KE51bWJlclR5cGUsIDQpLFxuICAgICAgICBbQ29sb3JUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiB2LmV2YWx1YXRlKGN0eCkudG9BcnJheSgpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAncmdiJzogW1xuICAgICAgICBDb2xvclR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZVxuICAgICAgICBdLFxuICAgICAgICByZ2JhXG4gICAgXSxcbiAgICAncmdiYSc6IFtcbiAgICAgICAgQ29sb3JUeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIHJnYmFcbiAgICBdLFxuICAgICdoYXMnOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5UeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXMoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHJlZlswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhcyhrZXkuZXZhbHVhdGUoY3R4KSwgb2JqLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJ2dldCc6IHtcbiAgICAgICAgdHlwZTogVmFsdWVUeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHJlZlswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldChrZXkuZXZhbHVhdGUoY3R4KSwgb2JqLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJ2ZlYXR1cmUtc3RhdGUnOiBbXG4gICAgICAgIFZhbHVlVHlwZSxcbiAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gZ2V0KGtleS5ldmFsdWF0ZShjdHgpLCBjdHguZmVhdHVyZVN0YXRlIHx8IHt9KTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3Byb3BlcnRpZXMnOiBbXG4gICAgICAgIE9iamVjdFR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2dlb21ldHJ5LXR5cGUnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lmdlb21ldHJ5VHlwZSgpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnaWQnOiBbXG4gICAgICAgIFZhbHVlVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguaWQoKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3pvb20nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lmdsb2JhbHMuem9vbTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2hlYXRtYXAtZGVuc2l0eSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguZ2xvYmFscy5oZWF0bWFwRGVuc2l0eSB8fCAwO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnbGluZS1wcm9ncmVzcyc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguZ2xvYmFscy5saW5lUHJvZ3Jlc3MgfHwgMDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2FjY3VtdWxhdGVkJzogW1xuICAgICAgICBWYWx1ZVR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lmdsb2JhbHMuYWNjdW11bGF0ZWQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdHguZ2xvYmFscy5hY2N1bXVsYXRlZDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJysnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIHZhcmFyZ3MoTnVtYmVyVHlwZSksXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBhcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmcgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICcqJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gYXJnczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKj0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnLSc6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyVHlwZSxcbiAgICAgICAgb3ZlcmxvYWRzOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gcmVmWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpIC0gYi5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHJlZlswXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1hLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnLyc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGVcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciBiID0gcmVmWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGEuZXZhbHVhdGUoY3R4KSAvIGIuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJyUnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgYiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJldHVybiBhLmV2YWx1YXRlKGN0eCkgJSBiLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdsbjInOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5MTjI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdwaSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkU7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdeJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZVxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBiID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIGUgPSByZWZbMV07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coYi5ldmFsdWF0ZShjdHgpLCBlLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnc3FydCc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4LmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnbG9nMTAnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpIC8gTWF0aC5MTjEwO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnbG4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnbG9nMic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBuID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKG4uZXZhbHVhdGUoY3R4KSkgLyBNYXRoLkxOMjtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3Npbic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBuID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKG4uZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdjb3MnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNvcyhuLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAndGFuJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC50YW4obi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2FzaW4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFzaW4obi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2Fjb3MnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFjb3Mobi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2F0YW4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4obi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ21pbic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgdmFyYXJncyhOdW1iZXJUeXBlKSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdtYXgnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIHZhcmFyZ3MoTnVtYmVyVHlwZSksXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnYWJzJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3JvdW5kJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIG4gPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IG4uZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIHJldHVybiB2IDwgMCA/IC1NYXRoLnJvdW5kKC12KSA6IE1hdGgucm91bmQodik7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmbG9vcic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBuID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iobi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2NlaWwnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobi5ldmFsdWF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci09PSc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBWYWx1ZVR5cGVcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgayA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0gPT09IHYudmFsdWU7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItaWQtPT0nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBjdHguaWQoKSA9PT0gdi52YWx1ZTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci10eXBlLT09JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gdi52YWx1ZTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci08JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciBrID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMV07XG4gICAgICAgICAgICB2YXIgYSA9IGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV07XG4gICAgICAgICAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPCBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLTwnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciBhID0gY3R4LmlkKCk7XG4gICAgICAgICAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPCBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLT4nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+IGI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItaWQtPic6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtWYWx1ZVR5cGVdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIGEgPSBjdHguaWQoKTtcbiAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+IGI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItPD0nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA8PSBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLTw9JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1ZhbHVlVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgYSA9IGN0eC5pZCgpO1xuICAgICAgICAgICAgdmFyIGIgPSB2LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDw9IGI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItPj0nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICAgICAgICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+PSBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLT49JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1ZhbHVlVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHYgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgYSA9IGN0eC5pZCgpO1xuICAgICAgICAgICAgdmFyIGIgPSB2LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhID49IGI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItaGFzJzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1ZhbHVlVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gay52YWx1ZSBpbiBjdHgucHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWhhcy1pZCc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmlkKCkgIT09IG51bGwgJiYgY3R4LmlkKCkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci10eXBlLWluJzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW2FycmF5KFN0cmluZ1R5cGUpXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiB2LnZhbHVlLmluZGV4T2YoY3R4Lmdlb21ldHJ5VHlwZSgpKSA+PSAwO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLWluJzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW2FycmF5KFZhbHVlVHlwZSldLFxuICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHYudmFsdWUuaW5kZXhPZihjdHguaWQoKSkgPj0gMDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1pbi1zbWFsbCc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBhcnJheShWYWx1ZVR5cGUpXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJldHVybiB2LnZhbHVlLmluZGV4T2YoY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXSkgPj0gMDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1pbi1sYXJnZSc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBhcnJheShWYWx1ZVR5cGUpXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGsgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgdiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJldHVybiBiaW5hcnlTZWFyY2goY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXSwgdi52YWx1ZSwgMCwgdi52YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2FsbCc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIEJvb2xlYW5UeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gcmVmWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpICYmIGIuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHZhcmFyZ3MoQm9vbGVhblR5cGUpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBhcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZy5ldmFsdWF0ZShjdHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJ2FueSc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIEJvb2xlYW5UeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY3R4LCByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gcmVmWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpIHx8IGIuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHZhcmFyZ3MoQm9vbGVhblR5cGUpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBhcmdzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLmV2YWx1YXRlKGN0eCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnISc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtCb29sZWFuVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGIgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gIWIuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2lzLXN1cHBvcnRlZC1zY3JpcHQnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHMgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgaXNTdXBwb3J0ZWRTY3JpcHQgPSBjdHguZ2xvYmFscyAmJiBjdHguZ2xvYmFscy5pc1N1cHBvcnRlZFNjcmlwdDtcbiAgICAgICAgICAgIGlmIChpc1N1cHBvcnRlZFNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1N1cHBvcnRlZFNjcmlwdChzLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICd1cGNhc2UnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtTdHJpbmdUeXBlXSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHJlZlswXTtcbiAgICAgICAgICAgIHJldHVybiBzLmV2YWx1YXRlKGN0eCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2Rvd25jYXNlJzogW1xuICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIHMgPSByZWZbMF07XG4gICAgICAgICAgICByZXR1cm4gcy5ldmFsdWF0ZShjdHgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdjb25jYXQnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIHZhcmFyZ3MoVmFsdWVUeXBlKSxcbiAgICAgICAgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9TdHJpbmckMShhcmcuZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3Jlc29sdmVkLWxvY2FsZSc6IFtcbiAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgW0NvbGxhdG9yVHlwZV0sXG4gICAgICAgIGZ1bmN0aW9uIChjdHgsIHJlZikge1xuICAgICAgICAgICAgdmFyIGNvbGxhdG9yID0gcmVmWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxhdG9yLmV2YWx1YXRlKGN0eCkucmVzb2x2ZWRMb2NhbGUoKTtcbiAgICAgICAgfVxuICAgIF1cbn0pO1xuXG5mdW5jdGlvbiBzdWNjZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiAnc3VjY2VzcycsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogJ2Vycm9yJyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24oc3BlYykge1xuICAgIHJldHVybiBzcGVjWydwcm9wZXJ0eS10eXBlJ10gPT09ICdkYXRhLWRyaXZlbicgfHwgc3BlY1sncHJvcGVydHktdHlwZSddID09PSAnY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW4nO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNab29tRXhwcmVzc2lvbihzcGVjKSB7XG4gICAgcmV0dXJuICEhc3BlYy5leHByZXNzaW9uICYmIHNwZWMuZXhwcmVzc2lvbi5wYXJhbWV0ZXJzLmluZGV4T2YoJ3pvb20nKSA+IC0xO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNJbnRlcnBvbGF0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gISFzcGVjLmV4cHJlc3Npb24gJiYgc3BlYy5leHByZXNzaW9uLmludGVycG9sYXRlZDtcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24kMSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlkZW50aXR5RnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4O1xufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKSB7XG4gICAgdmFyIGlzQ29sb3IgPSBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2NvbG9yJztcbiAgICB2YXIgem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgPSBwYXJhbWV0ZXJzLnN0b3BzICYmIHR5cGVvZiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdID09PSAnb2JqZWN0JztcbiAgICB2YXIgZmVhdHVyZURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8IHBhcmFtZXRlcnMucHJvcGVydHkgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgem9vbURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8ICFmZWF0dXJlRGVwZW5kZW50O1xuICAgIHZhciB0eXBlID0gcGFyYW1ldGVycy50eXBlIHx8IChzdXBwb3J0c0ludGVycG9sYXRpb24ocHJvcGVydHlTcGVjKSA/ICdleHBvbmVudGlhbCcgOiAnaW50ZXJ2YWwnKTtcbiAgICBpZiAoaXNDb2xvcikge1xuICAgICAgICBwYXJhbWV0ZXJzID0gZXh0ZW5kKHt9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuc3RvcHMpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuc3RvcHMgPSBwYXJhbWV0ZXJzLnN0b3BzLm1hcChmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHN0b3BbMF0sXG4gICAgICAgICAgICAgICAgICAgIENvbG9yLnBhcnNlKHN0b3BbMV0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZGVmYXVsdCA9IENvbG9yLnBhcnNlKHBhcmFtZXRlcnMuZGVmYXVsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmRlZmF1bHQgPSBDb2xvci5wYXJzZShwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlcnMuY29sb3JTcGFjZSAmJiBwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgIT09ICdyZ2InICYmICFjb2xvclNwYWNlc1twYXJhbWV0ZXJzLmNvbG9yU3BhY2VdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb2xvciBzcGFjZTogJyArIHBhcmFtZXRlcnMuY29sb3JTcGFjZSk7XG4gICAgfVxuICAgIHZhciBpbm5lckZ1bjtcbiAgICB2YXIgaGFzaGVkU3RvcHM7XG4gICAgdmFyIGNhdGVnb3JpY2FsS2V5VHlwZTtcbiAgICBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICBpbm5lckZ1biA9IGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnRlcnZhbCcpIHtcbiAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUludGVydmFsRnVuY3Rpb247XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnKSB7XG4gICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uO1xuICAgICAgICBoYXNoZWRTdG9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1ldGVycy5zdG9wczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzdG9wID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGhhc2hlZFN0b3BzW3N0b3BbMF1dID0gc3RvcFsxXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRlZ29yaWNhbEtleVR5cGUgPSB0eXBlb2YgcGFyYW1ldGVycy5zdG9wc1swXVswXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUlkZW50aXR5RnVuY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZ1bmN0aW9uIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICAgIH1cbiAgICBpZiAoem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQpIHtcbiAgICAgICAgdmFyIGZlYXR1cmVGdW5jdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIHpvb21TdG9wcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHBhcmFtZXRlcnMuc3RvcHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIHZhciBzdG9wJDEgPSBwYXJhbWV0ZXJzLnN0b3BzW3NdO1xuICAgICAgICAgICAgdmFyIHpvb20gPSBzdG9wJDFbMF0uem9vbTtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlRnVuY3Rpb25zW3pvb21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25zW3pvb21dID0ge1xuICAgICAgICAgICAgICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbWV0ZXJzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwYXJhbWV0ZXJzLnByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwYXJhbWV0ZXJzLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgem9vbVN0b3BzLnB1c2goem9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25zW3pvb21dLnN0b3BzLnB1c2goW1xuICAgICAgICAgICAgICAgIHN0b3AkMVswXS52YWx1ZSxcbiAgICAgICAgICAgICAgICBzdG9wJDFbMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmZWF0dXJlRnVuY3Rpb25TdG9wcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSB6b29tU3RvcHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeiA9IGxpc3QkMVtpJDFdO1xuICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHMucHVzaChbXG4gICAgICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uc1t6XS56b29tLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUZ1bmN0aW9uKGZlYXR1cmVGdW5jdGlvbnNbel0sIHByb3BlcnR5U3BlYylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uVHlwZSA9IHsgbmFtZTogJ2xpbmVhcicgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdjb21wb3NpdGUnLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvblR5cGU6IGludGVycG9sYXRpb25UeXBlLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkZhY3RvcjogSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvci5iaW5kKHVuZGVmaW5lZCwgaW50ZXJwb2xhdGlvblR5cGUpLFxuICAgICAgICAgICAgem9vbVN0b3BzOiBmZWF0dXJlRnVuY3Rpb25TdG9wcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc1swXTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIGV2YWx1YXRlKHJlZiwgcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHZhciB6b29tID0gcmVmLnpvb207XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BzOiBmZWF0dXJlRnVuY3Rpb25TdG9wcyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogcGFyYW1ldGVycy5iYXNlXG4gICAgICAgICAgICAgICAgfSwgcHJvcGVydHlTcGVjLCB6b29tKS5ldmFsdWF0ZSh6b29tLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHpvb21EZXBlbmRlbnQpIHtcbiAgICAgICAgdmFyIGludGVycG9sYXRpb25UeXBlJDEgPSB0eXBlID09PSAnZXhwb25lbnRpYWwnID8ge1xuICAgICAgICAgICAgbmFtZTogJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgICAgIGJhc2U6IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMVxuICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdjYW1lcmEnLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvblR5cGU6IGludGVycG9sYXRpb25UeXBlJDEsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uRmFjdG9yOiBJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0aW9uRmFjdG9yLmJpbmQodW5kZWZpbmVkLCBpbnRlcnBvbGF0aW9uVHlwZSQxKSxcbiAgICAgICAgICAgIHpvb21TdG9wczogcGFyYW1ldGVycy5zdG9wcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc1swXTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgem9vbSA9IHJlZi56b29tO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckZ1bihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHpvb20sIGhhc2hlZFN0b3BzLCBjYXRlZ29yaWNhbEtleVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAnc291cmNlJyxcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZShfLCBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZmVhdHVyZSAmJiBmZWF0dXJlLnByb3BlcnRpZXMgPyBmZWF0dXJlLnByb3BlcnRpZXNbcGFyYW1ldGVycy5wcm9wZXJ0eV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvYWxlc2NlKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJGdW4ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCB2YWx1ZSwgaGFzaGVkU3RvcHMsIGNhdGVnb3JpY2FsS2V5VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29hbGVzY2UoYSwgYiwgYykge1xuICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxufVxuZnVuY3Rpb24gZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQsIGhhc2hlZFN0b3BzLCBrZXlUeXBlKSB7XG4gICAgdmFyIGV2YWx1YXRlZCA9IHR5cGVvZiBpbnB1dCA9PT0ga2V5VHlwZSA/IGhhc2hlZFN0b3BzW2lucHV0XSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gY29hbGVzY2UoZXZhbHVhdGVkLCBwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJ2YWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0KSB7XG4gICAgaWYgKGdldFR5cGUoaW5wdXQpICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gY29hbGVzY2UocGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG4gICAgfVxuICAgIHZhciBuID0gcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7XG4gICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07XG4gICAgfVxuICAgIGlmIChpbnB1dCA8PSBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPj0gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMF0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzFdO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHBhcmFtZXRlcnMuc3RvcHMubWFwKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgIHJldHVybiBzdG9wWzBdO1xuICAgIH0pLCBpbnB1dCk7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzFdO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQpIHtcbiAgICB2YXIgYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMTtcbiAgICBpZiAoZ2V0VHlwZShpbnB1dCkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBjb2FsZXNjZShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbiAgICB9XG4gICAgdmFyIG4gPSBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDtcbiAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1swXVsxXTtcbiAgICB9XG4gICAgaWYgKGlucHV0IDw9IHBhcmFtZXRlcnMuc3RvcHNbMF1bMF0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07XG4gICAgfVxuICAgIGlmIChpbnB1dCA+PSBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVswXSkge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMV07XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZpbmRTdG9wTGVzc1RoYW5PckVxdWFsVG8ocGFyYW1ldGVycy5zdG9wcy5tYXAoZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIHN0b3BbMF07XG4gICAgfSksIGlucHV0KTtcbiAgICB2YXIgdCA9IGludGVycG9sYXRpb25GYWN0b3IoaW5wdXQsIGJhc2UsIHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzBdLCBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4ICsgMV1bMF0pO1xuICAgIHZhciBvdXRwdXRMb3dlciA9IHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzFdO1xuICAgIHZhciBvdXRwdXRVcHBlciA9IHBhcmFtZXRlcnMuc3RvcHNbaW5kZXggKyAxXVsxXTtcbiAgICB2YXIgaW50ZXJwID0gaW50ZXJwb2xhdGVbcHJvcGVydHlTcGVjLnR5cGVdIHx8IGlkZW50aXR5RnVuY3Rpb247XG4gICAgaWYgKHBhcmFtZXRlcnMuY29sb3JTcGFjZSAmJiBwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgIT09ICdyZ2InKSB7XG4gICAgICAgIHZhciBjb2xvcnNwYWNlID0gY29sb3JTcGFjZXNbcGFyYW1ldGVycy5jb2xvclNwYWNlXTtcbiAgICAgICAgaW50ZXJwID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcnNwYWNlLnJldmVyc2UoY29sb3JzcGFjZS5pbnRlcnBvbGF0ZShjb2xvcnNwYWNlLmZvcndhcmQoYSksIGNvbG9yc3BhY2UuZm9yd2FyZChiKSwgdCkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG91dHB1dExvd2VyLmV2YWx1YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobGVuLS0pXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgICAgICAgICAgIHZhciBldmFsdWF0ZWRMb3dlciA9IG91dHB1dExvd2VyLmV2YWx1YXRlLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICAgICAgdmFyIGV2YWx1YXRlZFVwcGVyID0gb3V0cHV0VXBwZXIuZXZhbHVhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGVkTG93ZXIgPT09IHVuZGVmaW5lZCB8fCBldmFsdWF0ZWRVcHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnAoZXZhbHVhdGVkTG93ZXIsIGV2YWx1YXRlZFVwcGVyLCB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVycChvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIsIHQpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVJZGVudGl0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQpIHtcbiAgICBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgaW5wdXQgPSBDb2xvci5wYXJzZShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2Zvcm1hdHRlZCcpIHtcbiAgICAgICAgaW5wdXQgPSBGb3JtYXR0ZWQuZnJvbVN0cmluZyhpbnB1dC50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICAgICAgaW5wdXQgPSBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcoaW5wdXQudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmIChnZXRUeXBlKGlucHV0KSAhPT0gcHJvcGVydHlTcGVjLnR5cGUgJiYgKHByb3BlcnR5U3BlYy50eXBlICE9PSAnZW51bScgfHwgIXByb3BlcnR5U3BlYy52YWx1ZXNbaW5wdXRdKSkge1xuICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNvYWxlc2NlKGlucHV0LCBwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRpb25GYWN0b3IoaW5wdXQsIGJhc2UsIGxvd2VyVmFsdWUsIHVwcGVyVmFsdWUpIHtcbiAgICB2YXIgZGlmZmVyZW5jZSA9IHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlO1xuICAgIHZhciBwcm9ncmVzcyA9IGlucHV0IC0gbG93ZXJWYWx1ZTtcbiAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGJhc2UgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHByb2dyZXNzIC8gZGlmZmVyZW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKE1hdGgucG93KGJhc2UsIHByb2dyZXNzKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIGRpZmZlcmVuY2UpIC0gMSk7XG4gICAgfVxufVxuXG52YXIgU3R5bGVFeHByZXNzaW9uID0gZnVuY3Rpb24gU3R5bGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHByb3BlcnR5U3BlYykge1xuICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgdGhpcy5fd2FybmluZ0hpc3RvcnkgPSB7fTtcbiAgICB0aGlzLl9ldmFsdWF0b3IgPSBuZXcgRXZhbHVhdGlvbkNvbnRleHQoKTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBwcm9wZXJ0eVNwZWMgPyBnZXREZWZhdWx0VmFsdWUocHJvcGVydHlTcGVjKSA6IG51bGw7XG4gICAgdGhpcy5fZW51bVZhbHVlcyA9IHByb3BlcnR5U3BlYyAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2VudW0nID8gcHJvcGVydHlTcGVjLnZhbHVlcyA6IG51bGw7XG59O1xuU3R5bGVFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nID0gZnVuY3Rpb24gZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmdsb2JhbHMgPSBnbG9iYWxzO1xuICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZVN0YXRlID0gZmVhdHVyZVN0YXRlO1xuICAgIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBjYW5vbmljYWw7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGF2YWlsYWJsZUltYWdlcyB8fCBudWxsO1xuICAgIHRoaXMuX2V2YWx1YXRvci5mb3JtYXR0ZWRTZWN0aW9uID0gZm9ybWF0dGVkU2VjdGlvbjtcbiAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHRoaXMuX2V2YWx1YXRvcik7XG59O1xuU3R5bGVFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IGdsb2JhbHM7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmUgPSBmZWF0dXJlIHx8IG51bGw7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IGZlYXR1cmVTdGF0ZSB8fCBudWxsO1xuICAgIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBjYW5vbmljYWw7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGF2YWlsYWJsZUltYWdlcyB8fCBudWxsO1xuICAgIHRoaXMuX2V2YWx1YXRvci5mb3JtYXR0ZWRTZWN0aW9uID0gZm9ybWF0dGVkU2VjdGlvbiB8fCBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUodGhpcy5fZXZhbHVhdG9yKTtcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiB2YWwgIT09IHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZW51bVZhbHVlcyAmJiAhKHZhbCBpbiB0aGlzLl9lbnVtVmFsdWVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyh0aGlzLl9lbnVtVmFsdWVzKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgICAgICB9KS5qb2luKCcsICcpICsgJywgYnV0IGZvdW5kICcgKyBKU09OLnN0cmluZ2lmeSh2YWwpICsgJyBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3dhcm5pbmdIaXN0b3J5W2UubWVzc2FnZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX3dhcm5pbmdIaXN0b3J5W2UubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWU7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbikgJiYgZXhwcmVzc2lvbi5sZW5ndGggPiAwICYmIHR5cGVvZiBleHByZXNzaW9uWzBdID09PSAnc3RyaW5nJyAmJiBleHByZXNzaW9uWzBdIGluIGV4cHJlc3Npb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNpbmdDb250ZXh0KGV4cHJlc3Npb25zLCBbXSwgcHJvcGVydHlTcGVjID8gZ2V0RXhwZWN0ZWRUeXBlKHByb3BlcnR5U3BlYykgOiB1bmRlZmluZWQpO1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZXIucGFyc2UoZXhwcmVzc2lvbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcHJvcGVydHlTcGVjICYmIHByb3BlcnR5U3BlYy50eXBlID09PSAnc3RyaW5nJyA/IHsgdHlwZUFubm90YXRpb246ICdjb2VyY2UnIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihwYXJzZXIuZXJyb3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3MobmV3IFN0eWxlRXhwcmVzc2lvbihwYXJzZWQsIHByb3BlcnR5U3BlYykpO1xufVxudmFyIFpvb21Db25zdGFudEV4cHJlc3Npb24gPSBmdW5jdGlvbiBab29tQ29uc3RhbnRFeHByZXNzaW9uKGtpbmQsIGV4cHJlc3Npb24pIHtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMuX3N0eWxlRXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgdGhpcy5pc1N0YXRlRGVwZW5kZW50ID0ga2luZCAhPT0gJ2NvbnN0YW50JyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb24uZXhwcmVzc2lvbik7XG59O1xuWm9vbUNvbnN0YW50RXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyA9IGZ1bmN0aW9uIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTtcbn07XG5ab29tQ29uc3RhbnRFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pO1xufTtcbnZhciBab29tRGVwZW5kZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIFpvb21EZXBlbmRlbnRFeHByZXNzaW9uKGtpbmQsIGV4cHJlc3Npb24sIHpvb21TdG9wcywgaW50ZXJwb2xhdGlvblR5cGUpIHtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMuem9vbVN0b3BzID0gem9vbVN0b3BzO1xuICAgIHRoaXMuX3N0eWxlRXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgdGhpcy5pc1N0YXRlRGVwZW5kZW50ID0ga2luZCAhPT0gJ2NhbWVyYScgJiYgIWlzU3RhdGVDb25zdGFudChleHByZXNzaW9uLmV4cHJlc3Npb24pO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBpbnRlcnBvbGF0aW9uVHlwZTtcbn07XG5ab29tRGVwZW5kZW50RXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyA9IGZ1bmN0aW9uIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTtcbn07XG5ab29tRGVwZW5kZW50RXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTtcbn07XG5ab29tRGVwZW5kZW50RXhwcmVzc2lvbi5wcm90b3R5cGUuaW50ZXJwb2xhdGlvbkZhY3RvciA9IGZ1bmN0aW9uIGludGVycG9sYXRpb25GYWN0b3IoaW5wdXQsIGxvd2VyLCB1cHBlcikge1xuICAgIGlmICh0aGlzLmludGVycG9sYXRpb25UeXBlKSB7XG4gICAgICAgIHJldHVybiBJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0aW9uRmFjdG9yKHRoaXMuaW50ZXJwb2xhdGlvblR5cGUsIGlucHV0LCBsb3dlciwgdXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKSB7XG4gICAgZXhwcmVzc2lvbiA9IGNyZWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKTtcbiAgICBpZiAoZXhwcmVzc2lvbi5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxuICAgIHZhciBwYXJzZWQgPSBleHByZXNzaW9uLnZhbHVlLmV4cHJlc3Npb247XG4gICAgdmFyIGlzRmVhdHVyZUNvbnN0YW50JDEgPSBpc0ZlYXR1cmVDb25zdGFudChwYXJzZWQpO1xuICAgIGlmICghaXNGZWF0dXJlQ29uc3RhbnQkMSAmJiAhc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24ocHJvcGVydHlTcGVjKSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoW25ldyBQYXJzaW5nRXJyb3IoJycsICdkYXRhIGV4cHJlc3Npb25zIG5vdCBzdXBwb3J0ZWQnKV0pO1xuICAgIH1cbiAgICB2YXIgaXNab29tQ29uc3RhbnQgPSBpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQocGFyc2VkLCBbJ3pvb20nXSk7XG4gICAgaWYgKCFpc1pvb21Db25zdGFudCAmJiAhc3VwcG9ydHNab29tRXhwcmVzc2lvbihwcm9wZXJ0eVNwZWMpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ3pvb20gZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZCcpXSk7XG4gICAgfVxuICAgIHZhciB6b29tQ3VydmUgPSBmaW5kWm9vbUN1cnZlKHBhcnNlZCk7XG4gICAgaWYgKCF6b29tQ3VydmUgJiYgIWlzWm9vbUNvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ1wiem9vbVwiIGV4cHJlc3Npb24gbWF5IG9ubHkgYmUgdXNlZCBhcyBpbnB1dCB0byBhIHRvcC1sZXZlbCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbi4nKV0pO1xuICAgIH0gZWxzZSBpZiAoem9vbUN1cnZlIGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihbem9vbUN1cnZlXSk7XG4gICAgfSBlbHNlIGlmICh6b29tQ3VydmUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0ZSAmJiAhc3VwcG9ydHNJbnRlcnBvbGF0aW9uKHByb3BlcnR5U3BlYykpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFtuZXcgUGFyc2luZ0Vycm9yKCcnLCAnXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb25zIGNhbm5vdCBiZSB1c2VkIHdpdGggdGhpcyBwcm9wZXJ0eScpXSk7XG4gICAgfVxuICAgIGlmICghem9vbUN1cnZlKSB7XG4gICAgICAgIHJldHVybiBzdWNjZXNzKGlzRmVhdHVyZUNvbnN0YW50JDEgPyBuZXcgWm9vbUNvbnN0YW50RXhwcmVzc2lvbignY29uc3RhbnQnLCBleHByZXNzaW9uLnZhbHVlKSA6IG5ldyBab29tQ29uc3RhbnRFeHByZXNzaW9uKCdzb3VyY2UnLCBleHByZXNzaW9uLnZhbHVlKSk7XG4gICAgfVxuICAgIHZhciBpbnRlcnBvbGF0aW9uVHlwZSA9IHpvb21DdXJ2ZSBpbnN0YW5jZW9mIEludGVycG9sYXRlID8gem9vbUN1cnZlLmludGVycG9sYXRpb24gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN1Y2Nlc3MoaXNGZWF0dXJlQ29uc3RhbnQkMSA/IG5ldyBab29tRGVwZW5kZW50RXhwcmVzc2lvbignY2FtZXJhJywgZXhwcmVzc2lvbi52YWx1ZSwgem9vbUN1cnZlLmxhYmVscywgaW50ZXJwb2xhdGlvblR5cGUpIDogbmV3IFpvb21EZXBlbmRlbnRFeHByZXNzaW9uKCdjb21wb3NpdGUnLCBleHByZXNzaW9uLnZhbHVlLCB6b29tQ3VydmUubGFiZWxzLCBpbnRlcnBvbGF0aW9uVHlwZSkpO1xufVxudmFyIFN0eWxlUHJvcGVydHlGdW5jdGlvbiA9IGZ1bmN0aW9uIFN0eWxlUHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBzcGVjaWZpY2F0aW9uKSB7XG4gICAgdGhpcy5fcGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgdGhpcy5fc3BlY2lmaWNhdGlvbiA9IHNwZWNpZmljYXRpb247XG4gICAgZXh0ZW5kKHRoaXMsIGNyZWF0ZUZ1bmN0aW9uKHRoaXMuX3BhcmFtZXRlcnMsIHRoaXMuX3NwZWNpZmljYXRpb24pKTtcbn07XG5TdHlsZVByb3BlcnR5RnVuY3Rpb24uZGVzZXJpYWxpemUgPSBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZVByb3BlcnR5RnVuY3Rpb24oc2VyaWFsaXplZC5fcGFyYW1ldGVycywgc2VyaWFsaXplZC5fc3BlY2lmaWNhdGlvbik7XG59O1xuU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9wYXJhbWV0ZXJzOiBpbnB1dC5fcGFyYW1ldGVycyxcbiAgICAgICAgX3NwZWNpZmljYXRpb246IGlucHV0Ll9zcGVjaWZpY2F0aW9uXG4gICAgfTtcbn07XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eUV4cHJlc3Npb24odmFsdWUsIHNwZWNpZmljYXRpb24pIHtcbiAgICBpZiAoaXNGdW5jdGlvbiQxKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0eWxlUHJvcGVydHlGdW5jdGlvbih2YWx1ZSwgc3BlY2lmaWNhdGlvbik7XG4gICAgfSBlbHNlIGlmIChpc0V4cHJlc3Npb24odmFsdWUpKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24ucmVzdWx0ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwcmVzc2lvbi52YWx1ZS5tYXAoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnIua2V5ICsgJzogJyArIGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgfSkuam9pbignLCAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbnN0YW50ID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHNwZWNpZmljYXRpb24udHlwZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgY29uc3RhbnQgPSBDb2xvci5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdjb25zdGFudCcsXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kWm9vbUN1cnZlKGV4cHJlc3Npb24pIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIExldCkge1xuICAgICAgICByZXN1bHQgPSBmaW5kWm9vbUN1cnZlKGV4cHJlc3Npb24ucmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2FsZXNjZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHJlc3Npb24uYXJnczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBsaXN0W2ldO1xuICAgICAgICAgICAgcmVzdWx0ID0gZmluZFpvb21DdXJ2ZShhcmcpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFN0ZXAgfHwgZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEludGVycG9sYXRlKSAmJiBleHByZXNzaW9uLmlucHV0IGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIGV4cHJlc3Npb24uaW5wdXQubmFtZSA9PT0gJ3pvb20nKSB7XG4gICAgICAgIHJlc3VsdCA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZXhwcmVzc2lvbi5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZFJlc3VsdCA9IGZpbmRab29tQ3VydmUoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRSZXN1bHQgaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNoaWxkUmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFyZXN1bHQgJiYgY2hpbGRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBQYXJzaW5nRXJyb3IoJycsICdcInpvb21cIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgXCJzdGVwXCIgb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb24uJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICYmIGNoaWxkUmVzdWx0ICYmIHJlc3VsdCAhPT0gY2hpbGRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBQYXJzaW5nRXJyb3IoJycsICdPbmx5IG9uZSB6b29tLWJhc2VkIFwic3RlcFwiIG9yIFwiaW50ZXJwb2xhdGVcIiBzdWJleHByZXNzaW9uIG1heSBiZSB1c2VkIGluIGFuIGV4cHJlc3Npb24uJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0RXhwZWN0ZWRUeXBlKHNwZWMpIHtcbiAgICB2YXIgdHlwZXMgPSB7XG4gICAgICAgIGNvbG9yOiBDb2xvclR5cGUsXG4gICAgICAgIHN0cmluZzogU3RyaW5nVHlwZSxcbiAgICAgICAgbnVtYmVyOiBOdW1iZXJUeXBlLFxuICAgICAgICBlbnVtOiBTdHJpbmdUeXBlLFxuICAgICAgICBib29sZWFuOiBCb29sZWFuVHlwZSxcbiAgICAgICAgZm9ybWF0dGVkOiBGb3JtYXR0ZWRUeXBlLFxuICAgICAgICByZXNvbHZlZEltYWdlOiBSZXNvbHZlZEltYWdlVHlwZVxuICAgIH07XG4gICAgaWYgKHNwZWMudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gYXJyYXkodHlwZXNbc3BlYy52YWx1ZV0gfHwgVmFsdWVUeXBlLCBzcGVjLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlc1tzcGVjLnR5cGVdO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKHNwZWMpIHtcbiAgICBpZiAoc3BlYy50eXBlID09PSAnY29sb3InICYmIGlzRnVuY3Rpb24kMShzcGVjLmRlZmF1bHQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgfSBlbHNlIGlmIChzcGVjLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yLnBhcnNlKHNwZWMuZGVmYXVsdCkgfHwgbnVsbDtcbiAgICB9IGVsc2UgaWYgKHNwZWMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzcGVjLmRlZmF1bHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gW1xuICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgIHZhbHVlXG4gICAgXSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gY29udmVydEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykge1xuICAgIHZhciBzdG9wcyA9IHBhcmFtZXRlcnMuc3RvcHM7XG4gICAgaWYgKCFzdG9wcykge1xuICAgICAgICByZXR1cm4gY29udmVydElkZW50aXR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKTtcbiAgICB9XG4gICAgdmFyIHpvb21BbmRGZWF0dXJlRGVwZW5kZW50ID0gc3RvcHMgJiYgdHlwZW9mIHN0b3BzWzBdWzBdID09PSAnb2JqZWN0JztcbiAgICB2YXIgZmVhdHVyZURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8IHBhcmFtZXRlcnMucHJvcGVydHkgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgem9vbURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8ICFmZWF0dXJlRGVwZW5kZW50O1xuICAgIHN0b3BzID0gc3RvcHMubWFwKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgIGlmICghZmVhdHVyZURlcGVuZGVudCAmJiBwcm9wZXJ0eVNwZWMudG9rZW5zICYmIHR5cGVvZiBzdG9wWzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzdG9wWzBdLFxuICAgICAgICAgICAgICAgIGNvbnZlcnRUb2tlblN0cmluZyhzdG9wWzFdKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc3RvcFswXSxcbiAgICAgICAgICAgIGNvbnZlcnRMaXRlcmFsKHN0b3BbMV0pXG4gICAgICAgIF07XG4gICAgfSk7XG4gICAgaWYgKHpvb21BbmRGZWF0dXJlRGVwZW5kZW50KSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcyk7XG4gICAgfSBlbHNlIGlmICh6b29tRGVwZW5kZW50KSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0Wm9vbUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0SWRlbnRpdHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICB2YXIgZ2V0ID0gW1xuICAgICAgICAnZ2V0JyxcbiAgICAgICAgcGFyYW1ldGVycy5wcm9wZXJ0eVxuICAgIF07XG4gICAgaWYgKHBhcmFtZXRlcnMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ3N0cmluZycgPyBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgIGdldFxuICAgICAgICBdIDogZ2V0O1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdlbnVtJykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ21hdGNoJyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5U3BlYy52YWx1ZXMpLFxuICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgcGFyYW1ldGVycy5kZWZhdWx0XG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBbXG4gICAgICAgICAgICBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2NvbG9yJyA/ICd0by1jb2xvcicgOiBwcm9wZXJ0eVNwZWMudHlwZSxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIGNvbnZlcnRMaXRlcmFsKHBhcmFtZXRlcnMuZGVmYXVsdClcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uLnNwbGljZSgxLCAwLCBwcm9wZXJ0eVNwZWMudmFsdWUsIHByb3BlcnR5U3BlYy5sZW5ndGggfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdGVPcGVyYXRvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3dpdGNoIChwYXJhbWV0ZXJzLmNvbG9yU3BhY2UpIHtcbiAgICBjYXNlICdoY2wnOlxuICAgICAgICByZXR1cm4gJ2ludGVycG9sYXRlLWhjbCc7XG4gICAgY2FzZSAnbGFiJzpcbiAgICAgICAgcmV0dXJuICdpbnRlcnBvbGF0ZS1sYWInO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnaW50ZXJwb2xhdGUnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRab29tQW5kUHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKSB7XG4gICAgdmFyIGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnMgPSB7fTtcbiAgICB2YXIgZmVhdHVyZUZ1bmN0aW9uU3RvcHMgPSB7fTtcbiAgICB2YXIgem9vbVN0b3BzID0gW107XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdG9wcy5sZW5ndGg7IHMrKykge1xuICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW3NdO1xuICAgICAgICB2YXIgem9vbSA9IHN0b3BbMF0uem9vbTtcbiAgICAgICAgaWYgKGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnNbem9vbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6b29tXSA9IHtcbiAgICAgICAgICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtZXRlcnMudHlwZSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyYW1ldGVycy5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBwYXJhbWV0ZXJzLmRlZmF1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25TdG9wc1t6b29tXSA9IFtdO1xuICAgICAgICAgICAgem9vbVN0b3BzLnB1c2goem9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHNbem9vbV0ucHVzaChbXG4gICAgICAgICAgICBzdG9wWzBdLnZhbHVlLFxuICAgICAgICAgICAgc3RvcFsxXVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgdmFyIGZ1bmN0aW9uVHlwZSA9IGdldEZ1bmN0aW9uVHlwZSh7fSwgcHJvcGVydHlTcGVjKTtcbiAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gW1xuICAgICAgICAgICAgZ2V0SW50ZXJwb2xhdGVPcGVyYXRvcihwYXJhbWV0ZXJzKSxcbiAgICAgICAgICAgIFsnbGluZWFyJ10sXG4gICAgICAgICAgICBbJ3pvb20nXVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHpvb21TdG9wczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB6ID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3pdLCBwcm9wZXJ0eVNwZWMsIGZlYXR1cmVGdW5jdGlvblN0b3BzW3pdKTtcbiAgICAgICAgICAgIGFwcGVuZFN0b3BQYWlyKGV4cHJlc3Npb24sIHosIG91dHB1dCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uJDEgPSBbXG4gICAgICAgICAgICAnc3RlcCcsXG4gICAgICAgICAgICBbJ3pvb20nXVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSB6b29tU3RvcHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeiQxID0gbGlzdCQxW2kkMV07XG4gICAgICAgICAgICB2YXIgb3V0cHV0JDEgPSBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3okMV0sIHByb3BlcnR5U3BlYywgZmVhdHVyZUZ1bmN0aW9uU3RvcHNbeiQxXSk7XG4gICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uJDEsIHokMSwgb3V0cHV0JDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShleHByZXNzaW9uJDEpO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbiQxO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvYWxlc2NlJDEoYSwgYikge1xuICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcykge1xuICAgIHZhciB0eXBlID0gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYyk7XG4gICAgdmFyIGdldCA9IFtcbiAgICAgICAgJ2dldCcsXG4gICAgICAgIHBhcmFtZXRlcnMucHJvcGVydHlcbiAgICBdO1xuICAgIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHR5cGVvZiBzdG9wc1swXVswXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gWydjYXNlJ107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RvcHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IGxpc3RbaV07XG4gICAgICAgICAgICBleHByZXNzaW9uLnB1c2goW1xuICAgICAgICAgICAgICAgICc9PScsXG4gICAgICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgICAgIHN0b3BbMF1cbiAgICAgICAgICAgIF0sIHN0b3BbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGV4cHJlc3Npb24ucHVzaChjb252ZXJ0TGl0ZXJhbChjb2FsZXNjZSQxKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpKSk7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NhdGVnb3JpY2FsJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiQxID0gW1xuICAgICAgICAgICAgJ21hdGNoJyxcbiAgICAgICAgICAgIGdldFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBzdG9wczsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzdG9wJDEgPSBsaXN0JDFbaSQxXTtcbiAgICAgICAgICAgIGFwcGVuZFN0b3BQYWlyKGV4cHJlc3Npb24kMSwgc3RvcCQxWzBdLCBzdG9wJDFbMV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBleHByZXNzaW9uJDEucHVzaChjb252ZXJ0TGl0ZXJhbChjb2FsZXNjZSQxKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpKSk7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uJDE7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uJDIgPSBbXG4gICAgICAgICAgICAnc3RlcCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAgICAgZ2V0XG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDAsIGxpc3QkMiA9IHN0b3BzOyBpJDIgPCBsaXN0JDIubGVuZ3RoOyBpJDIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHN0b3AkMiA9IGxpc3QkMltpJDJdO1xuICAgICAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiQyLCBzdG9wJDJbMF0sIHN0b3AkMlsxXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKGV4cHJlc3Npb24kMik7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLmRlZmF1bHQgPT09IHVuZGVmaW5lZCA/IGV4cHJlc3Npb24kMiA6IFtcbiAgICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPT0nLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGVvZicsXG4gICAgICAgICAgICAgICAgICAgIGdldFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ251bWJlcidcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHByZXNzaW9uJDIsXG4gICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgICAgIHZhciBiYXNlID0gcGFyYW1ldGVycy5iYXNlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmJhc2UgOiAxO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiQzID0gW1xuICAgICAgICAgICAgZ2V0SW50ZXJwb2xhdGVPcGVyYXRvcihwYXJhbWV0ZXJzKSxcbiAgICAgICAgICAgIGJhc2UgPT09IDEgPyBbJ2xpbmVhciddIDogW1xuICAgICAgICAgICAgICAgICdleHBvbmVudGlhbCcsXG4gICAgICAgICAgICAgICAgYmFzZVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBnZXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSQzID0gMCwgbGlzdCQzID0gc3RvcHM7IGkkMyA8IGxpc3QkMy5sZW5ndGg7IGkkMyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCQzID0gbGlzdCQzW2kkM107XG4gICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uJDMsIHN0b3AkM1swXSwgc3RvcCQzWzFdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkID8gZXhwcmVzc2lvbiQzIDogW1xuICAgICAgICAgICAgJ2Nhc2UnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc9PScsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAndHlwZW9mJyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAnbnVtYmVyJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb24kMyxcbiAgICAgICAgICAgIGNvbnZlcnRMaXRlcmFsKHBhcmFtZXRlcnMuZGVmYXVsdClcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvcGVydHkgZnVuY3Rpb24gdHlwZSAnICsgdHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFpvb21GdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzLCBpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKVxuICAgICAgICBpbnB1dCA9IFsnem9vbSddO1xuICAgIHZhciB0eXBlID0gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYyk7XG4gICAgdmFyIGV4cHJlc3Npb247XG4gICAgdmFyIGlzU3RlcCA9IGZhbHNlO1xuICAgIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBbXG4gICAgICAgICAgICAnc3RlcCcsXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICBdO1xuICAgICAgICBpc1N0ZXAgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICB2YXIgYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IFtcbiAgICAgICAgICAgIGdldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycyksXG4gICAgICAgICAgICBiYXNlID09PSAxID8gWydsaW5lYXInXSA6IFtcbiAgICAgICAgICAgICAgICAnZXhwb25lbnRpYWwnLFxuICAgICAgICAgICAgICAgIGJhc2VcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB6b29tIGZ1bmN0aW9uIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0b3BzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc3RvcCA9IGxpc3RbaV07XG4gICAgICAgIGFwcGVuZFN0b3BQYWlyKGV4cHJlc3Npb24sIHN0b3BbMF0sIHN0b3BbMV0sIGlzU3RlcCk7XG4gICAgfVxuICAgIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShleHByZXNzaW9uKTtcbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbn1cbmZ1bmN0aW9uIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShleHByZXNzaW9uKSB7XG4gICAgaWYgKGV4cHJlc3Npb25bMF0gPT09ICdzdGVwJyAmJiBleHByZXNzaW9uLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBleHByZXNzaW9uLnB1c2goMCk7XG4gICAgICAgIGV4cHJlc3Npb24ucHVzaChleHByZXNzaW9uWzNdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmRTdG9wUGFpcihjdXJ2ZSwgaW5wdXQsIG91dHB1dCwgaXNTdGVwKSB7XG4gICAgaWYgKGN1cnZlLmxlbmd0aCA+IDMgJiYgaW5wdXQgPT09IGN1cnZlW2N1cnZlLmxlbmd0aCAtIDJdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoaXNTdGVwICYmIGN1cnZlLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgY3VydmUucHVzaChpbnB1dCk7XG4gICAgfVxuICAgIGN1cnZlLnB1c2gob3V0cHV0KTtcbn1cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uVHlwZShwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICBpZiAocGFyYW1ldGVycy50eXBlKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5U3BlYy5leHByZXNzaW9uLmludGVycG9sYXRlZCA/ICdleHBvbmVudGlhbCcgOiAnaW50ZXJ2YWwnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb2tlblN0cmluZyhzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFsnY29uY2F0J107XG4gICAgdmFyIHJlID0gL3soW157fV0rKX0vZztcbiAgICB2YXIgcG9zID0gMDtcbiAgICBmb3IgKHZhciBtYXRjaCA9IHJlLmV4ZWMocyk7IG1hdGNoICE9PSBudWxsOyBtYXRjaCA9IHJlLmV4ZWMocykpIHtcbiAgICAgICAgdmFyIGxpdGVyYWwgPSBzLnNsaWNlKHBvcywgcmUubGFzdEluZGV4IC0gbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgcG9zID0gcmUubGFzdEluZGV4O1xuICAgICAgICBpZiAobGl0ZXJhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChsaXRlcmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChbXG4gICAgICAgICAgICAnZ2V0JyxcbiAgICAgICAgICAgIG1hdGNoWzFdXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgaWYgKHBvcyA8IHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHMuc2xpY2UocG9zKSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAndG8tc3RyaW5nJyxcbiAgICAgICAgICAgIHJlc3VsdFsxXVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciA9PT0gdHJ1ZSB8fCBmaWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyKSB8fCBmaWx0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChmaWx0ZXJbMF0pIHtcbiAgICBjYXNlICdoYXMnOlxuICAgICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aCA+PSAyICYmIGZpbHRlclsxXSAhPT0gJyRpZCcgJiYgZmlsdGVyWzFdICE9PSAnJHR5cGUnO1xuICAgIGNhc2UgJ2luJzpcbiAgICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggPj0gMyAmJiAodHlwZW9mIGZpbHRlclsxXSAhPT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShmaWx0ZXJbMl0pKTtcbiAgICBjYXNlICchaW4nOlxuICAgIGNhc2UgJyFoYXMnOlxuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSAnPT0nOlxuICAgIGNhc2UgJyE9JzpcbiAgICBjYXNlICc+JzpcbiAgICBjYXNlICc+PSc6XG4gICAgY2FzZSAnPCc6XG4gICAgY2FzZSAnPD0nOlxuICAgICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aCAhPT0gMyB8fCAoQXJyYXkuaXNBcnJheShmaWx0ZXJbMV0pIHx8IEFycmF5LmlzQXJyYXkoZmlsdGVyWzJdKSk7XG4gICAgY2FzZSAnYW55JzpcbiAgICBjYXNlICdhbGwnOlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGZpbHRlci5zbGljZSgxKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBmID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmICghaXNFeHByZXNzaW9uRmlsdGVyKGYpICYmIHR5cGVvZiBmICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxudmFyIGZpbHRlclNwZWMgPSB7XG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZSxcbiAgICAndHJhbnNpdGlvbic6IGZhbHNlLFxuICAgICdwcm9wZXJ0eS10eXBlJzogJ2RhdGEtZHJpdmVuJyxcbiAgICAnZXhwcmVzc2lvbic6IHtcbiAgICAgICAgJ2ludGVycG9sYXRlZCc6IGZhbHNlLFxuICAgICAgICAncGFyYW1ldGVycyc6IFtcbiAgICAgICAgICAgICd6b29tJyxcbiAgICAgICAgICAgICdmZWF0dXJlJ1xuICAgICAgICBdXG4gICAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyID09PSBudWxsIHx8IGZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZWVkR2VvbWV0cnk6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICghaXNFeHByZXNzaW9uRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgZmlsdGVyID0gY29udmVydEZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICB2YXIgY29tcGlsZWQgPSBjcmVhdGVFeHByZXNzaW9uKGZpbHRlciwgZmlsdGVyU3BlYyk7XG4gICAgaWYgKGNvbXBpbGVkLnJlc3VsdCA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29tcGlsZWQudmFsdWUubWFwKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnIua2V5ICsgJzogJyArIGVyci5tZXNzYWdlO1xuICAgICAgICB9KS5qb2luKCcsICcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmVlZEdlb21ldHJ5ID0gQXJyYXkuaXNBcnJheShmaWx0ZXIpICYmIGZpbHRlci5sZW5ndGggIT09IDAgJiYgZmlsdGVyWzBdID09PSAnd2l0aGluJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmUsIGNhbm9uaWNhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlZC52YWx1ZS5ldmFsdWF0ZShnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlLCB7fSwgY2Fub25pY2FsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZWVkR2VvbWV0cnk6IG5lZWRHZW9tZXRyeVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBvcCA9IGZpbHRlclswXTtcbiAgICBpZiAoZmlsdGVyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBvcCAhPT0gJ2FueSc7XG4gICAgfVxuICAgIHZhciBjb252ZXJ0ZWQgPSBvcCA9PT0gJz09JyA/IGNvbnZlcnRDb21wYXJpc29uT3AoZmlsdGVyWzFdLCBmaWx0ZXJbMl0sICc9PScpIDogb3AgPT09ICchPScgPyBjb252ZXJ0TmVnYXRpb24oY29udmVydENvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgJz09JykpIDogb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9wID09PSAnPD0nIHx8IG9wID09PSAnPj0nID8gY29udmVydENvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgb3ApIDogb3AgPT09ICdhbnknID8gY29udmVydERpc2p1bmN0aW9uT3AoZmlsdGVyLnNsaWNlKDEpKSA6IG9wID09PSAnYWxsJyA/IFsnYWxsJ10uY29uY2F0KGZpbHRlci5zbGljZSgxKS5tYXAoY29udmVydEZpbHRlcikpIDogb3AgPT09ICdub25lJyA/IFsnYWxsJ10uY29uY2F0KGZpbHRlci5zbGljZSgxKS5tYXAoY29udmVydEZpbHRlcikubWFwKGNvbnZlcnROZWdhdGlvbikpIDogb3AgPT09ICdpbicgPyBjb252ZXJ0SW5PcChmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSkgOiBvcCA9PT0gJyFpbicgPyBjb252ZXJ0TmVnYXRpb24oY29udmVydEluT3AoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMikpKSA6IG9wID09PSAnaGFzJyA/IGNvbnZlcnRIYXNPcChmaWx0ZXJbMV0pIDogb3AgPT09ICchaGFzJyA/IGNvbnZlcnROZWdhdGlvbihjb252ZXJ0SGFzT3AoZmlsdGVyWzFdKSkgOiB0cnVlO1xuICAgIHJldHVybiBjb252ZXJ0ZWQ7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29tcGFyaXNvbk9wKHByb3BlcnR5LCB2YWx1ZSwgb3ApIHtcbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnJHR5cGUnOlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2ZpbHRlci10eXBlLScgKyBvcCxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgY2FzZSAnJGlkJzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdmaWx0ZXItaWQtJyArIG9wLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgXTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2ZpbHRlci0nICsgb3AsXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydERpc2p1bmN0aW9uT3AoZmlsdGVycykge1xuICAgIHJldHVybiBbJ2FueSddLmNvbmNhdChmaWx0ZXJzLm1hcChjb252ZXJ0RmlsdGVyKSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0SW5PcChwcm9wZXJ0eSwgdmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnJHR5cGUnOlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2ZpbHRlci10eXBlLWluJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgdmFsdWVzXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgY2FzZSAnJGlkJzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdmaWx0ZXItaWQtaW4nLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB2YWx1ZXNcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDIwMCAmJiAhdmFsdWVzLnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHYgIT09IHR5cGVvZiB2YWx1ZXNbMF07XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnZmlsdGVyLWluLWxhcmdlJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNvcnQoY29tcGFyZSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnZmlsdGVyLWluLXNtYWxsJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRIYXNPcChwcm9wZXJ0eSkge1xuICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICBjYXNlICckdHlwZSc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJyRpZCc6XG4gICAgICAgIHJldHVybiBbJ2ZpbHRlci1oYXMtaWQnXTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2ZpbHRlci1oYXMnLFxuICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgXTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0TmVnYXRpb24oZmlsdGVyKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJyEnLFxuICAgICAgICBmaWx0ZXJcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RmlsdGVyJDEoZmlsdGVyKSB7XG4gICAgcmV0dXJuIF9jb252ZXJ0RmlsdGVyKGZpbHRlciwge30pO1xufVxuZnVuY3Rpb24gX2NvbnZlcnRGaWx0ZXIoZmlsdGVyLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgdmFyIHJlZiQxO1xuICAgIGlmIChpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH1cbiAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIG9wID0gZmlsdGVyWzBdO1xuICAgIGlmIChmaWx0ZXIubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIG9wICE9PSAnYW55JztcbiAgICB9XG4gICAgdmFyIGNvbnZlcnRlZDtcbiAgICBpZiAob3AgPT09ICc9PScgfHwgb3AgPT09ICchPScgfHwgb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9wID09PSAnPD0nIHx8IG9wID09PSAnPj0nKSB7XG4gICAgICAgIHZhciByZWYgPSBmaWx0ZXI7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVmWzJdO1xuICAgICAgICBjb252ZXJ0ZWQgPSBjb252ZXJ0Q29tcGFyaXNvbk9wJDEocHJvcGVydHksIHZhbHVlLCBvcCwgZXhwZWN0ZWRUeXBlcyk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJ2FueScpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZmlsdGVyLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgdmFyIHR5cGVzID0ge307XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfY29udmVydEZpbHRlcihmLCB0eXBlcyk7XG4gICAgICAgICAgICB2YXIgdHlwZWNoZWNrcyA9IHJ1bnRpbWVUeXBlQ2hlY2tzKHR5cGVzKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlY2hlY2tzID09PSB0cnVlID8gY2hpbGQgOiBbXG4gICAgICAgICAgICAgICAgJ2Nhc2UnLFxuICAgICAgICAgICAgICAgIHR5cGVjaGVja3MsXG4gICAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWydhbnknXS5jb25jYXQoY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICdhbGwnKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiQxID0gZmlsdGVyLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgcmV0dXJuIF9jb252ZXJ0RmlsdGVyKGYsIGV4cGVjdGVkVHlwZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuJDEubGVuZ3RoID4gMSA/IFsnYWxsJ10uY29uY2F0KGNoaWxkcmVuJDEpIDogKHJlZiQxID0gW10pLmNvbmNhdC5hcHBseShyZWYkMSwgY2hpbGRyZW4kMSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnIScsXG4gICAgICAgICAgICBfY29udmVydEZpbHRlcihbJ2FueSddLmNvbmNhdChmaWx0ZXIuc2xpY2UoMSkpLCB7fSlcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnaW4nKSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IGNvbnZlcnRJbk9wJDEoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMikpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICchaW4nKSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IGNvbnZlcnRJbk9wJDEoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMiksIHRydWUpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICdoYXMnKSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IGNvbnZlcnRIYXNPcCQxKGZpbHRlclsxXSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyFoYXMnKSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IFtcbiAgICAgICAgICAgICchJyxcbiAgICAgICAgICAgIGNvbnZlcnRIYXNPcCQxKGZpbHRlclsxXSlcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb252ZXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkO1xufVxuZnVuY3Rpb24gcnVudGltZVR5cGVDaGVja3MoZXhwZWN0ZWRUeXBlcykge1xuICAgIHZhciBjb25kaXRpb25zID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZXhwZWN0ZWRUeXBlcykge1xuICAgICAgICB2YXIgZ2V0ID0gcHJvcGVydHkgPT09ICckaWQnID8gWydpZCddIDogW1xuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICBdO1xuICAgICAgICBjb25kaXRpb25zLnB1c2goW1xuICAgICAgICAgICAgJz09JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAndHlwZW9mJyxcbiAgICAgICAgICAgICAgICBnZXRcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzW3Byb3BlcnR5XVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnNbMF07XG4gICAgfVxuICAgIHJldHVybiBbJ2FsbCddLmNvbmNhdChjb25kaXRpb25zKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRDb21wYXJpc29uT3AkMShwcm9wZXJ0eSwgdmFsdWUsIG9wLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgdmFyIGdldDtcbiAgICBpZiAocHJvcGVydHkgPT09ICckdHlwZScpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9wLFxuICAgICAgICAgICAgWydnZW9tZXRyeS10eXBlJ10sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICckaWQnKSB7XG4gICAgICAgIGdldCA9IFsnaWQnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXQgPSBbXG4gICAgICAgICAgICAnZ2V0JyxcbiAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgIF07XG4gICAgfVxuICAgIGlmIChleHBlY3RlZFR5cGVzICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICBleHBlY3RlZFR5cGVzW3Byb3BlcnR5XSA9IHR5cGU7XG4gICAgfVxuICAgIGlmIChvcCA9PT0gJz09JyAmJiBwcm9wZXJ0eSAhPT0gJyRpZCcgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdhbGwnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdoYXMnLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc9PScsXG4gICAgICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnIT0nICYmIHByb3BlcnR5ICE9PSAnJGlkJyAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2FueScsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJyEnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ2hhcycsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnIT0nLFxuICAgICAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIG9wLFxuICAgICAgICBnZXQsXG4gICAgICAgIHZhbHVlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRJbk9wJDEocHJvcGVydHksIHZhbHVlcywgbmVnYXRlKSB7XG4gICAgaWYgKG5lZ2F0ZSA9PT0gdm9pZCAwKVxuICAgICAgICBuZWdhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmVnYXRlO1xuICAgIH1cbiAgICB2YXIgZ2V0O1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJyR0eXBlJykge1xuICAgICAgICBnZXQgPSBbJ2dlb21ldHJ5LXR5cGUnXTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnJGlkJykge1xuICAgICAgICBnZXQgPSBbJ2lkJ107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0ID0gW1xuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICBdO1xuICAgIH1cbiAgICB2YXIgdW5pZm9ybVR5cGVzID0gdHJ1ZTtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZXNbMF07XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSB2YWx1ZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHVuaWZvcm1UeXBlcyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVuaWZvcm1UeXBlcyAmJiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHZhciB1bmlxdWVWYWx1ZXMgPSB2YWx1ZXMuc29ydCgpLmZpbHRlcihmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgPT09IDAgfHwgdmFsdWVzW2kgLSAxXSAhPT0gdjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnbWF0Y2gnLFxuICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgdW5pcXVlVmFsdWVzLFxuICAgICAgICAgICAgIW5lZ2F0ZSxcbiAgICAgICAgICAgIG5lZ2F0ZVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW25lZ2F0ZSA/ICdhbGwnIDogJ2FueSddLmNvbmNhdCh2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZWdhdGUgPyAnIT0nIDogJz09JyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIHZcbiAgICAgICAgXTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0SGFzT3AkMShwcm9wZXJ0eSkge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJyR0eXBlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnJGlkJykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJyE9JyxcbiAgICAgICAgICAgIFsnaWQnXSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2hhcycsXG4gICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWlncmF0ZVRvRXhwcmVzc2lvbnMgKHN0eWxlKSB7XG4gICAgdmFyIGNvbnZlcnRlZCA9IFtdO1xuICAgIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmIChsYXllci5maWx0ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmZpbHRlciA9IGNvbnZlcnRGaWx0ZXIkMShsYXllci5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZWFjaFByb3BlcnR5KHN0eWxlLCB7XG4gICAgICAgIHBhaW50OiB0cnVlLFxuICAgICAgICBsYXlvdXQ6IHRydWVcbiAgICB9LCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZSA9IHJlZi5yZWZlcmVuY2U7XG4gICAgICAgIHZhciBzZXQgPSByZWYuc2V0O1xuICAgICAgICBpZiAoaXNFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgc2V0KGNvbnZlcnRGdW5jdGlvbih2YWx1ZSwgcmVmZXJlbmNlKSk7XG4gICAgICAgICAgICBjb252ZXJ0ZWQucHVzaChwYXRoLmpvaW4oJy4nKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJlbmNlLnRva2VucyAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZXQoY29udmVydFRva2VuU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIG1pZ3JhdGUgKHN0eWxlKSB7XG4gICAgdmFyIG1pZ3JhdGVkID0gZmFsc2U7XG4gICAgaWYgKHN0eWxlLnZlcnNpb24gPT09IDcpIHtcbiAgICAgICAgc3R5bGUgPSBtaWdyYXRlVG9WOChzdHlsZSk7XG4gICAgICAgIG1pZ3JhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlLnZlcnNpb24gPT09IDgpIHtcbiAgICAgICAgbWlncmF0ZWQgPSBtaWdyYXRlVG9FeHByZXNzaW9ucyhzdHlsZSk7XG4gICAgICAgIG1pZ3JhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFtaWdyYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBtaWdyYXRlIGZyb20nLCBzdHlsZS52ZXJzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NpdGUgKHN0eWxlKSB7XG4gICAgdmFyIHN0eWxlSURzID0gW107XG4gICAgdmFyIHNvdXJjZUlEcyA9IFtdO1xuICAgIHZhciBjb21wb3NpdGVkU291cmNlTGF5ZXJzID0gW107XG4gICAgZm9yICh2YXIgaWQgaW4gc3R5bGUuc291cmNlcykge1xuICAgICAgICB2YXIgc291cmNlID0gc3R5bGUuc291cmNlc1tpZF07XG4gICAgICAgIGlmIChzb3VyY2UudHlwZSAhPT0gJ3ZlY3RvcicpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCA9IC9ebWFwYm94OlxcL1xcLyguKikvLmV4ZWMoc291cmNlLnVybCk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlSURzLnB1c2goaWQpO1xuICAgICAgICBzb3VyY2VJRHMucHVzaChtYXRjaFsxXSk7XG4gICAgfVxuICAgIGlmIChzdHlsZUlEcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gICAgc3R5bGVJRHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgZGVsZXRlIHN0eWxlLnNvdXJjZXNbaWRdO1xuICAgIH0pO1xuICAgIHZhciBjb21wb3NpdGVJRCA9IHNvdXJjZUlEcy5qb2luKCcsJyk7XG4gICAgc3R5bGUuc291cmNlc1tjb21wb3NpdGVJRF0gPSB7XG4gICAgICAgICd0eXBlJzogJ3ZlY3RvcicsXG4gICAgICAgICd1cmwnOiAnbWFwYm94Oi8vJyArIGNvbXBvc2l0ZUlEXG4gICAgfTtcbiAgICBzdHlsZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKHN0eWxlSURzLmluZGV4T2YobGF5ZXIuc291cmNlKSA+PSAwKSB7XG4gICAgICAgICAgICBsYXllci5zb3VyY2UgPSBjb21wb3NpdGVJRDtcbiAgICAgICAgICAgIGlmICgnc291cmNlLWxheWVyJyBpbiBsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb3NpdGVkU291cmNlTGF5ZXJzLmluZGV4T2YobGF5ZXJbJ3NvdXJjZS1sYXllciddKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmxpY3Rpbmcgc291cmNlIGxheWVyIG5hbWVzJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlZFNvdXJjZUxheWVycy5wdXNoKGxheWVyWydzb3VyY2UtbGF5ZXInXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG52YXIgcmVmUHJvcGVydGllcyA9IFtcbiAgICAndHlwZScsXG4gICAgJ3NvdXJjZScsXG4gICAgJ3NvdXJjZS1sYXllcicsXG4gICAgJ21pbnpvb20nLFxuICAgICdtYXh6b29tJyxcbiAgICAnZmlsdGVyJyxcbiAgICAnbGF5b3V0J1xuXTtcblxuZnVuY3Rpb24gZGVyZWYobGF5ZXIsIHBhcmVudCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBrIGluIGxheWVyKSB7XG4gICAgICAgIGlmIChrICE9PSAncmVmJykge1xuICAgICAgICAgICAgcmVzdWx0W2tdID0gbGF5ZXJba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrIGluIHBhcmVudCkge1xuICAgICAgICAgICAgcmVzdWx0W2tdID0gcGFyZW50W2tdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRlcmVmTGF5ZXJzKGxheWVycykge1xuICAgIGxheWVycyA9IGxheWVycy5zbGljZSgpO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcFtsYXllcnNbaV0uaWRdID0gbGF5ZXJzW2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsYXllcnMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICBpZiAoJ3JlZicgaW4gbGF5ZXJzW2kkMV0pIHtcbiAgICAgICAgICAgIGxheWVyc1tpJDFdID0gZGVyZWYobGF5ZXJzW2kkMV0sIG1hcFtsYXllcnNbaSQxXS5yZWZdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzO1xufVxuXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoISh0eXBlb2YgYiA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cblxudmFyIG9wZXJhdGlvbnMgPSB7XG4gICAgc2V0U3R5bGU6ICdzZXRTdHlsZScsXG4gICAgYWRkTGF5ZXI6ICdhZGRMYXllcicsXG4gICAgcmVtb3ZlTGF5ZXI6ICdyZW1vdmVMYXllcicsXG4gICAgc2V0UGFpbnRQcm9wZXJ0eTogJ3NldFBhaW50UHJvcGVydHknLFxuICAgIHNldExheW91dFByb3BlcnR5OiAnc2V0TGF5b3V0UHJvcGVydHknLFxuICAgIHNldEZpbHRlcjogJ3NldEZpbHRlcicsXG4gICAgYWRkU291cmNlOiAnYWRkU291cmNlJyxcbiAgICByZW1vdmVTb3VyY2U6ICdyZW1vdmVTb3VyY2UnLFxuICAgIHNldEdlb0pTT05Tb3VyY2VEYXRhOiAnc2V0R2VvSlNPTlNvdXJjZURhdGEnLFxuICAgIHNldExheWVyWm9vbVJhbmdlOiAnc2V0TGF5ZXJab29tUmFuZ2UnLFxuICAgIHNldExheWVyUHJvcGVydHk6ICdzZXRMYXllclByb3BlcnR5JyxcbiAgICBzZXRDZW50ZXI6ICdzZXRDZW50ZXInLFxuICAgIHNldFpvb206ICdzZXRab29tJyxcbiAgICBzZXRCZWFyaW5nOiAnc2V0QmVhcmluZycsXG4gICAgc2V0UGl0Y2g6ICdzZXRQaXRjaCcsXG4gICAgc2V0U3ByaXRlOiAnc2V0U3ByaXRlJyxcbiAgICBzZXRHbHlwaHM6ICdzZXRHbHlwaHMnLFxuICAgIHNldFRyYW5zaXRpb246ICdzZXRUcmFuc2l0aW9uJyxcbiAgICBzZXRMaWdodDogJ3NldExpZ2h0J1xufTtcbmZ1bmN0aW9uIGFkZFNvdXJjZShzb3VyY2VJZCwgYWZ0ZXIsIGNvbW1hbmRzKSB7XG4gICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuYWRkU291cmNlLFxuICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICBzb3VyY2VJZCxcbiAgICAgICAgICAgIGFmdGVyW3NvdXJjZUlkXVxuICAgICAgICBdXG4gICAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCkge1xuICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZVNvdXJjZSxcbiAgICAgICAgYXJnczogW3NvdXJjZUlkXVxuICAgIH0pO1xuICAgIHNvdXJjZXNSZW1vdmVkW3NvdXJjZUlkXSA9IHRydWU7XG59XG5mdW5jdGlvbiB1cGRhdGVTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpIHtcbiAgICByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7XG4gICAgYWRkU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gY2FuVXBkYXRlR2VvSlNPTihiZWZvcmUsIGFmdGVyLCBzb3VyY2VJZCkge1xuICAgIHZhciBwcm9wO1xuICAgIGZvciAocHJvcCBpbiBiZWZvcmVbc291cmNlSWRdKSB7XG4gICAgICAgIGlmICghYmVmb3JlW3NvdXJjZUlkXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3AgIT09ICdkYXRhJyAmJiAhZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF1bcHJvcF0sIGFmdGVyW3NvdXJjZUlkXVtwcm9wXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3AgaW4gYWZ0ZXJbc291cmNlSWRdKSB7XG4gICAgICAgIGlmICghYWZ0ZXJbc291cmNlSWRdLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcCAhPT0gJ2RhdGEnICYmICFkZWVwRXF1YWwoYmVmb3JlW3NvdXJjZUlkXVtwcm9wXSwgYWZ0ZXJbc291cmNlSWRdW3Byb3BdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGlmZlNvdXJjZXMoYmVmb3JlLCBhZnRlciwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKSB7XG4gICAgYmVmb3JlID0gYmVmb3JlIHx8IHt9O1xuICAgIGFmdGVyID0gYWZ0ZXIgfHwge307XG4gICAgdmFyIHNvdXJjZUlkO1xuICAgIGZvciAoc291cmNlSWQgaW4gYmVmb3JlKSB7XG4gICAgICAgIGlmICghYmVmb3JlLmhhc093blByb3BlcnR5KHNvdXJjZUlkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhZnRlci5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVNvdXJjZShzb3VyY2VJZCwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHNvdXJjZUlkIGluIGFmdGVyKSB7XG4gICAgICAgIGlmICghYWZ0ZXIuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgIGFkZFNvdXJjZShzb3VyY2VJZCwgYWZ0ZXIsIGNvbW1hbmRzKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF0sIGFmdGVyW3NvdXJjZUlkXSkpIHtcbiAgICAgICAgICAgIGlmIChiZWZvcmVbc291cmNlSWRdLnR5cGUgPT09ICdnZW9qc29uJyAmJiBhZnRlcltzb3VyY2VJZF0udHlwZSA9PT0gJ2dlb2pzb24nICYmIGNhblVwZGF0ZUdlb0pTT04oYmVmb3JlLCBhZnRlciwgc291cmNlSWQpKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0R2VvSlNPTlNvdXJjZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJbc291cmNlSWRdLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZSwgYWZ0ZXIsIGNvbW1hbmRzLCBsYXllcklkLCBrbGFzcywgY29tbWFuZCkge1xuICAgIGJlZm9yZSA9IGJlZm9yZSB8fCB7fTtcbiAgICBhZnRlciA9IGFmdGVyIHx8IHt9O1xuICAgIHZhciBwcm9wO1xuICAgIGZvciAocHJvcCBpbiBiZWZvcmUpIHtcbiAgICAgICAgaWYgKCFiZWZvcmUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZVtwcm9wXSwgYWZ0ZXJbcHJvcF0pKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJbcHJvcF0sXG4gICAgICAgICAgICAgICAgICAgIGtsYXNzXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wIGluIGFmdGVyKSB7XG4gICAgICAgIGlmICghYWZ0ZXIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgYmVmb3JlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVbcHJvcF0sIGFmdGVyW3Byb3BdKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyW3Byb3BdLFxuICAgICAgICAgICAgICAgICAgICBrbGFzc1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGx1Y2tJZChsYXllcikge1xuICAgIHJldHVybiBsYXllci5pZDtcbn1cbmZ1bmN0aW9uIGluZGV4QnlJZChncm91cCwgbGF5ZXIpIHtcbiAgICBncm91cFtsYXllci5pZF0gPSBsYXllcjtcbiAgICByZXR1cm4gZ3JvdXA7XG59XG5mdW5jdGlvbiBkaWZmTGF5ZXJzKGJlZm9yZSwgYWZ0ZXIsIGNvbW1hbmRzKSB7XG4gICAgYmVmb3JlID0gYmVmb3JlIHx8IFtdO1xuICAgIGFmdGVyID0gYWZ0ZXIgfHwgW107XG4gICAgdmFyIGJlZm9yZU9yZGVyID0gYmVmb3JlLm1hcChwbHVja0lkKTtcbiAgICB2YXIgYWZ0ZXJPcmRlciA9IGFmdGVyLm1hcChwbHVja0lkKTtcbiAgICB2YXIgYmVmb3JlSW5kZXggPSBiZWZvcmUucmVkdWNlKGluZGV4QnlJZCwge30pO1xuICAgIHZhciBhZnRlckluZGV4ID0gYWZ0ZXIucmVkdWNlKGluZGV4QnlJZCwge30pO1xuICAgIHZhciB0cmFja2VyID0gYmVmb3JlT3JkZXIuc2xpY2UoKTtcbiAgICB2YXIgY2xlYW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBpLCBkLCBsYXllcklkLCBiZWZvcmVMYXllciwgYWZ0ZXJMYXllciwgaW5zZXJ0QmVmb3JlTGF5ZXJJZCwgcHJvcDtcbiAgICBmb3IgKGkgPSAwLCBkID0gMDsgaSA8IGJlZm9yZU9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxheWVySWQgPSBiZWZvcmVPcmRlcltpXTtcbiAgICAgICAgaWYgKCFhZnRlckluZGV4Lmhhc093blByb3BlcnR5KGxheWVySWQpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZUxheWVyLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtsYXllcklkXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmFja2VyLnNwbGljZSh0cmFja2VyLmluZGV4T2YobGF5ZXJJZCwgZCksIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGQgPSAwOyBpIDwgYWZ0ZXJPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYXllcklkID0gYWZ0ZXJPcmRlclthZnRlck9yZGVyLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgaWYgKHRyYWNrZXJbdHJhY2tlci5sZW5ndGggLSAxIC0gaV0gPT09IGxheWVySWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWZvcmVJbmRleC5oYXNPd25Qcm9wZXJ0eShsYXllcklkKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXJJZF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhY2tlci5zcGxpY2UodHJhY2tlci5sYXN0SW5kZXhPZihsYXllcklkLCB0cmFja2VyLmxlbmd0aCAtIGQpLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQrKztcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkID0gdHJhY2tlclt0cmFja2VyLmxlbmd0aCAtIGldO1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuYWRkTGF5ZXIsXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgYWZ0ZXJJbmRleFtsYXllcklkXSxcbiAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICB0cmFja2VyLnNwbGljZSh0cmFja2VyLmxlbmd0aCAtIGksIDAsIGxheWVySWQpO1xuICAgICAgICBjbGVhbltsYXllcklkXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhZnRlck9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxheWVySWQgPSBhZnRlck9yZGVyW2ldO1xuICAgICAgICBiZWZvcmVMYXllciA9IGJlZm9yZUluZGV4W2xheWVySWRdO1xuICAgICAgICBhZnRlckxheWVyID0gYWZ0ZXJJbmRleFtsYXllcklkXTtcbiAgICAgICAgaWYgKGNsZWFuW2xheWVySWRdIHx8IGRlZXBFcXVhbChiZWZvcmVMYXllciwgYWZ0ZXJMYXllcikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyLnNvdXJjZSwgYWZ0ZXJMYXllci5zb3VyY2UpIHx8ICFkZWVwRXF1YWwoYmVmb3JlTGF5ZXJbJ3NvdXJjZS1sYXllciddLCBhZnRlckxheWVyWydzb3VyY2UtbGF5ZXInXSkgfHwgIWRlZXBFcXVhbChiZWZvcmVMYXllci50eXBlLCBhZnRlckxheWVyLnR5cGUpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZUxheWVyLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtsYXllcklkXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkID0gdHJhY2tlclt0cmFja2VyLmxhc3RJbmRleE9mKGxheWVySWQpICsgMV07XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLmFkZExheWVyLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllcixcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTGF5ZXJJZFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyLmxheW91dCwgYWZ0ZXJMYXllci5sYXlvdXQsIGNvbW1hbmRzLCBsYXllcklkLCBudWxsLCBvcGVyYXRpb25zLnNldExheW91dFByb3BlcnR5KTtcbiAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyLnBhaW50LCBhZnRlckxheWVyLnBhaW50LCBjb21tYW5kcywgbGF5ZXJJZCwgbnVsbCwgb3BlcmF0aW9ucy5zZXRQYWludFByb3BlcnR5KTtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIuZmlsdGVyLCBhZnRlckxheWVyLmZpbHRlcikpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0RmlsdGVyLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllci5maWx0ZXJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllci5taW56b29tLCBhZnRlckxheWVyLm1pbnpvb20pIHx8ICFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIubWF4em9vbSwgYWZ0ZXJMYXllci5tYXh6b29tKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRMYXllclpvb21SYW5nZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyTGF5ZXIubWluem9vbSxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllci5tYXh6b29tXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIGJlZm9yZUxheWVyKSB7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZUxheWVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2xheW91dCcgfHwgcHJvcCA9PT0gJ3BhaW50JyB8fCBwcm9wID09PSAnZmlsdGVyJyB8fCBwcm9wID09PSAnbWV0YWRhdGEnIHx8IHByb3AgPT09ICdtaW56b29tJyB8fCBwcm9wID09PSAnbWF4em9vbScpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wLmluZGV4T2YoJ3BhaW50LicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdLCBjb21tYW5kcywgbGF5ZXJJZCwgcHJvcC5zbGljZSg2KSwgb3BlcmF0aW9ucy5zZXRQYWludFByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllcltwcm9wXSwgYWZ0ZXJMYXllcltwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRMYXllclByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGF5ZXJbcHJvcF1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBhZnRlckxheWVyKSB7XG4gICAgICAgICAgICBpZiAoIWFmdGVyTGF5ZXIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgYmVmb3JlTGF5ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnbGF5b3V0JyB8fCBwcm9wID09PSAncGFpbnQnIHx8IHByb3AgPT09ICdmaWx0ZXInIHx8IHByb3AgPT09ICdtZXRhZGF0YScgfHwgcHJvcCA9PT0gJ21pbnpvb20nIHx8IHByb3AgPT09ICdtYXh6b29tJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AuaW5kZXhPZigncGFpbnQuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlTGF5ZXJbcHJvcF0sIGFmdGVyTGF5ZXJbcHJvcF0sIGNvbW1hbmRzLCBsYXllcklkLCBwcm9wLnNsaWNlKDYpLCBvcGVyYXRpb25zLnNldFBhaW50UHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldExheWVyUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllcltwcm9wXVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkaWZmU3R5bGVzKGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBpZiAoIWJlZm9yZSkge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlcl1cbiAgICAgICAgICAgIH1dO1xuICAgIH1cbiAgICB2YXIgY29tbWFuZHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUudmVyc2lvbiwgYWZ0ZXIudmVyc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXJdXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmNlbnRlciwgYWZ0ZXIuY2VudGVyKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRDZW50ZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmNlbnRlcl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS56b29tLCBhZnRlci56b29tKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRab29tLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci56b29tXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmJlYXJpbmcsIGFmdGVyLmJlYXJpbmcpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEJlYXJpbmcsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmJlYXJpbmddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUucGl0Y2gsIGFmdGVyLnBpdGNoKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRQaXRjaCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIucGl0Y2hdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuc3ByaXRlLCBhZnRlci5zcHJpdGUpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFNwcml0ZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIuc3ByaXRlXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmdseXBocywgYWZ0ZXIuZ2x5cGhzKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRHbHlwaHMsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmdseXBoc11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS50cmFuc2l0aW9uLCBhZnRlci50cmFuc2l0aW9uKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRUcmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci50cmFuc2l0aW9uXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmxpZ2h0LCBhZnRlci5saWdodCkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGlnaHQsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmxpZ2h0XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZXNSZW1vdmVkID0ge307XG4gICAgICAgIHZhciByZW1vdmVPckFkZFNvdXJjZUNvbW1hbmRzID0gW107XG4gICAgICAgIGRpZmZTb3VyY2VzKGJlZm9yZS5zb3VyY2VzLCBhZnRlci5zb3VyY2VzLCByZW1vdmVPckFkZFNvdXJjZUNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7XG4gICAgICAgIHZhciBiZWZvcmVMYXllcnMgPSBbXTtcbiAgICAgICAgaWYgKGJlZm9yZS5sYXllcnMpIHtcbiAgICAgICAgICAgIGJlZm9yZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlc1JlbW92ZWRbbGF5ZXIuc291cmNlXSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlTGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXIuaWRdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb21tYW5kcyA9IGNvbW1hbmRzLmNvbmNhdChyZW1vdmVPckFkZFNvdXJjZUNvbW1hbmRzKTtcbiAgICAgICAgZGlmZkxheWVycyhiZWZvcmVMYXllcnMsIGFmdGVyLmxheWVycywgY29tbWFuZHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gY29tcHV0ZSBzdHlsZSBkaWZmOicsIGUpO1xuICAgICAgICBjb21tYW5kcyA9IFt7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTdHlsZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXJdXG4gICAgICAgICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzO1xufVxuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIG1lc3NhZ2UsIGlkZW50aWZpZXIpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAoa2V5ID8ga2V5ICsgJzogJyA6ICcnKSArIG1lc3NhZ2U7XG4gICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuX19saW5lX18pIHtcbiAgICAgICAgdGhpcy5saW5lID0gdmFsdWUuX19saW5lX187XG4gICAgfVxufTtcblxudmFyIFBhcnNpbmdFcnJvciQxID0gZnVuY3Rpb24gUGFyc2luZ0Vycm9yKGVycm9yKSB7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgdmFyIG1hdGNoID0gZXJyb3IubWVzc2FnZS5tYXRjaCgvbGluZSAoXFxkKykvKTtcbiAgICB0aGlzLmxpbmUgPSBtYXRjaCA/IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgOiAwO1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVDb25zdGFudHMob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgY29uc3RhbnRzID0gb3B0aW9ucy52YWx1ZTtcbiAgICBpZiAoY29uc3RhbnRzKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGNvbnN0YW50cywgJ2NvbnN0YW50cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2OCcpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bmJ1bmRsZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVlcFVuYnVuZGxlKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZGVlcFVuYnVuZGxlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmICEodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSkge1xuICAgICAgICB2YXIgdW5idW5kbGVkVmFsdWUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICB1bmJ1bmRsZWRWYWx1ZVtrZXldID0gZGVlcFVuYnVuZGxlKHZhbHVlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmJ1bmRsZWRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuYnVuZGxlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgb2JqZWN0ID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgZWxlbWVudFNwZWNzID0gb3B0aW9ucy52YWx1ZVNwZWMgfHwge307XG4gICAgdmFyIGVsZW1lbnRWYWxpZGF0b3JzID0gb3B0aW9ucy5vYmplY3RFbGVtZW50VmFsaWRhdG9ycyB8fCB7fTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKG9iamVjdCk7XG4gICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG9iamVjdCwgJ29iamVjdCBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldO1xuICAgIH1cbiAgICBmb3IgKHZhciBvYmplY3RLZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHZhciBlbGVtZW50U3BlY0tleSA9IG9iamVjdEtleS5zcGxpdCgnLicpWzBdO1xuICAgICAgICB2YXIgZWxlbWVudFNwZWMgPSBlbGVtZW50U3BlY3NbZWxlbWVudFNwZWNLZXldIHx8IGVsZW1lbnRTcGVjc1snKiddO1xuICAgICAgICB2YXIgdmFsaWRhdGVFbGVtZW50ID0gdm9pZCAwO1xuICAgICAgICBpZiAoZWxlbWVudFZhbGlkYXRvcnNbZWxlbWVudFNwZWNLZXldKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUVsZW1lbnQgPSBlbGVtZW50VmFsaWRhdG9yc1tlbGVtZW50U3BlY0tleV07XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFNwZWNzW2VsZW1lbnRTcGVjS2V5XSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gdmFsaWRhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFZhbGlkYXRvcnNbJyonXSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gZWxlbWVudFZhbGlkYXRvcnNbJyonXTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50U3BlY3NbJyonXSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gdmFsaWRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0W29iamVjdEtleV0sICd1bmtub3duIHByb3BlcnR5IFwiJyArIG9iamVjdEtleSArICdcIicpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbGVtZW50KHtcbiAgICAgICAgICAgIGtleTogKGtleSA/IGtleSArICcuJyA6IGtleSkgKyBvYmplY3RLZXksXG4gICAgICAgICAgICB2YWx1ZTogb2JqZWN0W29iamVjdEtleV0sXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IGVsZW1lbnRTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICAgIG9iamVjdEtleTogb2JqZWN0S2V5XG4gICAgICAgIH0sIG9iamVjdCkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBlbGVtZW50U3BlY0tleSQxIGluIGVsZW1lbnRTcGVjcykge1xuICAgICAgICBpZiAoZWxlbWVudFZhbGlkYXRvcnNbZWxlbWVudFNwZWNLZXkkMV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50U3BlY3NbZWxlbWVudFNwZWNLZXkkMV0ucmVxdWlyZWQgJiYgZWxlbWVudFNwZWNzW2VsZW1lbnRTcGVjS2V5JDFdWydkZWZhdWx0J10gPT09IHVuZGVmaW5lZCAmJiBvYmplY3RbZWxlbWVudFNwZWNLZXkkMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG9iamVjdCwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCInICsgZWxlbWVudFNwZWNLZXkkMSArICdcIicpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5KG9wdGlvbnMpIHtcbiAgICB2YXIgYXJyYXkgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBhcnJheVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHZhbGlkYXRlQXJyYXlFbGVtZW50ID0gb3B0aW9ucy5hcnJheUVsZW1lbnRWYWxpZGF0b3IgfHwgdmFsaWRhdGU7XG4gICAgaWYgKGdldFR5cGUoYXJyYXkpICE9PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCAnYXJyYXkgZXhwZWN0ZWQsICcgKyBnZXRUeXBlKGFycmF5KSArICcgZm91bmQnKV07XG4gICAgfVxuICAgIGlmIChhcnJheVNwZWMubGVuZ3RoICYmIGFycmF5Lmxlbmd0aCAhPT0gYXJyYXlTcGVjLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgJ2FycmF5IGxlbmd0aCAnICsgYXJyYXlTcGVjLmxlbmd0aCArICcgZXhwZWN0ZWQsIGxlbmd0aCAnICsgYXJyYXkubGVuZ3RoICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgaWYgKGFycmF5U3BlY1snbWluLWxlbmd0aCddICYmIGFycmF5Lmxlbmd0aCA8IGFycmF5U3BlY1snbWluLWxlbmd0aCddKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCAnYXJyYXkgbGVuZ3RoIGF0IGxlYXN0ICcgKyBhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSArICcgZXhwZWN0ZWQsIGxlbmd0aCAnICsgYXJyYXkubGVuZ3RoICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgdmFyIGFycmF5RWxlbWVudFNwZWMgPSB7XG4gICAgICAgICd0eXBlJzogYXJyYXlTcGVjLnZhbHVlLFxuICAgICAgICAndmFsdWVzJzogYXJyYXlTcGVjLnZhbHVlc1xuICAgIH07XG4gICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA8IDcpIHtcbiAgICAgICAgYXJyYXlFbGVtZW50U3BlYy5mdW5jdGlvbiA9IGFycmF5U3BlYy5mdW5jdGlvbjtcbiAgICB9XG4gICAgaWYgKGdldFR5cGUoYXJyYXlTcGVjLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXJyYXlFbGVtZW50U3BlYyA9IGFycmF5U3BlYy52YWx1ZTtcbiAgICB9XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUFycmF5RWxlbWVudCh7XG4gICAgICAgICAgICBhcnJheTogYXJyYXksXG4gICAgICAgICAgICBhcnJheUluZGV4OiBpLFxuICAgICAgICAgICAgdmFsdWU6IGFycmF5W2ldLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBhcnJheUVsZW1lbnRTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgICAgICBrZXk6IGtleSArICdbJyArIGkgKyAnXSdcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICB0eXBlID0gJ05hTic7XG4gICAgfVxuICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ251bWJlciBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldO1xuICAgIH1cbiAgICBpZiAoJ21pbmltdW0nIGluIHZhbHVlU3BlYyAmJiB2YWx1ZSA8IHZhbHVlU3BlYy5taW5pbXVtKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCB2YWx1ZSArICcgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHZhbHVlICcgKyB2YWx1ZVNwZWMubWluaW11bSldO1xuICAgIH1cbiAgICBpZiAoJ21heGltdW0nIGluIHZhbHVlU3BlYyAmJiB2YWx1ZSA+IHZhbHVlU3BlYy5tYXhpbXVtKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCB2YWx1ZSArICcgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlICcgKyB2YWx1ZVNwZWMubWF4aW11bSldO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBmdW5jdGlvblZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciBmdW5jdGlvblR5cGUgPSB1bmJ1bmRsZShvcHRpb25zLnZhbHVlLnR5cGUpO1xuICAgIHZhciBzdG9wS2V5VHlwZTtcbiAgICB2YXIgc3RvcERvbWFpblZhbHVlcyA9IHt9O1xuICAgIHZhciBwcmV2aW91c1N0b3BEb21haW5WYWx1ZTtcbiAgICB2YXIgcHJldmlvdXNTdG9wRG9tYWluWm9vbTtcbiAgICB2YXIgaXNab29tRnVuY3Rpb24gPSBmdW5jdGlvblR5cGUgIT09ICdjYXRlZ29yaWNhbCcgJiYgb3B0aW9ucy52YWx1ZS5wcm9wZXJ0eSA9PT0gdW5kZWZpbmVkO1xuICAgIHZhciBpc1Byb3BlcnR5RnVuY3Rpb24gPSAhaXNab29tRnVuY3Rpb247XG4gICAgdmFyIGlzWm9vbUFuZFByb3BlcnR5RnVuY3Rpb24gPSBnZXRUeXBlKG9wdGlvbnMudmFsdWUuc3RvcHMpID09PSAnYXJyYXknICYmIGdldFR5cGUob3B0aW9ucy52YWx1ZS5zdG9wc1swXSkgPT09ICdhcnJheScgJiYgZ2V0VHlwZShvcHRpb25zLnZhbHVlLnN0b3BzWzBdWzBdKSA9PT0gJ29iamVjdCc7XG4gICAgdmFyIGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMuZnVuY3Rpb24sXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgc3RvcHM6IHZhbGlkYXRlRnVuY3Rpb25TdG9wcyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHZhbGlkYXRlRnVuY3Rpb25EZWZhdWx0XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnaWRlbnRpdHknICYmIGlzWm9vbUZ1bmN0aW9uKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwicHJvcGVydHlcIicpKTtcbiAgICB9XG4gICAgaWYgKGZ1bmN0aW9uVHlwZSAhPT0gJ2lkZW50aXR5JyAmJiAhb3B0aW9ucy52YWx1ZS5zdG9wcykge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInN0b3BzXCInKSk7XG4gICAgfVxuICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdleHBvbmVudGlhbCcgJiYgb3B0aW9ucy52YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiAhc3VwcG9ydHNJbnRlcnBvbGF0aW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnZXhwb25lbnRpYWwgZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0eWxlU3BlYy4kdmVyc2lvbiA+PSA4KSB7XG4gICAgICAgIGlmIChpc1Byb3BlcnR5RnVuY3Rpb24gJiYgIXN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ3Byb3BlcnR5IGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzWm9vbUZ1bmN0aW9uICYmICFzdXBwb3J0c1pvb21FeHByZXNzaW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ3pvb20gZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChmdW5jdGlvblR5cGUgPT09ICdjYXRlZ29yaWNhbCcgfHwgaXNab29tQW5kUHJvcGVydHlGdW5jdGlvbikgJiYgb3B0aW9ucy52YWx1ZS5wcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdcInByb3BlcnR5XCIgcHJvcGVydHkgaXMgcmVxdWlyZWQnKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvblN0b3BzKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnaWRlbnRpdHkgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGEgXCJzdG9wc1wiIHByb3BlcnR5JyldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUFycmF5KHtcbiAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IG9wdGlvbnMudmFsdWVTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgYXJyYXlFbGVtZW50VmFsaWRhdG9yOiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ2FycmF5JyAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHZhbHVlLCAnYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdG9wJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25TdG9wKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdhcnJheSBleHBlY3RlZCwgJyArIGdldFR5cGUodmFsdWUpICsgJyBmb3VuZCcpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2FycmF5IGxlbmd0aCAyIGV4cGVjdGVkLCBsZW5ndGggJyArIHZhbHVlLmxlbmd0aCArICcgZm91bmQnKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzWm9vbUFuZFByb3BlcnR5RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChnZXRUeXBlKHZhbHVlWzBdKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ29iamVjdCBleHBlY3RlZCwgJyArIGdldFR5cGUodmFsdWVbMF0pICsgJyBmb3VuZCcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZVswXS56b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ29iamVjdCBzdG9wIGtleSBtdXN0IGhhdmUgem9vbScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZVswXS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHZhbHVlJyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RvcERvbWFpblpvb20gJiYgcHJldmlvdXNTdG9wRG9tYWluWm9vbSA+IHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWVbMF0uem9vbSwgJ3N0b3Agem9vbSB2YWx1ZXMgbXVzdCBhcHBlYXIgaW4gYXNjZW5kaW5nIG9yZGVyJyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pICE9PSBwcmV2aW91c1N0b3BEb21haW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNTdG9wRG9tYWluWm9vbSA9IHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU3RvcERvbWFpblZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHN0b3BEb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1swXScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogeyB6b29tOiB7fSB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgem9vbTogdmFsaWRhdGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWxpZGF0ZVN0b3BEb21haW5WYWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVTdG9wRG9tYWluVmFsdWUoe1xuICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1swXScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzoge30sXG4gICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICAgICAgfSwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFeHByZXNzaW9uKGRlZXBVbmJ1bmRsZSh2YWx1ZVsxXSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzFdJywgdmFsdWVbMV0sICdleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gZnVuY3Rpb24gc3RvcHMuJyldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICBrZXk6IGtleSArICdbMV0nLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzFdLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBmdW5jdGlvblZhbHVlU3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3RvcERvbWFpblZhbHVlKG9wdGlvbnMsIHN0b3ApIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlKG9wdGlvbnMudmFsdWUpO1xuICAgICAgICB2YXIgdmFsdWUgPSB1bmJ1bmRsZShvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgdmFyIHJlcG9ydFZhbHVlID0gb3B0aW9ucy52YWx1ZSAhPT0gbnVsbCA/IG9wdGlvbnMudmFsdWUgOiBzdG9wO1xuICAgICAgICBpZiAoIXN0b3BLZXlUeXBlKSB7XG4gICAgICAgICAgICBzdG9wS2V5VHlwZSA9IHR5cGU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gc3RvcEtleVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsIHR5cGUgKyAnIHN0b3AgZG9tYWluIHR5cGUgbXVzdCBtYXRjaCBwcmV2aW91cyBzdG9wIGRvbWFpbiB0eXBlICcgKyBzdG9wS2V5VHlwZSldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsICdzdG9wIGRvbWFpbiB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLCBzdHJpbmcsIG9yIGJvb2xlYW4nKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmIGZ1bmN0aW9uVHlwZSAhPT0gJ2NhdGVnb3JpY2FsJykge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnbnVtYmVyIGV4cGVjdGVkLCAnICsgdHlwZSArICcgZm91bmQnO1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKGZ1bmN0aW9uVmFsdWVTcGVjKSAmJiBmdW5jdGlvblR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJ1xcbklmIHlvdSBpbnRlbmRlZCB0byB1c2UgYSBjYXRlZ29yaWNhbCBmdW5jdGlvbiwgc3BlY2lmeSBgXCJ0eXBlXCI6IFwiY2F0ZWdvcmljYWxcImAuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsIG1lc3NhZ2UpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHR5cGUgPT09ICdudW1iZXInICYmICghaXNGaW5pdGUodmFsdWUpIHx8IE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsICdpbnRlZ2VyIGV4cGVjdGVkLCBmb3VuZCAnICsgdmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25UeXBlICE9PSAnY2F0ZWdvcmljYWwnICYmIHR5cGUgPT09ICdudW1iZXInICYmIHByZXZpb3VzU3RvcERvbWFpblZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlcyBtdXN0IGFwcGVhciBpbiBhc2NlbmRpbmcgb3JkZXInKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdjYXRlZ29yaWNhbCcgJiYgdmFsdWUgaW4gc3RvcERvbWFpblZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZScpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3BEb21haW5WYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25EZWZhdWx0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHtcbiAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogZnVuY3Rpb25WYWx1ZVNwZWMsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cHJlc3Npb24ob3B0aW9ucykge1xuICAgIHZhciBleHByZXNzaW9uID0gKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdwcm9wZXJ0eScgPyBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24gOiBjcmVhdGVFeHByZXNzaW9uKShkZWVwVW5idW5kbGUob3B0aW9ucy52YWx1ZSksIG9wdGlvbnMudmFsdWVTcGVjKTtcbiAgICBpZiAoZXhwcmVzc2lvbi5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWUubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoJycgKyBvcHRpb25zLmtleSArIGVycm9yLmtleSwgb3B0aW9ucy52YWx1ZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZXhwcmVzc2lvbk9iaiA9IGV4cHJlc3Npb24udmFsdWUuZXhwcmVzc2lvbiB8fCBleHByZXNzaW9uLnZhbHVlLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbjtcbiAgICBpZiAob3B0aW9ucy5leHByZXNzaW9uQ29udGV4dCA9PT0gJ3Byb3BlcnR5JyAmJiBvcHRpb25zLnByb3BlcnR5S2V5ID09PSAndGV4dC1mb250JyAmJiAhZXhwcmVzc2lvbk9iai5vdXRwdXREZWZpbmVkKCkpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnSW52YWxpZCBkYXRhIGV4cHJlc3Npb24gZm9yIFwiJyArIG9wdGlvbnMucHJvcGVydHlLZXkgKyAnXCIuIE91dHB1dCB2YWx1ZXMgbXVzdCBiZSBjb250YWluZWQgYXMgbGl0ZXJhbHMgd2l0aGluIHRoZSBleHByZXNzaW9uLicpXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdwcm9wZXJ0eScgJiYgb3B0aW9ucy5wcm9wZXJ0eVR5cGUgPT09ICdsYXlvdXQnICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbk9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnXCJmZWF0dXJlLXN0YXRlXCIgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGxheW91dCBwcm9wZXJ0aWVzLicpXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdmaWx0ZXInICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbk9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnXCJmZWF0dXJlLXN0YXRlXCIgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGZpbHRlcnMuJyldO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5leHByZXNzaW9uQ29udGV4dCAmJiBvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0LmluZGV4T2YoJ2NsdXN0ZXInKSA9PT0gMCkge1xuICAgICAgICBpZiAoIWlzR2xvYmFsUHJvcGVydHlDb25zdGFudChleHByZXNzaW9uT2JqLCBbXG4gICAgICAgICAgICAgICAgJ3pvb20nLFxuICAgICAgICAgICAgICAgICdmZWF0dXJlLXN0YXRlJ1xuICAgICAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ1wiem9vbVwiIGFuZCBcImZlYXR1cmUtc3RhdGVcIiBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGNsdXN0ZXIgcHJvcGVydGllcy4nKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdjbHVzdGVyLWluaXRpYWwnICYmICFpc0ZlYXR1cmVDb25zdGFudChleHByZXNzaW9uT2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnRmVhdHVyZSBkYXRhIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggaW5pdGlhbCBleHByZXNzaW9uIHBhcnQgb2YgY2x1c3RlciBwcm9wZXJ0aWVzLicpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQm9vbGVhbihvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcbiAgICBpZiAodHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYm9vbGVhbiBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJyldO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29sb3Iob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29sb3IgZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgaWYgKGNzc2NvbG9ycGFyc2VyXzEodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29sb3IgZXhwZWN0ZWQsIFwiJyArIHZhbHVlICsgJ1wiIGZvdW5kJyldO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRW51bShvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVNwZWMudmFsdWVzKSkge1xuICAgICAgICBpZiAodmFsdWVTcGVjLnZhbHVlcy5pbmRleE9mKHVuYnVuZGxlKHZhbHVlKSkgPT09IC0xKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdleHBlY3RlZCBvbmUgb2YgWycgKyB2YWx1ZVNwZWMudmFsdWVzLmpvaW4oJywgJykgKyAnXSwgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcgZm91bmQnKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWVTcGVjLnZhbHVlcykuaW5kZXhPZih1bmJ1bmRsZSh2YWx1ZSkpID09PSAtMSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZXhwZWN0ZWQgb25lIG9mIFsnICsgT2JqZWN0LmtleXModmFsdWVTcGVjLnZhbHVlcykuam9pbignLCAnKSArICddLCAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJyBmb3VuZCcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZpbHRlcihvcHRpb25zKSB7XG4gICAgaWYgKGlzRXhwcmVzc2lvbkZpbHRlcihkZWVwVW5idW5kbGUob3B0aW9ucy52YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24oZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ2ZpbHRlcicsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHsgdmFsdWU6ICdib29sZWFuJyB9XG4gICAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVOb25FeHByZXNzaW9uRmlsdGVyKG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlcihvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYXJyYXkgZXhwZWN0ZWQsICcgKyBnZXRUeXBlKHZhbHVlKSArICcgZm91bmQnKV07XG4gICAgfVxuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgdHlwZTtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudCcpXTtcbiAgICB9XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUVudW0oe1xuICAgICAgICBrZXk6IGtleSArICdbMF0nLFxuICAgICAgICB2YWx1ZTogdmFsdWVbMF0sXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmZpbHRlcl9vcGVyYXRvcixcbiAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICB9KSk7XG4gICAgc3dpdGNoICh1bmJ1bmRsZSh2YWx1ZVswXSkpIHtcbiAgICBjYXNlICc8JzpcbiAgICBjYXNlICc8PSc6XG4gICAgY2FzZSAnPic6XG4gICAgY2FzZSAnPj0nOlxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIgJiYgdW5idW5kbGUodmFsdWVbMV0pID09PSAnJHR5cGUnKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcIiR0eXBlXCIgY2Fubm90IGJlIHVzZSB3aXRoIG9wZXJhdG9yIFwiJyArIHZhbHVlWzBdICsgJ1wiJykpO1xuICAgICAgICB9XG4gICAgY2FzZSAnPT0nOlxuICAgIGNhc2UgJyE9JzpcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZmlsdGVyIGFycmF5IGZvciBvcGVyYXRvciBcIicgKyB2YWx1ZVswXSArICdcIiBtdXN0IGhhdmUgMyBlbGVtZW50cycpKTtcbiAgICAgICAgfVxuICAgIGNhc2UgJ2luJzpcbiAgICBjYXNlICchaW4nOlxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJ1sxXScsIHZhbHVlWzFdLCAnc3RyaW5nIGV4cGVjdGVkLCAnICsgdHlwZSArICcgZm91bmQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbaV0pO1xuICAgICAgICAgICAgaWYgKHVuYnVuZGxlKHZhbHVlWzFdKSA9PT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbnVtKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnWycgKyBpICsgJ10nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmdlb21ldHJ5X3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbJyArIGkgKyAnXScsIHZhbHVlW2ldLCAnc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW4gZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlICdhbnknOlxuICAgIGNhc2UgJ2FsbCc6XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IHZhbHVlLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVOb25FeHByZXNzaW9uRmlsdGVyKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSArICdbJyArIGkkMSArICddJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaSQxXSxcbiAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaGFzJzpcbiAgICBjYXNlICchaGFzJzpcbiAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgZm9yIFwiJyArIHZhbHVlWzBdICsgJ1wiIG9wZXJhdG9yIG11c3QgaGF2ZSAyIGVsZW1lbnRzJykpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbMV0nLCB2YWx1ZVsxXSwgJ3N0cmluZyBleHBlY3RlZCwgJyArIHR5cGUgKyAnIGZvdW5kJykpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KG9wdGlvbnMsIHByb3BlcnR5VHlwZSkge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBwcm9wZXJ0eUtleSA9IG9wdGlvbnMub2JqZWN0S2V5O1xuICAgIHZhciBsYXllclNwZWMgPSBzdHlsZVNwZWNbcHJvcGVydHlUeXBlICsgJ18nICsgb3B0aW9ucy5sYXllclR5cGVdO1xuICAgIGlmICghbGF5ZXJTcGVjKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHRyYW5zaXRpb25NYXRjaCA9IHByb3BlcnR5S2V5Lm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuICAgIGlmIChwcm9wZXJ0eVR5cGUgPT09ICdwYWludCcgJiYgdHJhbnNpdGlvbk1hdGNoICYmIGxheWVyU3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dICYmIGxheWVyU3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dLnRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMudHJhbnNpdGlvbixcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWMgfHwgbGF5ZXJTcGVjW3Byb3BlcnR5S2V5XTtcbiAgICBpZiAoIXZhbHVlU3BlYykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ3Vua25vd24gcHJvcGVydHkgXCInICsgcHJvcGVydHlLZXkgKyAnXCInKV07XG4gICAgfVxuICAgIHZhciB0b2tlbk1hdGNoO1xuICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ3N0cmluZycgJiYgc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24odmFsdWVTcGVjKSAmJiAhdmFsdWVTcGVjLnRva2VucyAmJiAodG9rZW5NYXRjaCA9IC9eeyhbXn1dKyl9JC8uZXhlYyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCInICsgcHJvcGVydHlLZXkgKyAnXCIgZG9lcyBub3Qgc3VwcG9ydCBpbnRlcnBvbGF0aW9uIHN5bnRheFxcbicgKyAnVXNlIGFuIGlkZW50aXR5IHByb3BlcnR5IGZ1bmN0aW9uIGluc3RlYWQ6IGB7IFwidHlwZVwiOiBcImlkZW50aXR5XCIsIFwicHJvcGVydHlcIjogJyArIEpTT04uc3RyaW5naWZ5KHRva2VuTWF0Y2hbMV0pICsgJyB9YC4nKV07XG4gICAgfVxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZiAob3B0aW9ucy5sYXllclR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eUtleSA9PT0gJ3RleHQtZmllbGQnICYmIHN0eWxlICYmICFzdHlsZS5nbHlwaHMpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ3VzZSBvZiBcInRleHQtZmllbGRcIiByZXF1aXJlcyBhIHN0eWxlIFwiZ2x5cGhzXCIgcHJvcGVydHknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5S2V5ID09PSAndGV4dC1mb250JyAmJiBpc0Z1bmN0aW9uJDEoZGVlcFVuYnVuZGxlKHZhbHVlKSkgJiYgdW5idW5kbGUodmFsdWUudHlwZSkgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1widGV4dC1mb250XCIgZG9lcyBub3Qgc3VwcG9ydCBpZGVudGl0eSBmdW5jdGlvbnMnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogdmFsdWVTcGVjLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ3Byb3BlcnR5JyxcbiAgICAgICAgcHJvcGVydHlUeXBlOiBwcm9wZXJ0eVR5cGUsXG4gICAgICAgIHByb3BlcnR5S2V5OiBwcm9wZXJ0eUtleVxuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQYWludFByb3BlcnR5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVQcm9wZXJ0eShvcHRpb25zLCAncGFpbnQnKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVMYXlvdXRQcm9wZXJ0eShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlUHJvcGVydHkob3B0aW9ucywgJ2xheW91dCcpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUxheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIGxheWVyID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgaWYgKCFsYXllci50eXBlICYmICFsYXllci5yZWYpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnZWl0aGVyIFwidHlwZVwiIG9yIFwicmVmXCIgaXMgcmVxdWlyZWQnKSk7XG4gICAgfVxuICAgIHZhciB0eXBlID0gdW5idW5kbGUobGF5ZXIudHlwZSk7XG4gICAgdmFyIHJlZiA9IHVuYnVuZGxlKGxheWVyLnJlZik7XG4gICAgaWYgKGxheWVyLmlkKSB7XG4gICAgICAgIHZhciBsYXllcklkID0gdW5idW5kbGUobGF5ZXIuaWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMuYXJyYXlJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJMYXllciA9IHN0eWxlLmxheWVyc1tpXTtcbiAgICAgICAgICAgIGlmICh1bmJ1bmRsZShvdGhlckxheWVyLmlkKSA9PT0gbGF5ZXJJZCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5pZCwgJ2R1cGxpY2F0ZSBsYXllciBpZCBcIicgKyBsYXllci5pZCArICdcIiwgcHJldmlvdXNseSB1c2VkIGF0IGxpbmUgJyArIG90aGVyTGF5ZXIuaWQuX19saW5lX18pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3JlZicgaW4gbGF5ZXIpIHtcbiAgICAgICAgW1xuICAgICAgICAgICAgJ3R5cGUnLFxuICAgICAgICAgICAgJ3NvdXJjZScsXG4gICAgICAgICAgICAnc291cmNlLWxheWVyJyxcbiAgICAgICAgICAgICdmaWx0ZXInLFxuICAgICAgICAgICAgJ2xheW91dCdcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBpZiAocCBpbiBsYXllcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllcltwXSwgJ1wiJyArIHAgKyAnXCIgaXMgcHJvaGliaXRlZCBmb3IgcmVmIGxheWVycycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYXJlbnQ7XG4gICAgICAgIHN0eWxlLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgaWYgKHVuYnVuZGxlKGxheWVyLmlkKSA9PT0gcmVmKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbGF5ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnJlZiwgJ3JlZiBsYXllciBcIicgKyByZWYgKyAnXCIgbm90IGZvdW5kJykpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC5yZWYpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5yZWYsICdyZWYgY2Fubm90IHJlZmVyZW5jZSBhbm90aGVyIHJlZiBsYXllcicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSB1bmJ1bmRsZShwYXJlbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICBpZiAoIWxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInNvdXJjZVwiJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHN0eWxlLnNvdXJjZXMgJiYgc3R5bGUuc291cmNlc1tsYXllci5zb3VyY2VdO1xuICAgICAgICAgICAgdmFyIHNvdXJjZVR5cGUgPSBzb3VyY2UgJiYgdW5idW5kbGUoc291cmNlLnR5cGUpO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCAnc291cmNlIFwiJyArIGxheWVyLnNvdXJjZSArICdcIiBub3QgZm91bmQnKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09ICd2ZWN0b3InICYmIHR5cGUgPT09ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ2xheWVyIFwiJyArIGxheWVyLmlkICsgJ1wiIHJlcXVpcmVzIGEgcmFzdGVyIHNvdXJjZScpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3Jhc3RlcicgJiYgdHlwZSAhPT0gJ3Jhc3RlcicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCAnbGF5ZXIgXCInICsgbGF5ZXIuaWQgKyAnXCIgcmVxdWlyZXMgYSB2ZWN0b3Igc291cmNlJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlID09PSAndmVjdG9yJyAmJiAhbGF5ZXJbJ3NvdXJjZS1sYXllciddKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnbGF5ZXIgXCInICsgbGF5ZXIuaWQgKyAnXCIgbXVzdCBzcGVjaWZ5IGEgXCJzb3VyY2UtbGF5ZXJcIicpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3Jhc3Rlci1kZW0nICYmIHR5cGUgIT09ICdoaWxsc2hhZGUnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ3Jhc3Rlci1kZW0gc291cmNlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBsYXllciB0eXBlIFxcJ2hpbGxzaGFkZVxcJy4nKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsaW5lJyAmJiBsYXllci5wYWludCAmJiBsYXllci5wYWludFsnbGluZS1ncmFkaWVudCddICYmIChzb3VyY2VUeXBlICE9PSAnZ2VvanNvbicgfHwgIXNvdXJjZS5saW5lTWV0cmljcykpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIsICdsYXllciBcIicgKyBsYXllci5pZCArICdcIiBzcGVjaWZpZXMgYSBsaW5lLWdyYWRpZW50LCB3aGljaCByZXF1aXJlcyBhIEdlb0pTT04gc291cmNlIHdpdGggYGxpbmVNZXRyaWNzYCBlbmFibGVkLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBsYXllcixcbiAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMubGF5ZXIsXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgJyonOiBmdW5jdGlvbiBfKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiB0eXBlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJy50eXBlJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxheWVyLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmxheWVyLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGxheWVyLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RLZXk6ICd0eXBlJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlcjogdmFsaWRhdGVGaWx0ZXIsXG4gICAgICAgICAgICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnKic6IGZ1bmN0aW9uIF8ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUxheW91dFByb3BlcnR5KGV4dGVuZCh7IGxheWVyVHlwZTogdHlwZSB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYWludDogZnVuY3Rpb24gcGFpbnQob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllcixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyonOiBmdW5jdGlvbiBfKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVQYWludFByb3BlcnR5KGV4dGVuZCh7IGxheWVyVHlwZTogdHlwZSB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdzdHJpbmcgZXhwZWN0ZWQsICcgKyB0eXBlICsgJyBmb3VuZCcpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG52YXIgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnMgPSB7IHByb21vdGVJZDogdmFsaWRhdGVQcm9tb3RlSWQgfTtcbmZ1bmN0aW9uIHZhbGlkYXRlU291cmNlKG9wdGlvbnMpIHtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICBpZiAoIXZhbHVlLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcInR5cGVcIiBpcyByZXF1aXJlZCcpXTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB1bmJ1bmRsZSh2YWx1ZS50eXBlKTtcbiAgICB2YXIgZXJyb3JzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3ZlY3Rvcic6XG4gICAgY2FzZSAncmFzdGVyJzpcbiAgICBjYXNlICdyYXN0ZXItZGVtJzpcbiAgICAgICAgZXJyb3JzID0gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlY1snc291cmNlXycgKyB0eXBlLnJlcGxhY2UoJy0nLCAnXycpXSxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczogb2JqZWN0RWxlbWVudFZhbGlkYXRvcnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgY2FzZSAnZ2VvanNvbic6XG4gICAgICAgIGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX2dlb2pzb24sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiBvYmplY3RFbGVtZW50VmFsaWRhdG9yc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbHVlLmNsdXN0ZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdmFsdWUuY2x1c3RlclByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gdmFsdWUuY2x1c3RlclByb3BlcnRpZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gcmVmWzBdO1xuICAgICAgICAgICAgICAgIHZhciBtYXBFeHByID0gcmVmWzFdO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VFeHByID0gdHlwZW9mIG9wZXJhdG9yID09PSAnc3RyaW5nJyA/IFtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgIFsnYWNjdW11bGF0ZWQnXSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICBdIDogb3BlcmF0b3I7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCB2YWxpZGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSArICcuJyArIHByb3AgKyAnLm1hcCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXBFeHByLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ2NsdXN0ZXItbWFwJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIHZhbGlkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJy4nICsgcHJvcCArICcucmVkdWNlJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlZHVjZUV4cHIsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Db250ZXh0OiAnY2x1c3Rlci1yZWR1Y2UnXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfdmlkZW8sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnNvdXJjZV9pbWFnZSxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgIH0pO1xuICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG51bGwsICdQbGVhc2UgdXNlIHJ1bnRpbWUgQVBJcyB0byBhZGQgY2FudmFzIHNvdXJjZXMsIHJhdGhlciB0aGFuIGluY2x1ZGluZyB0aGVtIGluIHN0eWxlc2hlZXRzLicsICdzb3VyY2UuY2FudmFzJyldO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUVudW0oe1xuICAgICAgICAgICAga2V5OiBrZXkgKyAnLnR5cGUnLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnR5cGUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ3ZlY3RvcicsXG4gICAgICAgICAgICAgICAgICAgICdyYXN0ZXInLFxuICAgICAgICAgICAgICAgICAgICAncmFzdGVyLWRlbScsXG4gICAgICAgICAgICAgICAgICAgICdnZW9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZGVvJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ltYWdlJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb21vdGVJZChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgaWYgKGdldFR5cGUodmFsdWUpID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVTdHJpbmcoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIHZhbGlkYXRlU3RyaW5nKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSArICcuJyArIHByb3AsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW3Byb3BdXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGlnaHQob3B0aW9ucykge1xuICAgIHZhciBsaWdodCA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciBsaWdodFNwZWMgPSBzdHlsZVNwZWMubGlnaHQ7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHJvb3RUeXBlID0gZ2V0VHlwZShsaWdodCk7XG4gICAgaWYgKGxpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9IGVsc2UgaWYgKHJvb3RUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKCdsaWdodCcsIGxpZ2h0LCAnb2JqZWN0IGV4cGVjdGVkLCAnICsgcm9vdFR5cGUgKyAnIGZvdW5kJyldKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIGxpZ2h0KSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uTWF0Y2ggPSBrZXkubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uTWF0Y2ggJiYgbGlnaHRTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0gJiYgbGlnaHRTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0udHJhbnNpdGlvbikge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpZ2h0W2tleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMudHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaWdodFNwZWNba2V5XSkge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpZ2h0W2tleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBsaWdodFNwZWNba2V5XSxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsaWdodFtrZXldLCAndW5rbm93biBwcm9wZXJ0eSBcIicgKyBrZXkgKyAnXCInKV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0dGVkKG9wdGlvbnMpIHtcbiAgICBpZiAodmFsaWRhdGVTdHJpbmcob3B0aW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbihvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVJbWFnZShvcHRpb25zKSB7XG4gICAgaWYgKHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24ob3B0aW9ucyk7XG59XG5cbnZhciBWQUxJREFUT1JTID0ge1xuICAgICcqJzogZnVuY3Rpb24gXygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgJ2FycmF5JzogdmFsaWRhdGVBcnJheSxcbiAgICAnYm9vbGVhbic6IHZhbGlkYXRlQm9vbGVhbixcbiAgICAnbnVtYmVyJzogdmFsaWRhdGVOdW1iZXIsXG4gICAgJ2NvbG9yJzogdmFsaWRhdGVDb2xvcixcbiAgICAnY29uc3RhbnRzJzogdmFsaWRhdGVDb25zdGFudHMsXG4gICAgJ2VudW0nOiB2YWxpZGF0ZUVudW0sXG4gICAgJ2ZpbHRlcic6IHZhbGlkYXRlRmlsdGVyLFxuICAgICdmdW5jdGlvbic6IHZhbGlkYXRlRnVuY3Rpb24sXG4gICAgJ2xheWVyJzogdmFsaWRhdGVMYXllcixcbiAgICAnb2JqZWN0JzogdmFsaWRhdGVPYmplY3QsXG4gICAgJ3NvdXJjZSc6IHZhbGlkYXRlU291cmNlLFxuICAgICdsaWdodCc6IHZhbGlkYXRlTGlnaHQsXG4gICAgJ3N0cmluZyc6IHZhbGlkYXRlU3RyaW5nLFxuICAgICdmb3JtYXR0ZWQnOiB2YWxpZGF0ZUZvcm1hdHRlZCxcbiAgICAncmVzb2x2ZWRJbWFnZSc6IHZhbGlkYXRlSW1hZ2Vcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGlmICh2YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiBpc0Z1bmN0aW9uJDEodW5idW5kbGUodmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVGdW5jdGlvbihvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlU3BlYy5leHByZXNzaW9uICYmIGlzRXhwcmVzc2lvbihkZWVwVW5idW5kbGUodmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVFeHByZXNzaW9uKG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodmFsdWVTcGVjLnR5cGUgJiYgVkFMSURBVE9SU1t2YWx1ZVNwZWMudHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWxpZCA9IHZhbGlkYXRlT2JqZWN0KGV4dGVuZCh7fSwgb3B0aW9ucywgeyB2YWx1ZVNwZWM6IHZhbHVlU3BlYy50eXBlID8gc3R5bGVTcGVjW3ZhbHVlU3BlYy50eXBlXSA6IHZhbHVlU3BlYyB9KSk7XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlR2x5cGhzVVJMIChvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIGVycm9ycyA9IHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCd7Zm9udHN0YWNrfScpID09PSAtMSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcImdseXBoc1wiIHVybCBtdXN0IGluY2x1ZGUgYSBcIntmb250c3RhY2t9XCIgdG9rZW4nKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCd7cmFuZ2V9JykgPT09IC0xKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1wiZ2x5cGhzXCIgdXJsIG11c3QgaW5jbHVkZSBhIFwie3JhbmdlfVwiIHRva2VuJykpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlTWluKHN0eWxlLCBzdHlsZVNwZWMpIHtcbiAgICBpZiAoc3R5bGVTcGVjID09PSB2b2lkIDApXG4gICAgICAgIHN0eWxlU3BlYyA9IHY4O1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAga2V5OiAnJyxcbiAgICAgICAgdmFsdWU6IHN0eWxlLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy4kcm9vdCxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgIGdseXBoczogdmFsaWRhdGVHbHlwaHNVUkwsXG4gICAgICAgICAgICAnKic6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpO1xuICAgIGlmIChzdHlsZS5jb25zdGFudHMpIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUNvbnN0YW50cyh7XG4gICAgICAgICAgICBrZXk6ICdjb25zdGFudHMnLFxuICAgICAgICAgICAgdmFsdWU6IHN0eWxlLmNvbnN0YW50cyxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvcnRFcnJvcnMoZXJyb3JzKTtcbn1cbnZhbGlkYXRlU3R5bGVNaW4uc291cmNlID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlU291cmNlKTtcbnZhbGlkYXRlU3R5bGVNaW4ubGlnaHQgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVMaWdodCk7XG52YWxpZGF0ZVN0eWxlTWluLmxheWVyID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGF5ZXIpO1xudmFsaWRhdGVTdHlsZU1pbi5maWx0ZXIgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVGaWx0ZXIpO1xudmFsaWRhdGVTdHlsZU1pbi5wYWludFByb3BlcnR5ID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlUGFpbnRQcm9wZXJ0eSk7XG52YWxpZGF0ZVN0eWxlTWluLmxheW91dFByb3BlcnR5ID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGF5b3V0UHJvcGVydHkpO1xuZnVuY3Rpb24gc29ydEVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KGVycm9ycykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5saW5lIC0gYi5saW5lO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gd3JhcENsZWFuRXJyb3JzKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxlbi0tKVxuICAgICAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICAgIHJldHVybiBzb3J0RXJyb3JzKGlubmVyLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICB9O1xufVxuXG52YXIganNvbmxpbnQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uIDAuNC4xNSAqL1xuLypcbiAgUmV0dXJucyBhIFBhcnNlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5cbiAgUGFyc2VyOiB7XG4gICAgeXk6IHt9XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlOiB7XG4gICAgeXk6IHt9LFxuICAgIHRyYWNlOiBmdW5jdGlvbigpLFxuICAgIHN5bWJvbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gbnVtYmVyfSxcbiAgICB0ZXJtaW5hbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbnVtYmVyID09PiBuYW1lfSxcbiAgICBwcm9kdWN0aW9uc186IFsuLi5dLFxuICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlLCAkJCwgXyQpLFxuICAgIHRhYmxlOiBbLi4uXSxcbiAgICBkZWZhdWx0QWN0aW9uczogey4uLn0sXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQpLFxuXG4gICAgbGV4ZXI6IHtcbiAgICAgICAgRU9GOiAxLFxuICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24oaW5wdXQpLFxuICAgICAgICBpbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgdW5wdXQ6IGZ1bmN0aW9uKHN0ciksXG4gICAgICAgIG1vcmU6IGZ1bmN0aW9uKCksXG4gICAgICAgIGxlc3M6IGZ1bmN0aW9uKG4pLFxuICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAgICAgICAgdGVzdF9tYXRjaDogZnVuY3Rpb24ocmVnZXhfbWF0Y2hfYXJyYXksIHJ1bGVfaW5kZXgpLFxuICAgICAgICBuZXh0OiBmdW5jdGlvbigpLFxuICAgICAgICBsZXg6IGZ1bmN0aW9uKCksXG4gICAgICAgIGJlZ2luOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICAgICAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAgICAgICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24oKSxcbiAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24oY29uZGl0aW9uKSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICByYW5nZXM6IGJvb2xlYW4gICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIpXG4gICAgICAgICAgICBmbGV4OiBib29sZWFuICAgICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gZmxleC1saWtlIGxleGluZyBiZWhhdmlvdXIgd2hlcmUgdGhlIHJ1bGVzIGFyZSB0ZXN0ZWQgZXhoYXVzdGl2ZWx5IHRvIGZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gpXG4gICAgICAgICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW4gIChvcHRpb25hbDogdHJ1ZSA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgZWFjaCBtYXRjaGluZyByZWdleCB0aGUgYWN0aW9uIGNvZGUgaXMgaW52b2tlZDsgdGhlIGxleGVyIHRlcm1pbmF0ZXMgdGhlIHNjYW4gd2hlbiBhIHRva2VuIGlzIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24gY29kZSlcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbih5eSwgeXlfLCAkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLCBZWV9TVEFSVCksXG4gICAgICAgIHJ1bGVzOiBbLi4uXSxcbiAgICAgICAgY29uZGl0aW9uczoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IHNldH0sXG4gICAgfVxuICB9XG5cblxuICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7XG4gICAgZmlyc3RfbGluZTogbixcbiAgICBsYXN0X2xpbmU6IG4sXG4gICAgZmlyc3RfY29sdW1uOiBuLFxuICAgIGxhc3RfY29sdW1uOiBuLFxuICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXSAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCByZWd1bGFyIHplcm8tYmFzZWQpXG4gIH1cblxuXG4gIHRoZSBwYXJzZUVycm9yIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGFuZCBwYXJzZXIgZXJyb3JzOiB7XG4gICAgdGV4dDogICAgICAgIChtYXRjaGVkIHRleHQpXG4gICAgdG9rZW46ICAgICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4sIGlmIGFueSlcbiAgICBsaW5lOiAgICAgICAgKHl5bGluZW5vKVxuICB9XG4gIHdoaWxlIHBhcnNlciAoZ3JhbW1hcikgZXJyb3JzIHdpbGwgYWxzbyBwcm92aWRlIHRoZXNlIG1lbWJlcnMsIGkuZS4gcGFyc2VyIGVycm9ycyBkZWxpdmVyIGEgc3VwZXJzZXQgb2YgYXR0cmlidXRlczoge1xuICAgIGxvYzogICAgICAgICAoeXlsbG9jKVxuICAgIGV4cGVjdGVkOiAgICAoc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHNldCBvZiBleHBlY3RlZCB0b2tlbnMpXG4gICAgcmVjb3ZlcmFibGU6IChib29sZWFuOiBUUlVFIHdoZW4gdGhlIHBhcnNlciBoYXMgYSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVycm9yKVxuICB9XG4qL1xudmFyIHBhcnNlciA9IChmdW5jdGlvbigpe1xudmFyIG89ZnVuY3Rpb24oayx2LG8sbCl7Zm9yKG89b3x8e30sbD1rLmxlbmd0aDtsLS07b1trW2xdXT12KXsgfXJldHVybiBvfSwkVjA9WzEsMTJdLCRWMT1bMSwxM10sJFYyPVsxLDldLCRWMz1bMSwxMF0sJFY0PVsxLDExXSwkVjU9WzEsMTRdLCRWNj1bMSwxNV0sJFY3PVsxNCwxOCwyMiwyNF0sJFY4PVsxOCwyMl0sJFY5PVsyMiwyNF07XG52YXIgcGFyc2VyID0ge3RyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCJlcnJvclwiOjIsXCJKU09OU3RyaW5nXCI6MyxcIlNUUklOR1wiOjQsXCJKU09OTnVtYmVyXCI6NSxcIk5VTUJFUlwiOjYsXCJKU09OTnVsbExpdGVyYWxcIjo3LFwiTlVMTFwiOjgsXCJKU09OQm9vbGVhbkxpdGVyYWxcIjo5LFwiVFJVRVwiOjEwLFwiRkFMU0VcIjoxMSxcIkpTT05UZXh0XCI6MTIsXCJKU09OVmFsdWVcIjoxMyxcIkVPRlwiOjE0LFwiSlNPTk9iamVjdFwiOjE1LFwiSlNPTkFycmF5XCI6MTYsXCJ7XCI6MTcsXCJ9XCI6MTgsXCJKU09OTWVtYmVyTGlzdFwiOjE5LFwiSlNPTk1lbWJlclwiOjIwLFwiOlwiOjIxLFwiLFwiOjIyLFwiW1wiOjIzLFwiXVwiOjI0LFwiSlNPTkVsZW1lbnRMaXN0XCI6MjUsXCIkYWNjZXB0XCI6MCxcIiRlbmRcIjoxfSxcbnRlcm1pbmFsc186IHsyOlwiZXJyb3JcIiw0OlwiU1RSSU5HXCIsNjpcIk5VTUJFUlwiLDg6XCJOVUxMXCIsMTA6XCJUUlVFXCIsMTE6XCJGQUxTRVwiLDE0OlwiRU9GXCIsMTc6XCJ7XCIsMTg6XCJ9XCIsMjE6XCI6XCIsMjI6XCIsXCIsMjM6XCJbXCIsMjQ6XCJdXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywxXSxbNSwxXSxbNywxXSxbOSwxXSxbOSwxXSxbMTIsMl0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzE1LDJdLFsxNSwzXSxbMjAsM10sWzE5LDFdLFsxOSwzXSxbMTYsMl0sWzE2LDNdLFsyNSwxXSxbMjUsM11dLFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUgLyogYWN0aW9uWzFdICovLCAkJCAvKiB2c3RhY2sgKi8sIF8kIC8qIGxzdGFjayAqLykge1xuLyogdGhpcyA9PSB5eXZhbCAqL1xuXG52YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xuc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDE6XG4gLy8gcmVwbGFjZSBlc2NhcGVkIGNoYXJhY3RlcnMgd2l0aCBhY3R1YWwgY2hhcmFjdGVyXG4gICAgICAgICAgdGhpcy4kID0gbmV3IFN0cmluZyh5eXRleHQucmVwbGFjZSgvXFxcXChcXFxcfFwiKS9nLCBcIiRcIitcIjFcIilcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcbi9nLCdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxyL2csJ1xccicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHQvZywnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdi9nLCdcXHYnKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxmL2csJ1xcZicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXGIvZywnXFxiJykpO1xuICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9ICB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDI6XG5cbiAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBOdW1iZXIoeXl0ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9ICB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDM6XG5cbiAgICAgICAgICAgIHRoaXMuJCA9IG51bGw7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDQ6XG5cbiAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBCb29sZWFuKHRydWUpO1xuICAgICAgICAgICAgdGhpcy4kLl9fbGluZV9fID0gdGhpcy5fJC5maXJzdF9saW5lO1xuICAgICAgICBcbmJyZWFrO1xuY2FzZSA1OlxuXG4gICAgICAgICAgICB0aGlzLiQgPSBuZXcgQm9vbGVhbihmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDY6XG5yZXR1cm4gdGhpcy4kID0gJCRbJDAtMV07XG5jYXNlIDEzOlxudGhpcy4kID0ge307IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLiQsICdfX2xpbmVfXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl8kLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbmJyZWFrO1xuY2FzZSAxNDogY2FzZSAxOTpcbnRoaXMuJCA9ICQkWyQwLTFdOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG5icmVhaztcbmNhc2UgMTU6XG50aGlzLiQgPSBbJCRbJDAtMl0sICQkWyQwXV07XG5icmVhaztcbmNhc2UgMTY6XG50aGlzLiQgPSB7fTsgdGhpcy4kWyQkWyQwXVswXV0gPSAkJFskMF1bMV07XG5icmVhaztcbmNhc2UgMTc6XG50aGlzLiQgPSAkJFskMC0yXTsgJCRbJDAtMl1bJCRbJDBdWzBdXSA9ICQkWyQwXVsxXTtcbmJyZWFrO1xuY2FzZSAxODpcbnRoaXMuJCA9IFtdOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG5icmVhaztcbmNhc2UgMjA6XG50aGlzLiQgPSBbJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAyMTpcbnRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbn1cbn0sXG50YWJsZTogW3szOjUsNDokVjAsNTo2LDY6JFYxLDc6Myw4OiRWMiw5OjQsMTA6JFYzLDExOiRWNCwxMjoxLDEzOjIsMTU6NywxNjo4LDE3OiRWNSwyMzokVjZ9LHsxOlszXX0sezE0OlsxLDE2XX0sbygkVjcsWzIsN10pLG8oJFY3LFsyLDhdKSxvKCRWNyxbMiw5XSksbygkVjcsWzIsMTBdKSxvKCRWNyxbMiwxMV0pLG8oJFY3LFsyLDEyXSksbygkVjcsWzIsM10pLG8oJFY3LFsyLDRdKSxvKCRWNyxbMiw1XSksbyhbMTQsMTgsMjEsMjIsMjRdLFsyLDFdKSxvKCRWNyxbMiwyXSksezM6MjAsNDokVjAsMTg6WzEsMTddLDE5OjE4LDIwOjE5fSx7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTM6MjMsMTU6NywxNjo4LDE3OiRWNSwyMzokVjYsMjQ6WzEsMjFdLDI1OjIyfSx7MTpbMiw2XX0sbygkVjcsWzIsMTNdKSx7MTg6WzEsMjRdLDIyOlsxLDI1XX0sbygkVjgsWzIsMTZdKSx7MjE6WzEsMjZdfSxvKCRWNyxbMiwxOF0pLHsyMjpbMSwyOF0sMjQ6WzEsMjddfSxvKCRWOSxbMiwyMF0pLG8oJFY3LFsyLDE0XSksezM6MjAsNDokVjAsMjA6Mjl9LHszOjUsNDokVjAsNTo2LDY6JFYxLDc6Myw4OiRWMiw5OjQsMTA6JFYzLDExOiRWNCwxMzozMCwxNTo3LDE2OjgsMTc6JFY1LDIzOiRWNn0sbygkVjcsWzIsMTldKSx7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTM6MzEsMTU6NywxNjo4LDE3OiRWNSwyMzokVjZ9LG8oJFY4LFsyLDE3XSksbygkVjgsWzIsMTVdKSxvKCRWOSxbMiwyMV0pXSxcbmRlZmF1bHRBY3Rpb25zOiB7MTY6WzIsNl19LFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSkge1xuICAgICAgICB0aGlzLnRyYWNlKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgfVxufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcywgc3RhY2sgPSBbMF0sIHZzdGFjayA9IFtudWxsXSwgbHN0YWNrID0gW10sIHRhYmxlID0gdGhpcy50YWJsZSwgeXl0ZXh0ID0gJycsIHl5bGluZW5vID0gMCwgeXlsZW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTtcbiAgICB2YXIgYXJncyA9IGxzdGFjay5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGxleGVyID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICB2YXIgc2hhcmVkU3RhdGUgPSB7IHl5OiB7fSB9O1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICBzaGFyZWRTdGF0ZS55eS5sZXhlciA9IGxleGVyO1xuICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV4ZXIueXlsbG9jID0ge307XG4gICAgfVxuICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG4gICAgdmFyIHJhbmdlcyA9IGxleGVyLm9wdGlvbnMgJiYgbGV4ZXIub3B0aW9ucy5yYW5nZXM7XG4gICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7XG4gICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgICB0b2tlbiA9IGxleGVyLmxleCgpIHx8IEVPRjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgIHZhciBzeW1ib2wsIHN0YXRlLCBhY3Rpb24sIHIsIHl5dmFsID0ge30sIHAsIGxlbiwgbmV3U3RhdGUsIGV4cGVjdGVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xuICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXTtcbiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSAnJztcbiAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gVEVSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKCdcXCcnICsgdGhpcy50ZXJtaW5hbHNfW3BdICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzpcXG4nICsgbGV4ZXIuc2hvd1Bvc2l0aW9uKCkgKyAnXFxuRXhwZWN0aW5nICcgKyBleHBlY3RlZC5qb2luKCcsICcpICsgJywgZ290IFxcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcXCcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6IFVuZXhwZWN0ZWQgJyArIChzeW1ib2wgPT0gRU9GID8gJ2VuZCBvZiBpbnB1dCcgOiAnXFwnJyArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBsZXhlci55eWxpbmVubyxcbiAgICAgICAgICAgICAgICAgICAgbG9jOiB5eWxvYyxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJyArIHN0YXRlICsgJywgdG9rZW46ICcgKyBzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaChsZXhlci55eWxsb2MpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pO1xuICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB5eWxlbmcgPSBsZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIHl5bGluZW5vID0gbGV4ZXIueXlsaW5lbm87XG4gICAgICAgICAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcbiAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aCAtIGxlbl07XG4gICAgICAgICAgICB5eXZhbC5fJCA9IHtcbiAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgbGFzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHl5dmFsLl8kLnJhbmdlID0gW1xuICAgICAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLFxuICAgICAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLnJhbmdlWzFdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uYXBwbHkoeXl2YWwsIFtcbiAgICAgICAgICAgICAgICB5eXRleHQsXG4gICAgICAgICAgICAgICAgeXlsZW5nLFxuICAgICAgICAgICAgICAgIHl5bGluZW5vLFxuICAgICAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5LFxuICAgICAgICAgICAgICAgIGFjdGlvblsxXSxcbiAgICAgICAgICAgICAgICB2c3RhY2ssXG4gICAgICAgICAgICAgICAgbHN0YWNrXG4gICAgICAgICAgICBdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgwLCAtMSAqIGxlbiAqIDIpO1xuICAgICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5dmFsLl8kKTtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1dW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufX07XG4vKiBnZW5lcmF0ZWQgYnkgamlzb24tbGV4IDAuMy40ICovXG52YXIgbGV4ZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBsZXhlciA9ICh7XG5cbkVPRjoxLFxuXG5wYXJzZUVycm9yOmZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgICAgIGlmICh0aGlzLnl5LnBhcnNlcikge1xuICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dFxuc2V0SW5wdXQ6ZnVuY3Rpb24gKGlucHV0LCB5eSkge1xuICAgICAgICB0aGlzLnl5ID0geXkgfHwgdGhpcy55eSB8fCB7fTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2JhY2t0cmFjayA9IHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IDAsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IDEsXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwwXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0XG5pbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG5cbi8vIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhIHN0cmluZykgaW50byB0aGUgaW5wdXRcbnVucHV0OmZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgLy90aGlzLnl5bGVuZyAtPSBsZW47XG4gICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgICAgdmFyIG9sZExpbmVzID0gdGhpcy5tYXRjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gLT0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IHRoaXMueXlsbG9jLnJhbmdlO1xuXG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgKGxpbmVzLmxlbmd0aCA9PT0gb2xkTGluZXMubGVuZ3RoID8gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIDogMClcbiAgICAgICAgICAgICAgICAgKyBvbGRMaW5lc1tvbGRMaW5lcy5sZW5ndGggLSBsaW5lcy5sZW5ndGhdLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgIHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgY2FjaGVzIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kcyBpdCBvbiBuZXh0IGFjdGlvblxubW9yZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgc2lnbmFscyB0aGUgbGV4ZXIgdGhhdCB0aGlzIHJ1bGUgZmFpbHMgdG8gbWF0Y2ggdGhlIGlucHV0LCBzbyB0aGUgbmV4dCBtYXRjaGluZyBydWxlIChyZWdleCkgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxucmVqZWN0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBZb3UgY2FuIG9ubHkgaW52b2tlIHJlamVjdCgpIGluIHRoZSBsZXhlciB3aGVuIHRoZSBsZXhlciBpcyBvZiB0aGUgYmFja3RyYWNraW5nIHBlcnN1YXNpb24gKG9wdGlvbnMuYmFja3RyYWNrX2xleGVyID0gdHJ1ZSkuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbmxlc3M6ZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyBhbHJlYWR5IG1hdGNoZWQgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5wYXN0SW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLic6JycpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG51cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkgKyAobmV4dC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0aGUgbGV4aW5nIGVycm9yIG9jY3VycmVkLCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuc2hvd1Bvc2l0aW9uOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMgKyBcIl5cIjtcbiAgICB9LFxuXG4vLyB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW5cbnRlc3RfbWF0Y2g6ZnVuY3Rpb24gKG1hdGNoLCBpbmRleGVkX3J1bGUpIHtcbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICBiYWNrdXA7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgY29udGV4dFxuICAgICAgICAgICAgYmFja3VwID0ge1xuICAgICAgICAgICAgICAgIHl5bGluZW5vOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgIHl5bGxvYzoge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LFxuICAgICAgICAgICAgICAgIG1hdGNoOiB0aGlzLm1hdGNoLFxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IHRoaXMubWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsXG4gICAgICAgICAgICAgICAgeXlsZW5nOiB0aGlzLnl5bGVuZyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLFxuICAgICAgICAgICAgICAgIF9pbnB1dDogdGhpcy5faW5wdXQsXG4gICAgICAgICAgICAgICAgeXk6IHRoaXMueXksXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgICAgICAgZG9uZTogdGhpcy5kb25lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBiYWNrdXAueXlsbG9jLnJhbmdlID0gdGhpcy55eWxsb2MucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IG1hdGNoWzBdLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggLSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5tYXRjaCgvXFxyP1xcbj8vKVswXS5sZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIGluZGV4ZWRfcnVsZSwgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAvLyByZWNvdmVyIGNvbnRleHRcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYmFja3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGJhY2t1cFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIHRoZSBuZXh0IHJ1bGUgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4vLyByZXR1cm4gbmV4dCBtYXRjaCBpbiBpbnB1dFxubmV4dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICB0ZW1wTWF0Y2gsXG4gICAgICAgICAgICBpbmRleDtcbiAgICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7XG4gICAgICAgICAgICB0aGlzLnl5dGV4dCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wTWF0Y2ggPSB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLnJ1bGVzW3J1bGVzW2ldXSk7XG4gICAgICAgICAgICBpZiAodGVtcE1hdGNoICYmICghbWF0Y2ggfHwgdGVtcE1hdGNoWzBdLmxlbmd0aCA+IG1hdGNoWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRlbXBNYXRjaDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2godGVtcE1hdGNoLCBydWxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIGEgcnVsZSBNSVNtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFVucmVjb2duaXplZCB0ZXh0LlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW5cbmxleDpmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWN0aXZhdGVzIGEgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSAocHVzaGVzIHRoZSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9udG8gdGhlIGNvbmRpdGlvbiBzdGFjaylcbmJlZ2luOmZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgICB9LFxuXG4vLyBwb3AgdGhlIHByZXZpb3VzbHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvZmYgdGhlIGNvbmRpdGlvbiBzdGFja1xucG9wU3RhdGU6ZnVuY3Rpb24gcG9wU3RhdGUoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbMF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBwcm9kdWNlIHRoZSBsZXhlciBydWxlIHNldCB3aGljaCBpcyBhY3RpdmUgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZVxuX2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXV0ucnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW1wiSU5JVElBTFwiXS5ydWxlcztcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGU7IHdoZW4gYW4gaW5kZXggYXJndW1lbnQgaXMgcHJvdmlkZWQgaXQgcHJvZHVjZXMgdGhlIE4tdGggcHJldmlvdXMgY29uZGl0aW9uIHN0YXRlLCBpZiBhdmFpbGFibGVcbnRvcFN0YXRlOmZ1bmN0aW9uIHRvcFN0YXRlKG4pIHtcbiAgICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7XG4gICAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW25dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiSU5JVElBTFwiO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWxpYXMgZm9yIGJlZ2luKGNvbmRpdGlvbilcbnB1c2hTdGF0ZTpmdW5jdGlvbiBwdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICB9LFxuXG4vLyByZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgY3VycmVudGx5IG9uIHRoZSBzdGFja1xuc3RhdGVTdGFja1NpemU6ZnVuY3Rpb24gc3RhdGVTdGFja1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aDtcbiAgICB9LFxub3B0aW9uczoge30sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXkseXlfLCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsWVlfU1RBUlQpIHtcbnN3aXRjaCgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG5jYXNlIDA6Lyogc2tpcCB3aGl0ZXNwYWNlICovXG5icmVhaztcbmNhc2UgMTpyZXR1cm4gNlxuY2FzZSAyOnl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigxLHl5Xy55eWxlbmctMik7IHJldHVybiA0XG5jYXNlIDM6cmV0dXJuIDE3XG5jYXNlIDQ6cmV0dXJuIDE4XG5jYXNlIDU6cmV0dXJuIDIzXG5jYXNlIDY6cmV0dXJuIDI0XG5jYXNlIDc6cmV0dXJuIDIyXG5jYXNlIDg6cmV0dXJuIDIxXG5jYXNlIDk6cmV0dXJuIDEwXG5jYXNlIDEwOnJldHVybiAxMVxuY2FzZSAxMTpyZXR1cm4gOFxuY2FzZSAxMjpyZXR1cm4gMTRcbmNhc2UgMTM6cmV0dXJuICdJTlZBTElEJ1xufVxufSxcbnJ1bGVzOiBbL14oPzpcXHMrKS8sL14oPzooLT8oWzAtOV18WzEtOV1bMC05XSspKShcXC5bMC05XSspPyhbZUVdWy0rXT9bMC05XSspP1xcYikvLC9eKD86XCIoPzpcXFxcW1xcXFxcImJmbnJ0L118XFxcXHVbYS1mQS1GMC05XXs0fXxbXlxcXFxcXDAtXFx4MDlcXHgwYS1cXHgxZlwiXSkqXCIpLywvXig/OlxceykvLC9eKD86XFx9KS8sL14oPzpcXFspLywvXig/OlxcXSkvLC9eKD86LCkvLC9eKD86OikvLC9eKD86dHJ1ZVxcYikvLC9eKD86ZmFsc2VcXGIpLywvXig/Om51bGxcXGIpLywvXig/OiQpLywvXig/Oi4pL10sXG5jb25kaXRpb25zOiB7XCJJTklUSUFMXCI6e1wicnVsZXNcIjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxM10sXCJpbmNsdXNpdmVcIjp0cnVlfX1cbn0pO1xucmV0dXJuIGxleGVyO1xufSkoKTtcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuZnVuY3Rpb24gUGFyc2VyICgpIHtcbiAgdGhpcy55eSA9IHt9O1xufVxuUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xucmV0dXJuIG5ldyBQYXJzZXI7XG59KSgpO1xuXG5cbmlmICh0eXBlb2YgY29tbW9uanNSZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiAnb2JqZWN0JyAhPT0gJ3VuZGVmaW5lZCcpIHtcbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xuZXhwb3J0cy5QYXJzZXIgPSBwYXJzZXIuUGFyc2VyO1xuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlci5wYXJzZS5hcHBseShwYXJzZXIsIGFyZ3VtZW50cyk7IH07XG59XG59KTtcbnZhciBqc29ubGludF8xID0ganNvbmxpbnQucGFyc2VyO1xudmFyIGpzb25saW50XzIgPSBqc29ubGludC5QYXJzZXI7XG52YXIganNvbmxpbnRfMyA9IGpzb25saW50LnBhcnNlO1xuXG5mdW5jdGlvbiByZWFkU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyB8fCBzdHlsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb25saW50LnBhcnNlKHN0eWxlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yJDEoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlKHN0eWxlLCBzdHlsZVNwZWMpIHtcbiAgICBpZiAoc3R5bGVTcGVjID09PSB2b2lkIDApXG4gICAgICAgIHN0eWxlU3BlYyA9IHY4O1xuICAgIHZhciBzID0gc3R5bGU7XG4gICAgdHJ5IHtcbiAgICAgICAgcyA9IHJlYWRTdHlsZShzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBbZV07XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVN0eWxlTWluKHMsIHN0eWxlU3BlYyk7XG59XG5cbnZhciBTVVBQT1JURURfU1BFQ19WRVJTSU9OID0gODtcbnZhciBNQVhfU09VUkNFU19JTl9TVFlMRSA9IDE1O1xuZnVuY3Rpb24gaXNWYWxpZCh2YWx1ZSwgcmVnZXgpIHtcbiAgICBpZiAoIXZhbHVlIHx8IGdldFR5cGUodmFsdWUpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICEhdmFsdWUubWF0Y2gocmVnZXgpO1xufVxuZnVuY3Rpb24gZ2V0U291cmNlQ291bnQoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS51cmwpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS51cmwuc3BsaXQoJywnKS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QWxsb3dlZEtleUVycm9ycyhvYmosIGtleXMsIHBhdGgpIHtcbiAgICB2YXIgYWxsb3dlZCA9IG5ldyBTZXQoa2V5cyk7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoIWFsbG93ZWQuaGFzKGspKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHBhdGggPyBwYXRoICsgJy4nICsgayA6IG51bGw7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKHByb3AsIG9ialtrXSwgJ1Vuc3VwcG9ydGVkIHByb3BlcnR5IFwiJyArIGsgKyAnXCInKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gZ2V0U291cmNlRXJyb3JzKHNvdXJjZSwgaSkge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgc291cmNlS2V5cyA9IFtcbiAgICAgICAgJ3R5cGUnLFxuICAgICAgICAndXJsJyxcbiAgICAgICAgJ3RpbGVTaXplJ1xuICAgIF07XG4gICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBnZXRBbGxvd2VkS2V5RXJyb3JzKHNvdXJjZSwgc291cmNlS2V5cywgJ3NvdXJjZScpKTtcbiAgICB2YXIgc291cmNlVXJsUGF0dGVybiA9IC9ebWFwYm94OlxcL1xcLyhbXi9dKikkLztcbiAgICBpZiAoIWlzVmFsaWQoc291cmNlLnVybCwgc291cmNlVXJsUGF0dGVybikpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcignc291cmNlc1snICsgaSArICddJywgc291cmNlLnVybCwgJ1NvdXJjZSB1cmwgbXVzdCBiZSBhIHZhbGlkIE1hcGJveCB0aWxlc2V0IHVybCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIGdldFNvdXJjZXNFcnJvcnMoc291cmNlcykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZXMpLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgdmFyIHNvdXJjZUVycm9ycyA9IGdldFNvdXJjZUVycm9ycyhzb3VyY2VzW3NdLCBpKTtcbiAgICAgICAgaWYgKCFzb3VyY2VFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50ICsgZ2V0U291cmNlQ291bnQoc291cmNlc1tzXSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBzb3VyY2VFcnJvcnMpO1xuICAgIH0pO1xuICAgIGlmIChjb3VudCA+IE1BWF9TT1VSQ0VTX0lOX1NUWUxFKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3NvdXJjZXMnLCBudWxsLCAnU3R5bGVzIG11c3QgY29udGFpbiAnICsgTUFYX1NPVVJDRVNfSU5fU1RZTEUgKyAnIG9yIGZld2VyIHNvdXJjZXMnKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBnZXRSb290RXJyb3JzKHN0eWxlLCBzcGVjS2V5cykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgb3B0aW9uYWxSb290UHJvcGVydGllcyA9IFtcbiAgICAgICAgJ293bmVyJyxcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ2NhY2hlQ29udHJvbCcsXG4gICAgICAgICdkcmFmdCcsXG4gICAgICAgICdjcmVhdGVkJyxcbiAgICAgICAgJ21vZGlmaWVkJyxcbiAgICAgICAgJ3Zpc2liaWxpdHknXG4gICAgXTtcbiAgICB2YXIgYWxsb3dlZEtleUVycm9ycyA9IGdldEFsbG93ZWRLZXlFcnJvcnMoc3R5bGUsIHNwZWNLZXlzLmNvbmNhdChvcHRpb25hbFJvb3RQcm9wZXJ0aWVzKSk7XG4gICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBhbGxvd2VkS2V5RXJyb3JzKTtcbiAgICBpZiAoc3R5bGUudmVyc2lvbiA+IFNVUFBPUlRFRF9TUEVDX1ZFUlNJT04gfHwgc3R5bGUudmVyc2lvbiA8IFNVUFBPUlRFRF9TUEVDX1ZFUlNJT04pIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcigndmVyc2lvbicsIHN0eWxlLnZlcnNpb24sICdTdHlsZSB2ZXJzaW9uIG11c3QgYmUgJyArIFNVUFBPUlRFRF9TUEVDX1ZFUlNJT04pKTtcbiAgICB9XG4gICAgdmFyIGdseXBoVXJsUGF0dGVybiA9IC9ebWFwYm94OlxcL1xcL2ZvbnRzXFwvKFteL10qKVxcL3tmb250c3RhY2t9XFwve3JhbmdlfS5wYmYkLztcbiAgICBpZiAoIWlzVmFsaWQoc3R5bGUuZ2x5cGhzLCBnbHlwaFVybFBhdHRlcm4pKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ2dseXBocycsIHN0eWxlLmdseXBocywgJ1N0eWxlcyBtdXN0IHJlZmVyZW5jZSBnbHlwaHMgaG9zdGVkIGJ5IE1hcGJveCcpKTtcbiAgICB9XG4gICAgdmFyIHNwcml0ZVVybFBhdHRlcm4gPSAvXm1hcGJveDpcXC9cXC9zcHJpdGVzXFwvKFteL10qKVxcLyhbXi9dKilcXC8/KFteL10qKT8kLztcbiAgICBpZiAoIWlzVmFsaWQoc3R5bGUuc3ByaXRlLCBzcHJpdGVVcmxQYXR0ZXJuKSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKCdzcHJpdGUnLCBzdHlsZS5zcHJpdGUsICdTdHlsZXMgbXVzdCByZWZlcmVuY2Ugc3ByaXRlcyBob3N0ZWQgYnkgTWFwYm94JykpO1xuICAgIH1cbiAgICB2YXIgdmlzaWJpbGl0eVBhdHRlcm4gPSAvXihwdWJsaWN8cHJpdmF0ZSkkLztcbiAgICBpZiAoIWlzVmFsaWQoc3R5bGUudmlzaWJpbGl0eSwgdmlzaWJpbGl0eVBhdHRlcm4pKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3Zpc2liaWxpdHknLCBzdHlsZS52aXNpYmlsaXR5LCAnU3R5bGUgdmlzaWJpbGl0eSBtdXN0IGJlIHB1YmxpYyBvciBwcml2YXRlJykpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNYXBib3hBcGlTdXBwb3J0ZWQoc3R5bGUpIHtcbiAgICB2YXIgcyA9IHN0eWxlO1xuICAgIHRyeSB7XG4gICAgICAgIHMgPSByZWFkU3R5bGUocyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gW2VdO1xuICAgIH1cbiAgICB2YXIgZXJyb3JzID0gdmFsaWRhdGVTdHlsZU1pbihzLCB2OCkuY29uY2F0KGdldFJvb3RFcnJvcnMocywgT2JqZWN0LmtleXModjguJHJvb3QpKSk7XG4gICAgaWYgKHMuc291cmNlcykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGdldFNvdXJjZXNFcnJvcnMocy5zb3VyY2VzKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5cbnZhciBleHByZXNzaW9uJDEgPSB7XG4gICAgU3R5bGVFeHByZXNzaW9uOiBTdHlsZUV4cHJlc3Npb24sXG4gICAgaXNFeHByZXNzaW9uOiBpc0V4cHJlc3Npb24sXG4gICAgaXNFeHByZXNzaW9uRmlsdGVyOiBpc0V4cHJlc3Npb25GaWx0ZXIsXG4gICAgY3JlYXRlRXhwcmVzc2lvbjogY3JlYXRlRXhwcmVzc2lvbixcbiAgICBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb246IGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbixcbiAgICBub3JtYWxpemVQcm9wZXJ0eUV4cHJlc3Npb246IG5vcm1hbGl6ZVByb3BlcnR5RXhwcmVzc2lvbixcbiAgICBab29tQ29uc3RhbnRFeHByZXNzaW9uOiBab29tQ29uc3RhbnRFeHByZXNzaW9uLFxuICAgIFpvb21EZXBlbmRlbnRFeHByZXNzaW9uOiBab29tRGVwZW5kZW50RXhwcmVzc2lvbixcbiAgICBTdHlsZVByb3BlcnR5RnVuY3Rpb246IFN0eWxlUHJvcGVydHlGdW5jdGlvblxufTtcbnZhciBzdHlsZUZ1bmN0aW9uID0ge1xuICAgIGNvbnZlcnRGdW5jdGlvbjogY29udmVydEZ1bmN0aW9uLFxuICAgIGNyZWF0ZUZ1bmN0aW9uOiBjcmVhdGVGdW5jdGlvbixcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uJDFcbn07XG52YXIgdmlzaXQgPSB7XG4gICAgZWFjaFNvdXJjZTogZWFjaFNvdXJjZSxcbiAgICBlYWNoTGF5ZXI6IGVhY2hMYXllcixcbiAgICBlYWNoUHJvcGVydHk6IGVhY2hQcm9wZXJ0eVxufTtcbnZhbGlkYXRlU3R5bGUucGFyc2VkID0gdmFsaWRhdGVTdHlsZTtcbnZhbGlkYXRlU3R5bGUubGF0ZXN0ID0gdmFsaWRhdGVTdHlsZTtcblxuZXhwb3J0IHsgQ29sb3IsIFBhcnNpbmdFcnJvciQxIGFzIFBhcnNpbmdFcnJvciwgVmFsaWRhdGlvbkVycm9yLCBjb21wb3NpdGUsIGNvbnZlcnRGaWx0ZXIkMSBhcyBjb252ZXJ0RmlsdGVyLCBkZXJlZkxheWVycywgZGlmZlN0eWxlcyBhcyBkaWZmLCBleHByZXNzaW9uJDEgYXMgZXhwcmVzc2lvbiwgY3JlYXRlRmlsdGVyIGFzIGZlYXR1cmVGaWx0ZXIsIGZvcm1hdCwgc3R5bGVGdW5jdGlvbiBhcyBmdW5jdGlvbiwgdjggYXMgbGF0ZXN0LCBtaWdyYXRlLCB2OCwgdmFsaWRhdGVTdHlsZSBhcyB2YWxpZGF0ZSwgdmFsaWRhdGVNYXBib3hBcGlTdXBwb3J0ZWQsIHZpc2l0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJ2YXIgZm9udFdlaWdodHMgPSB7XG4gIHRoaW46IDEwMCxcbiAgaGFpcmxpbmU6IDEwMCxcbiAgJ3VsdHJhLWxpZ2h0JzogMTAwLFxuICAnZXh0cmEtbGlnaHQnOiAxMDAsXG4gIGxpZ2h0OiAyMDAsXG4gIGJvb2s6IDMwMCxcbiAgcmVndWxhcjogNDAwLFxuICBub3JtYWw6IDQwMCxcbiAgcGxhaW46IDQwMCxcbiAgcm9tYW46IDQwMCxcbiAgc3RhbmRhcmQ6IDQwMCxcbiAgbWVkaXVtOiA1MDAsXG4gICdzZW1pLWJvbGQnOiA2MDAsXG4gICdkZW1pLWJvbGQnOiA2MDAsXG4gIGJvbGQ6IDcwMCxcbiAgaGVhdnk6IDgwMCxcbiAgYmxhY2s6IDgwMCxcbiAgJ2V4dHJhLWJvbGQnOiA4MDAsXG4gICd1bHRyYS1ibGFjayc6IDkwMCxcbiAgJ2V4dHJhLWJsYWNrJzogOTAwLFxuICAndWx0cmEtYm9sZCc6IDkwMCxcbiAgJ2hlYXZ5LWJsYWNrJzogOTAwLFxuICBmYXQ6IDkwMCxcbiAgcG9zdGVyOiA5MDBcbn07XG52YXIgc3AgPSAnICc7XG52YXIgaXRhbGljUkUgPSAvKGl0YWxpY3xvYmxpcXVlKSQvaTtcblxudmFyIGZvbnRDYWNoZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZvbnRzLCBzaXplLCBsaW5lSGVpZ2h0KSB7XG4gIHZhciBjc3NEYXRhID0gZm9udENhY2hlW2ZvbnRzXTtcbiAgaWYgKCFjc3NEYXRhKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZvbnRzKSkge1xuICAgICAgZm9udHMgPSBbZm9udHNdO1xuICAgIH1cbiAgICB2YXIgd2VpZ2h0ID0gNDAwO1xuICAgIHZhciBzdHlsZSA9ICdub3JtYWwnO1xuICAgIHZhciBmb250RmFtaWxpZXMgPSBbXTtcbiAgICB2YXIgaGF2ZVdlaWdodCwgaGF2ZVN0eWxlO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZvbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBmb250ID0gZm9udHNbaV07XG4gICAgICB2YXIgcGFydHMgPSBmb250LnNwbGl0KCcgJyk7XG4gICAgICB2YXIgbWF5YmVXZWlnaHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG1heWJlV2VpZ2h0ID09ICdub3JtYWwnIHx8IG1heWJlV2VpZ2h0ID09ICdpdGFsaWMnIHx8IG1heWJlV2VpZ2h0ID09ICdvYmxpcXVlJykge1xuICAgICAgICBzdHlsZSA9IGhhdmVTdHlsZSA/IHN0eWxlIDogbWF5YmVXZWlnaHQ7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICBtYXliZVdlaWdodCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGl0YWxpY1JFLnRlc3QobWF5YmVXZWlnaHQpKSB7XG4gICAgICAgIG1heWJlV2VpZ2h0ID0gbWF5YmVXZWlnaHQucmVwbGFjZShpdGFsaWNSRSwgJycpO1xuICAgICAgICBzdHlsZSA9IGhhdmVTdHlsZSA/IHN0eWxlIDogcGFydHNbcGFydHMubGVuZ3RoIC0gMV0ucmVwbGFjZShtYXliZVdlaWdodCwgJycpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgdyBpbiBmb250V2VpZ2h0cykge1xuICAgICAgICBpZiAobWF5YmVXZWlnaHQgPT0gdyB8fCBtYXliZVdlaWdodCA9PSB3LnJlcGxhY2UoJy0nLCAnJykgfHwgbWF5YmVXZWlnaHQgPT0gdy5yZXBsYWNlKCctJywgc3ApKSB7XG4gICAgICAgICAgd2VpZ2h0ID0gaGF2ZVdlaWdodCA/IHdlaWdodCA6IGZvbnRXZWlnaHRzW3ddO1xuICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhdmVXZWlnaHQgJiYgdHlwZW9mIG1heWJlV2VpZ2h0ID09ICdudW1iZXInKSB7XG4gICAgICAgIHdlaWdodCA9IG1heWJlV2VpZ2h0O1xuICAgICAgfVxuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBwYXJ0cy5qb2luKHNwKVxuICAgICAgICAucmVwbGFjZSgnS2xva2FudGVjaCBOb3RvIFNhbnMnLCAnTm90byBTYW5zJyk7XG4gICAgICBpZiAoZm9udEZhbWlseS5pbmRleE9mKHNwKSAhPT0gLTEpIHtcbiAgICAgICAgZm9udEZhbWlseSA9ICdcIicgKyBmb250RmFtaWx5ICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGZvbnRGYW1pbGllcy5wdXNoKGZvbnRGYW1pbHkpO1xuICAgIH1cbiAgICAvLyBDU1MgZm9udCBwcm9wZXJ0eTogZm9udC1zdHlsZSBmb250LXdlaWdodCBmb250LXNpemUvbGluZS1oZWlnaHQgZm9udC1mYW1pbHlcbiAgICBjc3NEYXRhID0gZm9udENhY2hlW2ZvbnRzXSA9IFtzdHlsZSwgd2VpZ2h0LCBmb250RmFtaWxpZXNdO1xuICB9XG4gIHJldHVybiBjc3NEYXRhWzBdICsgc3AgKyBjc3NEYXRhWzFdICsgc3AgKyBzaXplICsgJ3B4JyArIChsaW5lSGVpZ2h0ID8gJy8nICsgbGluZUhlaWdodCA6ICcnKSArIHNwICsgY3NzRGF0YVsyXTtcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvQXNzZXJ0aW9uRXJyb3JcbiAqL1xuaW1wb3J0IHtWRVJTSU9OLCBpbmhlcml0c30gZnJvbSAnLi9pbmRleC5qcyc7XG5cbi8qKlxuICogRXJyb3Igb2JqZWN0IHRocm93biB3aGVuIGFuIGFzc2VydGlvbiBmYWlsZWQuIFRoaXMgaXMgYW4gRUNNQS0yNjIgRXJyb3IsXG4gKiBleHRlbmRlZCB3aXRoIGEgYGNvZGVgIHByb3BlcnR5LlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3J9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIEVycm9yIGNvZGUuXG4gKi9cbmNvbnN0IEFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24oY29kZSkge1xuXG4gIGNvbnN0IHBhdGggPSBWRVJTSU9OID8gVkVSU0lPTi5zcGxpdCgnLScpWzBdIDogJ2xhdGVzdCc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLm1lc3NhZ2UgPSAnQXNzZXJ0aW9uIGZhaWxlZC4gU2VlIGh0dHBzOi8vb3BlbmxheWVycy5vcmcvZW4vJyArIHBhdGggK1xuICAgICAgJy9kb2MvZXJyb3JzLyMnICsgY29kZSArICcgZm9yIGRldGFpbHMuJztcblxuICAvKipcbiAgICogRXJyb3IgY29kZS4gVGhlIG1lYW5pbmcgb2YgdGhlIGNvZGUgY2FuIGJlIGZvdW5kIG9uXG4gICAqIHtAbGluayBodHRwczovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9kb2MvZXJyb3JzL30gKHJlcGxhY2UgYGxhdGVzdGAgd2l0aFxuICAgKiB0aGUgdmVyc2lvbiBmb3VuZCBpbiB0aGUgT3BlbkxheWVycyBzY3JpcHQncyBoZWFkZXIgY29tbWVudCBpZiBhIHZlcnNpb25cbiAgICogb3RoZXIgdGhhbiB0aGUgbGF0ZXN0IGlzIHVzZWQpLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAYXBpXG4gICAqL1xuICB0aGlzLmNvZGUgPSBjb2RlO1xuXG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cbn07XG5cbmluaGVyaXRzKEFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmV4cG9ydCBkZWZhdWx0IEFzc2VydGlvbkVycm9yO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0Rpc3Bvc2FibGVcbiAqL1xuaW1wb3J0IHtVTkRFRklORUR9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcblxuLyoqXG4gKiBPYmplY3RzIHRoYXQgbmVlZCB0byBjbGVhbiB1cCBhZnRlciB0aGVtc2VsdmVzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNvbnN0IERpc3Bvc2FibGUgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIFRoZSBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAqIEB0eXBlIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZWRfID0gZmFsc2U7XG5cbi8qKlxuICogQ2xlYW4gdXAuXG4gKi9cbkRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRpc3Bvc2VkXykge1xuICAgIHRoaXMuZGlzcG9zZWRfID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4dGVuc2lvbiBwb2ludCBmb3IgZGlzcG9zYWJsZSBvYmplY3RzLlxuICogQHByb3RlY3RlZFxuICovXG5EaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBVTkRFRklORUQ7XG5leHBvcnQgZGVmYXVsdCBEaXNwb3NhYmxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlVGlsZVxuICovXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICcuL2luZGV4LmpzJztcbmltcG9ydCBUaWxlIGZyb20gJy4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQge2xpc3Rlbk9uY2UsIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obmV3OiBtb2R1bGU6b2wvSW1hZ2VUaWxlLCBtb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZCxcbiAqIG1vZHVsZTpvbC9UaWxlU3RhdGUsIHN0cmluZywgP3N0cmluZywgbW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9uKX0gVGlsZUNsYXNzXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHttb2R1bGU6b2wvVGlsZX1cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBJbWFnZSBzb3VyY2UgVVJJLlxuICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvbiBUaWxlIGxvYWQgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlfk9wdGlvbnM9fSBvcHRfb3B0aW9ucyBUaWxlIG9wdGlvbnMuXG4gKi9cbmNvbnN0IEltYWdlVGlsZSA9IGZ1bmN0aW9uKHRpbGVDb29yZCwgc3RhdGUsIHNyYywgY3Jvc3NPcmlnaW4sIHRpbGVMb2FkRnVuY3Rpb24sIG9wdF9vcHRpb25zKSB7XG5cbiAgVGlsZS5jYWxsKHRoaXMsIHRpbGVDb29yZCwgc3RhdGUsIG9wdF9vcHRpb25zKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqL1xuICB0aGlzLmNyb3NzT3JpZ2luXyA9IGNyb3NzT3JpZ2luO1xuXG4gIC8qKlxuICAgKiBJbWFnZSBVUklcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuc3JjXyA9IHNyYztcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0ltYWdlfEhUTUxDYW52YXNFbGVtZW50fVxuICAgKi9cbiAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgaWYgKGNyb3NzT3JpZ2luICE9PSBudWxsKSB7XG4gICAgdGhpcy5pbWFnZV8uY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pn1cbiAgICovXG4gIHRoaXMuaW1hZ2VMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbn1cbiAgICovXG4gIHRoaXMudGlsZUxvYWRGdW5jdGlvbl8gPSB0aWxlTG9hZEZ1bmN0aW9uO1xuXG59O1xuXG5pbmhlcml0cyhJbWFnZVRpbGUsIFRpbGUpO1xuXG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuSW1hZ2VUaWxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgdGhpcy5pbWFnZV8gPSBnZXRCbGFua0ltYWdlKCk7XG4gIH1cbiAgaWYgKHRoaXMuaW50ZXJpbVRpbGUpIHtcbiAgICB0aGlzLmludGVyaW1UaWxlLmRpc3Bvc2UoKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkFCT1JUO1xuICB0aGlzLmNoYW5nZWQoKTtcbiAgVGlsZS5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsLmNhbGwodGhpcyk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBIVE1MIGltYWdlIGVsZW1lbnQgZm9yIHRoaXMgdGlsZSAobWF5IGJlIGEgQ2FudmFzLCBJbWFnZSwgb3IgVmlkZW8pLlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBJbWFnZS5cbiAqIEBhcGlcbiAqL1xuSW1hZ2VUaWxlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pbWFnZV87XG59O1xuXG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuSW1hZ2VUaWxlLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc3JjXztcbn07XG5cblxuLyoqXG4gKiBUcmFja3MgbG9hZGluZyBvciByZWFkIGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5JbWFnZVRpbGUucHJvdG90eXBlLmhhbmRsZUltYWdlRXJyb3JfID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRVJST1I7XG4gIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgdGhpcy5pbWFnZV8gPSBnZXRCbGFua0ltYWdlKCk7XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuXG4vKipcbiAqIFRyYWNrcyBzdWNjZXNzZnVsIGltYWdlIGxvYWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuSW1hZ2VUaWxlLnByb3RvdHlwZS5oYW5kbGVJbWFnZUxvYWRfID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmltYWdlXy5uYXR1cmFsV2lkdGggJiYgdGhpcy5pbWFnZV8ubmF0dXJhbEhlaWdodCkge1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BREVEO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gIH1cbiAgdGhpcy51bmxpc3RlbkltYWdlXygpO1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICogQGFwaVxuICovXG5JbWFnZVRpbGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5JRExFO1xuICAgIHRoaXMuaW1hZ2VfID0gbmV3IEltYWdlKCk7XG4gICAgaWYgKHRoaXMuY3Jvc3NPcmlnaW5fICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmltYWdlXy5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW5fO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BRElORztcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXyA9IFtcbiAgICAgIGxpc3Rlbk9uY2UodGhpcy5pbWFnZV8sIEV2ZW50VHlwZS5FUlJPUixcbiAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUVycm9yXywgdGhpcyksXG4gICAgICBsaXN0ZW5PbmNlKHRoaXMuaW1hZ2VfLCBFdmVudFR5cGUuTE9BRCxcbiAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUxvYWRfLCB0aGlzKVxuICAgIF07XG4gICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uXyh0aGlzLCB0aGlzLnNyY18pO1xuICB9XG59O1xuXG5cbi8qKlxuICogRGlzY2FyZHMgZXZlbnQgaGFuZGxlcnMgd2hpY2ggbGlzdGVuIGZvciBsb2FkIGNvbXBsZXRpb24gb3IgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkltYWdlVGlsZS5wcm90b3R5cGUudW5saXN0ZW5JbWFnZV8gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbWFnZUxpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgdGhpcy5pbWFnZUxpc3RlbmVyS2V5c18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIEdldCBhIDEtcGl4ZWwgYmxhbmsgaW1hZ2UuXG4gKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQmxhbmsgaW1hZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldEJsYW5rSW1hZ2UoKSB7XG4gIGNvbnN0IGN0eCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgxLCAxKTtcbiAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICByZXR1cm4gY3R4LmNhbnZhcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VUaWxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL09iamVjdFxuICovXG5pbXBvcnQge2dldFVpZCwgaW5oZXJpdHN9IGZyb20gJy4vaW5kZXguanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuL09ic2VydmFibGUuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuL29iai5qcyc7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZlxuICogdGhpcyB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBmb3IgYGtleWAuXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jb25zdCBPYmplY3RFdmVudCA9IGZ1bmN0aW9uKHR5cGUsIGtleSwgb2xkVmFsdWUpIHtcbiAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdob3NlIHZhbHVlIGlzIGNoYW5naW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAYXBpXG4gICAqL1xuICB0aGlzLmtleSA9IGtleTtcblxuICAvKipcbiAgICogVGhlIG9sZCB2YWx1ZS4gVG8gZ2V0IHRoZSBuZXcgdmFsdWUgdXNlIGBlLnRhcmdldC5nZXQoZS5rZXkpYCB3aGVyZVxuICAgKiBgZWAgaXMgdGhlIGV2ZW50IG9iamVjdC5cbiAgICogQHR5cGUgeyp9XG4gICAqIEBhcGlcbiAgICovXG4gIHRoaXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcblxufTtcbmluaGVyaXRzKE9iamVjdEV2ZW50LCBFdmVudCk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBNb3N0IG5vbi10cml2aWFsIGNsYXNzZXMgaW5oZXJpdCBmcm9tIHRoaXMuXG4gKlxuICogVGhpcyBleHRlbmRzIHtAbGluayBtb2R1bGU6b2wvT2JzZXJ2YWJsZX0gd2l0aCBvYnNlcnZhYmxlXG4gKiBwcm9wZXJ0aWVzLCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIG9ic2VydmFibGUgYXMgd2VsbCBhcyB0aGUgb2JqZWN0IGFzIGFcbiAqIHdob2xlLlxuICpcbiAqIENsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyBoYXZlIHByZS1kZWZpbmVkIHByb3BlcnRpZXMsIHRvIHdoaWNoIHlvdSBjYW5cbiAqIGFkZCB5b3VyIG93bnMuIFRoZSBwcmUtZGVmaW5lZCBwcm9wZXJ0aWVzIGFyZSBsaXN0ZWQgaW4gdGhpcyBkb2N1bWVudGF0aW9uIGFzXG4gKiAnT2JzZXJ2YWJsZSBQcm9wZXJ0aWVzJywgYW5kIGhhdmUgdGhlaXIgb3duIGFjY2Vzc29yczsgZm9yIGV4YW1wbGUsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGhhcyBhIGB0YXJnZXRgIHByb3BlcnR5LCBhY2Nlc3NlZCB3aXRoXG4gKiBgZ2V0VGFyZ2V0KClgIGFuZCBjaGFuZ2VkIHdpdGggYHNldFRhcmdldCgpYC4gTm90IGFsbCBwcm9wZXJ0aWVzIGFyZSBob3dldmVyXG4gKiBzZXR0YWJsZS4gVGhlcmUgYXJlIGFsc28gZ2VuZXJhbC1wdXJwb3NlIGFjY2Vzc29ycyBgZ2V0KClgIGFuZCBgc2V0KClgLiBGb3JcbiAqIGV4YW1wbGUsIGBnZXQoJ3RhcmdldCcpYCBpcyBlcXVpdmFsZW50IHRvIGBnZXRUYXJnZXQoKWAuXG4gKlxuICogVGhlIGBzZXRgIGFjY2Vzc29ycyB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCBhbmQgeW91IGNhbiBtb25pdG9yIHRoaXMgYnlcbiAqIHJlZ2lzdGVyaW5nIGEgbGlzdGVuZXIuIEZvciBleGFtcGxlLCB7QGxpbmsgbW9kdWxlOm9sL1ZpZXd+Vmlld30gaGFzIGFcbiAqIGBjZW50ZXJgIHByb3BlcnR5LCBzbyBgdmlldy5vbignY2hhbmdlOmNlbnRlcicsIGZ1bmN0aW9uKGV2dCkgey4uLn0pO2Agd291bGRcbiAqIGNhbGwgdGhlIGZ1bmN0aW9uIHdoZW5ldmVyIHRoZSB2YWx1ZSBvZiB0aGUgY2VudGVyIHByb3BlcnR5IGNoYW5nZXMuIFdpdGhpblxuICogdGhlIGZ1bmN0aW9uLCBgZXZ0LnRhcmdldGAgd291bGQgYmUgdGhlIHZpZXcsIHNvIGBldnQudGFyZ2V0LmdldENlbnRlcigpYFxuICogd291bGQgcmV0dXJuIHRoZSBuZXcgY2VudGVyLlxuICpcbiAqIFlvdSBjYW4gYWRkIHlvdXIgb3duIG9ic2VydmFibGUgcHJvcGVydGllcyB3aXRoXG4gKiBgb2JqZWN0LnNldCgncHJvcCcsICd2YWx1ZScpYCwgYW5kIHJldHJpZXZlIHRoYXQgd2l0aCBgb2JqZWN0LmdldCgncHJvcCcpYC5cbiAqIFlvdSBjYW4gbGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoYXQgcHJvcGVydHkgdmFsdWUgd2l0aFxuICogYG9iamVjdC5vbignY2hhbmdlOnByb3AnLCBsaXN0ZW5lcilgLiBZb3UgY2FuIGdldCBhIGxpc3Qgb2YgYWxsXG4gKiBwcm9wZXJ0aWVzIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdCNnZXRQcm9wZXJ0aWVzfS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIG9ic2VydmFibGUgcHJvcGVydGllcyBhcmUgc2VwYXJhdGUgZnJvbSBzdGFuZGFyZCBKUyBwcm9wZXJ0aWVzLlxuICogWW91IGNhbiwgZm9yIGV4YW1wbGUsIGdpdmUgeW91ciBtYXAgb2JqZWN0IGEgdGl0bGUgd2l0aFxuICogYG1hcC50aXRsZT0nTmV3IHRpdGxlJ2AgYW5kIHdpdGggYG1hcC5zZXQoJ3RpdGxlJywgJ0Fub3RoZXIgdGl0bGUnKWAuIFRoZVxuICogZmlyc3Qgd2lsbCBiZSBhIGBoYXNPd25Qcm9wZXJ0eWA7IHRoZSBzZWNvbmQgd2lsbCBhcHBlYXIgaW5cbiAqIGBnZXRQcm9wZXJ0aWVzKClgLiBPbmx5IHRoZSBzZWNvbmQgaXMgb2JzZXJ2YWJsZS5cbiAqXG4gKiBQcm9wZXJ0aWVzIGNhbiBiZSBkZWxldGVkIGJ5IHVzaW5nIHRoZSB1bnNldCBtZXRob2QuIEUuZy5cbiAqIG9iamVjdC51bnNldCgnZm9vJykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL09ic2VydmFibGV9XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPj19IG9wdF92YWx1ZXMgQW4gb2JqZWN0IHdpdGgga2V5LXZhbHVlIHBhaXJzLlxuICogQGZpcmVzIG1vZHVsZTpvbC9PYmplY3R+T2JqZWN0RXZlbnRcbiAqIEBhcGlcbiAqL1xuY29uc3QgQmFzZU9iamVjdCA9IGZ1bmN0aW9uKG9wdF92YWx1ZXMpIHtcbiAgT2JzZXJ2YWJsZS5jYWxsKHRoaXMpO1xuXG4gIC8vIENhbGwge0BsaW5rIG1vZHVsZTpvbH5nZXRVaWR9IHRvIGVuc3VyZSB0aGF0IHRoZSBvcmRlciBvZiBvYmplY3RzJyBpZHMgaXNcbiAgLy8gdGhlIHNhbWUgYXMgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBjcmVhdGVkLiAgVGhpcyBhbHNvIGhlbHBzIHRvXG4gIC8vIGVuc3VyZSB0aGF0IG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgYWRkZWQgaW4gdGhlIHNhbWUgb3JkZXIsIHdoaWNoXG4gIC8vIGhlbHBzIG1hbnkgSmF2YVNjcmlwdCBlbmdpbmVzIGdlbmVyYXRlIGZhc3RlciBjb2RlLlxuICBnZXRVaWQodGhpcyk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsICo+fVxuICAgKi9cbiAgdGhpcy52YWx1ZXNfID0ge307XG5cbiAgaWYgKG9wdF92YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc2V0UHJvcGVydGllcyhvcHRfdmFsdWVzKTtcbiAgfVxufTtcblxuaW5oZXJpdHMoQmFzZU9iamVjdCwgT2JzZXJ2YWJsZSk7XG5cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmNvbnN0IGNoYW5nZUV2ZW50VHlwZUNhY2hlID0ge307XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICogQHJldHVybiB7c3RyaW5nfSBDaGFuZ2UgbmFtZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5nZUV2ZW50VHlwZShrZXkpIHtcbiAgcmV0dXJuIGNoYW5nZUV2ZW50VHlwZUNhY2hlLmhhc093blByb3BlcnR5KGtleSkgP1xuICAgIGNoYW5nZUV2ZW50VHlwZUNhY2hlW2tleV0gOlxuICAgIChjaGFuZ2VFdmVudFR5cGVDYWNoZVtrZXldID0gJ2NoYW5nZTonICsga2V5KTtcbn1cblxuXG4vKipcbiAqIEdldHMgYSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IG5hbWUuXG4gKiBAcmV0dXJuIHsqfSBWYWx1ZS5cbiAqIEBhcGlcbiAqL1xuQmFzZU9iamVjdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gIGxldCB2YWx1ZTtcbiAgaWYgKHRoaXMudmFsdWVzXy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgdmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBvYmplY3QgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gTGlzdCBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBhcGlcbiAqL1xuQmFzZU9iamVjdC5wcm90b3R5cGUuZ2V0S2V5cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy52YWx1ZXNfKTtcbn07XG5cblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IG9mIGFsbCBwcm9wZXJ0eSBuYW1lcyBhbmQgdmFsdWVzLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsICo+fSBPYmplY3QuXG4gKiBAYXBpXG4gKi9cbkJhc2VPYmplY3QucHJvdG90eXBlLmdldFByb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGFzc2lnbih7fSwgdGhpcy52YWx1ZXNfKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBPbGQgdmFsdWUuXG4gKi9cbkJhc2VPYmplY3QucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uKGtleSwgb2xkVmFsdWUpIHtcbiAgbGV0IGV2ZW50VHlwZTtcbiAgZXZlbnRUeXBlID0gZ2V0Q2hhbmdlRXZlbnRUeXBlKGtleSk7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgT2JqZWN0RXZlbnQoZXZlbnRUeXBlLCBrZXksIG9sZFZhbHVlKSk7XG4gIGV2ZW50VHlwZSA9IE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRTtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBPYmplY3RFdmVudChldmVudFR5cGUsIGtleSwgb2xkVmFsdWUpKTtcbn07XG5cblxuLyoqXG4gKiBTZXRzIGEgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zaWxlbnQgVXBkYXRlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbiBldmVudC5cbiAqIEBhcGlcbiAqL1xuQmFzZU9iamVjdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgb3B0X3NpbGVudCkge1xuICBpZiAob3B0X3NpbGVudCkge1xuICAgIHRoaXMudmFsdWVzX1trZXldID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICB0aGlzLnZhbHVlc19ba2V5XSA9IHZhbHVlO1xuICAgIGlmIChvbGRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMubm90aWZ5KGtleSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFNldHMgYSBjb2xsZWN0aW9uIG9mIGtleS12YWx1ZSBwYWlycy4gIE5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgYW55IGV4aXN0aW5nXG4gKiBwcm9wZXJ0aWVzIGFuZCBhZGRzIG5ldyBvbmVzIChpdCBkb2VzIG5vdCByZW1vdmUgYW55IGV4aXN0aW5nIHByb3BlcnRpZXMpLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgKj59IHZhbHVlcyBWYWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc2lsZW50IFVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gKiBAYXBpXG4gKi9cbkJhc2VPYmplY3QucHJvdG90eXBlLnNldFByb3BlcnRpZXMgPSBmdW5jdGlvbih2YWx1ZXMsIG9wdF9zaWxlbnQpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgdGhpcy5zZXQoa2V5LCB2YWx1ZXNba2V5XSwgb3B0X3NpbGVudCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBVbnNldHMgYSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IG5hbWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc2lsZW50IFVuc2V0IHdpdGhvdXQgdHJpZ2dlcmluZyBhbiBldmVudC5cbiAqIEBhcGlcbiAqL1xuQmFzZU9iamVjdC5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihrZXksIG9wdF9zaWxlbnQpIHtcbiAgaWYgKGtleSBpbiB0aGlzLnZhbHVlc18pIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWVzX1trZXldO1xuICAgIGRlbGV0ZSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICBpZiAoIW9wdF9zaWxlbnQpIHtcbiAgICAgIHRoaXMubm90aWZ5KGtleSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBCYXNlT2JqZWN0O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL09iamVjdEV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBwcm9wZXJ0eSBpcyBjaGFuZ2VkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL09iamVjdH5PYmplY3RFdmVudCNwcm9wZXJ0eWNoYW5nZVxuICAgKiBAYXBpXG4gICAqL1xuICBQUk9QRVJUWUNIQU5HRTogJ3Byb3BlcnR5Y2hhbmdlJ1xufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9PYnNlcnZhYmxlXG4gKi9cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJy4vaW5kZXguanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXksIHVubGlzdGVuLCBsaXN0ZW5PbmNlfSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvRXZlbnRUYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEFuIGV2ZW50IHRhcmdldCBwcm92aWRpbmcgY29udmVuaWVudCBtZXRob2RzIGZvciBsaXN0ZW5lciByZWdpc3RyYXRpb25cbiAqIGFuZCB1bnJlZ2lzdHJhdGlvbi4gQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIGFsd2F5cyBhdmFpbGFibGUgdGhyb3VnaFxuICoge0BsaW5rIG1vZHVsZTpvbC9PYnNlcnZhYmxlfk9ic2VydmFibGUjY2hhbmdlZH0uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH1cbiAqIEBmaXJlcyBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkV2ZW50XG4gKiBAc3RydWN0XG4gKiBAYXBpXG4gKi9cbmNvbnN0IE9ic2VydmFibGUgPSBmdW5jdGlvbigpIHtcblxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5yZXZpc2lvbl8gPSAwO1xuXG59O1xuXG5pbmhlcml0cyhPYnNlcnZhYmxlLCBFdmVudFRhcmdldCk7XG5cblxuLyoqXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIHVzaW5nIHRoZSBrZXkgcmV0dXJuZWQgYnkgYG9uKClgIG9yIGBvbmNlKClgLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleXxBcnJheS48bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXk+fSBrZXkgVGhlIGtleSByZXR1cm5lZCBieSBgb24oKWBcbiAqICAgICBvciBgb25jZSgpYCAob3IgYW4gYXJyYXkgb2Yga2V5cykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bkJ5S2V5KGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0ga2V5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkoa2V5W2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdW5saXN0ZW5CeUtleSgvKiogQHR5cGUge21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fSAqLyAoa2V5KSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEluY3JlYXNlcyB0aGUgcmV2aXNpb24gY291bnRlciBhbmQgZGlzcGF0Y2hlcyBhICdjaGFuZ2UnIGV2ZW50LlxuICogQGFwaVxuICovXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gICsrdGhpcy5yZXZpc2lvbl87XG4gIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0hBTkdFKTtcbn07XG5cblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCBjYWxscyBhbGwgbGlzdGVuZXJzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gKiBvZiB0aGlzIHR5cGUuIFRoZSBldmVudCBwYXJhbWV0ZXIgY2FuIGVpdGhlciBiZSBhIHN0cmluZyBvciBhblxuICogT2JqZWN0IHdpdGggYSBgdHlwZWAgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHt7dHlwZTogc3RyaW5nLFxuICogICAgIHRhcmdldDogKEV2ZW50VGFyZ2V0fG1vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR8dW5kZWZpbmVkKX18XG4gKiAgICAgbW9kdWxlOm9sL2V2ZW50cy9FdmVudHxzdHJpbmd9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAqIEBmdW5jdGlvblxuICogQGFwaVxuICovXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50O1xuXG5cbi8qKlxuICogR2V0IHRoZSB2ZXJzaW9uIG51bWJlciBmb3IgdGhpcyBvYmplY3QuICBFYWNoIHRpbWUgdGhlIG9iamVjdCBpcyBtb2RpZmllZCxcbiAqIGl0cyB2ZXJzaW9uIG51bWJlciB3aWxsIGJlIGluY3JlbWVudGVkLlxuICogQHJldHVybiB7bnVtYmVyfSBSZXZpc2lvbi5cbiAqIEBhcGlcbiAqL1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZ2V0UmV2aXNpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmV2aXNpb25fO1xufTtcblxuXG4vKipcbiAqIExpc3RlbiBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gdHlwZSBUaGUgZXZlbnQgdHlwZSBvciBhcnJheSBvZiBldmVudCB0eXBlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fEFycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT59IFVuaXF1ZSBrZXkgZm9yIHRoZSBsaXN0ZW5lci4gSWZcbiAqICAgICBjYWxsZWQgd2l0aCBhbiBhcnJheSBvZiBldmVudCB0eXBlcyBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSByZXR1cm5cbiAqICAgICB3aWxsIGJlIGFuIGFycmF5IG9mIGtleXMuXG4gKiBAYXBpXG4gKi9cbk9ic2VydmFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICBjb25zdCBsZW4gPSB0eXBlLmxlbmd0aDtcbiAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAga2V5c1tpXSA9IGxpc3Rlbih0aGlzLCB0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW4odGhpcywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgbGlzdGVuZXIpO1xuICB9XG59O1xuXG5cbi8qKlxuICogTGlzdGVuIG9uY2UgZm9yIGEgY2VydGFpbiB0eXBlIG9mIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKD8pOiA/fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleXxBcnJheS48bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXk+fSBVbmlxdWUga2V5IGZvciB0aGUgbGlzdGVuZXIuIElmXG4gKiAgICAgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgcmV0dXJuXG4gKiAgICAgd2lsbCBiZSBhbiBhcnJheSBvZiBrZXlzLlxuICogQGFwaVxuICovXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICBjb25zdCBsZW4gPSB0eXBlLmxlbmd0aDtcbiAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAga2V5c1tpXSA9IGxpc3Rlbk9uY2UodGhpcywgdHlwZVtpXSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuT25jZSh0aGlzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBVbmxpc3RlbiBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gdHlwZSBUaGUgZXZlbnQgdHlwZSBvciBhcnJheSBvZiBldmVudCB0eXBlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBhcGlcbiAqL1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUudW4gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHR5cGUubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdW5saXN0ZW4odGhpcywgdHlwZVtpXSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdW5saXN0ZW4odGhpcywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgbGlzdGVuZXIpO1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgT2JzZXJ2YWJsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlXG4gKi9cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJy4vaW5kZXguanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2Vhc2VJbn0gZnJvbSAnLi9lYXNpbmcuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vZXZlbnRzL0V2ZW50VGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL1RpbGV9IGZvciB0aGUgdGlsZSBhbmQgYVxuICogYHtzdHJpbmd9YCBmb3IgdGhlIHVybCBhcyBhcmd1bWVudHMuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG1vZHVsZTpvbC9UaWxlLCBzdHJpbmcpfSBMb2FkRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZX0gc291cmNlcyB1c2UgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgdG8gZ2V0XG4gKiB0aGUgdXJsIHRoYXQgcHJvdmlkZXMgYSB0aWxlIGZvciBhIGdpdmVuIHRpbGUgY29vcmRpbmF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gZm9yIHRoZSB0aWxlXG4gKiBjb29yZGluYXRlLCBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSBwaXhlbCByYXRpbyBhbmQgYVxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IGZvciB0aGUgcHJvamVjdGlvbiAgYXMgYXJndW1lbnRzXG4gKiBhbmQgcmV0dXJucyBhIGB7c3RyaW5nfWAgcmVwcmVzZW50aW5nIHRoZSB0aWxlIFVSTCwgb3IgdW5kZWZpbmVkIGlmIG5vIHRpbGVcbiAqIHNob3VsZCBiZSByZXF1ZXN0ZWQgZm9yIHRoZSBwYXNzZWQgdGlsZSBjb29yZGluYXRlLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihtb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZCwgbnVtYmVyLFxuICogICAgICAgICAgIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb24pOiAoc3RyaW5nfHVuZGVmaW5lZCl9IFVybEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbj0yNTBdIEEgZHVyYXRpb24gZm9yIHRpbGUgb3BhY2l0eVxuICogdHJhbnNpdGlvbnMgaW4gbWlsbGlzZWNvbmRzLiBBIGR1cmF0aW9uIG9mIDAgZGlzYWJsZXMgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbi5cbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3IgdGlsZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fVxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGVTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlfk9wdGlvbnM9fSBvcHRfb3B0aW9ucyBUaWxlIG9wdGlvbnMuXG4gKi9cbmNvbnN0IFRpbGUgPSBmdW5jdGlvbih0aWxlQ29vcmQsIHN0YXRlLCBvcHRfb3B0aW9ucykge1xuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH1cbiAgICovXG4gIHRoaXMudGlsZUNvb3JkID0gdGlsZUNvb3JkO1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvVGlsZVN0YXRlfVxuICAgKi9cbiAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gIC8qKlxuICAgKiBBbiBcImludGVyaW1cIiB0aWxlIGZvciB0aGlzIHRpbGUuIFRoZSBpbnRlcmltIHRpbGUgbWF5IGJlIHVzZWQgd2hpbGUgdGhpc1xuICAgKiBvbmUgaXMgbG9hZGluZywgZm9yIFwic21vb3RoXCIgdHJhbnNpdGlvbnMgd2hlbiBjaGFuZ2luZyBwYXJhbXMvZGltZW5zaW9uc1xuICAgKiBvbiB0aGUgc291cmNlLlxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGV9XG4gICAqL1xuICB0aGlzLmludGVyaW1UaWxlID0gbnVsbDtcblxuICAvKipcbiAgICogQSBrZXkgYXNzaWduZWQgdG8gdGhlIHRpbGUuIFRoaXMgaXMgdXNlZCBieSB0aGUgdGlsZSBzb3VyY2UgdG8gZGV0ZXJtaW5lXG4gICAqIGlmIHRoaXMgdGlsZSBjYW4gZWZmZWN0aXZlbHkgYmUgdXNlZCwgb3IgaWYgYSBuZXcgdGlsZSBzaG91bGQgYmUgY3JlYXRlZFxuICAgKiBhbmQgdGhpcyBvbmUgYmUgdXNlZCBhcyBhbiBpbnRlcmltIHRpbGUgZm9yIHRoaXMgbmV3IHRpbGUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLmtleSA9ICcnO1xuXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gZm9yIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnRyYW5zaXRpb25fID0gb3B0aW9ucy50cmFuc2l0aW9uID09PSB1bmRlZmluZWQgPyAyNTAgOiBvcHRpb25zLnRyYW5zaXRpb247XG5cbiAgLyoqXG4gICAqIExvb2t1cCBvZiBzdGFydCB0aW1lcyBmb3IgcmVuZGVyaW5nIHRyYW5zaXRpb25zLiAgSWYgdGhlIHN0YXJ0IHRpbWUgaXNcbiAgICogZXF1YWwgdG8gLTEsIHRoZSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlLlxuICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsIG51bWJlcj59XG4gICAqL1xuICB0aGlzLnRyYW5zaXRpb25TdGFydHNfID0ge307XG5cbn07XG5cbmluaGVyaXRzKFRpbGUsIEV2ZW50VGFyZ2V0KTtcblxuXG4vKipcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuVGlsZS5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gKi9cblRpbGUucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5rZXkgKyAnLycgKyB0aGlzLnRpbGVDb29yZDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnRlcmltIHRpbGUgbW9zdCBzdWl0YWJsZSBmb3IgcmVuZGVyaW5nIHVzaW5nIHRoZSBjaGFpbiBvZiBpbnRlcmltXG4gKiB0aWxlcy4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgIG1vc3QgcmVjZW50IHRpbGUgdGhhdCBoYXMgYmVlbiBsb2FkZWQsIGlmIG5vXG4gKiBzdWNoIHRpbGUgZXhpc3RzLCB0aGUgb3JpZ2luYWwgdGlsZSBpcyByZXR1cm5lZC5cbiAqIEByZXR1cm4geyFtb2R1bGU6b2wvVGlsZX0gQmVzdCB0aWxlIGZvciByZW5kZXJpbmcuXG4gKi9cblRpbGUucHJvdG90eXBlLmdldEludGVyaW1UaWxlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pbnRlcmltVGlsZSkge1xuICAgIC8vZW1wdHkgY2hhaW5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsZXQgdGlsZSA9IHRoaXMuaW50ZXJpbVRpbGU7XG5cbiAgLy8gZmluZCB0aGUgZmlyc3QgbG9hZGVkIHRpbGUgYW5kIHJldHVybiBpdC4gU2luY2UgdGhlIGNoYWluIGlzIHNvcnRlZCBpblxuICAvLyBkZWNyZWFzaW5nIG9yZGVyIG9mIGNyZWF0aW9uIHRpbWUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gc2VhcmNoIHRoZSByZW1haW5kZXJcbiAgLy8gb2YgdGhlIGxpc3QgKGFsbCB0aG9zZSB0aWxlcyBjb3JyZXNwb25kIHRvIG9sZGVyIHJlcXVlc3RzIGFuZCB3aWxsIGJlXG4gIC8vIGNsZWFuZWQgdXAgYnkgcmVmcmVzaEludGVyaW1DaGFpbilcbiAgZG8ge1xuICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfVxuICAgIHRpbGUgPSB0aWxlLmludGVyaW1UaWxlO1xuICB9IHdoaWxlICh0aWxlKTtcblxuICAvLyB3ZSBjYW4gbm90IGZpbmQgYSBiZXR0ZXIgdGlsZVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR29lcyB0aHJvdWdoIHRoZSBjaGFpbiBvZiBpbnRlcmltIHRpbGVzIGFuZCBkaXNjYXJkcyBzZWN0aW9ucyBvZiB0aGUgY2hhaW5cbiAqIHRoYXQgYXJlIG5vIGxvbmdlciByZWxldmFudC5cbiAqL1xuVGlsZS5wcm90b3R5cGUucmVmcmVzaEludGVyaW1DaGFpbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaW50ZXJpbVRpbGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgdGlsZSA9IHRoaXMuaW50ZXJpbVRpbGU7XG4gIGxldCBwcmV2ID0gdGhpcztcblxuICBkbyB7XG4gICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAvL3dlIGhhdmUgYSBsb2FkZWQgdGlsZSwgd2UgY2FuIGRpc2NhcmQgdGhlIHJlc3Qgb2YgdGhlIGxpc3RcbiAgICAgIC8vd2Ugd291bGQgY291bGQgYWJvcnQgYW55IExPQURJTkcgdGlsZSByZXF1ZXN0XG4gICAgICAvL29sZGVyIHRoYW4gdGhpcyB0aWxlIChpLmUuIGFueSBMT0FESU5HIHRpbGUgZm9sbG93aW5nIHRoaXMgZW50cnkgaW4gdGhlIGNoYWluKVxuICAgICAgdGlsZS5pbnRlcmltVGlsZSA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgLy9rZWVwIHRoaXMgTE9BRElORyB0aWxlIGFueSBsb2FkZWQgdGlsZXMgbGF0ZXIgaW4gdGhlIGNoYWluIGFyZVxuICAgICAgLy9vbGRlciB0aGFuIHRoaXMgdGlsZSwgc28gd2UncmUgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGUgcmVxdWVzdFxuICAgICAgcHJldiA9IHRpbGU7XG4gICAgfSBlbHNlIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgIC8vdGhlIGhlYWQgb2YgdGhlIGxpc3QgaXMgdGhlIG1vc3QgY3VycmVudCB0aWxlLCB3ZSBkb24ndCBuZWVkXG4gICAgICAvL3RvIHN0YXJ0IGFueSBvdGhlciByZXF1ZXN0cyBmb3IgdGhpcyBjaGFpblxuICAgICAgcHJldi5pbnRlcmltVGlsZSA9IHRpbGUuaW50ZXJpbVRpbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXYgPSB0aWxlO1xuICAgIH1cbiAgICB0aWxlID0gcHJldi5pbnRlcmltVGlsZTtcbiAgfSB3aGlsZSAodGlsZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGlsZSBjb29yZGluYXRlIGZvciB0aGlzIHRpbGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gVGhlIHRpbGUgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuVGlsZS5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRpbGVDb29yZDtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZVN0YXRlfSBTdGF0ZS5cbiAqL1xuVGlsZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc3RhdGU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGVTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gKi9cblRpbGUucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5cbi8qKlxuICogTG9hZCB0aGUgaW1hZ2Ugb3IgcmV0cnkgaWYgbG9hZGluZyBwcmV2aW91c2x5IGZhaWxlZC5cbiAqIExvYWRpbmcgaXMgdGFrZW4gY2FyZSBvZiBieSB0aGUgdGlsZSBxdWV1ZSwgYW5kIGNhbGxpbmcgdGhpcyBtZXRob2QgaXNcbiAqIG9ubHkgbmVlZGVkIGZvciBwcmVsb2FkaW5nIG9yIGZvciByZWxvYWRpbmcgaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAqIEBhYnN0cmFjdFxuICogQGFwaVxuICovXG5UaWxlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBHZXQgdGhlIGFscGhhIHZhbHVlIGZvciByZW5kZXJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgQW4gaWQgZm9yIHRoZSByZW5kZXJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSByZW5kZXIgZnJhbWUgdGltZS5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5UaWxlLnByb3RvdHlwZS5nZXRBbHBoYSA9IGZ1bmN0aW9uKGlkLCB0aW1lKSB7XG4gIGlmICghdGhpcy50cmFuc2l0aW9uXykge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgbGV0IHN0YXJ0ID0gdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF07XG4gIGlmICghc3RhcnQpIHtcbiAgICBzdGFydCA9IHRpbWU7XG4gICAgdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF0gPSBzdGFydDtcbiAgfSBlbHNlIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGNvbnN0IGRlbHRhID0gdGltZSAtIHN0YXJ0ICsgKDEwMDAgLyA2MCk7IC8vIGF2b2lkIHJlbmRlcmluZyBhdCAwXG4gIGlmIChkZWx0YSA+PSB0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGVhc2VJbihkZWx0YSAvIHRoaXMudHJhbnNpdGlvbl8pO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB0aWxlIGlzIGluIGFuIGFscGhhIHRyYW5zaXRpb24uICBBIHRpbGUgaXMgY29uc2lkZXJlZCBpblxuICogdHJhbnNpdGlvbiBpZiB0aWxlLmdldEFscGhhKCkgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQgb3IgaGFzIGJlZW4gY2FsbGVkXG4gKiBhbmQgcmV0dXJuZWQgMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBBbiBpZCBmb3IgdGhlIHJlbmRlcmVyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgaXMgaW4gdHJhbnNpdGlvbi5cbiAqL1xuVGlsZS5wcm90b3R5cGUuaW5UcmFuc2l0aW9uID0gZnVuY3Rpb24oaWQpIHtcbiAgaWYgKCF0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0aGlzLnRyYW5zaXRpb25TdGFydHNfW2lkXSAhPT0gLTE7XG59O1xuXG4vKipcbiAqIE1hcmsgYSB0cmFuc2l0aW9uIGFzIGNvbXBsZXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gKi9cblRpbGUucHJvdG90eXBlLmVuZFRyYW5zaXRpb24gPSBmdW5jdGlvbihpZCkge1xuICBpZiAodGhpcy50cmFuc2l0aW9uXykge1xuICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdID0gLTE7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBUaWxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVDYWNoZVxuICovXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICcuL2luZGV4LmpzJztcbmltcG9ydCBMUlVDYWNoZSBmcm9tICcuL3N0cnVjdHMvTFJVQ2FjaGUuanMnO1xuaW1wb3J0IHtmcm9tS2V5LCBnZXRLZXl9IGZyb20gJy4vdGlsZWNvb3JkLmpzJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHttb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZS48bW9kdWxlOm9sL1RpbGU+fVxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaGlnaFdhdGVyTWFyayBIaWdoIHdhdGVyIG1hcmsuXG4gKiBAc3RydWN0XG4gKi9cbmNvbnN0IFRpbGVDYWNoZSA9IGZ1bmN0aW9uKG9wdF9oaWdoV2F0ZXJNYXJrKSB7XG5cbiAgTFJVQ2FjaGUuY2FsbCh0aGlzLCBvcHRfaGlnaFdhdGVyTWFyayk7XG5cbn07XG5cbmluaGVyaXRzKFRpbGVDYWNoZSwgTFJVQ2FjaGUpO1xuXG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9UaWxlUmFuZ2U+fSB1c2VkVGlsZXMgVXNlZCB0aWxlcy5cbiAqL1xuVGlsZUNhY2hlLnByb3RvdHlwZS5leHBpcmVDYWNoZSA9IGZ1bmN0aW9uKHVzZWRUaWxlcykge1xuICB3aGlsZSAodGhpcy5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgY29uc3QgdGlsZSA9IHRoaXMucGVla0xhc3QoKTtcbiAgICBjb25zdCB6S2V5ID0gdGlsZS50aWxlQ29vcmRbMF0udG9TdHJpbmcoKTtcbiAgICBpZiAoektleSBpbiB1c2VkVGlsZXMgJiYgdXNlZFRpbGVzW3pLZXldLmNvbnRhaW5zKHRpbGUudGlsZUNvb3JkKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9wKCkuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFBydW5lIGFsbCB0aWxlcyBmcm9tIHRoZSBjYWNoZSB0aGF0IGRvbid0IGhhdmUgdGhlIHNhbWUgeiBhcyB0aGUgbmV3ZXN0IHRpbGUuXG4gKi9cblRpbGVDYWNoZS5wcm90b3R5cGUucHJ1bmVFeGNlcHROZXdlc3RaID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmdldENvdW50KCkgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qga2V5ID0gdGhpcy5wZWVrRmlyc3RLZXkoKTtcbiAgY29uc3QgdGlsZUNvb3JkID0gZnJvbUtleShrZXkpO1xuICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIGlmICh0aWxlLnRpbGVDb29yZFswXSAhPT0geikge1xuICAgICAgdGhpcy5yZW1vdmUoZ2V0S2V5KHRpbGUudGlsZUNvb3JkKSk7XG4gICAgICB0aWxlLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xufTtcbmV4cG9ydCBkZWZhdWx0IFRpbGVDYWNoZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlUmFuZ2VcbiAqL1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgY29udGlndW91cyBibG9jayBvZiB0aWxlcy4gIEEgdGlsZSByYW5nZSBpcyBzcGVjaWZpZWRcbiAqIGJ5IGl0cyBtaW4vbWF4IHRpbGUgY29vcmRpbmF0ZXMgYW5kIGlzIGluY2x1c2l2ZSBvZiBjb29yZGluYXRlcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIE1pbmltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIE1pbmltdW0gWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIE1heGltdW0gWS5cbiAqIEBzdHJ1Y3RcbiAqL1xuY29uc3QgVGlsZVJhbmdlID0gZnVuY3Rpb24obWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5taW5YID0gbWluWDtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWF4WCA9IG1heFg7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1pblkgPSBtaW5ZO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5tYXhZID0gbWF4WTtcblxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIE1pbmltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIE1pbmltdW0gWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIE1heGltdW0gWS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGVSYW5nZT19IHRpbGVSYW5nZSBUaWxlUmFuZ2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZVJhbmdlfSBUaWxlIHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgdGlsZVJhbmdlKSB7XG4gIGlmICh0aWxlUmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHRpbGVSYW5nZS5taW5YID0gbWluWDtcbiAgICB0aWxlUmFuZ2UubWF4WCA9IG1heFg7XG4gICAgdGlsZVJhbmdlLm1pblkgPSBtaW5ZO1xuICAgIHRpbGVSYW5nZS5tYXhZID0gbWF4WTtcbiAgICByZXR1cm4gdGlsZVJhbmdlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVGlsZVJhbmdlKG1pblgsIG1heFgsIG1pblksIG1heFkpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgdGlsZSBjb29yZGluYXRlLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24odGlsZUNvb3JkKSB7XG4gIHJldHVybiB0aGlzLmNvbnRhaW5zWFkodGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGVSYW5nZX0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucy5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5jb250YWluc1RpbGVSYW5nZSA9IGZ1bmN0aW9uKHRpbGVSYW5nZSkge1xuICByZXR1cm4gdGhpcy5taW5YIDw9IHRpbGVSYW5nZS5taW5YICYmIHRpbGVSYW5nZS5tYXhYIDw9IHRoaXMubWF4WCAmJlxuICAgICAgdGhpcy5taW5ZIDw9IHRpbGVSYW5nZS5taW5ZICYmIHRpbGVSYW5nZS5tYXhZIDw9IHRoaXMubWF4WTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgY29vcmRpbmF0ZS5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5jb250YWluc1hZID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gdGhpcy5taW5YIDw9IHggJiYgeCA8PSB0aGlzLm1heFggJiYgdGhpcy5taW5ZIDw9IHkgJiYgeSA8PSB0aGlzLm1heFk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEVxdWFscy5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbih0aWxlUmFuZ2UpIHtcbiAgcmV0dXJuIHRoaXMubWluWCA9PSB0aWxlUmFuZ2UubWluWCAmJiB0aGlzLm1pblkgPT0gdGlsZVJhbmdlLm1pblkgJiZcbiAgICAgIHRoaXMubWF4WCA9PSB0aWxlUmFuZ2UubWF4WCAmJiB0aGlzLm1heFkgPT0gdGlsZVJhbmdlLm1heFk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbih0aWxlUmFuZ2UpIHtcbiAgaWYgKHRpbGVSYW5nZS5taW5YIDwgdGhpcy5taW5YKSB7XG4gICAgdGhpcy5taW5YID0gdGlsZVJhbmdlLm1pblg7XG4gIH1cbiAgaWYgKHRpbGVSYW5nZS5tYXhYID4gdGhpcy5tYXhYKSB7XG4gICAgdGhpcy5tYXhYID0gdGlsZVJhbmdlLm1heFg7XG4gIH1cbiAgaWYgKHRpbGVSYW5nZS5taW5ZIDwgdGhpcy5taW5ZKSB7XG4gICAgdGhpcy5taW5ZID0gdGlsZVJhbmdlLm1pblk7XG4gIH1cbiAgaWYgKHRpbGVSYW5nZS5tYXhZID4gdGhpcy5tYXhZKSB7XG4gICAgdGhpcy5tYXhZID0gdGlsZVJhbmdlLm1heFk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhlaWdodC5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubWF4WSAtIHRoaXMubWluWSArIDE7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gU2l6ZS5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdGhpcy5nZXRXaWR0aCgpLCB0aGlzLmdldEhlaWdodCgpXTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm1heFggLSB0aGlzLm1pblggKyAxO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGVSYW5nZX0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBJbnRlcnNlY3RzLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbih0aWxlUmFuZ2UpIHtcbiAgcmV0dXJuIHRoaXMubWluWCA8PSB0aWxlUmFuZ2UubWF4WCAmJlxuICAgICAgdGhpcy5tYXhYID49IHRpbGVSYW5nZS5taW5YICYmXG4gICAgICB0aGlzLm1pblkgPD0gdGlsZVJhbmdlLm1heFkgJiZcbiAgICAgIHRoaXMubWF4WSA+PSB0aWxlUmFuZ2UubWluWTtcbn07XG5leHBvcnQgZGVmYXVsdCBUaWxlUmFuZ2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZVN0YXRlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIElETEU6IDAsXG4gIExPQURJTkc6IDEsXG4gIExPQURFRDogMixcbiAgRVJST1I6IDMsXG4gIEVNUFRZOiA0LFxuICBBQk9SVDogNVxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9hcnJheVxuICovXG5cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHByb3ZpZGVkIHNvcnRlZCBsaXN0IGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBpZiBmb3VuZC4gSWYgaXQgY2FuJ3QgYmUgZm91bmQgaXQnbGwgcmV0dXJuIC0xLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvYmluYXJ5LXNlYXJjaFxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBoYXlzdGFjayBJdGVtcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSB7Kn0gbmVlZGxlIFRoZSBpdGVtIHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdF9jb21wYXJhdG9yIENvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgaXRlbSBpZiBmb3VuZCwgLTEgaWYgbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIG9wdF9jb21wYXJhdG9yKSB7XG4gIGxldCBtaWQsIGNtcDtcbiAgY29uc3QgY29tcGFyYXRvciA9IG9wdF9jb21wYXJhdG9yIHx8IG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb247XG4gIGxldCBsb3cgPSAwO1xuICBsZXQgaGlnaCA9IGhheXN0YWNrLmxlbmd0aDtcbiAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAvKiBOb3RlIHRoYXQgXCIobG93ICsgaGlnaCkgPj4+IDFcIiBtYXkgb3ZlcmZsb3csIGFuZCByZXN1bHRzIGluIGEgdHlwZWNhc3RcbiAgICAgKiB0byBkb3VibGUgKHdoaWNoIGdpdmVzIHRoZSB3cm9uZyByZXN1bHRzKS4gKi9cbiAgICBtaWQgPSBsb3cgKyAoaGlnaCAtIGxvdyA+PiAxKTtcbiAgICBjbXAgPSArY29tcGFyYXRvcihoYXlzdGFja1ttaWRdLCBuZWVkbGUpO1xuXG4gICAgaWYgKGNtcCA8IDAuMCkgeyAvKiBUb28gbG93LiAqL1xuICAgICAgbG93ICA9IG1pZCArIDE7XG5cbiAgICB9IGVsc2UgeyAvKiBLZXkgZm91bmQgb3IgdG9vIGhpZ2ggKi9cbiAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICBmb3VuZCA9ICFjbXA7XG4gICAgfVxuICB9XG5cbiAgLyogS2V5IG5vdCBmb3VuZC4gKi9cbiAgcmV0dXJuIGZvdW5kID8gbG93IDogfmxvdztcbn1cblxuXG4vKipcbiAqIENvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQgdGhhdCBpcyBzYWZlIGZvciBudW1iZXJzLlxuICogQHBhcmFtIHsqfSBhIFRoZSBmaXJzdCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlciBhcyB0aGUgZmlyc3RcbiAqICAgICBhcmd1bWVudCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG59XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBhcnJheSBjb250YWlucyB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheS48Kj59IGFyciBUaGUgYXJyYXkgdG8gdGVzdCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBvYmogVGhlIG9iamVjdCBmb3Igd2hpY2ggdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBvYmplY3QgaXMgaW4gdGhlIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkZXMoYXJyLCBvYmopIHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG9iaikgPj0gMDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyciBBcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXQgVGFyZ2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiAwIG1lYW5zIHJldHVybiB0aGUgbmVhcmVzdCwgPiAwXG4gKiAgICBtZWFucyByZXR1cm4gdGhlIGxhcmdlc3QgbmVhcmVzdCwgPCAwIG1lYW5zIHJldHVybiB0aGVcbiAqICAgIHNtYWxsZXN0IG5lYXJlc3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyRmluZE5lYXJlc3QoYXJyLCB0YXJnZXQsIGRpcmVjdGlvbikge1xuICBjb25zdCBuID0gYXJyLmxlbmd0aDtcbiAgaWYgKGFyclswXSA8PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmICh0YXJnZXQgPD0gYXJyW24gLSAxXSkge1xuICAgIHJldHVybiBuIC0gMTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgaTtcbiAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoYXJyW2ldIDwgdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGkgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPCAwKSB7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPD0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoYXJyW2ldID09IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKGFycltpXSA8IHRhcmdldCkge1xuICAgICAgICAgIGlmIChhcnJbaSAtIDFdIC0gdGFyZ2V0IDwgdGFyZ2V0IC0gYXJyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbiAtIDE7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBhcnIgQXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gYmVnaW4gQmVnaW4gaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VTdWJBcnJheShhcnIsIGJlZ2luLCBlbmQpIHtcbiAgd2hpbGUgKGJlZ2luIDwgZW5kKSB7XG4gICAgY29uc3QgdG1wID0gYXJyW2JlZ2luXTtcbiAgICBhcnJbYmVnaW5dID0gYXJyW2VuZF07XG4gICAgYXJyW2VuZF0gPSB0bXA7XG4gICAgKytiZWdpbjtcbiAgICAtLWVuZDtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48VkFMVUU+fSBhcnIgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7IUFycmF5LjxWQUxVRT58VkFMVUV9IGRhdGEgVGhlIGVsZW1lbnRzIG9yIGFycmF5cyBvZiBlbGVtZW50cyB0byBhZGQgdG8gYXJyLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoYXJyLCBkYXRhKSB7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW2RhdGFdO1xuICBjb25zdCBsZW5ndGggPSBleHRlbnNpb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2Fyci5sZW5ndGhdID0gZXh0ZW5zaW9uW2ldO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxWQUxVRT59IGFyciBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtWQUxVRX0gb2JqIFRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoYXJyLCBvYmopIHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKG9iaik7XG4gIGNvbnN0IGZvdW5kID0gaSA+IC0xO1xuICBpZiAoZm91bmQpIHtcbiAgICBhcnIuc3BsaWNlKGksIDEpO1xuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPFZBTFVFPn0gYXJyIFRoZSBhcnJheSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFZBTFVFLCBudW1iZXIsID8pIDogYm9vbGVhbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29tcGFyZS5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICogQHJldHVybiB7VkFMVUV8bnVsbH0gVGhlIGVsZW1lbnQgZm91bmQgb3IgbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQoYXJyLCBmdW5jKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGggPj4+IDA7XG4gIGxldCB2YWx1ZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJbaV07XG4gICAgaWYgKGZ1bmModmFsdWUsIGksIGFycikpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fSBhcnIxIFRoZSBmaXJzdCBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheXxVaW50OENsYW1wZWRBcnJheX0gYXJyMiBUaGUgc2Vjb25kIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB0d28gYXJyYXlzIGFyZSBlcXVhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhcnIxLCBhcnIyKSB7XG4gIGNvbnN0IGxlbjEgPSBhcnIxLmxlbmd0aDtcbiAgaWYgKGxlbjEgIT09IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyIFRoZSBhcnJheSB0byBzb3J0IChtb2RpZmllcyBvcmlnaW5hbCkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlRm5jIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFibGVTb3J0KGFyciwgY29tcGFyZUZuYykge1xuICBjb25zdCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICBjb25zdCB0bXAgPSBBcnJheShhcnIubGVuZ3RoKTtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRtcFtpXSA9IHtpbmRleDogaSwgdmFsdWU6IGFycltpXX07XG4gIH1cbiAgdG1wLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlRm5jKGEudmFsdWUsIGIudmFsdWUpIHx8IGEuaW5kZXggLSBiLmluZGV4O1xuICB9KTtcbiAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IHRtcFtpXS52YWx1ZTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48Kj59IGFyciBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gaW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBmdW5jKSB7XG4gIGxldCBpbmRleDtcbiAgY29uc3QgZm91bmQgPSAhYXJyLmV2ZXJ5KGZ1bmN0aW9uKGVsLCBpZHgpIHtcbiAgICBpbmRleCA9IGlkeDtcbiAgICByZXR1cm4gIWZ1bmMoZWwsIGlkeCwgYXJyKTtcbiAgfSk7XG4gIHJldHVybiBmb3VuZCA/IGluZGV4IDogLTE7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyIFRoZSBhcnJheSB0byB0ZXN0LlxuICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdF9mdW5jIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc3RyaWN0IFN0cmljdGx5IHNvcnRlZCAoZGVmYXVsdCBmYWxzZSkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm4gaW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NvcnRlZChhcnIsIG9wdF9mdW5jLCBvcHRfc3RyaWN0KSB7XG4gIGNvbnN0IGNvbXBhcmUgPSBvcHRfZnVuYyB8fCBudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9uO1xuICByZXR1cm4gYXJyLmV2ZXJ5KGZ1bmN0aW9uKGN1cnJlbnRWYWwsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gY29tcGFyZShhcnJbaW5kZXggLSAxXSwgY3VycmVudFZhbCk7XG4gICAgcmV0dXJuICEocmVzID4gMCB8fCBvcHRfc3RyaWN0ICYmIHJlcyA9PT0gMCk7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Fzc2VydHNcbiAqL1xuaW1wb3J0IEFzc2VydGlvbkVycm9yIGZyb20gJy4vQXNzZXJ0aW9uRXJyb3IuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYXNzZXJ0aW9uIEFzc2VydGlvbiB3ZSBleHBlY3RlZCB0byBiZSB0cnV0aHkuXG4gKiBAcGFyYW0ge251bWJlcn0gZXJyb3JDb2RlIEVycm9yIGNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoYXNzZXJ0aW9uLCBlcnJvckNvZGUpIHtcbiAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JDb2RlKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2RvbVxuICovXG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gaHRtbCBjYW52YXMgZWxlbWVudCBhbmQgcmV0dXJucyBpdHMgMmQgY29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3dpZHRoIENhbnZhcyB3aWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2hlaWdodCBDYW52YXMgaGVpZ2h0LlxuICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0NvbnRleHQyRChvcHRfd2lkdGgsIG9wdF9oZWlnaHQpIHtcbiAgY29uc3QgY2FudmFzID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpKTtcbiAgaWYgKG9wdF93aWR0aCkge1xuICAgIGNhbnZhcy53aWR0aCA9IG9wdF93aWR0aDtcbiAgfVxuICBpZiAob3B0X2hlaWdodCkge1xuICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRfaGVpZ2h0O1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi8gKGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBjb21wdXRlZCB3aWR0aCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVyV2lkdGgodHJ1ZSlgLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBFbGVtZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgd2lkdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlcldpZHRoKGVsZW1lbnQpIHtcbiAgbGV0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB3aWR0aCArPSBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0LCAxMCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCwgMTApO1xuXG4gIHJldHVybiB3aWR0aDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBjb21wdXRlZCBoZWlnaHQgZm9yIHRoZSBnaXZlbiBlbGVtZW50IGluY2x1ZGluZyBtYXJnaW4sXG4gKiBwYWRkaW5nIGFuZCBib3JkZXIuXG4gKiBFcXVpdmFsZW50IHRvIGpRdWVyeSdzIGAkKGVsKS5vdXRlckhlaWdodCh0cnVlKWAuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlckhlaWdodChlbGVtZW50KSB7XG4gIGxldCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBoZWlnaHQgKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luVG9wLCAxMCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20sIDEwKTtcblxuICByZXR1cm4gaGVpZ2h0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbmV3Tm9kZSBOb2RlIHRvIHJlcGxhY2Ugb2xkIG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gb2xkTm9kZSBUaGUgbm9kZSB0byBiZSByZXBsYWNlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU5vZGUobmV3Tm9kZSwgb2xkTm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBvbGROb2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVwbGFjZUNoaWxkKG5ld05vZGUsIG9sZE5vZGUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtOb2RlfSBUaGUgbm9kZSB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlID8gbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlIHRoZSBjaGlsZHJlbiBmcm9tLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4obm9kZSkge1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Vhc2luZ1xuICovXG5cblxuLyoqXG4gKiBTdGFydCBzbG93IGFuZCBzcGVlZCB1cC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhc2VJbih0KSB7XG4gIHJldHVybiBNYXRoLnBvdyh0LCAzKTtcbn1cblxuXG4vKipcbiAqIFN0YXJ0IGZhc3QgYW5kIHNsb3cgZG93bi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhc2VPdXQodCkge1xuICByZXR1cm4gMSAtIGVhc2VJbigxIC0gdCk7XG59XG5cblxuLyoqXG4gKiBTdGFydCBzbG93LCBzcGVlZCB1cCwgYW5kIHRoZW4gc2xvdyBkb3duIGFnYWluLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5BbmRPdXQodCkge1xuICByZXR1cm4gMyAqIHQgKiB0IC0gMiAqIHQgKiB0ICogdDtcbn1cblxuXG4vKipcbiAqIE1haW50YWluIGEgY29uc3RhbnQgc3BlZWQgb3ZlciB0aW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuIHQ7XG59XG5cblxuLyoqXG4gKiBTdGFydCBzbG93LCBzcGVlZCB1cCwgYW5kIGF0IHRoZSB2ZXJ5IGVuZCBzbG93IGRvd24gYWdhaW4uICBUaGlzIGhhcyB0aGVcbiAqIHNhbWUgZ2VuZXJhbCBiZWhhdmlvciBhcyB7QGxpbmsgbW9kdWxlOm9sL2Vhc2luZ35pbkFuZE91dH0sIGJ1dCB0aGUgZmluYWxcbiAqIHNsb3dkb3duIGlzIGRlbGF5ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cEFuZERvd24odCkge1xuICBpZiAodCA8IDAuNSkge1xuICAgIHJldHVybiBpbkFuZE91dCgyICogdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDEgLSBpbkFuZE91dCgyICogKHQgLSAwLjUpKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50c1xuICovXG5pbXBvcnQge2NsZWFyfSBmcm9tICcuL29iai5qcyc7XG5cblxuLyoqXG4gKiBLZXkgdG8gdXNlIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9PYnNlcnZhYmxlfk9ic2VydmFibGUjdW5CeUtleX0uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmVudHNLZXlcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbYmluZFRvXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb259IFtib3VuZExpc3RlbmVyXVxuICogQHByb3BlcnR5IHtib29sZWFufSBjYWxsT25jZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWxldGVJbmRleF1cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lclxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldHxtb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIExpc3RlbmVyIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFuIGV2ZW50IG9iamVjdCBhcyBhcmd1bWVudC5cbiAqIFdoZW4gdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgZXZlbnQgcHJvcGFnYXRpb24gd2lsbCBzdG9wLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihtb2R1bGU6b2wvZXZlbnRzL0V2ZW50KXxmdW5jdGlvbihtb2R1bGU6b2wvZXZlbnRzL0V2ZW50KTogYm9vbGVhbn0gTGlzdGVuZXJGdW5jdGlvblxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fSBsaXN0ZW5lck9iaiBMaXN0ZW5lciBvYmplY3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb259IEJvdW5kIGxpc3RlbmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZExpc3RlbmVyKGxpc3RlbmVyT2JqKSB7XG4gIGNvbnN0IGJvdW5kTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVyT2JqLmxpc3RlbmVyO1xuICAgIGNvbnN0IGJpbmRUbyA9IGxpc3RlbmVyT2JqLmJpbmRUbyB8fCBsaXN0ZW5lck9iai50YXJnZXQ7XG4gICAgaWYgKGxpc3RlbmVyT2JqLmNhbGxPbmNlKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KGxpc3RlbmVyT2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyLmNhbGwoYmluZFRvLCBldnQpO1xuICB9O1xuICBsaXN0ZW5lck9iai5ib3VuZExpc3RlbmVyID0gYm91bmRMaXN0ZW5lcjtcbiAgcmV0dXJuIGJvdW5kTGlzdGVuZXI7XG59XG5cblxuLyoqXG4gKiBGaW5kcyB0aGUgbWF0Y2hpbmcge0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fSBpbiB0aGUgZ2l2ZW4gbGlzdGVuZXJcbiAqIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7IUFycmF5PCFtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT59IGxpc3RlbmVycyBBcnJheSBvZiBsaXN0ZW5lcnMuXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfdGhpcyBUaGUgYHRoaXNgIHZhbHVlIGluc2lkZSB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc2V0RGVsZXRlSW5kZXggU2V0IHRoZSBkZWxldGVJbmRleCBvbiB0aGUgbWF0Y2hpbmdcbiAqICAgICBsaXN0ZW5lciwgZm9yIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfnVubGlzdGVuQnlLZXl9LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl8dW5kZWZpbmVkfSBUaGUgbWF0Y2hpbmcgbGlzdGVuZXIgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExpc3RlbmVyKGxpc3RlbmVycywgbGlzdGVuZXIsIG9wdF90aGlzLCBvcHRfc2V0RGVsZXRlSW5kZXgpIHtcbiAgbGV0IGxpc3RlbmVyT2JqO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGxpc3RlbmVyT2JqID0gbGlzdGVuZXJzW2ldO1xuICAgIGlmIChsaXN0ZW5lck9iai5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiZcbiAgICAgICAgbGlzdGVuZXJPYmouYmluZFRvID09PSBvcHRfdGhpcykge1xuICAgICAgaWYgKG9wdF9zZXREZWxldGVJbmRleCkge1xuICAgICAgICBsaXN0ZW5lck9iai5kZWxldGVJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdGVuZXJPYmo7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR+RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT58dW5kZWZpbmVkfSBMaXN0ZW5lcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlKSB7XG4gIGNvbnN0IGxpc3RlbmVyTWFwID0gdGFyZ2V0Lm9sX2xtO1xuICByZXR1cm4gbGlzdGVuZXJNYXAgPyBsaXN0ZW5lck1hcFt0eXBlXSA6IHVuZGVmaW5lZDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgbG9va3VwIG9mIGxpc3RlbmVycy4gIElmIG9uZSBkb2VzIG5vdCBleGlzdCBvbiB0aGUgdGFyZ2V0LCBpdCBpc1xuICogY3JlYXRlZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKiBAcmV0dXJuIHshT2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT4+fSBNYXAgb2ZcbiAqICAgICBsaXN0ZW5lcnMgYnkgZXZlbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXJNYXAodGFyZ2V0KSB7XG4gIGxldCBsaXN0ZW5lck1hcCA9IHRhcmdldC5vbF9sbTtcbiAgaWYgKCFsaXN0ZW5lck1hcCkge1xuICAgIGxpc3RlbmVyTWFwID0gdGFyZ2V0Lm9sX2xtID0ge307XG4gIH1cbiAgcmV0dXJuIGxpc3RlbmVyTWFwO1xufVxuXG5cbi8qKlxuICogQ2xlYW4gdXAgYWxsIGxpc3RlbmVyIG9iamVjdHMgb2YgdGhlIGdpdmVuIHR5cGUuICBBbGwgcHJvcGVydGllcyBvbiB0aGVcbiAqIGxpc3RlbmVyIG9iamVjdHMgd2lsbCBiZSByZW1vdmVkLCBhbmQgaWYgbm8gbGlzdGVuZXJzIHJlbWFpbiBpbiB0aGUgbGlzdGVuZXJcbiAqIG1hcCwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHRhcmdldC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICovXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnModGFyZ2V0LCB0eXBlKSB7XG4gIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0YXJnZXQsIHR5cGUpO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXS5ib3VuZExpc3RlbmVyKTtcbiAgICAgIGNsZWFyKGxpc3RlbmVyc1tpXSk7XG4gICAgfVxuICAgIGxpc3RlbmVycy5sZW5ndGggPSAwO1xuICAgIGNvbnN0IGxpc3RlbmVyTWFwID0gdGFyZ2V0Lm9sX2xtO1xuICAgIGlmIChsaXN0ZW5lck1hcCkge1xuICAgICAgZGVsZXRlIGxpc3RlbmVyTWFwW3R5cGVdO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGxpc3RlbmVyTWFwKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldC5vbF9sbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiB7QGxpbmsgaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sfVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIHRvIGEgYHRoaXNgIG9iamVjdCwgYW5kIHJldHVybnNcbiAqIGEga2V5IGZvciB1c2Ugd2l0aCB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c351bmxpc3RlbkJ5S2V5fS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR+RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3RoaXMgT2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIGB0aGlzYCBrZXl3b3JkIGluIHRoZVxuICogICAgIGxpc3RlbmVyLiBEZWZhdWx0IGlzIHRoZSBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9vbmNlIElmIHRydWUsIGFkZCB0aGUgbGlzdGVuZXIgYXMgb25lLW9mZiBsaXN0ZW5lci5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fSBVbmlxdWUga2V5IGZvciB0aGUgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0X3RoaXMsIG9wdF9vbmNlKSB7XG4gIGNvbnN0IGxpc3RlbmVyTWFwID0gZ2V0TGlzdGVuZXJNYXAodGFyZ2V0KTtcbiAgbGV0IGxpc3RlbmVycyA9IGxpc3RlbmVyTWFwW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVyTWFwW3R5cGVdID0gW107XG4gIH1cbiAgbGV0IGxpc3RlbmVyT2JqID0gZmluZExpc3RlbmVyKGxpc3RlbmVycywgbGlzdGVuZXIsIG9wdF90aGlzLCBmYWxzZSk7XG4gIGlmIChsaXN0ZW5lck9iaikge1xuICAgIGlmICghb3B0X29uY2UpIHtcbiAgICAgIC8vIFR1cm4gb25lLW9mZiBsaXN0ZW5lciBpbnRvIGEgcGVybWFuZW50IG9uZS5cbiAgICAgIGxpc3RlbmVyT2JqLmNhbGxPbmNlID0gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxpc3RlbmVyT2JqID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleX0gKi8gKHtcbiAgICAgIGJpbmRUbzogb3B0X3RoaXMsXG4gICAgICBjYWxsT25jZTogISFvcHRfb25jZSxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgdHlwZTogdHlwZVxuICAgIH0pO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGJpbmRMaXN0ZW5lcihsaXN0ZW5lck9iaikpO1xuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyT2JqKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lck9iajtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIG9uZS1vZmYgZXZlbnQgbGlzdGVuZXIgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICoge0BsaW5rIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbH1cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGVmZmljaWVudGx5IGJpbmRzIGEgYGxpc3RlbmVyYCBhcyBzZWxmLXVucmVnaXN0ZXJpbmcgbGlzdGVuZXJcbiAqIHRvIGEgYHRoaXNgIG9iamVjdCwgYW5kIHJldHVybnMgYSBrZXkgZm9yIHVzZSB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c351bmxpc3RlbkJ5S2V5fSBpbiBjYXNlIHRoZSBsaXN0ZW5lciBuZWVkcyB0byBiZVxuICogdW5yZWdpc3RlcmVkIGJlZm9yZSBpdCBpcyBjYWxsZWQuXG4gKlxuICogV2hlbiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c35saXN0ZW59IGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cyBhZnRlciB0aGlzXG4gKiBmdW5jdGlvbiwgdGhlIHNlbGYtdW5yZWdpc3RlcmluZyBsaXN0ZW5lciB3aWxsIGJlIHR1cm5lZCBpbnRvIGEgcGVybWFuZW50XG4gKiBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR+RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3RoaXMgT2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIGB0aGlzYCBrZXl3b3JkIGluIHRoZVxuICogICAgIGxpc3RlbmVyLiBEZWZhdWx0IGlzIHRoZSBgdGFyZ2V0YC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fSBLZXkgZm9yIHVubGlzdGVuQnlLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5PbmNlKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdF90aGlzKSB7XG4gIHJldHVybiBsaXN0ZW4odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0X3RoaXMsIHRydWUpO1xufVxuXG5cbi8qKlxuICogVW5yZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICoge0BsaW5rIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbH1cbiAqXG4gKiBUbyByZXR1cm4gYSBsaXN0ZW5lciwgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZXhhY3Qgc2FtZVxuICogYXJndW1lbnRzIHRoYXQgd2VyZSB1c2VkIGZvciBhIHByZXZpb3VzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbn0gY2FsbC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR+RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3RoaXMgT2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIGB0aGlzYCBrZXl3b3JkIGluIHRoZVxuICogICAgIGxpc3RlbmVyLiBEZWZhdWx0IGlzIHRoZSBgdGFyZ2V0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdF90aGlzKSB7XG4gIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0YXJnZXQsIHR5cGUpO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgY29uc3QgbGlzdGVuZXJPYmogPSBmaW5kTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lciwgb3B0X3RoaXMsIHRydWUpO1xuICAgIGlmIChsaXN0ZW5lck9iaikge1xuICAgICAgdW5saXN0ZW5CeUtleShsaXN0ZW5lck9iaik7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICoge0BsaW5rIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbH1cbiAqXG4gKiBUaGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gaXMgdGhlIGtleSByZXR1cm5lZCBmcm9tXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c35saXN0ZW59IG9yIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbk9uY2V9LlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9IGtleSBUaGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5CeUtleShrZXkpIHtcbiAgaWYgKGtleSAmJiBrZXkudGFyZ2V0KSB7XG4gICAga2V5LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGtleS50eXBlLCBrZXkuYm91bmRMaXN0ZW5lcik7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKGtleS50YXJnZXQsIGtleS50eXBlKTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBjb25zdCBpID0gJ2RlbGV0ZUluZGV4JyBpbiBrZXkgPyBrZXkuZGVsZXRlSW5kZXggOiBsaXN0ZW5lcnMuaW5kZXhPZihrZXkpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcnMoa2V5LnRhcmdldCwga2V5LnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjbGVhcihrZXkpO1xuICB9XG59XG5cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBhbGwgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIHtAbGluayBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWx9XG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRhcmdldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQWxsKHRhcmdldCkge1xuICBjb25zdCBsaXN0ZW5lck1hcCA9IGdldExpc3RlbmVyTWFwKHRhcmdldCk7XG4gIGZvciAoY29uc3QgdHlwZSBpbiBsaXN0ZW5lck1hcCkge1xuICAgIHJlbW92ZUxpc3RlbmVycyh0YXJnZXQsIHR5cGUpO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0V2ZW50XG4gKi9cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU3RyaXBwZWQgZG93biBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgVzNDIERPTSBMZXZlbCAyIEV2ZW50IGludGVyZmFjZS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLWludGVyZmFjZX1cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9ubHkgcHJvdmlkZXMgYHR5cGVgIGFuZCBgdGFyZ2V0YCBwcm9wZXJ0aWVzLCBhbmRcbiAqIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIG1ldGhvZHMuIEl0IGlzIG1lYW50IGFzIGJhc2UgY2xhc3NcbiAqIGZvciBoaWdoZXIgbGV2ZWwgZXZlbnRzIGRlZmluZWQgaW4gdGhlIGxpYnJhcnksIGFuZCB3b3JrcyB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldH0uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICovXG5jb25zdCBFdmVudCA9IGZ1bmN0aW9uKHR5cGUpIHtcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZDtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBhcGlcbiAgICovXG4gIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0YXJnZXQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBhcGlcbiAgICovXG4gIHRoaXMudGFyZ2V0ID0gbnVsbDtcblxufTtcblxuXG4vKipcbiAqIFN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gKiBAZnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID1cblxuICAvKipcbiAgICogU3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhcGlcbiAgICovXG4gIEV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH07XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fG1vZHVsZTpvbC9ldmVudHMvRXZlbnR9IGV2dCBFdmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2dCkge1xuICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fG1vZHVsZTpvbC9ldmVudHMvRXZlbnR9IGV2dCBFdmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZ0KSB7XG4gIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRUYXJnZXRcbiAqL1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IERpc3Bvc2FibGUgZnJvbSAnLi4vRGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQge3VubGlzdGVuQWxsfSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IHtVTkRFRklORUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtFdmVudFRhcmdldHxtb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fSBFdmVudFRhcmdldExpa2VcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnRUYXJnZXQgaW50ZXJmYWNlLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDAvUkVDLURPTS1MZXZlbC0yLUV2ZW50cy0yMDAwMTExMy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXR9XG4gKlxuICogVGhlcmUgYXJlIHR3byBpbXBvcnRhbnQgc2ltcGxpZmljYXRpb25zIGNvbXBhcmVkIHRvIHRoZSBzcGVjaWZpY2F0aW9uOlxuICpcbiAqIDEuIFRoZSBoYW5kbGluZyBvZiBgdXNlQ2FwdHVyZWAgaW4gYGFkZEV2ZW50TGlzdGVuZXJgIGFuZFxuICogICAgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLiBUaGVyZSBpcyBubyByZWFsIGNhcHR1cmUgbW9kZWwuXG4gKiAyLiBUaGUgaGFuZGxpbmcgb2YgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgb24gYGRpc3BhdGNoRXZlbnRgLlxuICogICAgVGhlcmUgaXMgbm8gZXZlbnQgdGFyZ2V0IGhpZXJhcmNoeS4gV2hlbiBhIGxpc3RlbmVyIGNhbGxzXG4gKiAgICBgc3RvcFByb3BhZ2F0aW9uYCBvciBgcHJldmVudERlZmF1bHRgIG9uIGFuIGV2ZW50IG9iamVjdCwgaXQgbWVhbnMgdGhhdCBub1xuICogICAgbW9yZSBsaXN0ZW5lcnMgYWZ0ZXIgdGhpcyBvbmUgd2lsbCBiZSBjYWxsZWQuIFNhbWUgYXMgd2hlbiB0aGUgbGlzdGVuZXJcbiAqICAgIHJldHVybnMgZmFsc2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL0Rpc3Bvc2FibGV9XG4gKi9cbmNvbnN0IEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG5cbiAgRGlzcG9zYWJsZS5jYWxsKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBudW1iZXI+fVxuICAgKi9cbiAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfID0ge307XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gICAqL1xuICB0aGlzLmRpc3BhdGNoaW5nXyA9IHt9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBBcnJheS48bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9uPj59XG4gICAqL1xuICB0aGlzLmxpc3RlbmVyc18gPSB7fTtcblxufTtcblxuaW5oZXJpdHMoRXZlbnRUYXJnZXQsIERpc3Bvc2FibGUpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBsZXQgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1t0eXBlXSA9IFtdO1xuICB9XG4gIGlmIChsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHt7dHlwZTogc3RyaW5nLFxuICogICAgIHRhcmdldDogKEV2ZW50VGFyZ2V0fG1vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR8dW5kZWZpbmVkKX18bW9kdWxlOm9sL2V2ZW50cy9FdmVudHxcbiAqICAgICBzdHJpbmd9IGV2ZW50IEV2ZW50IG9yIGV2ZW50IHR5cGUuXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gYGZhbHNlYCBpZiBhbnlvbmUgY2FsbGVkIHByZXZlbnREZWZhdWx0IG9uIHRoZVxuICogICAgIGV2ZW50IG9iamVjdCBvciBpZiBhbnkgb2YgdGhlIGxpc3RlbmVycyByZXR1cm5lZCBmYWxzZS5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICBjb25zdCBldnQgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnID8gbmV3IEV2ZW50KGV2ZW50KSA6IGV2ZW50O1xuICBjb25zdCB0eXBlID0gZXZ0LnR5cGU7XG4gIGV2dC50YXJnZXQgPSB0aGlzO1xuICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gIGxldCBwcm9wYWdhdGU7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICBpZiAoISh0eXBlIGluIHRoaXMuZGlzcGF0Y2hpbmdfKSkge1xuICAgICAgdGhpcy5kaXNwYXRjaGluZ19bdHlwZV0gPSAwO1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfW3R5cGVdID0gMDtcbiAgICB9XG4gICAgKyt0aGlzLmRpc3BhdGNoaW5nX1t0eXBlXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5jYWxsKHRoaXMsIGV2dCkgPT09IGZhbHNlIHx8IGV2dC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgICAgcHJvcGFnYXRlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAtLXRoaXMuZGlzcGF0Y2hpbmdfW3R5cGVdO1xuICAgIGlmICh0aGlzLmRpc3BhdGNoaW5nX1t0eXBlXSA9PT0gMCkge1xuICAgICAgbGV0IHBlbmRpbmdSZW1vdmFscyA9IHRoaXMucGVuZGluZ1JlbW92YWxzX1t0eXBlXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZW1vdmFsc19bdHlwZV07XG4gICAgICB3aGlsZSAocGVuZGluZ1JlbW92YWxzLS0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIFVOREVGSU5FRCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5kaXNwYXRjaGluZ19bdHlwZV07XG4gICAgfVxuICAgIHJldHVybiBwcm9wYWdhdGU7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24oKSB7XG4gIHVubGlzdGVuQWxsKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmllZCBldmVudCB0eXBlLiBMaXN0ZW5lcnMgYXJlIHJldHVybmVkIGluIHRoZVxuICogb3JkZXIgdGhhdCB0aGV5IHdpbGwgYmUgY2FsbGVkIGluLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9uPn0gTGlzdGVuZXJzLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZ2V0TGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICByZXR1cm4gdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3R5cGUgVHlwZS4gSWYgbm90IHByb3ZpZGVkLFxuICogICAgIGB0cnVlYCB3aWxsIGJlIHJldHVybmVkIGlmIHRoaXMgRXZlbnRUYXJnZXQgaGFzIGFueSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJuIHtib29sZWFufSBIYXMgbGlzdGVuZXJzLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuaGFzTGlzdGVuZXIgPSBmdW5jdGlvbihvcHRfdHlwZSkge1xuICByZXR1cm4gb3B0X3R5cGUgP1xuICAgIG9wdF90eXBlIGluIHRoaXMubGlzdGVuZXJzXyA6XG4gICAgT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnNfKS5sZW5ndGggPiAwO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHN+TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKHR5cGUgaW4gdGhpcy5wZW5kaW5nUmVtb3ZhbHNfKSB7XG4gICAgICAvLyBtYWtlIGxpc3RlbmVyIGEgbm8tb3AsIGFuZCByZW1vdmUgbGF0ZXIgaW4gI2Rpc3BhdGNoRXZlbnQoKVxuICAgICAgbGlzdGVuZXJzW2luZGV4XSA9IFVOREVGSU5FRDtcbiAgICAgICsrdGhpcy5wZW5kaW5nUmVtb3ZhbHNfW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgRXZlbnRUYXJnZXQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBHZW5lcmljIGNoYW5nZSBldmVudC4gVHJpZ2dlcmVkIHdoZW4gdGhlIHJldmlzaW9uIGNvdW50ZXIgaXMgaW5jcmVhc2VkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL2V2ZW50cy9FdmVudH5FdmVudCNjaGFuZ2VcbiAgICogQGFwaVxuICAgKi9cbiAgQ0hBTkdFOiAnY2hhbmdlJyxcblxuICBDTEVBUjogJ2NsZWFyJyxcbiAgQ09OVEVYVE1FTlU6ICdjb250ZXh0bWVudScsXG4gIENMSUNLOiAnY2xpY2snLFxuICBEQkxDTElDSzogJ2RibGNsaWNrJyxcbiAgRFJBR0VOVEVSOiAnZHJhZ2VudGVyJyxcbiAgRFJBR09WRVI6ICdkcmFnb3ZlcicsXG4gIERST1A6ICdkcm9wJyxcbiAgRVJST1I6ICdlcnJvcicsXG4gIEtFWURPV046ICdrZXlkb3duJyxcbiAgS0VZUFJFU1M6ICdrZXlwcmVzcycsXG4gIExPQUQ6ICdsb2FkJyxcbiAgTU9VU0VET1dOOiAnbW91c2Vkb3duJyxcbiAgTU9VU0VNT1ZFOiAnbW91c2Vtb3ZlJyxcbiAgTU9VU0VPVVQ6ICdtb3VzZW91dCcsXG4gIE1PVVNFVVA6ICdtb3VzZXVwJyxcbiAgTU9VU0VXSEVFTDogJ21vdXNld2hlZWwnLFxuICBNU1BPSU5URVJET1dOOiAnTVNQb2ludGVyRG93bicsXG4gIFJFU0laRTogJ3Jlc2l6ZScsXG4gIFRPVUNIU1RBUlQ6ICd0b3VjaHN0YXJ0JyxcbiAgVE9VQ0hNT1ZFOiAndG91Y2htb3ZlJyxcbiAgVE9VQ0hFTkQ6ICd0b3VjaGVuZCcsXG4gIFdIRUVMOiAnd2hlZWwnXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudFxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCBDb3JuZXIgZnJvbSAnLi9leHRlbnQvQ29ybmVyLmpzJztcbmltcG9ydCBSZWxhdGlvbnNoaXAgZnJvbSAnLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzJztcblxuXG4vKipcbiAqIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGFuIGV4dGVudDogYFttaW54LCBtaW55LCBtYXh4LCBtYXh5XWAuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPG51bWJlcj59IEV4dGVudFxuICogQGFwaVxuICovXG5cbi8qKlxuICogQnVpbGQgYW4gZXh0ZW50IHRoYXQgaW5jbHVkZXMgYWxsIGdpdmVuIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBCb3VuZGluZyBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuZGluZ0V4dGVudChjb29yZGluYXRlcykge1xuICBjb25zdCBleHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0geHMgWHMuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB5cyBZcy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5mdW5jdGlvbiBfYm91bmRpbmdFeHRlbnRYWXMoeHMsIHlzLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IG1pblggPSBNYXRoLm1pbi5hcHBseShudWxsLCB4cyk7XG4gIGNvbnN0IG1pblkgPSBNYXRoLm1pbi5hcHBseShudWxsLCB5cyk7XG4gIGNvbnN0IG1heFggPSBNYXRoLm1heC5hcHBseShudWxsLCB4cyk7XG4gIGNvbnN0IG1heFkgPSBNYXRoLm1heC5hcHBseShudWxsLCB5cyk7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIFJldHVybiBleHRlbnQgaW5jcmVhc2VkIGJ5IHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGFtb3VudCBieSB3aGljaCB0aGUgZXh0ZW50IHNob3VsZCBiZSBidWZmZXJlZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoZXh0ZW50LCB2YWx1ZSwgb3B0X2V4dGVudCkge1xuICBpZiAob3B0X2V4dGVudCkge1xuICAgIG9wdF9leHRlbnRbMF0gPSBleHRlbnRbMF0gLSB2YWx1ZTtcbiAgICBvcHRfZXh0ZW50WzFdID0gZXh0ZW50WzFdIC0gdmFsdWU7XG4gICAgb3B0X2V4dGVudFsyXSA9IGV4dGVudFsyXSArIHZhbHVlO1xuICAgIG9wdF9leHRlbnRbM10gPSBleHRlbnRbM10gKyB2YWx1ZTtcbiAgICByZXR1cm4gb3B0X2V4dGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW1xuICAgICAgZXh0ZW50WzBdIC0gdmFsdWUsXG4gICAgICBleHRlbnRbMV0gLSB2YWx1ZSxcbiAgICAgIGV4dGVudFsyXSArIHZhbHVlLFxuICAgICAgZXh0ZW50WzNdICsgdmFsdWVcbiAgICBdO1xuICB9XG59XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYW4gZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gVGhlIGNsb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoZXh0ZW50LCBvcHRfZXh0ZW50KSB7XG4gIGlmIChvcHRfZXh0ZW50KSB7XG4gICAgb3B0X2V4dGVudFswXSA9IGV4dGVudFswXTtcbiAgICBvcHRfZXh0ZW50WzFdID0gZXh0ZW50WzFdO1xuICAgIG9wdF9leHRlbnRbMl0gPSBleHRlbnRbMl07XG4gICAgb3B0X2V4dGVudFszXSA9IGV4dGVudFszXTtcbiAgICByZXR1cm4gb3B0X2V4dGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXh0ZW50LnNsaWNlKCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge251bWJlcn0gQ2xvc2VzdCBzcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKGV4dGVudCwgeCwgeSkge1xuICBsZXQgZHgsIGR5O1xuICBpZiAoeCA8IGV4dGVudFswXSkge1xuICAgIGR4ID0gZXh0ZW50WzBdIC0geDtcbiAgfSBlbHNlIGlmIChleHRlbnRbMl0gPCB4KSB7XG4gICAgZHggPSB4IC0gZXh0ZW50WzJdO1xuICB9IGVsc2Uge1xuICAgIGR4ID0gMDtcbiAgfVxuICBpZiAoeSA8IGV4dGVudFsxXSkge1xuICAgIGR5ID0gZXh0ZW50WzFdIC0geTtcbiAgfSBlbHNlIGlmIChleHRlbnRbM10gPCB5KSB7XG4gICAgZHkgPSB5IC0gZXh0ZW50WzNdO1xuICB9IGVsc2Uge1xuICAgIGR5ID0gMDtcbiAgfVxuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSBleHRlbnQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIGluIHRoZSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0Nvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlKSB7XG4gIHJldHVybiBjb250YWluc1hZKGV4dGVudCwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSk7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiBvbmUgZXh0ZW50IGNvbnRhaW5zIGFub3RoZXIuXG4gKlxuICogQW4gZXh0ZW50IGlzIGRlZW1lZCBjb250YWluZWQgaWYgaXQgbGllcyBjb21wbGV0ZWx5IHdpdGhpbiB0aGUgb3RoZXIgZXh0ZW50LFxuICogaW5jbHVkaW5nIGlmIHRoZXkgc2hhcmUgb25lIG9yIG1vcmUgZWRnZXMuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc2Vjb25kIGV4dGVudCBpcyBjb250YWluZWQgYnkgb3Igb24gdGhlIGVkZ2Ugb2YgdGhlXG4gKiAgICAgZmlyc3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0V4dGVudChleHRlbnQxLCBleHRlbnQyKSB7XG4gIHJldHVybiBleHRlbnQxWzBdIDw9IGV4dGVudDJbMF0gJiYgZXh0ZW50MlsyXSA8PSBleHRlbnQxWzJdICYmXG4gICAgICBleHRlbnQxWzFdIDw9IGV4dGVudDJbMV0gJiYgZXh0ZW50MlszXSA8PSBleHRlbnQxWzNdO1xufVxuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBjb29yZGluYXRlIGlzIGNvbnRhaW5lZCBvciBvbiB0aGUgZWRnZSBvZiB0aGUgZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBZIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgeCwgeSB2YWx1ZXMgYXJlIGNvbnRhaW5lZCBpbiB0aGUgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNYWShleHRlbnQsIHgsIHkpIHtcbiAgcmV0dXJuIGV4dGVudFswXSA8PSB4ICYmIHggPD0gZXh0ZW50WzJdICYmIGV4dGVudFsxXSA8PSB5ICYmIHkgPD0gZXh0ZW50WzNdO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBhIGNvb3JkaW5hdGUgYW5kIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudC9SZWxhdGlvbnNoaXB9IFRoZSByZWxhdGlvbnNoaXAgKGJpdHdpc2UgY29tcGFyZSB3aXRoXG4gKiAgICAgbW9kdWxlOm9sL2V4dGVudC9SZWxhdGlvbnNoaXB+UmVsYXRpb25zaGlwKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBjb29yZGluYXRlKSB7XG4gIGNvbnN0IG1pblggPSBleHRlbnRbMF07XG4gIGNvbnN0IG1pblkgPSBleHRlbnRbMV07XG4gIGNvbnN0IG1heFggPSBleHRlbnRbMl07XG4gIGNvbnN0IG1heFkgPSBleHRlbnRbM107XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgbGV0IHJlbGF0aW9uc2hpcCA9IFJlbGF0aW9uc2hpcC5VTktOT1dOO1xuICBpZiAoeCA8IG1pblgpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuTEVGVDtcbiAgfSBlbHNlIGlmICh4ID4gbWF4WCkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5SSUdIVDtcbiAgfVxuICBpZiAoeSA8IG1pblkpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuQkVMT1c7XG4gIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuQUJPVkU7XG4gIH1cbiAgaWYgKHJlbGF0aW9uc2hpcCA9PT0gUmVsYXRpb25zaGlwLlVOS05PV04pIHtcbiAgICByZWxhdGlvbnNoaXAgPSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HO1xuICB9XG4gIHJldHVybiByZWxhdGlvbnNoaXA7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gZW1wdHkgZXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEVtcHR5IGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5KCkge1xuICByZXR1cm4gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV4dGVudCBvciB1cGRhdGUgdGhlIHByb3ZpZGVkIGV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIE1pbmltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIE1pbmltdW0gWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIE1heGltdW0gWS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBvcHRfZXh0ZW50KSB7XG4gIGlmIChvcHRfZXh0ZW50KSB7XG4gICAgb3B0X2V4dGVudFswXSA9IG1pblg7XG4gICAgb3B0X2V4dGVudFsxXSA9IG1pblk7XG4gICAgb3B0X2V4dGVudFsyXSA9IG1heFg7XG4gICAgb3B0X2V4dGVudFszXSA9IG1heFk7XG4gICAgcmV0dXJuIG9wdF9leHRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVtcHR5IGV4dGVudCBvciBtYWtlIHRoZSBwcm92aWRlZCBvbmUgZW1wdHkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVFbXB0eShvcHRfZXh0ZW50KSB7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICBJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5LCBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgb3B0X2V4dGVudCkge1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV07XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZSh4LCB5LCB4LCB5LCBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlcyhjb29yZGluYXRlcywgb3B0X2V4dGVudCkge1xuICBjb25zdCBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUVtcHR5KG9wdF9leHRlbnQpO1xuICByZXR1cm4gZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCBjb29yZGluYXRlcyk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkob3B0X2V4dGVudCk7XG4gIHJldHVybiBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPj59IHJpbmdzIFJpbmdzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbVJpbmdzKHJpbmdzLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkob3B0X2V4dGVudCk7XG4gIHJldHVybiBleHRlbmRSaW5ncyhleHRlbnQsIHJpbmdzKTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZSBpZiB0d28gZXh0ZW50cyBhcmUgZXF1aXZhbGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBleHRlbnRzIGFyZSBlcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIGV4dGVudDFbMF0gPT0gZXh0ZW50MlswXSAmJiBleHRlbnQxWzJdID09IGV4dGVudDJbMl0gJiZcbiAgICAgIGV4dGVudDFbMV0gPT0gZXh0ZW50MlsxXSAmJiBleHRlbnQxWzNdID09IGV4dGVudDJbM107XG59XG5cblxuLyoqXG4gKiBNb2RpZnkgYW4gZXh0ZW50IHRvIGluY2x1ZGUgYW5vdGhlciBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQxIFRoZSBleHRlbnQgdG8gYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQyIFRoZSBleHRlbnQgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBmaXJzdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBBIHJlZmVyZW5jZSB0byB0aGUgZmlyc3QgKGV4dGVuZGVkKSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoZXh0ZW50MSwgZXh0ZW50Mikge1xuICBpZiAoZXh0ZW50MlswXSA8IGV4dGVudDFbMF0pIHtcbiAgICBleHRlbnQxWzBdID0gZXh0ZW50MlswXTtcbiAgfVxuICBpZiAoZXh0ZW50MlsyXSA+IGV4dGVudDFbMl0pIHtcbiAgICBleHRlbnQxWzJdID0gZXh0ZW50MlsyXTtcbiAgfVxuICBpZiAoZXh0ZW50MlsxXSA8IGV4dGVudDFbMV0pIHtcbiAgICBleHRlbnQxWzFdID0gZXh0ZW50MlsxXTtcbiAgfVxuICBpZiAoZXh0ZW50MlszXSA+IGV4dGVudDFbM10pIHtcbiAgICBleHRlbnQxWzNdID0gZXh0ZW50MlszXTtcbiAgfVxuICByZXR1cm4gZXh0ZW50MTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlKSB7XG4gIGlmIChjb29yZGluYXRlWzBdIDwgZXh0ZW50WzBdKSB7XG4gICAgZXh0ZW50WzBdID0gY29vcmRpbmF0ZVswXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVswXSA+IGV4dGVudFsyXSkge1xuICAgIGV4dGVudFsyXSA9IGNvb3JkaW5hdGVbMF07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMV0gPCBleHRlbnRbMV0pIHtcbiAgICBleHRlbnRbMV0gPSBjb29yZGluYXRlWzFdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzFdID4gZXh0ZW50WzNdKSB7XG4gICAgZXh0ZW50WzNdID0gY29vcmRpbmF0ZVsxXTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRDb29yZGluYXRlcyhleHRlbnQsIGNvb3JkaW5hdGVzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kRmxhdENvb3JkaW5hdGVzKGV4dGVudCwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICBleHRlbmRYWShleHRlbnQsIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+Pn0gcmluZ3MgUmluZ3MuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kUmluZ3MoZXh0ZW50LCByaW5ncykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSByaW5ncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCByaW5nc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFhZKGV4dGVudCwgeCwgeSkge1xuICBleHRlbnRbMF0gPSBNYXRoLm1pbihleHRlbnRbMF0sIHgpO1xuICBleHRlbnRbMV0gPSBNYXRoLm1pbihleHRlbnRbMV0sIHkpO1xuICBleHRlbnRbMl0gPSBNYXRoLm1heChleHRlbnRbMl0sIHgpO1xuICBleHRlbnRbM10gPSBNYXRoLm1heChleHRlbnRbM10sIHkpO1xufVxuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxscyBgY2FsbGJhY2tgIGZvciBlYWNoIGNvcm5lciBvZiB0aGUgZXh0ZW50LiBJZiB0aGVcbiAqIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIGZ1bmN0aW9uIHJldHVybnMgdGhhdCB2YWx1ZVxuICogaW1tZWRpYXRlbHkuIE90aGVyd2lzZSB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpULCBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlKTogU30gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcGFyYW0ge1Q9fSBvcHRfdGhpcyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gKiBAcmV0dXJuIHtTfGJvb2xlYW59IFZhbHVlLlxuICogQHRlbXBsYXRlIFMsIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hDb3JuZXIoZXh0ZW50LCBjYWxsYmFjaywgb3B0X3RoaXMpIHtcbiAgbGV0IHZhbDtcbiAgdmFsID0gY2FsbGJhY2suY2FsbChvcHRfdGhpcywgZ2V0Qm90dG9tTGVmdChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2suY2FsbChvcHRfdGhpcywgZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIGdldFRvcFJpZ2h0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCBnZXRUb3BMZWZ0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyZWEoZXh0ZW50KSB7XG4gIGxldCBhcmVhID0gMDtcbiAgaWYgKCFpc0VtcHR5KGV4dGVudCkpIHtcbiAgICBhcmVhID0gZ2V0V2lkdGgoZXh0ZW50KSAqIGdldEhlaWdodChleHRlbnQpO1xuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBib3R0b20gbGVmdCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBCb3R0b20gbGVmdCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm90dG9tTGVmdChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMF0sIGV4dGVudFsxXV07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGJvdHRvbSByaWdodCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBCb3R0b20gcmlnaHQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvdHRvbVJpZ2h0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFsyXSwgZXh0ZW50WzFdXTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgY2VudGVyIGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IENlbnRlci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENlbnRlcihleHRlbnQpIHtcbiAgcmV0dXJuIFsoZXh0ZW50WzBdICsgZXh0ZW50WzJdKSAvIDIsIChleHRlbnRbMV0gKyBleHRlbnRbM10pIC8gMl07XG59XG5cblxuLyoqXG4gKiBHZXQgYSBjb3JuZXIgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50L0Nvcm5lcn0gY29ybmVyIENvcm5lci5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IENvcm5lciBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29ybmVyKGV4dGVudCwgY29ybmVyKSB7XG4gIGxldCBjb29yZGluYXRlO1xuICBpZiAoY29ybmVyID09PSBDb3JuZXIuQk9UVE9NX0xFRlQpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0Qm90dG9tTGVmdChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gQ29ybmVyLkJPVFRPTV9SSUdIVCkge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRCb3R0b21SaWdodChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gQ29ybmVyLlRPUF9MRUZUKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09IENvcm5lci5UT1BfUklHSFQpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0VG9wUmlnaHQoZXh0ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UsIDEzKTsgLy8gSW52YWxpZCBjb3JuZXJcbiAgfVxuICByZXR1cm4gKFxuICAgIC8qKiBAdHlwZSB7IW1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9ICovIChjb29yZGluYXRlKVxuICApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVubGFyZ2VkIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbmxhcmdlZEFyZWEoZXh0ZW50MSwgZXh0ZW50Mikge1xuICBjb25zdCBtaW5YID0gTWF0aC5taW4oZXh0ZW50MVswXSwgZXh0ZW50MlswXSk7XG4gIGNvbnN0IG1pblkgPSBNYXRoLm1pbihleHRlbnQxWzFdLCBleHRlbnQyWzFdKTtcbiAgY29uc3QgbWF4WCA9IE1hdGgubWF4KGV4dGVudDFbMl0sIGV4dGVudDJbMl0pO1xuICBjb25zdCBtYXhZID0gTWF0aC5tYXgoZXh0ZW50MVszXSwgZXh0ZW50MlszXSk7XG4gIHJldHVybiAobWF4WCAtIG1pblgpICogKG1heFkgLSBtaW5ZKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY2VudGVyIENlbnRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zaXplflNpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JWaWV3QW5kU2l6ZShjZW50ZXIsIHJlc29sdXRpb24sIHJvdGF0aW9uLCBzaXplLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IGR4ID0gcmVzb2x1dGlvbiAqIHNpemVbMF0gLyAyO1xuICBjb25zdCBkeSA9IHJlc29sdXRpb24gKiBzaXplWzFdIC8gMjtcbiAgY29uc3QgY29zUm90YXRpb24gPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gIGNvbnN0IHNpblJvdGF0aW9uID0gTWF0aC5zaW4ocm90YXRpb24pO1xuICBjb25zdCB4Q29zID0gZHggKiBjb3NSb3RhdGlvbjtcbiAgY29uc3QgeFNpbiA9IGR4ICogc2luUm90YXRpb247XG4gIGNvbnN0IHlDb3MgPSBkeSAqIGNvc1JvdGF0aW9uO1xuICBjb25zdCB5U2luID0gZHkgKiBzaW5Sb3RhdGlvbjtcbiAgY29uc3QgeCA9IGNlbnRlclswXTtcbiAgY29uc3QgeSA9IGNlbnRlclsxXTtcbiAgY29uc3QgeDAgPSB4IC0geENvcyArIHlTaW47XG4gIGNvbnN0IHgxID0geCAtIHhDb3MgLSB5U2luO1xuICBjb25zdCB4MiA9IHggKyB4Q29zIC0geVNpbjtcbiAgY29uc3QgeDMgPSB4ICsgeENvcyArIHlTaW47XG4gIGNvbnN0IHkwID0geSAtIHhTaW4gLSB5Q29zO1xuICBjb25zdCB5MSA9IHkgLSB4U2luICsgeUNvcztcbiAgY29uc3QgeTIgPSB5ICsgeFNpbiArIHlDb3M7XG4gIGNvbnN0IHkzID0geSArIHhTaW4gLSB5Q29zO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoXG4gICAgTWF0aC5taW4oeDAsIHgxLCB4MiwgeDMpLCBNYXRoLm1pbih5MCwgeTEsIHkyLCB5MyksXG4gICAgTWF0aC5tYXgoeDAsIHgxLCB4MiwgeDMpLCBNYXRoLm1heCh5MCwgeTEsIHkyLCB5MyksXG4gICAgb3B0X2V4dGVudCk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGhlaWdodCBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbM10gLSBleHRlbnRbMV07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gSW50ZXJzZWN0aW9uIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25BcmVhKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgY29uc3QgaW50ZXJzZWN0aW9uID0gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIpO1xuICByZXR1cm4gZ2V0QXJlYShpbnRlcnNlY3Rpb24pO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGV4dGVudHMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IE9wdGlvbmFsIGV4dGVudCB0byBwb3B1bGF0ZSB3aXRoIGludGVyc2VjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBJbnRlcnNlY3RpbmcgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIsIG9wdF9leHRlbnQpIHtcbiAgY29uc3QgaW50ZXJzZWN0aW9uID0gb3B0X2V4dGVudCA/IG9wdF9leHRlbnQgOiBjcmVhdGVFbXB0eSgpO1xuICBpZiAoaW50ZXJzZWN0cyhleHRlbnQxLCBleHRlbnQyKSkge1xuICAgIGlmIChleHRlbnQxWzBdID4gZXh0ZW50MlswXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzBdID0gZXh0ZW50MVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzBdID0gZXh0ZW50MlswXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbMV0gPiBleHRlbnQyWzFdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMV0gPSBleHRlbnQxWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMV0gPSBleHRlbnQyWzFdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVsyXSA8IGV4dGVudDJbMl0pIHtcbiAgICAgIGludGVyc2VjdGlvblsyXSA9IGV4dGVudDFbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblsyXSA9IGV4dGVudDJbMl07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzNdIDwgZXh0ZW50MlszXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzNdID0gZXh0ZW50MVszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzNdID0gZXh0ZW50MlszXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlT3JVcGRhdGVFbXB0eShpbnRlcnNlY3Rpb24pO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb247XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBNYXJnaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJnaW4oZXh0ZW50KSB7XG4gIHJldHVybiBnZXRXaWR0aChleHRlbnQpICsgZ2V0SGVpZ2h0KGV4dGVudCk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgKHdpZHRoLCBoZWlnaHQpIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gVGhlIGV4dGVudCBzaXplLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZShleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0gLSBleHRlbnRbMF0sIGV4dGVudFszXSAtIGV4dGVudFsxXV07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHRvcCBsZWZ0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IFRvcCBsZWZ0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BMZWZ0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFswXSwgZXh0ZW50WzNdXTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgdG9wIHJpZ2h0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IFRvcCByaWdodCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wUmlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzJdLCBleHRlbnRbM11dO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSB3aWR0aCBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBXaWR0aC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdpZHRoKGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzJdIC0gZXh0ZW50WzBdO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIG9uZSBleHRlbnQgaW50ZXJzZWN0cyBhbm90aGVyLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDIgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBleHRlbnRzIGludGVyc2VjdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHMoZXh0ZW50MSwgZXh0ZW50Mikge1xuICByZXR1cm4gZXh0ZW50MVswXSA8PSBleHRlbnQyWzJdICYmXG4gICAgICBleHRlbnQxWzJdID49IGV4dGVudDJbMF0gJiZcbiAgICAgIGV4dGVudDFbMV0gPD0gZXh0ZW50MlszXSAmJlxuICAgICAgZXh0ZW50MVszXSA+PSBleHRlbnQyWzFdO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGV4dGVudCBpcyBlbXB0eS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMl0gPCBleHRlbnRbMF0gfHwgZXh0ZW50WzNdIDwgZXh0ZW50WzFdO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5PclVwZGF0ZShleHRlbnQsIG9wdF9leHRlbnQpIHtcbiAgaWYgKG9wdF9leHRlbnQpIHtcbiAgICBvcHRfZXh0ZW50WzBdID0gZXh0ZW50WzBdO1xuICAgIG9wdF9leHRlbnRbMV0gPSBleHRlbnRbMV07XG4gICAgb3B0X2V4dGVudFsyXSA9IGV4dGVudFsyXTtcbiAgICBvcHRfZXh0ZW50WzNdID0gZXh0ZW50WzNdO1xuICAgIHJldHVybiBvcHRfZXh0ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUZyb21DZW50ZXIoZXh0ZW50LCB2YWx1ZSkge1xuICBjb25zdCBkZWx0YVggPSAoKGV4dGVudFsyXSAtIGV4dGVudFswXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBjb25zdCBkZWx0YVkgPSAoKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBleHRlbnRbMF0gLT0gZGVsdGFYO1xuICBleHRlbnRbMl0gKz0gZGVsdGFYO1xuICBleHRlbnRbMV0gLT0gZGVsdGFZO1xuICBleHRlbnRbM10gKz0gZGVsdGFZO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBzZWdtZW50IGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzIGludGVyc2VjdHMgKGNyb3NzZXMsXG4gKiB0b3VjaGVzLCBvciBpcyBjb250YWluZWQgYnkpIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gc3RhcnQgU2VnbWVudCBzdGFydCBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBlbmQgU2VnbWVudCBlbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWdtZW50IGludGVyc2VjdHMgdGhlIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNTZWdtZW50KGV4dGVudCwgc3RhcnQsIGVuZCkge1xuICBsZXQgaW50ZXJzZWN0cyA9IGZhbHNlO1xuICBjb25zdCBzdGFydFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBzdGFydCk7XG4gIGNvbnN0IGVuZFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBlbmQpO1xuICBpZiAoc3RhcnRSZWwgPT09IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkcgfHxcbiAgICAgIGVuZFJlbCA9PT0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORykge1xuICAgIGludGVyc2VjdHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1pblggPSBleHRlbnRbMF07XG4gICAgY29uc3QgbWluWSA9IGV4dGVudFsxXTtcbiAgICBjb25zdCBtYXhYID0gZXh0ZW50WzJdO1xuICAgIGNvbnN0IG1heFkgPSBleHRlbnRbM107XG4gICAgY29uc3Qgc3RhcnRYID0gc3RhcnRbMF07XG4gICAgY29uc3Qgc3RhcnRZID0gc3RhcnRbMV07XG4gICAgY29uc3QgZW5kWCA9IGVuZFswXTtcbiAgICBjb25zdCBlbmRZID0gZW5kWzFdO1xuICAgIGNvbnN0IHNsb3BlID0gKGVuZFkgLSBzdGFydFkpIC8gKGVuZFggLSBzdGFydFgpO1xuICAgIGxldCB4LCB5O1xuICAgIGlmICghIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHRvcFxuICAgICAgeCA9IGVuZFggLSAoKGVuZFkgLSBtYXhZKSAvIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHMgJiYgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLlJJR0hUKSAmJlxuICAgICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLlJJR0hUKSkge1xuICAgICAgLy8gcG90ZW50aWFsbHkgaW50ZXJzZWN0cyByaWdodFxuICAgICAgeSA9IGVuZFkgLSAoKGVuZFggLSBtYXhYKSAqIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB5ID49IG1pblkgJiYgeSA8PSBtYXhZO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHMgJiYgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKSAmJlxuICAgICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKSkge1xuICAgICAgLy8gcG90ZW50aWFsbHkgaW50ZXJzZWN0cyBib3R0b21cbiAgICAgIHggPSBlbmRYIC0gKChlbmRZIC0gbWluWSkgLyBzbG9wZSk7XG4gICAgICBpbnRlcnNlY3RzID0geCA+PSBtaW5YICYmIHggPD0gbWF4WDtcbiAgICB9XG4gICAgaWYgKCFpbnRlcnNlY3RzICYmICEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5MRUZUKSAmJlxuICAgICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkxFRlQpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIGxlZnRcbiAgICAgIHkgPSBlbmRZIC0gKChlbmRYIC0gbWluWCkgKiBzbG9wZSk7XG4gICAgICBpbnRlcnNlY3RzID0geSA+PSBtaW5ZICYmIHkgPD0gbWF4WTtcbiAgICB9XG5cbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0cztcbn1cblxuXG4vKipcbiAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIHRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICogQ2FsbGVkIHdpdGggYFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXWAgZXh0ZW50IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKGV4dGVudCwgdHJhbnNmb3JtRm4sIG9wdF9leHRlbnQpIHtcbiAgY29uc3QgY29vcmRpbmF0ZXMgPSBbXG4gICAgZXh0ZW50WzBdLCBleHRlbnRbMV0sXG4gICAgZXh0ZW50WzBdLCBleHRlbnRbM10sXG4gICAgZXh0ZW50WzJdLCBleHRlbnRbMV0sXG4gICAgZXh0ZW50WzJdLCBleHRlbnRbM11cbiAgXTtcbiAgdHJhbnNmb3JtRm4oY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzLCAyKTtcbiAgY29uc3QgeHMgPSBbY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzJdLCBjb29yZGluYXRlc1s0XSwgY29vcmRpbmF0ZXNbNl1dO1xuICBjb25zdCB5cyA9IFtjb29yZGluYXRlc1sxXSwgY29vcmRpbmF0ZXNbM10sIGNvb3JkaW5hdGVzWzVdLCBjb29yZGluYXRlc1s3XV07XG4gIHJldHVybiBfYm91bmRpbmdFeHRlbnRYWXMoeHMsIHlzLCBvcHRfZXh0ZW50KTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9leHRlbnQvQ29ybmVyXG4gKi9cblxuLyoqXG4gKiBFeHRlbnQgY29ybmVyLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBCT1RUT01fTEVGVDogJ2JvdHRvbS1sZWZ0JyxcbiAgQk9UVE9NX1JJR0hUOiAnYm90dG9tLXJpZ2h0JyxcbiAgVE9QX0xFRlQ6ICd0b3AtbGVmdCcsXG4gIFRPUF9SSUdIVDogJ3RvcC1yaWdodCdcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZXh0ZW50L1JlbGF0aW9uc2hpcFxuICovXG5cbi8qKlxuICogUmVsYXRpb25zaGlwIHRvIGFuIGV4dGVudC5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVU5LTk9XTjogMCxcbiAgSU5URVJTRUNUSU5HOiAxLFxuICBBQk9WRTogMixcbiAgUklHSFQ6IDQsXG4gIEJFTE9XOiA4LFxuICBMRUZUOiAxNlxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mdW5jdGlvbnNcbiAqL1xuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIHRydWUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRSVUUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIGZhbHNlLlxuICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRkFMU0UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHJldXNhYmxlIGZ1bmN0aW9uLCB1c2VkIGUuZy4gYXMgYSBkZWZhdWx0IGZvciBjYWxsYmFja3MuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSBOb3RoaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gVU5ERUZJTkVEKCkge31cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0dlb21ldHJ5VHlwZVxuICovXG5cbi8qKlxuICogVGhlIGdlb21ldHJ5IHR5cGUuIE9uZSBvZiBgJ1BvaW50J2AsIGAnTGluZVN0cmluZydgLCBgJ0xpbmVhclJpbmcnYCxcbiAqIGAnUG9seWdvbidgLCBgJ011bHRpUG9pbnQnYCwgYCdNdWx0aUxpbmVTdHJpbmcnYCwgYCdNdWx0aVBvbHlnb24nYCxcbiAqIGAnR2VvbWV0cnlDb2xsZWN0aW9uJ2AsIGAnQ2lyY2xlJ2AuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBPSU5UOiAnUG9pbnQnLFxuICBMSU5FX1NUUklORzogJ0xpbmVTdHJpbmcnLFxuICBMSU5FQVJfUklORzogJ0xpbmVhclJpbmcnLFxuICBQT0xZR09OOiAnUG9seWdvbicsXG4gIE1VTFRJX1BPSU5UOiAnTXVsdGlQb2ludCcsXG4gIE1VTFRJX0xJTkVfU1RSSU5HOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgTVVMVElfUE9MWUdPTjogJ011bHRpUG9seWdvbicsXG4gIEdFT01FVFJZX0NPTExFQ1RJT046ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuICBDSVJDTEU6ICdDaXJjbGUnXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sXG4gKi9cblxuaW1wb3J0IHtnZXRDb250ZXh0fSBmcm9tICcuL3dlYmdsLmpzJztcblxuXG4vKipcbiAqIEFuIGFycmF5IHdpdGggdHdvIGVsZW1lbnRzLCByZXByZXNlbnRpbmcgYSBwaXhlbC4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlXG4gKiB4LWNvb3JkaW5hdGUsIHRoZSBzZWNvbmQgdGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgcGl4ZWwuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPG51bWJlcj59IFBpeGVsXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEluY2x1ZGUgZGVidWdnYWJsZSBzaGFkZXIgc291cmNlcy4gIERlZmF1bHQgaXMgYHRydWVgLiBUaGlzIHNob3VsZCBiZSBzZXQgdG9cbiAqIGBmYWxzZWAgZm9yIHByb2R1Y3Rpb24gYnVpbGRzLlxuICogVE9ETzogbW92ZSB0byBhIHNlcGFyYXRlIG9sLXdlYmdsIHBhY2thZ2VcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgREVCVUdfV0VCR0wgPSB0cnVlO1xuXG5cbi8qKlxuICogVE9ETzogbW92ZSB0byBhIHNlcGFyYXRlIG9sLXdlYmdsIHBhY2thZ2VcbiAqIFRoZSBtYXhpbXVtIHN1cHBvcnRlZCBXZWJHTCB0ZXh0dXJlIHNpemUgaW4gcGl4ZWxzLiBJZiBXZWJHTCBpcyBub3RcbiAqIHN1cHBvcnRlZCwgdGhlIHZhbHVlIGlzIHNldCB0byBgdW5kZWZpbmVkYC5cbiAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICovXG5sZXQgV0VCR0xfTUFYX1RFWFRVUkVfU0laRTsgLy8gdmFsdWUgaXMgc2V0IGJlbG93XG5cblxuLyoqXG4gKiBUT0RPOiBtb3ZlIHRvIGEgc2VwYXJhdGUgb2wtd2ViZ2wgcGFja2FnZVxuICogTGlzdCBvZiBzdXBwb3J0ZWQgV2ViR0wgZXh0ZW5zaW9ucy5cbiAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAqL1xubGV0IFdFQkdMX0VYVEVOU0lPTlM7IC8vIHZhbHVlIGlzIHNldCBiZWxvd1xuXG5cbi8qKlxuICogVE9ETzogbW92ZSB0byBhIHNlcGFyYXRlIG9sLXdlYmdsIHBhY2thZ2VcbiAqIFdlYkdMIGlzIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5sZXQgSEFTX1dFQkdMID0gZmFsc2U7XG5cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdXZWJHTFJlbmRlcmluZ0NvbnRleHQnIGluIHdpbmRvdykge1xuICB0cnkge1xuICAgIGNvbnN0IGNhbnZhcyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdDQU5WQVMnKSk7XG4gICAgY29uc3QgZ2wgPSBnZXRDb250ZXh0KGNhbnZhcywge2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRydWV9KTtcbiAgICBpZiAoZ2wpIHtcbiAgICAgIEhBU19XRUJHTCA9IHRydWU7XG4gICAgICBXRUJHTF9NQVhfVEVYVFVSRV9TSVpFID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSkpO1xuICAgICAgV0VCR0xfRVhURU5TSU9OUyA9IGdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBwYXNzXG4gIH1cbn1cblxuZXhwb3J0IHtIQVNfV0VCR0wsIFdFQkdMX01BWF9URVhUVVJFX1NJWkUsIFdFQkdMX0VYVEVOU0lPTlN9O1xuXG5cbi8qKlxuICogT3BlbkxheWVycyB2ZXJzaW9uLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAndjQuNi40JztcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gUGFyZW50Q2xhc3MoYSwgYikgeyB9XG4gKiAgICAgUGFyZW50Q2xhc3MucHJvdG90eXBlLmZvbyA9IGZ1bmN0aW9uKGEpIHsgfVxuICpcbiAqICAgICBmdW5jdGlvbiBDaGlsZENsYXNzKGEsIGIsIGMpIHtcbiAqICAgICAgIC8vIENhbGwgcGFyZW50IGNvbnN0cnVjdG9yXG4gKiAgICAgICBQYXJlbnRDbGFzcy5jYWxsKHRoaXMsIGEsIGIpO1xuICogICAgIH1cbiAqICAgICBpbmhlcml0cyhDaGlsZENsYXNzLCBQYXJlbnRDbGFzcyk7XG4gKlxuICogICAgIHZhciBjaGlsZCA9IG5ldyBDaGlsZENsYXNzKCdhJywgJ2InLCAnc2VlJyk7XG4gKiAgICAgY2hpbGQuZm9vKCk7IC8vIFRoaXMgd29ya3MuXG4gKlxuICogQHBhcmFtIHshRnVuY3Rpb259IGNoaWxkQ3RvciBDaGlsZCBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBwYXJlbnRDdG9yIFBhcmVudCBjb25zdHJ1Y3Rvci5cbiAqIEBmdW5jdGlvblxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5oZXJpdHMoY2hpbGRDdG9yLCBwYXJlbnRDdG9yKSB7XG4gIGNoaWxkQ3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudEN0b3IucHJvdG90eXBlKTtcbiAgY2hpbGRDdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNoaWxkQ3Rvcjtcbn1cblxuXG4vKipcbiAqIENvdW50ZXIgZm9yIGdldFVpZC5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5sZXQgdWlkQ291bnRlcl8gPSAwO1xuXG4vKipcbiAqIEdldHMgYSB1bmlxdWUgSUQgZm9yIGFuIG9iamVjdC4gVGhpcyBtdXRhdGVzIHRoZSBvYmplY3Qgc28gdGhhdCBmdXJ0aGVyIGNhbGxzXG4gKiB3aXRoIHRoZSBzYW1lIG9iamVjdCBhcyBhIHBhcmFtZXRlciByZXR1cm5zIHRoZSBzYW1lIHZhbHVlLiBVbmlxdWUgSURzIGFyZSBnZW5lcmF0ZWRcbiAqIGFzIGEgc3RyaWN0bHkgaW5jcmVhc2luZyBzZXF1ZW5jZS4gQWRhcHRlZCBmcm9tIGdvb2cuZ2V0VWlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBnZXQgdGhlIHVuaXF1ZSBJRCBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB1bmlxdWUgSUQgZm9yIHRoZSBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaWQob2JqKSB7XG4gIHJldHVybiBvYmoub2xfdWlkIHx8IChvYmoub2xfdWlkID0gKyt1aWRDb3VudGVyXyk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvbWF0aFxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcblxuLyoqXG4gKiBUYWtlcyBhIG51bWJlciBhbmQgY2xhbXBzIGl0IHRvIHdpdGhpbiB0aGUgcHJvdmlkZWQgYm91bmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBpbnB1dCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHZhbHVlIHRvIHJldHVybi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gdmFsdWUgdG8gcmV0dXJuLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5wdXQgbnVtYmVyIGlmIGl0IGlzIHdpdGhpbiBib3VuZHMsIG9yIHRoZSBuZWFyZXN0XG4gKiAgICAgbnVtYmVyIHdpdGhpbiB0aGUgYm91bmRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbn1cblxuXG4vKipcbiAqIFJldHVybiB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgYSBnaXZlbiBudW1iZXIuIFRoZSBtZXRob2Qgd2lsbCB1c2UgdGhlXG4gKiBuYXRpdmUgYE1hdGguY29zaGAgZnVuY3Rpb24gaWYgaXQgaXMgYXZhaWxhYmxlLCBvdGhlcndpc2UgdGhlIGh5cGVyYm9saWNcbiAqIGNvc2luZSB3aWxsIGJlIGNhbGN1bGF0ZWQgdmlhIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgdGhlIE1vemlsbGFcbiAqIGRldmVsb3BlciBuZXR3b3JrLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEh5cGVyYm9saWMgY29zaW5lIG9mIHguXG4gKi9cbmV4cG9ydCBjb25zdCBjb3NoICA9IChmdW5jdGlvbigpIHtcbiAgLy8gV3JhcHBlZCBpbiBhIGlpZmUsIHRvIHNhdmUgdGhlIG92ZXJoZWFkIG9mIGNoZWNraW5nIGZvciB0aGUgbmF0aXZlXG4gIC8vIGltcGxlbWVudGF0aW9uIG9uIGV2ZXJ5IGludm9jYXRpb24uXG4gIGxldCBjb3NoO1xuICBpZiAoJ2Nvc2gnIGluIE1hdGgpIHtcbiAgICAvLyBUaGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgdGhlIG5hdGl2ZSBNYXRoLmNvc2ggZnVuY3Rpb24sIHVzZSBpdOKAplxuICAgIGNvc2ggPSBNYXRoLmNvc2g7XG4gIH0gZWxzZSB7XG4gICAgLy8g4oCmIGVsc2UsIHVzZSB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIE1ETjpcbiAgICBjb3NoID0gZnVuY3Rpb24oeCkge1xuICAgICAgY29uc3QgeSA9IE1hdGguZXhwKHgpO1xuICAgICAgcmV0dXJuICh5ICsgMSAvIHkpIC8gMjtcbiAgICB9O1xuICB9XG4gIHJldHVybiBjb3NoO1xufSgpKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzbWFsbGVzdCBwb3dlciBvZiB0d28gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFVwVG9Qb3dlck9mVHdvKHgpIHtcbiAgYXNzZXJ0KDAgPCB4LCAyOSk7IC8vIGB4YCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBgMGBcbiAgcmV0dXJuIE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZyh4KSAvIE1hdGguTE4yKSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnQgKHgsIHkpIGFuZCB0aGVcbiAqIGxpbmUgc2VnbWVudCAoeDEsIHkxKSB0byAoeDIsIHkyKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IHgxIFgxLlxuICogQHBhcmFtIHtudW1iZXJ9IHkxIFkxLlxuICogQHBhcmFtIHtudW1iZXJ9IHgyIFgyLlxuICogQHBhcmFtIHtudW1iZXJ9IHkyIFkyLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZFNlZ21lbnREaXN0YW5jZSh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBkeCA9IHgyIC0geDE7XG4gIGNvbnN0IGR5ID0geTIgLSB5MTtcbiAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG4gICAgY29uc3QgdCA9ICgoeCAtIHgxKSAqIGR4ICsgKHkgLSB5MSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGlmICh0ID4gMSkge1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgeDEgKz0gZHggKiB0O1xuICAgICAgeTEgKz0gZHkgKiB0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3F1YXJlZERpc3RhbmNlKHgsIHksIHgxLCB5MSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgY29uc3QgZHggPSB4MiAtIHgxO1xuICBjb25zdCBkeSA9IHkyIC0geTE7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuXG4vKipcbiAqIFNvbHZlcyBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyB1c2luZyBHYXVzc2lhbiBlbGltaW5hdGlvbiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBtYXQgQXVnbWVudGVkIG1hdHJpeCAobiB4IG4gKyAxIGNvbHVtbilcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHJvdy1tYWpvciBvcmRlci5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBUaGUgcmVzdWx0aW5nIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvbHZlTGluZWFyU3lzdGVtKG1hdCkge1xuICBjb25zdCBuID0gbWF0Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIC8vIEZpbmQgbWF4IGluIHRoZSBpLXRoIGNvbHVtbiAoaWdub3JpbmcgaSAtIDEgZmlyc3Qgcm93cylcbiAgICBsZXQgbWF4Um93ID0gaTtcbiAgICBsZXQgbWF4RWwgPSBNYXRoLmFicyhtYXRbaV1baV0pO1xuICAgIGZvciAobGV0IHIgPSBpICsgMTsgciA8IG47IHIrKykge1xuICAgICAgY29uc3QgYWJzVmFsdWUgPSBNYXRoLmFicyhtYXRbcl1baV0pO1xuICAgICAgaWYgKGFic1ZhbHVlID4gbWF4RWwpIHtcbiAgICAgICAgbWF4RWwgPSBhYnNWYWx1ZTtcbiAgICAgICAgbWF4Um93ID0gcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4RWwgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBtYXRyaXggaXMgc2luZ3VsYXJcbiAgICB9XG5cbiAgICAvLyBTd2FwIG1heCByb3cgd2l0aCBpLXRoIChjdXJyZW50KSByb3dcbiAgICBjb25zdCB0bXAgPSBtYXRbbWF4Um93XTtcbiAgICBtYXRbbWF4Um93XSA9IG1hdFtpXTtcbiAgICBtYXRbaV0gPSB0bXA7XG5cbiAgICAvLyBTdWJ0cmFjdCB0aGUgaS10aCByb3cgdG8gbWFrZSBhbGwgdGhlIHJlbWFpbmluZyByb3dzIDAgaW4gdGhlIGktdGggY29sdW1uXG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICBjb25zdCBjb2VmID0gLW1hdFtqXVtpXSAvIG1hdFtpXVtpXTtcbiAgICAgIGZvciAobGV0IGsgPSBpOyBrIDwgbiArIDE7IGsrKykge1xuICAgICAgICBpZiAoaSA9PSBrKSB7XG4gICAgICAgICAgbWF0W2pdW2tdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRbal1ba10gKz0gY29lZiAqIG1hdFtpXVtrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbHZlIEF4PWIgZm9yIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IEEgKG1hdClcbiAgY29uc3QgeCA9IG5ldyBBcnJheShuKTtcbiAgZm9yIChsZXQgbCA9IG4gLSAxOyBsID49IDA7IGwtLSkge1xuICAgIHhbbF0gPSBtYXRbbF1bbl0gLyBtYXRbbF1bbF07XG4gICAgZm9yIChsZXQgbSA9IGwgLSAxOyBtID49IDA7IG0tLSkge1xuICAgICAgbWF0W21dW25dIC09IG1hdFttXVtsXSAqIHhbbF07XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufVxuXG5cbi8qKlxuICogQ29udmVydHMgcmFkaWFucyB0byB0byBkZWdyZWVzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBBbmdsZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBpbiBkZWdyZWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWVzKGFuZ2xlSW5SYWRpYW5zKSB7XG4gIHJldHVybiBhbmdsZUluUmFkaWFucyAqIDE4MCAvIE1hdGguUEk7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5EZWdyZWVzIEFuZ2xlIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIGluIHJhZGlhbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbnMoYW5nbGVJbkRlZ3JlZXMpIHtcbiAgcmV0dXJuIGFuZ2xlSW5EZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtb2R1bG8gb2YgYSAvIGIsIGRlcGVuZGluZyBvbiB0aGUgc2lnbiBvZiBiLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIERpdmlkZW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IGIgRGl2aXNvci5cbiAqIEByZXR1cm4ge251bWJlcn0gTW9kdWxvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbW9kdWxvKGEsIGIpIHtcbiAgY29uc3QgciA9IGEgJSBiO1xuICByZXR1cm4gciAqIGIgPCAwID8gciArIGIgOiByO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxpbmVhcmx5IGludGVycG9sYXRlZCB2YWx1ZSBvZiB4IGJldHdlZW4gYSBhbmQgYi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IHggVmFsdWUgdG8gYmUgaW50ZXJwb2xhdGVkLlxuICogQHJldHVybiB7bnVtYmVyfSBJbnRlcnBvbGF0ZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKGEsIGIsIHgpIHtcbiAgcmV0dXJuIGEgKyB4ICogKGIgLSBhKTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9vYmpcbiAqL1xuXG5cbi8qKlxuICogUG9seWZpbGwgZm9yIE9iamVjdC5hc3NpZ24oKS4gIEFzc2lnbnMgZW51bWVyYWJsZSBhbmQgb3duIHByb3BlcnRpZXMgZnJvbVxuICogb25lIG9yIG1vcmUgc291cmNlIG9iamVjdHMgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICogQHBhcmFtIHshT2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX3NvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3QocykuXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBUaGUgbW9kaWZpZWQgdGFyZ2V0IG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGFzc2lnbiA9ICh0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJykgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24odGFyZ2V0LCB2YXJfc291cmNlcykge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yIChsZXQgaSA9IDEsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBwcm9wZXJ0aWVzIGZyb20gYW4gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsZWFyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIob2JqZWN0KSB7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEdldCBhbiBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMgZnJvbSBhbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxLLFY+fSBvYmplY3QgVGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgdmFsdWVzLlxuICogQHJldHVybiB7IUFycmF5PFY+fSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVzKG9iamVjdCkge1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICB2YWx1ZXMucHVzaChvYmplY3RbcHJvcGVydHldKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBoYXMgYW55IHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgb2JqZWN0IGlzIGVtcHR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eShvYmplY3QpIHtcbiAgbGV0IHByb3BlcnR5O1xuICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gIXByb3BlcnR5O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2pcbiAqL1xuXG4vKipcbiAqIFRoZSBvbC9wcm9qIG1vZHVsZSBzdG9yZXM6XG4gKiAqIGEgbGlzdCBvZiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn1cbiAqIG9iamVjdHMsIG9uZSBmb3IgZWFjaCBwcm9qZWN0aW9uIHN1cHBvcnRlZCBieSB0aGUgYXBwbGljYXRpb25cbiAqICogYSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgbmVlZGVkIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgaW4gb25lIHByb2plY3Rpb25cbiAqIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgc3RhdGljIGZ1bmN0aW9ucyBhcmUgdGhlIG1ldGhvZHMgdXNlZCB0byBtYWludGFpbiB0aGVzZS5cbiAqIEVhY2ggdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbiBoYW5kbGUgbm90IG9ubHkgc2ltcGxlIGNvb3JkaW5hdGUgcGFpcnMsIGJ1dCBhbHNvXG4gKiBsYXJnZSBhcnJheXMgb2YgY29vcmRpbmF0ZXMgc3VjaCBhcyB2ZWN0b3IgZ2VvbWV0cmllcy5cbiAqXG4gKiBXaGVuIGxvYWRlZCwgdGhlIGxpYnJhcnkgYWRkcyBwcm9qZWN0aW9uIG9iamVjdHMgZm9yIEVQU0c6NDMyNiAoV0dTODRcbiAqIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMpIGFuZCBFUFNHOjM4NTcgKFdlYiBvciBTcGhlcmljYWwgTWVyY2F0b3IsIGFzIHVzZWRcbiAqIGZvciBleGFtcGxlIGJ5IEJpbmcgTWFwcyBvciBPcGVuU3RyZWV0TWFwKSwgdG9nZXRoZXIgd2l0aCB0aGUgcmVsZXZhbnRcbiAqIHRyYW5zZm9ybSBmdW5jdGlvbnMuXG4gKlxuICogQWRkaXRpb25hbCB0cmFuc2Zvcm1zIG1heSBiZSBhZGRlZCBieSB1c2luZyB0aGUge0BsaW5rIGh0dHA6Ly9wcm9qNGpzLm9yZy99XG4gKiBsaWJyYXJ5ICh2ZXJzaW9uIDIuMiBvciBsYXRlcikuIFlvdSBjYW4gdXNlIHRoZSBmdWxsIGJ1aWxkIHN1cHBsaWVkIGJ5XG4gKiBQcm9qNGpzLCBvciBjcmVhdGUgYSBjdXN0b20gYnVpbGQgdG8gc3VwcG9ydCB0aG9zZSBwcm9qZWN0aW9ucyB5b3UgbmVlZDsgc2VlXG4gKiB0aGUgUHJvajRqcyB3ZWJzaXRlIGZvciBob3cgdG8gZG8gdGhpcy4gWW91IGFsc28gbmVlZCB0aGUgUHJvajRqcyBkZWZpbml0aW9uc1xuICogZm9yIHRoZSByZXF1aXJlZCBwcm9qZWN0aW9ucy4gVGhlc2UgZGVmaW5pdGlvbnMgY2FuIGJlIG9idGFpbmVkIGZyb21cbiAqIHtAbGluayBodHRwczovL2Vwc2cuaW8vfSwgYW5kIGFyZSBhIEpTIGZ1bmN0aW9uLCBzbyBjYW4gYmUgbG9hZGVkIGluIGEgc2NyaXB0XG4gKiB0YWcgKGFzIGluIHRoZSBleGFtcGxlcykgb3IgcGFzdGVkIGludG8geW91ciBhcHBsaWNhdGlvbi5cbiAqXG4gKiBBZnRlciBhbGwgcmVxdWlyZWQgcHJvamVjdGlvbiBkZWZpbml0aW9ucyBhcmUgYWRkZWQgdG8gcHJvajQncyByZWdpc3RyeSAoYnlcbiAqIHVzaW5nIGBwcm9qNC5kZWZzKClgKSwgc2ltcGx5IGNhbGwgYHJlZ2lzdGVyKHByb2o0KWAgZnJvbSB0aGUgYG9sL3Byb2ovcHJvajRgXG4gKiBwYWNrYWdlLiBFeGlzdGluZyB0cmFuc2Zvcm1zIGFyZSBub3QgY2hhbmdlZCBieSB0aGlzIGZ1bmN0aW9uLiBTZWVcbiAqIGV4YW1wbGVzL3dtcy1pbWFnZS1jdXN0b20tcHJvaiBmb3IgYW4gZXhhbXBsZSBvZiB0aGlzLlxuICpcbiAqIEFkZGl0aW9uYWwgcHJvamVjdGlvbiBkZWZpbml0aW9ucyBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIGBwcm9qNC5kZWZzKClgIGFueVxuICogdGltZS4gSnVzdCBtYWtlIHN1cmUgdG8gY2FsbCBgcmVnaXN0ZXIocHJvajQpYCBhZ2FpbjsgZm9yIGV4YW1wbGUsIHdpdGggdXNlci1zdXBwbGllZCBkYXRhIHdoZXJlIHlvdSBkb24ndFxuICoga25vdyBpbiBhZHZhbmNlIHdoYXQgcHJvamVjdGlvbnMgYXJlIG5lZWRlZCwgeW91IGNhbiBpbml0aWFsbHkgbG9hZCBtaW5pbWFsXG4gKiBzdXBwb3J0IGFuZCB0aGVuIGxvYWQgd2hpY2hldmVyIGFyZSByZXF1ZXN0ZWQuXG4gKlxuICogTm90ZSB0aGF0IFByb2o0anMgZG9lcyBub3Qgc3VwcG9ydCBwcm9qZWN0aW9uIGV4dGVudHMuIElmIHlvdSB3YW50IHRvIGFkZFxuICogb25lIGZvciBjcmVhdGluZyBkZWZhdWx0IHRpbGUgZ3JpZHMsIHlvdSBjYW4gYWRkIGl0IGFmdGVyIHRoZSBQcm9qZWN0aW9uXG4gKiBvYmplY3QgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIGBzZXRFeHRlbnRgLCBmb3IgZXhhbXBsZSxcbiAqIGBnZXQoJ0VQU0c6MTIzNCcpLnNldEV4dGVudChleHRlbnQpYC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBQcm9qNGpzIHN1cHBvcnQsIGFueSB0cmFuc2Zvcm0gZnVuY3Rpb25zIGNhbiBiZSBhZGRlZCB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+YWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXN9LiBUbyB1c2UgdGhpcywgeW91IG11c3QgZmlyc3QgY3JlYXRlXG4gKiBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBvYmplY3QgZm9yIHRoZSBuZXcgcHJvamVjdGlvbiBhbmQgYWRkIGl0IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvan5hZGRQcm9qZWN0aW9ufS4gWW91IGNhbiB0aGVuIGFkZCB0aGUgZm9yd2FyZCBhbmQgaW52ZXJzZVxuICogZnVuY3Rpb25zIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zfS4gU2VlXG4gKiBleGFtcGxlcy93bXMtY3VzdG9tLXByb2ogZm9yIGFuIGV4YW1wbGUgb2YgdGhpcy5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgbm8gdHJhbnNmb3JtcyBhcmUgbmVlZGVkIGFuZCB5b3Ugb25seSBuZWVkIHRvIGRlZmluZSB0aGVcbiAqIHByb2plY3Rpb24sIGp1c3QgYWRkIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvan5hZGRQcm9qZWN0aW9ufS4gU2VlIGV4YW1wbGVzL3dtcy1uby1wcm9qIGZvciBhbiBleGFtcGxlIG9mXG4gKiB0aGlzLlxuICovXG5pbXBvcnQge2dldERpc3RhbmNlfSBmcm9tICcuL3NwaGVyZS5qcyc7XG5pbXBvcnQge2FwcGx5VHJhbnNmb3JtfSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7dG9FUFNHNDMyNiwgZnJvbUVQU0c0MzI2LCBQUk9KRUNUSU9OUyBhcyBFUFNHMzg1N19QUk9KRUNUSU9OU30gZnJvbSAnLi9wcm9qL2Vwc2czODU3LmpzJztcbmltcG9ydCB7UFJPSkVDVElPTlMgYXMgRVBTRzQzMjZfUFJPSkVDVElPTlN9IGZyb20gJy4vcHJvai9lcHNnNDMyNi5qcyc7XG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL3Byb2ovUHJvamVjdGlvbi5qcyc7XG5pbXBvcnQgVW5pdHMsIHtNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQgKiBhcyBwcm9qZWN0aW9ucyBmcm9tICcuL3Byb2ovcHJvamVjdGlvbnMuanMnO1xuaW1wb3J0IHthZGQgYXMgYWRkVHJhbnNmb3JtRnVuYywgY2xlYXIgYXMgY2xlYXJUcmFuc2Zvcm1GdW5jcywgZ2V0IGFzIGdldFRyYW5zZm9ybUZ1bmN9IGZyb20gJy4vcHJvai90cmFuc2Zvcm1zLmpzJztcblxuXG4vKipcbiAqIEEgcHJvamVjdGlvbiBhcyB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0sIFNSUyBpZGVudGlmaWVyXG4gKiBzdHJpbmcgb3IgdW5kZWZpbmVkLlxuICogQHR5cGVkZWYge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb258c3RyaW5nfHVuZGVmaW5lZH0gUHJvamVjdGlvbkxpa2VcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQSB0cmFuc2Zvcm0gZnVuY3Rpb24gYWNjZXB0cyBhbiBhcnJheSBvZiBpbnB1dCBjb29yZGluYXRlIHZhbHVlcywgYW4gb3B0aW9uYWxcbiAqIG91dHB1dCBhcnJheSwgYW5kIGFuIG9wdGlvbmFsIGRpbWVuc2lvbiAoZGVmYXVsdCBzaG91bGQgYmUgMikuICBUaGUgZnVuY3Rpb25cbiAqIHRyYW5zZm9ybXMgdGhlIGlucHV0IGNvb3JkaW5hdGUgdmFsdWVzLCBwb3B1bGF0ZXMgdGhlIG91dHB1dCBhcnJheSwgYW5kXG4gKiByZXR1cm5zIHRoZSBvdXRwdXQgYXJyYXkuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEFycmF5LjxudW1iZXI+LCBBcnJheS48bnVtYmVyPj0sIG51bWJlcj0pOiBBcnJheS48bnVtYmVyPn0gVHJhbnNmb3JtRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5cbmV4cG9ydCB7TUVURVJTX1BFUl9VTklUfTtcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGlucHV0IElucHV0IGNvb3JkaW5hdGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gb3B0X291dHB1dCBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IE91dHB1dCBjb29yZGluYXRlIGFycmF5IChuZXcgYXJyYXksIHNhbWUgY29vcmRpbmF0ZVxuICogICAgIHZhbHVlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVRyYW5zZm9ybShpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICBsZXQgb3V0cHV0O1xuICBpZiAob3B0X291dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb3B0X291dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICBvdXRwdXQgPSBvcHRfb3V0cHV0O1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGlucHV0IElucHV0IGNvb3JkaW5hdGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gb3B0X291dHB1dCBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IElucHV0IGNvb3JkaW5hdGUgYXJyYXkgKHNhbWUgYXJyYXkgYXMgaW5wdXQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHlUcmFuc2Zvcm0oaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgaWYgKG9wdF9vdXRwdXQgIT09IHVuZGVmaW5lZCAmJiBpbnB1dCAhPT0gb3B0X291dHB1dCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9wdF9vdXRwdXRbaV0gPSBpbnB1dFtpXTtcbiAgICB9XG4gICAgaW5wdXQgPSBvcHRfb3V0cHV0O1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuXG4vKipcbiAqIEFkZCBhIFByb2plY3Rpb24gb2JqZWN0IHRvIHRoZSBsaXN0IG9mIHN1cHBvcnRlZCBwcm9qZWN0aW9ucyB0aGF0IGNhbiBiZVxuICogbG9va2VkIHVwIGJ5IHRoZWlyIGNvZGUuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24gaW5zdGFuY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgcHJvamVjdGlvbnMuYWRkKHByb2plY3Rpb24uZ2V0Q29kZSgpLCBwcm9qZWN0aW9uKTtcbiAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uLCBwcm9qZWN0aW9uLCBjbG9uZVRyYW5zZm9ybSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMgUHJvamVjdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucykge1xuICBwcm9qZWN0aW9ucy5mb3JFYWNoKGFkZFByb2plY3Rpb24pO1xufVxuXG5cbi8qKlxuICogRmV0Y2hlcyBhIFByb2plY3Rpb24gb2JqZWN0IGZvciB0aGUgY29kZSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbkxpa2UgRWl0aGVyIGEgY29kZSBzdHJpbmcgd2hpY2ggaXNcbiAqICAgICBhIGNvbWJpbmF0aW9uIG9mIGF1dGhvcml0eSBhbmQgaWRlbnRpZmllciBzdWNoIGFzIFwiRVBTRzo0MzI2XCIsIG9yIGFuXG4gKiAgICAgZXhpc3RpbmcgcHJvamVjdGlvbiBvYmplY3QsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IFByb2plY3Rpb24gb2JqZWN0LCBvciBudWxsIGlmIG5vdCBpbiBsaXN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHByb2plY3Rpb25MaWtlKSB7XG4gIGxldCBwcm9qZWN0aW9uID0gbnVsbDtcbiAgaWYgKHByb2plY3Rpb25MaWtlIGluc3RhbmNlb2YgUHJvamVjdGlvbikge1xuICAgIHByb2plY3Rpb24gPSBwcm9qZWN0aW9uTGlrZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvamVjdGlvbkxpa2UgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY29kZSA9IHByb2plY3Rpb25MaWtlO1xuICAgIHByb2plY3Rpb24gPSBwcm9qZWN0aW9ucy5nZXQoY29kZSk7XG4gIH1cbiAgcmV0dXJuIHByb2plY3Rpb247XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHJlc29sdXRpb24gb2YgdGhlIHBvaW50IGluIGRlZ3JlZXMgb3IgZGlzdGFuY2UgdW5pdHMuXG4gKiBGb3IgcHJvamVjdGlvbnMgd2l0aCBkZWdyZWVzIGFzIHRoZSB1bml0IHRoaXMgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZVxuICogcHJvdmlkZWQgcmVzb2x1dGlvbi4gRm9yIG90aGVyIHByb2plY3Rpb25zIHRoZSBwb2ludCByZXNvbHV0aW9uIGlzXG4gKiBieSBkZWZhdWx0IGVzdGltYXRlZCBieSB0cmFuc2Zvcm1pbmcgdGhlICdwb2ludCcgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICogbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLFxuICogYW5kIHRha2luZyB0aGUgYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAqIEEgY3VzdG9tIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZCBmb3IgYSBzcGVjaWZpYyBwcm9qZWN0aW9uLCBlaXRoZXJcbiAqIGJ5IHNldHRpbmcgdGhlIGBnZXRQb2ludFJlc29sdXRpb25gIG9wdGlvbiBpbiB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IGNvbnN0cnVjdG9yIG9yIGJ5IHVzaW5nXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9uI3NldEdldFBvaW50UmVzb2x1dGlvbn0gdG8gY2hhbmdlIGFuIGV4aXN0aW5nXG4gKiBwcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gVGhlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBOb21pbmFsIHJlc29sdXRpb24gaW4gcHJvamVjdGlvbiB1bml0cy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gcG9pbnQgUG9pbnQgdG8gZmluZCBhZGp1c3RlZCByZXNvbHV0aW9uIGF0LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Vbml0cz19IG9wdF91bml0cyBVbml0cyB0byBnZXQgdGhlIHBvaW50IHJlc29sdXRpb24gaW4uXG4gKiBEZWZhdWx0IGlzIHRoZSBwcm9qZWN0aW9uJ3MgdW5pdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBvaW50IHJlc29sdXRpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2ludFJlc29sdXRpb24ocHJvamVjdGlvbiwgcmVzb2x1dGlvbiwgcG9pbnQsIG9wdF91bml0cykge1xuICBwcm9qZWN0aW9uID0gZ2V0KHByb2plY3Rpb24pO1xuICBsZXQgcG9pbnRSZXNvbHV0aW9uO1xuICBjb25zdCBnZXR0ZXIgPSBwcm9qZWN0aW9uLmdldFBvaW50UmVzb2x1dGlvbkZ1bmMoKTtcbiAgaWYgKGdldHRlcikge1xuICAgIHBvaW50UmVzb2x1dGlvbiA9IGdldHRlcihyZXNvbHV0aW9uLCBwb2ludCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdW5pdHMgPSBwcm9qZWN0aW9uLmdldFVuaXRzKCk7XG4gICAgaWYgKHVuaXRzID09IFVuaXRzLkRFR1JFRVMgJiYgIW9wdF91bml0cyB8fCBvcHRfdW5pdHMgPT0gVW5pdHMuREVHUkVFUykge1xuICAgICAgcG9pbnRSZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXN0aW1hdGUgcG9pbnQgcmVzb2x1dGlvbiBieSB0cmFuc2Zvcm1pbmcgdGhlIGNlbnRlciBwaXhlbCB0byBFUFNHOjQzMjYsXG4gICAgICAvLyBtZWFzdXJpbmcgaXRzIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG5vcm1hbCBzcGhlcmUsIGFuZCB0YWtpbmcgdGhlXG4gICAgICAvLyBhdmVyYWdlIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgY29uc3QgdG9FUFNHNDMyNiA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhwcm9qZWN0aW9uLCBnZXQoJ0VQU0c6NDMyNicpKTtcbiAgICAgIGxldCB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgcG9pbnRbMF0gLSByZXNvbHV0aW9uIC8gMiwgcG9pbnRbMV0sXG4gICAgICAgIHBvaW50WzBdICsgcmVzb2x1dGlvbiAvIDIsIHBvaW50WzFdLFxuICAgICAgICBwb2ludFswXSwgcG9pbnRbMV0gLSByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgcG9pbnRbMF0sIHBvaW50WzFdICsgcmVzb2x1dGlvbiAvIDJcbiAgICAgIF07XG4gICAgICB2ZXJ0aWNlcyA9IHRvRVBTRzQzMjYodmVydGljZXMsIHZlcnRpY2VzLCAyKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoMCwgMiksIHZlcnRpY2VzLnNsaWNlKDIsIDQpKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGdldERpc3RhbmNlKHZlcnRpY2VzLnNsaWNlKDQsIDYpLCB2ZXJ0aWNlcy5zbGljZSg2LCA4KSk7XG4gICAgICBwb2ludFJlc29sdXRpb24gPSAod2lkdGggKyBoZWlnaHQpIC8gMjtcbiAgICAgIGNvbnN0IG1ldGVyc1BlclVuaXQgPSBvcHRfdW5pdHMgP1xuICAgICAgICBNRVRFUlNfUEVSX1VOSVRbb3B0X3VuaXRzXSA6XG4gICAgICAgIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICAgICAgaWYgKG1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludFJlc29sdXRpb24gLz0gbWV0ZXJzUGVyVW5pdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvaW50UmVzb2x1dGlvbjtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdGhhdCBkb24ndCBhbHRlciBjb29yZGluYXRlcy4gVGhvc2UgYWxsb3dcbiAqIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMgUHJvamVjdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRFcXVpdmFsZW50UHJvamVjdGlvbnMocHJvamVjdGlvbnMpIHtcbiAgYWRkUHJvamVjdGlvbnMocHJvamVjdGlvbnMpO1xuICBwcm9qZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oZGVzdGluYXRpb24pIHtcbiAgICAgIGlmIChzb3VyY2UgIT09IGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGFkZFRyYW5zZm9ybUZ1bmMoc291cmNlLCBkZXN0aW5hdGlvbiwgY2xvbmVUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gY29udmVydCBjb29yZGluYXRlcyBpbiBhbnkgcHJvamVjdGlvblxuICogaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbj59IHByb2plY3Rpb25zMSBQcm9qZWN0aW9ucyB3aXRoIGVxdWFsXG4gKiAgICAgbWVhbmluZy5cbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb24+fSBwcm9qZWN0aW9uczIgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBmb3J3YXJkVHJhbnNmb3JtIFRyYW5zZm9ybWF0aW9uIGZyb20gYW55XG4gKiAgIHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBpbnZlcnNlVHJhbnNmb3JtIFRyYW5zZm9ybSBmcm9tIGFueSBwcm9qZWN0aW9uXG4gKiAgIGluIHByb2plY3Rpb24yIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24xLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zKHByb2plY3Rpb25zMSwgcHJvamVjdGlvbnMyLCBmb3J3YXJkVHJhbnNmb3JtLCBpbnZlcnNlVHJhbnNmb3JtKSB7XG4gIHByb2plY3Rpb25zMS5mb3JFYWNoKGZ1bmN0aW9uKHByb2plY3Rpb24xKSB7XG4gICAgcHJvamVjdGlvbnMyLmZvckVhY2goZnVuY3Rpb24ocHJvamVjdGlvbjIpIHtcbiAgICAgIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbjEsIHByb2plY3Rpb24yLCBmb3J3YXJkVHJhbnNmb3JtKTtcbiAgICAgIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbjIsIHByb2plY3Rpb24xLCBpbnZlcnNlVHJhbnNmb3JtKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBDbGVhciBhbGwgY2FjaGVkIHByb2plY3Rpb25zIGFuZCB0cmFuc2Zvcm1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbGxQcm9qZWN0aW9ucygpIHtcbiAgcHJvamVjdGlvbnMuY2xlYXIoKTtcbiAgY2xlYXJUcmFuc2Zvcm1GdW5jcygpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufHN0cmluZ3x1bmRlZmluZWR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0Q29kZSBEZWZhdWx0IGNvZGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBQcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbihwcm9qZWN0aW9uLCBkZWZhdWx0Q29kZSkge1xuICBpZiAoIXByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZ2V0KGRlZmF1bHRDb2RlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvamVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2V0KHByb2plY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259ICovIChwcm9qZWN0aW9uKVxuICAgICk7XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+VHJhbnNmb3JtRnVuY3Rpb259IGZyb20gYSBzaW1wbGUgMkQgY29vcmRpbmF0ZSB0cmFuc2Zvcm1cbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlKTogbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRUcmFuc2Zvcm0gQ29vcmRpbmF0ZVxuICogICAgIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShjb29yZFRyYW5zZm9ybSkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGlucHV0IElucHV0LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBPdXRwdXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24oaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IG9wdF9kaW1lbnNpb24gIT09IHVuZGVmaW5lZCA/IG9wdF9kaW1lbnNpb24gOiAyO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gb3B0X291dHB1dCAhPT0gdW5kZWZpbmVkID8gb3B0X291dHB1dCA6IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gY29vcmRUcmFuc2Zvcm0oW2lucHV0W2ldLCBpbnB1dFtpICsgMV1dKTtcbiAgICAgICAgb3V0cHV0W2ldID0gcG9pbnRbMF07XG4gICAgICAgIG91dHB1dFtpICsgMV0gPSBwb2ludFsxXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGRpbWVuc2lvbiAtIDE7IGogPj0gMjsgLS1qKSB7XG4gICAgICAgICAgb3V0cHV0W2kgKyBqXSA9IGlucHV0W2kgKyBqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyBjb29yZGluYXRlIHRyYW5zZm9ybSBmdW5jdGlvbnMgdG8gY29udmVydCBjb29yZGluYXRlcyBiZXR3ZWVuIHRoZVxuICogc291cmNlIHByb2plY3Rpb24gYW5kIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogVGhlIGZvcndhcmQgYW5kIGludmVyc2UgZnVuY3Rpb25zIGNvbnZlcnQgY29vcmRpbmF0ZSBwYWlyczsgdGhpcyBmdW5jdGlvblxuICogY29udmVydHMgdGhlc2UgaW50byB0aGUgZnVuY3Rpb25zIHVzZWQgaW50ZXJuYWxseSB3aGljaCBhbHNvIGhhbmRsZVxuICogZXh0ZW50cyBhbmQgY29vcmRpbmF0ZSBhcnJheXMuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSk6IG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGZvcndhcmQgVGhlIGZvcndhcmQgdHJhbnNmb3JtXG4gKiAgICAgZnVuY3Rpb24gKHRoYXQgaXMsIGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvblxuICogICAgIHByb2plY3Rpb24pIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnNcbiAqICAgICB0aGUgdHJhbnNmb3JtZWQge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9LlxuICogQHBhcmFtIHtmdW5jdGlvbihtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlKTogbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gaW52ZXJzZSBUaGUgaW52ZXJzZSB0cmFuc2Zvcm1cbiAqICAgICBmdW5jdGlvbiAodGhhdCBpcywgZnJvbSB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbiB0byB0aGUgc291cmNlXG4gKiAgICAgcHJvamVjdGlvbikgdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogICAgIHRoZSB0cmFuc2Zvcm1lZCB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb29yZGluYXRlVHJhbnNmb3Jtcyhzb3VyY2UsIGRlc3RpbmF0aW9uLCBmb3J3YXJkLCBpbnZlcnNlKSB7XG4gIGNvbnN0IHNvdXJjZVByb2ogPSBnZXQoc291cmNlKTtcbiAgY29uc3QgZGVzdFByb2ogPSBnZXQoZGVzdGluYXRpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKHNvdXJjZVByb2osIGRlc3RQcm9qLCBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShmb3J3YXJkKSk7XG4gIGFkZFRyYW5zZm9ybUZ1bmMoZGVzdFByb2osIHNvdXJjZVByb2osIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGludmVyc2UpKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gbG9uZ2l0dWRlL2xhdGl0dWRlIHRvIGEgZGlmZmVyZW50IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZSBhcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLCBpLmUuXG4gKiAgICAgYW4gYXJyYXkgd2l0aCBsb25naXR1ZGUgYXMgMXN0IGFuZCBsYXRpdHVkZSBhcyAybmQgZWxlbWVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2U9fSBvcHRfcHJvamVjdGlvbiBUYXJnZXQgcHJvamVjdGlvbi4gVGhlXG4gKiAgICAgZGVmYXVsdCBpcyBXZWIgTWVyY2F0b3IsIGkuZS4gJ0VQU0c6Mzg1NycuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBDb29yZGluYXRlIHByb2plY3RlZCB0byB0aGUgdGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTG9uTGF0KGNvb3JkaW5hdGUsIG9wdF9wcm9qZWN0aW9uKSB7XG4gIHJldHVybiB0cmFuc2Zvcm0oY29vcmRpbmF0ZSwgJ0VQU0c6NDMyNicsXG4gICAgb3B0X3Byb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IG9wdF9wcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NycpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgdG8gbG9uZ2l0dWRlL2xhdGl0dWRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIFByb2plY3RlZCBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZT19IG9wdF9wcm9qZWN0aW9uIFByb2plY3Rpb24gb2YgdGhlIGNvb3JkaW5hdGUuXG4gKiAgICAgVGhlIGRlZmF1bHQgaXMgV2ViIE1lcmNhdG9yLCBpLmUuICdFUFNHOjM4NTcnLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZSBhcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLCBpLmUuIGFuIGFycmF5XG4gKiAgICAgd2l0aCBsb25naXR1ZGUgYXMgMXN0IGFuZCBsYXRpdHVkZSBhcyAybmQgZWxlbWVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTG9uTGF0KGNvb3JkaW5hdGUsIG9wdF9wcm9qZWN0aW9uKSB7XG4gIGNvbnN0IGxvbkxhdCA9IHRyYW5zZm9ybShjb29yZGluYXRlLFxuICAgIG9wdF9wcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRfcHJvamVjdGlvbiA6ICdFUFNHOjM4NTcnLCAnRVBTRzo0MzI2Jyk7XG4gIGNvbnN0IGxvbiA9IGxvbkxhdFswXTtcbiAgaWYgKGxvbiA8IC0xODAgfHwgbG9uID4gMTgwKSB7XG4gICAgbG9uTGF0WzBdID0gbW9kdWxvKGxvbiArIDE4MCwgMzYwKSAtIDE4MDtcbiAgfVxuICByZXR1cm4gbG9uTGF0O1xufVxuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBwcm9qZWN0aW9ucyBhcmUgdGhlIHNhbWUsIHRoYXQgaXMgZXZlcnkgY29vcmRpbmF0ZSBpbiBvbmVcbiAqIHByb2plY3Rpb24gZG9lcyByZXByZXNlbnQgdGhlIHNhbWUgZ2VvZ3JhcGhpYyBwb2ludCBhcyB0aGUgc2FtZSBjb29yZGluYXRlIGluXG4gKiB0aGUgb3RoZXIgcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24xIFByb2plY3Rpb24gMS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbjIgUHJvamVjdGlvbiAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gRXF1aXZhbGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWl2YWxlbnQocHJvamVjdGlvbjEsIHByb2plY3Rpb24yKSB7XG4gIGlmIChwcm9qZWN0aW9uMSA9PT0gcHJvamVjdGlvbjIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBlcXVhbFVuaXRzID0gcHJvamVjdGlvbjEuZ2V0VW5pdHMoKSA9PT0gcHJvamVjdGlvbjIuZ2V0VW5pdHMoKTtcbiAgaWYgKHByb2plY3Rpb24xLmdldENvZGUoKSA9PT0gcHJvamVjdGlvbjIuZ2V0Q29kZSgpKSB7XG4gICAgcmV0dXJuIGVxdWFsVW5pdHM7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1GdW5jID09PSBjbG9uZVRyYW5zZm9ybSAmJiBlcXVhbFVuaXRzO1xuICB9XG59XG5cblxuLyoqXG4gKiBTZWFyY2hlcyBpbiB0aGUgbGlzdCBvZiB0cmFuc2Zvcm0gZnVuY3Rpb25zIGZvciB0aGUgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmdcbiAqIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gc291cmNlUHJvamVjdGlvbiBTb3VyY2UgUHJvamVjdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IGRlc3RpbmF0aW9uUHJvamVjdGlvbiBEZXN0aW5hdGlvbiBQcm9qZWN0aW9uXG4gKiAgICAgb2JqZWN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3Byb2p+VHJhbnNmb3JtRnVuY3Rpb259IFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhzb3VyY2VQcm9qZWN0aW9uLCBkZXN0aW5hdGlvblByb2plY3Rpb24pIHtcbiAgY29uc3Qgc291cmNlQ29kZSA9IHNvdXJjZVByb2plY3Rpb24uZ2V0Q29kZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvblByb2plY3Rpb24uZ2V0Q29kZSgpO1xuICBsZXQgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybUZ1bmMoc291cmNlQ29kZSwgZGVzdGluYXRpb25Db2RlKTtcbiAgaWYgKCF0cmFuc2Zvcm1GdW5jKSB7XG4gICAgdHJhbnNmb3JtRnVuYyA9IGlkZW50aXR5VHJhbnNmb3JtO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jO1xufVxuXG5cbi8qKlxuICogR2l2ZW4gdGhlIHByb2plY3Rpb24tbGlrZSBvYmplY3RzLCBzZWFyY2hlcyBmb3IgYSB0cmFuc2Zvcm1hdGlvblxuICogZnVuY3Rpb24gdG8gY29udmVydCBhIGNvb3JkaW5hdGVzIGFycmF5IGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZVxuICogZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgY29uc3Qgc291cmNlUHJvamVjdGlvbiA9IGdldChzb3VyY2UpO1xuICBjb25zdCBkZXN0aW5hdGlvblByb2plY3Rpb24gPSBnZXQoZGVzdGluYXRpb24pO1xuICByZXR1cm4gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbik7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSBmcm9tIHNvdXJjZSBwcm9qZWN0aW9uIHRvIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBUaGlzIHJldHVybnMgYSBuZXcgY29vcmRpbmF0ZSAoYW5kIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwpLlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+dHJhbnNmb3JtRXh0ZW50fSBmb3IgZXh0ZW50IHRyYW5zZm9ybWF0aW9uLlxuICogU2VlIHRoZSB0cmFuc2Zvcm0gbWV0aG9kIG9mIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeX5HZW9tZXRyeX0gYW5kIGl0c1xuICogc3ViY2xhc3NlcyBmb3IgZ2VvbWV0cnkgdHJhbnNmb3Jtcy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShjb29yZGluYXRlLCBzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKGNvb3JkaW5hdGUsIHVuZGVmaW5lZCwgY29vcmRpbmF0ZS5sZW5ndGgpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBleHRlbnQgZnJvbSBzb3VyY2UgcHJvamVjdGlvbiB0byBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLiAgVGhpc1xuICogcmV0dXJucyBhIG5ldyBleHRlbnQgKGFuZCBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsKS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudCB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24tbGlrZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24tbGlrZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBUaGUgdHJhbnNmb3JtZWQgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRXh0ZW50KGV4dGVudCwgc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0oZXh0ZW50LCB0cmFuc2Zvcm1GdW5jKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIHBvaW50IHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gcG9pbnQgUG9pbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHNvdXJjZVByb2plY3Rpb24gU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IGRlc3RpbmF0aW9uUHJvamVjdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gUG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1XaXRoUHJvamVjdGlvbnMocG9pbnQsIHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbikge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbik7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKHBvaW50KTtcbn1cblxuLyoqXG4gKiBBZGQgdHJhbnNmb3JtcyB0byBhbmQgZnJvbSBFUFNHOjQzMjYgYW5kIEVQU0c6Mzg1Ny4gIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG4gKiBieSB3aGVuIHRoaXMgbW9kdWxlIGlzIGV4ZWN1dGVkIGFuZCBzaG91bGQgb25seSBuZWVkIHRvIGJlIGNhbGxlZCBhZ2FpbiBhZnRlclxuICogYGNsZWFyQWxsUHJvamVjdGlvbnMoKWAgaXMgY2FsbGVkIChlLmcuIGluIHRlc3RzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbW1vbigpIHtcbiAgLy8gQWRkIHRyYW5zZm9ybWF0aW9ucyB0aGF0IGRvbid0IGFsdGVyIGNvb3JkaW5hdGVzIHRvIGNvbnZlcnQgd2l0aGluIHNldCBvZlxuICAvLyBwcm9qZWN0aW9ucyB3aXRoIGVxdWFsIG1lYW5pbmcuXG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHMzg1N19QUk9KRUNUSU9OUyk7XG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHNDMyNl9QUk9KRUNUSU9OUyk7XG4gIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnMgdG8gY29udmVydCBFUFNHOjQzMjYgbGlrZSBjb29yZGluYXRlcyB0byBFUFNHOjM4NTcgbGlrZVxuICAvLyBjb29yZGluYXRlcyBhbmQgYmFjay5cbiAgYWRkRXF1aXZhbGVudFRyYW5zZm9ybXMoRVBTRzQzMjZfUFJPSkVDVElPTlMsIEVQU0czODU3X1BST0pFQ1RJT05TLCBmcm9tRVBTRzQzMjYsIHRvRVBTRzQzMjYpO1xufVxuXG5hZGRDb21tb24oKTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL1Byb2plY3Rpb25cbiAqL1xuaW1wb3J0IHtNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4uL3Byb2ovVW5pdHMuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgVGhlIFNSUyBpZGVudGlmaWVyIGNvZGUsIGUuZy4gYEVQU0c6NDMyNmAuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9wcm9qL1VuaXRzfHN0cmluZ30gW3VuaXRzXSBVbml0cy4gUmVxdWlyZWQgdW5sZXNzIGFcbiAqIHByb2o0IHByb2plY3Rpb24gaXMgZGVmaW5lZCBmb3IgYGNvZGVgLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF0gVGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhlIFNSUy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXhpc09yaWVudGF0aW9uPSdlbnUnXSBUaGUgYXhpcyBvcmllbnRhdGlvbiBhcyBzcGVjaWZpZWQgaW4gUHJvajQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtnbG9iYWw9ZmFsc2VdIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgdmFsaWQgZm9yIHRoZSB3aG9sZSBnbG9iZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWV0ZXJzUGVyVW5pdF0gVGhlIG1ldGVycyBwZXIgdW5pdCBmb3IgdGhlIFNSUy5cbiAqIElmIG5vdCBwcm92aWRlZCwgdGhlIGB1bml0c2AgYXJlIHVzZWQgdG8gZ2V0IHRoZSBtZXRlcnMgcGVyIHVuaXQgZnJvbSB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1VuaXRzfk1FVEVSU19QRVJfVU5JVH1cbiAqIGxvb2t1cCB0YWJsZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IFt3b3JsZEV4dGVudF0gVGhlIHdvcmxkIGV4dGVudCBmb3IgdGhlIFNSUy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyLCBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlKTpudW1iZXJ9IFtnZXRQb2ludFJlc29sdXRpb25dXG4gKiBGdW5jdGlvbiB0byBkZXRlcm1pbmUgcmVzb2x1dGlvbiBhdCBhIHBvaW50LiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICogYHtudW1iZXJ9YCB2aWV3IHJlc29sdXRpb24gYW5kIGFuIGB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX1gIGFzIGFyZ3VtZW50cywgYW5kIHJldHVybnNcbiAqIHRoZSBge251bWJlcn1gIHJlc29sdXRpb24gYXQgdGhlIHBhc3NlZCBjb29yZGluYXRlLiBJZiB0aGlzIGlzIGB1bmRlZmluZWRgLFxuICogdGhlIGRlZmF1bHQge0BsaW5rIG1vZHVsZTpvbC9wcm9qI2dldFBvaW50UmVzb2x1dGlvbn0gZnVuY3Rpb24gd2lsbCBiZSB1c2VkLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9qZWN0aW9uIGRlZmluaXRpb24gY2xhc3MuIE9uZSBvZiB0aGVzZSBpcyBjcmVhdGVkIGZvciBlYWNoIHByb2plY3Rpb25cbiAqIHN1cHBvcnRlZCBpbiB0aGUgYXBwbGljYXRpb24gYW5kIHN0b3JlZCBpbiB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qfSBuYW1lc3BhY2UuXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBpbiBhcHBsaWNhdGlvbnMsIGJ1dCB0aGlzIGlzIG5vdCByZXF1aXJlZCwgYXMgQVBJIHBhcmFtc1xuICogYW5kIG9wdGlvbnMgdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gd2hpY2ggbWVhbnMgdGhlIHNpbXBsZSBzdHJpbmdcbiAqIGNvZGUgd2lsbCBzdWZmaWNlLlxuICpcbiAqIFlvdSBjYW4gdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvan5nZXR9IHRvIHJldHJpZXZlIHRoZSBvYmplY3QgZm9yIGEgcGFydGljdWxhclxuICogcHJvamVjdGlvbi5cbiAqXG4gKiBUaGUgbGlicmFyeSBpbmNsdWRlcyBkZWZpbml0aW9ucyBmb3IgYEVQU0c6NDMyNmAgYW5kIGBFUFNHOjM4NTdgLCB0b2dldGhlclxuICogd2l0aCB0aGUgZm9sbG93aW5nIGFsaWFzZXM6XG4gKiAqIGBFUFNHOjQzMjZgOiBDUlM6ODQsIHVybjpvZ2M6ZGVmOmNyczpFUFNHOjYuNjo0MzI2LFxuICogICAgIHVybjpvZ2M6ZGVmOmNyczpPR0M6MS4zOkNSUzg0LCB1cm46b2djOmRlZjpjcnM6T0dDOjI6ODQsXG4gKiAgICAgaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzQzMjYsXG4gKiAgICAgdXJuOngtb2djOmRlZjpjcnM6RVBTRzo0MzI2XG4gKiAqIGBFUFNHOjM4NTdgOiBFUFNHOjEwMjEwMCwgRVBTRzoxMDIxMTMsIEVQU0c6OTAwOTEzLFxuICogICAgIHVybjpvZ2M6ZGVmOmNyczpFUFNHOjYuMTg6MzozODU3LFxuICogICAgIGh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCMzODU3XG4gKlxuICogSWYgeW91IHVzZSBwcm9qNGpzLCBhbGlhc2VzIGNhbiBiZSBhZGRlZCB1c2luZyBgcHJvajQuZGVmcygpYDsgc2VlXG4gKiBbZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL3Byb2o0anMvcHJvajRqcykuIFRvIHNldCBhbiBhbHRlcm5hdGl2ZVxuICogbmFtZXNwYWNlIGZvciBwcm9qNCwgdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvan5zZXRQcm9qNH0uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+T3B0aW9uc30gb3B0aW9ucyBQcm9qZWN0aW9uIG9wdGlvbnMuXG4gKiBAc3RydWN0XG4gKiBAYXBpXG4gKi9cbmNvbnN0IFByb2plY3Rpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5jb2RlXyA9IG9wdGlvbnMuY29kZTtcblxuICAvKipcbiAgICogVW5pdHMgb2YgcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBXaGVuIHNldCB0byBgVElMRV9QSVhFTFNgLCBhXG4gICAqIGB0aGlzLmV4dGVudF9gIGFuZCBgdGhpcy53b3JsZEV4dGVudF9gIG11c3QgYmUgY29uZmlndXJlZCBwcm9wZXJseSBmb3IgZWFjaFxuICAgKiB0aWxlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL3Byb2ovVW5pdHN9XG4gICAqL1xuICB0aGlzLnVuaXRzXyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3Byb2ovVW5pdHN9ICovIChvcHRpb25zLnVuaXRzKTtcblxuICAvKipcbiAgICogVmFsaWRpdHkgZXh0ZW50IG9mIHRoZSBwcm9qZWN0aW9uIGluIHByb2plY3RlZCBjb29yZGluYXRlcy4gRm9yIHByb2plY3Rpb25zXG4gICAqIHdpdGggYFRJTEVfUElYRUxTYCB1bml0cywgdGhpcyBpcyB0aGUgZXh0ZW50IG9mIHRoZSB0aWxlIGluXG4gICAqIHRpbGUgcGl4ZWwgc3BhY2UuXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH1cbiAgICovXG4gIHRoaXMuZXh0ZW50XyA9IG9wdGlvbnMuZXh0ZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmV4dGVudCA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEV4dGVudCBvZiB0aGUgd29ybGQgaW4gRVBTRzo0MzI2LiBGb3IgcHJvamVjdGlvbnMgd2l0aFxuICAgKiBgVElMRV9QSVhFTFNgIHVuaXRzLCB0aGlzIGlzIHRoZSBleHRlbnQgb2YgdGhlIHRpbGUgaW5cbiAgICogcHJvamVjdGVkIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH1cbiAgICovXG4gIHRoaXMud29ybGRFeHRlbnRfID0gb3B0aW9ucy53b3JsZEV4dGVudCAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLndvcmxkRXh0ZW50IDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuYXhpc09yaWVudGF0aW9uXyA9IG9wdGlvbnMuYXhpc09yaWVudGF0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMuYXhpc09yaWVudGF0aW9uIDogJ2VudSc7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5nbG9iYWxfID0gb3B0aW9ucy5nbG9iYWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2xvYmFsIDogZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgdGhpcy5leHRlbnRfKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlciwgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSk6bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBvcHRpb25zLmdldFBvaW50UmVzb2x1dGlvbjtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH1cbiAgICovXG4gIHRoaXMuZGVmYXVsdFRpbGVHcmlkXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy5tZXRlcnNQZXJVbml0XyA9IG9wdGlvbnMubWV0ZXJzUGVyVW5pdDtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcHJvamVjdGlvbiBpcyBzdWl0YWJsZSBmb3Igd3JhcHBpbmcgdGhlIHgtYXhpc1xuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5jYW5XcmFwWCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jYW5XcmFwWF87XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIGZvciB0aGlzIHByb2plY3Rpb24sIGUuZy4gJ0VQU0c6NDMyNicuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvZGUuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldENvZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29kZV87XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB2YWxpZGl0eSBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5leHRlbnRfO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdW5pdHMgb2YgdGhpcyBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3Byb2ovVW5pdHN9IFVuaXRzLlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRVbml0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy51bml0c187XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBhbW91bnQgb2YgbWV0ZXJzIHBlciB1bml0IG9mIHRoaXMgcHJvamVjdGlvbi4gIElmIHRoZSBwcm9qZWN0aW9uIGlzXG4gKiBub3QgY29uZmlndXJlZCB3aXRoIGBtZXRlcnNQZXJVbml0YCBvciBhIHVuaXRzIGlkZW50aWZpZXIsIHRoZSByZXR1cm4gaXNcbiAqIGB1bmRlZmluZWRgLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gTWV0ZXJzLlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRNZXRlcnNQZXJVbml0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm1ldGVyc1BlclVuaXRfIHx8IE1FVEVSU19QRVJfVU5JVFt0aGlzLnVuaXRzX107XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB3b3JsZCBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldFdvcmxkRXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndvcmxkRXh0ZW50Xztcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGF4aXMgb3JpZW50YXRpb24gb2YgdGhpcyBwcm9qZWN0aW9uLlxuICogRXhhbXBsZSB2YWx1ZXMgYXJlOlxuICogZW51IC0gdGhlIGRlZmF1bHQgZWFzdGluZywgbm9ydGhpbmcsIGVsZXZhdGlvbi5cbiAqIG5ldSAtIG5vcnRoaW5nLCBlYXN0aW5nLCB1cCAtIHVzZWZ1bCBmb3IgXCJsYXQvbG9uZ1wiIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMsXG4gKiAgICAgb3Igc291dGggb3JpZW50YXRlZCB0cmFuc3ZlcnNlIG1lcmNhdG9yLlxuICogd251IC0gd2VzdGluZywgbm9ydGhpbmcsIHVwIC0gc29tZSBwbGFuZXRhcnkgY29vcmRpbmF0ZSBzeXN0ZW1zIGhhdmVcbiAqICAgICBcIndlc3QgcG9zaXRpdmVcIiBjb29yZGluYXRlIHN5c3RlbXNcbiAqIEByZXR1cm4ge3N0cmluZ30gQXhpcyBvcmllbnRhdGlvbi5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0QXhpc09yaWVudGF0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmF4aXNPcmllbnRhdGlvbl87XG59O1xuXG5cbi8qKlxuICogSXMgdGhpcyBwcm9qZWN0aW9uIGEgZ2xvYmFsIHByb2plY3Rpb24gd2hpY2ggc3BhbnMgdGhlIHdob2xlIHdvcmxkP1xuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyBnbG9iYWwuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmlzR2xvYmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdsb2JhbF87XG59O1xuXG5cbi8qKlxuKiBTZXQgaWYgdGhlIHByb2plY3Rpb24gaXMgYSBnbG9iYWwgcHJvamVjdGlvbiB3aGljaCBzcGFucyB0aGUgd2hvbGUgd29ybGRcbiogQHBhcmFtIHtib29sZWFufSBnbG9iYWwgV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyBnbG9iYWwuXG4qIEBhcGlcbiovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5zZXRHbG9iYWwgPSBmdW5jdGlvbihnbG9iYWwpIHtcbiAgdGhpcy5nbG9iYWxfID0gZ2xvYmFsO1xuICB0aGlzLmNhbldyYXBYXyA9ICEhKGdsb2JhbCAmJiB0aGlzLmV4dGVudF8pO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXREZWZhdWx0VGlsZUdyaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGVmYXVsdFRpbGVHcmlkXztcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gdGlsZUdyaWQgVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5zZXREZWZhdWx0VGlsZUdyaWQgPSBmdW5jdGlvbih0aWxlR3JpZCkge1xuICB0aGlzLmRlZmF1bHRUaWxlR3JpZF8gPSB0aWxlR3JpZDtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuc2V0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50KSB7XG4gIHRoaXMuZXh0ZW50XyA9IGV4dGVudDtcbiAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgZXh0ZW50KTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gd29ybGRFeHRlbnQgV29ybGQgZXh0ZW50XG4gKiAgICAgW21pbmxvbiwgbWlubGF0LCBtYXhsb24sIG1heGxhdF0uXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLnNldFdvcmxkRXh0ZW50ID0gZnVuY3Rpb24od29ybGRFeHRlbnQpIHtcbiAgdGhpcy53b3JsZEV4dGVudF8gPSB3b3JsZEV4dGVudDtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGdldFBvaW50UmVzb2x1dGlvbiBmdW5jdGlvbiAoc2VlIHtAbGluayBtb2R1bGU6b2wvcHJvan5nZXRQb2ludFJlc29sdXRpb259XG4gKiBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOm51bWJlcn0gZnVuYyBGdW5jdGlvblxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5zZXRHZXRQb2ludFJlc29sdXRpb24gPSBmdW5jdGlvbihmdW5jKSB7XG4gIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBmdW5jO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgY3VzdG9tIHBvaW50IHJlc29sdXRpb24gZnVuY3Rpb24gZm9yIHRoaXMgcHJvamVjdGlvbiAoaWYgc2V0KS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlciwgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSk6bnVtYmVyfHVuZGVmaW5lZH0gVGhlIGN1c3RvbSBwb2ludFxuICogcmVzb2x1dGlvbiBmdW5jdGlvbiAoaWYgc2V0KS5cbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuYyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXztcbn07XG5leHBvcnQgZGVmYXVsdCBQcm9qZWN0aW9uO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovVW5pdHNcbiAqL1xuXG4vKipcbiAqIFByb2plY3Rpb24gdW5pdHM6IGAnZGVncmVlcydgLCBgJ2Z0J2AsIGAnbSdgLCBgJ3BpeGVscydgLCBgJ3RpbGUtcGl4ZWxzJ2Agb3JcbiAqIGAndXMtZnQnYC5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFVuaXRzID0ge1xuICBERUdSRUVTOiAnZGVncmVlcycsXG4gIEZFRVQ6ICdmdCcsXG4gIE1FVEVSUzogJ20nLFxuICBQSVhFTFM6ICdwaXhlbHMnLFxuICBUSUxFX1BJWEVMUzogJ3RpbGUtcGl4ZWxzJyxcbiAgVVNGRUVUOiAndXMtZnQnXG59O1xuXG5cbi8qKlxuICogTWV0ZXJzIHBlciB1bml0IGxvb2t1cCB0YWJsZS5cbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdC48bW9kdWxlOm9sL3Byb2ovVW5pdHMsIG51bWJlcj59XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBNRVRFUlNfUEVSX1VOSVQgPSB7fTtcbi8vIHVzZSB0aGUgcmFkaXVzIG9mIHRoZSBOb3JtYWwgc3BoZXJlXG5NRVRFUlNfUEVSX1VOSVRbVW5pdHMuREVHUkVFU10gPSAyICogTWF0aC5QSSAqIDYzNzA5OTcgLyAzNjA7XG5NRVRFUlNfUEVSX1VOSVRbVW5pdHMuRkVFVF0gPSAwLjMwNDg7XG5NRVRFUlNfUEVSX1VOSVRbVW5pdHMuTUVURVJTXSA9IDE7XG5NRVRFUlNfUEVSX1VOSVRbVW5pdHMuVVNGRUVUXSA9IDEyMDAgLyAzOTM3O1xuXG5leHBvcnQgZGVmYXVsdCBVbml0cztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL2Vwc2czODU3XG4gKi9cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJy4uL2luZGV4LmpzJztcbmltcG9ydCB7Y29zaH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuLi9wcm9qL1Byb2plY3Rpb24uanMnO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4uL3Byb2ovVW5pdHMuanMnO1xuXG5cbi8qKlxuICogUmFkaXVzIG9mIFdHUzg0IHNwaGVyZVxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFJBRElVUyA9IDYzNzgxMzc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBIQUxGX1NJWkUgPSBNYXRoLlBJICogUkFESVVTO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBFWFRFTlQgPSBbXG4gIC1IQUxGX1NJWkUsIC1IQUxGX1NJWkUsXG4gIEhBTEZfU0laRSwgSEFMRl9TSVpFXG5dO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBXT1JMRF9FWFRFTlQgPSBbLTE4MCwgLTg1LCAxODAsIDg1XTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb2plY3Rpb24gb2JqZWN0IGZvciB3ZWIvc3BoZXJpY2FsIE1lcmNhdG9yIChFUFNHOjM4NTcpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBDb2RlLlxuICovXG5mdW5jdGlvbiBFUFNHMzg1N1Byb2plY3Rpb24oY29kZSkge1xuICBQcm9qZWN0aW9uLmNhbGwodGhpcywge1xuICAgIGNvZGU6IGNvZGUsXG4gICAgdW5pdHM6IFVuaXRzLk1FVEVSUyxcbiAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgd29ybGRFeHRlbnQ6IFdPUkxEX0VYVEVOVCxcbiAgICBnZXRQb2ludFJlc29sdXRpb246IGZ1bmN0aW9uKHJlc29sdXRpb24sIHBvaW50KSB7XG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiAvIGNvc2gocG9pbnRbMV0gLyBSQURJVVMpO1xuICAgIH1cbiAgfSk7XG59XG5pbmhlcml0cyhFUFNHMzg1N1Byb2plY3Rpb24sIFByb2plY3Rpb24pO1xuXG5cbi8qKlxuICogUHJvamVjdGlvbnMgZXF1YWwgdG8gRVBTRzozODU3LlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uPn1cbiAqL1xuZXhwb3J0IGNvbnN0IFBST0pFQ1RJT05TID0gW1xuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzoxMDIxMDAnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzoxMDIxMTMnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzo5MDA5MTMnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni4xODozOjM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6OjM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzM4NTcnKVxuXTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIGZyb20gRVBTRzo0MzI2IHRvIEVQU0c6Mzg1Ny5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBpbnB1dCBJbnB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24gKGRlZmF1bHQgaXMgYDJgKS5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRVBTRzQzMjYoaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBjb25zdCBkaW1lbnNpb24gPSBvcHRfZGltZW5zaW9uID4gMSA/IG9wdF9kaW1lbnNpb24gOiAyO1xuICBsZXQgb3V0cHV0ID0gb3B0X291dHB1dDtcbiAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRpbWVuc2lvbiA+IDIpIHtcbiAgICAgIC8vIHByZXNlcnZlIHZhbHVlcyBiZXlvbmQgc2Vjb25kIGRpbWVuc2lvblxuICAgICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhbGZTaXplID0gSEFMRl9TSVpFO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBkaW1lbnNpb24pIHtcbiAgICBvdXRwdXRbaV0gPSBoYWxmU2l6ZSAqIGlucHV0W2ldIC8gMTgwO1xuICAgIGxldCB5ID0gUkFESVVTICpcbiAgICAgICAgTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAqIChpbnB1dFtpICsgMV0gKyA5MCkgLyAzNjApKTtcbiAgICBpZiAoeSA+IGhhbGZTaXplKSB7XG4gICAgICB5ID0gaGFsZlNpemU7XG4gICAgfSBlbHNlIGlmICh5IDwgLWhhbGZTaXplKSB7XG4gICAgICB5ID0gLWhhbGZTaXplO1xuICAgIH1cbiAgICBvdXRwdXRbaSArIDFdID0geTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjM4NTcgdG8gRVBTRzo0MzI2LlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGlucHV0IElucHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IG9wdF9vdXRwdXQgT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGltZW5zaW9uIERpbWVuc2lvbiAoZGVmYXVsdCBpcyBgMmApLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRVBTRzQzMjYoaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBjb25zdCBkaW1lbnNpb24gPSBvcHRfZGltZW5zaW9uID4gMSA/IG9wdF9kaW1lbnNpb24gOiAyO1xuICBsZXQgb3V0cHV0ID0gb3B0X291dHB1dDtcbiAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRpbWVuc2lvbiA+IDIpIHtcbiAgICAgIC8vIHByZXNlcnZlIHZhbHVlcyBiZXlvbmQgc2Vjb25kIGRpbWVuc2lvblxuICAgICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGRpbWVuc2lvbikge1xuICAgIG91dHB1dFtpXSA9IDE4MCAqIGlucHV0W2ldIC8gSEFMRl9TSVpFO1xuICAgIG91dHB1dFtpICsgMV0gPSAzNjAgKiBNYXRoLmF0YW4oXG4gICAgICBNYXRoLmV4cChpbnB1dFtpICsgMV0gLyBSQURJVVMpKSAvIE1hdGguUEkgLSA5MDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovZXBzZzQzMjZcbiAqL1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi4vcHJvai9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuLi9wcm9qL1VuaXRzLmpzJztcblxuXG4vKipcbiAqIFNlbWktbWFqb3IgcmFkaXVzIG9mIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgUkFESVVTID0gNjM3ODEzNztcblxuXG4vKipcbiAqIEV4dGVudCBvZiB0aGUgRVBTRzo0MzI2IHByb2plY3Rpb24gd2hpY2ggaXMgdGhlIHdob2xlIHdvcmxkLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICovXG5leHBvcnQgY29uc3QgRVhURU5UID0gWy0xODAsIC05MCwgMTgwLCA5MF07XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBNRVRFUlNfUEVSX1VOSVQgPSBNYXRoLlBJICogUkFESVVTIC8gMTgwO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIFdHUzg0IGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMgKEVQU0c6NDMyNikuXG4gKlxuICogTm90ZSB0aGF0IE9wZW5MYXllcnMgZG9lcyBub3Qgc3RyaWN0bHkgY29tcGx5IHdpdGggdGhlIEVQU0cgZGVmaW5pdGlvbi5cbiAqIFRoZSBFUFNHIHJlZ2lzdHJ5IGRlZmluZXMgNDMyNiBhcyBhIENSUyBmb3IgTGF0aXR1ZGUsTG9uZ2l0dWRlICh5LHgpLlxuICogT3BlbkxheWVycyB0cmVhdHMgRVBTRzo0MzI2IGFzIGEgcHNldWRvLXByb2plY3Rpb24sIHdpdGggeCx5IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBDb2RlLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYXhpc09yaWVudGF0aW9uIEF4aXMgb3JpZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIEVQU0c0MzI2UHJvamVjdGlvbihjb2RlLCBvcHRfYXhpc09yaWVudGF0aW9uKSB7XG4gIFByb2plY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgY29kZTogY29kZSxcbiAgICB1bml0czogVW5pdHMuREVHUkVFUyxcbiAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICBheGlzT3JpZW50YXRpb246IG9wdF9heGlzT3JpZW50YXRpb24sXG4gICAgZ2xvYmFsOiB0cnVlLFxuICAgIG1ldGVyc1BlclVuaXQ6IE1FVEVSU19QRVJfVU5JVCxcbiAgICB3b3JsZEV4dGVudDogRVhURU5UXG4gIH0pO1xufVxuaW5oZXJpdHMoRVBTRzQzMjZQcm9qZWN0aW9uLCBQcm9qZWN0aW9uKTtcblxuXG4vKipcbiAqIFByb2plY3Rpb25zIGVxdWFsIHRvIEVQU0c6NDMyNi5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbj59XG4gKi9cbmV4cG9ydCBjb25zdCBQUk9KRUNUSU9OUyA9IFtcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignQ1JTOjg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ0VQU0c6NDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6OjQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjYuNjo0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6T0dDOjEuMzpDUlM4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6T0dDOjI6ODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3Vybjp4LW9nYzpkZWY6Y3JzOkVQU0c6NDMyNicsICduZXUnKVxuXTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3Byb2plY3Rpb25zXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbj59XG4gKi9cbmxldCBjYWNoZSA9IHt9O1xuXG5cbi8qKlxuICogQ2xlYXIgdGhlIHByb2plY3Rpb25zIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGNhY2hlID0ge307XG59XG5cblxuLyoqXG4gKiBHZXQgYSBjYWNoZWQgcHJvamVjdGlvbiBieSBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgVGhlIGNvZGUgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gVGhlIHByb2plY3Rpb24gKGlmIGNhY2hlZCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoY29kZSkge1xuICByZXR1cm4gY2FjaGVbY29kZV0gfHwgbnVsbDtcbn1cblxuXG4vKipcbiAqIEFkZCBhIHByb2plY3Rpb24gdG8gdGhlIGNhY2hlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgVGhlIHByb2plY3Rpb24gY29kZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBUaGUgcHJvamVjdGlvbiB0byBjYWNoZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChjb2RlLCBwcm9qZWN0aW9uKSB7XG4gIGNhY2hlW2NvZGVdID0gcHJvamVjdGlvbjtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3RyYW5zZm9ybXNcbiAqL1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIE9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbj4+fVxuICovXG5sZXQgdHJhbnNmb3JtcyA9IHt9O1xuXG5cbi8qKlxuICogQ2xlYXIgdGhlIHRyYW5zZm9ybSBjYWNoZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuICB0cmFuc2Zvcm1zID0ge307XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gc291cmNlIFNvdXJjZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gZGVzdGluYXRpb24gRGVzdGluYXRpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoc291cmNlLCBkZXN0aW5hdGlvbiwgdHJhbnNmb3JtRm4pIHtcbiAgY29uc3Qgc291cmNlQ29kZSA9IHNvdXJjZS5nZXRDb2RlKCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uLmdldENvZGUoKTtcbiAgaWYgKCEoc291cmNlQ29kZSBpbiB0cmFuc2Zvcm1zKSkge1xuICAgIHRyYW5zZm9ybXNbc291cmNlQ29kZV0gPSB7fTtcbiAgfVxuICB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV0gPSB0cmFuc2Zvcm1Gbjtcbn1cblxuXG4vKipcbiAqIFVucmVnaXN0ZXJzIHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLiAgVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjbGVhbiB1cFxuICogY2FjaGVkIHRyYW5zZm9ybXMgZHVyaW5nIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVGhlIHVucmVnaXN0ZXJlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlLmdldENvZGUoKTtcbiAgY29uc3QgZGVzdGluYXRpb25Db2RlID0gZGVzdGluYXRpb24uZ2V0Q29kZSgpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIGRlbGV0ZSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIGlmIChpc0VtcHR5KHRyYW5zZm9ybXNbc291cmNlQ29kZV0pKSB7XG4gICAgZGVsZXRlIHRyYW5zZm9ybXNbc291cmNlQ29kZV07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuXG4vKipcbiAqIEdldCBhIHRyYW5zZm9ybSBnaXZlbiBhIHNvdXJjZSBjb2RlIGFuZCBhIGRlc3RpbmF0aW9uIGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlQ29kZSBUaGUgY29kZSBmb3IgdGhlIHNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uQ29kZSBUaGUgY29kZSBmb3IgdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbnx1bmRlZmluZWR9IFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gKGlmIGZvdW5kKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpIHtcbiAgbGV0IHRyYW5zZm9ybTtcbiAgaWYgKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcyAmJiBkZXN0aW5hdGlvbkNvZGUgaW4gdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkge1xuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvalxuICovXG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHtjb250YWluc0Nvb3JkaW5hdGUsIGNyZWF0ZUVtcHR5LCBleHRlbmQsIGdldEhlaWdodCwgZ2V0VG9wTGVmdCwgZ2V0V2lkdGh9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7c29sdmVMaW5lYXJTeXN0ZW19IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2dldFBvaW50UmVzb2x1dGlvbiwgdHJhbnNmb3JtfSBmcm9tICcuL3Byb2ouanMnO1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyBpZGVhbCByZXNvbHV0aW9uIHRvIHVzZSBmcm9tIHRoZSBzb3VyY2UgaW4gb3JkZXIgdG8gYWNoaWV2ZVxuICogcGl4ZWwgbWFwcGluZyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byAxOjEgZHVyaW5nIHJlcHJvamVjdGlvbi5cbiAqIFRoZSByZXNvbHV0aW9uIGlzIGNhbGN1bGF0ZWQgcmVnYXJkbGVzcyBvZiB3aGF0IHJlc29sdXRpb25zXG4gKiBhcmUgYWN0dWFsbHkgYXZhaWxhYmxlIGluIHRoZSBkYXRhc2V0IChUaWxlR3JpZCwgSW1hZ2UsIC4uLikuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSB0YXJnZXRDZW50ZXIgVGFyZ2V0IGNlbnRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmVzdCByZXNvbHV0aW9uIHRvIHVzZS4gQ2FuIGJlICstSW5maW5pdHksIE5hTiBvciAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbihzb3VyY2VQcm9qLCB0YXJnZXRQcm9qLFxuICB0YXJnZXRDZW50ZXIsIHRhcmdldFJlc29sdXRpb24pIHtcblxuICBjb25zdCBzb3VyY2VDZW50ZXIgPSB0cmFuc2Zvcm0odGFyZ2V0Q2VudGVyLCB0YXJnZXRQcm9qLCBzb3VyY2VQcm9qKTtcblxuICAvLyBjYWxjdWxhdGUgdGhlIGlkZWFsIHJlc29sdXRpb24gb2YgdGhlIHNvdXJjZSBkYXRhXG4gIGxldCBzb3VyY2VSZXNvbHV0aW9uID0gZ2V0UG9pbnRSZXNvbHV0aW9uKHRhcmdldFByb2osIHRhcmdldFJlc29sdXRpb24sIHRhcmdldENlbnRlcik7XG5cbiAgY29uc3QgdGFyZ2V0TWV0ZXJzUGVyVW5pdCA9IHRhcmdldFByb2ouZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICBpZiAodGFyZ2V0TWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlUmVzb2x1dGlvbiAqPSB0YXJnZXRNZXRlcnNQZXJVbml0O1xuICB9XG4gIGNvbnN0IHNvdXJjZU1ldGVyc1BlclVuaXQgPSBzb3VyY2VQcm9qLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgaWYgKHNvdXJjZU1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVJlc29sdXRpb24gLz0gc291cmNlTWV0ZXJzUGVyVW5pdDtcbiAgfVxuXG4gIC8vIEJhc2VkIG9uIHRoZSBwcm9qZWN0aW9uIHByb3BlcnRpZXMsIHRoZSBwb2ludCByZXNvbHV0aW9uIGF0IHRoZSBzcGVjaWZpZWRcbiAgLy8gY29vcmRpbmF0ZXMgbWF5IGJlIHNsaWdodGx5IGRpZmZlcmVudC4gV2UgbmVlZCB0byByZXZlcnNlLWNvbXBlbnNhdGUgdGhpc1xuICAvLyBpbiBvcmRlciB0byBhY2hpZXZlIG9wdGltYWwgcmVzdWx0cy5cblxuICBjb25zdCBzb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICBpZiAoIXNvdXJjZUV4dGVudCB8fCBjb250YWluc0Nvb3JkaW5hdGUoc291cmNlRXh0ZW50LCBzb3VyY2VDZW50ZXIpKSB7XG4gICAgY29uc3QgY29tcGVuc2F0aW9uRmFjdG9yID0gZ2V0UG9pbnRSZXNvbHV0aW9uKHNvdXJjZVByb2osIHNvdXJjZVJlc29sdXRpb24sIHNvdXJjZUNlbnRlcikgL1xuICAgICAgICBzb3VyY2VSZXNvbHV0aW9uO1xuICAgIGlmIChpc0Zpbml0ZShjb21wZW5zYXRpb25GYWN0b3IpICYmIGNvbXBlbnNhdGlvbkZhY3RvciA+IDApIHtcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gLz0gY29tcGVuc2F0aW9uRmFjdG9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3VyY2VSZXNvbHV0aW9uO1xufVxuXG5cbi8qKlxuICogRW5sYXJnZSB0aGUgY2xpcHBpbmcgdHJpYW5nbGUgcG9pbnQgYnkgMSBwaXhlbCB0byBlbnN1cmUgdGhlIGVkZ2VzIG92ZXJsYXBcbiAqIGluIG9yZGVyIHRvIG1hc2sgZ2FwcyBjYXVzZWQgYnkgYW50aWFsaWFzaW5nLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZW50cm9pZFggQ2VudHJvaWQgb2YgdGhlIHRyaWFuZ2xlICh4IGNvb3JkaW5hdGUgaW4gcGl4ZWxzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjZW50cm9pZFkgQ2VudHJvaWQgb2YgdGhlIHRyaWFuZ2xlICh5IGNvb3JkaW5hdGUgaW4gcGl4ZWxzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgKGluIHBpeGVscykuXG4gKiBAcGFyYW0ge251bWJlcn0geSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IChpbiBwaXhlbHMpLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gTmV3IHBvaW50IDEgcHggZmFydGhlciBmcm9tIHRoZSBjZW50cm9pZC5cbiAqL1xuZnVuY3Rpb24gZW5sYXJnZUNsaXBQb2ludChjZW50cm9pZFgsIGNlbnRyb2lkWSwgeCwgeSkge1xuICBjb25zdCBkWCA9IHggLSBjZW50cm9pZFg7XG4gIGNvbnN0IGRZID0geSAtIGNlbnRyb2lkWTtcbiAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpO1xuICByZXR1cm4gW01hdGgucm91bmQoeCArIGRYIC8gZGlzdGFuY2UpLCBNYXRoLnJvdW5kKHkgKyBkWSAvIGRpc3RhbmNlKV07XG59XG5cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzb3VyY2UgZGF0YSBpbnRvIG5ldyBjYW52YXMgYmFzZWQgb24gdGhlIHRyaWFuZ3VsYXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0ge251bWJlcn0gc291cmNlUmVzb2x1dGlvbiBTb3VyY2UgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IHNvdXJjZUV4dGVudCBFeHRlbnQgb2YgdGhlIGRhdGEgc291cmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSB0YXJnZXRFeHRlbnQgVGFyZ2V0IGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlcHJvai9Ucmlhbmd1bGF0aW9ufSB0cmlhbmd1bGF0aW9uXG4gKiBDYWxjdWxhdGVkIHRyaWFuZ3VsYXRpb24uXG4gKiBAcGFyYW0ge0FycmF5Ljx7ZXh0ZW50OiBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudCxcbiAqICAgICAgICAgICAgICAgICBpbWFnZTogKEhUTUxDYW52YXNFbGVtZW50fEltYWdlfEhUTUxWaWRlb0VsZW1lbnQpfT59IHNvdXJjZXNcbiAqIEFycmF5IG9mIHNvdXJjZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gZ3V0dGVyIEd1dHRlciBvZiB0aGUgc291cmNlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yZW5kZXJFZGdlcyBSZW5kZXIgcmVwcm9qZWN0aW9uIGVkZ2VzLlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IENhbnZhcyB3aXRoIHJlcHJvamVjdGVkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIod2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbyxcbiAgc291cmNlUmVzb2x1dGlvbiwgc291cmNlRXh0ZW50LCB0YXJnZXRSZXNvbHV0aW9uLCB0YXJnZXRFeHRlbnQsXG4gIHRyaWFuZ3VsYXRpb24sIHNvdXJjZXMsIGd1dHRlciwgb3B0X3JlbmRlckVkZ2VzKSB7XG5cbiAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiB3aWR0aCksXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogaGVpZ2h0KSk7XG5cbiAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xuICB9XG5cbiAgY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblxuICBjb25zdCBzb3VyY2VEYXRhRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNyYywgaSwgYXJyKSB7XG4gICAgZXh0ZW5kKHNvdXJjZURhdGFFeHRlbnQsIHNyYy5leHRlbnQpO1xuICB9KTtcblxuICBjb25zdCBjYW52YXNXaWR0aEluVW5pdHMgPSBnZXRXaWR0aChzb3VyY2VEYXRhRXh0ZW50KTtcbiAgY29uc3QgY2FudmFzSGVpZ2h0SW5Vbml0cyA9IGdldEhlaWdodChzb3VyY2VEYXRhRXh0ZW50KTtcbiAgY29uc3Qgc3RpdGNoQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBjYW52YXNXaWR0aEluVW5pdHMgLyBzb3VyY2VSZXNvbHV0aW9uKSxcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBjYW52YXNIZWlnaHRJblVuaXRzIC8gc291cmNlUmVzb2x1dGlvbikpO1xuXG4gIGNvbnN0IHN0aXRjaFNjYWxlID0gcGl4ZWxSYXRpbyAvIHNvdXJjZVJlc29sdXRpb247XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNyYywgaSwgYXJyKSB7XG4gICAgY29uc3QgeFBvcyA9IHNyYy5leHRlbnRbMF0gLSBzb3VyY2VEYXRhRXh0ZW50WzBdO1xuICAgIGNvbnN0IHlQb3MgPSAtKHNyYy5leHRlbnRbM10gLSBzb3VyY2VEYXRhRXh0ZW50WzNdKTtcbiAgICBjb25zdCBzcmNXaWR0aCA9IGdldFdpZHRoKHNyYy5leHRlbnQpO1xuICAgIGNvbnN0IHNyY0hlaWdodCA9IGdldEhlaWdodChzcmMuZXh0ZW50KTtcblxuICAgIHN0aXRjaENvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgc3JjLmltYWdlLFxuICAgICAgZ3V0dGVyLCBndXR0ZXIsXG4gICAgICBzcmMuaW1hZ2Uud2lkdGggLSAyICogZ3V0dGVyLCBzcmMuaW1hZ2UuaGVpZ2h0IC0gMiAqIGd1dHRlcixcbiAgICAgIHhQb3MgKiBzdGl0Y2hTY2FsZSwgeVBvcyAqIHN0aXRjaFNjYWxlLFxuICAgICAgc3JjV2lkdGggKiBzdGl0Y2hTY2FsZSwgc3JjSGVpZ2h0ICogc3RpdGNoU2NhbGUpO1xuICB9KTtcblxuICBjb25zdCB0YXJnZXRUb3BMZWZ0ID0gZ2V0VG9wTGVmdCh0YXJnZXRFeHRlbnQpO1xuXG4gIHRyaWFuZ3VsYXRpb24uZ2V0VHJpYW5nbGVzKCkuZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgLyogQ2FsY3VsYXRlIGFmZmluZSB0cmFuc2Zvcm0gKHNyYyAtPiBkc3QpXG4gICAgICogUmVzdWx0aW5nIG1hdHJpeCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRpbmF0ZVxuICAgICAqIGZyb20gYHNvdXJjZVByb2plY3Rpb25gIHRvIGRlc3RpbmF0aW9uIHBpeGVscy5cbiAgICAgKlxuICAgICAqIFRvIG9wdGltaXplIG51bWJlciBvZiBjb250ZXh0IGNhbGxzIGFuZCBpbmNyZWFzZSBudW1lcmljYWwgc3RhYmlsaXR5LFxuICAgICAqIHdlIGFsc28gZG8gdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxuICAgICAqIHRyYW5zKC10b3BMZWZ0RXh0ZW50Q29ybmVyKSwgc2NhbGUoMSAvIHRhcmdldFJlc29sdXRpb24pLCBzY2FsZSgxLCAtMSlcbiAgICAgKiBoZXJlIGJlZm9yZSBzb2x2aW5nIHRoZSBsaW5lYXIgc3lzdGVtIHNvIFt1aSwgdmldIGFyZSBwaXhlbCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIFNyYyBwb2ludHM6IHhpLCB5aVxuICAgICAqIERzdCBwb2ludHM6IHVpLCB2aVxuICAgICAqIEFmZmluZSBjb2VmZmljaWVudHM6IGFpalxuICAgICAqXG4gICAgICogfCB4MCB5MCAxICAwICAwIDAgfCAgIHxhMDB8ICAgfHUwfFxuICAgICAqIHwgeDEgeTEgMSAgMCAgMCAwIHwgICB8YTAxfCAgIHx1MXxcbiAgICAgKiB8IHgyIHkyIDEgIDAgIDAgMCB8IHggfGEwMnwgPSB8dTJ8XG4gICAgICogfCAgMCAgMCAwIHgwIHkwIDEgfCAgIHxhMTB8ICAgfHYwfFxuICAgICAqIHwgIDAgIDAgMCB4MSB5MSAxIHwgICB8YTExfCAgIHx2MXxcbiAgICAgKiB8ICAwICAwIDAgeDIgeTIgMSB8ICAgfGExMnwgICB8djJ8XG4gICAgICovXG4gICAgY29uc3Qgc291cmNlID0gdHJpYW5nbGUuc291cmNlO1xuICAgIGNvbnN0IHRhcmdldCA9IHRyaWFuZ2xlLnRhcmdldDtcbiAgICBsZXQgeDAgPSBzb3VyY2VbMF1bMF0sIHkwID0gc291cmNlWzBdWzFdO1xuICAgIGxldCB4MSA9IHNvdXJjZVsxXVswXSwgeTEgPSBzb3VyY2VbMV1bMV07XG4gICAgbGV0IHgyID0gc291cmNlWzJdWzBdLCB5MiA9IHNvdXJjZVsyXVsxXTtcbiAgICBjb25zdCB1MCA9ICh0YXJnZXRbMF1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgY29uc3QgdjAgPSAtKHRhcmdldFswXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICBjb25zdCB1MSA9ICh0YXJnZXRbMV1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgY29uc3QgdjEgPSAtKHRhcmdldFsxXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICBjb25zdCB1MiA9ICh0YXJnZXRbMl1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgY29uc3QgdjIgPSAtKHRhcmdldFsyXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcblxuICAgIC8vIFNoaWZ0IGFsbCB0aGUgc291cmNlIHBvaW50cyB0byBpbXByb3ZlIG51bWVyaWNhbCBzdGFiaWxpdHlcbiAgICAvLyBvZiBhbGwgdGhlIHN1YnNlcXVlbnQgY2FsY3VsYXRpb25zLiBUaGUgW3gwLCB5MF0gaXMgdXNlZCBoZXJlLlxuICAgIC8vIFRoaXMgaXMgYWxzbyB1c2VkIHRvIHNpbXBsaWZ5IHRoZSBsaW5lYXIgc3lzdGVtLlxuICAgIGNvbnN0IHNvdXJjZU51bWVyaWNhbFNoaWZ0WCA9IHgwO1xuICAgIGNvbnN0IHNvdXJjZU51bWVyaWNhbFNoaWZ0WSA9IHkwO1xuICAgIHgwID0gMDtcbiAgICB5MCA9IDA7XG4gICAgeDEgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRYO1xuICAgIHkxIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WTtcbiAgICB4MiAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFg7XG4gICAgeTIgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRZO1xuXG4gICAgY29uc3QgYXVnbWVudGVkTWF0cml4ID0gW1xuICAgICAgW3gxLCB5MSwgMCwgMCwgdTEgLSB1MF0sXG4gICAgICBbeDIsIHkyLCAwLCAwLCB1MiAtIHUwXSxcbiAgICAgIFswLCAwLCB4MSwgeTEsIHYxIC0gdjBdLFxuICAgICAgWzAsIDAsIHgyLCB5MiwgdjIgLSB2MF1cbiAgICBdO1xuICAgIGNvbnN0IGFmZmluZUNvZWZzID0gc29sdmVMaW5lYXJTeXN0ZW0oYXVnbWVudGVkTWF0cml4KTtcbiAgICBpZiAoIWFmZmluZUNvZWZzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb25zdCBjZW50cm9pZFggPSAodTAgKyB1MSArIHUyKSAvIDM7XG4gICAgY29uc3QgY2VudHJvaWRZID0gKHYwICsgdjEgKyB2MikgLyAzO1xuICAgIGNvbnN0IHAwID0gZW5sYXJnZUNsaXBQb2ludChjZW50cm9pZFgsIGNlbnRyb2lkWSwgdTAsIHYwKTtcbiAgICBjb25zdCBwMSA9IGVubGFyZ2VDbGlwUG9pbnQoY2VudHJvaWRYLCBjZW50cm9pZFksIHUxLCB2MSk7XG4gICAgY29uc3QgcDIgPSBlbmxhcmdlQ2xpcFBvaW50KGNlbnRyb2lkWCwgY2VudHJvaWRZLCB1MiwgdjIpO1xuXG4gICAgY29udGV4dC5tb3ZlVG8ocDFbMF0sIHAxWzFdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhwMFswXSwgcDBbMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHAyWzBdLCBwMlsxXSk7XG4gICAgY29udGV4dC5jbGlwKCk7XG5cbiAgICBjb250ZXh0LnRyYW5zZm9ybShcbiAgICAgIGFmZmluZUNvZWZzWzBdLCBhZmZpbmVDb2Vmc1syXSwgYWZmaW5lQ29lZnNbMV0sIGFmZmluZUNvZWZzWzNdLCB1MCwgdjApO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoc291cmNlRGF0YUV4dGVudFswXSAtIHNvdXJjZU51bWVyaWNhbFNoaWZ0WCxcbiAgICAgIHNvdXJjZURhdGFFeHRlbnRbM10gLSBzb3VyY2VOdW1lcmljYWxTaGlmdFkpO1xuXG4gICAgY29udGV4dC5zY2FsZShzb3VyY2VSZXNvbHV0aW9uIC8gcGl4ZWxSYXRpbyxcbiAgICAgIC1zb3VyY2VSZXNvbHV0aW9uIC8gcGl4ZWxSYXRpbyk7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZShzdGl0Y2hDb250ZXh0LmNhbnZhcywgMCwgMCk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGlmIChvcHRfcmVuZGVyRWRnZXMpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcblxuICAgIHRyaWFuZ3VsYXRpb24uZ2V0VHJpYW5nbGVzKCkuZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0cmlhbmdsZS50YXJnZXQ7XG4gICAgICBjb25zdCB1MCA9ICh0YXJnZXRbMF1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB2MCA9IC0odGFyZ2V0WzBdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdTEgPSAodGFyZ2V0WzFdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdjEgPSAtKHRhcmdldFsxXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHUyID0gKHRhcmdldFsyXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHYyID0gLSh0YXJnZXRbMl1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh1MSwgdjEpO1xuICAgICAgY29udGV4dC5saW5lVG8odTAsIHYwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHUyLCB2Mik7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9KTtcblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmNhbnZhcztcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovVGlsZVxuICovXG5pbXBvcnQge0VSUk9SX1RIUkVTSE9MRH0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IFRpbGUgZnJvbSAnLi4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2dldEFyZWEsIGdldENlbnRlciwgZ2V0SW50ZXJzZWN0aW9ufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2NhbGN1bGF0ZVNvdXJjZVJlc29sdXRpb24sIHJlbmRlciBhcyByZW5kZXJSZXByb2plY3RlZH0gZnJvbSAnLi4vcmVwcm9qLmpzJztcbmltcG9ydCBUcmlhbmd1bGF0aW9uIGZyb20gJy4uL3JlcHJvai9Ucmlhbmd1bGF0aW9uLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIpIDogbW9kdWxlOm9sL1RpbGV9IEZ1bmN0aW9uVHlwZVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBlbmNhcHN1bGF0aW5nIHNpbmdsZSByZXByb2plY3RlZCB0aWxlLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGVJbWFnZX5UaWxlSW1hZ2V9LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTpvbC9UaWxlfVxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IHNvdXJjZVRpbGVHcmlkIFNvdXJjZSB0aWxlIGdyaWQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHRhcmdldFByb2ogVGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gdGFyZ2V0VGlsZUdyaWQgVGFyZ2V0IHRpbGUgZ3JpZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBDb29yZGluYXRlIG9mIHRoZSB0aWxlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gd3JhcHBlZFRpbGVDb29yZCBDb29yZGluYXRlIG9mIHRoZSB0aWxlIHdyYXBwZWQgaW4gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlciBHdXR0ZXIgb2YgdGhlIHNvdXJjZSB0aWxlcy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlcHJvai9UaWxlfkZ1bmN0aW9uVHlwZX0gZ2V0VGlsZUZ1bmN0aW9uXG4gKiAgICAgRnVuY3Rpb24gcmV0dXJuaW5nIHNvdXJjZSB0aWxlcyAoeiwgeCwgeSwgcGl4ZWxSYXRpbykuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9lcnJvclRocmVzaG9sZCBBY2NlcHRhYmxlIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcHgpLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JlbmRlckVkZ2VzIFJlbmRlciByZXByb2plY3Rpb24gZWRnZXMuXG4gKi9cbmNvbnN0IFJlcHJvalRpbGUgPSBmdW5jdGlvbihzb3VyY2VQcm9qLCBzb3VyY2VUaWxlR3JpZCxcbiAgdGFyZ2V0UHJvaiwgdGFyZ2V0VGlsZUdyaWQsIHRpbGVDb29yZCwgd3JhcHBlZFRpbGVDb29yZCxcbiAgcGl4ZWxSYXRpbywgZ3V0dGVyLCBnZXRUaWxlRnVuY3Rpb24sXG4gIG9wdF9lcnJvclRocmVzaG9sZCwgb3B0X3JlbmRlckVkZ2VzKSB7XG4gIFRpbGUuY2FsbCh0aGlzLCB0aWxlQ29vcmQsIFRpbGVTdGF0ZS5JRExFKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLnJlbmRlckVkZ2VzXyA9IG9wdF9yZW5kZXJFZGdlcyAhPT0gdW5kZWZpbmVkID8gb3B0X3JlbmRlckVkZ2VzIDogZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnBpeGVsUmF0aW9fID0gcGl4ZWxSYXRpbztcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuZ3V0dGVyXyA9IGd1dHRlcjtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgKi9cbiAgdGhpcy5jYW52YXNfID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH1cbiAgICovXG4gIHRoaXMuc291cmNlVGlsZUdyaWRfID0gc291cmNlVGlsZUdyaWQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9XG4gICAqL1xuICB0aGlzLnRhcmdldFRpbGVHcmlkXyA9IHRhcmdldFRpbGVHcmlkO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9XG4gICAqL1xuICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfID0gd3JhcHBlZFRpbGVDb29yZCA/IHdyYXBwZWRUaWxlQ29vcmQgOiB0aWxlQ29vcmQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshQXJyYXkuPG1vZHVsZTpvbC9UaWxlPn1cbiAgICovXG4gIHRoaXMuc291cmNlVGlsZXNfID0gW107XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXk+fVxuICAgKi9cbiAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnNvdXJjZVpfID0gMDtcblxuICBjb25zdCB0YXJnZXRFeHRlbnQgPSB0YXJnZXRUaWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGhpcy53cmFwcGVkVGlsZUNvb3JkXyk7XG4gIGNvbnN0IG1heFRhcmdldEV4dGVudCA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldEV4dGVudCgpO1xuICBsZXQgbWF4U291cmNlRXh0ZW50ID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0RXh0ZW50KCk7XG5cbiAgY29uc3QgbGltaXRlZFRhcmdldEV4dGVudCA9IG1heFRhcmdldEV4dGVudCA/XG4gICAgZ2V0SW50ZXJzZWN0aW9uKHRhcmdldEV4dGVudCwgbWF4VGFyZ2V0RXh0ZW50KSA6IHRhcmdldEV4dGVudDtcblxuICBpZiAoZ2V0QXJlYShsaW1pdGVkVGFyZ2V0RXh0ZW50KSA9PT0gMCkge1xuICAgIC8vIFRpbGUgaXMgY29tcGxldGVseSBvdXRzaWRlIHJhbmdlIC0+IEVNUFRZXG4gICAgLy8gVE9ETzogaXMgaXQgYWN0dWFsbHkgY29ycmVjdCB0aGF0IHRoZSBzb3VyY2UgZXZlbiBjcmVhdGVzIHRoZSB0aWxlID9cbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNvdXJjZVByb2pFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICBpZiAoc291cmNlUHJvakV4dGVudCkge1xuICAgIGlmICghbWF4U291cmNlRXh0ZW50KSB7XG4gICAgICBtYXhTb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qRXh0ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhTb3VyY2VFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24obWF4U291cmNlRXh0ZW50LCBzb3VyY2VQcm9qRXh0ZW50KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB0YXJnZXRSZXNvbHV0aW9uID0gdGFyZ2V0VGlsZUdyaWQuZ2V0UmVzb2x1dGlvbihcbiAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdKTtcblxuICBjb25zdCB0YXJnZXRDZW50ZXIgPSBnZXRDZW50ZXIobGltaXRlZFRhcmdldEV4dGVudCk7XG4gIGNvbnN0IHNvdXJjZVJlc29sdXRpb24gPSBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKFxuICAgIHNvdXJjZVByb2osIHRhcmdldFByb2osIHRhcmdldENlbnRlciwgdGFyZ2V0UmVzb2x1dGlvbik7XG5cbiAgaWYgKCFpc0Zpbml0ZShzb3VyY2VSZXNvbHV0aW9uKSB8fCBzb3VyY2VSZXNvbHV0aW9uIDw9IDApIHtcbiAgICAvLyBpbnZhbGlkIHNvdXJjZVJlc29sdXRpb24gLT4gRU1QVFlcbiAgICAvLyBwcm9iYWJseSBlZGdlcyBvZiB0aGUgcHJvamVjdGlvbnMgd2hlbiBubyBleHRlbnQgaXMgZGVmaW5lZFxuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXJyb3JUaHJlc2hvbGRJblBpeGVscyA9IG9wdF9lcnJvclRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRfZXJyb3JUaHJlc2hvbGQgOiBFUlJPUl9USFJFU0hPTEQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshbW9kdWxlOm9sL3JlcHJvai9Ucmlhbmd1bGF0aW9ufVxuICAgKi9cbiAgdGhpcy50cmlhbmd1bGF0aW9uXyA9IG5ldyBUcmlhbmd1bGF0aW9uKFxuICAgIHNvdXJjZVByb2osIHRhcmdldFByb2osIGxpbWl0ZWRUYXJnZXRFeHRlbnQsIG1heFNvdXJjZUV4dGVudCxcbiAgICBzb3VyY2VSZXNvbHV0aW9uICogZXJyb3JUaHJlc2hvbGRJblBpeGVscyk7XG5cbiAgaWYgKHRoaXMudHJpYW5ndWxhdGlvbl8uZ2V0VHJpYW5nbGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gbm8gdmFsaWQgdHJpYW5nbGVzIC0+IEVNUFRZXG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnNvdXJjZVpfID0gc291cmNlVGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24oc291cmNlUmVzb2x1dGlvbik7XG4gIGxldCBzb3VyY2VFeHRlbnQgPSB0aGlzLnRyaWFuZ3VsYXRpb25fLmNhbGN1bGF0ZVNvdXJjZUV4dGVudCgpO1xuXG4gIGlmIChtYXhTb3VyY2VFeHRlbnQpIHtcbiAgICBpZiAoc291cmNlUHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICBzb3VyY2VFeHRlbnRbMV0gPSBjbGFtcChcbiAgICAgICAgc291cmNlRXh0ZW50WzFdLCBtYXhTb3VyY2VFeHRlbnRbMV0sIG1heFNvdXJjZUV4dGVudFszXSk7XG4gICAgICBzb3VyY2VFeHRlbnRbM10gPSBjbGFtcChcbiAgICAgICAgc291cmNlRXh0ZW50WzNdLCBtYXhTb3VyY2VFeHRlbnRbMV0sIG1heFNvdXJjZUV4dGVudFszXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZUV4dGVudCA9IGdldEludGVyc2VjdGlvbihzb3VyY2VFeHRlbnQsIG1heFNvdXJjZUV4dGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFnZXRBcmVhKHNvdXJjZUV4dGVudCkpIHtcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNvdXJjZVJhbmdlID0gc291cmNlVGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgIHNvdXJjZUV4dGVudCwgdGhpcy5zb3VyY2VaXyk7XG5cbiAgICBmb3IgKGxldCBzcmNYID0gc291cmNlUmFuZ2UubWluWDsgc3JjWCA8PSBzb3VyY2VSYW5nZS5tYXhYOyBzcmNYKyspIHtcbiAgICAgIGZvciAobGV0IHNyY1kgPSBzb3VyY2VSYW5nZS5taW5ZOyBzcmNZIDw9IHNvdXJjZVJhbmdlLm1heFk7IHNyY1krKykge1xuICAgICAgICBjb25zdCB0aWxlID0gZ2V0VGlsZUZ1bmN0aW9uKHRoaXMuc291cmNlWl8sIHNyY1gsIHNyY1ksIHBpeGVsUmF0aW8pO1xuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgIHRoaXMuc291cmNlVGlsZXNfLnB1c2godGlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zb3VyY2VUaWxlc18ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgIH1cbiAgfVxufTtcblxuaW5oZXJpdHMoUmVwcm9qVGlsZSwgVGlsZSk7XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5SZXByb2pUaWxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICB0aGlzLnVubGlzdGVuU291cmNlc18oKTtcbiAgfVxuICBUaWxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIEhUTUwgQ2FudmFzIGVsZW1lbnQgZm9yIHRoaXMgdGlsZS5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMuXG4gKi9cblJlcHJvalRpbGUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNhbnZhc187XG59O1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuUmVwcm9qVGlsZS5wcm90b3R5cGUucmVwcm9qZWN0XyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzb3VyY2VzID0gW107XG4gIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goZnVuY3Rpb24odGlsZSwgaSwgYXJyKSB7XG4gICAgaWYgKHRpbGUgJiYgdGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgIHNvdXJjZXMucHVzaCh7XG4gICAgICAgIGV4dGVudDogdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGUudGlsZUNvb3JkKSxcbiAgICAgICAgaW1hZ2U6IHRpbGUuZ2V0SW1hZ2UoKVxuICAgICAgfSk7XG4gICAgfVxuICB9LmJpbmQodGhpcykpO1xuICB0aGlzLnNvdXJjZVRpbGVzXy5sZW5ndGggPSAwO1xuXG4gIGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRVJST1I7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeiA9IHRoaXMud3JhcHBlZFRpbGVDb29yZF9bMF07XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFRpbGVTaXplKHopO1xuICAgIGNvbnN0IHdpZHRoID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHNpemVbMF07XG4gICAgY29uc3QgaGVpZ2h0ID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHNpemVbMV07XG4gICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFJlc29sdXRpb24oeik7XG4gICAgY29uc3Qgc291cmNlUmVzb2x1dGlvbiA9IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldFJlc29sdXRpb24odGhpcy5zb3VyY2VaXyk7XG5cbiAgICBjb25zdCB0YXJnZXRFeHRlbnQgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRUaWxlQ29vcmRFeHRlbnQoXG4gICAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfKTtcbiAgICB0aGlzLmNhbnZhc18gPSByZW5kZXJSZXByb2plY3RlZCh3aWR0aCwgaGVpZ2h0LCB0aGlzLnBpeGVsUmF0aW9fLFxuICAgICAgc291cmNlUmVzb2x1dGlvbiwgdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0RXh0ZW50KCksXG4gICAgICB0YXJnZXRSZXNvbHV0aW9uLCB0YXJnZXRFeHRlbnQsIHRoaXMudHJpYW5ndWxhdGlvbl8sIHNvdXJjZXMsXG4gICAgICB0aGlzLmd1dHRlcl8sIHRoaXMucmVuZGVyRWRnZXNfKTtcblxuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BREVEO1xuICB9XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblJlcHJvalRpbGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURJTkc7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG5cbiAgICBsZXQgbGVmdFRvTG9hZCA9IDA7XG5cbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gW107XG4gICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaChmdW5jdGlvbih0aWxlLCBpLCBhcnIpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHN0YXRlID09IFRpbGVTdGF0ZS5JRExFIHx8IHN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICAgIGxlZnRUb0xvYWQrKztcblxuICAgICAgICBjb25zdCBzb3VyY2VMaXN0ZW5LZXkgPSBsaXN0ZW4odGlsZSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEIHx8XG4gICAgICAgICAgICAgICAgICBzdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IgfHxcbiAgICAgICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FTVBUWSkge1xuICAgICAgICAgICAgICB1bmxpc3RlbkJ5S2V5KHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgICAgICAgIGxlZnRUb0xvYWQtLTtcbiAgICAgICAgICAgICAgaWYgKGxlZnRUb0xvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVubGlzdGVuU291cmNlc18oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcHJvamVjdF8oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfLnB1c2goc291cmNlTGlzdGVuS2V5KTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaChmdW5jdGlvbih0aWxlLCBpLCBhcnIpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHN0YXRlID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgIHRpbGUubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGxlZnRUb0xvYWQgPT09IDApIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5yZXByb2plY3RfLmJpbmQodGhpcyksIDApO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblJlcHJvalRpbGUucHJvdG90eXBlLnVubGlzdGVuU291cmNlc18gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcbn07XG5leHBvcnQgZGVmYXVsdCBSZXByb2pUaWxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9Ucmlhbmd1bGF0aW9uXG4gKi9cbmltcG9ydCB7Ym91bmRpbmdFeHRlbnQsIGNyZWF0ZUVtcHR5LCBleHRlbmRDb29yZGluYXRlLCBnZXRCb3R0b21MZWZ0LCBnZXRCb3R0b21SaWdodCxcbiAgZ2V0VG9wTGVmdCwgZ2V0VG9wUmlnaHQsIGdldFdpZHRoLCBpbnRlcnNlY3RzfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtnZXRUcmFuc2Zvcm19IGZyb20gJy4uL3Byb2ouanMnO1xuXG5cbi8qKlxuICogU2luZ2xlIHRyaWFuZ2xlOyBjb25zaXN0cyBvZiAzIHNvdXJjZSBwb2ludHMgYW5kIDMgdGFyZ2V0IHBvaW50cy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyaWFuZ2xlXG4gKiBAcHJvcGVydHkge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gc291cmNlXG4gKiBAcHJvcGVydHkge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gdGFyZ2V0XG4gKi9cblxuXG4vKipcbiAqIE1heGltdW0gbnVtYmVyIG9mIHN1YmRpdmlzaW9uIHN0ZXBzIGR1cmluZyByYXN0ZXIgcmVwcm9qZWN0aW9uIHRyaWFuZ3VsYXRpb24uXG4gKiBQcmV2ZW50cyBoaWdoIG1lbW9yeSB1c2FnZSBhbmQgbGFyZ2UgbnVtYmVyIG9mIHByb2o0IGNhbGxzIChmb3IgY2VydGFpblxuICogdHJhbnNmb3JtYXRpb25zIGFuZCBhcmVhcykuIEF0IG1vc3QgYDIqKDJedGhpcylgIHRyaWFuZ2xlcyBhcmUgY3JlYXRlZCBmb3JcbiAqIGVhY2ggdHJpYW5ndWxhdGVkIGV4dGVudCAodGlsZS9pbWFnZSkuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBNQVhfU1VCRElWSVNJT04gPSAxMDtcblxuXG4vKipcbiAqIE1heGltdW0gYWxsb3dlZCBzaXplIG9mIHRyaWFuZ2xlIHJlbGF0aXZlIHRvIHdvcmxkIHdpZHRoLiBXaGVuIHRyYW5zZm9ybWluZ1xuICogY29ybmVycyBvZiB3b3JsZCBleHRlbnQgYmV0d2VlbiBjZXJ0YWluIHByb2plY3Rpb25zLCB0aGUgcmVzdWx0aW5nXG4gKiB0cmlhbmd1bGF0aW9uIHNlZW1zIHRvIGhhdmUgemVybyBlcnJvciBhbmQgbm8gc3ViZGl2aXNpb24gaXMgcGVyZm9ybWVkLiBJZlxuICogdGhlIHRyaWFuZ2xlIHdpZHRoIGlzIG1vcmUgdGhhbiB0aGlzIChyZWxhdGl2ZSB0byB3b3JsZCB3aWR0aDsgMC0xKSxcbiAqIHN1YmRpdmlzb24gaXMgZm9yY2VkICh1cCB0byBgTUFYX1NVQkRJVklTSU9OYCkuIERlZmF1bHQgaXMgYDAuMjVgLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgTUFYX1RSSUFOR0xFX1dJRFRIID0gMC4yNTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENsYXNzIGNvbnRhaW5pbmcgdHJpYW5ndWxhdGlvbiBvZiB0aGUgZ2l2ZW4gdGFyZ2V0IGV4dGVudC5cbiAqIFVzZWQgZm9yIGRldGVybWluaW5nIHNvdXJjZSBkYXRhIGFuZCB0aGUgcmVwcm9qZWN0aW9uIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHNvdXJjZVByb2ogU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHRhcmdldFByb2ogVGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSB0YXJnZXRFeHRlbnQgVGFyZ2V0IGV4dGVudCB0byB0cmlhbmd1bGF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IG1heFNvdXJjZUV4dGVudCBNYXhpbWFsIHNvdXJjZSBleHRlbnQgdGhhdCBjYW4gYmUgdXNlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvclRocmVzaG9sZCBBY2NlcHRhYmxlIGVycm9yIChpbiBzb3VyY2UgdW5pdHMpLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNvbnN0IFRyaWFuZ3VsYXRpb24gPSBmdW5jdGlvbihzb3VyY2VQcm9qLCB0YXJnZXRQcm9qLCB0YXJnZXRFeHRlbnQsXG4gIG1heFNvdXJjZUV4dGVudCwgZXJyb3JUaHJlc2hvbGQpIHtcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNvdXJjZVByb2pfID0gc291cmNlUHJvajtcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRhcmdldFByb2pfID0gdGFyZ2V0UHJvajtcblxuICAvKiogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59ICovXG4gIGxldCB0cmFuc2Zvcm1JbnZDYWNoZSA9IHt9O1xuICBjb25zdCB0cmFuc2Zvcm1JbnYgPSBnZXRUcmFuc2Zvcm0odGhpcy50YXJnZXRQcm9qXywgdGhpcy5zb3VyY2VQcm9qXyk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYyBBIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRyYW5zZm9ybUludl8gPSBmdW5jdGlvbihjKSB7XG4gICAgY29uc3Qga2V5ID0gY1swXSArICcvJyArIGNbMV07XG4gICAgaWYgKCF0cmFuc2Zvcm1JbnZDYWNoZVtrZXldKSB7XG4gICAgICB0cmFuc2Zvcm1JbnZDYWNoZVtrZXldID0gdHJhbnNmb3JtSW52KGMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtSW52Q2FjaGVba2V5XTtcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5tYXhTb3VyY2VFeHRlbnRfID0gbWF4U291cmNlRXh0ZW50O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5lcnJvclRocmVzaG9sZFNxdWFyZWRfID0gZXJyb3JUaHJlc2hvbGQgKiBlcnJvclRocmVzaG9sZDtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvcmVwcm9qL1RyaWFuZ3VsYXRpb25+VHJpYW5nbGU+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy50cmlhbmdsZXNfID0gW107XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IHRoZSB0cmlhbmd1bGF0aW9uIGNyb3NzZXMgZWRnZSBvZiB0aGUgc291cmNlIHByb2plY3Rpb24uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSBmYWxzZTtcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmNhbldyYXBYSW5Tb3VyY2VfID0gdGhpcy5zb3VyY2VQcm9qXy5jYW5XcmFwWCgpICYmXG4gICAgICAhIW1heFNvdXJjZUV4dGVudCAmJlxuICAgICAgISF0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpICYmXG4gICAgICAoZ2V0V2lkdGgobWF4U291cmNlRXh0ZW50KSA9PSBnZXRXaWR0aCh0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpKSk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyA9IHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkgP1xuICAgIGdldFdpZHRoKHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkpIDogbnVsbDtcblxuICAvKipcbiAgICogQHR5cGUgez9udW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRhcmdldFdvcmxkV2lkdGhfID0gdGhpcy50YXJnZXRQcm9qXy5nZXRFeHRlbnQoKSA/XG4gICAgZ2V0V2lkdGgodGhpcy50YXJnZXRQcm9qXy5nZXRFeHRlbnQoKSkgOiBudWxsO1xuXG4gIGNvbnN0IGRlc3RpbmF0aW9uVG9wTGVmdCA9IGdldFRvcExlZnQodGFyZ2V0RXh0ZW50KTtcbiAgY29uc3QgZGVzdGluYXRpb25Ub3BSaWdodCA9IGdldFRvcFJpZ2h0KHRhcmdldEV4dGVudCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uQm90dG9tUmlnaHQgPSBnZXRCb3R0b21SaWdodCh0YXJnZXRFeHRlbnQpO1xuICBjb25zdCBkZXN0aW5hdGlvbkJvdHRvbUxlZnQgPSBnZXRCb3R0b21MZWZ0KHRhcmdldEV4dGVudCk7XG4gIGNvbnN0IHNvdXJjZVRvcExlZnQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Ub3BMZWZ0KTtcbiAgY29uc3Qgc291cmNlVG9wUmlnaHQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Ub3BSaWdodCk7XG4gIGNvbnN0IHNvdXJjZUJvdHRvbVJpZ2h0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uQm90dG9tUmlnaHQpO1xuICBjb25zdCBzb3VyY2VCb3R0b21MZWZ0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uQm90dG9tTGVmdCk7XG5cbiAgdGhpcy5hZGRRdWFkXyhcbiAgICBkZXN0aW5hdGlvblRvcExlZnQsIGRlc3RpbmF0aW9uVG9wUmlnaHQsXG4gICAgZGVzdGluYXRpb25Cb3R0b21SaWdodCwgZGVzdGluYXRpb25Cb3R0b21MZWZ0LFxuICAgIHNvdXJjZVRvcExlZnQsIHNvdXJjZVRvcFJpZ2h0LCBzb3VyY2VCb3R0b21SaWdodCwgc291cmNlQm90dG9tTGVmdCxcbiAgICBNQVhfU1VCRElWSVNJT04pO1xuXG4gIGlmICh0aGlzLndyYXBzWEluU291cmNlXykge1xuICAgIGxldCBsZWZ0Qm91bmQgPSBJbmZpbml0eTtcbiAgICB0aGlzLnRyaWFuZ2xlc18uZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICBsZWZ0Qm91bmQgPSBNYXRoLm1pbihsZWZ0Qm91bmQsXG4gICAgICAgIHRyaWFuZ2xlLnNvdXJjZVswXVswXSwgdHJpYW5nbGUuc291cmNlWzFdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMl1bMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gU2hpZnQgdHJpYW5nbGVzIHRvIGJlIGFzIGNsb3NlIHRvIGBsZWZ0Qm91bmRgIGFzIHBvc3NpYmxlXG4gICAgLy8gKGlmIHRoZSBkaXN0YW5jZSBpcyBtb3JlIHRoYW4gYHdvcmxkV2lkdGggLyAyYCBpdCBjYW4gYmUgY2xvc2VyLlxuICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlKSB7XG4gICAgICBpZiAoTWF0aC5tYXgodHJpYW5nbGUuc291cmNlWzBdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMV1bMF0sXG4gICAgICAgIHRyaWFuZ2xlLnNvdXJjZVsyXVswXSkgLSBsZWZ0Qm91bmQgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICBjb25zdCBuZXdUcmlhbmdsZSA9IFtbdHJpYW5nbGUuc291cmNlWzBdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMF1bMV1dLFxuICAgICAgICAgIFt0cmlhbmdsZS5zb3VyY2VbMV1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVsxXV0sXG4gICAgICAgICAgW3RyaWFuZ2xlLnNvdXJjZVsyXVswXSwgdHJpYW5nbGUuc291cmNlWzJdWzFdXV07XG4gICAgICAgIGlmICgobmV3VHJpYW5nbGVbMF1bMF0gLSBsZWZ0Qm91bmQpID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICBuZXdUcmlhbmdsZVswXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobmV3VHJpYW5nbGVbMV1bMF0gLSBsZWZ0Qm91bmQpID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICBuZXdUcmlhbmdsZVsxXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobmV3VHJpYW5nbGVbMl1bMF0gLSBsZWZ0Qm91bmQpID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICBuZXdUcmlhbmdsZVsyXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmFyZWx5IChpZiB0aGUgZXh0ZW50IGNvbnRhaW5zIGJvdGggdGhlIGRhdGVsaW5lIGFuZCBwcmltZSBtZXJpZGlhbilcbiAgICAgICAgLy8gdGhlIHNoaWZ0IGNhbiBpbiB0dXJuIGJyZWFrIHNvbWUgdHJpYW5nbGVzLlxuICAgICAgICAvLyBEZXRlY3QgdGhpcyBoZXJlIGFuZCBkb24ndCBzaGlmdCBpbiBzdWNoIGNhc2VzLlxuICAgICAgICBjb25zdCBtaW5YID0gTWF0aC5taW4oXG4gICAgICAgICAgbmV3VHJpYW5nbGVbMF1bMF0sIG5ld1RyaWFuZ2xlWzFdWzBdLCBuZXdUcmlhbmdsZVsyXVswXSk7XG4gICAgICAgIGNvbnN0IG1heFggPSBNYXRoLm1heChcbiAgICAgICAgICBuZXdUcmlhbmdsZVswXVswXSwgbmV3VHJpYW5nbGVbMV1bMF0sIG5ld1RyaWFuZ2xlWzJdWzBdKTtcbiAgICAgICAgaWYgKChtYXhYIC0gbWluWCkgPCB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZSA9IG5ld1RyaWFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHRyYW5zZm9ybUludkNhY2hlID0ge307XG59O1xuXG5cbi8qKlxuICogQWRkcyB0cmlhbmdsZSB0byB0aGUgdHJpYW5ndWxhdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYSBUaGUgdGFyZ2V0IGEgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYiBUaGUgdGFyZ2V0IGIgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYyBUaGUgdGFyZ2V0IGMgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYVNyYyBUaGUgc291cmNlIGEgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYlNyYyBUaGUgc291cmNlIGIgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY1NyYyBUaGUgc291cmNlIGMgY29vcmRpbmF0ZS5cbiAqIEBwcml2YXRlXG4gKi9cblRyaWFuZ3VsYXRpb24ucHJvdG90eXBlLmFkZFRyaWFuZ2xlXyA9IGZ1bmN0aW9uKGEsIGIsIGMsXG4gIGFTcmMsIGJTcmMsIGNTcmMpIHtcbiAgdGhpcy50cmlhbmdsZXNfLnB1c2goe1xuICAgIHNvdXJjZTogW2FTcmMsIGJTcmMsIGNTcmNdLFxuICAgIHRhcmdldDogW2EsIGIsIGNdXG4gIH0pO1xufTtcblxuXG4vKipcbiAqIEFkZHMgcXVhZCAocG9pbnRzIGluIGNsb2NrLXdpc2Ugb3JkZXIpIHRvIHRoZSB0cmlhbmd1bGF0aW9uXG4gKiAoYW5kIHJlcHJvamVjdHMgdGhlIHZlcnRpY2VzKSBpZiB2YWxpZC5cbiAqIFBlcmZvcm1zIHF1YWQgc3ViZGl2aXNpb24gaWYgbmVlZGVkIHRvIGluY3JlYXNlIHByZWNpc2lvbi5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGEgVGhlIHRhcmdldCBhIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGIgVGhlIHRhcmdldCBiIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGMgVGhlIHRhcmdldCBjIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGQgVGhlIHRhcmdldCBkIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFTcmMgVGhlIHNvdXJjZSBhIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGJTcmMgVGhlIHNvdXJjZSBiIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNTcmMgVGhlIHNvdXJjZSBjIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGRTcmMgVGhlIHNvdXJjZSBkIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4U3ViZGl2aXNpb24gTWF4aW1hbCBhbGxvd2VkIHN1YmRpdmlzaW9uIG9mIHRoZSBxdWFkLlxuICogQHByaXZhdGVcbiAqL1xuVHJpYW5ndWxhdGlvbi5wcm90b3R5cGUuYWRkUXVhZF8gPSBmdW5jdGlvbihhLCBiLCBjLCBkLFxuICBhU3JjLCBiU3JjLCBjU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbikge1xuXG4gIGNvbnN0IHNvdXJjZVF1YWRFeHRlbnQgPSBib3VuZGluZ0V4dGVudChbYVNyYywgYlNyYywgY1NyYywgZFNyY10pO1xuICBjb25zdCBzb3VyY2VDb3ZlcmFnZVggPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfID9cbiAgICBnZXRXaWR0aChzb3VyY2VRdWFkRXh0ZW50KSAvIHRoaXMuc291cmNlV29ybGRXaWR0aF8gOiBudWxsO1xuICBjb25zdCBzb3VyY2VXb3JsZFdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnNvdXJjZVdvcmxkV2lkdGhfKTtcblxuICAvLyB3aGVuIHRoZSBxdWFkIGlzIHdyYXBwZWQgaW4gdGhlIHNvdXJjZSBwcm9qZWN0aW9uXG4gIC8vIGl0IGNvdmVycyBtb3N0IG9mIHRoZSBwcm9qZWN0aW9uIGV4dGVudCwgYnV0IG5vdCBmdWxseVxuICBjb25zdCB3cmFwc1ggPSB0aGlzLnNvdXJjZVByb2pfLmNhbldyYXBYKCkgJiZcbiAgICAgICAgICAgICAgIHNvdXJjZUNvdmVyYWdlWCA+IDAuNSAmJiBzb3VyY2VDb3ZlcmFnZVggPCAxO1xuXG4gIGxldCBuZWVkc1N1YmRpdmlzaW9uID0gZmFsc2U7XG5cbiAgaWYgKG1heFN1YmRpdmlzaW9uID4gMCkge1xuICAgIGlmICh0aGlzLnRhcmdldFByb2pfLmlzR2xvYmFsKCkgJiYgdGhpcy50YXJnZXRXb3JsZFdpZHRoXykge1xuICAgICAgY29uc3QgdGFyZ2V0UXVhZEV4dGVudCA9IGJvdW5kaW5nRXh0ZW50KFthLCBiLCBjLCBkXSk7XG4gICAgICBjb25zdCB0YXJnZXRDb3ZlcmFnZVggPSBnZXRXaWR0aCh0YXJnZXRRdWFkRXh0ZW50KSAvIHRoaXMudGFyZ2V0V29ybGRXaWR0aF87XG4gICAgICBuZWVkc1N1YmRpdmlzaW9uIHw9XG4gICAgICAgICAgdGFyZ2V0Q292ZXJhZ2VYID4gTUFYX1RSSUFOR0xFX1dJRFRIO1xuICAgIH1cbiAgICBpZiAoIXdyYXBzWCAmJiB0aGlzLnNvdXJjZVByb2pfLmlzR2xvYmFsKCkgJiYgc291cmNlQ292ZXJhZ2VYKSB7XG4gICAgICBuZWVkc1N1YmRpdmlzaW9uIHw9XG4gICAgICAgICAgc291cmNlQ292ZXJhZ2VYID4gTUFYX1RSSUFOR0xFX1dJRFRIO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbmVlZHNTdWJkaXZpc2lvbiAmJiB0aGlzLm1heFNvdXJjZUV4dGVudF8pIHtcbiAgICBpZiAoIWludGVyc2VjdHMoc291cmNlUXVhZEV4dGVudCwgdGhpcy5tYXhTb3VyY2VFeHRlbnRfKSkge1xuICAgICAgLy8gd2hvbGUgcXVhZCBvdXRzaWRlIHNvdXJjZSBwcm9qZWN0aW9uIGV4dGVudCAtPiBpZ25vcmVcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoIW5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICBpZiAoIWlzRmluaXRlKGFTcmNbMF0pIHx8ICFpc0Zpbml0ZShhU3JjWzFdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoYlNyY1swXSkgfHwgIWlzRmluaXRlKGJTcmNbMV0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShjU3JjWzBdKSB8fCAhaXNGaW5pdGUoY1NyY1sxXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGRTcmNbMF0pIHx8ICFpc0Zpbml0ZShkU3JjWzFdKSkge1xuICAgICAgaWYgKG1heFN1YmRpdmlzaW9uID4gMCkge1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uKSB7XG4gICAgICBjb25zdCBjZW50ZXIgPSBbKGFbMF0gKyBjWzBdKSAvIDIsIChhWzFdICsgY1sxXSkgLyAyXTtcbiAgICAgIGNvbnN0IGNlbnRlclNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhjZW50ZXIpO1xuXG4gICAgICBsZXQgZHg7XG4gICAgICBpZiAod3JhcHNYKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlclNyY0VzdGltWCA9XG4gICAgICAgICAgICAobW9kdWxvKGFTcmNbMF0sIHNvdXJjZVdvcmxkV2lkdGgpICtcbiAgICAgICAgICAgICBtb2R1bG8oY1NyY1swXSwgc291cmNlV29ybGRXaWR0aCkpIC8gMjtcbiAgICAgICAgZHggPSBjZW50ZXJTcmNFc3RpbVggLVxuICAgICAgICAgICAgbW9kdWxvKGNlbnRlclNyY1swXSwgc291cmNlV29ybGRXaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IChhU3JjWzBdICsgY1NyY1swXSkgLyAyIC0gY2VudGVyU3JjWzBdO1xuICAgICAgfVxuICAgICAgY29uc3QgZHkgPSAoYVNyY1sxXSArIGNTcmNbMV0pIC8gMiAtIGNlbnRlclNyY1sxXTtcbiAgICAgIGNvbnN0IGNlbnRlclNyY0Vycm9yU3F1YXJlZCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgbmVlZHNTdWJkaXZpc2lvbiA9IGNlbnRlclNyY0Vycm9yU3F1YXJlZCA+IHRoaXMuZXJyb3JUaHJlc2hvbGRTcXVhcmVkXztcbiAgICB9XG4gICAgaWYgKG5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgIGlmIChNYXRoLmFicyhhWzBdIC0gY1swXSkgPD0gTWF0aC5hYnMoYVsxXSAtIGNbMV0pKSB7XG4gICAgICAgIC8vIHNwbGl0IGhvcml6b250YWxseSAodG9wICYgYm90dG9tKVxuICAgICAgICBjb25zdCBiYyA9IFsoYlswXSArIGNbMF0pIC8gMiwgKGJbMV0gKyBjWzFdKSAvIDJdO1xuICAgICAgICBjb25zdCBiY1NyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhiYyk7XG4gICAgICAgIGNvbnN0IGRhID0gWyhkWzBdICsgYVswXSkgLyAyLCAoZFsxXSArIGFbMV0pIC8gMl07XG4gICAgICAgIGNvbnN0IGRhU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRhKTtcblxuICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgIGEsIGIsIGJjLCBkYSwgYVNyYywgYlNyYywgYmNTcmMsIGRhU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgIGRhLCBiYywgYywgZCwgZGFTcmMsIGJjU3JjLCBjU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3BsaXQgdmVydGljYWxseSAobGVmdCAmIHJpZ2h0KVxuICAgICAgICBjb25zdCBhYiA9IFsoYVswXSArIGJbMF0pIC8gMiwgKGFbMV0gKyBiWzFdKSAvIDJdO1xuICAgICAgICBjb25zdCBhYlNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhhYik7XG4gICAgICAgIGNvbnN0IGNkID0gWyhjWzBdICsgZFswXSkgLyAyLCAoY1sxXSArIGRbMV0pIC8gMl07XG4gICAgICAgIGNvbnN0IGNkU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGNkKTtcblxuICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgIGEsIGFiLCBjZCwgZCwgYVNyYywgYWJTcmMsIGNkU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgIGFiLCBiLCBjLCBjZCwgYWJTcmMsIGJTcmMsIGNTcmMsIGNkU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3cmFwc1gpIHtcbiAgICBpZiAoIXRoaXMuY2FuV3JhcFhJblNvdXJjZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5hZGRUcmlhbmdsZV8oYSwgYywgZCwgYVNyYywgY1NyYywgZFNyYyk7XG4gIHRoaXMuYWRkVHJpYW5nbGVfKGEsIGIsIGMsIGFTcmMsIGJTcmMsIGNTcmMpO1xufTtcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgZXh0ZW50IG9mIHRoZSAnc291cmNlJyBjb29yZGluYXRlcyBmcm9tIGFsbCB0aGUgdHJpYW5nbGVzLlxuICpcbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBDYWxjdWxhdGVkIGV4dGVudC5cbiAqL1xuVHJpYW5ndWxhdGlvbi5wcm90b3R5cGUuY2FsY3VsYXRlU291cmNlRXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgdGhpcy50cmlhbmdsZXNfLmZvckVhY2goZnVuY3Rpb24odHJpYW5nbGUsIGksIGFycikge1xuICAgIGNvbnN0IHNyYyA9IHRyaWFuZ2xlLnNvdXJjZTtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzBdKTtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzFdKTtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzJdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGV4dGVudDtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOm9sL3JlcHJvai9Ucmlhbmd1bGF0aW9uflRyaWFuZ2xlPn0gQXJyYXkgb2YgdGhlIGNhbGN1bGF0ZWQgdHJpYW5nbGVzLlxuICovXG5Ucmlhbmd1bGF0aW9uLnByb3RvdHlwZS5nZXRUcmlhbmdsZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHJpYW5nbGVzXztcbn07XG5leHBvcnQgZGVmYXVsdCBUcmlhbmd1bGF0aW9uO1xuIiwiLyoqXG4gKiBEZWZhdWx0IG1heGltdW0gYWxsb3dlZCB0aHJlc2hvbGQgIChpbiBwaXhlbHMpIGZvciByZXByb2plY3Rpb25cbiAqIHRyaWFuZ3VsYXRpb24uXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgRVJST1JfVEhSRVNIT0xEID0gMC41O1xuXG4vKipcbiAqIEVuYWJsZSBhdXRvbWF0aWMgcmVwcm9qZWN0aW9uIG9mIHJhc3RlciBzb3VyY2VzLiBEZWZhdWx0IGlzIGB0cnVlYC5cbiAqIFRPRE86IGRlY2lkZSBpZiB3ZSB3YW50IHRvIGV4cG9zZSB0aGlzIGFzIGEgYnVpbGQgZmxhZyBvciByZW1vdmUgaXRcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gPSB0cnVlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NpemVcbiAqL1xuXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYSBzaXplOiBgW3dpZHRoLCBoZWlnaHRdYC5cbiAqIEB0eXBlZGVmIHtBcnJheS48bnVtYmVyPn0gU2l6ZVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyZWQgc2l6ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRvIGJ1ZmZlci5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NpemV+U2l6ZT19IG9wdF9zaXplIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBUaGUgYnVmZmVyZWQgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihzaXplLCBudW0sIG9wdF9zaXplKSB7XG4gIGlmIChvcHRfc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0X3NpemUgPSBbMCwgMF07XG4gIH1cbiAgb3B0X3NpemVbMF0gPSBzaXplWzBdICsgMiAqIG51bTtcbiAgb3B0X3NpemVbMV0gPSBzaXplWzFdICsgMiAqIG51bTtcbiAgcmV0dXJuIG9wdF9zaXplO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHNpemUgaGFzIGEgcG9zaXRpdmUgYXJlYS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gc2l6ZSBUaGUgc2l6ZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHNpemUgaGFzIGEgcG9zaXRpdmUgYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0FyZWEoc2l6ZSkge1xuICByZXR1cm4gc2l6ZVswXSA+IDAgJiYgc2l6ZVsxXSA+IDA7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2l6ZSBzY2FsZWQgYnkgYSByYXRpby4gVGhlIHJlc3VsdCB3aWxsIGJlIGFuIGFycmF5IG9mIGludGVnZXJzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBzaXplIFNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gUmF0aW8uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zaXplflNpemU9fSBvcHRfc2l6ZSBPcHRpb25hbCByZXVzYWJsZSBzaXplIGFycmF5LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gVGhlIHNjYWxlZCBzaXplLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUoc2l6ZSwgcmF0aW8sIG9wdF9zaXplKSB7XG4gIGlmIChvcHRfc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0X3NpemUgPSBbMCwgMF07XG4gIH1cbiAgb3B0X3NpemVbMF0gPSAoc2l6ZVswXSAqIHJhdGlvICsgMC41KSB8IDA7XG4gIG9wdF9zaXplWzFdID0gKHNpemVbMV0gKiByYXRpbyArIDAuNSkgfCAwO1xuICByZXR1cm4gb3B0X3NpemU7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGBtb2R1bGU6b2wvc2l6ZX5TaXplYCBhcnJheSBmb3IgdGhlIHBhc3NlZCBpbiBudW1iZXIgKG1lYW5pbmc6IHNxdWFyZSkgb3JcbiAqIGBtb2R1bGU6b2wvc2l6ZX5TaXplYCBhcnJheS5cbiAqIChtZWFuaW5nOiBub24tc3F1YXJlKSxcbiAqIEBwYXJhbSB7bnVtYmVyfG1vZHVsZTpvbC9zaXplflNpemV9IHNpemUgV2lkdGggYW5kIGhlaWdodC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NpemV+U2l6ZT19IG9wdF9zaXplIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBTaXplLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TaXplKHNpemUsIG9wdF9zaXplKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNpemUpKSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdF9zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdF9zaXplID0gW3NpemUsIHNpemVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRfc2l6ZVswXSA9IG9wdF9zaXplWzFdID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdF9zaXplO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1NvdXJjZVxuICovXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCBTb3VyY2VTdGF0ZSBmcm9tICcuLi9zb3VyY2UvU3RhdGUuanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgc291cmNlXG4gKiBhdHRyaWJ1dGlvbnMuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG1vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZSk6IChzdHJpbmd8QXJyYXkuPHN0cmluZz4pfSBBdHRyaWJ1dGlvblxuICovXG5cblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGF0dHJpYnV0aW9uIGluZm9ybWF0aW9uIGZvciBkYXRhIHNvdXJjZXMuXG4gKlxuICogSXQgcmVwcmVzZW50cyBlaXRoZXJcbiAqICogYSBzaW1wbGUgc3RyaW5nIChlLmcuIGAnwqkgQWNtZSBJbmMuJ2ApXG4gKiAqIGFuIGFycmF5IG9mIHNpbXBsZSBzdHJpbmdzIChlLmcuIGBbJ8KpIEFjbWUgSW5jLicsICfCqSBCYWNtZSBJbmMuJ11gKVxuICogKiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzIChge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufWApXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ3xBcnJheS48c3RyaW5nPnxtb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn0gQXR0cmlidXRpb25MaWtlXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvblxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1N0YXRlfSBbc3RhdGVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWF1cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3Ige0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllcn0gc291cmNlcy5cbiAqXG4gKiBBIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UgY2hhbmdlcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhYnN0cmFjdFxuICogQGV4dGVuZHMge21vZHVsZTpvbC9PYmplY3R9XG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfk9wdGlvbnN9IG9wdGlvbnMgU291cmNlIG9wdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmNvbnN0IFNvdXJjZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufVxuICAgKi9cbiAgdGhpcy5wcm9qZWN0aW9uXyA9IGdldFByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgez9tb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn1cbiAgICovXG4gIHRoaXMuYXR0cmlidXRpb25zXyA9IHRoaXMuYWRhcHRBdHRyaWJ1dGlvbnNfKG9wdGlvbnMuYXR0cmlidXRpb25zKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9XG4gICAqL1xuICB0aGlzLnN0YXRlXyA9IG9wdGlvbnMuc3RhdGUgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5zdGF0ZSA6IFNvdXJjZVN0YXRlLlJFQURZO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMud3JhcFhfID0gb3B0aW9ucy53cmFwWCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwWCA6IGZhbHNlO1xuXG59O1xuXG5pbmhlcml0cyhTb3VyY2UsIEJhc2VPYmplY3QpO1xuXG4vKipcbiAqIFR1cm5zIHRoZSBhdHRyaWJ1dGlvbnMgb3B0aW9uIGludG8gYW4gYXR0cmlidXRpb25zIGZ1bmN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbkxpa2V8dW5kZWZpbmVkfSBhdHRyaWJ1dGlvbkxpa2UgVGhlIGF0dHJpYnV0aW9uIG9wdGlvbi5cbiAqIEByZXR1cm4gez9tb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn0gQW4gYXR0cmlidXRpb24gZnVuY3Rpb24gKG9yIG51bGwpLlxuICovXG5Tb3VyY2UucHJvdG90eXBlLmFkYXB0QXR0cmlidXRpb25zXyA9IGZ1bmN0aW9uKGF0dHJpYnV0aW9uTGlrZSkge1xuICBpZiAoIWF0dHJpYnV0aW9uTGlrZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGF0dHJpYnV0aW9uTGlrZSkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0aW9uTGlrZTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGlvbkxpa2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXR0cmlidXRpb25MaWtlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZyYW1lU3RhdGUpIHtcbiAgICByZXR1cm4gW2F0dHJpYnV0aW9uTGlrZV07XG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBib29sZWFuPn0gc2tpcHBlZEZlYXR1cmVVaWRzIFNraXBwZWQgZmVhdHVyZSB1aWRzLlxuICogQHBhcmFtIHtmdW5jdGlvbigobW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlKSk6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICogQHRlbXBsYXRlIFRcbiAqL1xuU291cmNlLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSA9IFVOREVGSU5FRDtcblxuXG4vKipcbiAqIEdldCB0aGUgYXR0cmlidXRpb24gZnVuY3Rpb24gZm9yIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHs/bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb259IEF0dHJpYnV0aW9uIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2UucHJvdG90eXBlLmdldEF0dHJpYnV0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5hdHRyaWJ1dGlvbnNfO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgcHJvamVjdGlvbiBvZiB0aGUgc291cmNlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gUHJvamVjdGlvbi5cbiAqIEBhcGlcbiAqL1xuU291cmNlLnByb3RvdHlwZS5nZXRQcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnByb2plY3Rpb25fO1xufTtcblxuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj58dW5kZWZpbmVkfSBSZXNvbHV0aW9ucy5cbiAqL1xuU291cmNlLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9ucyA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBHZXQgdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UsIHNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9TdGF0ZX5TdGF0ZX0gZm9yIHBvc3NpYmxlIHN0YXRlcy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IFN0YXRlLlxuICogQGFwaVxuICovXG5Tb3VyY2UucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlXztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gV3JhcCBYLlxuICovXG5Tb3VyY2UucHJvdG90eXBlLmdldFdyYXBYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndyYXBYXztcbn07XG5cblxuLyoqXG4gKiBSZWZyZXNoZXMgdGhlIHNvdXJjZSBhbmQgZmluYWxseSBkaXNwYXRjaGVzIGEgJ2NoYW5nZScgZXZlbnQuXG4gKiBAYXBpXG4gKi9cblNvdXJjZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0aW9ucyBvZiB0aGUgc291cmNlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbkxpa2V8dW5kZWZpbmVkfSBhdHRyaWJ1dGlvbnMgQXR0cmlidXRpb25zLlxuICogICAgIENhbiBiZSBwYXNzZWQgYXMgYHN0cmluZ2AsIGBBcnJheTxzdHJpbmc+YCwgYHtAbGluayBtb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn1gLFxuICogICAgIG9yIGB1bmRlZmluZWRgLlxuICogQGFwaVxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldEF0dHJpYnV0aW9ucyA9IGZ1bmN0aW9uKGF0dHJpYnV0aW9ucykge1xuICB0aGlzLmF0dHJpYnV0aW9uc18gPSB0aGlzLmFkYXB0QXR0cmlidXRpb25zXyhhdHRyaWJ1dGlvbnMpO1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IHN0YXRlIFN0YXRlLlxuICogQHByb3RlY3RlZFxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgdGhpcy5jaGFuZ2VkKCk7XG59O1xuZXhwb3J0IGRlZmF1bHQgU291cmNlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9TdGF0ZVxuICovXG5cbi8qKlxuICogU3RhdGUgb2YgdGhlIHNvdXJjZSwgb25lIG9mICd1bmRlZmluZWQnLCAnbG9hZGluZycsICdyZWFkeScgb3IgJ2Vycm9yJy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVU5ERUZJTkVEOiAndW5kZWZpbmVkJyxcbiAgTE9BRElORzogJ2xvYWRpbmcnLFxuICBSRUFEWTogJ3JlYWR5JyxcbiAgRVJST1I6ICdlcnJvcidcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1RpbGVcbiAqL1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IHtVTkRFRklORUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgVGlsZUNhY2hlIGZyb20gJy4uL1RpbGVDYWNoZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCB7ZXF1aXZhbGVudH0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge3RvU2l6ZSwgc2NhbGUgYXMgc2NhbGVTaXplfSBmcm9tICcuLi9zaXplLmpzJztcbmltcG9ydCBTb3VyY2UgZnJvbSAnLi4vc291cmNlL1NvdXJjZS5qcyc7XG5pbXBvcnQge2dldEtleVpYWSwgd2l0aGluRXh0ZW50QW5kWn0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcbmltcG9ydCB7d3JhcFgsIGdldEZvclByb2plY3Rpb24gYXMgZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9ufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV1cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IFtleHRlbnRdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWVdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IFtzdGF0ZV1cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBbdGlsZUdyaWRdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciBzb3VyY2VzIHByb3ZpZGluZyBpbWFnZXMgZGl2aWRlZCBpbnRvIGEgdGlsZSBncmlkLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFic3RyYWN0XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V9XG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvVGlsZX5PcHRpb25zPX0gb3B0aW9ucyBTb3VyY2VUaWxlIHNvdXJjZSBvcHRpb25zLlxuICogQGFwaVxuICovXG5jb25zdCBUaWxlU291cmNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gIFNvdXJjZS5jYWxsKHRoaXMsIHtcbiAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgIGV4dGVudDogb3B0aW9ucy5leHRlbnQsXG4gICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgIHdyYXBYOiBvcHRpb25zLndyYXBYXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMub3BhcXVlXyA9IG9wdGlvbnMub3BhcXVlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYXF1ZSA6IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy50aWxlUGl4ZWxSYXRpb18gPSBvcHRpb25zLnRpbGVQaXhlbFJhdGlvICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gOiAxO1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9XG4gICAqL1xuICB0aGlzLnRpbGVHcmlkID0gb3B0aW9ucy50aWxlR3JpZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aWxlR3JpZCA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge21vZHVsZTpvbC9UaWxlQ2FjaGV9XG4gICAqL1xuICB0aGlzLnRpbGVDYWNoZSA9IG5ldyBUaWxlQ2FjaGUob3B0aW9ucy5jYWNoZVNpemUpO1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvc2l6ZX5TaXplfVxuICAgKi9cbiAgdGhpcy50bXBTaXplID0gWzAsIDBdO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5rZXlfID0gJyc7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge21vZHVsZTpvbC9UaWxlfk9wdGlvbnN9XG4gICAqL1xuICB0aGlzLnRpbGVPcHRpb25zID0ge3RyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbn07XG5cbn07XG5cbmluaGVyaXRzKFRpbGVTb3VyY2UsIFNvdXJjZSk7XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBDYW4gZXhwaXJlIGNhY2hlLlxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5jYW5FeHBpcmVDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50aWxlQ2FjaGUuY2FuRXhwaXJlQ2FjaGUoKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvVGlsZVJhbmdlPn0gdXNlZFRpbGVzIFVzZWQgdGlsZXMuXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLmV4cGlyZUNhY2hlID0gZnVuY3Rpb24ocHJvamVjdGlvbiwgdXNlZFRpbGVzKSB7XG4gIGNvbnN0IHRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgaWYgKHRpbGVDYWNoZSkge1xuICAgIHRpbGVDYWNoZS5leHBpcmVDYWNoZSh1c2VkVGlsZXMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0geiBab29tIGxldmVsLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obW9kdWxlOm9sL1RpbGUpOihib29sZWFufHVuZGVmaW5lZCl9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2hcbiAqICAgICBsb2FkZWQgdGlsZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHRoZSB0aWxlIHdpbGwgbm90IGJlXG4gKiAgICAgY29uc2lkZXJlZCBsb2FkZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdGlsZSByYW5nZSBpcyBmdWxseSBjb3ZlcmVkIHdpdGggbG9hZGVkIHRpbGVzLlxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5mb3JFYWNoTG9hZGVkVGlsZSA9IGZ1bmN0aW9uKHByb2plY3Rpb24sIHosIHRpbGVSYW5nZSwgY2FsbGJhY2spIHtcbiAgY29uc3QgdGlsZUNhY2hlID0gdGhpcy5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBpZiAoIXRpbGVDYWNoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBjb3ZlcmVkID0gdHJ1ZTtcbiAgbGV0IHRpbGUsIHRpbGVDb29yZEtleSwgbG9hZGVkO1xuICBmb3IgKGxldCB4ID0gdGlsZVJhbmdlLm1pblg7IHggPD0gdGlsZVJhbmdlLm1heFg7ICsreCkge1xuICAgIGZvciAobGV0IHkgPSB0aWxlUmFuZ2UubWluWTsgeSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt5KSB7XG4gICAgICB0aWxlQ29vcmRLZXkgPSBnZXRLZXlaWFkoeiwgeCwgeSk7XG4gICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aWxlQ2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgICB0aWxlID0gLyoqIEB0eXBlIHshbW9kdWxlOm9sL1RpbGV9ICovICh0aWxlQ2FjaGUuZ2V0KHRpbGVDb29yZEtleSkpO1xuICAgICAgICBsb2FkZWQgPSB0aWxlLmdldFN0YXRlKCkgPT09IFRpbGVTdGF0ZS5MT0FERUQ7XG4gICAgICAgIGlmIChsb2FkZWQpIHtcbiAgICAgICAgICBsb2FkZWQgPSAoY2FsbGJhY2sodGlsZSkgIT09IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgICAgY292ZXJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY292ZXJlZDtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRHdXR0ZXIgPSBmdW5jdGlvbihwcm9qZWN0aW9uKSB7XG4gIHJldHVybiAwO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUga2V5IHRvIGJlIHVzZWQgZm9yIGFsbCB0aWxlcyBpbiB0aGUgc291cmNlLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUga2V5IGZvciBhbGwgdGlsZXMuXG4gKiBAcHJvdGVjdGVkXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5rZXlfO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgdG8gYmUgdXNlZCBhcyB0aGUga2V5IGZvciBhbGwgdGlsZXMgaW4gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBmb3IgdGlsZXMuXG4gKiBAcHJvdGVjdGVkXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLnNldEtleSA9IGZ1bmN0aW9uKGtleSkge1xuICBpZiAodGhpcy5rZXlfICE9PSBrZXkpIHtcbiAgICB0aGlzLmtleV8gPSBrZXk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IE9wYXF1ZS5cbiAqL1xuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0T3BhcXVlID0gZnVuY3Rpb24ocHJvamVjdGlvbikge1xuICByZXR1cm4gdGhpcy5vcGFxdWVfO1xufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLmdldFJlc29sdXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRpbGVHcmlkLmdldFJlc29sdXRpb25zKCk7XG59O1xuXG5cbi8qKlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7IW1vZHVsZTpvbC9UaWxlfSBUaWxlLlxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge307XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHRpbGUgZ3JpZCBvZiB0aGUgdGlsZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IFRpbGUgZ3JpZC5cbiAqIEBhcGlcbiAqL1xuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUdyaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudGlsZUdyaWQ7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBUaWxlIGdyaWQuXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uKHByb2plY3Rpb24pIHtcbiAgaWYgKCF0aGlzLnRpbGVHcmlkKSB7XG4gICAgcmV0dXJuIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL1RpbGVDYWNoZX0gVGlsZSBjYWNoZS5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uKHByb2plY3Rpb24pIHtcbiAgY29uc3QgdGhpc1Byb2ogPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgaWYgKHRoaXNQcm9qICYmICFlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdGlsZSBwaXhlbCByYXRpbyBmb3IgdGhpcyBzb3VyY2UuIFN1YmNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXNcbiAqIG1ldGhvZCwgd2hpY2ggaXMgbWVhbnQgdG8gcmV0dXJuIGEgc3VwcG9ydGVkIHBpeGVsIHJhdGlvIHRoYXQgbWF0Y2hlcyB0aGVcbiAqIHByb3ZpZGVkIGBwaXhlbFJhdGlvYCBhcyBjbG9zZSBhcyBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHJldHVybiB7bnVtYmVyfSBUaWxlIHBpeGVsIHJhdGlvLlxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlUGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKHBpeGVsUmF0aW8pIHtcbiAgcmV0dXJuIHRoaXMudGlsZVBpeGVsUmF0aW9fO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gVGlsZSBzaXplLlxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlUGl4ZWxTaXplID0gZnVuY3Rpb24oeiwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICBjb25zdCB0aWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBjb25zdCB0aWxlUGl4ZWxSYXRpbyA9IHRoaXMuZ2V0VGlsZVBpeGVsUmF0aW8ocGl4ZWxSYXRpbyk7XG4gIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRpbGVHcmlkLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemUpO1xuICBpZiAodGlsZVBpeGVsUmF0aW8gPT0gMSkge1xuICAgIHJldHVybiB0aWxlU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2NhbGVTaXplKHRpbGVTaXplLCB0aWxlUGl4ZWxSYXRpbywgdGhpcy50bXBTaXplKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSB0aWxlIGNvb3JkaW5hdGUgd3JhcHBlZCBhcm91bmQgdGhlIHgtYXhpcy4gV2hlbiB0aGUgdGlsZSBjb29yZGluYXRlXG4gKiBpcyBvdXRzaWRlIHRoZSByZXNvbHV0aW9uIGFuZCBleHRlbnQgcmFuZ2Ugb2YgdGhlIHRpbGUgZ3JpZCwgYG51bGxgIHdpbGwgYmVcbiAqIHJldHVybmVkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbj19IG9wdF9wcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlIHRvIGJlIHBhc3NlZCB0byB0aGUgdGlsZVVybEZ1bmN0aW9uIG9yXG4gKiAgICAgbnVsbCBpZiBubyB0aWxlIFVSTCBzaG91bGQgYmUgY3JlYXRlZCBmb3IgdGhlIHBhc3NlZCBgdGlsZUNvb3JkYC5cbiAqL1xuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uID0gZnVuY3Rpb24odGlsZUNvb3JkLCBvcHRfcHJvamVjdGlvbikge1xuICBjb25zdCBwcm9qZWN0aW9uID0gb3B0X3Byb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0X3Byb2plY3Rpb24gOiB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgY29uc3QgdGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgaWYgKHRoaXMuZ2V0V3JhcFgoKSAmJiBwcm9qZWN0aW9uLmlzR2xvYmFsKCkpIHtcbiAgICB0aWxlQ29vcmQgPSB3cmFwWCh0aWxlR3JpZCwgdGlsZUNvb3JkLCBwcm9qZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gd2l0aGluRXh0ZW50QW5kWih0aWxlQ29vcmQsIHRpbGVHcmlkKSA/IHRpbGVDb29yZCA6IG51bGw7XG59O1xuXG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuVGlsZVNvdXJjZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnRpbGVDYWNoZS5jbGVhcigpO1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5cblxuLyoqXG4gKiBNYXJrcyBhIHRpbGUgY29vcmQgYXMgYmVpbmcgdXNlZCwgd2l0aG91dCB0cmlnZ2VyaW5nIGEgbG9hZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS51c2VUaWxlID0gVU5ERUZJTkVEO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlU291cmNlfSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZiB0aGlzXG4gKiB0eXBlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTpvbC9ldmVudHMvRXZlbnR9XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZX0gdGlsZSBUaGUgdGlsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IFRpbGVTb3VyY2VFdmVudCA9IGZ1bmN0aW9uKHR5cGUsIHRpbGUpIHtcblxuICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gIC8qKlxuICAgKiBUaGUgdGlsZSByZWxhdGVkIHRvIHRoZSBldmVudC5cbiAgICogQHR5cGUge21vZHVsZTpvbC9UaWxlfVxuICAgKiBAYXBpXG4gICAqL1xuICB0aGlzLnRpbGUgPSB0aWxlO1xuXG59O1xuaW5oZXJpdHMoVGlsZVNvdXJjZUV2ZW50LCBFdmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVTb3VyY2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1RpbGVFdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSB0aWxlIHN0YXJ0cyBsb2FkaW5nLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIFRJTEVMT0FEU1RBUlQ6ICd0aWxlbG9hZHN0YXJ0JyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSB0aWxlIGZpbmlzaGVzIGxvYWRpbmcsIGVpdGhlciB3aGVuIGl0cyBkYXRhIGlzIGxvYWRlZCxcbiAgICogb3Igd2hlbiBsb2FkaW5nIHdhcyBhYm9ydGVkIGJlY2F1c2UgdGhlIHRpbGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlU291cmNlRXZlbnQjdGlsZWxvYWRlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgVElMRUxPQURFTkQ6ICd0aWxlbG9hZGVuZCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBpZiB0aWxlIGxvYWRpbmcgcmVzdWx0cyBpbiBhbiBlcnJvci5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlU291cmNlRXZlbnQjdGlsZWxvYWRlcnJvclxuICAgKiBAYXBpXG4gICAqL1xuICBUSUxFTE9BREVSUk9SOiAndGlsZWxvYWRlcnJvcidcblxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZUltYWdlXG4gKi9cbmltcG9ydCB7RU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT059IGZyb20gJy4uL3JlcHJvai9jb21tb24uanMnO1xuaW1wb3J0IHtnZXRVaWQsIGluaGVyaXRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgSW1hZ2VUaWxlIGZyb20gJy4uL0ltYWdlVGlsZS5qcyc7XG5pbXBvcnQgVGlsZUNhY2hlIGZyb20gJy4uL1RpbGVDYWNoZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2VxdWl2YWxlbnQsIGdldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCBSZXByb2pUaWxlIGZyb20gJy4uL3JlcHJvai9UaWxlLmpzJztcbmltcG9ydCBVcmxUaWxlIGZyb20gJy4uL3NvdXJjZS9VcmxUaWxlLmpzJztcbmltcG9ydCB7Z2V0S2V5LCBnZXRLZXlaWFl9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge2dldEZvclByb2plY3Rpb24gYXMgZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9ufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTIwNDhdIENhY2hlIHNpemUuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IGFyZSB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXIgb3IgaWYgeW91IHdhbnQgdG9cbiAqIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci4gIFNlZVxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlfSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWU9dHJ1ZV0gV2hldGhlciB0aGUgbGF5ZXIgaXMgb3BhcXVlLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MC41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1N0YXRlfSBbc3RhdGVdIFNvdXJjZSBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL0ltYWdlVGlsZX5UaWxlQ2xhc3N9IFt0aWxlQ2xhc3NdIENsYXNzIHVzZWQgdG8gaW5zdGFudGlhdGUgaW1hZ2UgdGlsZXMuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvSW1hZ2VUaWxlfkltYWdlVGlsZX0uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gW3RpbGVHcmlkXSBUaWxlIGdyaWQuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbn0gW3RpbGVMb2FkRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvYWQgYSB0aWxlIGdpdmVuIGEgVVJMLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIGZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gKiAgIGltYWdlVGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH07XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGlsZVBpeGVsUmF0aW89MV0gVGhlIHBpeGVsIHJhdGlvIHVzZWQgYnkgdGhlIHRpbGUgc2VydmljZS4gRm9yIGV4YW1wbGUsIGlmIHRoZSB0aWxlXG4gKiBzZXJ2aWNlIGFkdmVydGl6ZXMgMjU2cHggYnkgMjU2cHggdGlsZXMgYnV0IGFjdHVhbGx5IHNlbmRzIDUxMnB4XG4gKiBieSA1MTJweCBpbWFnZXMgKGZvciByZXRpbmEvaGlkcGkgZGV2aWNlcykgdGhlbiBgdGlsZVBpeGVsUmF0aW9gXG4gKiBzaG91bGQgYmUgc2V0IHRvIGAyYC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1RpbGV+VXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGdldCB0aWxlIFVSTCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSBhbmQgdGhlIHByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF0gVVJMIHRlbXBsYXRlLiBNdXN0IGluY2x1ZGUgYHt4fWAsIGB7eX1gIG9yIGB7LXl9YCwgYW5kIGB7en1gIHBsYWNlaG9sZGVycy5cbiAqIEEgYHs/LT99YCB0ZW1wbGF0ZSBwYXR0ZXJuLCBmb3IgZXhhbXBsZSBgc3ViZG9tYWlue2EtZn0uZG9tYWluLmNvbWAsIG1heSBiZVxuICogdXNlZCBpbnN0ZWFkIG9mIGRlZmluaW5nIGVhY2ggb25lIHNlcGFyYXRlbHkgaW4gdGhlIGB1cmxzYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBbdXJsc10gQW4gYXJyYXkgb2YgVVJMIHRlbXBsYXRlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS4gVGhlIGRlZmF1bHQsIGlzIHRvXG4gKiByZXF1ZXN0IG91dC1vZi1ib3VuZHMgdGlsZXMgZnJvbSB0aGUgc2VydmVyLiBXaGVuIHNldCB0byBgZmFsc2VgLCBvbmx5IG9uZVxuICogd29ybGQgd2lsbCBiZSByZW5kZXJlZC4gV2hlbiBzZXQgdG8gYHRydWVgLCB0aWxlcyB3aWxsIGJlIHJlcXVlc3RlZCBmb3Igb25lXG4gKiB3b3JsZCBvbmx5LCBidXQgdGhleSB3aWxsIGJlIHdyYXBwZWQgaG9yaXpvbnRhbGx5IHRvIHJlbmRlciBtdWx0aXBsZSB3b3JsZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb25dIER1cmF0aW9uIG9mIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24gZm9yIHJlbmRlcmluZy5cbiAqIFRvIGRpc2FibGUgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiwgcGFzcyBgdHJhbnNpdGlvbjogMGAuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMgcHJvdmlkaW5nIGltYWdlcyBkaXZpZGVkIGludG8gYSB0aWxlIGdyaWQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmlyZXMgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2VFdmVudFxuICogQGV4dGVuZHMge21vZHVsZTpvbC9zb3VyY2UvVXJsVGlsZX1cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NvdXJjZS9UaWxlSW1hZ2V+T3B0aW9ucz19IG9wdGlvbnMgSW1hZ2UgdGlsZSBvcHRpb25zLlxuICogQGFwaVxuICovXG5jb25zdCBUaWxlSW1hZ2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgVXJsVGlsZS5jYWxsKHRoaXMsIHtcbiAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgZXh0ZW50OiBvcHRpb25zLmV4dGVudCxcbiAgICBvcGFxdWU6IG9wdGlvbnMub3BhcXVlLFxuICAgIHByb2plY3Rpb246IG9wdGlvbnMucHJvamVjdGlvbixcbiAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICB0aWxlR3JpZDogb3B0aW9ucy50aWxlR3JpZCxcbiAgICB0aWxlTG9hZEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb24gP1xuICAgICAgb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uIDogZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24sXG4gICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgdGlsZVVybEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbixcbiAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgIHVybHM6IG9wdGlvbnMudXJscyxcbiAgICB3cmFwWDogb3B0aW9ucy53cmFwWCxcbiAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb25cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqL1xuICB0aGlzLmNyb3NzT3JpZ2luID1cbiAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3Jvc3NPcmlnaW4gOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHtmdW5jdGlvbihuZXc6IG1vZHVsZTpvbC9JbWFnZVRpbGUsIG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkLCBtb2R1bGU6b2wvVGlsZVN0YXRlLCBzdHJpbmcsXG4gICAqICAgICAgICA/c3RyaW5nLCBtb2R1bGU6b2wvVGlsZX5Mb2FkRnVuY3Rpb24sIG1vZHVsZTpvbC9UaWxlfk9wdGlvbnM9KX1cbiAgICovXG4gIHRoaXMudGlsZUNsYXNzID0gb3B0aW9ucy50aWxlQ2xhc3MgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy50aWxlQ2xhc3MgOiBJbWFnZVRpbGU7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL1RpbGVDYWNoZT59XG4gICAqL1xuICB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24gPSB7fTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWQ+fVxuICAgKi9cbiAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24gPSB7fTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkXyA9IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18gPSBmYWxzZTtcbn07XG5cbmluaGVyaXRzKFRpbGVJbWFnZSwgVXJsVGlsZSk7XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5UaWxlSW1hZ2UucHJvdG90eXBlLmNhbkV4cGlyZUNhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICByZXR1cm4gVXJsVGlsZS5wcm90b3R5cGUuY2FuRXhwaXJlQ2FjaGUuY2FsbCh0aGlzKTtcbiAgfVxuICBpZiAodGhpcy50aWxlQ2FjaGUuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbikge1xuICAgICAgaWYgKHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltrZXldLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5UaWxlSW1hZ2UucHJvdG90eXBlLmV4cGlyZUNhY2hlID0gZnVuY3Rpb24ocHJvamVjdGlvbiwgdXNlZFRpbGVzKSB7XG4gIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICBVcmxUaWxlLnByb3RvdHlwZS5leHBpcmVDYWNoZS5jYWxsKHRoaXMsIHByb2plY3Rpb24sIHVzZWRUaWxlcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVzZWRUaWxlQ2FjaGUgPSB0aGlzLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG5cbiAgdGhpcy50aWxlQ2FjaGUuZXhwaXJlQ2FjaGUodGhpcy50aWxlQ2FjaGUgPT0gdXNlZFRpbGVDYWNoZSA/IHVzZWRUaWxlcyA6IHt9KTtcbiAgZm9yIChjb25zdCBpZCBpbiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24pIHtcbiAgICBjb25zdCB0aWxlQ2FjaGUgPSB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25baWRdO1xuICAgIHRpbGVDYWNoZS5leHBpcmVDYWNoZSh0aWxlQ2FjaGUgPT0gdXNlZFRpbGVDYWNoZSA/IHVzZWRUaWxlcyA6IHt9KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0R3V0dGVyID0gZnVuY3Rpb24ocHJvamVjdGlvbikge1xuICBpZiAoRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gJiZcbiAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpICYmIHByb2plY3Rpb24gJiYgIWVxdWl2YWxlbnQodGhpcy5nZXRQcm9qZWN0aW9uKCksIHByb2plY3Rpb24pKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R3V0dGVySW50ZXJuYWwoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBwcm90ZWN0ZWRcbiAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICovXG5UaWxlSW1hZ2UucHJvdG90eXBlLmdldEd1dHRlckludGVybmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0T3BhcXVlID0gZnVuY3Rpb24ocHJvamVjdGlvbikge1xuICBpZiAoRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gJiZcbiAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpICYmIHByb2plY3Rpb24gJiYgIWVxdWl2YWxlbnQodGhpcy5nZXRQcm9qZWN0aW9uKCksIHByb2plY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBVcmxUaWxlLnByb3RvdHlwZS5nZXRPcGFxdWUuY2FsbCh0aGlzLCBwcm9qZWN0aW9uKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24ocHJvamVjdGlvbikge1xuICBpZiAoIUVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OKSB7XG4gICAgcmV0dXJuIFVybFRpbGUucHJvdG90eXBlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbi5jYWxsKHRoaXMsIHByb2plY3Rpb24pO1xuICB9XG4gIGNvbnN0IHRoaXNQcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gIGlmICh0aGlzLnRpbGVHcmlkICYmICghdGhpc1Byb2ogfHwgZXF1aXZhbGVudCh0aGlzUHJvaiwgcHJvamVjdGlvbikpKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUdyaWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJvaktleSA9IGdldFVpZChwcm9qZWN0aW9uKS50b1N0cmluZygpO1xuICAgIGlmICghKHByb2pLZXkgaW4gdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24pKSB7XG4gICAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9IGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7IW1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gKi8gKHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uW3Byb2pLZXldKVxuICAgICk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5UaWxlSW1hZ2UucHJvdG90eXBlLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24gPSBmdW5jdGlvbihwcm9qZWN0aW9uKSB7XG4gIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICByZXR1cm4gVXJsVGlsZS5wcm90b3R5cGUuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbi5jYWxsKHRoaXMsIHByb2plY3Rpb24pO1xuICB9XG4gIGNvbnN0IHRoaXNQcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7IGlmICghdGhpc1Byb2ogfHwgZXF1aXZhbGVudCh0aGlzUHJvaiwgcHJvamVjdGlvbikpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJvaktleSA9IGdldFVpZChwcm9qZWN0aW9uKS50b1N0cmluZygpO1xuICAgIGlmICghKHByb2pLZXkgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSkge1xuICAgICAgdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW3Byb2pLZXldID0gbmV3IFRpbGVDYWNoZSh0aGlzLnRpbGVDYWNoZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltwcm9qS2V5XTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgc2V0IG9uIHRoZSB0aWxlLlxuICogQHJldHVybiB7IW1vZHVsZTpvbC9UaWxlfSBUaWxlLlxuICogQHByaXZhdGVcbiAqL1xuVGlsZUltYWdlLnByb3RvdHlwZS5jcmVhdGVUaWxlXyA9IGZ1bmN0aW9uKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24sIGtleSkge1xuICBjb25zdCB0aWxlQ29vcmQgPSBbeiwgeCwgeV07XG4gIGNvbnN0IHVybFRpbGVDb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uKFxuICAgIHRpbGVDb29yZCwgcHJvamVjdGlvbik7XG4gIGNvbnN0IHRpbGVVcmwgPSB1cmxUaWxlQ29vcmQgP1xuICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uKHVybFRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHRpbGUgPSBuZXcgdGhpcy50aWxlQ2xhc3MoXG4gICAgdGlsZUNvb3JkLFxuICAgIHRpbGVVcmwgIT09IHVuZGVmaW5lZCA/IFRpbGVTdGF0ZS5JRExFIDogVGlsZVN0YXRlLkVNUFRZLFxuICAgIHRpbGVVcmwgIT09IHVuZGVmaW5lZCA/IHRpbGVVcmwgOiAnJyxcbiAgICB0aGlzLmNyb3NzT3JpZ2luLFxuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbixcbiAgICB0aGlzLnRpbGVPcHRpb25zKTtcbiAgdGlsZS5rZXkgPSBrZXk7XG4gIGxpc3Rlbih0aWxlLCBFdmVudFR5cGUuQ0hBTkdFLFxuICAgIHRoaXMuaGFuZGxlVGlsZUNoYW5nZSwgdGhpcyk7XG4gIHJldHVybiB0aWxlO1xufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0VGlsZSA9IGZ1bmN0aW9uKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgY29uc3Qgc291cmNlUHJvamVjdGlvbiA9IC8qKiBAdHlwZSB7IW1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259ICovICh0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gfHxcbiAgICAgICFzb3VyY2VQcm9qZWN0aW9uIHx8ICFwcm9qZWN0aW9uIHx8IGVxdWl2YWxlbnQoc291cmNlUHJvamVjdGlvbiwgcHJvamVjdGlvbikpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlSW50ZXJuYWwoeiwgeCwgeSwgcGl4ZWxSYXRpbywgc291cmNlUHJvamVjdGlvbiB8fCBwcm9qZWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBjb25zdCB0aWxlQ29vcmQgPSBbeiwgeCwgeV07XG4gICAgbGV0IHRpbGU7XG4gICAgY29uc3QgdGlsZUNvb3JkS2V5ID0gZ2V0S2V5KHRpbGVDb29yZCk7XG4gICAgaWYgKGNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgIHRpbGUgPSAvKiogQHR5cGUgeyFtb2R1bGU6b2wvVGlsZX0gKi8gKGNhY2hlLmdldCh0aWxlQ29vcmRLZXkpKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICBpZiAodGlsZSAmJiB0aWxlLmtleSA9PSBrZXkpIHtcbiAgICAgIHJldHVybiB0aWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzb3VyY2VUaWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHNvdXJjZVByb2plY3Rpb24pO1xuICAgICAgY29uc3QgdGFyZ2V0VGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIGNvbnN0IHdyYXBwZWRUaWxlQ29vcmQgPVxuICAgICAgICAgIHRoaXMuZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uKHRpbGVDb29yZCwgcHJvamVjdGlvbik7XG4gICAgICBjb25zdCBuZXdUaWxlID0gbmV3IFJlcHJvalRpbGUoXG4gICAgICAgIHNvdXJjZVByb2plY3Rpb24sIHNvdXJjZVRpbGVHcmlkLFxuICAgICAgICBwcm9qZWN0aW9uLCB0YXJnZXRUaWxlR3JpZCxcbiAgICAgICAgdGlsZUNvb3JkLCB3cmFwcGVkVGlsZUNvb3JkLCB0aGlzLmdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pLFxuICAgICAgICB0aGlzLmdldEd1dHRlckludGVybmFsKCksXG4gICAgICAgIGZ1bmN0aW9uKHosIHgsIHksIHBpeGVsUmF0aW8pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlSW50ZXJuYWwoeiwgeCwgeSwgcGl4ZWxSYXRpbywgc291cmNlUHJvamVjdGlvbik7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZF8sXG4gICAgICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfKTtcbiAgICAgIG5ld1RpbGUua2V5ID0ga2V5O1xuXG4gICAgICBpZiAodGlsZSkge1xuICAgICAgICBuZXdUaWxlLmludGVyaW1UaWxlID0gdGlsZTtcbiAgICAgICAgbmV3VGlsZS5yZWZyZXNoSW50ZXJpbUNoYWluKCk7XG4gICAgICAgIGNhY2hlLnJlcGxhY2UodGlsZUNvb3JkS2V5LCBuZXdUaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlLnNldCh0aWxlQ29vcmRLZXksIG5ld1RpbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1RpbGU7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0geyFtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL1RpbGV9IFRpbGUuXG4gKiBAcHJvdGVjdGVkXG4gKi9cblRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0VGlsZUludGVybmFsID0gZnVuY3Rpb24oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICBsZXQgdGlsZSA9IG51bGw7XG4gIGNvbnN0IHRpbGVDb29yZEtleSA9IGdldEtleVpYWSh6LCB4LCB5KTtcbiAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgaWYgKCF0aGlzLnRpbGVDYWNoZS5jb250YWluc0tleSh0aWxlQ29vcmRLZXkpKSB7XG4gICAgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZV8oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbiwga2V5KTtcbiAgICB0aGlzLnRpbGVDYWNoZS5zZXQodGlsZUNvb3JkS2V5LCB0aWxlKTtcbiAgfSBlbHNlIHtcbiAgICB0aWxlID0gdGhpcy50aWxlQ2FjaGUuZ2V0KHRpbGVDb29yZEtleSk7XG4gICAgaWYgKHRpbGUua2V5ICE9IGtleSkge1xuICAgICAgLy8gVGhlIHNvdXJjZSdzIHBhcmFtcyBjaGFuZ2VkLiBJZiB0aGUgdGlsZSBoYXMgYW4gaW50ZXJpbSB0aWxlIGFuZCBpZiB3ZVxuICAgICAgLy8gY2FuIHVzZSBpdCB0aGVuIHdlIHVzZSBpdC4gT3RoZXJ3aXNlIHdlIGNyZWF0ZSBhIG5ldyB0aWxlLiAgSW4gYm90aFxuICAgICAgLy8gY2FzZXMgd2UgYXR0ZW1wdCB0byBhc3NpZ24gYW4gaW50ZXJpbSB0aWxlIHRvIHRoZSBuZXcgdGlsZS5cbiAgICAgIGNvbnN0IGludGVyaW1UaWxlID0gdGlsZTtcbiAgICAgIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGVfKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24sIGtleSk7XG5cbiAgICAgIC8vbWFrZSB0aGUgbmV3IHRpbGUgdGhlIGhlYWQgb2YgdGhlIGxpc3QsXG4gICAgICBpZiAoaW50ZXJpbVRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgICAvL3RoZSBvbGQgdGlsZSBoYXNuJ3QgYmVndW4gbG9hZGluZyB5ZXQsIGFuZCBpcyBub3cgb3V0ZGF0ZWQsIHNvIHdlIGNhbiBzaW1wbHkgZGlzY2FyZCBpdFxuICAgICAgICB0aWxlLmludGVyaW1UaWxlID0gaW50ZXJpbVRpbGUuaW50ZXJpbVRpbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlLmludGVyaW1UaWxlID0gaW50ZXJpbVRpbGU7XG4gICAgICB9XG4gICAgICB0aWxlLnJlZnJlc2hJbnRlcmltQ2hhaW4oKTtcbiAgICAgIHRoaXMudGlsZUNhY2hlLnJlcGxhY2UodGlsZUNvb3JkS2V5LCB0aWxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbGU7XG59O1xuXG5cbi8qKlxuICogU2V0cyB3aGV0aGVyIHRvIHJlbmRlciByZXByb2plY3Rpb24gZWRnZXMgb3Igbm90ICh1c3VhbGx5IGZvciBkZWJ1Z2dpbmcpLlxuICogQHBhcmFtIHtib29sZWFufSByZW5kZXIgUmVuZGVyIHRoZSBlZGdlcy5cbiAqIEBhcGlcbiAqL1xuVGlsZUltYWdlLnByb3RvdHlwZS5zZXRSZW5kZXJSZXByb2plY3Rpb25FZGdlcyA9IGZ1bmN0aW9uKHJlbmRlcikge1xuICBpZiAoIUVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OIHx8XG4gICAgICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9PSByZW5kZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18gPSByZW5kZXI7XG4gIGZvciAoY29uc3QgaWQgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSB7XG4gICAgdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW2lkXS5jbGVhcigpO1xuICB9XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIHRpbGUgZ3JpZCB0byB1c2Ugd2hlbiByZXByb2plY3RpbmcgdGhlIHRpbGVzIHRvIHRoZSBnaXZlblxuICogcHJvamVjdGlvbiBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IHRpbGUgZ3JpZCBmb3IgdGhlIHByb2plY3Rpb24uXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlIGRlZmF1bHQgdGlsZSBncmlkIGNhbm5vdCBiZSBjcmVhdGVkXG4gKiAoZS5nLiBwcm9qZWN0aW9uIGhhcyBubyBleHRlbnQgZGVmaW5lZCkgb3JcbiAqIGZvciBvcHRpbWl6YXRpb24gcmVhc29ucyAoY3VzdG9tIHRpbGUgc2l6ZSwgcmVzb2x1dGlvbnMsIC4uLikuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IHRpbGVncmlkIFRpbGUgZ3JpZCB0byB1c2UgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICogQGFwaVxuICovXG5UaWxlSW1hZ2UucHJvdG90eXBlLnNldFRpbGVHcmlkRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uKHByb2plY3Rpb24sIHRpbGVncmlkKSB7XG4gIGlmIChFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgIGNvbnN0IHByb2ogPSBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGlmIChwcm9qKSB7XG4gICAgICBjb25zdCBwcm9qS2V5ID0gZ2V0VWlkKHByb2opLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoIShwcm9qS2V5IGluIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uKSkge1xuICAgICAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9IHRpbGVncmlkO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL0ltYWdlVGlsZX0gaW1hZ2VUaWxlIEltYWdlIHRpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUaWxlSW1hZ2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1VybFRpbGVcbiAqL1xuaW1wb3J0IHtnZXRVaWQsIGluaGVyaXRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2V4cGFuZFVybCwgY3JlYXRlRnJvbVRlbXBsYXRlcywgbnVsbFRpbGVVcmxGdW5jdGlvbn0gZnJvbSAnLi4vdGlsZXVybGZ1bmN0aW9uLmpzJztcbmltcG9ydCBUaWxlU291cmNlLCB7VGlsZVNvdXJjZUV2ZW50fSBmcm9tICcuLi9zb3VyY2UvVGlsZS5qcyc7XG5pbXBvcnQgVGlsZUV2ZW50VHlwZSBmcm9tICcuLi9zb3VyY2UvVGlsZUV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2dldEtleVpYWX0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZV1cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1N0YXRlfSBbc3RhdGVdXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gW3RpbGVHcmlkXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvVGlsZX5Mb2FkRnVuY3Rpb259IHRpbGVMb2FkRnVuY3Rpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGlsZVBpeGVsUmF0aW9dXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9ufSBbdGlsZVVybEZ1bmN0aW9uXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBbdXJsc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb25dXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMgcHJvdmlkaW5nIHRpbGVzIGRpdmlkZWQgaW50byBhIHRpbGUgZ3JpZCBvdmVyIGh0dHAuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWJzdHJhY3RcbiAqIEBmaXJlcyBtb2R1bGU6b2wvc291cmNlL1RpbGVFdmVudFxuICogQGV4dGVuZHMge21vZHVsZTpvbC9zb3VyY2UvVGlsZX1cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NvdXJjZS9VcmxUaWxlfk9wdGlvbnM9fSBvcHRpb25zIEltYWdlIHRpbGUgb3B0aW9ucy5cbiAqL1xuY29uc3QgVXJsVGlsZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICBUaWxlU291cmNlLmNhbGwodGhpcywge1xuICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICBleHRlbnQ6IG9wdGlvbnMuZXh0ZW50LFxuICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgIHRpbGVHcmlkOiBvcHRpb25zLnRpbGVHcmlkLFxuICAgIHRpbGVQaXhlbFJhdGlvOiBvcHRpb25zLnRpbGVQaXhlbFJhdGlvLFxuICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvblxuICB9KTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9ufVxuICAgKi9cbiAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uID0gb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn1cbiAgICovXG4gIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gdGhpcy5maXhlZFRpbGVVcmxGdW5jdGlvbiA/XG4gICAgdGhpcy5maXhlZFRpbGVVcmxGdW5jdGlvbi5iaW5kKHRoaXMpIDogbnVsbFRpbGVVcmxGdW5jdGlvbjtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdHlwZSB7IUFycmF5LjxzdHJpbmc+fG51bGx9XG4gICAqL1xuICB0aGlzLnVybHMgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLnVybHMpIHtcbiAgICB0aGlzLnNldFVybHMob3B0aW9ucy51cmxzKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnVybCkge1xuICAgIHRoaXMuc2V0VXJsKG9wdGlvbnMudXJsKTtcbiAgfVxuICBpZiAob3B0aW9ucy50aWxlVXJsRnVuY3Rpb24pIHtcbiAgICB0aGlzLnNldFRpbGVVcmxGdW5jdGlvbihvcHRpb25zLnRpbGVVcmxGdW5jdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgeyFPYmplY3QuPG51bWJlciwgYm9vbGVhbj59XG4gICAqL1xuICB0aGlzLnRpbGVMb2FkaW5nS2V5c18gPSB7fTtcblxufTtcblxuaW5oZXJpdHMoVXJsVGlsZSwgVGlsZVNvdXJjZSk7XG5cblxuLyoqXG4gKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGV+VXJsRnVuY3Rpb258dW5kZWZpbmVkfVxuICogQHByb3RlY3RlZFxuICovXG5VcmxUaWxlLnByb3RvdHlwZS5maXhlZFRpbGVVcmxGdW5jdGlvbjtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHRpbGUgbG9hZCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9ufSBUaWxlTG9hZEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblVybFRpbGUucHJvdG90eXBlLmdldFRpbGVMb2FkRnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudGlsZUxvYWRGdW5jdGlvbjtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHRpbGUgVVJMIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn0gVGlsZVVybEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblVybFRpbGUucHJvdG90eXBlLmdldFRpbGVVcmxGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50aWxlVXJsRnVuY3Rpb247XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBVUkxzIHVzZWQgZm9yIHRoaXMgc291cmNlLlxuICogV2hlbiBhIHRpbGVVcmxGdW5jdGlvbiBpcyB1c2VkIGluc3RlYWQgb2YgdXJsIG9yIHVybHMsXG4gKiBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHshQXJyYXkuPHN0cmluZz58bnVsbH0gVVJMcy5cbiAqIEBhcGlcbiAqL1xuVXJsVGlsZS5wcm90b3R5cGUuZ2V0VXJscyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy51cmxzO1xufTtcblxuXG4vKipcbiAqIEhhbmRsZSB0aWxlIGNoYW5nZSBldmVudHMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnR9IGV2ZW50IEV2ZW50LlxuICogQHByb3RlY3RlZFxuICovXG5VcmxUaWxlLnByb3RvdHlwZS5oYW5kbGVUaWxlQ2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgY29uc3QgdGlsZSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGV9ICovIChldmVudC50YXJnZXQpO1xuICBjb25zdCB1aWQgPSBnZXRVaWQodGlsZSk7XG4gIGNvbnN0IHRpbGVTdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgbGV0IHR5cGU7XG4gIGlmICh0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICB0aGlzLnRpbGVMb2FkaW5nS2V5c19bdWlkXSA9IHRydWU7XG4gICAgdHlwZSA9IFRpbGVFdmVudFR5cGUuVElMRUxPQURTVEFSVDtcbiAgfSBlbHNlIGlmICh1aWQgaW4gdGhpcy50aWxlTG9hZGluZ0tleXNfKSB7XG4gICAgZGVsZXRlIHRoaXMudGlsZUxvYWRpbmdLZXlzX1t1aWRdO1xuICAgIHR5cGUgPSB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SID8gVGlsZUV2ZW50VHlwZS5USUxFTE9BREVSUk9SIDpcbiAgICAgICh0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkxPQURFRCB8fCB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkFCT1JUKSA/XG4gICAgICAgIFRpbGVFdmVudFR5cGUuVElMRUxPQURFTkQgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGUgIT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUaWxlU291cmNlRXZlbnQodHlwZSwgdGlsZSkpO1xuICB9XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB0aWxlIGxvYWQgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uIFRpbGUgbG9hZCBmdW5jdGlvbi5cbiAqIEBhcGlcbiAqL1xuVXJsVGlsZS5wcm90b3R5cGUuc2V0VGlsZUxvYWRGdW5jdGlvbiA9IGZ1bmN0aW9uKHRpbGVMb2FkRnVuY3Rpb24pIHtcbiAgdGhpcy50aWxlQ2FjaGUuY2xlYXIoKTtcbiAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uID0gdGlsZUxvYWRGdW5jdGlvbjtcbiAgdGhpcy5jaGFuZ2VkKCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB0aWxlIFVSTCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn0gdGlsZVVybEZ1bmN0aW9uIFRpbGUgVVJMIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfa2V5IE9wdGlvbmFsIG5ldyB0aWxlIGtleSBmb3IgdGhlIHNvdXJjZS5cbiAqIEBhcGlcbiAqL1xuVXJsVGlsZS5wcm90b3R5cGUuc2V0VGlsZVVybEZ1bmN0aW9uID0gZnVuY3Rpb24odGlsZVVybEZ1bmN0aW9uLCBvcHRfa2V5KSB7XG4gIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gdGlsZVVybEZ1bmN0aW9uO1xuICB0aGlzLnRpbGVDYWNoZS5wcnVuZUV4Y2VwdE5ld2VzdFooKTtcbiAgaWYgKHR5cGVvZiBvcHRfa2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2V0S2V5KG9wdF9rZXkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBVUkwgdG8gdXNlIGZvciByZXF1ZXN0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMLlxuICogQGFwaVxuICovXG5VcmxUaWxlLnByb3RvdHlwZS5zZXRVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgY29uc3QgdXJscyA9IHRoaXMudXJscyA9IGV4cGFuZFVybCh1cmwpO1xuICB0aGlzLnNldFRpbGVVcmxGdW5jdGlvbih0aGlzLmZpeGVkVGlsZVVybEZ1bmN0aW9uID9cbiAgICB0aGlzLmZpeGVkVGlsZVVybEZ1bmN0aW9uLmJpbmQodGhpcykgOlxuICAgIGNyZWF0ZUZyb21UZW1wbGF0ZXModXJscywgdGhpcy50aWxlR3JpZCksIHVybCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBVUkxzIHRvIHVzZSBmb3IgcmVxdWVzdHMuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB1cmxzIFVSTHMuXG4gKiBAYXBpXG4gKi9cblVybFRpbGUucHJvdG90eXBlLnNldFVybHMgPSBmdW5jdGlvbih1cmxzKSB7XG4gIHRoaXMudXJscyA9IHVybHM7XG4gIGNvbnN0IGtleSA9IHVybHMuam9pbignXFxuJyk7XG4gIHRoaXMuc2V0VGlsZVVybEZ1bmN0aW9uKHRoaXMuZml4ZWRUaWxlVXJsRnVuY3Rpb24gP1xuICAgIHRoaXMuZml4ZWRUaWxlVXJsRnVuY3Rpb24uYmluZCh0aGlzKSA6XG4gICAgY3JlYXRlRnJvbVRlbXBsYXRlcyh1cmxzLCB0aGlzLnRpbGVHcmlkKSwga2V5KTtcbn07XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5VcmxUaWxlLnByb3RvdHlwZS51c2VUaWxlID0gZnVuY3Rpb24oeiwgeCwgeSkge1xuICBjb25zdCB0aWxlQ29vcmRLZXkgPSBnZXRLZXlaWFkoeiwgeCwgeSk7XG4gIGlmICh0aGlzLnRpbGVDYWNoZS5jb250YWluc0tleSh0aWxlQ29vcmRLZXkpKSB7XG4gICAgdGhpcy50aWxlQ2FjaGUuZ2V0KHRpbGVDb29yZEtleSk7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBVcmxUaWxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9YWVpcbiAqL1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IFRpbGVJbWFnZSBmcm9tICcuLi9zb3VyY2UvVGlsZUltYWdlLmpzJztcbmltcG9ydCB7Y3JlYXRlWFlaLCBleHRlbnRGcm9tUHJvamVjdGlvbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZT0yMDQ4XSBDYWNoZSBzaXplLlxuICogQHByb3BlcnR5IHtudWxsfHN0cmluZ30gW2Nyb3NzT3JpZ2luXSBUaGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgZm9yIGxvYWRlZCBpbWFnZXMuICBOb3RlIHRoYXRcbiAqIHlvdSBtdXN0IHByb3ZpZGUgYSBgY3Jvc3NPcmlnaW5gIHZhbHVlIGlmIHlvdSBhcmUgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyIG9yIGlmIHlvdSB3YW50IHRvXG4gKiBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuICBTZWVcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZX0gZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlPXRydWVdIFdoZXRoZXIgdGhlIGxheWVyIGlzIG9wYXF1ZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uPSdFUFNHOjM4NTcnXSBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MC41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tPTE4XSBPcHRpb25hbCBtYXggem9vbSBsZXZlbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBPcHRpb25hbCBtaW4gem9vbSBsZXZlbC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBbdGlsZUdyaWRdIFRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpbz0xXSBUaGUgcGl4ZWwgcmF0aW8gdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSB0aWxlIHNlcnZpY2UgYWR2ZXJ0aXplcyAyNTZweCBieSAyNTZweCB0aWxlcyBidXQgYWN0dWFsbHkgc2VuZHMgNTEycHhcbiAqIGJ5IDUxMnB4IGltYWdlcyAoZm9yIHJldGluYS9oaWRwaSBkZXZpY2VzKSB0aGVuIGB0aWxlUGl4ZWxSYXRpb2BcbiAqIHNob3VsZCBiZSBzZXQgdG8gYDJgLlxuICogQHByb3BlcnR5IHtudW1iZXJ8bW9kdWxlOm9sL3NpemV+U2l6ZX0gW3RpbGVTaXplPVsyNTYsIDI1Nl1dIFRoZSB0aWxlIHNpemUgdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZ2V0XG4gKiB0aWxlIFVSTCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSBhbmQgdGhlIHByb2plY3Rpb24uXG4gKiBSZXF1aXJlZCBpZiB1cmwgb3IgdXJscyBhcmUgbm90IHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVSTCB0ZW1wbGF0ZS4gTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsXG4gKiBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLiBBIGB7Py0/fWAgdGVtcGxhdGUgcGF0dGVybiwgZm9yIGV4YW1wbGUgYHN1YmRvbWFpbnthLWZ9LmRvbWFpbi5jb21gLFxuICogbWF5IGJlIHVzZWQgaW5zdGVhZCBvZiBkZWZpbmluZyBlYWNoIG9uZSBzZXBhcmF0ZWx5IGluIHRoZSBgdXJsc2Agb3B0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gW3VybHNdIEFuIGFycmF5IG9mIFVSTCB0ZW1wbGF0ZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl0gRHVyYXRpb24gb2YgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiBmb3IgcmVuZGVyaW5nLlxuICogVG8gZGlzYWJsZSB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLCBwYXNzIGB0cmFuc2l0aW9uOiAwYC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGF5ZXIgc291cmNlIGZvciB0aWxlIGRhdGEgd2l0aCBVUkxzIGluIGEgc2V0IFhZWiBmb3JtYXQgdGhhdCBhcmVcbiAqIGRlZmluZWQgaW4gYSBVUkwgdGVtcGxhdGUuIEJ5IGRlZmF1bHQsIHRoaXMgZm9sbG93cyB0aGUgd2lkZWx5LXVzZWRcbiAqIEdvb2dsZSBncmlkIHdoZXJlIGB4YCAwIGFuZCBgeWAgMCBhcmUgaW4gdGhlIHRvcCBsZWZ0LiBHcmlkcyBsaWtlXG4gKiBUTVMgd2hlcmUgYHhgIDAgYW5kIGB5YCAwIGFyZSBpbiB0aGUgYm90dG9tIGxlZnQgY2FuIGJlIHVzZWQgYnlcbiAqIHVzaW5nIHRoZSBgey15fWAgcGxhY2Vob2xkZXIgaW4gdGhlIFVSTCB0ZW1wbGF0ZSwgc28gbG9uZyBhcyB0aGVcbiAqIHNvdXJjZSBkb2VzIG5vdCBoYXZlIGEgY3VzdG9tIHRpbGUgZ3JpZC4gSW4gdGhpcyBjYXNlLFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZUltYWdlfSBjYW4gYmUgdXNlZCB3aXRoIGEgYHRpbGVVcmxGdW5jdGlvbmBcbiAqIHN1Y2ggYXM6XG4gKlxuICogIHRpbGVVcmxGdW5jdGlvbjogZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xuICogICAgcmV0dXJuICdodHRwOi8vbWFwc2VydmVyLmNvbS8nICsgY29vcmRpbmF0ZVswXSArICcvJyArXG4gKiAgICAgICAgY29vcmRpbmF0ZVsxXSArICcvJyArIGNvb3JkaW5hdGVbMl0gKyAnLnBuZyc7XG4gKiAgICB9XG4gKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTpvbC9zb3VyY2UvVGlsZUltYWdlfVxuICogQHBhcmFtIHttb2R1bGU6b2wvc291cmNlL1hZWn5PcHRpb25zPX0gb3B0X29wdGlvbnMgWFlaIG9wdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmNvbnN0IFhZWiA9IGZ1bmN0aW9uKG9wdF9vcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcHJvamVjdGlvbiA9IG9wdGlvbnMucHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLnByb2plY3Rpb24gOiAnRVBTRzozODU3JztcblxuICBjb25zdCB0aWxlR3JpZCA9IG9wdGlvbnMudGlsZUdyaWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGlsZUdyaWQgOlxuICAgIGNyZWF0ZVhZWih7XG4gICAgICBleHRlbnQ6IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pLFxuICAgICAgbWF4Wm9vbTogb3B0aW9ucy5tYXhab29tLFxuICAgICAgbWluWm9vbTogb3B0aW9ucy5taW5ab29tLFxuICAgICAgdGlsZVNpemU6IG9wdGlvbnMudGlsZVNpemVcbiAgICB9KTtcblxuICBUaWxlSW1hZ2UuY2FsbCh0aGlzLCB7XG4gICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgIGNyb3NzT3JpZ2luOiBvcHRpb25zLmNyb3NzT3JpZ2luLFxuICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgcHJvamVjdGlvbjogcHJvamVjdGlvbixcbiAgICByZXByb2plY3Rpb25FcnJvclRocmVzaG9sZDogb3B0aW9ucy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZCxcbiAgICB0aWxlR3JpZDogdGlsZUdyaWQsXG4gICAgdGlsZUxvYWRGdW5jdGlvbjogb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uLFxuICAgIHRpbGVQaXhlbFJhdGlvOiBvcHRpb25zLnRpbGVQaXhlbFJhdGlvLFxuICAgIHRpbGVVcmxGdW5jdGlvbjogb3B0aW9ucy50aWxlVXJsRnVuY3Rpb24sXG4gICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICB1cmxzOiBvcHRpb25zLnVybHMsXG4gICAgd3JhcFg6IG9wdGlvbnMud3JhcFggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFggOiB0cnVlLFxuICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvblxuICB9KTtcblxufTtcblxuaW5oZXJpdHMoWFlaLCBUaWxlSW1hZ2UpO1xuZXhwb3J0IGRlZmF1bHQgWFlaO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTGF0aXR1ZGUvbG9uZ2l0dWRlIHNwaGVyaWNhbCBnZW9kZXN5IGZvcm11bGFlIHRha2VuIGZyb21cbiAqIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXG4gKiBMaWNlbnNlZCB1bmRlciBDQy1CWS0zLjAuXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIG9sL3NwaGVyZVxuICovXG5pbXBvcnQge3RvUmFkaWFucywgdG9EZWdyZWVzfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcblxuXG4vKipcbiAqIE9iamVjdCBsaXRlcmFsIHdpdGggb3B0aW9ucyBmb3IgdGhlIHtAbGluayBnZXRMZW5ndGh9IG9yIHtAbGluayBnZXRBcmVhfVxuICogZnVuY3Rpb25zLlxuICogQHR5cGVkZWYge09iamVjdH0gU3BoZXJlTWV0cmljT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb249J0VQU0c6Mzg1NyddXG4gKiBQcm9qZWN0aW9uIG9mIHRoZSAgZ2VvbWV0cnkuICBCeSBkZWZhdWx0LCB0aGUgZ2VvbWV0cnkgaXMgYXNzdW1lZCB0byBiZSBpblxuICogV2ViIE1lcmNhdG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXM9NjM3MTAwOC44XSBTcGhlcmUgcmFkaXVzLiAgQnkgZGVmYXVsdCwgdGhlIHJhZGl1cyBvZiB0aGVcbiAqIGVhcnRoIGlzIHVzZWQgKENsYXJrZSAxODY2IEF1dGhhbGljIFNwaGVyZSkuXG4gKi9cblxuXG4vKipcbiAqIFRoZSBtZWFuIEVhcnRoIHJhZGl1cyAoMS8zICogKDJhICsgYikpIGZvciB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRWFydGhfcmFkaXVzI01lYW5fcmFkaXVzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9SQURJVVMgPSA2MzcxMDA4Ljg7XG5cblxuLyoqXG4gKiBHZXQgdGhlIGdyZWF0IGNpcmNsZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheX0gYzEgU3RhcnRpbmcgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGMyIEVuZGluZyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzIHRvIHVzZS4gIERlZmF1bHRzIHRvIHRoZSBFYXJ0aCdzXG4gKiAgICAgbWVhbiByYWRpdXMgdXNpbmcgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGdyZWF0IGNpcmNsZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMgKGluIG1ldGVycykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZShjMSwgYzIsIG9wdF9yYWRpdXMpIHtcbiAgY29uc3QgcmFkaXVzID0gb3B0X3JhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgbGF0MSA9IHRvUmFkaWFucyhjMVsxXSk7XG4gIGNvbnN0IGxhdDIgPSB0b1JhZGlhbnMoYzJbMV0pO1xuICBjb25zdCBkZWx0YUxhdEJ5MiA9IChsYXQyIC0gbGF0MSkgLyAyO1xuICBjb25zdCBkZWx0YUxvbkJ5MiA9IHRvUmFkaWFucyhjMlswXSAtIGMxWzBdKSAvIDI7XG4gIGNvbnN0IGEgPSBNYXRoLnNpbihkZWx0YUxhdEJ5MikgKiBNYXRoLnNpbihkZWx0YUxhdEJ5MikgK1xuICAgICAgTWF0aC5zaW4oZGVsdGFMb25CeTIpICogTWF0aC5zaW4oZGVsdGFMb25CeTIpICpcbiAgICAgIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0Mik7XG4gIHJldHVybiAyICogcmFkaXVzICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjdW11bGF0aXZlIGdyZWF0IGNpcmNsZSBsZW5ndGggb2YgbGluZXN0cmluZyBjb29yZGluYXRlcyAoZ2VvZ3JhcGhpYykuXG4gKiBAcGFyYW0ge0FycmF5fSBjb29yZGluYXRlcyBMaW5lc3RyaW5nIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggKGluIG1ldGVycykuXG4gKi9cbmZ1bmN0aW9uIGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpIHtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpIC0gMTsgKytpKSB7XG4gICAgbGVuZ3RoICs9IGdldERpc3RhbmNlKGNvb3JkaW5hdGVzW2ldLCBjb29yZGluYXRlc1tpICsgMV0sIHJhZGl1cyk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgc3BoZXJpY2FsIGxlbmd0aCBvZiBhIGdlb21ldHJ5LiAgVGhpcyBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGVcbiAqIGdyZWF0IGNpcmNsZSBkaXN0YW5jZXMgYmV0d2VlbiBjb29yZGluYXRlcy4gIEZvciBwb2x5Z29ucywgdGhlIGxlbmd0aCBpc1xuICogdGhlIHN1bSBvZiBhbGwgcmluZ3MuICBGb3IgcG9pbnRzLCB0aGUgbGVuZ3RoIGlzIHplcm8uICBGb3IgbXVsdGktcGFydFxuICogZ2VvbWV0cmllcywgdGhlIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBsZW5ndGggb2YgZWFjaCBwYXJ0LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeX0gZ2VvbWV0cnkgQSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NwaGVyZX5TcGhlcmVNZXRyaWNPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9ucyBmb3IgdGhlXG4gKiBsZW5ndGggY2FsY3VsYXRpb24uICBCeSBkZWZhdWx0LCBnZW9tZXRyaWVzIGFyZSBhc3N1bWVkIHRvIGJlIGluICdFUFNHOjM4NTcnLlxuICogWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBwcm92aWRpbmcgYSBgcHJvamVjdGlvbmAgb3B0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3BoZXJpY2FsIGxlbmd0aCAoaW4gbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExlbmd0aChnZW9tZXRyeSwgb3B0X29wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgcHJvamVjdGlvbiA9IG9wdGlvbnMucHJvamVjdGlvbiB8fCAnRVBTRzozODU3JztcbiAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgaWYgKHR5cGUgIT09IEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpLnRyYW5zZm9ybShwcm9qZWN0aW9uLCAnRVBTRzo0MzI2Jyk7XG4gIH1cbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGxldCBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORUFSX1JJTkc6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX0gKi8gKGdlb21ldHJ5KS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgbGVuZ3RoID0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1NpbXBsZUdlb21ldHJ5fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzW2ldLCByYWRpdXMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX0gKi8gKGdlb21ldHJ5KS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aEludGVybmFsKGNvb3Jkc1tqXSwgcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT046IHtcbiAgICAgIGNvbnN0IGdlb21ldHJpZXMgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbn0gKi8gKGdlb21ldHJ5KS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBsZW5ndGggKz0gZ2V0TGVuZ3RoKGdlb21ldHJpZXNbaV0sIG9wdF9vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNwaGVyaWNhbCBhcmVhIGZvciBhIGxpc3Qgb2YgY29vcmRpbmF0ZXMuXG4gKlxuICogW1JlZmVyZW5jZV0oaHR0cHM6Ly90cnMtbmV3LmpwbC5uYXNhLmdvdi9oYW5kbGUvMjAxNC80MDQwOSlcbiAqIFJvYmVydC4gRy4gQ2hhbWJlcmxhaW4gYW5kIFdpbGxpYW0gSC4gRHVxdWV0dGUsIFwiU29tZSBBbGdvcml0aG1zIGZvclxuICogUG9seWdvbnMgb24gYSBTcGhlcmVcIiwgSlBMIFB1YmxpY2F0aW9uIDA3LTAzLCBKZXQgUHJvcHVsc2lvblxuICogTGFib3JhdG9yeSwgUGFzYWRlbmEsIENBLCBKdW5lIDIwMDdcbiAqXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgTGlzdCBvZiBjb29yZGluYXRlcyBvZiBhIGxpbmVhclxuICogcmluZy4gSWYgdGhlIHJpbmcgaXMgb3JpZW50ZWQgY2xvY2t3aXNlLCB0aGUgYXJlYSB3aWxsIGJlIHBvc2l0aXZlLFxuICogb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChpbiBzcXVhcmUgbWV0ZXJzKS5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpIHtcbiAgbGV0IGFyZWEgPSAwO1xuICBjb25zdCBsZW4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIGxldCB4MSA9IGNvb3JkaW5hdGVzW2xlbiAtIDFdWzBdO1xuICBsZXQgeTEgPSBjb29yZGluYXRlc1tsZW4gLSAxXVsxXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHgyID0gY29vcmRpbmF0ZXNbaV1bMF07XG4gICAgY29uc3QgeTIgPSBjb29yZGluYXRlc1tpXVsxXTtcbiAgICBhcmVhICs9IHRvUmFkaWFucyh4MiAtIHgxKSAqXG4gICAgICAgICgyICsgTWF0aC5zaW4odG9SYWRpYW5zKHkxKSkgK1xuICAgICAgICBNYXRoLnNpbih0b1JhZGlhbnMoeTIpKSk7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBhcmVhICogcmFkaXVzICogcmFkaXVzIC8gMi4wO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzcGhlcmljYWwgYXJlYSBvZiBhIGdlb21ldHJ5LiAgVGhpcyBpcyB0aGUgYXJlYSAoaW4gbWV0ZXJzKSBhc3N1bWluZ1xuICogdGhhdCBwb2x5Z29uIGVkZ2VzIGFyZSBzZWdtZW50cyBvZiBncmVhdCBjaXJjbGVzIG9uIGEgc3BoZXJlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeX0gZ2VvbWV0cnkgQSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NwaGVyZX5TcGhlcmVNZXRyaWNPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIGFyZWFcbiAqICAgICBjYWxjdWxhdGlvbi4gIEJ5IGRlZmF1bHQsIGdlb21ldHJpZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gJ0VQU0c6Mzg1NycuXG4gKiAgICAgWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBwcm92aWRpbmcgYSBgcHJvamVjdGlvbmAgb3B0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3BoZXJpY2FsIGFyZWEgKGluIHNxdWFyZSBtZXRlcnMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJlYShnZW9tZXRyeSwgb3B0X29wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgcHJvamVjdGlvbiA9IG9wdGlvbnMucHJvamVjdGlvbiB8fCAnRVBTRzozODU3JztcbiAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgaWYgKHR5cGUgIT09IEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpLnRyYW5zZm9ybShwcm9qZWN0aW9uLCAnRVBTRzo0MzI2Jyk7XG4gIH1cbiAgbGV0IGFyZWEgPSAwO1xuICBsZXQgY29vcmRpbmF0ZXMsIGNvb3JkcywgaSwgaWksIGosIGpqO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0lOVDpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVDpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORzpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FQVJfUklORzoge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPTFlHT046IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9Qb2x5Z29ufSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBhcmVhID0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzWzBdLCByYWRpdXMpKTtcbiAgICAgIGZvciAoaSA9IDEsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBhcmVhIC09IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlc1tpXSwgcmFkaXVzKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1NpbXBsZUdlb21ldHJ5fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGFyZWEgKz0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3Jkc1swXSwgcmFkaXVzKSk7XG4gICAgICAgIGZvciAoaiA9IDEsIGpqID0gY29vcmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBhcmVhIC09IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZHNbal0sIHJhZGl1cykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTjoge1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9ufSAqLyAoZ2VvbWV0cnkpLmdldEdlb21ldHJpZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGFyZWEgKz0gZ2V0QXJlYShnZW9tZXRyaWVzW2ldLCBvcHRfb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBhdCB0aGUgZ2l2ZW4gZGlzdGFuY2UgYW5kIGJlYXJpbmcgZnJvbSBgYzFgLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYzEgVGhlIG9yaWdpbiBwb2ludCAoYFtsb24sIGxhdF1gIGluIGRlZ3JlZXMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIFRoZSBncmVhdC1jaXJjbGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgb3JpZ2luXG4gKiAgICAgcG9pbnQgYW5kIHRoZSB0YXJnZXQgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gYmVhcmluZyBUaGUgYmVhcmluZyAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9yYWRpdXMgVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLiAgRGVmYXVsdHMgdG8gdGhlIEVhcnRoJ3NcbiAqICAgICBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gVGhlIHRhcmdldCBwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mZnNldChjMSwgZGlzdGFuY2UsIGJlYXJpbmcsIG9wdF9yYWRpdXMpIHtcbiAgY29uc3QgcmFkaXVzID0gb3B0X3JhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgbGF0MSA9IHRvUmFkaWFucyhjMVsxXSk7XG4gIGNvbnN0IGxvbjEgPSB0b1JhZGlhbnMoYzFbMF0pO1xuICBjb25zdCBkQnlSID0gZGlzdGFuY2UgLyByYWRpdXM7XG4gIGNvbnN0IGxhdCA9IE1hdGguYXNpbihcbiAgICBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGRCeVIpICtcbiAgICAgIE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4oZEJ5UikgKiBNYXRoLmNvcyhiZWFyaW5nKSk7XG4gIGNvbnN0IGxvbiA9IGxvbjEgKyBNYXRoLmF0YW4yKFxuICAgIE1hdGguc2luKGJlYXJpbmcpICogTWF0aC5zaW4oZEJ5UikgKiBNYXRoLmNvcyhsYXQxKSxcbiAgICBNYXRoLmNvcyhkQnlSKSAtIE1hdGguc2luKGxhdDEpICogTWF0aC5zaW4obGF0KSk7XG4gIHJldHVybiBbdG9EZWdyZWVzKGxvbiksIHRvRGVncmVlcyhsYXQpXTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHJ1Y3RzL0xSVUNhY2hlXG4gKi9cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJy4uL2luZGV4LmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi9ldmVudHMvRXZlbnRUYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVudHJ5XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5X1xuICogQHByb3BlcnR5IHtPYmplY3R9IG5ld2VyXG4gKiBAcHJvcGVydHkge09iamVjdH0gb2xkZXJcbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWVfXG4gKi9cblxuXG4vKipcbiAqIEltcGxlbWVudHMgYSBMZWFzdC1SZWNlbnRseS1Vc2VkIGNhY2hlIHdoZXJlIHRoZSBrZXlzIGRvIG5vdCBjb25mbGljdCB3aXRoXG4gKiBPYmplY3QncyBwcm9wZXJ0aWVzIChlLmcuICdoYXNPd25Qcm9wZXJ0eScgaXMgbm90IGFsbG93ZWQgYXMgYSBrZXkpLiBFeHBpcmluZ1xuICogaXRlbXMgZnJvbSB0aGUgY2FjaGUgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSB1c2VyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH1cbiAqIEBmaXJlcyBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkV2ZW50XG4gKiBAc3RydWN0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaGlnaFdhdGVyTWFyayBIaWdoIHdhdGVyIG1hcmsuXG4gKi9cbmNvbnN0IExSVUNhY2hlID0gZnVuY3Rpb24ob3B0X2hpZ2hXYXRlck1hcmspIHtcblxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gb3B0X2hpZ2hXYXRlck1hcmsgIT09IHVuZGVmaW5lZCA/IG9wdF9oaWdoV2F0ZXJNYXJrIDogMjA0ODtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuY291bnRfID0gMDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL3N0cnVjdHMvTFJVQ2FjaGV+RW50cnk+fVxuICAgKi9cbiAgdGhpcy5lbnRyaWVzXyA9IHt9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7P21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlfkVudHJ5fVxuICAgKi9cbiAgdGhpcy5vbGRlc3RfID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgez9tb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZX5FbnRyeX1cbiAgICovXG4gIHRoaXMubmV3ZXN0XyA9IG51bGw7XG5cbn07XG5cbmluaGVyaXRzKExSVUNhY2hlLCBFdmVudFRhcmdldCk7XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBDYW4gZXhwaXJlIGNhY2hlLlxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUuY2FuRXhwaXJlQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0Q291bnQoKSA+IHRoaXMuaGlnaFdhdGVyTWFyaztcbn07XG5cblxuLyoqXG4gKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY291bnRfID0gMDtcbiAgdGhpcy5lbnRyaWVzXyA9IHt9O1xuICB0aGlzLm9sZGVzdF8gPSBudWxsO1xuICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNMRUFSKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIGtleS5cbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmNvbnRhaW5zS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHJldHVybiB0aGlzLmVudHJpZXNfLmhhc093blByb3BlcnR5KGtleSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBULCBzdHJpbmcsIG1vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlKTogP30gZiBUaGUgZnVuY3Rpb25cbiAqICAgICB0byBjYWxsIGZvciBldmVyeSBlbnRyeSBmcm9tIHRoZSBvbGRlc3QgdG8gdGhlIG5ld2VyLiBUaGlzIGZ1bmN0aW9uIHRha2VzXG4gKiAgICAgMyBhcmd1bWVudHMgKHRoZSBlbnRyeSB2YWx1ZSwgdGhlIGVudHJ5IGtleSBhbmQgdGhlIExSVUNhY2hlIG9iamVjdCkuXG4gKiAgICAgVGhlIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICogQHBhcmFtIHtTPX0gb3B0X3RoaXMgVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGBmYC5cbiAqIEB0ZW1wbGF0ZSBTXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZiwgb3B0X3RoaXMpIHtcbiAgbGV0IGVudHJ5ID0gdGhpcy5vbGRlc3RfO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICBmLmNhbGwob3B0X3RoaXMsIGVudHJ5LnZhbHVlXywgZW50cnkua2V5XywgdGhpcyk7XG4gICAgZW50cnkgPSBlbnRyeS5uZXdlcjtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICogQHJldHVybiB7VH0gVmFsdWUuXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgY29uc3QgZW50cnkgPSB0aGlzLmVudHJpZXNfW2tleV07XG4gIGFzc2VydChlbnRyeSAhPT0gdW5kZWZpbmVkLFxuICAgIDE1KTsgLy8gVHJpZWQgdG8gZ2V0IGEgdmFsdWUgZm9yIGEga2V5IHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlXG4gIGlmIChlbnRyeSA9PT0gdGhpcy5uZXdlc3RfKSB7XG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgfSBlbHNlIGlmIChlbnRyeSA9PT0gdGhpcy5vbGRlc3RfKSB7XG4gICAgdGhpcy5vbGRlc3RfID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZX5FbnRyeX0gKi8gKHRoaXMub2xkZXN0Xy5uZXdlcik7XG4gICAgdGhpcy5vbGRlc3RfLm9sZGVyID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyO1xuICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7XG4gIH1cbiAgZW50cnkubmV3ZXIgPSBudWxsO1xuICBlbnRyeS5vbGRlciA9IHRoaXMubmV3ZXN0XztcbiAgdGhpcy5uZXdlc3RfLm5ld2VyID0gZW50cnk7XG4gIHRoaXMubmV3ZXN0XyA9IGVudHJ5O1xuICByZXR1cm4gZW50cnkudmFsdWVfO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbiBlbnRyeSBmcm9tIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGVudHJ5IGtleS5cbiAqIEByZXR1cm4ge1R9IFRoZSByZW1vdmVkIGVudHJ5LlxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7XG4gIGNvbnN0IGVudHJ5ID0gdGhpcy5lbnRyaWVzX1trZXldO1xuICBhc3NlcnQoZW50cnkgIT09IHVuZGVmaW5lZCwgMTUpOyAvLyBUcmllZCB0byBnZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGVcbiAgaWYgKGVudHJ5ID09PSB0aGlzLm5ld2VzdF8pIHtcbiAgICB0aGlzLm5ld2VzdF8gPSAvKiogQHR5cGUge21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlfkVudHJ5fSAqLyAoZW50cnkub2xkZXIpO1xuICAgIGlmICh0aGlzLm5ld2VzdF8pIHtcbiAgICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IG51bGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVudHJ5ID09PSB0aGlzLm9sZGVzdF8pIHtcbiAgICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlfkVudHJ5fSAqLyAoZW50cnkubmV3ZXIpO1xuICAgIGlmICh0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMub2xkZXN0Xy5vbGRlciA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7XG4gICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjtcbiAgfVxuICBkZWxldGUgdGhpcy5lbnRyaWVzX1trZXldO1xuICAtLXRoaXMuY291bnRfO1xuICByZXR1cm4gZW50cnkudmFsdWVfO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gQ291bnQuXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb3VudF87XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEtleXMuXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5nZXRLZXlzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkodGhpcy5jb3VudF8pO1xuICBsZXQgaSA9IDA7XG4gIGxldCBlbnRyeTtcbiAgZm9yIChlbnRyeSA9IHRoaXMubmV3ZXN0XzsgZW50cnk7IGVudHJ5ID0gZW50cnkub2xkZXIpIHtcbiAgICBrZXlzW2krK10gPSBlbnRyeS5rZXlfO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0FycmF5LjxUPn0gVmFsdWVzLlxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLmNvdW50Xyk7XG4gIGxldCBpID0gMDtcbiAgbGV0IGVudHJ5O1xuICBmb3IgKGVudHJ5ID0gdGhpcy5uZXdlc3RfOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5vbGRlcikge1xuICAgIHZhbHVlc1tpKytdID0gZW50cnkudmFsdWVfO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7VH0gTGFzdCB2YWx1ZS5cbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLnBlZWtMYXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9sZGVzdF8udmFsdWVfO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gTGFzdCBrZXkuXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5wZWVrTGFzdEtleSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vbGRlc3RfLmtleV87XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBrZXkgb2YgdGhlIG5ld2VzdCBpdGVtIGluIHRoZSBjYWNoZS4gIFRocm93cyBpZiB0aGUgY2FjaGUgaXMgZW1wdHkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuZXdlc3Qga2V5LlxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUucGVla0ZpcnN0S2V5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm5ld2VzdF8ua2V5Xztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtUfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBlbnRyeSA9IHRoaXMub2xkZXN0XztcbiAgZGVsZXRlIHRoaXMuZW50cmllc19bZW50cnkua2V5X107XG4gIGlmIChlbnRyeS5uZXdlcikge1xuICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gbnVsbDtcbiAgfVxuICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlfkVudHJ5fSAqLyAoZW50cnkubmV3ZXIpO1xuICBpZiAoIXRoaXMub2xkZXN0Xykge1xuICAgIHRoaXMubmV3ZXN0XyA9IG51bGw7XG4gIH1cbiAgLS10aGlzLmNvdW50XztcbiAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICB0aGlzLmdldChrZXkpOyAgLy8gdXBkYXRlIGBuZXdlc3RfYFxuICB0aGlzLmVudHJpZXNfW2tleV0udmFsdWVfID0gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gKiBAcGFyYW0ge1R9IHZhbHVlIFZhbHVlLlxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICBhc3NlcnQoIShrZXkgaW4gdGhpcy5lbnRyaWVzXyksXG4gICAgMTYpOyAvLyBUcmllZCB0byBzZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBpcyB1c2VkIGFscmVhZHlcbiAgY29uc3QgZW50cnkgPSAvKiogQHR5cGUge21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlfkVudHJ5fSAqLyAoe1xuICAgIGtleV86IGtleSxcbiAgICBuZXdlcjogbnVsbCxcbiAgICBvbGRlcjogdGhpcy5uZXdlc3RfLFxuICAgIHZhbHVlXzogdmFsdWVcbiAgfSk7XG4gIGlmICghdGhpcy5uZXdlc3RfKSB7XG4gICAgdGhpcy5vbGRlc3RfID0gZW50cnk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5uZXdlc3RfLm5ld2VyID0gZW50cnk7XG4gIH1cbiAgdGhpcy5uZXdlc3RfID0gZW50cnk7XG4gIHRoaXMuZW50cmllc19ba2V5XSA9IGVudHJ5O1xuICArK3RoaXMuY291bnRfO1xufTtcblxuXG4vKipcbiAqIFNldCBhIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgZm9yIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIENhY2hlIHNpemUuXG4gKiBAYXBpXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBzaXplO1xufTtcblxuXG4vKipcbiAqIFBydW5lIHRoZSBjYWNoZS5cbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLnBydW5lID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICB0aGlzLnBvcCgpO1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgTFJVQ2FjaGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWNvb3JkXG4gKi9cblxuXG4vKipcbiAqIEFuIGFycmF5IG9mIHRocmVlIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBvZiBhIHRpbGUgaW4gYSB0aWxlXG4gKiBncmlkLiBUaGUgb3JkZXIgaXMgYHpgLCBgeGAsIGFuZCBgeWAuIGB6YCBpcyB0aGUgem9vbSBsZXZlbC5cbiAqIEB0eXBlZGVmIHtBcnJheS48bnVtYmVyPn0gVGlsZUNvb3JkXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQ9fSBvcHRfdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZSh6LCB4LCB5LCBvcHRfdGlsZUNvb3JkKSB7XG4gIGlmIChvcHRfdGlsZUNvb3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRfdGlsZUNvb3JkWzBdID0gejtcbiAgICBvcHRfdGlsZUNvb3JkWzFdID0geDtcbiAgICBvcHRfdGlsZUNvb3JkWzJdID0geTtcbiAgICByZXR1cm4gb3B0X3RpbGVDb29yZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3osIHgsIHldO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleVpYWSh6LCB4LCB5KSB7XG4gIHJldHVybiB6ICsgJy8nICsgeCArICcvJyArIHk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGtleSBmb3IgYSB0aWxlIGNvb3JkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRoZSB0aWxlIGNvb3JkLlxuICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkodGlsZUNvb3JkKSB7XG4gIHJldHVybiBnZXRLZXlaWFkodGlsZUNvb3JkWzBdLCB0aWxlQ29vcmRbMV0sIHRpbGVDb29yZFsyXSk7XG59XG5cblxuLyoqXG4gKiBHZXQgYSB0aWxlIGNvb3JkIGdpdmVuIGEga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgdGlsZSBjb29yZCBrZXkuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gVGhlIHRpbGUgY29vcmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tS2V5KGtleSkge1xuICByZXR1cm4ga2V5LnNwbGl0KCcvJykubWFwKE51bWJlcik7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZC5cbiAqIEByZXR1cm4ge251bWJlcn0gSGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2godGlsZUNvb3JkKSB7XG4gIHJldHVybiAodGlsZUNvb3JkWzFdIDw8IHRpbGVDb29yZFswXSkgKyB0aWxlQ29vcmRbMl07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gUXVhZCBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkS2V5KHRpbGVDb29yZCkge1xuICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICBjb25zdCBkaWdpdHMgPSBuZXcgQXJyYXkoeik7XG4gIGxldCBtYXNrID0gMSA8PCAoeiAtIDEpO1xuICBsZXQgaSwgY2hhckNvZGU7XG4gIGZvciAoaSA9IDA7IGkgPCB6OyArK2kpIHtcbiAgICAvLyA0OCBpcyBjaGFyQ29kZSBmb3IgMCAtICcwJy5jaGFyQ29kZUF0KDApXG4gICAgY2hhckNvZGUgPSA0ODtcbiAgICBpZiAodGlsZUNvb3JkWzFdICYgbWFzaykge1xuICAgICAgY2hhckNvZGUgKz0gMTtcbiAgICB9XG4gICAgaWYgKHRpbGVDb29yZFsyXSAmIG1hc2spIHtcbiAgICAgIGNoYXJDb2RlICs9IDI7XG4gICAgfVxuICAgIGRpZ2l0c1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIG1hc2sgPj49IDE7XG4gIH1cbiAgcmV0dXJuIGRpZ2l0cy5qb2luKCcnKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0geyFtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRpbGUgY29vcmRpbmF0ZSBpcyB3aXRoaW4gZXh0ZW50IGFuZCB6b29tIGxldmVsIHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aGluRXh0ZW50QW5kWih0aWxlQ29vcmQsIHRpbGVHcmlkKSB7XG4gIGNvbnN0IHogPSB0aWxlQ29vcmRbMF07XG4gIGNvbnN0IHggPSB0aWxlQ29vcmRbMV07XG4gIGNvbnN0IHkgPSB0aWxlQ29vcmRbMl07XG5cbiAgaWYgKHRpbGVHcmlkLmdldE1pblpvb20oKSA+IHogfHwgeiA+IHRpbGVHcmlkLmdldE1heFpvb20oKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBleHRlbnQgPSB0aWxlR3JpZC5nZXRFeHRlbnQoKTtcbiAgbGV0IHRpbGVSYW5nZTtcbiAgaWYgKCFleHRlbnQpIHtcbiAgICB0aWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRGdWxsVGlsZVJhbmdlKHopO1xuICB9IGVsc2Uge1xuICAgIHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6KTtcbiAgfVxuICBpZiAoIXRpbGVSYW5nZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aWxlUmFuZ2UuY29udGFpbnNYWSh4LCB5KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkXG4gKi9cbmltcG9ydCB7REVGQVVMVF9NQVhfWk9PTSwgREVGQVVMVF9USUxFX1NJWkV9IGZyb20gJy4vdGlsZWdyaWQvY29tbW9uLmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuL3NpemUuanMnO1xuaW1wb3J0IHtjb250YWluc0Nvb3JkaW5hdGUsIGNyZWF0ZU9yVXBkYXRlLCBnZXRDb3JuZXIsIGdldEhlaWdodCwgZ2V0V2lkdGh9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCBDb3JuZXIgZnJvbSAnLi9leHRlbnQvQ29ybmVyLmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuL29iai5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9uLCBNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4vcHJvai5qcyc7XG5pbXBvcnQgVW5pdHMgZnJvbSAnLi9wcm9qL1VuaXRzLmpzJztcbmltcG9ydCBUaWxlR3JpZCBmcm9tICcuL3RpbGVncmlkL1RpbGVHcmlkLmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7IW1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gRGVmYXVsdCB0aWxlIGdyaWQgZm9yIHRoZVxuICogcGFzc2VkIHByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgbGV0IHRpbGVHcmlkID0gcHJvamVjdGlvbi5nZXREZWZhdWx0VGlsZUdyaWQoKTtcbiAgaWYgKCF0aWxlR3JpZCkge1xuICAgIHRpbGVHcmlkID0gY3JlYXRlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBwcm9qZWN0aW9uLnNldERlZmF1bHRUaWxlR3JpZCh0aWxlR3JpZCk7XG4gIH1cbiAgcmV0dXJuIHRpbGVHcmlkO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWCh0aWxlR3JpZCwgdGlsZUNvb3JkLCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHogPSB0aWxlQ29vcmRbMF07XG4gIGNvbnN0IGNlbnRlciA9IHRpbGVHcmlkLmdldFRpbGVDb29yZENlbnRlcih0aWxlQ29vcmQpO1xuICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIGlmICghY29udGFpbnNDb29yZGluYXRlKHByb2plY3Rpb25FeHRlbnQsIGNlbnRlcikpIHtcbiAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgY29uc3Qgd29ybGRzQXdheSA9IE1hdGguY2VpbCgocHJvamVjdGlvbkV4dGVudFswXSAtIGNlbnRlclswXSkgLyB3b3JsZFdpZHRoKTtcbiAgICBjZW50ZXJbMF0gKz0gd29ybGRXaWR0aCAqIHdvcmxkc0F3YXk7XG4gICAgcmV0dXJuIHRpbGVHcmlkLmdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjZW50ZXIsIHopO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aWxlQ29vcmQ7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9tYXhab29tIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8bW9kdWxlOm9sL3NpemV+U2l6ZT19IG9wdF90aWxlU2l6ZSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudC9Db3JuZXI9fSBvcHRfY29ybmVyIEV4dGVudCBjb3JuZXIgKGRlZmF1bHQgaXMgYCd0b3AtbGVmdCdgKS5cbiAqIEByZXR1cm4geyFtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSwgb3B0X2Nvcm5lcikge1xuICBjb25zdCBjb3JuZXIgPSBvcHRfY29ybmVyICE9PSB1bmRlZmluZWQgPyBvcHRfY29ybmVyIDogQ29ybmVyLlRPUF9MRUZUO1xuXG4gIGNvbnN0IHJlc29sdXRpb25zID0gcmVzb2x1dGlvbnNGcm9tRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSk7XG5cbiAgcmV0dXJuIG5ldyBUaWxlR3JpZCh7XG4gICAgZXh0ZW50OiBleHRlbnQsXG4gICAgb3JpZ2luOiBnZXRDb3JuZXIoZXh0ZW50LCBjb3JuZXIpLFxuICAgIHJlc29sdXRpb25zOiByZXNvbHV0aW9ucyxcbiAgICB0aWxlU2l6ZTogb3B0X3RpbGVTaXplXG4gIH0pO1xufVxuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWFlaT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF0gRXh0ZW50IGZvciB0aGUgdGlsZSBncmlkLiBUaGUgb3JpZ2luIGZvciBhbiBYWVogdGlsZSBncmlkIGlzIHRoZVxuICogdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBleHRlbnQuIFRoZSB6ZXJvIGxldmVsIG9mIHRoZSBncmlkIGlzIGRlZmluZWQgYnkgdGhlIHJlc29sdXRpb24gYXQgd2hpY2ggb25lIHRpbGUgZml0cyBpbiB0aGVcbiAqIHByb3ZpZGVkIGV4dGVudC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZXh0ZW50IG9mIHRoZSBFUFNHOjM4NTcgcHJvamVjdGlvbiBpcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20uIFRoZSBkZWZhdWx0IGlzIGA0MmAuIFRoaXMgZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGxldmVsc1xuICogaW4gdGhlIGdyaWQgc2V0LiBGb3IgZXhhbXBsZSwgYSBgbWF4Wm9vbWAgb2YgMjEgbWVhbnMgdGhlcmUgYXJlIDIyIGxldmVscyBpbiB0aGUgZ3JpZCBzZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gTWluaW11bSB6b29tLlxuICogQHByb3BlcnR5IHtudW1iZXJ8bW9kdWxlOm9sL3NpemV+U2l6ZX0gW3RpbGVTaXplPVsyNTYsIDI1Nl1dIFRpbGUgc2l6ZSBpbiBwaXhlbHMuXG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZXMgYSB0aWxlIGdyaWQgd2l0aCBhIHN0YW5kYXJkIFhZWiB0aWxpbmcgc2NoZW1lLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWdyaWR+WFlaT3B0aW9ucz19IG9wdF9vcHRpb25zIFRpbGUgZ3JpZCBvcHRpb25zLlxuICogQHJldHVybiB7IW1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gVGlsZSBncmlkIGluc3RhbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlWFlaKG9wdF9vcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSAvKiogQHR5cGUge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH5PcHRpb25zfSAqLyAoe30pO1xuICBhc3NpZ24ob3B0aW9ucywgb3B0X29wdGlvbnMgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0X29wdGlvbnMgOiAvKiogQHR5cGUge21vZHVsZTpvbC90aWxlZ3JpZH5YWVpPcHRpb25zfSAqLyAoe30pKTtcbiAgaWYgKG9wdGlvbnMuZXh0ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmV4dGVudCA9IGdldFByb2plY3Rpb24oJ0VQU0c6Mzg1NycpLmdldEV4dGVudCgpO1xuICB9XG4gIG9wdGlvbnMucmVzb2x1dGlvbnMgPSByZXNvbHV0aW9uc0Zyb21FeHRlbnQoXG4gICAgb3B0aW9ucy5leHRlbnQsIG9wdGlvbnMubWF4Wm9vbSwgb3B0aW9ucy50aWxlU2l6ZSk7XG4gIGRlbGV0ZSBvcHRpb25zLm1heFpvb207XG5cbiAgcmV0dXJuIG5ldyBUaWxlR3JpZChvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIHJlc29sdXRpb25zIGFycmF5IGZyb20gYW4gZXh0ZW50LiAgQSB6b29tIGZhY3RvciBvZiAyIGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbWF4Wm9vbSBNYXhpbXVtIHpvb20gbGV2ZWwgKGRlZmF1bHQgaXNcbiAqICAgICBERUZBVUxUX01BWF9aT09NKS5cbiAqIEBwYXJhbSB7bnVtYmVyfG1vZHVsZTpvbC9zaXplflNpemU9fSBvcHRfdGlsZVNpemUgVGlsZSBzaXplIChkZWZhdWx0IHVzZXNcbiAqICAgICBERUZBVUxUX1RJTEVfU0laRSkuXG4gKiBAcmV0dXJuIHshQXJyYXkuPG51bWJlcj59IFJlc29sdXRpb25zIGFycmF5LlxuICovXG5mdW5jdGlvbiByZXNvbHV0aW9uc0Zyb21FeHRlbnQoZXh0ZW50LCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplKSB7XG4gIGNvbnN0IG1heFpvb20gPSBvcHRfbWF4Wm9vbSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRfbWF4Wm9vbSA6IERFRkFVTFRfTUFYX1pPT007XG5cbiAgY29uc3QgaGVpZ2h0ID0gZ2V0SGVpZ2h0KGV4dGVudCk7XG4gIGNvbnN0IHdpZHRoID0gZ2V0V2lkdGgoZXh0ZW50KTtcblxuICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZShvcHRfdGlsZVNpemUgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0X3RpbGVTaXplIDogREVGQVVMVF9USUxFX1NJWkUpO1xuICBjb25zdCBtYXhSZXNvbHV0aW9uID0gTWF0aC5tYXgoXG4gICAgd2lkdGggLyB0aWxlU2l6ZVswXSwgaGVpZ2h0IC8gdGlsZVNpemVbMV0pO1xuXG4gIGNvbnN0IGxlbmd0aCA9IG1heFpvb20gKyAxO1xuICBjb25zdCByZXNvbHV0aW9ucyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCB6ID0gMDsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgcmVzb2x1dGlvbnNbel0gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coMiwgeik7XG4gIH1cbiAgcmV0dXJuIHJlc29sdXRpb25zO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbWF4Wm9vbSBNYXhpbXVtIHpvb20gbGV2ZWwgKGRlZmF1bHQgaXNcbiAqICAgICBERUZBVUxUX01BWF9aT09NKS5cbiAqIEBwYXJhbSB7bnVtYmVyfG1vZHVsZTpvbC9zaXplflNpemU9fSBvcHRfdGlsZVNpemUgVGlsZSBzaXplIChkZWZhdWx0IHVzZXNcbiAqICAgICBERUZBVUxUX1RJTEVfU0laRSkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnQvQ29ybmVyPX0gb3B0X2Nvcm5lciBFeHRlbnQgY29ybmVyIChkZWZhdWx0IGlzIGAndG9wLWxlZnQnYCkuXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBUaWxlR3JpZCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvclByb2plY3Rpb24ocHJvamVjdGlvbiwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSwgb3B0X2Nvcm5lcikge1xuICBjb25zdCBleHRlbnQgPSBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgcmV0dXJuIGNyZWF0ZUZvckV4dGVudChleHRlbnQsIG9wdF9tYXhab29tLCBvcHRfdGlsZVNpemUsIG9wdF9jb3JuZXIpO1xufVxuXG5cbi8qKlxuICogR2VuZXJhdGUgYSB0aWxlIGdyaWQgZXh0ZW50IGZyb20gYSBwcm9qZWN0aW9uLiAgSWYgdGhlIHByb2plY3Rpb24gaGFzIGFuXG4gKiBleHRlbnQsIGl0IGlzIHVzZWQuICBJZiBub3QsIGEgZ2xvYmFsIGV4dGVudCBpcyBhc3N1bWVkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgcHJvamVjdGlvbiA9IGdldFByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIGxldCBleHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICBpZiAoIWV4dGVudCkge1xuICAgIGNvbnN0IGhhbGYgPSAxODAgKiBNRVRFUlNfUEVSX1VOSVRbVW5pdHMuREVHUkVFU10gLyBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgICBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZSgtaGFsZiwgLWhhbGYsIGhhbGYsIGhhbGYpO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWdyaWQvVGlsZUdyaWRcbiAqL1xuaW1wb3J0IHtERUZBVUxUX1RJTEVfU0laRX0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IFRpbGVSYW5nZSwge2NyZWF0ZU9yVXBkYXRlIGFzIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlfSBmcm9tICcuLi9UaWxlUmFuZ2UuanMnO1xuaW1wb3J0IHtpc1NvcnRlZCwgbGluZWFyRmluZE5lYXJlc3R9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGUsIGdldFRvcExlZnR9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuLi9zaXplLmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGUgYXMgY3JlYXRlT3JVcGRhdGVUaWxlQ29vcmR9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIE5vIHRpbGVzIG91dHNpZGUgdGhpc1xuICogZXh0ZW50IHdpbGwgYmUgcmVxdWVzdGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV9IHNvdXJjZXMuIFdoZW4gbm8gYG9yaWdpbmAgb3JcbiAqIGBvcmlnaW5zYCBhcmUgY29uZmlndXJlZCwgdGhlIGBvcmlnaW5gIHdpbGwgYmUgc2V0IHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBNaW5pbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IFtvcmlnaW5dIFRoZSB0aWxlIGdyaWQgb3JpZ2luLCBpLmUuIHdoZXJlIHRoZSBgeGBcbiAqIGFuZCBgeWAgYXhlcyBtZWV0IChgW3osIDAsIDBdYCkuIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdCB0byByaWdodCBhbmQgdXB3YXJkcy4gSWYgbm90XG4gKiBzcGVjaWZpZWQsIGBleHRlbnRgIG9yIGBvcmlnaW5zYCBtdXN0IGJlIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59IFtvcmlnaW5zXSBUaWxlIGdyaWQgb3JpZ2lucywgaS5lLiB3aGVyZVxuICogdGhlIGB4YCBhbmQgYHlgIGF4ZXMgbWVldCAoYFt6LCAwLCAwXWApLCBmb3IgZWFjaCB6b29tIGxldmVsLiBJZiBnaXZlbiwgdGhlIGFycmF5IGxlbmd0aFxuICogc2hvdWxkIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGByZXNvbHV0aW9uc2AgYXJyYXksIGkuZS4gZWFjaCByZXNvbHV0aW9uIGNhbiBoYXZlIGEgZGlmZmVyZW50XG4gKiBvcmlnaW4uIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdCB0byByaWdodCBhbmQgdXB3YXJkcy4gSWYgbm90IHNwZWNpZmllZCwgYGV4dGVudGAgb3JcbiAqIGBvcmlnaW5gIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgeyFBcnJheS48bnVtYmVyPn0gcmVzb2x1dGlvbnMgUmVzb2x1dGlvbnMuIFRoZSBhcnJheSBpbmRleCBvZiBlYWNoIHJlc29sdXRpb24gbmVlZHNcbiAqIHRvIG1hdGNoIHRoZSB6b29tIGxldmVsLiBUaGlzIG1lYW5zIHRoYXQgZXZlbiBpZiBhIGBtaW5ab29tYCBpcyBjb25maWd1cmVkLCB0aGUgcmVzb2x1dGlvbnNcbiAqIGFycmF5IHdpbGwgaGF2ZSBhIGxlbmd0aCBvZiBgbWF4Wm9vbSArIDFgLlxuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOm9sL3NpemV+U2l6ZT59IFtzaXplc10gU2l6ZXMuXG4gKiBAcHJvcGVydHkge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplfSBbdGlsZVNpemVdIFRpbGUgc2l6ZS5cbiAqIERlZmF1bHQgaXMgYFsyNTYsIDI1Nl1gLlxuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOm9sL3NpemV+U2l6ZT59IFt0aWxlU2l6ZXNdIFRpbGUgc2l6ZXMuIElmIGdpdmVuLCB0aGUgYXJyYXkgbGVuZ3RoXG4gKiBzaG91bGQgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheSwgaS5lLiBlYWNoIHJlc29sdXRpb24gY2FuIGhhdmUgYSBkaWZmZXJlbnRcbiAqIHRpbGUgc2l6ZS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc2V0dGluZyB0aGUgZ3JpZCBwYXR0ZXJuIGZvciBzb3VyY2VzIGFjY2Vzc2luZyB0aWxlZC1pbWFnZVxuICogc2VydmVycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfk9wdGlvbnN9IG9wdGlvbnMgVGlsZSBncmlkIG9wdGlvbnMuXG4gKiBAc3RydWN0XG4gKiBAYXBpXG4gKi9cbmNvbnN0IFRpbGVHcmlkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1pblpvb20gPSBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluWm9vbSA6IDA7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0aGlzLnJlc29sdXRpb25zXyA9IG9wdGlvbnMucmVzb2x1dGlvbnM7XG4gIGFzc2VydChpc1NvcnRlZCh0aGlzLnJlc29sdXRpb25zXywgZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYTtcbiAgfSwgdHJ1ZSksIDE3KTsgLy8gYHJlc29sdXRpb25zYCBtdXN0IGJlIHNvcnRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyXG5cblxuICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYSBjb25zaXN0ZW50IHpvb20gZmFjdG9yIGFuZCBvcmlnaW5cbiAgbGV0IHpvb21GYWN0b3I7XG4gIGlmICghb3B0aW9ucy5vcmlnaW5zKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmICghem9vbUZhY3Rvcikge1xuICAgICAgICB6b29tRmFjdG9yID0gdGhpcy5yZXNvbHV0aW9uc19baV0gLyB0aGlzLnJlc29sdXRpb25zX1tpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5yZXNvbHV0aW9uc19baV0gLyB0aGlzLnJlc29sdXRpb25zX1tpICsgMV0gIT09IHpvb21GYWN0b3IpIHtcbiAgICAgICAgICB6b29tRmFjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLnpvb21GYWN0b3JfID0gem9vbUZhY3RvcjtcblxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1heFpvb20gPSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX1cbiAgICovXG4gIHRoaXMub3JpZ2luXyA9IG9wdGlvbnMub3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9yaWdpbiA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59XG4gICAqL1xuICB0aGlzLm9yaWdpbnNfID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMub3JpZ2lucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5vcmlnaW5zXyA9IG9wdGlvbnMub3JpZ2lucztcbiAgICBhc3NlcnQodGhpcy5vcmlnaW5zXy5sZW5ndGggPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoLFxuICAgICAgMjApOyAvLyBOdW1iZXIgb2YgYG9yaWdpbnNgIGFuZCBgcmVzb2x1dGlvbnNgIG11c3QgYmUgZXF1YWxcbiAgfVxuXG4gIGNvbnN0IGV4dGVudCA9IG9wdGlvbnMuZXh0ZW50O1xuXG4gIGlmIChleHRlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXRoaXMub3JpZ2luXyAmJiAhdGhpcy5vcmlnaW5zXykge1xuICAgIHRoaXMub3JpZ2luXyA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgfVxuXG4gIGFzc2VydChcbiAgICAoIXRoaXMub3JpZ2luXyAmJiB0aGlzLm9yaWdpbnNfKSB8fCAodGhpcy5vcmlnaW5fICYmICF0aGlzLm9yaWdpbnNfKSxcbiAgICAxOCk7IC8vIEVpdGhlciBgb3JpZ2luYCBvciBgb3JpZ2luc2AgbXVzdCBiZSBjb25maWd1cmVkLCBuZXZlciBib3RoXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyfG1vZHVsZTpvbC9zaXplflNpemU+fVxuICAgKi9cbiAgdGhpcy50aWxlU2l6ZXNfID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMudGlsZVNpemVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRpbGVTaXplc18gPSBvcHRpb25zLnRpbGVTaXplcztcbiAgICBhc3NlcnQodGhpcy50aWxlU2l6ZXNfLmxlbmd0aCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGgsXG4gICAgICAxOSk7IC8vIE51bWJlciBvZiBgdGlsZVNpemVzYCBhbmQgYHJlc29sdXRpb25zYCBtdXN0IGJlIGVxdWFsXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplfVxuICAgKi9cbiAgdGhpcy50aWxlU2l6ZV8gPSBvcHRpb25zLnRpbGVTaXplICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMudGlsZVNpemUgOlxuICAgICF0aGlzLnRpbGVTaXplc18gPyBERUZBVUxUX1RJTEVfU0laRSA6IG51bGw7XG4gIGFzc2VydChcbiAgICAoIXRoaXMudGlsZVNpemVfICYmIHRoaXMudGlsZVNpemVzXykgfHxcbiAgICAgICh0aGlzLnRpbGVTaXplXyAmJiAhdGhpcy50aWxlU2l6ZXNfKSxcbiAgICAyMik7IC8vIEVpdGhlciBgdGlsZVNpemVgIG9yIGB0aWxlU2l6ZXNgIG11c3QgYmUgY29uZmlndXJlZCwgbmV2ZXIgYm90aFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAqL1xuICB0aGlzLmV4dGVudF8gPSBleHRlbnQgIT09IHVuZGVmaW5lZCA/IGV4dGVudCA6IG51bGw7XG5cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvVGlsZVJhbmdlPn1cbiAgICovXG4gIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC9zaXplflNpemV9XG4gICAqL1xuICB0aGlzLnRtcFNpemVfID0gWzAsIDBdO1xuXG4gIGlmIChvcHRpb25zLnNpemVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IG9wdGlvbnMuc2l6ZXMubWFwKGZ1bmN0aW9uKHNpemUsIHopIHtcbiAgICAgIGNvbnN0IHRpbGVSYW5nZSA9IG5ldyBUaWxlUmFuZ2UoXG4gICAgICAgIE1hdGgubWluKDAsIHNpemVbMF0pLCBNYXRoLm1heChzaXplWzBdIC0gMSwgLTEpLFxuICAgICAgICBNYXRoLm1pbigwLCBzaXplWzFdKSwgTWF0aC5tYXgoc2l6ZVsxXSAtIDEsIC0xKSk7XG4gICAgICByZXR1cm4gdGlsZVJhbmdlO1xuICAgIH0sIHRoaXMpO1xuICB9IGVsc2UgaWYgKGV4dGVudCkge1xuICAgIHRoaXMuY2FsY3VsYXRlVGlsZVJhbmdlc18oZXh0ZW50KTtcbiAgfVxuXG59O1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH1cbiAqL1xuY29uc3QgdG1wVGlsZUNvb3JkID0gWzAsIDAsIDBdO1xuXG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdpdGggZWFjaCB0aWxlIGNvb3JkaW5hdGUgZm9yIGEgZ2l2ZW4gZXh0ZW50IGFuZCB6b29tIGxldmVsLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbSBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkKX0gY2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIHdpdGggZWFjaCB0aWxlIGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5mb3JFYWNoVGlsZUNvb3JkID0gZnVuY3Rpb24oZXh0ZW50LCB6b29tLCBjYWxsYmFjaykge1xuICBjb25zdCB0aWxlUmFuZ2UgPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6b29tKTtcbiAgZm9yIChsZXQgaSA9IHRpbGVSYW5nZS5taW5YLCBpaSA9IHRpbGVSYW5nZS5tYXhYOyBpIDw9IGlpOyArK2kpIHtcbiAgICBmb3IgKGxldCBqID0gdGlsZVJhbmdlLm1pblksIGpqID0gdGlsZVJhbmdlLm1heFk7IGogPD0gamo7ICsraikge1xuICAgICAgY2FsbGJhY2soW3pvb20sIGksIGpdKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBudW1iZXIsIG1vZHVsZTpvbC9UaWxlUmFuZ2UpOiBib29sZWFufSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEBwYXJhbSB7VD19IG9wdF90aGlzIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgY2FsbGJhY2tgLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlPX0gb3B0X3RpbGVSYW5nZSBUZW1wb3JhcnkgbW9kdWxlOm9sL1RpbGVSYW5nZSBvYmplY3QuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBUZW1wb3JhcnkgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnQgb2JqZWN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ2FsbGJhY2sgc3VjY2VlZGVkLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmZvckVhY2hUaWxlQ29vcmRQYXJlbnRUaWxlUmFuZ2UgPSBmdW5jdGlvbih0aWxlQ29vcmQsIGNhbGxiYWNrLCBvcHRfdGhpcywgb3B0X3RpbGVSYW5nZSwgb3B0X2V4dGVudCkge1xuICBsZXQgdGlsZVJhbmdlLCB4LCB5O1xuICBsZXQgdGlsZUNvb3JkRXh0ZW50ID0gbnVsbDtcbiAgbGV0IHogPSB0aWxlQ29vcmRbMF0gLSAxO1xuICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgIHggPSB0aWxlQ29vcmRbMV07XG4gICAgeSA9IHRpbGVDb29yZFsyXTtcbiAgfSBlbHNlIHtcbiAgICB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIG9wdF9leHRlbnQpO1xuICB9XG4gIHdoaWxlICh6ID49IHRoaXMubWluWm9vbSkge1xuICAgIGlmICh0aGlzLnpvb21GYWN0b3JfID09PSAyKSB7XG4gICAgICB4ID0gTWF0aC5mbG9vcih4IC8gMik7XG4gICAgICB5ID0gTWF0aC5mbG9vcih5IC8gMik7XG4gICAgICB0aWxlUmFuZ2UgPSBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZSh4LCB4LCB5LCB5LCBvcHRfdGlsZVJhbmdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZVJhbmdlID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKHRpbGVDb29yZEV4dGVudCwgeiwgb3B0X3RpbGVSYW5nZSk7XG4gICAgfVxuICAgIGlmIChjYWxsYmFjay5jYWxsKG9wdF90aGlzLCB6LCB0aWxlUmFuZ2UpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLS16O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGV4dGVudCBmb3IgdGhpcyB0aWxlIGdyaWQsIGlmIGl0IHdhcyBjb25maWd1cmVkLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5leHRlbnRfO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgZ3JpZC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWF4IHpvb20uXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRNYXhab29tID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm1heFpvb207XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBncmlkLlxuICogQHJldHVybiB7bnVtYmVyfSBNaW4gem9vbS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldE1pblpvb20gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubWluWm9vbTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIG9yaWdpbiBmb3IgdGhlIGdyaWQgYXQgdGhlIGdpdmVuIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBPcmlnaW4uXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRPcmlnaW4gPSBmdW5jdGlvbih6KSB7XG4gIGlmICh0aGlzLm9yaWdpbl8pIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbnNfW3pdO1xuICB9XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSByZXNvbHV0aW9uIGZvciB0aGUgZ2l2ZW4gem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbi5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFJlc29sdXRpb24gPSBmdW5jdGlvbih6KSB7XG4gIHJldHVybiB0aGlzLnJlc29sdXRpb25zX1t6XTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGxpc3Qgb2YgcmVzb2x1dGlvbnMgZm9yIHRoZSB0aWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gUmVzb2x1dGlvbnMuXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc187XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGVSYW5nZT19IG9wdF90aWxlUmFuZ2UgVGVtcG9yYXJ5IG1vZHVsZTpvbC9UaWxlUmFuZ2Ugb2JqZWN0LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgVGVtcG9yYXJ5IG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50IG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IFRpbGUgcmFuZ2UuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRDaGlsZFRpbGVSYW5nZSA9IGZ1bmN0aW9uKHRpbGVDb29yZCwgb3B0X3RpbGVSYW5nZSwgb3B0X2V4dGVudCkge1xuICBpZiAodGlsZUNvb3JkWzBdIDwgdGhpcy5tYXhab29tKSB7XG4gICAgaWYgKHRoaXMuem9vbUZhY3Rvcl8gPT09IDIpIHtcbiAgICAgIGNvbnN0IG1pblggPSB0aWxlQ29vcmRbMV0gKiAyO1xuICAgICAgY29uc3QgbWluWSA9IHRpbGVDb29yZFsyXSAqIDI7XG4gICAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UobWluWCwgbWluWCArIDEsIG1pblksIG1pblkgKyAxLCBvcHRfdGlsZVJhbmdlKTtcbiAgICB9XG4gICAgY29uc3QgdGlsZUNvb3JkRXh0ZW50ID0gdGhpcy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCBvcHRfZXh0ZW50KTtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgdGlsZUNvb3JkRXh0ZW50LCB0aWxlQ29vcmRbMF0gKyAxLCBvcHRfdGlsZVJhbmdlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGV4dGVudCBmb3IgYSB0aWxlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudCBvYmplY3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZVJhbmdlRXh0ZW50ID0gZnVuY3Rpb24oeiwgdGlsZVJhbmdlLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHopO1xuICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHopO1xuICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcbiAgY29uc3QgbWluWCA9IG9yaWdpblswXSArIHRpbGVSYW5nZS5taW5YICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICBjb25zdCBtYXhYID0gb3JpZ2luWzBdICsgKHRpbGVSYW5nZS5tYXhYICsgMSkgKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gIGNvbnN0IG1pblkgPSBvcmlnaW5bMV0gKyB0aWxlUmFuZ2UubWluWSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgY29uc3QgbWF4WSA9IG9yaWdpblsxXSArICh0aWxlUmFuZ2UubWF4WSArIDEpICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgb3B0X2V4dGVudCk7XG59O1xuXG5cbi8qKlxuICogR2V0IGEgdGlsZSByYW5nZSBmb3IgdGhlIGdpdmVuIGV4dGVudCBhbmQgaW50ZWdlciB6b29tIGxldmVsLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGVSYW5nZT19IG9wdF90aWxlUmFuZ2UgVGVtcG9yYXJ5IHRpbGUgcmFuZ2Ugb2JqZWN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL1RpbGVSYW5nZX0gVGlsZSByYW5nZS5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFogPSBmdW5jdGlvbihleHRlbnQsIHosIG9wdF90aWxlUmFuZ2UpIHtcbiAgY29uc3QgdGlsZUNvb3JkID0gdG1wVGlsZUNvb3JkO1xuICB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kWl8oZXh0ZW50WzBdLCBleHRlbnRbMV0sIHosIGZhbHNlLCB0aWxlQ29vcmQpO1xuICBjb25zdCBtaW5YID0gdGlsZUNvb3JkWzFdO1xuICBjb25zdCBtaW5ZID0gdGlsZUNvb3JkWzJdO1xuICB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kWl8oZXh0ZW50WzJdLCBleHRlbnRbM10sIHosIHRydWUsIHRpbGVDb29yZCk7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShtaW5YLCB0aWxlQ29vcmRbMV0sIG1pblksIHRpbGVDb29yZFsyXSwgb3B0X3RpbGVSYW5nZSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IFRpbGUgY2VudGVyLlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkQ2VudGVyID0gZnVuY3Rpb24odGlsZUNvb3JkKSB7XG4gIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHRpbGVDb29yZFswXSk7XG4gIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24odGlsZUNvb3JkWzBdKTtcbiAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh0aWxlQ29vcmRbMF0pLCB0aGlzLnRtcFNpemVfKTtcbiAgcmV0dXJuIFtcbiAgICBvcmlnaW5bMF0gKyAodGlsZUNvb3JkWzFdICsgMC41KSAqIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbixcbiAgICBvcmlnaW5bMV0gKyAodGlsZUNvb3JkWzJdICsgMC41KSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvblxuICBdO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgZXh0ZW50IG9mIGEgdGlsZSBjb29yZGluYXRlLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBUZW1wb3JhcnkgZXh0ZW50IG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRFeHRlbnQgPSBmdW5jdGlvbih0aWxlQ29vcmQsIG9wdF9leHRlbnQpIHtcbiAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4odGlsZUNvb3JkWzBdKTtcbiAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih0aWxlQ29vcmRbMF0pO1xuICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHRpbGVDb29yZFswXSksIHRoaXMudG1wU2l6ZV8pO1xuICBjb25zdCBtaW5YID0gb3JpZ2luWzBdICsgdGlsZUNvb3JkWzFdICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICBjb25zdCBtaW5ZID0gb3JpZ2luWzFdICsgdGlsZUNvb3JkWzJdICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICBjb25zdCBtYXhYID0gbWluWCArIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgY29uc3QgbWF4WSA9IG1pblkgKyB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb247XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBvcHRfZXh0ZW50KTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBmb3IgdGhlIGdpdmVuIG1hcCBjb29yZGluYXRlIGFuZCByZXNvbHV0aW9uLiAgVGhpc1xuICogbWV0aG9kIGNvbnNpZGVycyB0aGF0IGNvb3JkaW5hdGVzIHRoYXQgaW50ZXJzZWN0IHRpbGUgYm91bmRhcmllcyBzaG91bGQgYmVcbiAqIGFzc2lnbmVkIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQ9fSBvcHRfdGlsZUNvb3JkIERlc3RpbmF0aW9uIG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkIG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRGb3JDb29yZEFuZFJlc29sdXRpb24gPSBmdW5jdGlvbihjb29yZGluYXRlLCByZXNvbHV0aW9uLCBvcHRfdGlsZUNvb3JkKSB7XG4gIHJldHVybiB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8oXG4gICAgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgcmVzb2x1dGlvbiwgZmFsc2UsIG9wdF90aWxlQ29vcmQpO1xufTtcblxuXG4vKipcbiAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIGNhbGxlZCBmb3IgcmVzb2x1dGlvbnMgdGhhdCBjb3JyZXNwb25kXG4gKiB0byBhbiBpbnRlZ2VyIHpvb20gbGV2ZWwuICBJbnN0ZWFkIGNhbGwgdGhlIGBnZXRUaWxlQ29vcmRGb3JYWUFuZFpfYCBtZXRob2QuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24gKGZvciBhIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWwpLlxuICogQHBhcmFtIHtib29sZWFufSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5IEluc3RlYWQgb2YgbGV0dGluZyBlZGdlXG4gKiAgICAgaW50ZXJzZWN0aW9ucyBnbyB0byB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZSwgbGV0IGVkZ2UgaW50ZXJzZWN0aW9uc1xuICogICAgIGdvIHRvIHRoZSBsb3dlciB0aWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkPX0gb3B0X3RpbGVDb29yZCBUZW1wb3JhcnkgbW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQgb2JqZWN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwcml2YXRlXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fID0gZnVuY3Rpb24oXG4gIHgsIHksIHJlc29sdXRpb24sIHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3ksIG9wdF90aWxlQ29vcmQpIHtcbiAgY29uc3QgeiA9IHRoaXMuZ2V0WkZvclJlc29sdXRpb24ocmVzb2x1dGlvbik7XG4gIGNvbnN0IHNjYWxlID0gcmVzb2x1dGlvbiAvIHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuXG4gIGNvbnN0IGFkanVzdFggPSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5ID8gMC41IDogMDtcbiAgY29uc3QgYWRqdXN0WSA9IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgPyAwIDogMC41O1xuICBjb25zdCB4RnJvbU9yaWdpbiA9IE1hdGguZmxvb3IoKHggLSBvcmlnaW5bMF0pIC8gcmVzb2x1dGlvbiArIGFkanVzdFgpO1xuICBjb25zdCB5RnJvbU9yaWdpbiA9IE1hdGguZmxvb3IoKHkgLSBvcmlnaW5bMV0pIC8gcmVzb2x1dGlvbiArIGFkanVzdFkpO1xuICBsZXQgdGlsZUNvb3JkWCA9IHNjYWxlICogeEZyb21PcmlnaW4gLyB0aWxlU2l6ZVswXTtcbiAgbGV0IHRpbGVDb29yZFkgPSBzY2FsZSAqIHlGcm9tT3JpZ2luIC8gdGlsZVNpemVbMV07XG5cbiAgaWYgKHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kpIHtcbiAgICB0aWxlQ29vcmRYID0gTWF0aC5jZWlsKHRpbGVDb29yZFgpIC0gMTtcbiAgICB0aWxlQ29vcmRZID0gTWF0aC5jZWlsKHRpbGVDb29yZFkpIC0gMTtcbiAgfSBlbHNlIHtcbiAgICB0aWxlQ29vcmRYID0gTWF0aC5mbG9vcih0aWxlQ29vcmRYKTtcbiAgICB0aWxlQ29vcmRZID0gTWF0aC5mbG9vcih0aWxlQ29vcmRZKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZCh6LCB0aWxlQ29vcmRYLCB0aWxlQ29vcmRZLCBvcHRfdGlsZUNvb3JkKTtcbn07XG5cblxuLyoqXG4gKiBBbHRob3VnaCB0aGVyZSBpcyByZXBldGl0aW9uIGJldHdlZW4gdGhpcyBtZXRob2QgYW5kIGBnZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fYCxcbiAqIHRoZXkgc2hvdWxkIGhhdmUgc2VwYXJhdGUgaW1wbGVtZW50YXRpb25zLiAgVGhpcyBtZXRob2QgaXMgZm9yIGludGVnZXIgem9vbVxuICogbGV2ZWxzLiAgVGhlIG90aGVyIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZm9yIHJlc29sdXRpb25zIGNvcnJlc3BvbmRpbmdcbiAqIHRvIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWxzLlxuICogQHBhcmFtIHtudW1iZXJ9IHggTWFwIHggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IE1hcCB5IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgSW5zdGVhZCBvZiBsZXR0aW5nIGVkZ2VcbiAqICAgICBpbnRlcnNlY3Rpb25zIGdvIHRvIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLCBsZXQgZWRnZSBpbnRlcnNlY3Rpb25zXG4gKiAgICAgZ28gdG8gdGhlIGxvd2VyIHRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQ9fSBvcHRfdGlsZUNvb3JkIFRlbXBvcmFyeSBtb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZCBvYmplY3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICogQHByaXZhdGVcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZEZvclhZQW5kWl8gPSBmdW5jdGlvbih4LCB5LCB6LCByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5LCBvcHRfdGlsZUNvb3JkKSB7XG4gIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHopO1xuICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHopO1xuICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcblxuICBjb25zdCBhZGp1c3RYID0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSA/IDAuNSA6IDA7XG4gIGNvbnN0IGFkanVzdFkgPSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5ID8gMCA6IDAuNTtcbiAgY29uc3QgeEZyb21PcmlnaW4gPSBNYXRoLmZsb29yKCh4IC0gb3JpZ2luWzBdKSAvIHJlc29sdXRpb24gKyBhZGp1c3RYKTtcbiAgY29uc3QgeUZyb21PcmlnaW4gPSBNYXRoLmZsb29yKCh5IC0gb3JpZ2luWzFdKSAvIHJlc29sdXRpb24gKyBhZGp1c3RZKTtcbiAgbGV0IHRpbGVDb29yZFggPSB4RnJvbU9yaWdpbiAvIHRpbGVTaXplWzBdO1xuICBsZXQgdGlsZUNvb3JkWSA9IHlGcm9tT3JpZ2luIC8gdGlsZVNpemVbMV07XG5cbiAgaWYgKHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kpIHtcbiAgICB0aWxlQ29vcmRYID0gTWF0aC5jZWlsKHRpbGVDb29yZFgpIC0gMTtcbiAgICB0aWxlQ29vcmRZID0gTWF0aC5jZWlsKHRpbGVDb29yZFkpIC0gMTtcbiAgfSBlbHNlIHtcbiAgICB0aWxlQ29vcmRYID0gTWF0aC5mbG9vcih0aWxlQ29vcmRYKTtcbiAgICB0aWxlQ29vcmRZID0gTWF0aC5mbG9vcih0aWxlQ29vcmRZKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZCh6LCB0aWxlQ29vcmRYLCB0aWxlQ29vcmRZLCBvcHRfdGlsZUNvb3JkKTtcbn07XG5cblxuLyoqXG4gKiBHZXQgYSB0aWxlIGNvb3JkaW5hdGUgZ2l2ZW4gYSBtYXAgY29vcmRpbmF0ZSBhbmQgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHogWm9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQ9fSBvcHRfdGlsZUNvb3JkIERlc3RpbmF0aW9uIG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkIG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRGb3JDb29yZEFuZFogPSBmdW5jdGlvbihjb29yZGluYXRlLCB6LCBvcHRfdGlsZUNvb3JkKSB7XG4gIHJldHVybiB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kWl8oXG4gICAgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgeiwgZmFsc2UsIG9wdF90aWxlQ29vcmQpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcmVzb2x1dGlvbi5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZFJlc29sdXRpb24gPSBmdW5jdGlvbih0aWxlQ29vcmQpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfW3RpbGVDb29yZFswXV07XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB0aWxlIHNpemUgZm9yIGEgem9vbSBsZXZlbC4gVGhlIHR5cGUgb2YgdGhlIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZVxuICogYHRpbGVTaXplYCBvciBgdGlsZVNpemVzYCB0aGF0IHRoZSB0aWxlIGdyaWQgd2FzIGNvbmZpZ3VyZWQgd2l0aC4gVG8gYWx3YXlzXG4gKiBnZXQgYW4gYG1vZHVsZTpvbC9zaXplflNpemVgLCBydW4gdGhlIHJlc3VsdCB0aHJvdWdoIGBtb2R1bGU6b2wvc2l6ZX5TaXplLnRvU2l6ZSgpYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gKiBAcmV0dXJuIHtudW1iZXJ8bW9kdWxlOm9sL3NpemV+U2l6ZX0gVGlsZSBzaXplLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZVNpemUgPSBmdW5jdGlvbih6KSB7XG4gIGlmICh0aGlzLnRpbGVTaXplXykge1xuICAgIHJldHVybiB0aGlzLnRpbGVTaXplXztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy50aWxlU2l6ZXNfW3pdO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWm9vbSBsZXZlbC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IEV4dGVudCB0aWxlIHJhbmdlIGZvciB0aGUgc3BlY2lmaWVkIHpvb20gbGV2ZWwuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRGdWxsVGlsZVJhbmdlID0gZnVuY3Rpb24oeikge1xuICBpZiAoIXRoaXMuZnVsbFRpbGVSYW5nZXNfKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRpbGVSYW5nZXNfW3pdO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpcmVjdGlvbiBJZiAwLCB0aGUgbmVhcmVzdCByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC5cbiAqICAgICBJZiAxLCB0aGUgbmVhcmVzdCBsb3dlciByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC4gSWYgLTEsIHRoZSBuZWFyZXN0XG4gKiAgICAgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBEZWZhdWx0IGlzIDAuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFouXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRaRm9yUmVzb2x1dGlvbiA9IGZ1bmN0aW9uKHJlc29sdXRpb24sIG9wdF9kaXJlY3Rpb24pIHtcbiAgY29uc3QgeiA9IGxpbmVhckZpbmROZWFyZXN0KHRoaXMucmVzb2x1dGlvbnNfLCByZXNvbHV0aW9uLCBvcHRfZGlyZWN0aW9uIHx8IDApO1xuICByZXR1cm4gY2xhbXAoeiwgdGhpcy5taW5ab29tLCB0aGlzLm1heFpvb20pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7IW1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50IGZvciB0aGlzIHRpbGUgZ3JpZC5cbiAqIEBwcml2YXRlXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5jYWxjdWxhdGVUaWxlUmFuZ2VzXyA9IGZ1bmN0aW9uKGV4dGVudCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGg7XG4gIGNvbnN0IGZ1bGxUaWxlUmFuZ2VzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IHogPSB0aGlzLm1pblpvb207IHogPCBsZW5ndGg7ICsreikge1xuICAgIGZ1bGxUaWxlUmFuZ2VzW3pdID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeik7XG4gIH1cbiAgdGhpcy5mdWxsVGlsZVJhbmdlc18gPSBmdWxsVGlsZVJhbmdlcztcbn07XG5leHBvcnQgZGVmYXVsdCBUaWxlR3JpZDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZC9jb21tb25cbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgbWF4aW11bSB6b29tIGZvciBkZWZhdWx0IHRpbGUgZ3JpZHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfWk9PTSA9IDQyO1xuXG4vKipcbiAqIERlZmF1bHQgdGlsZSBzaXplLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElMRV9TSVpFID0gMjU2O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGV1cmxmdW5jdGlvblxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtoYXNoIGFzIHRpbGVDb29yZEhhc2h9IGZyb20gJy4vdGlsZWNvb3JkLmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBUZW1wbGF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHRpbGVHcmlkKSB7XG4gIGNvbnN0IHpSZWdFeCA9IC9cXHt6XFx9L2c7XG4gIGNvbnN0IHhSZWdFeCA9IC9cXHt4XFx9L2c7XG4gIGNvbnN0IHlSZWdFeCA9IC9cXHt5XFx9L2c7XG4gIGNvbnN0IGRhc2hZUmVnRXggPSAvXFx7LXlcXH0vZztcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBDb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRpbGUgVVJMLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgICAgaWYgKCF0aWxlQ29vcmQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKHpSZWdFeCwgdGlsZUNvb3JkWzBdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgLnJlcGxhY2UoeFJlZ0V4LCB0aWxlQ29vcmRbMV0udG9TdHJpbmcoKSlcbiAgICAgICAgICAucmVwbGFjZSh5UmVnRXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgeSA9IC10aWxlQ29vcmRbMl0gLSAxO1xuICAgICAgICAgICAgcmV0dXJuIHkudG9TdHJpbmcoKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXBsYWNlKGRhc2hZUmVnRXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGlsZUdyaWQuZ2V0RnVsbFRpbGVSYW5nZSh6KTtcbiAgICAgICAgICAgIGFzc2VydChyYW5nZSwgNTUpOyAvLyBUaGUgey15fSBwbGFjZWhvbGRlciByZXF1aXJlcyBhIHRpbGUgZ3JpZCB3aXRoIGV4dGVudFxuICAgICAgICAgICAgY29uc3QgeSA9IHJhbmdlLmdldEhlaWdodCgpICsgdGlsZUNvb3JkWzJdO1xuICAgICAgICAgICAgcmV0dXJuIHkudG9TdHJpbmcoKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB0ZW1wbGF0ZXMgVGVtcGxhdGVzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UZW1wbGF0ZXModGVtcGxhdGVzLCB0aWxlR3JpZCkge1xuICBjb25zdCBsZW4gPSB0ZW1wbGF0ZXMubGVuZ3RoO1xuICBjb25zdCB0aWxlVXJsRnVuY3Rpb25zID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0aWxlVXJsRnVuY3Rpb25zW2ldID0gY3JlYXRlRnJvbVRlbXBsYXRlKHRlbXBsYXRlc1tpXSwgdGlsZUdyaWQpO1xuICB9XG4gIHJldHVybiBjcmVhdGVGcm9tVGlsZVVybEZ1bmN0aW9ucyh0aWxlVXJsRnVuY3Rpb25zKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9uPn0gdGlsZVVybEZ1bmN0aW9ucyBUaWxlIFVSTCBGdW5jdGlvbnMuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGlsZVVybEZ1bmN0aW9ucyh0aWxlVXJsRnVuY3Rpb25zKSB7XG4gIGlmICh0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zWzBdO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbih0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICAgIGlmICghdGlsZUNvb3JkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBoID0gdGlsZUNvb3JkSGFzaCh0aWxlQ29vcmQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IG1vZHVsbyhoLCB0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zW2luZGV4XSh0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudWxsVGlsZVVybEZ1bmN0aW9uKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gQXJyYXkgb2YgdXJscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFVybCh1cmwpIHtcbiAgY29uc3QgdXJscyA9IFtdO1xuICBsZXQgbWF0Y2ggPSAvXFx7KFthLXpdKS0oW2Etel0pXFx9Ly5leGVjKHVybCk7XG4gIGlmIChtYXRjaCkge1xuICAgIC8vIGNoYXIgcmFuZ2VcbiAgICBjb25zdCBzdGFydENoYXJDb2RlID0gbWF0Y2hbMV0uY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBzdG9wQ2hhckNvZGUgPSBtYXRjaFsyXS5jaGFyQ29kZUF0KDApO1xuICAgIGxldCBjaGFyQ29kZTtcbiAgICBmb3IgKGNoYXJDb2RlID0gc3RhcnRDaGFyQ29kZTsgY2hhckNvZGUgPD0gc3RvcENoYXJDb2RlOyArK2NoYXJDb2RlKSB7XG4gICAgICB1cmxzLnB1c2godXJsLnJlcGxhY2UobWF0Y2hbMF0sIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxzO1xuICB9XG4gIG1hdGNoID0gbWF0Y2ggPSAvXFx7KFxcZCspLShcXGQrKVxcfS8uZXhlYyh1cmwpO1xuICBpZiAobWF0Y2gpIHtcbiAgICAvLyBudW1iZXIgcmFuZ2VcbiAgICBjb25zdCBzdG9wID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcbiAgICBmb3IgKGxldCBpID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgIHVybHMucHVzaCh1cmwucmVwbGFjZShtYXRjaFswXSwgaS50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxzO1xuICB9XG4gIHVybHMucHVzaCh1cmwpO1xuICByZXR1cm4gdXJscztcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC93ZWJnbFxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzIHRha2VuIGZyb20gZ29vZy53ZWJnbFxuICovXG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBPTkUgPSAxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgU1JDX0FMUEhBID0gMHgwMzAyO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQ09MT1JfQVRUQUNITUVOVDAgPSAweDhDRTA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBDT0xPUl9CVUZGRVJfQklUID0gMHgwMDAwNDAwMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFRSSUFOR0xFUyA9IDB4MDAwNDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFRSSUFOR0xFX1NUUklQID0gMHgwMDA1O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgT05FX01JTlVTX1NSQ19BTFBIQSA9IDB4MDMwMztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEFSUkFZX0JVRkZFUiA9IDB4ODg5MjtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEVMRU1FTlRfQVJSQVlfQlVGRkVSID0gMHg4ODkzO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgU1RSRUFNX0RSQVcgPSAweDg4RTA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBTVEFUSUNfRFJBVyA9IDB4ODhFNDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERZTkFNSUNfRFJBVyA9IDB4ODhFODtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IENVTExfRkFDRSA9IDB4MEI0NDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJMRU5EID0gMHgwQkUyO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgU1RFTkNJTF9URVNUID0gMHgwQjkwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgREVQVEhfVEVTVCA9IDB4MEI3MTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFNDSVNTT1JfVEVTVCA9IDB4MEMxMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFVOU0lHTkVEX0JZVEUgPSAweDE0MDE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBVTlNJR05FRF9TSE9SVCA9IDB4MTQwMztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFVOU0lHTkVEX0lOVCA9IDB4MTQwNTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEZMT0FUID0gMHgxNDA2O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgUkdCQSA9IDB4MTkwODtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEZSQUdNRU5UX1NIQURFUiA9IDB4OEIzMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFZFUlRFWF9TSEFERVIgPSAweDhCMzE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBMSU5LX1NUQVRVUyA9IDB4OEI4MjtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IExJTkVBUiA9IDB4MjYwMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFRFWFRVUkVfTUFHX0ZJTFRFUiA9IDB4MjgwMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFRFWFRVUkVfTUlOX0ZJTFRFUiA9IDB4MjgwMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFRFWFRVUkVfV1JBUF9TID0gMHgyODAyO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVEVYVFVSRV9XUkFQX1QgPSAweDI4MDM7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBURVhUVVJFXzJEID0gMHgwREUxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVEVYVFVSRTAgPSAweDg0QzA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFNUF9UT19FREdFID0gMHg4MTJGO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQ09NUElMRV9TVEFUVVMgPSAweDhCODE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBGUkFNRUJVRkZFUiA9IDB4OEQ0MDtcblxuXG4vKiogZW5kIG9mIGdvb2cud2ViZ2wgY29uc3RhbnRzXG4gKi9cblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICovXG5jb25zdCBDT05URVhUX0lEUyA9IFtcbiAgJ2V4cGVyaW1lbnRhbC13ZWJnbCcsXG4gICd3ZWJnbCcsXG4gICd3ZWJraXQtM2QnLFxuICAnbW96LXdlYmdsJ1xuXTtcblxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBDYW52YXMuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9hdHRyaWJ1dGVzIEF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJ1dGVzKSB7XG4gIGNvbnN0IGlpID0gQ09OVEVYVF9JRFMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlpOyArK2kpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KENPTlRFWFRfSURTW2ldLCBvcHRfYXR0cmlidXRlcyk7XG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHshV2ViR0xSZW5kZXJpbmdDb250ZXh0fSAqLyAoY29udGV4dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gcGFzc1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMC4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBmYW1pbGllcztcblxuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpY29uOiAnaWNvbnMvZ29vZ2xlLnN2ZycsXG4gICAgbmFtZTogJ2dvb2dsZScsXG4gICAgdGl0bGU6ICdHb29nbGUgRm9udHMnLFxuICAgIGxpbms6ICdnb29nbGUuY29tL2ZvbnRzJyxcbiAgICBnZXROYW1lczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFtaWxpZXM7XG4gICAgfSxcbiAgICBnZXRMaW5rOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gXCJodHRwczovL2ZvbnRzLmdvb2dsZS5jb20vc3BlY2ltZW4vXCIgKyAobmFtZS5yZXBsYWNlKC8oICkvZywgJysnKSk7XG4gICAgfSxcbiAgICBub3JtYWxpemVOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH07XG5cbiAgZmFtaWxpZXMgPSBbXCJBQmVlWmVlXCIsIFwiQWJlbFwiLCBcIkFicmlsIEZhdGZhY2VcIiwgXCJBY2xvbmljYVwiLCBcIkFjbWVcIiwgXCJBY3RvclwiLCBcIkFkYW1pbmFcIiwgXCJBZHZlbnQgUHJvXCIsIFwiQWd1YWZpbmEgU2NyaXB0XCIsIFwiQWtyb25pbVwiLCBcIkFsYWRpblwiLCBcIkFsZHJpY2hcIiwgXCJBbGVmXCIsIFwiQWxlZ3JleWFcIiwgXCJBbGVncmV5YSBTQ1wiLCBcIkFsZWdyZXlhIFNhbnNcIiwgXCJBbGVncmV5YSBTYW5zIFNDXCIsIFwiQWxleCBCcnVzaFwiLCBcIkFsZmEgU2xhYiBPbmVcIiwgXCJBbGljZVwiLCBcIkFsaWtlXCIsIFwiQWxpa2UgQW5ndWxhclwiLCBcIkFsbGFuXCIsIFwiQWxsZXJ0YVwiLCBcIkFsbGVydGEgU3RlbmNpbFwiLCBcIkFsbHVyYVwiLCBcIkFsbWVuZHJhXCIsIFwiQWxtZW5kcmEgRGlzcGxheVwiLCBcIkFsbWVuZHJhIFNDXCIsIFwiQW1hcmFudGVcIiwgXCJBbWFyYW50aFwiLCBcIkFtYXRpYyBTQ1wiLCBcIkFtZXRoeXN0YVwiLCBcIkFtaXJpXCIsIFwiQW1pdGFcIiwgXCJBbmFoZWltXCIsIFwiQW5kYWRhXCIsIFwiQW5kaWthXCIsIFwiQW5na29yXCIsIFwiQW5uaWUgVXNlIFlvdXIgVGVsZXNjb3BlXCIsIFwiQW5vbnltb3VzIFByb1wiLCBcIkFudGljXCIsIFwiQW50aWMgRGlkb25lXCIsIFwiQW50aWMgU2xhYlwiLCBcIkFudG9uXCIsIFwiQXJhcGV5XCIsIFwiQXJidXR1c1wiLCBcIkFyYnV0dXMgU2xhYlwiLCBcIkFyY2hpdGVjdHMgRGF1Z2h0ZXJcIiwgXCJBcmNoaXZvIEJsYWNrXCIsIFwiQXJjaGl2byBOYXJyb3dcIiwgXCJBcmltb1wiLCBcIkFyaXpvbmlhXCIsIFwiQXJtYXRhXCIsIFwiQXJ0aWZpa2FcIiwgXCJBcnZvXCIsIFwiQXJ5YVwiLCBcIkFzYXBcIiwgXCJBc2FyXCIsIFwiQXNzZXRcIiwgXCJBc3Rsb2NoXCIsIFwiQXN1bFwiLCBcIkF0b21pYyBBZ2VcIiwgXCJBdWJyZXlcIiwgXCJBdWRpb3dpZGVcIiwgXCJBdXRvdXIgT25lXCIsIFwiQXZlcmFnZVwiLCBcIkF2ZXJhZ2UgU2Fuc1wiLCBcIkF2ZXJpYSBHcnVlc2EgTGlicmVcIiwgXCJBdmVyaWEgTGlicmVcIiwgXCJBdmVyaWEgU2FucyBMaWJyZVwiLCBcIkF2ZXJpYSBTZXJpZiBMaWJyZVwiLCBcIkJhZCBTY3JpcHRcIiwgXCJCYWx0aGF6YXJcIiwgXCJCYW5nZXJzXCIsIFwiQmFzaWNcIiwgXCJCYXR0YW1iYW5nXCIsIFwiQmF1bWFuc1wiLCBcIkJheW9uXCIsIFwiQmVsZ3Jhbm9cIiwgXCJCZWxsZXphXCIsIFwiQmVuY2hOaW5lXCIsIFwiQmVudGhhbVwiLCBcIkJlcmtzaGlyZSBTd2FzaFwiLCBcIkJldmFuXCIsIFwiQmlnZWxvdyBSdWxlc1wiLCBcIkJpZ3Nob3QgT25lXCIsIFwiQmlsYm9cIiwgXCJCaWxibyBTd2FzaCBDYXBzXCIsIFwiQmlyeWFuaVwiLCBcIkJpdHRlclwiLCBcIkJsYWNrIE9wcyBPbmVcIiwgXCJCb2tvclwiLCBcIkJvbmJvblwiLCBcIkJvb2dhbG9vXCIsIFwiQm93bGJ5IE9uZVwiLCBcIkJvd2xieSBPbmUgU0NcIiwgXCJCcmF3bGVyXCIsIFwiQnJlZSBTZXJpZlwiLCBcIkJ1YmJsZWd1bSBTYW5zXCIsIFwiQnViYmxlciBPbmVcIiwgXCJCdWRhXCIsIFwiQnVlbmFyZFwiLCBcIkJ1dGNoZXJtYW5cIiwgXCJCdXR0ZXJmbHkgS2lkc1wiLCBcIkNhYmluXCIsIFwiQ2FiaW4gQ29uZGVuc2VkXCIsIFwiQ2FiaW4gU2tldGNoXCIsIFwiQ2Flc2FyIERyZXNzaW5nXCIsIFwiQ2FnbGlvc3Ryb1wiLCBcIkNhbGxpZ3JhZmZpdHRpXCIsIFwiQ2FtYmF5XCIsIFwiQ2FtYm9cIiwgXCJDYW5kYWxcIiwgXCJDYW50YXJlbGxcIiwgXCJDYW50YXRhIE9uZVwiLCBcIkNhbnRvcmEgT25lXCIsIFwiQ2FwcmlvbGFcIiwgXCJDYXJkb1wiLCBcIkNhcm1lXCIsIFwiQ2Fycm9pcyBHb3RoaWNcIiwgXCJDYXJyb2lzIEdvdGhpYyBTQ1wiLCBcIkNhcnRlciBPbmVcIiwgXCJDYXRhbWFyYW5cIiwgXCJDYXVkZXhcIiwgXCJDYXZlYXRcIiwgXCJDYXZlYXQgQnJ1c2hcIiwgXCJDZWRhcnZpbGxlIEN1cnNpdmVcIiwgXCJDZXZpY2hlIE9uZVwiLCBcIkNoYW5nYSBPbmVcIiwgXCJDaGFuZ29cIiwgXCJDaGF1IFBoaWxvbWVuZSBPbmVcIiwgXCJDaGVsYSBPbmVcIiwgXCJDaGVsc2VhIE1hcmtldFwiLCBcIkNoZW5sYVwiLCBcIkNoZXJyeSBDcmVhbSBTb2RhXCIsIFwiQ2hlcnJ5IFN3YXNoXCIsIFwiQ2hld3lcIiwgXCJDaGljbGVcIiwgXCJDaGl2b1wiLCBcIkNob25idXJpXCIsIFwiQ2luemVsXCIsIFwiQ2luemVsIERlY29yYXRpdmVcIiwgXCJDbGlja2VyIFNjcmlwdFwiLCBcIkNvZGFcIiwgXCJDb2RhIENhcHRpb25cIiwgXCJDb2R5c3RhclwiLCBcIkNvbWJvXCIsIFwiQ29tZm9ydGFhXCIsIFwiQ29taW5nIFNvb25cIiwgXCJDb25jZXJ0IE9uZVwiLCBcIkNvbmRpbWVudFwiLCBcIkNvbnRlbnRcIiwgXCJDb250cmFpbCBPbmVcIiwgXCJDb252ZXJnZW5jZVwiLCBcIkNvb2tpZVwiLCBcIkNvcHNlXCIsIFwiQ29yYmVuXCIsIFwiQ291cmdldHRlXCIsIFwiQ291c2luZVwiLCBcIkNvdXN0YXJkXCIsIFwiQ292ZXJlZCBCeSBZb3VyIEdyYWNlXCIsIFwiQ3JhZnR5IEdpcmxzXCIsIFwiQ3JlZXBzdGVyXCIsIFwiQ3JldGUgUm91bmRcIiwgXCJDcmltc29uIFRleHRcIiwgXCJDcm9pc3NhbnQgT25lXCIsIFwiQ3J1c2hlZFwiLCBcIkN1cHJ1bVwiLCBcIkN1dGl2ZVwiLCBcIkN1dGl2ZSBNb25vXCIsIFwiRGFtaW9uXCIsIFwiRGFuY2luZyBTY3JpcHRcIiwgXCJEYW5ncmVrXCIsIFwiRGF3bmluZyBvZiBhIE5ldyBEYXlcIiwgXCJEYXlzIE9uZVwiLCBcIkRla2tvXCIsIFwiRGVsaXVzXCIsIFwiRGVsaXVzIFN3YXNoIENhcHNcIiwgXCJEZWxpdXMgVW5pY2FzZVwiLCBcIkRlbGxhIFJlc3BpcmFcIiwgXCJEZW5rIE9uZVwiLCBcIkRldm9uc2hpcmVcIiwgXCJEaHVyamF0aVwiLCBcIkRpZGFjdCBHb3RoaWNcIiwgXCJEaXBsb21hdGFcIiwgXCJEaXBsb21hdGEgU0NcIiwgXCJEb21pbmVcIiwgXCJEb25lZ2FsIE9uZVwiLCBcIkRvcHBpbyBPbmVcIiwgXCJEb3JzYVwiLCBcIkRvc2lzXCIsIFwiRHIgU3VnaXlhbWFcIiwgXCJEcm9pZCBTYW5zXCIsIFwiRHJvaWQgU2FucyBNb25vXCIsIFwiRHJvaWQgU2VyaWZcIiwgXCJEdXJ1IFNhbnNcIiwgXCJEeW5hbGlnaHRcIiwgXCJFQiBHYXJhbW9uZFwiLCBcIkVhZ2xlIExha2VcIiwgXCJFYXRlclwiLCBcIkVjb25vbWljYVwiLCBcIkVjemFyXCIsIFwiRWsgTXVrdGFcIiwgXCJFbGVjdHJvbGl6ZVwiLCBcIkVsc2llXCIsIFwiRWxzaWUgU3dhc2ggQ2Fwc1wiLCBcIkVtYmxlbWEgT25lXCIsIFwiRW1pbHlzIENhbmR5XCIsIFwiRW5nYWdlbWVudFwiLCBcIkVuZ2xlYmVydFwiLCBcIkVucmlxdWV0YVwiLCBcIkVyaWNhIE9uZVwiLCBcIkVzdGViYW5cIiwgXCJFdXBob3JpYSBTY3JpcHRcIiwgXCJFd2VydFwiLCBcIkV4b1wiLCBcIkV4byAyXCIsIFwiRXhwbGV0dXMgU2Fuc1wiLCBcIkZhbndvb2QgVGV4dFwiLCBcIkZhc2NpbmF0ZVwiLCBcIkZhc2NpbmF0ZSBJbmxpbmVcIiwgXCJGYXN0ZXIgT25lXCIsIFwiRmFzdGhhbmRcIiwgXCJGYXVuYSBPbmVcIiwgXCJGZWRlcmFudFwiLCBcIkZlZGVyb1wiLCBcIkZlbGlwYVwiLCBcIkZlbml4XCIsIFwiRmluZ2VyIFBhaW50XCIsIFwiRmlyYSBNb25vXCIsIFwiRmlyYSBTYW5zXCIsIFwiRmphbGxhIE9uZVwiLCBcIkZqb3JkIE9uZVwiLCBcIkZsYW1lbmNvXCIsIFwiRmxhdm9yc1wiLCBcIkZvbmRhbWVudG9cIiwgXCJGb250ZGluZXIgU3dhbmt5XCIsIFwiRm9ydW1cIiwgXCJGcmFuY29pcyBPbmVcIiwgXCJGcmVja2xlIEZhY2VcIiwgXCJGcmVkZXJpY2thIHRoZSBHcmVhdFwiLCBcIkZyZWRva2EgT25lXCIsIFwiRnJlZWhhbmRcIiwgXCJGcmVzY2FcIiwgXCJGcmlqb2xlXCIsIFwiRnJ1a3R1clwiLCBcIkZ1Z2F6IE9uZVwiLCBcIkdGUyBEaWRvdFwiLCBcIkdGUyBOZW9oZWxsZW5pY1wiLCBcIkdhYnJpZWxhXCIsIFwiR2FmYXRhXCIsIFwiR2FsZGVhbm9cIiwgXCJHYWxpbmRvXCIsIFwiR2VudGl1bSBCYXNpY1wiLCBcIkdlbnRpdW0gQm9vayBCYXNpY1wiLCBcIkdlb1wiLCBcIkdlb3N0YXJcIiwgXCJHZW9zdGFyIEZpbGxcIiwgXCJHZXJtYW5pYSBPbmVcIiwgXCJHaWR1Z3VcIiwgXCJHaWxkYSBEaXNwbGF5XCIsIFwiR2l2ZSBZb3UgR2xvcnlcIiwgXCJHbGFzcyBBbnRpcXVhXCIsIFwiR2xlZ29vXCIsIFwiR2xvcmlhIEhhbGxlbHVqYWhcIiwgXCJHb2JsaW4gT25lXCIsIFwiR29jaGkgSGFuZFwiLCBcIkdvcmRpdGFzXCIsIFwiR291ZHkgQm9va2xldHRlciAxOTExXCIsIFwiR3JhZHVhdGVcIiwgXCJHcmFuZCBIb3RlbFwiLCBcIkdyYXZpdGFzIE9uZVwiLCBcIkdyZWF0IFZpYmVzXCIsIFwiR3JpZmZ5XCIsIFwiR3J1cHBvXCIsIFwiR3VkZWFcIiwgXCJHdXJhamFkYVwiLCBcIkhhYmliaVwiLCBcIkhhbGFudFwiLCBcIkhhbW1lcnNtaXRoIE9uZVwiLCBcIkhhbmFsZWlcIiwgXCJIYW5hbGVpIEZpbGxcIiwgXCJIYW5kbGVlXCIsIFwiSGFudW1hblwiLCBcIkhhcHB5IE1vbmtleVwiLCBcIkhlYWRsYW5kIE9uZVwiLCBcIkhlbm55IFBlbm55XCIsIFwiSGVyciBWb24gTXVlbGxlcmhvZmZcIiwgXCJIaW5kXCIsIFwiSGluZCBTaWxpZ3VyaVwiLCBcIkhpbmQgVmFkb2RhcmFcIiwgXCJIb2x0d29vZCBPbmUgU0NcIiwgXCJIb21lbWFkZSBBcHBsZVwiLCBcIkhvbWVuYWplXCIsIFwiSU0gRmVsbCBEVyBQaWNhXCIsIFwiSU0gRmVsbCBEVyBQaWNhIFNDXCIsIFwiSU0gRmVsbCBEb3VibGUgUGljYVwiLCBcIklNIEZlbGwgRG91YmxlIFBpY2EgU0NcIiwgXCJJTSBGZWxsIEVuZ2xpc2hcIiwgXCJJTSBGZWxsIEVuZ2xpc2ggU0NcIiwgXCJJTSBGZWxsIEZyZW5jaCBDYW5vblwiLCBcIklNIEZlbGwgRnJlbmNoIENhbm9uIFNDXCIsIFwiSU0gRmVsbCBHcmVhdCBQcmltZXJcIiwgXCJJTSBGZWxsIEdyZWF0IFByaW1lciBTQ1wiLCBcIkljZWJlcmdcIiwgXCJJY2VsYW5kXCIsIFwiSW1wcmltYVwiLCBcIkluY29uc29sYXRhXCIsIFwiSW5kZXJcIiwgXCJJbmRpZSBGbG93ZXJcIiwgXCJJbmlrYVwiLCBcIklua251dCBBbnRpcXVhXCIsIFwiSXJpc2ggR3JvdmVyXCIsIFwiSXN0b2sgV2ViXCIsIFwiSXRhbGlhbmFcIiwgXCJJdGFsaWFubm9cIiwgXCJJdGltXCIsIFwiSmFjcXVlcyBGcmFuY29pc1wiLCBcIkphY3F1ZXMgRnJhbmNvaXMgU2hhZG93XCIsIFwiSmFsZGlcIiwgXCJKaW0gTmlnaHRzaGFkZVwiLCBcIkpvY2tleSBPbmVcIiwgXCJKb2xseSBMb2RnZXJcIiwgXCJKb3NlZmluIFNhbnNcIiwgXCJKb3NlZmluIFNsYWJcIiwgXCJKb3RpIE9uZVwiLCBcIkp1ZHNvblwiLCBcIkp1bGVlXCIsIFwiSnVsaXVzIFNhbnMgT25lXCIsIFwiSnVuZ2VcIiwgXCJKdXJhXCIsIFwiSnVzdCBBbm90aGVyIEhhbmRcIiwgXCJKdXN0IE1lIEFnYWluIERvd24gSGVyZVwiLCBcIkthZHdhXCIsIFwiS2FsYW1cIiwgXCJLYW1lcm9uXCIsIFwiS2FudHVtcnV5XCIsIFwiS2FybGFcIiwgXCJLYXJtYVwiLCBcIkthdXNoYW4gU2NyaXB0XCIsIFwiS2F2b29uXCIsIFwiS2RhbSBUaG1vclwiLCBcIktlYW5pYSBPbmVcIiwgXCJLZWxseSBTbGFiXCIsIFwiS2VuaWFcIiwgXCJLaGFuZFwiLCBcIktobWVyXCIsIFwiS2h1bGFcIiwgXCJLaXRlIE9uZVwiLCBcIktuZXdhdmVcIiwgXCJLb3R0YSBPbmVcIiwgXCJLb3VsZW5cIiwgXCJLcmFua3lcIiwgXCJLcmVvblwiLCBcIktyaXN0aVwiLCBcIktyb25hIE9uZVwiLCBcIkt1cmFsZVwiLCBcIkxhIEJlbGxlIEF1cm9yZVwiLCBcIkxhaWxhXCIsIFwiTGFra2kgUmVkZHlcIiwgXCJMYW5jZWxvdFwiLCBcIkxhdGVlZlwiLCBcIkxhdG9cIiwgXCJMZWFndWUgU2NyaXB0XCIsIFwiTGVja2VybGkgT25lXCIsIFwiTGVkZ2VyXCIsIFwiTGVrdG9uXCIsIFwiTGVtb25cIiwgXCJMaWJyZSBCYXNrZXJ2aWxsZVwiLCBcIkxpZmUgU2F2ZXJzXCIsIFwiTGlsaXRhIE9uZVwiLCBcIkxpbHkgU2NyaXB0IE9uZVwiLCBcIkxpbWVsaWdodFwiLCBcIkxpbmRlbiBIaWxsXCIsIFwiTG9ic3RlclwiLCBcIkxvYnN0ZXIgVHdvXCIsIFwiTG9uZHJpbmEgT3V0bGluZVwiLCBcIkxvbmRyaW5hIFNoYWRvd1wiLCBcIkxvbmRyaW5hIFNrZXRjaFwiLCBcIkxvbmRyaW5hIFNvbGlkXCIsIFwiTG9yYVwiLCBcIkxvdmUgWWEgTGlrZSBBIFNpc3RlclwiLCBcIkxvdmVkIGJ5IHRoZSBLaW5nXCIsIFwiTG92ZXJzIFF1YXJyZWxcIiwgXCJMdWNraWVzdCBHdXlcIiwgXCJMdXNpdGFuYVwiLCBcIkx1c3RyaWFcIiwgXCJNYWNvbmRvXCIsIFwiTWFjb25kbyBTd2FzaCBDYXBzXCIsIFwiTWFncmFcIiwgXCJNYWlkZW4gT3JhbmdlXCIsIFwiTWFrb1wiLCBcIk1hbGxhbm5hXCIsIFwiTWFuZGFsaVwiLCBcIk1hcmNlbGx1c1wiLCBcIk1hcmNlbGx1cyBTQ1wiLCBcIk1hcmNrIFNjcmlwdFwiLCBcIk1hcmdhcmluZVwiLCBcIk1hcmtvIE9uZVwiLCBcIk1hcm1lbGFkXCIsIFwiTWFydGVsXCIsIFwiTWFydGVsIFNhbnNcIiwgXCJNYXJ2ZWxcIiwgXCJNYXRlXCIsIFwiTWF0ZSBTQ1wiLCBcIk1hdmVuIFByb1wiLCBcIk1jTGFyZW5cIiwgXCJNZWRkb25cIiwgXCJNZWRpZXZhbFNoYXJwXCIsIFwiTWVkdWxhIE9uZVwiLCBcIk1lZ3JpbVwiLCBcIk1laWUgU2NyaXB0XCIsIFwiTWVyaWVuZGFcIiwgXCJNZXJpZW5kYSBPbmVcIiwgXCJNZXJyaXdlYXRoZXJcIiwgXCJNZXJyaXdlYXRoZXIgU2Fuc1wiLCBcIk1ldGFsXCIsIFwiTWV0YWwgTWFuaWFcIiwgXCJNZXRhbW9ycGhvdXNcIiwgXCJNZXRyb3Bob2JpY1wiLCBcIk1pY2hyb21hXCIsIFwiTWlsb25nYVwiLCBcIk1pbHRvbmlhblwiLCBcIk1pbHRvbmlhbiBUYXR0b29cIiwgXCJNaW5pdmVyXCIsIFwiTWlzcyBGYWphcmRvc2VcIiwgXCJNb2Rha1wiLCBcIk1vZGVybiBBbnRpcXVhXCIsIFwiTW9sZW5nb1wiLCBcIk1vbGxlXCIsIFwiTW9uZGFcIiwgXCJNb25vZmV0dFwiLCBcIk1vbm90b25cIiwgXCJNb25zaWV1ciBMYSBEb3VsYWlzZVwiLCBcIk1vbnRhZ2FcIiwgXCJNb250ZXpcIiwgXCJNb250c2VycmF0XCIsIFwiTW9udHNlcnJhdCBBbHRlcm5hdGVzXCIsIFwiTW9udHNlcnJhdCBTdWJyYXlhZGFcIiwgXCJNb3VsXCIsIFwiTW91bHBhbGlcIiwgXCJNb3VudGFpbnMgb2YgQ2hyaXN0bWFzXCIsIFwiTW91c2UgTWVtb2lyc1wiLCBcIk1yIEJlZGZvcnRcIiwgXCJNciBEYWZvZVwiLCBcIk1yIERlIEhhdmlsYW5kXCIsIFwiTXJzIFNhaW50IERlbGFmaWVsZFwiLCBcIk1ycyBTaGVwcGFyZHNcIiwgXCJNdWxpXCIsIFwiTXlzdGVyeSBRdWVzdFwiLCBcIk5UUlwiLCBcIk5ldWNoYVwiLCBcIk5ldXRvblwiLCBcIk5ldyBSb2NrZXJcIiwgXCJOZXdzIEN5Y2xlXCIsIFwiTmljb25uZVwiLCBcIk5peGllIE9uZVwiLCBcIk5vYmlsZVwiLCBcIk5va29yYVwiLCBcIk5vcmljYW5cIiwgXCJOb3NpZmVyXCIsIFwiTm90aGluZyBZb3UgQ291bGQgRG9cIiwgXCJOb3RpY2lhIFRleHRcIiwgXCJOb3RvIFNhbnNcIiwgXCJOb3RvIFNlcmlmXCIsIFwiTm92YSBDdXRcIiwgXCJOb3ZhIEZsYXRcIiwgXCJOb3ZhIE1vbm9cIiwgXCJOb3ZhIE92YWxcIiwgXCJOb3ZhIFJvdW5kXCIsIFwiTm92YSBTY3JpcHRcIiwgXCJOb3ZhIFNsaW1cIiwgXCJOb3ZhIFNxdWFyZVwiLCBcIk51bWFuc1wiLCBcIk51bml0b1wiLCBcIk9kb3IgTWVhbiBDaGV5XCIsIFwiT2Zmc2lkZVwiLCBcIk9sZCBTdGFuZGFyZCBUVFwiLCBcIk9sZGVuYnVyZ1wiLCBcIk9sZW8gU2NyaXB0XCIsIFwiT2xlbyBTY3JpcHQgU3dhc2ggQ2Fwc1wiLCBcIk9wZW4gU2Fuc1wiLCBcIk9wZW4gU2FucyBDb25kZW5zZWRcIiwgXCJPcmFuaWVuYmF1bVwiLCBcIk9yYml0cm9uXCIsIFwiT3JlZ2Fub1wiLCBcIk9yaWVudGFcIiwgXCJPcmlnaW5hbCBTdXJmZXJcIiwgXCJPc3dhbGRcIiwgXCJPdmVyIHRoZSBSYWluYm93XCIsIFwiT3ZlcmxvY2tcIiwgXCJPdmVybG9jayBTQ1wiLCBcIk92b1wiLCBcIk94eWdlblwiLCBcIk94eWdlbiBNb25vXCIsIFwiUFQgTW9ub1wiLCBcIlBUIFNhbnNcIiwgXCJQVCBTYW5zIENhcHRpb25cIiwgXCJQVCBTYW5zIE5hcnJvd1wiLCBcIlBUIFNlcmlmXCIsIFwiUFQgU2VyaWYgQ2FwdGlvblwiLCBcIlBhY2lmaWNvXCIsIFwiUGFsYW5xdWluXCIsIFwiUGFsYW5xdWluIERhcmtcIiwgXCJQYXByaWthXCIsIFwiUGFyaXNpZW5uZVwiLCBcIlBhc3Nlcm8gT25lXCIsIFwiUGFzc2lvbiBPbmVcIiwgXCJQYXRod2F5IEdvdGhpYyBPbmVcIiwgXCJQYXRyaWNrIEhhbmRcIiwgXCJQYXRyaWNrIEhhbmQgU0NcIiwgXCJQYXR1YSBPbmVcIiwgXCJQYXl0b25lIE9uZVwiLCBcIlBlZGRhbmFcIiwgXCJQZXJhbHRhXCIsIFwiUGVybWFuZW50IE1hcmtlclwiLCBcIlBldGl0IEZvcm1hbCBTY3JpcHRcIiwgXCJQZXRyb25hXCIsIFwiUGhpbG9zb3BoZXJcIiwgXCJQaWVkcmFcIiwgXCJQaW55b24gU2NyaXB0XCIsIFwiUGlyYXRhIE9uZVwiLCBcIlBsYXN0ZXJcIiwgXCJQbGF5XCIsIFwiUGxheWJhbGxcIiwgXCJQbGF5ZmFpciBEaXNwbGF5XCIsIFwiUGxheWZhaXIgRGlzcGxheSBTQ1wiLCBcIlBvZGtvdmFcIiwgXCJQb2lyZXQgT25lXCIsIFwiUG9sbGVyIE9uZVwiLCBcIlBvbHlcIiwgXCJQb21waWVyZVwiLCBcIlBvbnRhbm8gU2Fuc1wiLCBcIlBvcHBpbnNcIiwgXCJQb3J0IExsaWdhdCBTYW5zXCIsIFwiUG9ydCBMbGlnYXQgU2xhYlwiLCBcIlByYWdhdGkgTmFycm93XCIsIFwiUHJhdGFcIiwgXCJQcmVhaHZpaGVhclwiLCBcIlByZXNzIFN0YXJ0IDJQXCIsIFwiUHJpbmNlc3MgU29maWFcIiwgXCJQcm9jaW9ub1wiLCBcIlByb3N0byBPbmVcIiwgXCJQdXJpdGFuXCIsIFwiUHVycGxlIFB1cnNlXCIsIFwiUXVhbmRvXCIsIFwiUXVhbnRpY29cIiwgXCJRdWF0dHJvY2VudG9cIiwgXCJRdWF0dHJvY2VudG8gU2Fuc1wiLCBcIlF1ZXN0cmlhbFwiLCBcIlF1aWNrc2FuZFwiLCBcIlF1aW50ZXNzZW50aWFsXCIsIFwiUXdpZ2xleVwiLCBcIlJhY2luZyBTYW5zIE9uZVwiLCBcIlJhZGxleVwiLCBcIlJhamRoYW5pXCIsIFwiUmFsZXdheVwiLCBcIlJhbGV3YXkgRG90c1wiLCBcIlJhbWFiaGFkcmFcIiwgXCJSYW1hcmFqYVwiLCBcIlJhbWJsYVwiLCBcIlJhbW1ldHRvIE9uZVwiLCBcIlJhbmNoZXJzXCIsIFwiUmFuY2hvXCIsIFwiUmFuZ2FcIiwgXCJSYXRpb25hbGVcIiwgXCJSYXZpIFByYWthc2hcIiwgXCJSZWRyZXNzZWRcIiwgXCJSZWVuaWUgQmVhbmllXCIsIFwiUmV2YWxpYVwiLCBcIlJob2RpdW0gTGlicmVcIiwgXCJSaWJleWVcIiwgXCJSaWJleWUgTWFycm93XCIsIFwiUmlnaHRlb3VzXCIsIFwiUmlzcXVlXCIsIFwiUm9ib3RvXCIsIFwiUm9ib3RvIENvbmRlbnNlZFwiLCBcIlJvYm90byBNb25vXCIsIFwiUm9ib3RvIFNsYWJcIiwgXCJSb2NoZXN0ZXJcIiwgXCJSb2NrIFNhbHRcIiwgXCJSb2traXR0XCIsIFwiUm9tYW5lc2NvXCIsIFwiUm9wYSBTYW5zXCIsIFwiUm9zYXJpb1wiLCBcIlJvc2FyaXZvXCIsIFwiUm91Z2UgU2NyaXB0XCIsIFwiUm96aGEgT25lXCIsIFwiUnViaWtcIiwgXCJSdWJpayBNb25vIE9uZVwiLCBcIlJ1YmlrIE9uZVwiLCBcIlJ1ZGFcIiwgXCJSdWZpbmFcIiwgXCJSdWdlIEJvb2dpZVwiLCBcIlJ1bHVrb1wiLCBcIlJ1bSBSYWlzaW5cIiwgXCJSdXNsYW4gRGlzcGxheVwiLCBcIlJ1c3NvIE9uZVwiLCBcIlJ1dGhpZVwiLCBcIlJ5ZVwiLCBcIlNhY3JhbWVudG9cIiwgXCJTYWhpdHlhXCIsIFwiU2FpbFwiLCBcIlNhbHNhXCIsIFwiU2FuY2hlelwiLCBcIlNhbmNyZWVrXCIsIFwiU2Fuc2l0YSBPbmVcIiwgXCJTYXJhbGFcIiwgXCJTYXJpbmFcIiwgXCJTYXJwYW5jaFwiLCBcIlNhdGlzZnlcIiwgXCJTY2FkYVwiLCBcIlNjaGVoZXJhemFkZVwiLCBcIlNjaG9vbGJlbGxcIiwgXCJTZWF3ZWVkIFNjcmlwdFwiLCBcIlNldmlsbGFuYVwiLCBcIlNleW1vdXIgT25lXCIsIFwiU2hhZG93cyBJbnRvIExpZ2h0XCIsIFwiU2hhZG93cyBJbnRvIExpZ2h0IFR3b1wiLCBcIlNoYW50aVwiLCBcIlNoYXJlXCIsIFwiU2hhcmUgVGVjaFwiLCBcIlNoYXJlIFRlY2ggTW9ub1wiLCBcIlNob2p1bWFydVwiLCBcIlNob3J0IFN0YWNrXCIsIFwiU2llbXJlYXBcIiwgXCJTaWdtYXIgT25lXCIsIFwiU2lnbmlrYVwiLCBcIlNpZ25pa2EgTmVnYXRpdmVcIiwgXCJTaW1vbmV0dGFcIiwgXCJTaW50b255XCIsIFwiU2lyaW4gU3RlbmNpbFwiLCBcIlNpeCBDYXBzXCIsIFwiU2tyYW5qaVwiLCBcIlNsYWJvIDEzcHhcIiwgXCJTbGFibyAyN3B4XCIsIFwiU2xhY2tleVwiLCBcIlNtb2t1bVwiLCBcIlNteXRoZVwiLCBcIlNuaWdsZXRcIiwgXCJTbmlwcGV0XCIsIFwiU25vd2J1cnN0IE9uZVwiLCBcIlNvZmFkaSBPbmVcIiwgXCJTb2ZpYVwiLCBcIlNvbnNpZSBPbmVcIiwgXCJTb3J0cyBNaWxsIEdvdWR5XCIsIFwiU291cmNlIENvZGUgUHJvXCIsIFwiU291cmNlIFNhbnMgUHJvXCIsIFwiU291cmNlIFNlcmlmIFByb1wiLCBcIlNwZWNpYWwgRWxpdGVcIiwgXCJTcGljeSBSaWNlXCIsIFwiU3Bpbm5ha2VyXCIsIFwiU3BpcmF4XCIsIFwiU3F1YWRhIE9uZVwiLCBcIlNyZWUgS3J1c2huYWRldmFyYXlhXCIsIFwiU3RhbGVtYXRlXCIsIFwiU3RhbGluaXN0IE9uZVwiLCBcIlN0YXJkb3MgU3RlbmNpbFwiLCBcIlN0aW50IFVsdHJhIENvbmRlbnNlZFwiLCBcIlN0aW50IFVsdHJhIEV4cGFuZGVkXCIsIFwiU3Rva2VcIiwgXCJTdHJhaXRcIiwgXCJTdWUgRWxsZW4gRnJhbmNpc2NvXCIsIFwiU3VtYW5hXCIsIFwiU3Vuc2hpbmV5XCIsIFwiU3VwZXJtZXJjYWRvIE9uZVwiLCBcIlN1cmFcIiwgXCJTdXJhbm5hXCIsIFwiU3VyYXZhcmFtXCIsIFwiU3V3YW5uYXBodW1cIiwgXCJTd2Fua3kgYW5kIE1vbyBNb29cIiwgXCJTeW5jb3BhdGVcIiwgXCJUYW5nZXJpbmVcIiwgXCJUYXByb21cIiwgXCJUYXVyaVwiLCBcIlRla29cIiwgXCJUZWxleFwiLCBcIlRlbmFsaSBSYW1ha3Jpc2huYVwiLCBcIlRlbm9yIFNhbnNcIiwgXCJUZXh0IE1lIE9uZVwiLCBcIlRoZSBHaXJsIE5leHQgRG9vclwiLCBcIlRpZW5uZVwiLCBcIlRpbGxhbmFcIiwgXCJUaW1tYW5hXCIsIFwiVGlub3NcIiwgXCJUaXRhbiBPbmVcIiwgXCJUaXRpbGxpdW0gV2ViXCIsIFwiVHJhZGUgV2luZHNcIiwgXCJUcm9jY2hpXCIsIFwiVHJvY2h1dFwiLCBcIlRyeWtrZXJcIiwgXCJUdWxwZW4gT25lXCIsIFwiVWJ1bnR1XCIsIFwiVWJ1bnR1IENvbmRlbnNlZFwiLCBcIlVidW50dSBNb25vXCIsIFwiVWx0cmFcIiwgXCJVbmNpYWwgQW50aXF1YVwiLCBcIlVuZGVyZG9nXCIsIFwiVW5pY2EgT25lXCIsIFwiVW5pZnJha3R1ckNvb2tcIiwgXCJVbmlmcmFrdHVyTWFndW50aWFcIiwgXCJVbmtlbXB0XCIsIFwiVW5sb2NrXCIsIFwiVW5uYVwiLCBcIlZUMzIzXCIsIFwiVmFtcGlybyBPbmVcIiwgXCJWYXJlbGFcIiwgXCJWYXJlbGEgUm91bmRcIiwgXCJWYXN0IFNoYWRvd1wiLCBcIlZlc3BlciBMaWJyZVwiLCBcIlZpYnVyXCIsIFwiVmlkYWxva2FcIiwgXCJWaWdhXCIsIFwiVm9jZXNcIiwgXCJWb2xraG92XCIsIFwiVm9sbGtvcm5cIiwgXCJWb2x0YWlyZVwiLCBcIldhaXRpbmcgZm9yIHRoZSBTdW5yaXNlXCIsIFwiV2FsbHBvZXRcIiwgXCJXYWx0ZXIgVHVybmNvYXRcIiwgXCJXYXJuZXNcIiwgXCJXZWxsZmxlZXRcIiwgXCJXZW5keSBPbmVcIiwgXCJXaXJlIE9uZVwiLCBcIldvcmsgU2Fuc1wiLCBcIllhbm9uZSBLYWZmZWVzYXR6XCIsIFwiWWFudHJhbWFuYXZcIiwgXCJZZWxsb3d0YWlsXCIsIFwiWWVzZXZhIE9uZVwiLCBcIlllc3RlcnllYXJcIiwgXCJaZXlhZGFcIl07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJpbXBvcnQge2FwcGx5LCBhcHBseUJhY2tncm91bmQsIGFwcGx5U3R5bGV9IGZyb20gJy4vaW5kZXgnO1xyXG5pbXBvcnQgc3R5bGVmdW5jdGlvbiBmcm9tICcuL3N0eWxlZnVuY3Rpb24nO1xyXG5cclxuY29uc3Qgb2xtcyA9IHtcclxuICBhcHBseTogYXBwbHksXHJcbiAgYXBwbHlCYWNrZ3JvdW5kOiBhcHBseUJhY2tncm91bmQsXHJcbiAgYXBwbHlTdHlsZTogYXBwbHlTdHlsZSxcclxuICBzdHlsZWZ1bmN0aW9uOiBzdHlsZWZ1bmN0aW9uXHJcbn07XHJcbmlmICh3aW5kb3cpIHtcclxuICB3aW5kb3cub2xtcyA9IG9sbXM7XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgb2xtcztcclxuXHJcbiIsIi8qXHJcbm9sLW1hcGJveC1zdHlsZSAtIFVzZSBNYXBib3ggU3R5bGUgb2JqZWN0cyB3aXRoIE9wZW5MYXllcnNcclxuQ29weXJpZ2h0IDIwMTYtcHJlc2VudCBCb3VuZGxlc3MgU3BhdGlhbCwgSW5jLlxyXG5MaWNlbnNlOiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYm91bmRsZXNzZ2VvL29sLW1hcGJveC1nbC1zdHlsZS9tYXN0ZXIvTElDRU5TRVxyXG4qL1xyXG5cclxuaW1wb3J0IFN0eWxlIGZyb20gJ29sL3N0eWxlL1N0eWxlJztcclxuaW1wb3J0IEZpbGwgZnJvbSAnb2wvc3R5bGUvRmlsbCc7XHJcbmltcG9ydCBTdHJva2UgZnJvbSAnb2wvc3R5bGUvU3Ryb2tlJztcclxuaW1wb3J0IEljb24gZnJvbSAnb2wvc3R5bGUvSWNvbic7XHJcbmltcG9ydCBUZXh0IGZyb20gJ29sL3N0eWxlL1RleHQnO1xyXG5pbXBvcnQgQ2lyY2xlIGZyb20gJ29sL3N0eWxlL0NpcmNsZSc7XHJcbmltcG9ydCBQb2ludCBmcm9tICdvbC9nZW9tL1BvaW50JztcclxuaW1wb3J0IHtkZXJlZkxheWVyc30gZnJvbSAnQG1hcGJveC9tYXBib3gtZ2wtc3R5bGUtc3BlYyc7XHJcbmltcG9ydCB7XHJcbiAgZXhwcmVzc2lvbiwgQ29sb3IsXHJcbiAgZnVuY3Rpb24gYXMgZm4sXHJcbiAgbGF0ZXN0IGFzIHNwZWMsXHJcbiAgZmVhdHVyZUZpbHRlciBhcyBjcmVhdGVGaWx0ZXJcclxufSBmcm9tICdAbWFwYm94L21hcGJveC1nbC1zdHlsZS1zcGVjJztcclxuaW1wb3J0IG1iMmNzcyBmcm9tICdtYXBib3gtdG8tY3NzLWZvbnQnO1xyXG5pbXBvcnQge1xyXG4gIGRlZzJyYWQsXHJcbiAgZ2V0Wm9vbUZvclJlc29sdXRpb25cclxufSBmcm9tICcuL3V0aWwnO1xyXG5cclxuXHJcbmNvbnN0IGlzRnVuY3Rpb24gPSBmbi5pc0Z1bmN0aW9uO1xyXG5jb25zdCBjb252ZXJ0RnVuY3Rpb24gPSBmbi5jb252ZXJ0RnVuY3Rpb247XHJcbmNvbnN0IGlzRXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uaXNFeHByZXNzaW9uO1xyXG5jb25zdCBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24gPSBleHByZXNzaW9uLmNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbjtcclxuXHJcbmNvbnN0IHR5cGVzID0ge1xyXG4gICdQb2ludCc6IDEsXHJcbiAgJ011bHRpUG9pbnQnOiAxLFxyXG4gICdMaW5lU3RyaW5nJzogMixcclxuICAnTXVsdGlMaW5lU3RyaW5nJzogMixcclxuICAnUG9seWdvbic6IDMsXHJcbiAgJ011bHRpUG9seWdvbic6IDNcclxufTtcclxuY29uc3QgZXhwcmVzc2lvbkRhdGEgPSBmdW5jdGlvbihyYXdFeHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHtcclxuICBjb25zdCBjb21waWxlZEV4cHJlc3Npb24gPSBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24ocmF3RXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKTtcclxuICBpZiAoY29tcGlsZWRFeHByZXNzaW9uLnJlc3VsdCA9PT0gJ2Vycm9yJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGNvbXBpbGVkRXhwcmVzc2lvbi52YWx1ZS5tYXAoZXJyID0+IGAke2Vyci5rZXl9OiAke2Vyci5tZXNzYWdlfWApLmpvaW4oJywgJykpO1xyXG4gIH1cclxuICByZXR1cm4gY29tcGlsZWRFeHByZXNzaW9uLnZhbHVlO1xyXG59O1xyXG5cclxuY29uc3QgZW1wdHlPYmogPSB7fTtcclxuY29uc3Qgem9vbU9iaiA9IHt6b29tOiAwfTtcclxuY29uc3QgZnVuY3Rpb25DYWNoZSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBHbCBvYmplY3QgbGF5ZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYXlvdXRPclBhaW50ICdsYXlvdXQnIG9yICdwYWludCcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBGZWF0dXJlIHByb3BlcnR5LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZSBHbCBmZWF0dXJlLlxyXG4gKiBAcmV0dXJuIHs/fSBWYWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZShsYXllciwgbGF5b3V0T3JQYWludCwgcHJvcGVydHksIHpvb20sIGZlYXR1cmUpIHtcclxuICBjb25zdCBsYXllcklkID0gbGF5ZXIuaWQ7XHJcbiAgaWYgKCFmdW5jdGlvbkNhY2hlW2xheWVySWRdKSB7XHJcbiAgICBmdW5jdGlvbkNhY2hlW2xheWVySWRdID0ge307XHJcbiAgfVxyXG4gIGNvbnN0IGZ1bmN0aW9ucyA9IGZ1bmN0aW9uQ2FjaGVbbGF5ZXJJZF07XHJcbiAgaWYgKCFmdW5jdGlvbnNbcHJvcGVydHldKSB7XHJcbiAgICBsZXQgdmFsdWUgPSAobGF5ZXJbbGF5b3V0T3JQYWludF0gfHwgZW1wdHlPYmopW3Byb3BlcnR5XTtcclxuICAgIGNvbnN0IHByb3BlcnR5U3BlYyA9IHNwZWNbYCR7bGF5b3V0T3JQYWludH1fJHtsYXllci50eXBlfWBdW3Byb3BlcnR5XTtcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhbHVlID0gcHJvcGVydHlTcGVjLmRlZmF1bHQ7XHJcbiAgICB9XHJcbiAgICBsZXQgaXNFeHByID0gaXNFeHByZXNzaW9uKCh2YWx1ZSkpO1xyXG4gICAgaWYgKCFpc0V4cHIgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgdmFsdWUgPSBjb252ZXJ0RnVuY3Rpb24odmFsdWUsIHByb3BlcnR5U3BlYyk7XHJcbiAgICAgIGlzRXhwciA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNFeHByKSB7XHJcbiAgICAgIGNvbnN0IGNvbXBpbGVkRXhwcmVzc2lvbiA9IGV4cHJlc3Npb25EYXRhKHZhbHVlLCBwcm9wZXJ0eVNwZWMpO1xyXG4gICAgICBmdW5jdGlvbnNbcHJvcGVydHldID0gY29tcGlsZWRFeHByZXNzaW9uLmV2YWx1YXRlLmJpbmQoY29tcGlsZWRFeHByZXNzaW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PSAnY29sb3InKSB7XHJcbiAgICAgICAgdmFsdWUgPSBDb2xvci5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb25zW3Byb3BlcnR5XSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbiAgem9vbU9iai56b29tID0gem9vbTtcclxuICByZXR1cm4gZnVuY3Rpb25zW3Byb3BlcnR5XSh6b29tT2JqLCBmZWF0dXJlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY292ZXJ0SWNvbkFuY2hvcihpY29uQW5jaG9yKSB7XHJcbiAgbGV0IGFuY2hvck9mZnNldCA9IFswLjUsIDAuNV07XHJcbiAgaWYgKFsndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCddLmluZGV4T2YoaWNvbkFuY2hvcikgPiAtMSkge1xyXG4gICAgYW5jaG9yT2Zmc2V0ID0gWzAsIDBdO1xyXG4gIH1cclxuICBpZiAoaWNvbkFuY2hvciA9PT0gJ2xlZnQnKSB7XHJcbiAgICBpY29uQW5jaG9yID0gJ3RvcC1sZWZ0JztcclxuICAgIGFuY2hvck9mZnNldCA9IFswLCAwLjVdO1xyXG4gIH1cclxuICBpZiAoaWNvbkFuY2hvciA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgaWNvbkFuY2hvciA9ICd0b3AtbGVmdCc7XHJcbiAgICBhbmNob3JPZmZzZXQgPSBbMSwgMC41XTtcclxuICB9XHJcbiAgaWYgKGljb25BbmNob3IgPT09ICdib3R0b20nKSB7XHJcbiAgICBpY29uQW5jaG9yID0gJ3RvcC1sZWZ0JztcclxuICAgIGFuY2hvck9mZnNldCA9IFswLjUsIDFdO1xyXG4gIH1cclxuICBpZiAoaWNvbkFuY2hvciA9PT0gJ3RvcCcpIHtcclxuICAgIGljb25BbmNob3IgPSAndG9wLWxlZnQnO1xyXG4gICAgYW5jaG9yT2Zmc2V0ID0gWzAuNSwgMF07XHJcbiAgfVxyXG4gIC8vY2VudGVyXHJcbiAgcmV0dXJuIHtcclxuICAgIGFuY2hvck9mZnNldDogYW5jaG9yT2Zmc2V0LFxyXG4gICAgaWNvbkFuY2hvcjogaWNvbkFuY2hvclxyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IGZvbnRNYXAgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGNob29zZUZvbnQoZm9udHMsIGF2YWlsYWJsZUZvbnRzKSB7XHJcbiAgaWYgKGZvbnRNYXBbZm9udHNdKSB7XHJcbiAgICByZXR1cm4gZm9udE1hcFtmb250c107XHJcbiAgfVxyXG4gIGlmIChhdmFpbGFibGVGb250cykge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZm9udHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICBjb25zdCBmb250ID0gZm9udHNbaV07XHJcbiAgICAgIGlmIChhdmFpbGFibGVGb250cy5pbmRleE9mKGZvbnQpICE9IC0xKSB7XHJcbiAgICAgICAgZm9udE1hcFtmb250c10gPSBmb250O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWZvbnRNYXBbZm9udHNdKSB7XHJcbiAgICAgIC8vIGZhbGxiYWNrIGZvbnRcclxuICAgICAgZm9udE1hcFtmb250c10gPSBmb250c1tmb250cy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgZm9udE1hcFtmb250c10gPSBmb250c1swXTtcclxuICB9XHJcbiAgcmV0dXJuIGZvbnRNYXBbZm9udHNdO1xyXG59XHJcblxyXG5jb25zdCBmaWx0ZXJDYWNoZSA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZXZhbHVhdGVGaWx0ZXIobGF5ZXJJZCwgZmlsdGVyLCBmZWF0dXJlLCB6b29tKSB7XHJcbiAgaWYgKCEobGF5ZXJJZCBpbiBmaWx0ZXJDYWNoZSkpIHtcclxuICAgIGZpbHRlckNhY2hlW2xheWVySWRdID0gY3JlYXRlRmlsdGVyKGZpbHRlcikuZmlsdGVyO1xyXG4gIH1cclxuICB6b29tT2JqLnpvb20gPSB6b29tO1xyXG4gIHJldHVybiBmaWx0ZXJDYWNoZVtsYXllcklkXSh6b29tT2JqLCBmZWF0dXJlKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbG9yV2l0aE9wYWNpdHkoY29sb3IsIG9wYWNpdHkpIHtcclxuICBpZiAoY29sb3IpIHtcclxuICAgIGlmIChjb2xvci5hID09PSAwIHx8IG9wYWNpdHkgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IGEgPSBjb2xvci5hO1xyXG4gICAgb3BhY2l0eSA9IG9wYWNpdHkgPT09IHVuZGVmaW5lZCA/IDEgOiBvcGFjaXR5O1xyXG4gICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKGNvbG9yLnIgKiAyNTUgLyBhKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuZyAqIDI1NSAvIGEpICtcclxuICAgICAgJywnICsgTWF0aC5yb3VuZChjb2xvci5iICogMjU1IC8gYSkgKyAnLCcgKyAoYSAqIG9wYWNpdHkpICsgJyknO1xyXG4gIH1cclxuICByZXR1cm4gY29sb3I7XHJcbn1cclxuXHJcbmNvbnN0IHRlbXBsYXRlUmVnRXggPSAvXihbXl0qKVxceyguKilcXH0oW15dKikkLztcclxuXHJcbmZ1bmN0aW9uIGZyb21UZW1wbGF0ZSh0ZXh0LCBwcm9wZXJ0aWVzKSB7XHJcbiAgbGV0IHBhcnRzO1xyXG4gIGRvIHtcclxuICAgIHBhcnRzID0gdGV4dC5tYXRjaCh0ZW1wbGF0ZVJlZ0V4KTtcclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbcGFydHNbMl1dIHx8ICcnO1xyXG4gICAgICB0ZXh0ID0gcGFydHNbMV0gKyB2YWx1ZSArIHBhcnRzWzNdO1xyXG4gICAgfVxyXG4gIH0gd2hpbGUgKHBhcnRzKTtcclxuICByZXR1cm4gdGV4dDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzdHlsZSBmdW5jdGlvbiBmcm9tIHRoZSBgZ2xTdHlsZWAgb2JqZWN0IGZvciBhbGwgbGF5ZXJzIHRoYXQgdXNlXHJcbiAqIHRoZSBzcGVjaWZpZWQgYHNvdXJjZWAsIHdoaWNoIG5lZWRzIHRvIGJlIGEgYFwidHlwZVwiOiBcInZlY3RvclwiYCBvclxyXG4gKiBgXCJ0eXBlXCI6IFwiZ2VvanNvblwiYCBzb3VyY2UgYW5kIGFwcGxpZXMgaXQgdG8gdGhlIHNwZWNpZmllZCBPcGVuTGF5ZXJzIGxheWVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29sLmxheWVyLlZlY3RvcnxvbC5sYXllci5WZWN0b3JUaWxlfSBvbExheWVyIE9wZW5MYXllcnMgbGF5ZXIgdG9cclxuICogYXBwbHkgdGhlIHN0eWxlIHRvLiBJbiBhZGRpdGlvbiB0byB0aGUgc3R5bGUsIHRoZSBsYXllciB3aWxsIGdldCB0d29cclxuICogcHJvcGVydGllczogYG1hcGJveC1zb3VyY2VgIHdpbGwgYmUgdGhlIGBpZGAgb2YgdGhlIGBnbFN0eWxlYCdzIHNvdXJjZSB1c2VkXHJcbiAqIGZvciB0aGUgbGF5ZXIsIGFuZCBgbWFwYm94LWxheWVyc2Agd2lsbCBiZSBhbiBhcnJheSBvZiB0aGUgYGlkYHMgb2YgdGhlXHJcbiAqIGBnbFN0eWxlYCdzIGxheWVycy5cclxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBnbFN0eWxlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHNvdXJjZSBgc291cmNlYCBrZXkgb3IgYW4gYXJyYXkgb2YgbGF5ZXIgYGlkYHNcclxuICogZnJvbSB0aGUgTWFwYm94IFN0eWxlIG9iamVjdC4gV2hlbiBhIGBzb3VyY2VgIGtleSBpcyBwcm92aWRlZCwgYWxsIGxheWVycyBmb3JcclxuICogdGhlIHNwZWNpZmllZCBzb3VyY2Ugd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgc3R5bGUgZnVuY3Rpb24uIFdoZW4gbGF5ZXIgYGlkYHNcclxuICogYXJlIHByb3ZpZGVkLCB0aGV5IG11c3QgYmUgZnJvbSBsYXllcnMgdGhhdCB1c2UgdGhlIHNhbWUgc291cmNlLlxyXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtyZXNvbHV0aW9ucz1bNzgyNzEuNTE2OTY0MDIwNDgsIDM5MTM1Ljc1ODQ4MjAxMDI0LFxyXG4gKiAxOTU2Ny44NzkyNDEwMDUxMiwgOTc4My45Mzk2MjA1MDI1NiwgNDg5MS45Njk4MTAyNTEyOCwgMjQ0NS45ODQ5MDUxMjU2NCxcclxuICogMTIyMi45OTI0NTI1NjI4MiwgNjExLjQ5NjIyNjI4MTQxLCAzMDUuNzQ4MTEzMTQwNzA1LCAxNTIuODc0MDU2NTcwMzUyNSxcclxuICogNzYuNDM3MDI4Mjg1MTc2MjUsIDM4LjIxODUxNDE0MjU4ODEzLCAxOS4xMDkyNTcwNzEyOTQwNjMsIDkuNTU0NjI4NTM1NjQ3MDMyLFxyXG4gKiA0Ljc3NzMxNDI2NzgyMzUxNiwgMi4zODg2NTcxMzM5MTE3NTgsIDEuMTk0MzI4NTY2OTU1ODc5LCAwLjU5NzE2NDI4MzQ3NzkzOTUsXHJcbiAqIDAuMjk4NTgyMTQxNzM4OTY5NzQsIDAuMTQ5MjkxMDcwODY5NDg0ODcsIDAuMDc0NjQ1NTM1NDM0NzQyNDRdXVxyXG4gKiBSZXNvbHV0aW9ucyBmb3IgbWFwcGluZyByZXNvbHV0aW9uIHRvIHpvb20gbGV2ZWwuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3ByaXRlRGF0YT11bmRlZmluZWRdIFNwcml0ZSBkYXRhIGZyb20gdGhlIHVybCBzcGVjaWZpZWQgaW5cclxuICogdGhlIE1hcGJveCBTdHlsZSBvYmplY3QncyBgc3ByaXRlYCBwcm9wZXJ0eS4gT25seSByZXF1aXJlZCBpZiBhIGBzcHJpdGVgXHJcbiAqIHByb3BlcnR5IGlzIHNwZWNpZmllZCBpbiB0aGUgTWFwYm94IFN0eWxlIG9iamVjdC5cclxuICogQHBhcmFtIHtPYmplY3R9IFtzcHJpdGVJbWFnZVVybD11bmRlZmluZWRdIFNwcml0ZSBpbWFnZSB1cmwgZm9yIHRoZSBzcHJpdGVcclxuICogc3BlY2lmaWVkIGluIHRoZSBNYXBib3ggU3R5bGUgb2JqZWN0J3MgYHNwcml0ZWAgcHJvcGVydHkuIE9ubHkgcmVxdWlyZWQgaWYgYVxyXG4gKiBgc3ByaXRlYCBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQgaW4gdGhlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW2ZvbnRzPXVuZGVmaW5lZF0gQXJyYXkgb2YgYXZhaWxhYmxlIGZvbnRzLCB1c2luZyB0aGVcclxuICogc2FtZSBmb250IG5hbWVzIGFzIHRoZSBNYXBib3ggU3R5bGUgb2JqZWN0LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBzdHlsZVxyXG4gKiBmdW5jdGlvbiB3aWxsIGFsd2F5cyB1c2UgdGhlIGZpcnN0IGZvbnQgZnJvbSB0aGUgZm9udCBhcnJheS5cclxuICogQHJldHVybiB7b2wuc3R5bGUuU3R5bGVGdW5jdGlvbn0gU3R5bGUgZnVuY3Rpb24gZm9yIHVzZSBpblxyXG4gKiBgb2wubGF5ZXIuVmVjdG9yYCBvciBgb2wubGF5ZXIuVmVjdG9yVGlsZWAuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvbExheWVyLCBnbFN0eWxlLCBzb3VyY2UsIHJlc29sdXRpb25zLCBzcHJpdGVEYXRhLCBzcHJpdGVJbWFnZVVybCxzcHJpdGVJbWFnZSwgZm9udHMpIHtcclxuICBpZiAoIXJlc29sdXRpb25zKSB7XHJcbiAgICByZXNvbHV0aW9ucyA9IFtdO1xyXG4gICAgZm9yIChsZXQgcmVzID0gNzgyNzEuNTE2OTY0MDIwNDg7IHJlc29sdXRpb25zLmxlbmd0aCA8IDIxOyByZXMgLz0gMikge1xyXG4gICAgICByZXNvbHV0aW9ucy5wdXNoKHJlcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgZ2xTdHlsZSA9PSAnc3RyaW5nJykge1xyXG4gICAgZ2xTdHlsZSA9IEpTT04ucGFyc2UoZ2xTdHlsZSk7XHJcbiAgfVxyXG4gIGlmIChnbFN0eWxlLnZlcnNpb24gIT0gOCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbFN0eWxlIHZlcnNpb24gOCByZXF1aXJlZC4nKTtcclxuICB9XHJcblxyXG4gIGxldCBzcHJpdGVJbWdTaXplO1xyXG4gIGlmIChzcHJpdGVJbWFnZVVybCAmJiAhc3ByaXRlSW1hZ2UpIHtcclxuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHNwcml0ZUltYWdlID0gaW1nO1xyXG4gICAgICBzcHJpdGVJbWdTaXplID0gW2ltZy53aWR0aCwgaW1nLmhlaWdodF07XHJcbiAgICAgIG9sTGF5ZXIuY2hhbmdlZCgpO1xyXG4gICAgfTtcclxuICAgIGltZy5zcmMgPSBzcHJpdGVJbWFnZVVybDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGN0eCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpLmdldENvbnRleHQoJzJkJyk7XHJcbiAgY29uc3QgbWVhc3VyZUNhY2hlID0ge307XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBUZXh0KHRleHQsIGZvbnQsIGVtKSB7XHJcbiAgICBjb25zdCBrZXkgPSBlbSArICcsJyArIGZvbnQgKyAnLCcgKyB0ZXh0O1xyXG4gICAgbGV0IHdyYXBwZWRUZXh0ID0gbWVhc3VyZUNhY2hlW2tleV07XHJcbiAgICBpZiAoIXdyYXBwZWRUZXh0KSB7XHJcbiAgICAgIGN0eC5mb250ID0gZm9udDtcclxuICAgICAgY29uc3Qgb25lRW0gPSBjdHgubWVhc3VyZVRleHQoJ00nKS53aWR0aDtcclxuICAgICAgY29uc3Qgd2lkdGggPSBvbmVFbSAqIGVtO1xyXG4gICAgICBjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQoJyAnKTtcclxuICAgICAgbGV0IGxpbmUgPSAnJztcclxuICAgICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gd29yZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHdvcmQgPSB3b3Jkc1tpXTtcclxuICAgICAgICBpZiAoKGN0eC5tZWFzdXJlVGV4dChsaW5lICsgd29yZCkud2lkdGggPD0gd2lkdGgpKSB7XHJcbiAgICAgICAgICBsaW5lICs9IChsaW5lID8gJyAnIDogJycpICsgd29yZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKGxpbmUpIHtcclxuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxpbmUgPSB3b3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobGluZSkge1xyXG4gICAgICAgIGxpbmVzLnB1c2gobGluZSk7XHJcbiAgICAgIH1cclxuICAgICAgbWVhc3VyZUNhY2hlW2tleV0gPSB3cmFwcGVkVGV4dCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdyYXBwZWRUZXh0O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYWxsTGF5ZXJzID0gZGVyZWZMYXllcnMoZ2xTdHlsZS5sYXllcnMpO1xyXG5cclxuICBjb25zdCBsYXllcnNCeVNvdXJjZUxheWVyID0ge307XHJcbiAgY29uc3QgbWFwYm94TGF5ZXJzID0gW107XHJcbiAgbGV0IG1hcGJveFNvdXJjZTtcclxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhbGxMYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSBhbGxMYXllcnNbaV07XHJcbiAgICBjb25zdCBsYXllcklkID0gbGF5ZXIuaWQ7XHJcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PSAnc3RyaW5nJyAmJiBsYXllci5zb3VyY2UgPT0gc291cmNlIHx8XHJcbiAgICAgIHNvdXJjZS5pbmRleE9mKGxheWVySWQpICE9PSAtMSkge1xyXG4gICAgICBjb25zdCBzb3VyY2VMYXllciA9IGxheWVyWydzb3VyY2UtbGF5ZXInXTtcclxuICAgICAgaWYgKCFtYXBib3hTb3VyY2UpIHtcclxuICAgICAgICBtYXBib3hTb3VyY2UgPSBsYXllci5zb3VyY2U7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGxheWVycyA9IGxheWVyc0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJdO1xyXG4gICAgICBpZiAoIWxheWVycykge1xyXG4gICAgICAgIGxheWVycyA9IGxheWVyc0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJdID0gW107XHJcbiAgICAgIH1cclxuICAgICAgbGF5ZXJzLnB1c2goe1xyXG4gICAgICAgIGxheWVyOiBsYXllcixcclxuICAgICAgICBpbmRleDogaVxyXG4gICAgICB9KTtcclxuICAgICAgbWFwYm94TGF5ZXJzLnB1c2gobGF5ZXJJZCk7XHJcbiAgICB9XHJcbiAgICAvLyAvLyBUT0RPIHJldmlzaXQgd2hlbiBkaWZmaW5nIGdldHMgYWRkZWRcclxuICAgIGRlbGV0ZSBmdW5jdGlvbkNhY2hlW2xheWVySWRdO1xyXG4gICAgZGVsZXRlIGZpbHRlckNhY2hlW2xheWVySWRdO1xyXG4gIH1cclxuICBjb25zdCBpY29uSW1hZ2VDYWNoZSA9IHt9O1xyXG5cclxuICBjb25zdCBzdHlsZXMgPSBbXTtcclxuICBjb25zdCBwYXR0ZXJuQ2FjaGUgPSB7fTtcclxuXHJcbiAgY29uc3Qgc3R5bGVGdW5jdGlvbiA9IGZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcclxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBmZWF0dXJlLmdldFByb3BlcnRpZXMoKTtcclxuICAgIGZlYXR1cmUuc3R5bGVJZHMgPSBmZWF0dXJlLnN0eWxlSWRzIHx8IHt9O1xyXG4gICAgY29uc3QgbGF5ZXJzID0gbGF5ZXJzQnlTb3VyY2VMYXllcltwcm9wZXJ0aWVzLmxheWVyXTtcclxuICAgIGlmICghbGF5ZXJzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCB6b29tID0gcmVzb2x1dGlvbnMuaW5kZXhPZihyZXNvbHV0aW9uKTtcclxuICAgIGlmICh6b29tID09IC0xKSB7XHJcbiAgICAgIHpvb20gPSBNYXRoLnJvdW5kKGdldFpvb21Gb3JSZXNvbHV0aW9uKHJlc29sdXRpb24sIHJlc29sdXRpb25zKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0eXBlID0gdHlwZXNbZmVhdHVyZS5nZXRHZW9tZXRyeSgpLmdldFR5cGUoKV07XHJcbiAgICBjb25zdCBmID0ge1xyXG4gICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxyXG4gICAgICB0eXBlOiB0eXBlXHJcbiAgICB9O1xyXG4gICAgbGV0IHN0eWxlc0xlbmd0aCA9IC0xO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgY29uc3QgbGF5ZXJEYXRhID0gbGF5ZXJzW2ldO1xyXG4gICAgICBjb25zdCBsYXllciA9IGxheWVyRGF0YS5sYXllcjtcclxuICAgICAgY29uc3QgbGF5ZXJJZCA9IGxheWVyLmlkO1xyXG5cclxuICAgICAgY29uc3QgbGF5b3V0ID0gbGF5ZXIubGF5b3V0IHx8IGVtcHR5T2JqO1xyXG4gICAgICBjb25zdCBwYWludCA9IGxheWVyLnBhaW50IHx8IGVtcHR5T2JqO1xyXG4gICAgICBpZiAobGF5b3V0LnZpc2liaWxpdHkgPT09ICdub25lJyB8fCAoJ21pbnpvb20nIGluIGxheWVyICYmIHpvb20gPCBsYXllci5taW56b29tKSB8fFxyXG4gICAgICAgICgnbWF4em9vbScgaW4gbGF5ZXIgJiYgem9vbSA+PSBsYXllci5tYXh6b29tKSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0gPSBmZWF0dXJlLnN0eWxlSWRzW3pvb21dIHx8IFtdO1xyXG4gICAgICBjb25zdCBmaWx0ZXIgPSBsYXllci5maWx0ZXI7XHJcbiAgICAgIGxldCBpY29uLCBpY29uSW1nO1xyXG4gICAgICBpZiAoIWZpbHRlciB8fCBldmFsdWF0ZUZpbHRlcihsYXllcklkLCBmaWx0ZXIsIGYsIHpvb20pKSB7XHJcbiAgICAgICAgbGV0IGNvbG9yLCBvcGFjaXR5LCBmaWxsLCBzdHJva2UsIHN0cm9rZUNvbG9yLCBzdHlsZTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGxheWVyRGF0YS5pbmRleDtcclxuICAgICAgICBpZiAodHlwZSA9PSAzICYmIGxheWVyLnR5cGUgPT0gJ2ZpbGwnKSB7XHJcbiAgICAgICAgICBvcGFjaXR5ID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdmaWxsLW9wYWNpdHknLCB6b29tLCBmKTtcclxuICAgICAgICAgIGlmICgnZmlsbC1wYXR0ZXJuJyBpbiBwYWludCkge1xyXG4gICAgICAgICAgICBjb25zdCBpY29uSW1hZ2UgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ZpbGwtcGF0dGVybicsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICBpZiAoaWNvbkltYWdlKSB7XHJcbiAgICAgICAgICAgICAgaWNvbiA9IHR5cGVvZiBpY29uSW1hZ2UgPT09ICdzdHJpbmcnID8gZnJvbVRlbXBsYXRlKGljb25JbWFnZSwgcHJvcGVydGllcykgOiBpY29uSW1hZ2UudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICBpZiAoc3ByaXRlSW1hZ2UgJiYgc3ByaXRlRGF0YSAmJiBzcHJpdGVEYXRhW2ljb25dKSB7XHJcbiAgICAgICAgICAgICAgICArK3N0eWxlc0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0ucHVzaChsYXllcklkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlIHx8ICFzdHlsZS5nZXRGaWxsKCkgfHwgc3R5bGUuZ2V0U3Ryb2tlKCkgfHwgc3R5bGUuZ2V0VGV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF0gPSBuZXcgU3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG5ldyBGaWxsKClcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWxsID0gc3R5bGUuZ2V0RmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0WkluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25fY2FjaGVfa2V5ID0gaWNvbiArICcuJyArIG9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IHBhdHRlcm5DYWNoZVtpY29uX2NhY2hlX2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgc3ByaXRlSW1hZ2VEYXRhID0gc3ByaXRlRGF0YVtpY29uXTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHNwcml0ZUltYWdlRGF0YS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHNwcml0ZUltYWdlRGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS54LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS55LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4oY2FudmFzLCAncmVwZWF0Jyk7XHJcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm5DYWNoZVtpY29uX2NhY2hlX2tleV0gPSBwYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmlsbC5zZXRDb2xvcihwYXR0ZXJuKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoJ2ZpbGwtY29sb3InIGluIHBhaW50KSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gY29sb3JXaXRoT3BhY2l0eShnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ZpbGwtY29sb3InLCB6b29tLCBmKSwgb3BhY2l0eSk7XHJcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpIHx8IHN0eWxlLmdldFRleHQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgIGZpbGw6IG5ldyBGaWxsKClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBmaWxsID0gc3R5bGUuZ2V0RmlsbCgpO1xyXG4gICAgICAgICAgICAgIGZpbGwuc2V0Q29sb3IoY29sb3IpO1xyXG4gICAgICAgICAgICAgIHN0eWxlLnNldFpJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCdmaWxsLW91dGxpbmUtY29sb3InIGluIHBhaW50KSB7XHJcbiAgICAgICAgICAgICAgc3Ryb2tlQ29sb3IgPSBjb2xvcldpdGhPcGFjaXR5KGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnZmlsbC1vdXRsaW5lLWNvbG9yJywgem9vbSwgcHJvcGVydGllcyksIG9wYWNpdHkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdmaWxsLWFudGlhbGlhcycgaW4gcGFpbnQpIHtcclxuICAgICAgICAgICAgICBzdHJva2VDb2xvciA9IGNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdHJva2VDb2xvcikge1xyXG4gICAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0U3Ryb2tlKCkgfHwgc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFRleHQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSgpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgc3Ryb2tlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgc3Ryb2tlLnNldENvbG9yKHN0cm9rZUNvbG9yKTtcclxuICAgICAgICAgICAgICBzdHJva2Uuc2V0V2lkdGgoMSk7XHJcbiAgICAgICAgICAgICAgc3R5bGUuc2V0WkluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSAhPSAxICYmIGxheWVyLnR5cGUgPT0gJ2xpbmUnKSB7XHJcbiAgICAgICAgICBjb2xvciA9ICEoJ2xpbmUtcGF0dGVybicgaW4gcGFpbnQpICYmICdsaW5lLWNvbG9yJyBpbiBwYWludCA/XHJcbiAgICAgICAgICAgIGNvbG9yV2l0aE9wYWNpdHkoZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdsaW5lLWNvbG9yJywgem9vbSwgZiksIGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnbGluZS1vcGFjaXR5Jywgem9vbSwgZikpIDpcclxuICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2xpbmUtd2lkdGgnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGlmIChjb2xvciAmJiB3aWR0aCA+IDApIHtcclxuICAgICAgICAgICAgKytzdHlsZXNMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5wdXNoKGxheWVySWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLmdldFN0cm9rZSgpIHx8IHN0eWxlLmdldEZpbGwoKSB8fCBzdHlsZS5nZXRUZXh0KCkpIHtcclxuICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdID0gbmV3IFN0eWxlKHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSgpXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3Ryb2tlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIHN0cm9rZS5zZXRMaW5lQ2FwKGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ2xpbmUtY2FwJywgem9vbSwgZikpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0TGluZUpvaW4oZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnbGluZS1qb2luJywgem9vbSwgZikpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0TWl0ZXJMaW1pdChnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdsaW5lLW1pdGVyLWxpbWl0Jywgem9vbSwgZikpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0Q29sb3IoY29sb3IpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0V2lkdGgod2lkdGgpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0TGluZURhc2gocGFpbnRbJ2xpbmUtZGFzaGFycmF5J10gP1xyXG4gICAgICAgICAgICAgIGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnbGluZS1kYXNoYXJyYXknLCB6b29tLCBmKS5tYXAoZnVuY3Rpb24oeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggKiB3aWR0aDtcclxuICAgICAgICAgICAgICB9KSA6IG51bGwpO1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRaSW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGhhc0ltYWdlID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHRleHQgPSBudWxsO1xyXG4gICAgICAgIGxldCBza2lwTGFiZWw7XHJcbiAgICAgICAgaWYgKCh0eXBlID09IDEgfHwgdHlwZSA9PSAyKSAmJiAnaWNvbi1pbWFnZScgaW4gbGF5b3V0KSB7XHJcbiAgICAgICAgICBjb25zdCBpY29uSW1hZ2UgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdpY29uLWltYWdlJywgem9vbSwgZik7XHJcbiAgICAgICAgICBpZiAoaWNvbkltYWdlKSB7XHJcbiAgICAgICAgICAgIGljb24gPSB0eXBlb2YgaWNvbkltYWdlID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgID8gZnJvbVRlbXBsYXRlKGljb25JbWFnZSwgcHJvcGVydGllcylcclxuICAgICAgICAgICAgICA6IGljb25JbWFnZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBsZXQgc3R5bGVHZW9tID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoc3ByaXRlSW1hZ2UgJiYgc3ByaXRlRGF0YSAmJiBzcHJpdGVEYXRhW2ljb25dKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gMikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcclxuICAgICAgICAgICAgICAgIC8vIG9sIHBhY2thZ2UgYW5kIG9sLWRlYnVnLmpzIG9ubHlcclxuICAgICAgICAgICAgICAgIGlmIChnZW9tLmdldEZsYXRNaWRwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSBnZW9tLmdldEV4dGVudCgpO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5zcXJ0KE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KChleHRlbnRbMl0gLSBleHRlbnRbMF0pIC8gcmVzb2x1dGlvbiwgMiksXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyByZXNvbHV0aW9uLCAyKSkpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDE1MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRklYTUUgRG8gbm90IGhhcmQtY29kZSBhIHNpemUgb2YgMTUwXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVHZW9tID0gbmV3IFBvaW50KGdlb20uZ2V0RmxhdE1pZHBvaW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICh0eXBlICE9PSAyIHx8IHN0eWxlR2VvbSkge1xyXG4gICAgICAgICAgICAgICAgKytzdHlsZXNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5pbmRleE9mKGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0SW1hZ2UoKSB8fCBzdHlsZS5nZXRGaWxsKCkgfHwgc3R5bGUuZ2V0U3Ryb2tlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0R2VvbWV0cnkoc3R5bGVHZW9tKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25TaXplID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnaWNvbi1zaXplJywgem9vbSwgZik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uQ29sb3IgPSBwYWludFsnaWNvbi1jb2xvciddICE9PSB1bmRlZmluZWQgPyBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ljb24tY29sb3InLCB6b29tLCBmKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uVHJhbnNsYXRlID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdpY29uLXRyYW5zbGF0ZScsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvblRyYW5zbGF0ZUFuY2hvciA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnaWNvbi10cmFuc2xhdGUtYW5jaG9yJywgem9vbSwgZik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uQW5jaG9yVmFsdWUgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdpY29uLWFuY2hvcicsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbk9mZnNldCA9IGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ2ljb24tb2Zmc2V0Jywgem9vbSwgZik7XHJcbiAgICAgICAgICAgICAgICBsZXQge1xyXG4gICAgICAgICAgICAgICAgICBhbmNob3JPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgIGljb25BbmNob3IgPSBpY29uQW5jaG9yVmFsdWVcclxuICAgICAgICAgICAgICAgIH0gPSBjb3ZlcnRJY29uQW5jaG9yKGljb25BbmNob3JWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaWNvbl9jYWNoZV9rZXkgPSBpY29uICsgJy4nICsgaWNvblNpemUgKyAnLicgKyBpY29uVHJhbnNsYXRlICsgJy4nICsgaWNvblRyYW5zbGF0ZUFuY2hvciArICcuJyArIGljb25BbmNob3IgKyAnLicgKyBpY29uT2Zmc2V0ICsgJy4nICsgYW5jaG9yT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGljb25Db2xvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICBpY29uX2NhY2hlX2tleSArPSAnLicgKyBpY29uQ29sb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpY29uSW1nID0gaWNvbkltYWdlQ2FjaGVbaWNvbl9jYWNoZV9rZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpY29uSW1nKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNwcml0ZUltYWdlRGF0YSA9IHNwcml0ZURhdGFbaWNvbl07XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBzcHJpdGVJbWFnZURhdGEud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzcHJpdGVJbWFnZURhdGEuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZSxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEueCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEueSxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGljb25Db2xvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1dCBvdXQgdGhlIHNwcml0ZSBhbmQgY29sb3IgaXRcclxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yV2l0aE9wYWNpdHkoaWNvbkNvbG9yLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gMCwgY2MgPSBkYXRhLmRhdGEubGVuZ3RoOyBjIDwgY2M7IGMgKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhW2NdID0gY29sb3JbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGFbYyArIDFdID0gY29sb3JbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGFbYyArIDJdID0gY29sb3JbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZU9mZnNldCA9IFtpY29uVHJhbnNsYXRlWzBdIC8gc3ByaXRlSW1hZ2VEYXRhLndpZHRoLCBpY29uVHJhbnNsYXRlWzFdIC8gc3ByaXRlSW1hZ2VEYXRhLmhlaWdodF07XHJcbiAgICAgICAgICAgICAgICAgIGljb25JbWcgPSBpY29uSW1hZ2VDYWNoZVtpY29uX2NhY2hlX2tleV0gPSBuZXcgSWNvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nOiBjYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yT3JpZ2luOiBpY29uQW5jaG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcjogW2ljb25PZmZzZXRbMF0gKyBhbmNob3JPZmZzZXRbMF0gKyB0cmFuc2xhdGVPZmZzZXRbMF0sIGljb25PZmZzZXRbMV0gKyBhbmNob3JPZmZzZXRbMV0gLSB0cmFuc2xhdGVPZmZzZXRbMV1dLFxyXG4gICAgICAgICAgICAgICAgICAgIGltZ1NpemU6IFtjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBpY29uU2l6ZSAvIHNwcml0ZUltYWdlRGF0YS5waXhlbFJhdGlvXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJvdGF0ZVZhbHVlID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnaWNvbi1yb3RhdGUnLCB6b29tLCBmKTtcclxuICAgICAgICAgICAgICAgIGlmIChyb3RhdGVWYWx1ZS5pbmRleE9mICYmIHJvdGF0ZVZhbHVlLmluZGV4T2YoJ3snKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICByb3RhdGVWYWx1ZSA9IDM2MCAtIGZyb21UZW1wbGF0ZShyb3RhdGVWYWx1ZSwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpY29uSW1nLnNldFJvdGF0aW9uKGRlZzJyYWQocm90YXRlVmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIGljb25JbWcuc2V0T3BhY2l0eShnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ljb24tb3BhY2l0eScsIHpvb20sIGYpKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldEltYWdlKGljb25JbWcpO1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHN0eWxlLmdldFRleHQoKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFRleHQodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFpJbmRleCg5OTk5OSAtIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGhhc0ltYWdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHNraXBMYWJlbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBza2lwTGFiZWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gMSAmJiAnY2lyY2xlLXJhZGl1cycgaW4gcGFpbnQpIHtcclxuICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgaWYgKGZlYXR1cmUuc3R5bGVJZHNbem9vbV0uaW5kZXhPZihsYXllcklkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5wdXNoKGxheWVySWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXTtcclxuICAgICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLmdldEltYWdlKCkgfHwgc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpKSB7XHJcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF0gPSBuZXcgU3R5bGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IGNpcmNsZVJhZGl1cyA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnY2lyY2xlLXJhZGl1cycsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgY2lyY2xlU3Ryb2tlQ29sb3IgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2NpcmNsZS1zdHJva2UtY29sb3InLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IGNpcmNsZUNvbG9yID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdjaXJjbGUtY29sb3InLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IGNpcmNsZU9wYWNpdHkgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2NpcmNsZS1vcGFjaXR5Jywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCBjaXJjbGVTdHJva2VXaWR0aCA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnY2lyY2xlLXN0cm9rZS13aWR0aCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgY2lyY2xlU3Ryb2tlT3BhY2l0eSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnY2lyY2xlLXN0cm9rZS1vcGFjaXR5Jywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCBjYWNoZV9rZXkgPSBjaXJjbGVSYWRpdXMgKyAnLicgKyBjaXJjbGVTdHJva2VDb2xvciArICcuJyArXHJcbiAgICAgICAgICAgIGNpcmNsZUNvbG9yICsgJy4nICsgY2lyY2xlT3BhY2l0eSArICcuJyArIGNpcmNsZVN0cm9rZVdpZHRoICsgJy4nICsgY2lyY2xlU3Ryb2tlT3BhY2l0eTtcclxuICAgICAgICAgIGljb25JbWcgPSBpY29uSW1hZ2VDYWNoZVtjYWNoZV9rZXldO1xyXG4gICAgICAgICAgaWYgKCFpY29uSW1nKSB7XHJcbiAgICAgICAgICAgIGljb25JbWcgPSBuZXcgQ2lyY2xlKHtcclxuICAgICAgICAgICAgICByYWRpdXM6IGNpcmNsZVJhZGl1cyxcclxuICAgICAgICAgICAgICBzdHJva2U6IGNpcmNsZVN0cm9rZVdpZHRoID09PSAwID8gdW5kZWZpbmVkIDogbmV3IFN0cm9rZSh7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogY2lyY2xlU3Ryb2tlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JXaXRoT3BhY2l0eShjaXJjbGVTdHJva2VDb2xvciwgY2lyY2xlU3Ryb2tlT3BhY2l0eSlcclxuICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JXaXRoT3BhY2l0eShjaXJjbGVDb2xvciwgY2lyY2xlT3BhY2l0eSlcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0eWxlLnNldEltYWdlKGljb25JbWcpO1xyXG4gICAgICAgICAgdGV4dCA9IHN0eWxlLmdldFRleHQoKTtcclxuICAgICAgICAgIHN0eWxlLnNldFRleHQodW5kZWZpbmVkKTtcclxuICAgICAgICAgIHN0eWxlLnNldEdlb21ldHJ5KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICBzdHlsZS5zZXRaSW5kZXgoOTk5OTkgLSBpbmRleCk7XHJcbiAgICAgICAgICBoYXNJbWFnZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGFiZWw7XHJcbiAgICAgICAgaWYgKCd0ZXh0LWZpZWxkJyBpbiBsYXlvdXQpIHtcclxuICAgICAgICAgIGNvbnN0IHRleHRGaWVsZCA9IGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3RleHQtZmllbGQnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGxhYmVsID0gZnJvbVRlbXBsYXRlKHRleHRGaWVsZCwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYWJlbCAmJiAhc2tpcExhYmVsKSB7XHJcbiAgICAgICAgICBpZiAoIWhhc0ltYWdlKSB7XHJcbiAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5pbmRleE9mKGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0ucHVzaChsYXllcklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdO1xyXG4gICAgICAgICAgICBpZiAoIXN0eWxlIHx8ICFzdHlsZS5nZXRUZXh0KCkgfHwgc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpKSB7XHJcbiAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlLnNldEltYWdlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHN0eWxlLnNldEdlb21ldHJ5KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIXN0eWxlLmdldFRleHQoKSkge1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRUZXh0KHRleHQgfHwgbmV3IFRleHQoKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0ZXh0ID0gc3R5bGUuZ2V0VGV4dCgpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dFNpemUgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LXNpemUnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRMaW5lSGVpZ2h0ID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAndGV4dC1saW5lLWhlaWdodCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgZm9udCA9IG1iMmNzcyhjaG9vc2VGb250KGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3RleHQtZm9udCcsIHpvb20sIGYpKSwgdGV4dFNpemUpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dFRyYW5zZm9ybSA9IGxheW91dFsndGV4dC10cmFuc2Zvcm0nXTtcclxuICAgICAgICAgIGlmICh0ZXh0VHJhbnNmb3JtID09ICd1cHBlcmNhc2UnKSB7XHJcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWwudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xyXG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCB3cmFwcGVkTGFiZWwgPSB0eXBlID09IDIgPyBsYWJlbCA6IHdyYXBUZXh0KGxhYmVsLCBmb250LCBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LW1heC13aWR0aCcsIHpvb20sIGYpKTtcclxuICAgICAgICAgIHRleHQuc2V0VGV4dCh3cmFwcGVkTGFiZWwpO1xyXG4gICAgICAgICAgdGV4dC5zZXRGb250KGZvbnQpO1xyXG4gICAgICAgICAgdGV4dC5zZXRSb3RhdGlvbihkZWcycmFkKGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3RleHQtcm90YXRlJywgem9vbSwgZikpKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRBbmNob3IgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LWFuY2hvcicsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKGhhc0ltYWdlIHx8IHR5cGUgPT0gMSkgPyAncG9pbnQnIDogZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnc3ltYm9sLXBsYWNlbWVudCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgdGV4dC5zZXRQbGFjZW1lbnQocGxhY2VtZW50KTtcclxuICAgICAgICAgIGxldCB0ZXh0SGFsb1dpZHRoID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICd0ZXh0LWhhbG8td2lkdGgnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRPZmZzZXQgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LW9mZnNldCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dFRyYW5zbGF0ZSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC10cmFuc2xhdGUnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGxldCB2T2Zmc2V0ID0gMDtcclxuICAgICAgICAgIGxldCBoT2Zmc2V0ID0gMDtcclxuICAgICAgICAgIGxldCB0ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgIGlmICh0ZXh0QW5jaG9yLmluZGV4T2YoJ2xlZnQnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgICAgICAgICBoT2Zmc2V0ID0gdGV4dEhhbG9XaWR0aDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFuY2hvci5pbmRleE9mKCdyaWdodCcpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xyXG4gICAgICAgICAgICBoT2Zmc2V0ID0gLXRleHRIYWxvV2lkdGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocGxhY2VtZW50ID09ICdwb2ludCcpIHtcclxuICAgICAgICAgICAgdGV4dC5zZXRUZXh0QWxpZ24odGV4dEFsaWduKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHQuc2V0TWF4QW5nbGUoZGVnMnJhZChnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LW1heC1hbmdsZScsIHpvb20sIGYpKSAqIGxhYmVsLmxlbmd0aCAvIHdyYXBwZWRMYWJlbC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB0ZXh0LnNldFRleHRBbGlnbigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgaWYgKHRleHRBbmNob3IuaW5kZXhPZignYm90dG9tJykgPT0gMCkge1xyXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcclxuICAgICAgICAgICAgdk9mZnNldCA9IC10ZXh0SGFsb1dpZHRoIC0gKDAuNSAqICh0ZXh0TGluZUhlaWdodCAtIDEpKSAqIHRleHRTaXplO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0ZXh0QW5jaG9yLmluZGV4T2YoJ3RvcCcpID09IDApIHtcclxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XHJcbiAgICAgICAgICAgIHZPZmZzZXQgPSB0ZXh0SGFsb1dpZHRoICsgKDAuNSAqICh0ZXh0TGluZUhlaWdodCAtIDEpKSAqIHRleHRTaXplO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGV4dC5zZXRUZXh0QmFzZWxpbmUodGV4dEJhc2VsaW5lKTtcclxuICAgICAgICAgIHRleHQuc2V0T2Zmc2V0WCh0ZXh0T2Zmc2V0WzBdICogdGV4dFNpemUgKyBoT2Zmc2V0ICsgdGV4dFRyYW5zbGF0ZVswXSk7XHJcbiAgICAgICAgICB0ZXh0LnNldE9mZnNldFkodGV4dE9mZnNldFsxXSAqIHRleHRTaXplICsgdk9mZnNldCArIHRleHRUcmFuc2xhdGVbMV0pO1xyXG4gICAgICAgICAgb3BhY2l0eSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC1vcGFjaXR5Jywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0Q29sb3IgPSBuZXcgRmlsbCgpO1xyXG5cclxuICAgICAgICAgIHRleHRDb2xvci5zZXRDb2xvcihjb2xvcldpdGhPcGFjaXR5KGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC1jb2xvcicsIHpvb20sIGYpLCBvcGFjaXR5KSk7XHJcbiAgICAgICAgICB0ZXh0LnNldEZpbGwodGV4dENvbG9yKTtcclxuICAgICAgICAgIGNvbnN0IGhhbG9Db2xvciA9IGNvbG9yV2l0aE9wYWNpdHkoZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICd0ZXh0LWhhbG8tY29sb3InLCB6b29tLCBmKSwgb3BhY2l0eSk7XHJcbiAgICAgICAgICBpZiAoaGFsb0NvbG9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRIYWxvID0gbmV3IFN0cm9rZSgpO1xyXG4gICAgICAgICAgICB0ZXh0SGFsby5zZXRDb2xvcihoYWxvQ29sb3IpO1xyXG4gICAgICAgICAgICB0ZXh0SGFsby5zZXRXaWR0aChnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ3RleHQtaGFsby13aWR0aCcsIHpvb20sIGYpKTtcclxuICAgICAgICAgICAgdGV4dC5zZXRTdHJva2UodGV4dEhhbG8pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dC5zZXRTdHJva2UodW5kZWZpbmVkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0eWxlLnNldFpJbmRleCg5OTk5OSAtIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3R5bGVzTGVuZ3RoID4gLTEpIHtcclxuICAgICAgc3R5bGVzLmxlbmd0aCA9IHN0eWxlc0xlbmd0aCArIDE7XHJcbiAgICAgIHJldHVybiBzdHlsZXM7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgb2xMYXllci5zZXRTdHlsZShzdHlsZUZ1bmN0aW9uKTtcclxuICBvbExheWVyLnNldCgnbWFwYm94LXNvdXJjZScsIG1hcGJveFNvdXJjZSk7XHJcbiAgb2xMYXllci5zZXQoJ21hcGJveC1sYXllcnMnLCBtYXBib3hMYXllcnMpO1xyXG4gIHJldHVybiBzdHlsZUZ1bmN0aW9uO1xyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiBkZWcycmFkKGRlZ3JlZXMpIHtcclxuICByZXR1cm4gZGVncmVlcyAqIE1hdGguUEkgLyAxODA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRab29tRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uLCByZXNvbHV0aW9ucykge1xyXG4gIGxldCBpID0gMDtcclxuICBjb25zdCBpaSA9IHJlc29sdXRpb25zLmxlbmd0aDtcclxuICBmb3IgKDsgaSA8IGlpOyArK2kpIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHJlc29sdXRpb25zW2ldO1xyXG4gICAgaWYgKGNhbmRpZGF0ZSA8IHJlc29sdXRpb24gJiYgaSArIDEgPCBpaSkge1xyXG4gICAgICBjb25zdCB6b29tRmFjdG9yID0gcmVzb2x1dGlvbnNbaV0gLyByZXNvbHV0aW9uc1tpICsgMV07XHJcbiAgICAgIHJldHVybiBpICsgTWF0aC5sb2cocmVzb2x1dGlvbnNbaV0gLyByZXNvbHV0aW9uKSAvIE1hdGgubG9nKHpvb21GYWN0b3IpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gaWkgLSAxO1xyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9NYXBfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfT2JzZXJ2YWJsZV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9mb3JtYXRfR2VvSlNPTl9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9mb3JtYXRfTVZUX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX2dlb21fUG9pbnRfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfbGF5ZXJfVGlsZV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9sYXllcl9WZWN0b3JfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfbGF5ZXJfVmVjdG9yVGlsZV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9wcm9qX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3NvdXJjZV9UaWxlSlNPTl9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zb3VyY2VfVmVjdG9yX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3NvdXJjZV9WZWN0b3JUaWxlX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3N0eWxlX0NpcmNsZV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zdHlsZV9GaWxsX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3N0eWxlX0ljb25fXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfc3R5bGVfU3Ryb2tlX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3N0eWxlX1N0eWxlX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3N0eWxlX1RleHRfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfdGlsZWdyaWRfXzsiXSwic291cmNlUm9vdCI6IiJ9